[
  {
    "cmd": "delete-by-query",
    "query": {
      "contexts": [
        "package"
      ],
      "query": {
        "op": "case",
        "type": "word",
        "word": "synthesizer"
      },
      "type": "context"
    }
  },
  [
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Sound.Signal.Block",
          "name": "Chunk",
          "package": "synthesizer",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Sound-Signal-Block.html#Chunk",
          "type": "data"
        },
        "index": {
          "hierarchy": "Sound Signal Block",
          "module": "Sound.Signal.Block",
          "name": "Chunk",
          "package": "synthesizer",
          "partial": "Chunk",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Sound-Signal-Block.html#t:Chunk"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Sound.Signal.Block",
          "name": "ChunkSize",
          "package": "synthesizer",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Sound-Signal-Block.html#ChunkSize",
          "type": "type"
        },
        "index": {
          "hierarchy": "Sound Signal Block",
          "module": "Sound.Signal.Block",
          "name": "ChunkSize",
          "package": "synthesizer",
          "partial": "Chunk Size",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Sound-Signal-Block.html#t:ChunkSize"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Sound.Signal.Block",
          "name": "T",
          "package": "synthesizer",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Sound-Signal-Block.html#T",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "Sound Signal Block",
          "module": "Sound.Signal.Block",
          "name": "T",
          "package": "synthesizer",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Sound-Signal-Block.html#t:T"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Sound.Signal.Block",
          "name": "append",
          "package": "synthesizer",
          "signature": "T a -\u003e T a -\u003e T a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Sound-Signal-Block.html#append",
          "type": "function"
        },
        "index": {
          "hierarchy": "Sound Signal Block",
          "module": "Sound.Signal.Block",
          "name": "append",
          "normalized": "T a-\u003eT a-\u003eT a",
          "package": "synthesizer",
          "signature": "T a-\u003eT a-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Sound-Signal-Block.html#v:append"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Sound.Signal.Block",
          "name": "defaultChunkSize",
          "package": "synthesizer",
          "signature": "ChunkSize",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Sound-Signal-Block.html#defaultChunkSize",
          "type": "function"
        },
        "index": {
          "hierarchy": "Sound Signal Block",
          "module": "Sound.Signal.Block",
          "name": "defaultChunkSize",
          "package": "synthesizer",
          "partial": "Chunk Size",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Sound-Signal-Block.html#v:defaultChunkSize"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Sound.Signal.Block",
          "name": "fromList",
          "package": "synthesizer",
          "signature": "ChunkSize -\u003e [a] -\u003e T a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Sound-Signal-Block.html#fromList",
          "type": "function"
        },
        "index": {
          "hierarchy": "Sound Signal Block",
          "module": "Sound.Signal.Block",
          "name": "fromList",
          "normalized": "ChunkSize-\u003e[a]-\u003eT a",
          "package": "synthesizer",
          "partial": "List",
          "signature": "ChunkSize-\u003e[a]-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Sound-Signal-Block.html#v:fromList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Sound.Signal.Block",
          "name": "head",
          "package": "synthesizer",
          "signature": "T a -\u003e a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Sound-Signal-Block.html#head",
          "type": "function"
        },
        "index": {
          "hierarchy": "Sound Signal Block",
          "module": "Sound.Signal.Block",
          "name": "head",
          "normalized": "T a-\u003ea",
          "package": "synthesizer",
          "signature": "T a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Sound-Signal-Block.html#v:head"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Sound.Signal.Block",
          "name": "isEmpty",
          "package": "synthesizer",
          "signature": "T a -\u003e Bool",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Sound-Signal-Block.html#isEmpty",
          "type": "function"
        },
        "index": {
          "hierarchy": "Sound Signal Block",
          "module": "Sound.Signal.Block",
          "name": "isEmpty",
          "normalized": "T a-\u003eBool",
          "package": "synthesizer",
          "partial": "Empty",
          "signature": "T a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Sound-Signal-Block.html#v:isEmpty"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Sound.Signal.Block",
          "name": "mapAccumL",
          "package": "synthesizer",
          "signature": "ChunkSize -\u003e (x -\u003e acc -\u003e Maybe (y, acc)) -\u003e acc -\u003e T x -\u003e (acc, T y)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Sound-Signal-Block.html#mapAccumL",
          "type": "function"
        },
        "index": {
          "hierarchy": "Sound Signal Block",
          "module": "Sound.Signal.Block",
          "name": "mapAccumL",
          "normalized": "ChunkSize-\u003e(a-\u003eb-\u003eMaybe(c,b))-\u003eb-\u003eT a-\u003e(b,T c)",
          "package": "synthesizer",
          "partial": "Accum",
          "signature": "ChunkSize-\u003e(x-\u003eacc-\u003eMaybe(y,acc))-\u003eacc-\u003eT x-\u003e(acc,T y)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Sound-Signal-Block.html#v:mapAccumL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Sound.Signal.Block",
          "name": "minLength",
          "package": "synthesizer",
          "signature": "Int -\u003e [a] -\u003e Int",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Sound-Signal-Block.html#minLength",
          "type": "function"
        },
        "index": {
          "hierarchy": "Sound Signal Block",
          "module": "Sound.Signal.Block",
          "name": "minLength",
          "normalized": "Int-\u003e[a]-\u003eInt",
          "package": "synthesizer",
          "partial": "Length",
          "signature": "Int-\u003e[a]-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Sound-Signal-Block.html#v:minLength"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Sound.Signal.Block",
          "name": "reduceL",
          "package": "synthesizer",
          "signature": "(a -\u003e acc -\u003e Maybe acc) -\u003e acc -\u003e T a -\u003e acc",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Sound-Signal-Block.html#reduceL",
          "type": "function"
        },
        "index": {
          "hierarchy": "Sound Signal Block",
          "module": "Sound.Signal.Block",
          "name": "reduceL",
          "normalized": "(a-\u003eb-\u003eMaybe b)-\u003eb-\u003eT a-\u003eb",
          "package": "synthesizer",
          "signature": "(a-\u003eacc-\u003eMaybe acc)-\u003eacc-\u003eT a-\u003eacc",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Sound-Signal-Block.html#v:reduceL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Sound.Signal.Block",
          "name": "singleton",
          "package": "synthesizer",
          "signature": "a -\u003e T a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Sound-Signal-Block.html#singleton",
          "type": "function"
        },
        "index": {
          "hierarchy": "Sound Signal Block",
          "module": "Sound.Signal.Block",
          "name": "singleton",
          "normalized": "a-\u003eT a",
          "package": "synthesizer",
          "signature": "a-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Sound-Signal-Block.html#v:singleton"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Sound.Signal.Block",
          "name": "tail",
          "package": "synthesizer",
          "signature": "T a -\u003e T a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Sound-Signal-Block.html#tail",
          "type": "function"
        },
        "index": {
          "hierarchy": "Sound Signal Block",
          "module": "Sound.Signal.Block",
          "name": "tail",
          "normalized": "T a-\u003eT a",
          "package": "synthesizer",
          "signature": "T a-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Sound-Signal-Block.html#v:tail"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Sound.Signal.Block",
          "name": "tails",
          "package": "synthesizer",
          "signature": "T a -\u003e [T a]",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Sound-Signal-Block.html#tails",
          "type": "function"
        },
        "index": {
          "hierarchy": "Sound Signal Block",
          "module": "Sound.Signal.Block",
          "name": "tails",
          "normalized": "T a-\u003e[T a]",
          "package": "synthesizer",
          "signature": "T a-\u003e[T a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Sound-Signal-Block.html#v:tails"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Sound.Signal.Block",
          "name": "toList",
          "package": "synthesizer",
          "signature": "T a -\u003e [a]",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Sound-Signal-Block.html#toList",
          "type": "function"
        },
        "index": {
          "hierarchy": "Sound Signal Block",
          "module": "Sound.Signal.Block",
          "name": "toList",
          "normalized": "T a-\u003e[a]",
          "package": "synthesizer",
          "partial": "List",
          "signature": "T a-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Sound-Signal-Block.html#v:toList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Sound.Signal.Block",
          "name": "toListAlt",
          "package": "synthesizer",
          "signature": "T a -\u003e [a]",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Sound-Signal-Block.html#toListAlt",
          "type": "function"
        },
        "index": {
          "hierarchy": "Sound Signal Block",
          "module": "Sound.Signal.Block",
          "name": "toListAlt",
          "normalized": "T a-\u003e[a]",
          "package": "synthesizer",
          "partial": "List Alt",
          "signature": "T a-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Sound-Signal-Block.html#v:toListAlt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Sound.Signal.Block",
          "name": "unfoldR",
          "package": "synthesizer",
          "signature": "ChunkSize -\u003e (acc -\u003e Maybe (y, acc)) -\u003e acc -\u003e (acc, T y)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Sound-Signal-Block.html#unfoldR",
          "type": "function"
        },
        "index": {
          "hierarchy": "Sound Signal Block",
          "module": "Sound.Signal.Block",
          "name": "unfoldR",
          "normalized": "ChunkSize-\u003e(a-\u003eMaybe(b,a))-\u003ea-\u003e(a,T b)",
          "package": "synthesizer",
          "signature": "ChunkSize-\u003e(acc-\u003eMaybe(y,acc))-\u003eacc-\u003e(acc,T y)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Sound-Signal-Block.html#v:unfoldR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Sound.Signal.Block",
          "name": "zipWith",
          "package": "synthesizer",
          "signature": "ChunkSize -\u003e (a -\u003e b -\u003e c) -\u003e T a -\u003e T b -\u003e T c",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Sound-Signal-Block.html#zipWith",
          "type": "function"
        },
        "index": {
          "hierarchy": "Sound Signal Block",
          "module": "Sound.Signal.Block",
          "name": "zipWith",
          "normalized": "ChunkSize-\u003e(a-\u003eb-\u003ec)-\u003eT a-\u003eT b-\u003eT c",
          "package": "synthesizer",
          "partial": "With",
          "signature": "ChunkSize-\u003e(a-\u003eb-\u003ec)-\u003eT a-\u003eT b-\u003eT c",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Sound-Signal-Block.html#v:zipWith"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Sound.Signal.StrictBlock",
          "name": "T",
          "package": "synthesizer",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Sound-Signal-StrictBlock.html#T",
          "type": "data"
        },
        "index": {
          "hierarchy": "Sound Signal StrictBlock",
          "module": "Sound.Signal.StrictBlock",
          "name": "T",
          "package": "synthesizer",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Sound-Signal-StrictBlock.html#t:T"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Sound.Signal.StrictBlock",
          "name": "++",
          "package": "synthesizer",
          "signature": "T a -\u003e T a -\u003e T a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Sound-Signal-StrictBlock.html#%2B%2B",
          "type": "function"
        },
        "index": {
          "hierarchy": "Sound Signal StrictBlock",
          "module": "Sound.Signal.StrictBlock",
          "name": "++",
          "normalized": "T a-\u003eT a-\u003eT a",
          "package": "synthesizer",
          "signature": "T a-\u003eT a-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Sound-Signal-StrictBlock.html#v:++"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Sound.Signal.StrictBlock",
          "name": "foldl'",
          "package": "synthesizer",
          "signature": "(acc -\u003e a -\u003e acc) -\u003e acc -\u003e T a -\u003e acc",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Sound-Signal-StrictBlock.html#foldl%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Sound Signal StrictBlock",
          "module": "Sound.Signal.StrictBlock",
          "name": "foldl'",
          "normalized": "(a-\u003eb-\u003ea)-\u003ea-\u003eT b-\u003ea",
          "package": "synthesizer",
          "signature": "(acc-\u003ea-\u003eacc)-\u003eacc-\u003eT a-\u003eacc",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Sound-Signal-StrictBlock.html#v:foldl'"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Sound.Signal.StrictBlock",
          "name": "singleton",
          "package": "synthesizer",
          "signature": "a -\u003e T a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Sound-Signal-StrictBlock.html#singleton",
          "type": "function"
        },
        "index": {
          "hierarchy": "Sound Signal StrictBlock",
          "module": "Sound.Signal.StrictBlock",
          "name": "singleton",
          "normalized": "a-\u003eT a",
          "package": "synthesizer",
          "signature": "a-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Sound-Signal-StrictBlock.html#v:singleton"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Sound.Signal.StrictBlock",
          "name": "toChunkList",
          "package": "synthesizer",
          "signature": "T a -\u003e [UArray Int a]",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Sound-Signal-StrictBlock.html#toChunkList",
          "type": "function"
        },
        "index": {
          "hierarchy": "Sound Signal StrictBlock",
          "module": "Sound.Signal.StrictBlock",
          "name": "toChunkList",
          "normalized": "T a-\u003e[UArray Int a]",
          "package": "synthesizer",
          "partial": "Chunk List",
          "signature": "T a-\u003e[UArray Int a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Sound-Signal-StrictBlock.html#v:toChunkList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Sound.Signal",
          "name": "++",
          "package": "synthesizer",
          "signature": "s a -\u003e s a -\u003e s a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Sound-Signal.html#%2B%2B",
          "type": "function"
        },
        "index": {
          "hierarchy": "Sound Signal",
          "module": "Sound.Signal",
          "name": "++",
          "normalized": "a b-\u003ea b-\u003ea b",
          "package": "synthesizer",
          "signature": "s a-\u003es a-\u003es a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Sound-Signal.html#v:++"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Sound.Signal",
          "name": "C",
          "package": "synthesizer",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Sound-Signal.html#C",
          "type": "class"
        },
        "index": {
          "hierarchy": "Sound Signal",
          "module": "Sound.Signal",
          "name": "C",
          "package": "synthesizer",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Sound-Signal.html#v:C"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Sound.Signal",
          "name": "crochetL",
          "package": "synthesizer",
          "signature": "(x -\u003e acc -\u003e Maybe (y, acc)) -\u003e acc -\u003e s x -\u003e s y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Sound-Signal.html#crochetL",
          "type": "function"
        },
        "index": {
          "hierarchy": "Sound Signal",
          "module": "Sound.Signal",
          "name": "crochetL",
          "normalized": "(a-\u003eb-\u003eMaybe(c,b))-\u003eb-\u003ed a-\u003ed c",
          "package": "synthesizer",
          "signature": "(x-\u003eacc-\u003eMaybe(y,acc))-\u003eacc-\u003es x-\u003es y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Sound-Signal.html#v:crochetL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Sound.Signal",
          "name": "cycle",
          "package": "synthesizer",
          "signature": "s a -\u003e s a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Sound-Signal.html#cycle",
          "type": "function"
        },
        "index": {
          "hierarchy": "Sound Signal",
          "module": "Sound.Signal",
          "name": "cycle",
          "normalized": "a b-\u003ea b",
          "package": "synthesizer",
          "signature": "s a-\u003es a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Sound-Signal.html#v:cycle"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "This is a fusion friendly implementation of delay.\nHowever, in order to be a \u003ctt\u003e\u003ca\u003ecrochetL\u003c/a\u003e\u003c/tt\u003e\nthe output has the same length as the input,\nthat is, the last element is removed - at least for finite input.\n",
          "module": "Sound.Signal",
          "name": "delay1",
          "package": "synthesizer",
          "signature": "a -\u003e s a -\u003e s a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Sound-Signal.html#delay1",
          "type": "function"
        },
        "index": {
          "description": "This is fusion friendly implementation of delay However in order to be crochetL the output has the same length as the input that is the last element is removed at least for finite input",
          "hierarchy": "Sound Signal",
          "module": "Sound.Signal",
          "name": "delay1",
          "normalized": "a-\u003eb a-\u003eb a",
          "package": "synthesizer",
          "signature": "a-\u003es a-\u003es a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Sound-Signal.html#v:delay1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Sound.Signal",
          "name": "foldL'",
          "package": "synthesizer",
          "signature": "(x -\u003e acc -\u003e acc) -\u003e acc -\u003e s x -\u003e acc",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Sound-Signal.html#foldL%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Sound Signal",
          "module": "Sound.Signal",
          "name": "foldL'",
          "normalized": "(a-\u003eb-\u003eb)-\u003eb-\u003ec a-\u003eb",
          "package": "synthesizer",
          "partial": "L'",
          "signature": "(x-\u003eacc-\u003eacc)-\u003eacc-\u003es x-\u003eacc",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Sound-Signal.html#v:foldL'"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Sound.Signal",
          "name": "fromList",
          "package": "synthesizer",
          "signature": "[y] -\u003e s y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Sound-Signal.html#fromList",
          "type": "function"
        },
        "index": {
          "hierarchy": "Sound Signal",
          "module": "Sound.Signal",
          "name": "fromList",
          "normalized": "[a]-\u003eb a",
          "package": "synthesizer",
          "partial": "List",
          "signature": "[y]-\u003es y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Sound-Signal.html#v:fromList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Sound.Signal",
          "name": "generate",
          "package": "synthesizer",
          "signature": "(acc -\u003e Maybe (y, acc)) -\u003e acc -\u003e s y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Sound-Signal.html#generate",
          "type": "function"
        },
        "index": {
          "hierarchy": "Sound Signal",
          "module": "Sound.Signal",
          "name": "generate",
          "normalized": "(a-\u003eMaybe(b,a))-\u003ea-\u003ec b",
          "package": "synthesizer",
          "signature": "(acc-\u003eMaybe(y,acc))-\u003eacc-\u003es y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Sound-Signal.html#v:generate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Sound.Signal",
          "name": "iterate",
          "package": "synthesizer",
          "signature": "(a -\u003e a) -\u003e a -\u003e s a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Sound-Signal.html#iterate",
          "type": "function"
        },
        "index": {
          "hierarchy": "Sound Signal",
          "module": "Sound.Signal",
          "name": "iterate",
          "normalized": "(a-\u003ea)-\u003ea-\u003eb a",
          "package": "synthesizer",
          "signature": "(a-\u003ea)-\u003ea-\u003es a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Sound-Signal.html#v:iterate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "can be used to check against native length implementation \n",
          "module": "Sound.Signal",
          "name": "lengthSlow",
          "package": "synthesizer",
          "signature": "s a -\u003e Int",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Sound-Signal.html#lengthSlow",
          "type": "function"
        },
        "index": {
          "description": "can be used to check against native length implementation",
          "hierarchy": "Sound Signal",
          "module": "Sound.Signal",
          "name": "lengthSlow",
          "normalized": "a b-\u003eInt",
          "package": "synthesizer",
          "partial": "Slow",
          "signature": "s a-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Sound-Signal.html#v:lengthSlow"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Sound.Signal",
          "name": "map",
          "package": "synthesizer",
          "signature": "(a -\u003e b) -\u003e s a -\u003e s b",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Sound-Signal.html#map",
          "type": "function"
        },
        "index": {
          "hierarchy": "Sound Signal",
          "module": "Sound.Signal",
          "name": "map",
          "normalized": "(a-\u003eb)-\u003ec a-\u003ec b",
          "package": "synthesizer",
          "signature": "(a-\u003eb)-\u003es a-\u003es b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Sound-Signal.html#v:map"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Sound.Signal",
          "name": "mapAccumL",
          "package": "synthesizer",
          "signature": "(x -\u003e acc -\u003e Maybe (y, acc)) -\u003e acc -\u003e s x -\u003e (acc, s y)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Sound-Signal.html#mapAccumL",
          "type": "function"
        },
        "index": {
          "hierarchy": "Sound Signal",
          "module": "Sound.Signal",
          "name": "mapAccumL",
          "normalized": "(a-\u003eb-\u003eMaybe(c,b))-\u003eb-\u003ed a-\u003e(b,d c)",
          "package": "synthesizer",
          "partial": "Accum",
          "signature": "(x-\u003eacc-\u003eMaybe(y,acc))-\u003eacc-\u003es x-\u003e(acc,s y)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Sound-Signal.html#v:mapAccumL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Sound.Signal",
          "name": "recourse",
          "package": "synthesizer",
          "signature": "(acc -\u003e Maybe acc) -\u003e acc -\u003e acc",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Sound-Signal.html#recourse",
          "type": "function"
        },
        "index": {
          "hierarchy": "Sound Signal",
          "module": "Sound.Signal",
          "name": "recourse",
          "normalized": "(a-\u003eMaybe a)-\u003ea-\u003ea",
          "package": "synthesizer",
          "signature": "(acc-\u003eMaybe acc)-\u003eacc-\u003eacc",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Sound-Signal.html#v:recourse"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Sound.Signal",
          "name": "reduceL",
          "package": "synthesizer",
          "signature": "(x -\u003e acc -\u003e Maybe acc) -\u003e acc -\u003e s x -\u003e acc",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Sound-Signal.html#reduceL",
          "type": "function"
        },
        "index": {
          "hierarchy": "Sound Signal",
          "module": "Sound.Signal",
          "name": "reduceL",
          "normalized": "(a-\u003eb-\u003eMaybe b)-\u003eb-\u003ec a-\u003eb",
          "package": "synthesizer",
          "signature": "(x-\u003eacc-\u003eMaybe acc)-\u003eacc-\u003es x-\u003eacc",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Sound-Signal.html#v:reduceL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Sound.Signal",
          "name": "repeat",
          "package": "synthesizer",
          "signature": "a -\u003e s a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Sound-Signal.html#repeat",
          "type": "function"
        },
        "index": {
          "hierarchy": "Sound Signal",
          "module": "Sound.Signal",
          "name": "repeat",
          "normalized": "a-\u003eb a",
          "package": "synthesizer",
          "signature": "a-\u003es a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Sound-Signal.html#v:repeat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Sound.Signal",
          "name": "replicate",
          "package": "synthesizer",
          "signature": "Int -\u003e a -\u003e s a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Sound-Signal.html#replicate",
          "type": "function"
        },
        "index": {
          "hierarchy": "Sound Signal",
          "module": "Sound.Signal",
          "name": "replicate",
          "normalized": "Int-\u003ea-\u003eb a",
          "package": "synthesizer",
          "signature": "Int-\u003ea-\u003es a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Sound-Signal.html#v:replicate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Sound.Signal",
          "name": "scanL",
          "package": "synthesizer",
          "signature": "(x -\u003e acc -\u003e acc) -\u003e acc -\u003e s x -\u003e s acc",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Sound-Signal.html#scanL",
          "type": "function"
        },
        "index": {
          "hierarchy": "Sound Signal",
          "module": "Sound.Signal",
          "name": "scanL",
          "normalized": "(a-\u003eb-\u003eb)-\u003eb-\u003ec a-\u003ec b",
          "package": "synthesizer",
          "signature": "(x-\u003eacc-\u003eacc)-\u003eacc-\u003es x-\u003es acc",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Sound-Signal.html#v:scanL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Sound.Signal",
          "name": "singleton",
          "package": "synthesizer",
          "signature": "a -\u003e s a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Sound-Signal.html#singleton",
          "type": "function"
        },
        "index": {
          "hierarchy": "Sound Signal",
          "module": "Sound.Signal",
          "name": "singleton",
          "normalized": "a-\u003eb a",
          "package": "synthesizer",
          "signature": "a-\u003es a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Sound-Signal.html#v:singleton"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Sound.Signal",
          "name": "take",
          "package": "synthesizer",
          "signature": "Int -\u003e s a -\u003e s a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Sound-Signal.html#take",
          "type": "function"
        },
        "index": {
          "hierarchy": "Sound Signal",
          "module": "Sound.Signal",
          "name": "take",
          "normalized": "Int-\u003ea b-\u003ea b",
          "package": "synthesizer",
          "signature": "Int-\u003es a-\u003es a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Sound-Signal.html#v:take"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Sound.Signal",
          "name": "takeWhile",
          "package": "synthesizer",
          "signature": "(a -\u003e Bool) -\u003e s a -\u003e s a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Sound-Signal.html#takeWhile",
          "type": "function"
        },
        "index": {
          "hierarchy": "Sound Signal",
          "module": "Sound.Signal",
          "name": "takeWhile",
          "normalized": "(a-\u003eBool)-\u003eb a-\u003eb a",
          "package": "synthesizer",
          "partial": "While",
          "signature": "(a-\u003eBool)-\u003es a-\u003es a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Sound-Signal.html#v:takeWhile"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Sound.Signal",
          "name": "unfoldR",
          "package": "synthesizer",
          "signature": "(acc -\u003e Maybe (y, acc)) -\u003e acc -\u003e (acc, s y)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Sound-Signal.html#unfoldR",
          "type": "function"
        },
        "index": {
          "hierarchy": "Sound Signal",
          "module": "Sound.Signal",
          "name": "unfoldR",
          "normalized": "(a-\u003eMaybe(b,a))-\u003ea-\u003e(a,c b)",
          "package": "synthesizer",
          "signature": "(acc-\u003eMaybe(y,acc))-\u003eacc-\u003e(acc,s y)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Sound-Signal.html#v:unfoldR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Sound.Signal",
          "name": "unzip",
          "package": "synthesizer",
          "signature": "s (a, b) -\u003e (s a, s b)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Sound-Signal.html#unzip",
          "type": "function"
        },
        "index": {
          "hierarchy": "Sound Signal",
          "module": "Sound.Signal",
          "name": "unzip",
          "normalized": "a(b,c)-\u003e(a b,a c)",
          "package": "synthesizer",
          "signature": "s(a,b)-\u003e(s a,s b)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Sound-Signal.html#v:unzip"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Sound.Signal",
          "name": "zipWith",
          "package": "synthesizer",
          "signature": "(a -\u003e b -\u003e c) -\u003e s a -\u003e s b -\u003e s c",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Sound-Signal.html#zipWith",
          "type": "function"
        },
        "index": {
          "hierarchy": "Sound Signal",
          "module": "Sound.Signal",
          "name": "zipWith",
          "normalized": "(a-\u003eb-\u003ec)-\u003ed a-\u003ed b-\u003ed c",
          "package": "synthesizer",
          "partial": "With",
          "signature": "(a-\u003eb-\u003ec)-\u003es a-\u003es b-\u003es c",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Sound-Signal.html#v:zipWith"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Sound.Signal",
          "name": "zipWith3",
          "package": "synthesizer",
          "signature": "(a -\u003e b -\u003e c -\u003e d) -\u003e s a -\u003e s b -\u003e s c -\u003e s d",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Sound-Signal.html#zipWith3",
          "type": "function"
        },
        "index": {
          "hierarchy": "Sound Signal",
          "module": "Sound.Signal",
          "name": "zipWith3",
          "normalized": "(a-\u003eb-\u003ec-\u003ed)-\u003ee a-\u003ee b-\u003ee c-\u003ee d",
          "package": "synthesizer",
          "partial": "With",
          "signature": "(a-\u003eb-\u003ec-\u003ed)-\u003es a-\u003es b-\u003es c-\u003es d",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Sound-Signal.html#v:zipWith3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Sound.Signal",
          "name": "zipWith4",
          "package": "synthesizer",
          "signature": "(a -\u003e b -\u003e c -\u003e d -\u003e e) -\u003e s a -\u003e s b -\u003e s c -\u003e s d -\u003e s e",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Sound-Signal.html#zipWith4",
          "type": "function"
        },
        "index": {
          "hierarchy": "Sound Signal",
          "module": "Sound.Signal",
          "name": "zipWith4",
          "normalized": "(a-\u003eb-\u003ec-\u003ed-\u003ee)-\u003ef a-\u003ef b-\u003ef c-\u003ef d-\u003ef e",
          "package": "synthesizer",
          "partial": "With",
          "signature": "(a-\u003eb-\u003ec-\u003ed-\u003ee)-\u003es a-\u003es b-\u003es c-\u003es d-\u003es e",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Sound-Signal.html#v:zipWith4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "value \n",
          "module": "Synthesizer.Amplitude.Control",
          "name": "constant",
          "package": "synthesizer",
          "signature": "y'-\u003e T y y' y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Amplitude-Control.html#constant",
          "type": "function"
        },
        "index": {
          "description": "value",
          "hierarchy": "Synthesizer Amplitude Control",
          "module": "Synthesizer.Amplitude.Control",
          "name": "constant",
          "normalized": "a-\u003eT b a b",
          "package": "synthesizer",
          "signature": "y'-\u003eT y y' y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Amplitude-Control.html#v:constant"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "amplitude \nvalue \n",
          "module": "Synthesizer.Amplitude.Control",
          "name": "constantVector",
          "package": "synthesizer",
          "signature": "y'-\u003e yv-\u003e T y y' yv",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Amplitude-Control.html#constantVector",
          "type": "function"
        },
        "index": {
          "description": "amplitude value",
          "hierarchy": "Synthesizer Amplitude Control",
          "module": "Synthesizer.Amplitude.Control",
          "name": "constantVector",
          "normalized": "a-\u003eb-\u003eT c a b",
          "package": "synthesizer",
          "partial": "Vector",
          "signature": "y'-\u003eyv-\u003eT y y' yv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Amplitude-Control.html#v:constantVector"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "range: one is mapped to \u003ctt\u003ecenter*range\u003c/tt\u003e, must be positive \ncenter: zero is mapped to \u003ctt\u003ecenter\u003c/tt\u003e \n",
          "module": "Synthesizer.Amplitude.Control",
          "name": "mapExponential",
          "package": "synthesizer",
          "signature": "y-\u003e y'-\u003e T y y y-\u003e T y y' y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Amplitude-Control.html#mapExponential",
          "type": "function"
        },
        "index": {
          "description": "range one is mapped to center range must be positive center zero is mapped to center",
          "hierarchy": "Synthesizer Amplitude Control",
          "module": "Synthesizer.Amplitude.Control",
          "name": "mapExponential",
          "normalized": "a-\u003eb-\u003eT a a a-\u003eT a b a",
          "package": "synthesizer",
          "partial": "Exponential",
          "signature": "y-\u003ey'-\u003eT y y y-\u003eT y y' y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Amplitude-Control.html#v:mapExponential"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "range: one is mapped to \u003ctt\u003ecenter+range\u003c/tt\u003e \ncenter: zero is mapped to \u003ctt\u003ecenter\u003c/tt\u003e \n",
          "module": "Synthesizer.Amplitude.Control",
          "name": "mapLinear",
          "package": "synthesizer",
          "signature": "y'-\u003e y'-\u003e T y y' y-\u003e T y y' y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Amplitude-Control.html#mapLinear",
          "type": "function"
        },
        "index": {
          "description": "range one is mapped to center range center zero is mapped to center",
          "hierarchy": "Synthesizer Amplitude Control",
          "module": "Synthesizer.Amplitude.Control",
          "name": "mapLinear",
          "normalized": "a-\u003ea-\u003eT b a b-\u003eT b a b",
          "package": "synthesizer",
          "partial": "Linear",
          "signature": "y'-\u003ey'-\u003eT y y' y-\u003eT y y' y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Amplitude-Control.html#v:mapLinear"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Amplitude.Cut",
          "name": "append",
          "package": "synthesizer",
          "signature": "T y y' yv -\u003e T y y' yv -\u003e T y y' yv",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Amplitude-Cut.html#append",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Amplitude Cut",
          "module": "Synthesizer.Amplitude.Cut",
          "name": "append",
          "normalized": "T a b c-\u003eT a b c-\u003eT a b c",
          "package": "synthesizer",
          "signature": "T y y' yv-\u003eT y y' yv-\u003eT y y' yv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Amplitude-Cut.html#v:append"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Amplitude.Cut",
          "name": "appendVolume",
          "package": "synthesizer",
          "signature": "y' -\u003e T y y' yv -\u003e T y y' yv -\u003e T y y' yv",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Amplitude-Cut.html#appendVolume",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Amplitude Cut",
          "module": "Synthesizer.Amplitude.Cut",
          "name": "appendVolume",
          "normalized": "a-\u003eT b a c-\u003eT b a c-\u003eT b a c",
          "package": "synthesizer",
          "partial": "Volume",
          "signature": "y'-\u003eT y y' yv-\u003eT y y' yv-\u003eT y y' yv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Amplitude-Cut.html#v:appendVolume"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Similar to \u003ctt\u003efoldr1 append\u003c/tt\u003e but more efficient and accurate,\nbecause it reduces the number of amplifications.\nDoes not work for infinite lists,\nbecause no maximum amplitude can be computed.\n",
          "module": "Synthesizer.Amplitude.Cut",
          "name": "concat",
          "package": "synthesizer",
          "signature": "[T y y' yv] -\u003e T y y' yv",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Amplitude-Cut.html#concat",
          "type": "function"
        },
        "index": {
          "description": "Similar to foldr1 append but more efficient and accurate because it reduces the number of amplifications Does not work for infinite lists because no maximum amplitude can be computed",
          "hierarchy": "Synthesizer Amplitude Cut",
          "module": "Synthesizer.Amplitude.Cut",
          "name": "concat",
          "normalized": "[T a b c]-\u003eT a b c",
          "package": "synthesizer",
          "signature": "[T y y' yv]-\u003eT y y' yv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Amplitude-Cut.html#v:concat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Give the output volume explicitly.\nDoes also work for infinite lists.\n",
          "module": "Synthesizer.Amplitude.Cut",
          "name": "concatVolume",
          "package": "synthesizer",
          "signature": "y' -\u003e [T y y' yv] -\u003e T y y' yv",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Amplitude-Cut.html#concatVolume",
          "type": "function"
        },
        "index": {
          "description": "Give the output volume explicitly Does also work for infinite lists",
          "hierarchy": "Synthesizer Amplitude Cut",
          "module": "Synthesizer.Amplitude.Cut",
          "name": "concatVolume",
          "normalized": "a-\u003e[T b a c]-\u003eT b a c",
          "package": "synthesizer",
          "partial": "Volume",
          "signature": "y'-\u003e[T y y' yv]-\u003eT y y' yv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Amplitude-Cut.html#v:concatVolume"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Amplitude.Cut",
          "name": "unzip",
          "package": "synthesizer",
          "signature": "T y y' (yv0, yv1) -\u003e (T y y' yv0, T y y' yv1)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Amplitude-Cut.html#unzip",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Amplitude Cut",
          "module": "Synthesizer.Amplitude.Cut",
          "name": "unzip",
          "normalized": "T a b(c,c)-\u003e(T a b c,T a b c)",
          "package": "synthesizer",
          "signature": "T y y'(yv,yv)-\u003e(T y y' yv,T y y' yv)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Amplitude-Cut.html#v:unzip"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Amplitude.Cut",
          "name": "unzip3",
          "package": "synthesizer",
          "signature": "T y y' (yv0, yv1, yv2) -\u003e (T y y' yv0, T y y' yv1, T y y' yv2)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Amplitude-Cut.html#unzip3",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Amplitude Cut",
          "module": "Synthesizer.Amplitude.Cut",
          "name": "unzip3",
          "normalized": "T a b(c,c,c)-\u003e(T a b c,T a b c,T a b c)",
          "package": "synthesizer",
          "signature": "T y y'(yv,yv,yv)-\u003e(T y y' yv,T y y' yv,T y y' yv)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Amplitude-Cut.html#v:unzip3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Amplitude.Cut",
          "name": "zip",
          "package": "synthesizer",
          "signature": "T y y' yv0 -\u003e T y y' yv1 -\u003e T y y' (yv0, yv1)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Amplitude-Cut.html#zip",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Amplitude Cut",
          "module": "Synthesizer.Amplitude.Cut",
          "name": "zip",
          "normalized": "T a b c-\u003eT a b c-\u003eT a b(c,c)",
          "package": "synthesizer",
          "signature": "T y y' yv-\u003eT y y' yv-\u003eT y y'(yv,yv)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Amplitude-Cut.html#v:zip"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Amplitude.Cut",
          "name": "zip3",
          "package": "synthesizer",
          "signature": "T y y' yv0 -\u003e T y y' yv1 -\u003e T y y' yv2 -\u003e T y y' (yv0, yv1, yv2)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Amplitude-Cut.html#zip3",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Amplitude Cut",
          "module": "Synthesizer.Amplitude.Cut",
          "name": "zip3",
          "normalized": "T a b c-\u003eT a b c-\u003eT a b c-\u003eT a b(c,c,c)",
          "package": "synthesizer",
          "signature": "T y y' yv-\u003eT y y' yv-\u003eT y y' yv-\u003eT y y'(yv,yv,yv)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Amplitude-Cut.html#v:zip3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Amplitude.Cut",
          "name": "zip3Volume",
          "package": "synthesizer",
          "signature": "y' -\u003e T y y' yv0 -\u003e T y y' yv1 -\u003e T y y' yv2 -\u003e T y y' (yv0, yv1, yv2)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Amplitude-Cut.html#zip3Volume",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Amplitude Cut",
          "module": "Synthesizer.Amplitude.Cut",
          "name": "zip3Volume",
          "normalized": "a-\u003eT b a c-\u003eT b a c-\u003eT b a c-\u003eT b a(c,c,c)",
          "package": "synthesizer",
          "partial": "Volume",
          "signature": "y'-\u003eT y y' yv-\u003eT y y' yv-\u003eT y y' yv-\u003eT y y'(yv,yv,yv)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Amplitude-Cut.html#v:zip3Volume"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Amplitude.Cut",
          "name": "zipVolume",
          "package": "synthesizer",
          "signature": "y' -\u003e T y y' yv0 -\u003e T y y' yv1 -\u003e T y y' (yv0, yv1)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Amplitude-Cut.html#zipVolume",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Amplitude Cut",
          "module": "Synthesizer.Amplitude.Cut",
          "name": "zipVolume",
          "normalized": "a-\u003eT b a c-\u003eT b a c-\u003eT b a(c,c)",
          "package": "synthesizer",
          "partial": "Volume",
          "signature": "y'-\u003eT y y' yv-\u003eT y y' yv-\u003eT y y'(yv,yv)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Amplitude-Cut.html#v:zipVolume"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Mix two signals.\n    In opposition to \u003ctt\u003e\u003ca\u003ezipWith\u003c/a\u003e\u003c/tt\u003e the result has the length of the longer signal. \n",
          "module": "Synthesizer.Amplitude.Displacement",
          "name": "mix",
          "package": "synthesizer",
          "signature": "T y y' yv -\u003e T y y' yv -\u003e T y y' yv",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Amplitude-Displacement.html#mix",
          "type": "function"
        },
        "index": {
          "description": "Mix two signals In opposition to zipWith the result has the length of the longer signal",
          "hierarchy": "Synthesizer Amplitude Displacement",
          "module": "Synthesizer.Amplitude.Displacement",
          "name": "mix",
          "normalized": "T a b c-\u003eT a b c-\u003eT a b c",
          "package": "synthesizer",
          "signature": "T y y' yv-\u003eT y y' yv-\u003eT y y' yv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Amplitude-Displacement.html#v:mix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Mix one or more signals. \n",
          "module": "Synthesizer.Amplitude.Displacement",
          "name": "mixMulti",
          "package": "synthesizer",
          "signature": "[T y y' yv] -\u003e T y y' yv",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Amplitude-Displacement.html#mixMulti",
          "type": "function"
        },
        "index": {
          "description": "Mix one or more signals",
          "hierarchy": "Synthesizer Amplitude Displacement",
          "module": "Synthesizer.Amplitude.Displacement",
          "name": "mixMulti",
          "normalized": "[T a b c]-\u003eT a b c",
          "package": "synthesizer",
          "partial": "Multi",
          "signature": "[T y y' yv]-\u003eT y y' yv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Amplitude-Displacement.html#v:mixMulti"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Amplitude.Displacement",
          "name": "mixMultiVolume",
          "package": "synthesizer",
          "signature": "y' -\u003e [T y y' yv] -\u003e T y y' yv",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Amplitude-Displacement.html#mixMultiVolume",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Amplitude Displacement",
          "module": "Synthesizer.Amplitude.Displacement",
          "name": "mixMultiVolume",
          "normalized": "a-\u003e[T b a c]-\u003eT b a c",
          "package": "synthesizer",
          "partial": "Multi Volume",
          "signature": "y'-\u003e[T y y' yv]-\u003eT y y' yv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Amplitude-Displacement.html#v:mixMultiVolume"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Amplitude.Displacement",
          "name": "mixVolume",
          "package": "synthesizer",
          "signature": "y' -\u003e T y y' yv -\u003e T y y' yv -\u003e T y y' yv",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Amplitude-Displacement.html#mixVolume",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Amplitude Displacement",
          "module": "Synthesizer.Amplitude.Displacement",
          "name": "mixVolume",
          "normalized": "a-\u003eT b a c-\u003eT b a c-\u003eT b a c",
          "package": "synthesizer",
          "partial": "Volume",
          "signature": "y'-\u003eT y y' yv-\u003eT y y' yv-\u003eT y y' yv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Amplitude-Displacement.html#v:mixVolume"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Add a number to all of the signal values.\n    This is useful for adjusting the center of a modulation. \n",
          "module": "Synthesizer.Amplitude.Displacement",
          "name": "raise",
          "package": "synthesizer",
          "signature": "y' -\u003e yv -\u003e T y y' yv -\u003e T y y' yv",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Amplitude-Displacement.html#raise",
          "type": "function"
        },
        "index": {
          "description": "Add number to all of the signal values This is useful for adjusting the center of modulation",
          "hierarchy": "Synthesizer Amplitude Displacement",
          "module": "Synthesizer.Amplitude.Displacement",
          "name": "raise",
          "normalized": "a-\u003eb-\u003eT c a b-\u003eT c a b",
          "package": "synthesizer",
          "signature": "y'-\u003eyv-\u003eT y y' yv-\u003eT y y' yv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Amplitude-Displacement.html#v:raise"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "The amplification factor must be positive. \n",
          "module": "Synthesizer.Amplitude.Filter",
          "name": "amplify",
          "package": "synthesizer",
          "signature": "y' -\u003e T y y' yv -\u003e T y y' yv",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Amplitude-Filter.html#amplify",
          "type": "function"
        },
        "index": {
          "description": "The amplification factor must be positive",
          "hierarchy": "Synthesizer Amplitude Filter",
          "module": "Synthesizer.Amplitude.Filter",
          "name": "amplify",
          "normalized": "a-\u003eT b a c-\u003eT b a c",
          "package": "synthesizer",
          "signature": "y'-\u003eT y y' yv-\u003eT y y' yv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Amplitude-Filter.html#v:amplify"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "the envelope \nthe signal to be enveloped \n",
          "module": "Synthesizer.Amplitude.Filter",
          "name": "envelope",
          "package": "synthesizer",
          "signature": "T y y' y0-\u003e T y y' yv-\u003e T y y' yv",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Amplitude-Filter.html#envelope",
          "type": "function"
        },
        "index": {
          "description": "the envelope the signal to be enveloped",
          "hierarchy": "Synthesizer Amplitude Filter",
          "module": "Synthesizer.Amplitude.Filter",
          "name": "envelope",
          "normalized": "T a b a-\u003eT a b c-\u003eT a b c",
          "package": "synthesizer",
          "signature": "T y y' y-\u003eT y y' yv-\u003eT y y' yv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Amplitude-Filter.html#v:envelope"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Amplitude.Filter",
          "name": "negate",
          "package": "synthesizer",
          "signature": "T y y' yv -\u003e T y y' yv",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Amplitude-Filter.html#negate",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Amplitude Filter",
          "module": "Synthesizer.Amplitude.Filter",
          "name": "negate",
          "normalized": "T a b c-\u003eT a b c",
          "package": "synthesizer",
          "signature": "T y y' yv-\u003eT y y' yv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Amplitude-Filter.html#v:negate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Amplitude.Signal",
          "name": "T",
          "package": "synthesizer",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Amplitude-Signal.html#T",
          "type": "data"
        },
        "index": {
          "hierarchy": "Synthesizer Amplitude Signal",
          "module": "Synthesizer.Amplitude.Signal",
          "name": "T",
          "package": "synthesizer",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Amplitude-Signal.html#t:T"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Synthesizer.Amplitude.Signal\",\"Synthesizer.SampleRateContext.Signal\"]",
          "name": "replaceAmplitude",
          "package": "synthesizer",
          "signature": "y1' -\u003e T y y0' yv -\u003e T y y1' yv",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Amplitude-Signal.html#replaceAmplitude",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Amplitude-Signal.html#v:replaceAmplitude\",\"http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-SampleRateContext-Signal.html#v:replaceAmplitude\"]"
        },
        "index": {
          "hierarchy": "Synthesizer Amplitude Signal",
          "module": "Synthesizer.Amplitude.Signal",
          "name": "replaceAmplitude",
          "normalized": "a-\u003eT a a b-\u003eT a a b",
          "package": "synthesizer",
          "partial": "Amplitude",
          "signature": "y-\u003eT y y yv-\u003eT y y yv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Amplitude-Signal.html#v:replaceAmplitude"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Synthesizer.Amplitude.Signal\",\"Synthesizer.SampleRateContext.Signal\"]",
          "name": "replaceSamples",
          "package": "synthesizer",
          "signature": "[yv1] -\u003e T y y' yv0 -\u003e T y y' yv1",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Amplitude-Signal.html#replaceSamples",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Amplitude-Signal.html#v:replaceSamples\",\"http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-SampleRateContext-Signal.html#v:replaceSamples\"]"
        },
        "index": {
          "hierarchy": "Synthesizer Amplitude Signal",
          "module": "Synthesizer.Amplitude.Signal",
          "name": "replaceSamples",
          "normalized": "[a]-\u003eT b c a-\u003eT b c a",
          "package": "synthesizer",
          "partial": "Samples",
          "signature": "[yv]-\u003eT y y' yv-\u003eT y y' yv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Amplitude-Signal.html#v:replaceSamples"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Synthesizer.Amplitude.Signal\",\"Synthesizer.SampleRateContext.Signal\"]",
          "name": "scalarSamples",
          "package": "synthesizer",
          "signature": "(y' -\u003e y) -\u003e T y y' y -\u003e [y]",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Amplitude-Signal.html#scalarSamples",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Amplitude-Signal.html#v:scalarSamples\",\"http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-SampleRateContext-Signal.html#v:scalarSamples\"]"
        },
        "index": {
          "hierarchy": "Synthesizer Amplitude Signal",
          "module": "Synthesizer.Amplitude.Signal",
          "name": "scalarSamples",
          "normalized": "(a-\u003eb)-\u003eT b a b-\u003e[b]",
          "package": "synthesizer",
          "partial": "Samples",
          "signature": "(y'-\u003ey)-\u003eT y y' y-\u003e[y]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Amplitude-Signal.html#v:scalarSamples"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Synthesizer.Amplitude.Signal\",\"Synthesizer.SampleRateContext.Signal\"]",
          "name": "toAmplitudeScalar",
          "package": "synthesizer",
          "signature": "T y y' yv -\u003e y' -\u003e y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Amplitude-Signal.html#toAmplitudeScalar",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Amplitude-Signal.html#v:toAmplitudeScalar\",\"http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-SampleRateContext-Signal.html#v:toAmplitudeScalar\"]"
        },
        "index": {
          "hierarchy": "Synthesizer Amplitude Signal",
          "module": "Synthesizer.Amplitude.Signal",
          "name": "toAmplitudeScalar",
          "normalized": "T a b c-\u003eb-\u003ea",
          "package": "synthesizer",
          "partial": "Amplitude Scalar",
          "signature": "T y y' yv-\u003ey'-\u003ey",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Amplitude-Signal.html#v:toAmplitudeScalar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Synthesizer.Amplitude.Signal\",\"Synthesizer.SampleRateContext.Signal\"]",
          "name": "vectorSamples",
          "package": "synthesizer",
          "signature": "(y' -\u003e y) -\u003e T y y' yv -\u003e [yv]",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Amplitude-Signal.html#vectorSamples",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Amplitude-Signal.html#v:vectorSamples\",\"http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-SampleRateContext-Signal.html#v:vectorSamples\"]"
        },
        "index": {
          "hierarchy": "Synthesizer Amplitude Signal",
          "module": "Synthesizer.Amplitude.Signal",
          "name": "vectorSamples",
          "normalized": "(a-\u003eb)-\u003eT b a c-\u003e[c]",
          "package": "synthesizer",
          "partial": "Samples",
          "signature": "(y'-\u003ey)-\u003eT y y' yv-\u003e[yv]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Amplitude-Signal.html#v:vectorSamples"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Synthesizer.ApplicativeUtility\",\"Synthesizer.Dimensional.Process\",\"Synthesizer.SampleRateContext.Rate\"]",
          "name": "$#",
          "package": "synthesizer",
          "signature": "f (a -\u003e b) -\u003e a -\u003e f b",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-ApplicativeUtility.html#%24%23",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-ApplicativeUtility.html#v:$#\",\"http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Process.html#v:$#\",\"http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-SampleRateContext-Rate.html#v:$#\"]"
        },
        "index": {
          "hierarchy": "Synthesizer ApplicativeUtility",
          "module": "Synthesizer.ApplicativeUtility",
          "name": "$#",
          "normalized": "a(b-\u003ec)-\u003eb-\u003ea c",
          "package": "synthesizer",
          "signature": "f(a-\u003eb)-\u003ea-\u003ef b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-ApplicativeUtility.html#v:$#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "This corresponds to \u003ctt\u003e\u003ca\u003e\u003c*\u003e\u003c/a\u003e\u003c/tt\u003e\n",
          "module": "[\"Synthesizer.ApplicativeUtility\",\"Synthesizer.Dimensional.Process\",\"Synthesizer.SampleRateContext.Rate\"]",
          "name": "$:",
          "package": "synthesizer",
          "signature": "f (a -\u003e b) -\u003e f a -\u003e f b",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-ApplicativeUtility.html#%24%3A",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-ApplicativeUtility.html#v:$:\",\"http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Process.html#v:$:\",\"http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-SampleRateContext-Rate.html#v:$:\"]"
        },
        "index": {
          "description": "This corresponds to",
          "hierarchy": "Synthesizer ApplicativeUtility",
          "module": "Synthesizer.ApplicativeUtility",
          "name": "$:",
          "normalized": "a(b-\u003ec)-\u003ea b-\u003ea c",
          "package": "synthesizer",
          "signature": "f(a-\u003eb)-\u003ef a-\u003ef b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-ApplicativeUtility.html#v:$:"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Instead of \u003ctt\u003emixMulti $:: map f xs\u003c/tt\u003e\nthe caller should write \u003ctt\u003emixMulti $: mapM f xs\u003c/tt\u003e\nin order to save the user from learning another infix operator.\n",
          "module": "[\"Synthesizer.ApplicativeUtility\",\"Synthesizer.Dimensional.Process\",\"Synthesizer.SampleRateContext.Rate\"]",
          "name": "$::",
          "package": "synthesizer",
          "signature": "f (t a -\u003e b) -\u003e t (f a) -\u003e f b",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-ApplicativeUtility.html#%24%3A%3A",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-ApplicativeUtility.html#v:$::\",\"http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Process.html#v:$::\",\"http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-SampleRateContext-Rate.html#v:$::\"]"
        },
        "index": {
          "description": "Instead of mixMulti map xs the caller should write mixMulti mapM xs in order to save the user from learning another infix operator",
          "hierarchy": "Synthesizer ApplicativeUtility",
          "module": "Synthesizer.ApplicativeUtility",
          "name": "$::",
          "normalized": "a(b c-\u003ed)-\u003eb(a c)-\u003ea d",
          "package": "synthesizer",
          "signature": "f(t a-\u003eb)-\u003et(f a)-\u003ef b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-ApplicativeUtility.html#v:$::"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Synthesizer.ApplicativeUtility\",\"Synthesizer.Dimensional.Process\",\"Synthesizer.SampleRateContext.Rate\"]",
          "name": "$^",
          "package": "synthesizer",
          "signature": "(a -\u003e b) -\u003e f a -\u003e f b",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-ApplicativeUtility.html#%24%5E",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-ApplicativeUtility.html#v:$^\",\"http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Process.html#v:$^\",\"http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-SampleRateContext-Rate.html#v:$^\"]"
        },
        "index": {
          "hierarchy": "Synthesizer ApplicativeUtility",
          "module": "Synthesizer.ApplicativeUtility",
          "name": "$^",
          "normalized": "(a-\u003eb)-\u003ec a-\u003ec b",
          "package": "synthesizer",
          "signature": "(a-\u003eb)-\u003ef a-\u003ef b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-ApplicativeUtility.html#v:$^"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Synthesizer.ApplicativeUtility\",\"Synthesizer.Dimensional.Process\",\"Synthesizer.SampleRateContext.Rate\"]",
          "name": ".:",
          "package": "synthesizer",
          "signature": "f (b -\u003e c) -\u003e f (a -\u003e b) -\u003e f (a -\u003e c)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-ApplicativeUtility.html#.%3A",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-ApplicativeUtility.html#v:.:\",\"http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Process.html#v:.:\",\"http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-SampleRateContext-Rate.html#v:.:\"]"
        },
        "index": {
          "hierarchy": "Synthesizer ApplicativeUtility",
          "module": "Synthesizer.ApplicativeUtility",
          "name": ".:",
          "normalized": "a(b-\u003ec)-\u003ea(d-\u003eb)-\u003ea(d-\u003ec)",
          "package": "synthesizer",
          "signature": "f(b-\u003ec)-\u003ef(a-\u003eb)-\u003ef(a-\u003ec)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-ApplicativeUtility.html#v:.:"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Synthesizer.ApplicativeUtility\",\"Synthesizer.Dimensional.Process\",\"Synthesizer.SampleRateContext.Rate\"]",
          "name": ".^",
          "package": "synthesizer",
          "signature": "(b -\u003e c) -\u003e f (a -\u003e b) -\u003e f (a -\u003e c)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-ApplicativeUtility.html#.%5E",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-ApplicativeUtility.html#v:.^\",\"http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Process.html#v:.^\",\"http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-SampleRateContext-Rate.html#v:.^\"]"
        },
        "index": {
          "hierarchy": "Synthesizer ApplicativeUtility",
          "module": "Synthesizer.ApplicativeUtility",
          "name": ".^",
          "normalized": "(a-\u003eb)-\u003ec(d-\u003ea)-\u003ec(d-\u003eb)",
          "package": "synthesizer",
          "signature": "(b-\u003ec)-\u003ef(a-\u003eb)-\u003ef(a-\u003ec)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-ApplicativeUtility.html#v:.^"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.ApplicativeUtility",
          "name": "liftA4",
          "package": "synthesizer",
          "signature": "(a -\u003e b -\u003e c -\u003e d -\u003e e) -\u003e f a -\u003e f b -\u003e f c -\u003e f d -\u003e f e",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-ApplicativeUtility.html#liftA4",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer ApplicativeUtility",
          "module": "Synthesizer.ApplicativeUtility",
          "name": "liftA4",
          "normalized": "(a-\u003eb-\u003ec-\u003ed-\u003ee)-\u003ef a-\u003ef b-\u003ef c-\u003ef d-\u003ef e",
          "package": "synthesizer",
          "signature": "(a-\u003eb-\u003ec-\u003ed-\u003ee)-\u003ef a-\u003ef b-\u003ef c-\u003ef d-\u003ef e",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-ApplicativeUtility.html#v:liftA4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.ApplicativeUtility",
          "name": "liftA5",
          "package": "synthesizer",
          "signature": "(a -\u003e b -\u003e c -\u003e d -\u003e e -\u003e g) -\u003e f a -\u003e f b -\u003e f c -\u003e f d -\u003e f e -\u003e f g",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-ApplicativeUtility.html#liftA5",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer ApplicativeUtility",
          "module": "Synthesizer.ApplicativeUtility",
          "name": "liftA5",
          "normalized": "(a-\u003eb-\u003ec-\u003ed-\u003ee-\u003ef)-\u003eg a-\u003eg b-\u003eg c-\u003eg d-\u003eg e-\u003eg f",
          "package": "synthesizer",
          "signature": "(a-\u003eb-\u003ec-\u003ed-\u003ee-\u003eg)-\u003ef a-\u003ef b-\u003ef c-\u003ef d-\u003ef e-\u003ef g",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-ApplicativeUtility.html#v:liftA5"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.ApplicativeUtility",
          "name": "liftA6",
          "package": "synthesizer",
          "signature": "(a -\u003e b -\u003e c -\u003e d -\u003e e -\u003e g -\u003e h) -\u003e f a -\u003e f b -\u003e f c -\u003e f d -\u003e f e -\u003e f g -\u003e f h",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-ApplicativeUtility.html#liftA6",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer ApplicativeUtility",
          "module": "Synthesizer.ApplicativeUtility",
          "name": "liftA6",
          "normalized": "(a-\u003eb-\u003ec-\u003ed-\u003ee-\u003ef-\u003eg)-\u003eh a-\u003eh b-\u003eh c-\u003eh d-\u003eh e-\u003eh f-\u003eh g",
          "package": "synthesizer",
          "signature": "(a-\u003eb-\u003ec-\u003ed-\u003ee-\u003eg-\u003eh)-\u003ef a-\u003ef b-\u003ef c-\u003ef d-\u003ef e-\u003ef g-\u003ef h",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-ApplicativeUtility.html#v:liftA6"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Our signal processors have types like \u003ctt\u003ef (a -\u003e b -\u003e c)\u003c/tt\u003e.\nThey could also have the type \u003ctt\u003ea -\u003e b -\u003e f c\u003c/tt\u003e\nor \u003ctt\u003ef a -\u003e f b -\u003e f c\u003c/tt\u003e.\nWe did not choose the last variant for reduction of redundancy in type signatures,\nand we did not choose the second variant for easy composition of processors.\nHowever the forms are freely convertible,\nand if you prefer the last one because you do not want to sprinkle '($:)' in your code,\nthen you may want to convert the processors using the following functions,\nthat can be defined purely in the \u003ctt\u003e\u003ca\u003eApplicative\u003c/a\u003e\u003c/tt\u003e class.\n",
          "module": "[\"Synthesizer.ApplicativeUtility\",\"Synthesizer.Dimensional.Process\",\"Synthesizer.SampleRateContext.Rate\"]",
          "name": "liftP",
          "package": "synthesizer",
          "signature": "f (a -\u003e b) -\u003e f a -\u003e f b",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-ApplicativeUtility.html#liftP",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-ApplicativeUtility.html#v:liftP\",\"http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Process.html#v:liftP\",\"http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-SampleRateContext-Rate.html#v:liftP\"]"
        },
        "index": {
          "description": "Our signal processors have types like They could also have the type or We did not choose the last variant for reduction of redundancy in type signatures and we did not choose the second variant for easy composition of processors However the forms are freely convertible and if you prefer the last one because you do not want to sprinkle in your code then you may want to convert the processors using the following functions that can be defined purely in the Applicative class",
          "hierarchy": "Synthesizer ApplicativeUtility",
          "module": "Synthesizer.ApplicativeUtility",
          "name": "liftP",
          "normalized": "a(b-\u003ec)-\u003ea b-\u003ea c",
          "package": "synthesizer",
          "signature": "f(a-\u003eb)-\u003ef a-\u003ef b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-ApplicativeUtility.html#v:liftP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Synthesizer.ApplicativeUtility\",\"Synthesizer.Dimensional.Process\",\"Synthesizer.SampleRateContext.Rate\"]",
          "name": "liftP2",
          "package": "synthesizer",
          "signature": "f (a -\u003e b -\u003e c) -\u003e f a -\u003e f b -\u003e f c",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-ApplicativeUtility.html#liftP2",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-ApplicativeUtility.html#v:liftP2\",\"http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Process.html#v:liftP2\",\"http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-SampleRateContext-Rate.html#v:liftP2\"]"
        },
        "index": {
          "hierarchy": "Synthesizer ApplicativeUtility",
          "module": "Synthesizer.ApplicativeUtility",
          "name": "liftP2",
          "normalized": "a(b-\u003ec-\u003ed)-\u003ea b-\u003ea c-\u003ea d",
          "package": "synthesizer",
          "signature": "f(a-\u003eb-\u003ec)-\u003ef a-\u003ef b-\u003ef c",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-ApplicativeUtility.html#v:liftP2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Synthesizer.ApplicativeUtility\",\"Synthesizer.Dimensional.Process\",\"Synthesizer.SampleRateContext.Rate\"]",
          "name": "liftP3",
          "package": "synthesizer",
          "signature": "f (a -\u003e b -\u003e c -\u003e d) -\u003e f a -\u003e f b -\u003e f c -\u003e f d",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-ApplicativeUtility.html#liftP3",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-ApplicativeUtility.html#v:liftP3\",\"http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Process.html#v:liftP3\",\"http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-SampleRateContext-Rate.html#v:liftP3\"]"
        },
        "index": {
          "hierarchy": "Synthesizer ApplicativeUtility",
          "module": "Synthesizer.ApplicativeUtility",
          "name": "liftP3",
          "normalized": "a(b-\u003ec-\u003ed-\u003ee)-\u003ea b-\u003ea c-\u003ea d-\u003ea e",
          "package": "synthesizer",
          "signature": "f(a-\u003eb-\u003ec-\u003ed)-\u003ef a-\u003ef b-\u003ef c-\u003ef d",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-ApplicativeUtility.html#v:liftP3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Synthesizer.ApplicativeUtility\",\"Synthesizer.Dimensional.Process\",\"Synthesizer.SampleRateContext.Rate\"]",
          "name": "liftP4",
          "package": "synthesizer",
          "signature": "f (a -\u003e b -\u003e c -\u003e d -\u003e e) -\u003e f a -\u003e f b -\u003e f c -\u003e f d -\u003e f e",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-ApplicativeUtility.html#liftP4",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-ApplicativeUtility.html#v:liftP4\",\"http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Process.html#v:liftP4\",\"http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-SampleRateContext-Rate.html#v:liftP4\"]"
        },
        "index": {
          "hierarchy": "Synthesizer ApplicativeUtility",
          "module": "Synthesizer.ApplicativeUtility",
          "name": "liftP4",
          "normalized": "a(b-\u003ec-\u003ed-\u003ee-\u003ef)-\u003ea b-\u003ea c-\u003ea d-\u003ea e-\u003ea f",
          "package": "synthesizer",
          "signature": "f(a-\u003eb-\u003ec-\u003ed-\u003ee)-\u003ef a-\u003ef b-\u003ef c-\u003ef d-\u003ef e",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-ApplicativeUtility.html#v:liftP4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "process chain that shall be looped \n",
          "module": "[\"Synthesizer.ApplicativeUtility\",\"Synthesizer.Dimensional.Process\",\"Synthesizer.SampleRateContext.Rate\"]",
          "name": "loop",
          "package": "synthesizer",
          "signature": "f (a -\u003e a)-\u003e f a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-ApplicativeUtility.html#loop",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-ApplicativeUtility.html#v:loop\",\"http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Process.html#v:loop\",\"http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-SampleRateContext-Rate.html#v:loop\"]"
        },
        "index": {
          "description": "process chain that shall be looped",
          "hierarchy": "Synthesizer ApplicativeUtility",
          "module": "Synthesizer.ApplicativeUtility",
          "name": "loop",
          "normalized": "a(b-\u003eb)-\u003ea b",
          "package": "synthesizer",
          "signature": "f(a-\u003ea)-\u003ef a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-ApplicativeUtility.html#v:loop"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Basic.Binary",
          "name": "C",
          "package": "synthesizer",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Basic-Binary.html#C",
          "type": "class"
        },
        "index": {
          "hierarchy": "Synthesizer Basic Binary",
          "module": "Synthesizer.Basic.Binary",
          "name": "C",
          "package": "synthesizer",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Basic-Binary.html#v:C"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Basic.Binary",
          "name": "fromCanonicalWith",
          "package": "synthesizer",
          "signature": "(real -\u003e int) -\u003e real -\u003e int",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Basic-Binary.html#fromCanonicalWith",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Basic Binary",
          "module": "Synthesizer.Basic.Binary",
          "name": "fromCanonicalWith",
          "normalized": "(a-\u003eb)-\u003ea-\u003eb",
          "package": "synthesizer",
          "partial": "Canonical With",
          "signature": "(real-\u003eint)-\u003ereal-\u003eint",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Basic-Binary.html#v:fromCanonicalWith"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Basic.Binary",
          "name": "int16FromCanonical",
          "package": "synthesizer",
          "signature": "a -\u003e Int16",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Basic-Binary.html#int16FromCanonical",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Basic Binary",
          "module": "Synthesizer.Basic.Binary",
          "name": "int16FromCanonical",
          "normalized": "a-\u003eInt",
          "package": "synthesizer",
          "partial": "From Canonical",
          "signature": "a-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Basic-Binary.html#v:int16FromCanonical"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Basic.Binary",
          "name": "int16FromDouble",
          "package": "synthesizer",
          "signature": "Double -\u003e Int16",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Basic-Binary.html#int16FromDouble",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Basic Binary",
          "module": "Synthesizer.Basic.Binary",
          "name": "int16FromDouble",
          "normalized": "Double-\u003eInt",
          "package": "synthesizer",
          "partial": "From Double",
          "signature": "Double-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Basic-Binary.html#v:int16FromDouble"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Basic.Binary",
          "name": "int16FromFloat",
          "package": "synthesizer",
          "signature": "Float -\u003e Int16",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Basic-Binary.html#int16FromFloat",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Basic Binary",
          "module": "Synthesizer.Basic.Binary",
          "name": "int16FromFloat",
          "normalized": "Float-\u003eInt",
          "package": "synthesizer",
          "partial": "From Float",
          "signature": "Float-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Basic-Binary.html#v:int16FromFloat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Basic.Binary",
          "name": "int16ToCanonical",
          "package": "synthesizer",
          "signature": "Int16 -\u003e a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Basic-Binary.html#int16ToCanonical",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Basic Binary",
          "module": "Synthesizer.Basic.Binary",
          "name": "int16ToCanonical",
          "normalized": "Int-\u003ea",
          "package": "synthesizer",
          "partial": "To Canonical",
          "signature": "Int-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Basic-Binary.html#v:int16ToCanonical"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Basic.Binary",
          "name": "numberOfChannels",
          "package": "synthesizer",
          "signature": "a -\u003e Int",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Basic-Binary.html#numberOfChannels",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Basic Binary",
          "module": "Synthesizer.Basic.Binary",
          "name": "numberOfChannels",
          "normalized": "a-\u003eInt",
          "package": "synthesizer",
          "partial": "Of Channels",
          "signature": "a-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Basic-Binary.html#v:numberOfChannels"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Basic.Binary",
          "name": "numberOfSignalChannels",
          "package": "synthesizer",
          "signature": "sig yv -\u003e Int",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Basic-Binary.html#numberOfSignalChannels",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Basic Binary",
          "module": "Synthesizer.Basic.Binary",
          "name": "numberOfSignalChannels",
          "normalized": "a b-\u003eInt",
          "package": "synthesizer",
          "partial": "Of Signal Channels",
          "signature": "sig yv-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Basic-Binary.html#v:numberOfSignalChannels"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Basic.Binary",
          "name": "outputFromCanonical",
          "package": "synthesizer",
          "signature": "(int -\u003e out) -\u003e a -\u003e out",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Basic-Binary.html#outputFromCanonical",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Basic Binary",
          "module": "Synthesizer.Basic.Binary",
          "name": "outputFromCanonical",
          "normalized": "(a-\u003eb)-\u003ec-\u003eb",
          "package": "synthesizer",
          "partial": "From Canonical",
          "signature": "(int-\u003eout)-\u003ea-\u003eout",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Basic-Binary.html#v:outputFromCanonical"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Basic.Binary",
          "name": "toCanonical",
          "package": "synthesizer",
          "signature": "int -\u003e real",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Basic-Binary.html#toCanonical",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Basic Binary",
          "module": "Synthesizer.Basic.Binary",
          "name": "toCanonical",
          "normalized": "a-\u003eb",
          "package": "synthesizer",
          "partial": "Canonical",
          "signature": "int-\u003ereal",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Basic-Binary.html#v:toCanonical"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "limit, fuzz booster\n",
          "module": "Synthesizer.Basic.Distortion",
          "name": "clip",
          "package": "synthesizer",
          "signature": "a -\u003e a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Basic-Distortion.html#clip",
          "type": "function"
        },
        "index": {
          "description": "limit fuzz booster",
          "hierarchy": "Synthesizer Basic Distortion",
          "module": "Synthesizer.Basic.Distortion",
          "name": "clip",
          "normalized": "a-\u003ea",
          "package": "synthesizer",
          "signature": "a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Basic-Distortion.html#v:clip"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "logit, tanh\n",
          "module": "Synthesizer.Basic.Distortion",
          "name": "logit",
          "package": "synthesizer",
          "signature": "a -\u003e a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Basic-Distortion.html#logit",
          "type": "function"
        },
        "index": {
          "description": "logit tanh",
          "hierarchy": "Synthesizer Basic Distortion",
          "module": "Synthesizer.Basic.Distortion",
          "name": "logit",
          "normalized": "a-\u003ea",
          "package": "synthesizer",
          "signature": "a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Basic-Distortion.html#v:logit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Basic.Distortion",
          "name": "quantize",
          "package": "synthesizer",
          "signature": "a -\u003e a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Basic-Distortion.html#quantize",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Basic Distortion",
          "module": "Synthesizer.Basic.Distortion",
          "name": "quantize",
          "normalized": "a-\u003ea",
          "package": "synthesizer",
          "signature": "a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Basic-Distortion.html#v:quantize"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "sine\n",
          "module": "Synthesizer.Basic.Distortion",
          "name": "sine",
          "package": "synthesizer",
          "signature": "a -\u003e a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Basic-Distortion.html#sine",
          "type": "function"
        },
        "index": {
          "description": "sine",
          "hierarchy": "Synthesizer Basic Distortion",
          "module": "Synthesizer.Basic.Distortion",
          "name": "sine",
          "normalized": "a-\u003ea",
          "package": "synthesizer",
          "signature": "a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Basic-Distortion.html#v:sine"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "zig-zag\n",
          "module": "Synthesizer.Basic.Distortion",
          "name": "zigZag",
          "package": "synthesizer",
          "signature": "a -\u003e a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Basic-Distortion.html#zigZag",
          "type": "function"
        },
        "index": {
          "description": "zig-zag",
          "hierarchy": "Synthesizer Basic Distortion",
          "module": "Synthesizer.Basic.Distortion",
          "name": "zigZag",
          "normalized": "a-\u003ea",
          "package": "synthesizer",
          "partial": "Zag",
          "signature": "a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Basic-Distortion.html#v:zigZag"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "limit, fuzz booster\n",
          "module": "Synthesizer.Basic.DistortionControlled",
          "name": "clip",
          "package": "synthesizer",
          "signature": "a -\u003e a -\u003e a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Basic-DistortionControlled.html#clip",
          "type": "function"
        },
        "index": {
          "description": "limit fuzz booster",
          "hierarchy": "Synthesizer Basic DistortionControlled",
          "module": "Synthesizer.Basic.DistortionControlled",
          "name": "clip",
          "normalized": "a-\u003ea-\u003ea",
          "package": "synthesizer",
          "signature": "a-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Basic-DistortionControlled.html#v:clip"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "logit, tanh\n",
          "module": "Synthesizer.Basic.DistortionControlled",
          "name": "logit",
          "package": "synthesizer",
          "signature": "a -\u003e a -\u003e a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Basic-DistortionControlled.html#logit",
          "type": "function"
        },
        "index": {
          "description": "logit tanh",
          "hierarchy": "Synthesizer Basic DistortionControlled",
          "module": "Synthesizer.Basic.DistortionControlled",
          "name": "logit",
          "normalized": "a-\u003ea-\u003ea",
          "package": "synthesizer",
          "signature": "a-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Basic-DistortionControlled.html#v:logit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Basic.DistortionControlled",
          "name": "quantize",
          "package": "synthesizer",
          "signature": "a -\u003e a -\u003e a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Basic-DistortionControlled.html#quantize",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Basic DistortionControlled",
          "module": "Synthesizer.Basic.DistortionControlled",
          "name": "quantize",
          "normalized": "a-\u003ea-\u003ea",
          "package": "synthesizer",
          "signature": "a-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Basic-DistortionControlled.html#v:quantize"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "sine\n",
          "module": "Synthesizer.Basic.DistortionControlled",
          "name": "sine",
          "package": "synthesizer",
          "signature": "a -\u003e a -\u003e a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Basic-DistortionControlled.html#sine",
          "type": "function"
        },
        "index": {
          "description": "sine",
          "hierarchy": "Synthesizer Basic DistortionControlled",
          "module": "Synthesizer.Basic.DistortionControlled",
          "name": "sine",
          "normalized": "a-\u003ea-\u003ea",
          "package": "synthesizer",
          "signature": "a-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Basic-DistortionControlled.html#v:sine"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "zig-zag\n",
          "module": "Synthesizer.Basic.DistortionControlled",
          "name": "zigZag",
          "package": "synthesizer",
          "signature": "a -\u003e a -\u003e a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Basic-DistortionControlled.html#zigZag",
          "type": "function"
        },
        "index": {
          "description": "zig-zag",
          "hierarchy": "Synthesizer Basic DistortionControlled",
          "module": "Synthesizer.Basic.DistortionControlled",
          "name": "zigZag",
          "normalized": "a-\u003ea-\u003ea",
          "package": "synthesizer",
          "partial": "Zag",
          "signature": "a-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Basic-DistortionControlled.html#v:zigZag"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Basic.Phase",
          "name": "T",
          "package": "synthesizer",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Basic-Phase.html#T",
          "type": "data"
        },
        "index": {
          "hierarchy": "Synthesizer Basic Phase",
          "module": "Synthesizer.Basic.Phase",
          "name": "T",
          "package": "synthesizer",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Basic-Phase.html#t:T"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Basic.Phase",
          "name": "decrement",
          "package": "synthesizer",
          "signature": "a -\u003e T a -\u003e T a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Basic-Phase.html#decrement",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Basic Phase",
          "module": "Synthesizer.Basic.Phase",
          "name": "decrement",
          "normalized": "a-\u003eT a-\u003eT a",
          "package": "synthesizer",
          "signature": "a-\u003eT a-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Basic-Phase.html#v:decrement"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Basic.Phase",
          "name": "fromRepresentative",
          "package": "synthesizer",
          "signature": "a -\u003e T a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Basic-Phase.html#fromRepresentative",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Basic Phase",
          "module": "Synthesizer.Basic.Phase",
          "name": "fromRepresentative",
          "normalized": "a-\u003eT a",
          "package": "synthesizer",
          "partial": "Representative",
          "signature": "a-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Basic-Phase.html#v:fromRepresentative"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Basic.Phase",
          "name": "increment",
          "package": "synthesizer",
          "signature": "a -\u003e T a -\u003e T a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Basic-Phase.html#increment",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Basic Phase",
          "module": "Synthesizer.Basic.Phase",
          "name": "increment",
          "normalized": "a-\u003eT a-\u003eT a",
          "package": "synthesizer",
          "signature": "a-\u003eT a-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Basic-Phase.html#v:increment"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Basic.Phase",
          "name": "multiply",
          "package": "synthesizer",
          "signature": "b -\u003e T a -\u003e T a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Basic-Phase.html#multiply",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Basic Phase",
          "module": "Synthesizer.Basic.Phase",
          "name": "multiply",
          "normalized": "a-\u003eT b-\u003eT b",
          "package": "synthesizer",
          "signature": "b-\u003eT a-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Basic-Phase.html#v:multiply"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Basic.Phase",
          "name": "toRepresentative",
          "package": "synthesizer",
          "signature": "T a -\u003e a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Basic-Phase.html#toRepresentative",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Basic Phase",
          "module": "Synthesizer.Basic.Phase",
          "name": "toRepresentative",
          "normalized": "T a-\u003ea",
          "package": "synthesizer",
          "partial": "Representative",
          "signature": "T a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Basic-Phase.html#v:toRepresentative"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Basic.ToneModulation",
          "name": "Coords",
          "package": "synthesizer",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Basic-ToneModulation.html#Coords",
          "type": "type"
        },
        "index": {
          "hierarchy": "Synthesizer Basic ToneModulation",
          "module": "Synthesizer.Basic.ToneModulation",
          "name": "Coords",
          "package": "synthesizer",
          "partial": "Coords",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Basic-ToneModulation.html#t:Coords"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Basic.ToneModulation",
          "name": "Skip",
          "package": "synthesizer",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Basic-ToneModulation.html#Skip",
          "type": "type"
        },
        "index": {
          "hierarchy": "Synthesizer Basic ToneModulation",
          "module": "Synthesizer.Basic.ToneModulation",
          "name": "Skip",
          "package": "synthesizer",
          "partial": "Skip",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Basic-ToneModulation.html#t:Skip"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Basic.ToneModulation",
          "name": "det2",
          "package": "synthesizer",
          "signature": "((a, a), (a, a)) -\u003e a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Basic-ToneModulation.html#det2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Basic ToneModulation",
          "module": "Synthesizer.Basic.ToneModulation",
          "name": "det2",
          "normalized": "((a,a),(a,a))-\u003ea",
          "package": "synthesizer",
          "signature": "((a,a),(a,a))-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Basic-ToneModulation.html#v:det2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Basic.ToneModulation",
          "name": "flattenShapePhase",
          "package": "synthesizer",
          "signature": "Int -\u003e a -\u003e (a, T a) -\u003e (Int, (a, a))",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Basic-ToneModulation.html#flattenShapePhase",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Basic ToneModulation",
          "module": "Synthesizer.Basic.ToneModulation",
          "name": "flattenShapePhase",
          "normalized": "Int-\u003ea-\u003e(a,T a)-\u003e(Int,(a,a))",
          "package": "synthesizer",
          "partial": "Shape Phase",
          "signature": "Int-\u003ea-\u003e(a,T a)-\u003e(Int,(a,a))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Basic-ToneModulation.html#v:flattenShapePhase"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Basic.ToneModulation",
          "name": "flattenShapePhaseAnalytic",
          "package": "synthesizer",
          "signature": "Int -\u003e a -\u003e (a, T a) -\u003e (Int, (a, a))",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Basic-ToneModulation.html#flattenShapePhaseAnalytic",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Basic ToneModulation",
          "module": "Synthesizer.Basic.ToneModulation",
          "name": "flattenShapePhaseAnalytic",
          "normalized": "Int-\u003ea-\u003e(a,T a)-\u003e(Int,(a,a))",
          "package": "synthesizer",
          "partial": "Shape Phase Analytic",
          "signature": "Int-\u003ea-\u003e(a,T a)-\u003e(Int,(a,a))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Basic-ToneModulation.html#v:flattenShapePhaseAnalytic"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Basic.ToneModulation",
          "name": "interpolationNumber",
          "package": "synthesizer",
          "signature": "Margin -\u003e Margin -\u003e Int -\u003e Int",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Basic-ToneModulation.html#interpolationNumber",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Basic ToneModulation",
          "module": "Synthesizer.Basic.ToneModulation",
          "name": "interpolationNumber",
          "normalized": "Margin-\u003eMargin-\u003eInt-\u003eInt",
          "package": "synthesizer",
          "partial": "Number",
          "signature": "Margin-\u003eMargin-\u003eInt-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Basic-ToneModulation.html#v:interpolationNumber"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Basic.ToneModulation",
          "name": "interpolationOffset",
          "package": "synthesizer",
          "signature": "Margin -\u003e Margin -\u003e Int -\u003e Int",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Basic-ToneModulation.html#interpolationOffset",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Basic ToneModulation",
          "module": "Synthesizer.Basic.ToneModulation",
          "name": "interpolationOffset",
          "normalized": "Margin-\u003eMargin-\u003eInt-\u003eInt",
          "package": "synthesizer",
          "partial": "Offset",
          "signature": "Margin-\u003eMargin-\u003eInt-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Basic-ToneModulation.html#v:interpolationOffset"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Basic.ToneModulation",
          "name": "shapeLimits",
          "package": "synthesizer",
          "signature": "Margin -\u003e Margin -\u003e Int -\u003e t -\u003e (t, t)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Basic-ToneModulation.html#shapeLimits",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Basic ToneModulation",
          "module": "Synthesizer.Basic.ToneModulation",
          "name": "shapeLimits",
          "normalized": "Margin-\u003eMargin-\u003eInt-\u003ea-\u003e(a,a)",
          "package": "synthesizer",
          "partial": "Limits",
          "signature": "Margin-\u003eMargin-\u003eInt-\u003et-\u003e(t,t)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Basic-ToneModulation.html#v:shapeLimits"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Basic.ToneModulation",
          "name": "solveSLE2",
          "package": "synthesizer",
          "signature": "((a, a), (a, a)) -\u003e (a, a) -\u003e (a, a)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Basic-ToneModulation.html#solveSLE2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Basic ToneModulation",
          "module": "Synthesizer.Basic.ToneModulation",
          "name": "solveSLE2",
          "normalized": "((a,a),(a,a))-\u003e(a,a)-\u003e(a,a)",
          "package": "synthesizer",
          "partial": "SLE",
          "signature": "((a,a),(a,a))-\u003e(a,a)-\u003e(a,a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Basic-ToneModulation.html#v:solveSLE2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert from the (shape,phase) parameter pair\nto the index within a wave (step) and the index of a wave (leap)\nin the sampled prototype tone.\n\u003c/p\u003e\u003cp\u003eFor this routine it would be simpler,\nif \u003ctt\u003eshape\u003c/tt\u003e would measure in multiples of \u003ctt\u003eperiod\u003c/tt\u003e\n(we would only need a Ring instance),\nbut for shapeLimit it is better the way it is.\n\u003c/p\u003e",
          "module": "Synthesizer.Basic.ToneModulation",
          "name": "untangleShapePhase",
          "package": "synthesizer",
          "signature": "Int -\u003e a -\u003e (a, a) -\u003e (a, a)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Basic-ToneModulation.html#untangleShapePhase",
          "type": "function"
        },
        "index": {
          "description": "Convert from the shape phase parameter pair to the index within wave step and the index of wave leap in the sampled prototype tone For this routine it would be simpler if shape would measure in multiples of period we would only need Ring instance but for shapeLimit it is better the way it is",
          "hierarchy": "Synthesizer Basic ToneModulation",
          "module": "Synthesizer.Basic.ToneModulation",
          "name": "untangleShapePhase",
          "normalized": "Int-\u003ea-\u003e(a,a)-\u003e(a,a)",
          "package": "synthesizer",
          "partial": "Shape Phase",
          "signature": "Int-\u003ea-\u003e(a,a)-\u003e(a,a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Basic-ToneModulation.html#v:untangleShapePhase"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Basic.ToneModulation",
          "name": "untangleShapePhaseAnalytic",
          "package": "synthesizer",
          "signature": "Int -\u003e a -\u003e (a, a) -\u003e (a, a)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Basic-ToneModulation.html#untangleShapePhaseAnalytic",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Basic ToneModulation",
          "module": "Synthesizer.Basic.ToneModulation",
          "name": "untangleShapePhaseAnalytic",
          "normalized": "Int-\u003ea-\u003e(a,a)-\u003e(a,a)",
          "package": "synthesizer",
          "partial": "Shape Phase Analytic",
          "signature": "Int-\u003ea-\u003e(a,a)-\u003e(a,a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Basic-ToneModulation.html#v:untangleShapePhaseAnalytic"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Basic.Wave",
          "name": "Harmonic",
          "package": "synthesizer",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Basic-Wave.html#Harmonic",
          "type": "data"
        },
        "index": {
          "hierarchy": "Synthesizer Basic Wave",
          "module": "Synthesizer.Basic.Wave",
          "name": "Harmonic",
          "package": "synthesizer",
          "partial": "Harmonic",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Basic-Wave.html#t:Harmonic"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Basic.Wave",
          "name": "T",
          "package": "synthesizer",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Basic-Wave.html#T",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "Synthesizer Basic Wave",
          "module": "Synthesizer.Basic.Wave",
          "name": "T",
          "package": "synthesizer",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Basic-Wave.html#t:T"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Basic.Wave",
          "name": "affineComb",
          "package": "synthesizer",
          "signature": "a -\u003e (a, a) -\u003e a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Basic-Wave.html#affineComb",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Basic Wave",
          "module": "Synthesizer.Basic.Wave",
          "name": "affineComb",
          "normalized": "a-\u003e(a,a)-\u003ea",
          "package": "synthesizer",
          "partial": "Comb",
          "signature": "a-\u003e(a,a)-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Basic-Wave.html#v:affineComb"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Basic.Wave",
          "name": "amplify",
          "package": "synthesizer",
          "signature": "y -\u003e T t y -\u003e T t y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Basic-Wave.html#amplify",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Basic Wave",
          "module": "Synthesizer.Basic.Wave",
          "name": "amplify",
          "normalized": "a-\u003eT b a-\u003eT b a",
          "package": "synthesizer",
          "signature": "y-\u003eT t y-\u003eT t y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Basic-Wave.html#v:amplify"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Basic.Wave",
          "name": "apply",
          "package": "synthesizer",
          "signature": "T t y -\u003e T t -\u003e y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Basic-Wave.html#apply",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Basic Wave",
          "module": "Synthesizer.Basic.Wave",
          "name": "apply",
          "normalized": "T a b-\u003eT a-\u003eb",
          "package": "synthesizer",
          "signature": "T t y-\u003eT t-\u003ey",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Basic-Wave.html#v:apply"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSpecify the wave by its harmonics.\n\u003c/p\u003e\u003cp\u003eThe function is implemented quite efficiently\nby applying the Horner scheme to a polynomial with complex coefficients\n(the harmonic parameters)\nusing a complex exponential as argument.\n\u003c/p\u003e",
          "module": "Synthesizer.Basic.Wave",
          "name": "composedHarmonics",
          "package": "synthesizer",
          "signature": "[Harmonic a] -\u003e T a a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Basic-Wave.html#composedHarmonics",
          "type": "function"
        },
        "index": {
          "description": "Specify the wave by its harmonics The function is implemented quite efficiently by applying the Horner scheme to polynomial with complex coefficients the harmonic parameters using complex exponential as argument",
          "hierarchy": "Synthesizer Basic Wave",
          "module": "Synthesizer.Basic.Wave",
          "name": "composedHarmonics",
          "normalized": "[Harmonic a]-\u003eT a a",
          "package": "synthesizer",
          "partial": "Harmonics",
          "signature": "[Harmonic a]-\u003eT a a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Basic-Wave.html#v:composedHarmonics"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Basic.Wave",
          "name": "cosine",
          "package": "synthesizer",
          "signature": "T a a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Basic-Wave.html#cosine",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Basic Wave",
          "module": "Synthesizer.Basic.Wave",
          "name": "cosine",
          "package": "synthesizer",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Basic-Wave.html#v:cosine"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Basic.Wave",
          "name": "distort",
          "package": "synthesizer",
          "signature": "(y -\u003e z) -\u003e T t y -\u003e T t z",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Basic-Wave.html#distort",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Basic Wave",
          "module": "Synthesizer.Basic.Wave",
          "name": "distort",
          "normalized": "(a-\u003eb)-\u003eT c a-\u003eT c b",
          "package": "synthesizer",
          "signature": "(y-\u003ez)-\u003eT t y-\u003eT t z",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Basic-Wave.html#v:distort"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Approximation of sine by parabolas.\nSurprisingly not really faster than \u003ctt\u003e\u003ca\u003esine\u003c/a\u003e\u003c/tt\u003e.\n",
          "module": "Synthesizer.Basic.Wave",
          "name": "fastSine2",
          "package": "synthesizer",
          "signature": "T a a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Basic-Wave.html#fastSine2",
          "type": "function"
        },
        "index": {
          "description": "Approximation of sine by parabolas Surprisingly not really faster than sine",
          "hierarchy": "Synthesizer Basic Wave",
          "module": "Synthesizer.Basic.Wave",
          "name": "fastSine2",
          "package": "synthesizer",
          "partial": "Sine",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Basic-Wave.html#v:fastSine2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Approximation of sine by fourth order polynomials.\n",
          "module": "Synthesizer.Basic.Wave",
          "name": "fastSine4",
          "package": "synthesizer",
          "signature": "T a a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Basic-Wave.html#fastSine4",
          "type": "function"
        },
        "index": {
          "description": "Approximation of sine by fourth order polynomials",
          "hierarchy": "Synthesizer Basic Wave",
          "module": "Synthesizer.Basic.Wave",
          "name": "fastSine4",
          "package": "synthesizer",
          "partial": "Sine",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Basic-Wave.html#v:fastSine4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Basic.Wave",
          "name": "fromFunction",
          "package": "synthesizer",
          "signature": "(t -\u003e y) -\u003e T t y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Basic-Wave.html#fromFunction",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Basic Wave",
          "module": "Synthesizer.Basic.Wave",
          "name": "fromFunction",
          "normalized": "(a-\u003eb)-\u003eT a b",
          "package": "synthesizer",
          "partial": "Function",
          "signature": "(t-\u003ey)-\u003eT t y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Basic-Wave.html#v:fromFunction"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Synthesizer.Basic.Wave\",\"Synthesizer.Basic.WaveSmoothed\"]",
          "name": "harmonic",
          "package": "synthesizer",
          "signature": "T a -\u003e a -\u003e Harmonic a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Basic-Wave.html#harmonic",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Basic-Wave.html#v:harmonic\",\"http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Basic-WaveSmoothed.html#v:harmonic\"]"
        },
        "index": {
          "hierarchy": "Synthesizer Basic Wave",
          "module": "Synthesizer.Basic.Wave",
          "name": "harmonic",
          "normalized": "T a-\u003ea-\u003eHarmonic a",
          "package": "synthesizer",
          "signature": "T a-\u003ea-\u003eHarmonic a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Basic-Wave.html#v:harmonic"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Basic.Wave",
          "name": "helix",
          "package": "synthesizer",
          "signature": "T a (T a)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Basic-Wave.html#helix",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Basic Wave",
          "module": "Synthesizer.Basic.Wave",
          "name": "helix",
          "package": "synthesizer",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Basic-Wave.html#v:helix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Tangens hyperbolicus allows interpolation\nbetween some kind of saw tooth and square wave.\nIn principle it is not necessary\nbecause you can distort a saw tooth oscillation by \u003ctt\u003emap tanh\u003c/tt\u003e.\n",
          "module": "Synthesizer.Basic.Wave",
          "name": "logitSaw",
          "package": "synthesizer",
          "signature": "a -\u003e T a a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Basic-Wave.html#logitSaw",
          "type": "function"
        },
        "index": {
          "description": "Tangens hyperbolicus allows interpolation between some kind of saw tooth and square wave In principle it is not necessary because you can distort saw tooth oscillation by map tanh",
          "hierarchy": "Synthesizer Basic Wave",
          "module": "Synthesizer.Basic.Wave",
          "name": "logitSaw",
          "normalized": "a-\u003eT a a",
          "package": "synthesizer",
          "partial": "Saw",
          "signature": "a-\u003eT a a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Basic-Wave.html#v:logitSaw"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Tangens hyperbolicus of a sine allows interpolation\nbetween some kind of sine and square wave.\nIn principle it is not necessary\nbecause you can distort a square oscillation by \u003ctt\u003emap tanh\u003c/tt\u003e.\n",
          "module": "Synthesizer.Basic.Wave",
          "name": "logitSine",
          "package": "synthesizer",
          "signature": "a -\u003e T a a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Basic-Wave.html#logitSine",
          "type": "function"
        },
        "index": {
          "description": "Tangens hyperbolicus of sine allows interpolation between some kind of sine and square wave In principle it is not necessary because you can distort square oscillation by map tanh",
          "hierarchy": "Synthesizer Basic Wave",
          "module": "Synthesizer.Basic.Wave",
          "name": "logitSine",
          "normalized": "a-\u003eT a a",
          "package": "synthesizer",
          "partial": "Sine",
          "signature": "a-\u003eT a a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Basic-Wave.html#v:logitSine"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Basic.Wave",
          "name": "overtone",
          "package": "synthesizer",
          "signature": "n -\u003e T t y -\u003e T t y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Basic-Wave.html#overtone",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Basic Wave",
          "module": "Synthesizer.Basic.Wave",
          "name": "overtone",
          "normalized": "a-\u003eT b c-\u003eT b c",
          "package": "synthesizer",
          "signature": "n-\u003eT t y-\u003eT t y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Basic-Wave.html#v:overtone"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Turn an unparametrized waveform into a parametrized one,\nwhere the parameter is a phase offset.\nThis way you express a phase modulated oscillator\nusing a shape modulated oscillator.\n",
          "module": "Synthesizer.Basic.Wave",
          "name": "phaseOffset",
          "package": "synthesizer",
          "signature": "T a b -\u003e a -\u003e T a b",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Basic-Wave.html#phaseOffset",
          "type": "function"
        },
        "index": {
          "description": "Turn an unparametrized waveform into parametrized one where the parameter is phase offset This way you express phase modulated oscillator using shape modulated oscillator",
          "hierarchy": "Synthesizer Basic Wave",
          "module": "Synthesizer.Basic.Wave",
          "name": "phaseOffset",
          "normalized": "T a b-\u003ea-\u003eT a b",
          "package": "synthesizer",
          "partial": "Offset",
          "signature": "T a b-\u003ea-\u003eT a b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Basic-Wave.html#v:phaseOffset"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "0 for \u003ctt\u003e\u003ca\u003efastSine2\u003c/a\u003e\u003c/tt\u003e, 1 for \u003ctt\u003e\u003ca\u003esaw\u003c/a\u003e\u003c/tt\u003e \n",
          "module": "Synthesizer.Basic.Wave",
          "name": "piecewiseParabolaSaw",
          "package": "synthesizer",
          "signature": "a-\u003e T a a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Basic-Wave.html#piecewiseParabolaSaw",
          "type": "function"
        },
        "index": {
          "description": "for fastSine2 for saw",
          "hierarchy": "Synthesizer Basic Wave",
          "module": "Synthesizer.Basic.Wave",
          "name": "piecewiseParabolaSaw",
          "normalized": "a-\u003eT a a",
          "package": "synthesizer",
          "partial": "Parabola Saw",
          "signature": "a-\u003eT a a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Basic-Wave.html#v:piecewiseParabolaSaw"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "0 for \u003ctt\u003e\u003ca\u003esine\u003c/a\u003e\u003c/tt\u003e, 1 for \u003ctt\u003e\u003ca\u003esaw\u003c/a\u003e\u003c/tt\u003e \n",
          "module": "Synthesizer.Basic.Wave",
          "name": "piecewiseSineSaw",
          "package": "synthesizer",
          "signature": "a-\u003e T a a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Basic-Wave.html#piecewiseSineSaw",
          "type": "function"
        },
        "index": {
          "description": "for sine for saw",
          "hierarchy": "Synthesizer Basic Wave",
          "module": "Synthesizer.Basic.Wave",
          "name": "piecewiseSineSaw",
          "normalized": "a-\u003eT a a",
          "package": "synthesizer",
          "partial": "Sine Saw",
          "signature": "a-\u003eT a a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Basic-Wave.html#v:piecewiseSineSaw"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "auxiliary\n",
          "module": "Synthesizer.Basic.Wave",
          "name": "power01Normed",
          "package": "synthesizer",
          "signature": "a -\u003e a -\u003e a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Basic-Wave.html#power01Normed",
          "type": "function"
        },
        "index": {
          "description": "auxiliary",
          "hierarchy": "Synthesizer Basic Wave",
          "module": "Synthesizer.Basic.Wave",
          "name": "power01Normed",
          "normalized": "a-\u003ea-\u003ea",
          "package": "synthesizer",
          "partial": "Normed",
          "signature": "a-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Basic-Wave.html#v:power01Normed"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePower function.\n\u003c/p\u003e\u003cp\u003eRoughly the map \u003ctt\u003ex p -\u003e x**p\u003c/tt\u003e\nbut retains the sign of \u003ctt\u003ex\u003c/tt\u003e and\nnormalizes the mapping over \u003ctt\u003e[-1,1]\u003c/tt\u003e to L2 norm of 1.\n\u003c/p\u003e",
          "module": "Synthesizer.Basic.Wave",
          "name": "powerNormed",
          "package": "synthesizer",
          "signature": "a -\u003e T a a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Basic-Wave.html#powerNormed",
          "type": "function"
        },
        "index": {
          "description": "Power function Roughly the map but retains the sign of and normalizes the mapping over to L2 norm of",
          "hierarchy": "Synthesizer Basic Wave",
          "module": "Synthesizer.Basic.Wave",
          "name": "powerNormed",
          "normalized": "a-\u003eT a a",
          "package": "synthesizer",
          "partial": "Normed",
          "signature": "a-\u003eT a a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Basic-Wave.html#v:powerNormed"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "auxiliary\n",
          "module": "Synthesizer.Basic.Wave",
          "name": "powerSigned",
          "package": "synthesizer",
          "signature": "a -\u003e a -\u003e a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Basic-Wave.html#powerSigned",
          "type": "function"
        },
        "index": {
          "description": "auxiliary",
          "hierarchy": "Synthesizer Basic Wave",
          "module": "Synthesizer.Basic.Wave",
          "name": "powerSigned",
          "normalized": "a-\u003ea-\u003ea",
          "package": "synthesizer",
          "partial": "Signed",
          "signature": "a-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Basic-Wave.html#v:powerSigned"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Basic.Wave",
          "name": "raise",
          "package": "synthesizer",
          "signature": "y -\u003e T t y -\u003e T t y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Basic-Wave.html#raise",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Basic Wave",
          "module": "Synthesizer.Basic.Wave",
          "name": "raise",
          "normalized": "a-\u003eT b a-\u003eT b a",
          "package": "synthesizer",
          "signature": "y-\u003eT t y-\u003eT t y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Basic-Wave.html#v:raise"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "saw tooth,\nit's a ramp down in order to have a positive coefficient for the first partial sine\n",
          "module": "Synthesizer.Basic.Wave",
          "name": "saw",
          "package": "synthesizer",
          "signature": "T a a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Basic-Wave.html#saw",
          "type": "function"
        },
        "index": {
          "description": "saw tooth it ramp down in order to have positive coefficient for the first partial sine",
          "hierarchy": "Synthesizer Basic Wave",
          "module": "Synthesizer.Basic.Wave",
          "name": "saw",
          "package": "synthesizer",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Basic-Wave.html#v:saw"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cpre\u003esawCos + i*saw\u003c/pre\u003e\u003cp\u003eThis is an analytic function and thus it may be used for frequency shifting.\n\u003c/p\u003e\u003cp\u003eThe formula can be derived from the power series of the logarithm function.\n\u003c/p\u003e",
          "module": "Synthesizer.Basic.Wave",
          "name": "sawComplex",
          "package": "synthesizer",
          "signature": "T a (T a)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Basic-Wave.html#sawComplex",
          "type": "function"
        },
        "index": {
          "description": "sawCos saw This is an analytic function and thus it may be used for frequency shifting The formula can be derived from the power series of the logarithm function",
          "hierarchy": "Synthesizer Basic Wave",
          "module": "Synthesizer.Basic.Wave",
          "name": "sawComplex",
          "package": "synthesizer",
          "partial": "Complex",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Basic-Wave.html#v:sawComplex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "This wave has the same absolute Fourier coefficients as \u003ctt\u003e\u003ca\u003esaw\u003c/a\u003e\u003c/tt\u003e\nbut the partial waves are shifted by 90 degree.\nThat is, it is the Hilbert transform of the saw wave.\nThe formula is derived from \u003ctt\u003e\u003ca\u003esawComplex\u003c/a\u003e\u003c/tt\u003e.\n",
          "module": "Synthesizer.Basic.Wave",
          "name": "sawCos",
          "package": "synthesizer",
          "signature": "T a a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Basic-Wave.html#sawCos",
          "type": "function"
        },
        "index": {
          "description": "This wave has the same absolute Fourier coefficients as saw but the partial waves are shifted by degree That is it is the Hilbert transform of the saw wave The formula is derived from sawComplex",
          "hierarchy": "Synthesizer Basic Wave",
          "module": "Synthesizer.Basic.Wave",
          "name": "sawCos",
          "package": "synthesizer",
          "partial": "Cos",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Basic-Wave.html#v:sawCos"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "pike width ranging from 0 to 1, 1 yields \u003ctt\u003e\u003ca\u003esaw\u003c/a\u003e\u003c/tt\u003e \n",
          "module": "Synthesizer.Basic.Wave",
          "name": "sawPike",
          "package": "synthesizer",
          "signature": "a-\u003e T a a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Basic-Wave.html#sawPike",
          "type": "function"
        },
        "index": {
          "description": "pike width ranging from to yields saw",
          "hierarchy": "Synthesizer Basic Wave",
          "module": "Synthesizer.Basic.Wave",
          "name": "sawPike",
          "normalized": "a-\u003eT a a",
          "package": "synthesizer",
          "partial": "Pike",
          "signature": "a-\u003eT a a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Basic-Wave.html#v:sawPike"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "map a phase to value of a sine wave \n",
          "module": "Synthesizer.Basic.Wave",
          "name": "sine",
          "package": "synthesizer",
          "signature": "T a a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Basic-Wave.html#sine",
          "type": "function"
        },
        "index": {
          "description": "map phase to value of sine wave",
          "hierarchy": "Synthesizer Basic Wave",
          "module": "Synthesizer.Basic.Wave",
          "name": "sine",
          "package": "synthesizer",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Basic-Wave.html#v:sine"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "0 for \u003ctt\u003e\u003ca\u003esine\u003c/a\u003e\u003c/tt\u003e, 1 for \u003ctt\u003e\u003ca\u003esaw\u003c/a\u003e\u003c/tt\u003e \n",
          "module": "Synthesizer.Basic.Wave",
          "name": "sineSawSharp",
          "package": "synthesizer",
          "signature": "a-\u003e T a a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Basic-Wave.html#sineSawSharp",
          "type": "function"
        },
        "index": {
          "description": "for sine for saw",
          "hierarchy": "Synthesizer Basic Wave",
          "module": "Synthesizer.Basic.Wave",
          "name": "sineSawSharp",
          "normalized": "a-\u003eT a a",
          "package": "synthesizer",
          "partial": "Saw Sharp",
          "signature": "a-\u003eT a a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Basic-Wave.html#v:sineSawSharp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "0 for \u003ctt\u003e\u003ca\u003esine\u003c/a\u003e\u003c/tt\u003e, 1 for \u003ctt\u003e\u003ca\u003esaw\u003c/a\u003e\u003c/tt\u003e \n",
          "module": "Synthesizer.Basic.Wave",
          "name": "sineSawSmooth",
          "package": "synthesizer",
          "signature": "a-\u003e T a a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Basic-Wave.html#sineSawSmooth",
          "type": "function"
        },
        "index": {
          "description": "for sine for saw",
          "hierarchy": "Synthesizer Basic Wave",
          "module": "Synthesizer.Basic.Wave",
          "name": "sineSawSmooth",
          "normalized": "a-\u003eT a a",
          "package": "synthesizer",
          "partial": "Saw Smooth",
          "signature": "a-\u003eT a a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Basic-Wave.html#v:sineSawSmooth"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "0 for \u003ctt\u003e\u003ca\u003esine\u003c/a\u003e\u003c/tt\u003e, 1 for \u003ctt\u003e\u003ca\u003esquare\u003c/a\u003e\u003c/tt\u003e \n",
          "module": "Synthesizer.Basic.Wave",
          "name": "sineSquare",
          "package": "synthesizer",
          "signature": "a-\u003e T a a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Basic-Wave.html#sineSquare",
          "type": "function"
        },
        "index": {
          "description": "for sine for square",
          "hierarchy": "Synthesizer Basic Wave",
          "module": "Synthesizer.Basic.Wave",
          "name": "sineSquare",
          "normalized": "a-\u003eT a a",
          "package": "synthesizer",
          "partial": "Square",
          "signature": "a-\u003eT a a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Basic-Wave.html#v:sineSquare"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "square \n",
          "module": "Synthesizer.Basic.Wave",
          "name": "square",
          "package": "synthesizer",
          "signature": "T a a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Basic-Wave.html#square",
          "type": "function"
        },
        "index": {
          "description": "square",
          "hierarchy": "Synthesizer Basic Wave",
          "module": "Synthesizer.Basic.Wave",
          "name": "square",
          "package": "synthesizer",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Basic-Wave.html#v:square"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "value between -1 and 1 controlling the ratio of high and low time:\n              -1 turns the high time to zero,\n               1 makes the low time zero,\n               0 yields \u003ctt\u003e\u003ca\u003esquare\u003c/a\u003e\u003c/tt\u003e \n",
          "module": "Synthesizer.Basic.Wave",
          "name": "squareAsymmetric",
          "package": "synthesizer",
          "signature": "a-\u003e T a a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Basic-Wave.html#squareAsymmetric",
          "type": "function"
        },
        "index": {
          "description": "value between and controlling the ratio of high and low time turns the high time to zero makes the low time zero yields square",
          "hierarchy": "Synthesizer Basic Wave",
          "module": "Synthesizer.Basic.Wave",
          "name": "squareAsymmetric",
          "normalized": "a-\u003eT a a",
          "package": "synthesizer",
          "partial": "Asymmetric",
          "signature": "a-\u003eT a a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Basic-Wave.html#v:squareAsymmetric"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Like \u003ctt\u003e\u003ca\u003esquareAsymmetric\u003c/a\u003e\u003c/tt\u003e but with zero average.\nIt could be simulated by adding two saw oscillations\nwith 180 degree phase difference and opposite sign.\n",
          "module": "Synthesizer.Basic.Wave",
          "name": "squareBalanced",
          "package": "synthesizer",
          "signature": "a -\u003e T a a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Basic-Wave.html#squareBalanced",
          "type": "function"
        },
        "index": {
          "description": "Like squareAsymmetric but with zero average It could be simulated by adding two saw oscillations with degree phase difference and opposite sign",
          "hierarchy": "Synthesizer Basic Wave",
          "module": "Synthesizer.Basic.Wave",
          "name": "squareBalanced",
          "normalized": "a-\u003eT a a",
          "package": "synthesizer",
          "partial": "Balanced",
          "signature": "a-\u003eT a a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Basic-Wave.html#v:squareBalanced"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cpre\u003esquareCos + i*square\u003c/pre\u003e\u003cp\u003eThis is an analytic function and thus it may be used for frequency shifting.\n\u003c/p\u003e\u003cp\u003eThe formula can be derived from the power series of the area tangens function.\n\u003c/p\u003e",
          "module": "Synthesizer.Basic.Wave",
          "name": "squareComplex",
          "package": "synthesizer",
          "signature": "T a (T a)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Basic-Wave.html#squareComplex",
          "type": "function"
        },
        "index": {
          "description": "squareCos square This is an analytic function and thus it may be used for frequency shifting The formula can be derived from the power series of the area tangens function",
          "hierarchy": "Synthesizer Basic Wave",
          "module": "Synthesizer.Basic.Wave",
          "name": "squareComplex",
          "package": "synthesizer",
          "partial": "Complex",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Basic-Wave.html#v:squareComplex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "This wave has the same absolute Fourier coefficients as \u003ctt\u003e\u003ca\u003esquare\u003c/a\u003e\u003c/tt\u003e\nbut the partial waves are shifted by 90 degree.\nThat is, it is the Hilbert transform of the saw wave.\n",
          "module": "Synthesizer.Basic.Wave",
          "name": "squareCos",
          "package": "synthesizer",
          "signature": "T a a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Basic-Wave.html#squareCos",
          "type": "function"
        },
        "index": {
          "description": "This wave has the same absolute Fourier coefficients as square but the partial waves are shifted by degree That is it is the Hilbert transform of the saw wave",
          "hierarchy": "Synthesizer Basic Wave",
          "module": "Synthesizer.Basic.Wave",
          "name": "squareCos",
          "package": "synthesizer",
          "partial": "Cos",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Basic-Wave.html#v:squareCos"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "pike width ranging from 0 to 1, 1 yields \u003ctt\u003e\u003ca\u003esquare\u003c/a\u003e\u003c/tt\u003e \n",
          "module": "Synthesizer.Basic.Wave",
          "name": "squarePike",
          "package": "synthesizer",
          "signature": "a-\u003e T a a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Basic-Wave.html#squarePike",
          "type": "function"
        },
        "index": {
          "description": "pike width ranging from to yields square",
          "hierarchy": "Synthesizer Basic Wave",
          "module": "Synthesizer.Basic.Wave",
          "name": "squarePike",
          "normalized": "a-\u003eT a a",
          "package": "synthesizer",
          "partial": "Pike",
          "signature": "a-\u003eT a a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Basic-Wave.html#v:squarePike"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "pike width ranging from 0 to 1 \nshift ranges from -1 to 1; 0 yields \u003ctt\u003e\u003ca\u003esquarePike\u003c/a\u003e\u003c/tt\u003e \n",
          "module": "Synthesizer.Basic.Wave",
          "name": "squarePikeShift",
          "package": "synthesizer",
          "signature": "a-\u003e a-\u003e T a a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Basic-Wave.html#squarePikeShift",
          "type": "function"
        },
        "index": {
          "description": "pike width ranging from to shift ranges from to yields squarePike",
          "hierarchy": "Synthesizer Basic Wave",
          "module": "Synthesizer.Basic.Wave",
          "name": "squarePikeShift",
          "normalized": "a-\u003ea-\u003eT a a",
          "package": "synthesizer",
          "partial": "Pike Shift",
          "signature": "a-\u003ea-\u003eT a a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Basic-Wave.html#v:squarePikeShift"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "width of the plateau ranging from 0 to 1:\n              0 yields \u003ctt\u003e\u003ca\u003etriangle\u003c/a\u003e\u003c/tt\u003e, 1 yields \u003ctt\u003e\u003ca\u003esquare\u003c/a\u003e\u003c/tt\u003e \n",
          "module": "Synthesizer.Basic.Wave",
          "name": "trapezoid",
          "package": "synthesizer",
          "signature": "a-\u003e T a a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Basic-Wave.html#trapezoid",
          "type": "function"
        },
        "index": {
          "description": "width of the plateau ranging from to yields triangle yields square",
          "hierarchy": "Synthesizer Basic Wave",
          "module": "Synthesizer.Basic.Wave",
          "name": "trapezoid",
          "normalized": "a-\u003eT a a",
          "package": "synthesizer",
          "signature": "a-\u003eT a a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Basic-Wave.html#v:trapezoid"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "sum of the plateau widths ranging from 0 to 1:\n              0 yields \u003ctt\u003e\u003ca\u003etriangleAsymmetric\u003c/a\u003e\u003c/tt\u003e,\n              1 yields \u003ctt\u003e\u003ca\u003esquareAsymmetric\u003c/a\u003e\u003c/tt\u003e \nasymmetry of the plateau widths ranging from -1 to 1 \n",
          "module": "Synthesizer.Basic.Wave",
          "name": "trapezoidAsymmetric",
          "package": "synthesizer",
          "signature": "a-\u003e a-\u003e T a a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Basic-Wave.html#trapezoidAsymmetric",
          "type": "function"
        },
        "index": {
          "description": "sum of the plateau widths ranging from to yields triangleAsymmetric yields squareAsymmetric asymmetry of the plateau widths ranging from to",
          "hierarchy": "Synthesizer Basic Wave",
          "module": "Synthesizer.Basic.Wave",
          "name": "trapezoidAsymmetric",
          "normalized": "a-\u003ea-\u003eT a a",
          "package": "synthesizer",
          "partial": "Asymmetric",
          "signature": "a-\u003ea-\u003eT a a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Basic-Wave.html#v:trapezoidAsymmetric"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "trapezoid with distinct high and low time and zero direct current offset\n",
          "module": "Synthesizer.Basic.Wave",
          "name": "trapezoidBalanced",
          "package": "synthesizer",
          "signature": "a -\u003e a -\u003e T a a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Basic-Wave.html#trapezoidBalanced",
          "type": "function"
        },
        "index": {
          "description": "trapezoid with distinct high and low time and zero direct current offset",
          "hierarchy": "Synthesizer Basic Wave",
          "module": "Synthesizer.Basic.Wave",
          "name": "trapezoidBalanced",
          "normalized": "a-\u003ea-\u003eT a a",
          "package": "synthesizer",
          "partial": "Balanced",
          "signature": "a-\u003ea-\u003eT a a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Basic-Wave.html#v:trapezoidBalanced"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "width of the ramp,\n               that is 1 yields a downwards saw ramp\n               and 0 yields a square wave. \n",
          "module": "Synthesizer.Basic.Wave",
          "name": "trapezoidSkew",
          "package": "synthesizer",
          "signature": "a-\u003e T a a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Basic-Wave.html#trapezoidSkew",
          "type": "function"
        },
        "index": {
          "description": "width of the ramp that is yields downwards saw ramp and yields square wave",
          "hierarchy": "Synthesizer Basic Wave",
          "module": "Synthesizer.Basic.Wave",
          "name": "trapezoidSkew",
          "normalized": "a-\u003eT a a",
          "package": "synthesizer",
          "partial": "Skew",
          "signature": "a-\u003eT a a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Basic-Wave.html#v:trapezoidSkew"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "triangle \n",
          "module": "Synthesizer.Basic.Wave",
          "name": "triangle",
          "package": "synthesizer",
          "signature": "T a a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Basic-Wave.html#triangle",
          "type": "function"
        },
        "index": {
          "description": "triangle",
          "hierarchy": "Synthesizer Basic Wave",
          "module": "Synthesizer.Basic.Wave",
          "name": "triangle",
          "package": "synthesizer",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Basic-Wave.html#v:triangle"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "asymmetry parameter ranging from -1 to 1:\n              For 0 you obtain the usual triangle.\n              For -1 you obtain a falling saw tooth starting with its maximum.\n              For 1 you obtain a rising saw tooth starting with a zero. \n",
          "module": "Synthesizer.Basic.Wave",
          "name": "triangleAsymmetric",
          "package": "synthesizer",
          "signature": "a-\u003e T a a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Basic-Wave.html#triangleAsymmetric",
          "type": "function"
        },
        "index": {
          "description": "asymmetry parameter ranging from to For you obtain the usual triangle For you obtain falling saw tooth starting with its maximum For you obtain rising saw tooth starting with zero",
          "hierarchy": "Synthesizer Basic Wave",
          "module": "Synthesizer.Basic.Wave",
          "name": "triangleAsymmetric",
          "normalized": "a-\u003eT a a",
          "package": "synthesizer",
          "partial": "Asymmetric",
          "signature": "a-\u003eT a a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Basic-Wave.html#v:triangleAsymmetric"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "pike width ranging from 0 to 1, 1 yields \u003ctt\u003e\u003ca\u003etriangle\u003c/a\u003e\u003c/tt\u003e \n",
          "module": "Synthesizer.Basic.Wave",
          "name": "trianglePike",
          "package": "synthesizer",
          "signature": "a-\u003e T a a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Basic-Wave.html#trianglePike",
          "type": "function"
        },
        "index": {
          "description": "pike width ranging from to yields triangle",
          "hierarchy": "Synthesizer Basic Wave",
          "module": "Synthesizer.Basic.Wave",
          "name": "trianglePike",
          "normalized": "a-\u003eT a a",
          "package": "synthesizer",
          "partial": "Pike",
          "signature": "a-\u003eT a a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Basic-Wave.html#v:trianglePike"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "pike width ranging from 0 to 1 \nshift ranges from -1 to 1; 0 yields \u003ctt\u003e\u003ca\u003etrianglePike\u003c/a\u003e\u003c/tt\u003e \n",
          "module": "Synthesizer.Basic.Wave",
          "name": "trianglePikeShift",
          "package": "synthesizer",
          "signature": "a-\u003e a-\u003e T a a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Basic-Wave.html#trianglePikeShift",
          "type": "function"
        },
        "index": {
          "description": "pike width ranging from to shift ranges from to yields trianglePike",
          "hierarchy": "Synthesizer Basic Wave",
          "module": "Synthesizer.Basic.Wave",
          "name": "trianglePikeShift",
          "normalized": "a-\u003ea-\u003eT a a",
          "package": "synthesizer",
          "partial": "Pike Shift",
          "signature": "a-\u003ea-\u003eT a a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Basic-Wave.html#v:trianglePikeShift"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA truncated cosine plus a ramp that guarantees a bump of high 2 at the boundaries.\n\u003c/p\u003e\u003cp\u003eIt is \u003ctt\u003etruncCosine (2 * fromIntegral n + 0.5) == truncOddCosine (2*n)\u003c/tt\u003e\n\u003c/p\u003e",
          "module": "Synthesizer.Basic.Wave",
          "name": "truncCosine",
          "package": "synthesizer",
          "signature": "a -\u003e T a a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Basic-Wave.html#truncCosine",
          "type": "function"
        },
        "index": {
          "description": "truncated cosine plus ramp that guarantees bump of high at the boundaries It is truncCosine fromIntegral truncOddCosine",
          "hierarchy": "Synthesizer Basic Wave",
          "module": "Synthesizer.Basic.Wave",
          "name": "truncCosine",
          "normalized": "a-\u003eT a a",
          "package": "synthesizer",
          "partial": "Cosine",
          "signature": "a-\u003eT a a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Basic-Wave.html#v:truncCosine"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "A truncated cosine. This has rich overtones.\n",
          "module": "Synthesizer.Basic.Wave",
          "name": "truncOddCosine",
          "package": "synthesizer",
          "signature": "Int -\u003e T a a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Basic-Wave.html#truncOddCosine",
          "type": "function"
        },
        "index": {
          "description": "truncated cosine This has rich overtones",
          "hierarchy": "Synthesizer Basic Wave",
          "module": "Synthesizer.Basic.Wave",
          "name": "truncOddCosine",
          "normalized": "Int-\u003eT a a",
          "package": "synthesizer",
          "partial": "Odd Cosine",
          "signature": "Int-\u003eT a a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Basic-Wave.html#v:truncOddCosine"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "For parameter zero this is \u003ctt\u003e\u003ca\u003esaw\u003c/a\u003e\u003c/tt\u003e.\n",
          "module": "Synthesizer.Basic.Wave",
          "name": "truncOddTriangle",
          "package": "synthesizer",
          "signature": "Int -\u003e T a a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Basic-Wave.html#truncOddTriangle",
          "type": "function"
        },
        "index": {
          "description": "For parameter zero this is saw",
          "hierarchy": "Synthesizer Basic Wave",
          "module": "Synthesizer.Basic.Wave",
          "name": "truncOddTriangle",
          "normalized": "Int-\u003eT a a",
          "package": "synthesizer",
          "partial": "Odd Triangle",
          "signature": "Int-\u003eT a a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Basic-Wave.html#v:truncOddTriangle"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Basic.Wave",
          "name": "truncTriangle",
          "package": "synthesizer",
          "signature": "a -\u003e T a a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Basic-Wave.html#truncTriangle",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Basic Wave",
          "module": "Synthesizer.Basic.Wave",
          "name": "truncTriangle",
          "normalized": "a-\u003eT a a",
          "package": "synthesizer",
          "partial": "Triangle",
          "signature": "a-\u003eT a a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Basic-Wave.html#v:truncTriangle"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Basic.WaveSmoothed",
          "name": "Harmonic",
          "package": "synthesizer",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Basic-Wave.html#Harmonic",
          "type": "data"
        },
        "index": {
          "hierarchy": "Synthesizer Basic WaveSmoothed",
          "module": "Synthesizer.Basic.WaveSmoothed",
          "name": "Harmonic",
          "package": "synthesizer",
          "partial": "Harmonic",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Basic-WaveSmoothed.html#t:Harmonic"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Basic.WaveSmoothed",
          "name": "T",
          "package": "synthesizer",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Basic-WaveSmoothed.html#T",
          "type": "data"
        },
        "index": {
          "hierarchy": "Synthesizer Basic WaveSmoothed",
          "module": "Synthesizer.Basic.WaveSmoothed",
          "name": "T",
          "package": "synthesizer",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Basic-WaveSmoothed.html#t:T"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Basic.WaveSmoothed",
          "name": "amplify",
          "package": "synthesizer",
          "signature": "y -\u003e T t y -\u003e T t y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Basic-WaveSmoothed.html#amplify",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Basic WaveSmoothed",
          "module": "Synthesizer.Basic.WaveSmoothed",
          "name": "amplify",
          "normalized": "a-\u003eT b a-\u003eT b a",
          "package": "synthesizer",
          "signature": "y-\u003eT t y-\u003eT t y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Basic-WaveSmoothed.html#v:amplify"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Basic.WaveSmoothed",
          "name": "apply",
          "package": "synthesizer",
          "signature": "T t y -\u003e t -\u003e T t -\u003e y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Basic-WaveSmoothed.html#apply",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Basic WaveSmoothed",
          "module": "Synthesizer.Basic.WaveSmoothed",
          "name": "apply",
          "normalized": "T a b-\u003ea-\u003eT a-\u003eb",
          "package": "synthesizer",
          "signature": "T t y-\u003et-\u003eT t-\u003ey",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Basic-WaveSmoothed.html#v:apply"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSpecify the wave by its harmonics.\n\u003c/p\u003e\u003cp\u003eThe function is implemented quite efficiently\nby applying the Horner scheme to a polynomial with complex coefficients\n(the harmonic parameters)\nusing a complex exponential as argument.\n\u003c/p\u003e",
          "module": "Synthesizer.Basic.WaveSmoothed",
          "name": "composedHarmonics",
          "package": "synthesizer",
          "signature": "[Harmonic a] -\u003e T a a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Basic-WaveSmoothed.html#composedHarmonics",
          "type": "function"
        },
        "index": {
          "description": "Specify the wave by its harmonics The function is implemented quite efficiently by applying the Horner scheme to polynomial with complex coefficients the harmonic parameters using complex exponential as argument",
          "hierarchy": "Synthesizer Basic WaveSmoothed",
          "module": "Synthesizer.Basic.WaveSmoothed",
          "name": "composedHarmonics",
          "normalized": "[Harmonic a]-\u003eT a a",
          "package": "synthesizer",
          "partial": "Harmonics",
          "signature": "[Harmonic a]-\u003eT a a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Basic-WaveSmoothed.html#v:composedHarmonics"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Basic.WaveSmoothed",
          "name": "cosine",
          "package": "synthesizer",
          "signature": "T a a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Basic-WaveSmoothed.html#cosine",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Basic WaveSmoothed",
          "module": "Synthesizer.Basic.WaveSmoothed",
          "name": "cosine",
          "package": "synthesizer",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Basic-WaveSmoothed.html#v:cosine"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Basic.WaveSmoothed",
          "name": "distort",
          "package": "synthesizer",
          "signature": "(y -\u003e z) -\u003e T t y -\u003e T t z",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Basic-WaveSmoothed.html#distort",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Basic WaveSmoothed",
          "module": "Synthesizer.Basic.WaveSmoothed",
          "name": "distort",
          "normalized": "(a-\u003eb)-\u003eT c a-\u003eT c b",
          "package": "synthesizer",
          "signature": "(y-\u003ez)-\u003eT t y-\u003eT t z",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Basic-WaveSmoothed.html#v:distort"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Basic.WaveSmoothed",
          "name": "fromControlledWave",
          "package": "synthesizer",
          "signature": "(t -\u003e T t y) -\u003e T t y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Basic-WaveSmoothed.html#fromControlledWave",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Basic WaveSmoothed",
          "module": "Synthesizer.Basic.WaveSmoothed",
          "name": "fromControlledWave",
          "normalized": "(a-\u003eT a b)-\u003eT a b",
          "package": "synthesizer",
          "partial": "Controlled Wave",
          "signature": "(t-\u003eT t y)-\u003eT t y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Basic-WaveSmoothed.html#v:fromControlledWave"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Basic.WaveSmoothed",
          "name": "fromFunction",
          "package": "synthesizer",
          "signature": "(t -\u003e t -\u003e y) -\u003e T t y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Basic-WaveSmoothed.html#fromFunction",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Basic WaveSmoothed",
          "module": "Synthesizer.Basic.WaveSmoothed",
          "name": "fromFunction",
          "normalized": "(a-\u003ea-\u003eb)-\u003eT a b",
          "package": "synthesizer",
          "partial": "Function",
          "signature": "(t-\u003et-\u003ey)-\u003eT t y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Basic-WaveSmoothed.html#v:fromFunction"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Use this function for waves which are sufficiently smooth.\nIf the Nyquist frequency is exceeded the wave is simply replaced\nby a constant zero wave.\n",
          "module": "Synthesizer.Basic.WaveSmoothed",
          "name": "fromWave",
          "package": "synthesizer",
          "signature": "T t y -\u003e T t y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Basic-WaveSmoothed.html#fromWave",
          "type": "function"
        },
        "index": {
          "description": "Use this function for waves which are sufficiently smooth If the Nyquist frequency is exceeded the wave is simply replaced by constant zero wave",
          "hierarchy": "Synthesizer Basic WaveSmoothed",
          "module": "Synthesizer.Basic.WaveSmoothed",
          "name": "fromWave",
          "normalized": "T a b-\u003eT a b",
          "package": "synthesizer",
          "partial": "Wave",
          "signature": "T t y-\u003eT t y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Basic-WaveSmoothed.html#v:fromWave"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Basic.WaveSmoothed",
          "name": "raise",
          "package": "synthesizer",
          "signature": "y -\u003e T t y -\u003e T t y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Basic-WaveSmoothed.html#raise",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Basic WaveSmoothed",
          "module": "Synthesizer.Basic.WaveSmoothed",
          "name": "raise",
          "normalized": "a-\u003eT b a-\u003eT b a",
          "package": "synthesizer",
          "signature": "y-\u003eT t y-\u003eT t y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Basic-WaveSmoothed.html#v:raise"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "saw tooth,\nit's a ramp down in order to have a positive coefficient for the first partial sine\n",
          "module": "Synthesizer.Basic.WaveSmoothed",
          "name": "saw",
          "package": "synthesizer",
          "signature": "T a a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Basic-WaveSmoothed.html#saw",
          "type": "function"
        },
        "index": {
          "description": "saw tooth it ramp down in order to have positive coefficient for the first partial sine",
          "hierarchy": "Synthesizer Basic WaveSmoothed",
          "module": "Synthesizer.Basic.WaveSmoothed",
          "name": "saw",
          "package": "synthesizer",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Basic-WaveSmoothed.html#v:saw"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "map a phase to value of a sine wave \n",
          "module": "Synthesizer.Basic.WaveSmoothed",
          "name": "sine",
          "package": "synthesizer",
          "signature": "T a a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Basic-WaveSmoothed.html#sine",
          "type": "function"
        },
        "index": {
          "description": "map phase to value of sine wave",
          "hierarchy": "Synthesizer Basic WaveSmoothed",
          "module": "Synthesizer.Basic.WaveSmoothed",
          "name": "sine",
          "package": "synthesizer",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Basic-WaveSmoothed.html#v:sine"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "square \n",
          "module": "Synthesizer.Basic.WaveSmoothed",
          "name": "square",
          "package": "synthesizer",
          "signature": "T a a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Basic-WaveSmoothed.html#square",
          "type": "function"
        },
        "index": {
          "description": "square",
          "hierarchy": "Synthesizer Basic WaveSmoothed",
          "module": "Synthesizer.Basic.WaveSmoothed",
          "name": "square",
          "package": "synthesizer",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Basic-WaveSmoothed.html#v:square"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "triangle \n",
          "module": "Synthesizer.Basic.WaveSmoothed",
          "name": "triangle",
          "package": "synthesizer",
          "signature": "T a a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Basic-WaveSmoothed.html#triangle",
          "type": "function"
        },
        "index": {
          "description": "triangle",
          "hierarchy": "Synthesizer Basic WaveSmoothed",
          "module": "Synthesizer.Basic.WaveSmoothed",
          "name": "triangle",
          "package": "synthesizer",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Basic-WaveSmoothed.html#v:triangle"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "In \u003ca\u003eSynthesizer.Basic.Distortion\u003c/a\u003e you find a collection\nof appropriate distortion functions.\n",
          "module": "Synthesizer.Causal.Displacement",
          "name": "distort",
          "package": "synthesizer",
          "signature": "(c -\u003e a -\u003e a) -\u003e T (c, a) a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Causal-Displacement.html#distort",
          "type": "function"
        },
        "index": {
          "description": "In Synthesizer.Basic.Distortion you find collection of appropriate distortion functions",
          "hierarchy": "Synthesizer Causal Displacement",
          "module": "Synthesizer.Causal.Displacement",
          "name": "distort",
          "normalized": "(a-\u003eb-\u003eb)-\u003eT(a,b)b",
          "package": "synthesizer",
          "signature": "(c-\u003ea-\u003ea)-\u003eT(c,a)a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Causal-Displacement.html#v:distort"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Mix two signals.\nUnfortunately we have to use \u003ctt\u003e\u003ca\u003ezipWith\u003c/a\u003e\u003c/tt\u003e semantic here,\nthat is the result is as long as the shorter of both inputs.\n",
          "module": "Synthesizer.Causal.Displacement",
          "name": "mix",
          "package": "synthesizer",
          "signature": "T (v, v) v",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Causal-Displacement.html#mix",
          "type": "function"
        },
        "index": {
          "description": "Mix two signals Unfortunately we have to use zipWith semantic here that is the result is as long as the shorter of both inputs",
          "hierarchy": "Synthesizer Causal Displacement",
          "module": "Synthesizer.Causal.Displacement",
          "name": "mix",
          "normalized": "T(a,a)a",
          "package": "synthesizer",
          "signature": "T(v,v)v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Causal-Displacement.html#v:mix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Add a number to all of the signal values.\nThis is useful for adjusting the center of a modulation.\n",
          "module": "Synthesizer.Causal.Displacement",
          "name": "raise",
          "package": "synthesizer",
          "signature": "v -\u003e T v v",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Causal-Displacement.html#raise",
          "type": "function"
        },
        "index": {
          "description": "Add number to all of the signal values This is useful for adjusting the center of modulation",
          "hierarchy": "Synthesizer Causal Displacement",
          "module": "Synthesizer.Causal.Displacement",
          "name": "raise",
          "normalized": "a-\u003eT a a",
          "package": "synthesizer",
          "signature": "v-\u003eT v v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Causal-Displacement.html#v:raise"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Causal.Interpolation",
          "name": "T",
          "package": "synthesizer",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Interpolation.html#T",
          "type": "data"
        },
        "index": {
          "hierarchy": "Synthesizer Causal Interpolation",
          "module": "Synthesizer.Causal.Interpolation",
          "name": "T",
          "package": "synthesizer",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Causal-Interpolation.html#t:T"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "All values of frequency control must be non-negative. \n",
          "module": "Synthesizer.Causal.Interpolation",
          "name": "relative",
          "package": "synthesizer",
          "signature": "T t y -\u003e t -\u003e T y -\u003e T t y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Causal-Interpolation.html#relative",
          "type": "function"
        },
        "index": {
          "description": "All values of frequency control must be non-negative",
          "hierarchy": "Synthesizer Causal Interpolation",
          "module": "Synthesizer.Causal.Interpolation",
          "name": "relative",
          "normalized": "T a b-\u003ea-\u003eT b-\u003eT a b",
          "package": "synthesizer",
          "signature": "T t y-\u003et-\u003eT y-\u003eT t y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Causal-Interpolation.html#v:relative"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Causal.Interpolation",
          "name": "relativeConstantPad",
          "package": "synthesizer",
          "signature": "T t y -\u003e t -\u003e T y -\u003e T t y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Causal-Interpolation.html#relativeConstantPad",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Causal Interpolation",
          "module": "Synthesizer.Causal.Interpolation",
          "name": "relativeConstantPad",
          "normalized": "T a b-\u003ea-\u003eT b-\u003eT a b",
          "package": "synthesizer",
          "partial": "Constant Pad",
          "signature": "T t y-\u003et-\u003eT y-\u003eT t y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Causal-Interpolation.html#v:relativeConstantPad"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Causal.Interpolation",
          "name": "relativeCyclicPad",
          "package": "synthesizer",
          "signature": "T t y -\u003e t -\u003e T y -\u003e T t y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Causal-Interpolation.html#relativeCyclicPad",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Causal Interpolation",
          "module": "Synthesizer.Causal.Interpolation",
          "name": "relativeCyclicPad",
          "normalized": "T a b-\u003ea-\u003eT b-\u003eT a b",
          "package": "synthesizer",
          "partial": "Cyclic Pad",
          "signature": "T t y-\u003et-\u003eT y-\u003eT t y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Causal-Interpolation.html#v:relativeCyclicPad"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "The extrapolation may miss some of the first and some of the last points\n",
          "module": "Synthesizer.Causal.Interpolation",
          "name": "relativeExtrapolationPad",
          "package": "synthesizer",
          "signature": "T t y -\u003e t -\u003e T y -\u003e T t y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Causal-Interpolation.html#relativeExtrapolationPad",
          "type": "function"
        },
        "index": {
          "description": "The extrapolation may miss some of the first and some of the last points",
          "hierarchy": "Synthesizer Causal Interpolation",
          "module": "Synthesizer.Causal.Interpolation",
          "name": "relativeExtrapolationPad",
          "normalized": "T a b-\u003ea-\u003eT b-\u003eT a b",
          "package": "synthesizer",
          "partial": "Extrapolation Pad",
          "signature": "T t y-\u003et-\u003eT y-\u003eT t y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Causal-Interpolation.html#v:relativeExtrapolationPad"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Causal.Interpolation",
          "name": "relativeZeroPad",
          "package": "synthesizer",
          "signature": "y -\u003e T t y -\u003e t -\u003e T y -\u003e T t y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Causal-Interpolation.html#relativeZeroPad",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Causal Interpolation",
          "module": "Synthesizer.Causal.Interpolation",
          "name": "relativeZeroPad",
          "normalized": "a-\u003eT b a-\u003eb-\u003eT a-\u003eT b a",
          "package": "synthesizer",
          "partial": "Zero Pad",
          "signature": "y-\u003eT t y-\u003et-\u003eT y-\u003eT t y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Causal-Interpolation.html#v:relativeZeroPad"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Causal.Interpolation",
          "name": "relativeZeroPadConstant",
          "package": "synthesizer",
          "signature": "t -\u003e T y -\u003e T t y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Causal-Interpolation.html#relativeZeroPadConstant",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Causal Interpolation",
          "module": "Synthesizer.Causal.Interpolation",
          "name": "relativeZeroPadConstant",
          "normalized": "a-\u003eT b-\u003eT a b",
          "package": "synthesizer",
          "partial": "Zero Pad Constant",
          "signature": "t-\u003eT y-\u003eT t y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Causal-Interpolation.html#v:relativeZeroPadConstant"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Causal.Interpolation",
          "name": "relativeZeroPadCubic",
          "package": "synthesizer",
          "signature": "t -\u003e T y -\u003e T t y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Causal-Interpolation.html#relativeZeroPadCubic",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Causal Interpolation",
          "module": "Synthesizer.Causal.Interpolation",
          "name": "relativeZeroPadCubic",
          "normalized": "a-\u003eT b-\u003eT a b",
          "package": "synthesizer",
          "partial": "Zero Pad Cubic",
          "signature": "t-\u003eT y-\u003eT t y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Causal-Interpolation.html#v:relativeZeroPadCubic"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Causal.Interpolation",
          "name": "relativeZeroPadLinear",
          "package": "synthesizer",
          "signature": "t -\u003e T y -\u003e T t y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Causal-Interpolation.html#relativeZeroPadLinear",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Causal Interpolation",
          "module": "Synthesizer.Causal.Interpolation",
          "name": "relativeZeroPadLinear",
          "normalized": "a-\u003eT b-\u003eT a b",
          "package": "synthesizer",
          "partial": "Zero Pad Linear",
          "signature": "t-\u003eT y-\u003eT t y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Causal-Interpolation.html#v:relativeZeroPadLinear"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "oscillator with modulated frequency \n",
          "module": "Synthesizer.Causal.Oscillator",
          "name": "freqMod",
          "package": "synthesizer",
          "signature": "T a b -\u003e T a -\u003e T a b",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Causal-Oscillator.html#freqMod",
          "type": "function"
        },
        "index": {
          "description": "oscillator with modulated frequency",
          "hierarchy": "Synthesizer Causal Oscillator",
          "module": "Synthesizer.Causal.Oscillator",
          "name": "freqMod",
          "normalized": "T a b-\u003eT a-\u003eT a b",
          "package": "synthesizer",
          "partial": "Mod",
          "signature": "T a b-\u003eT a-\u003eT a b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Causal-Oscillator.html#v:freqMod"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "oscillator with modulated frequency \n",
          "module": "Synthesizer.Causal.Oscillator",
          "name": "freqModAntiAlias",
          "package": "synthesizer",
          "signature": "T a b -\u003e T a -\u003e T a b",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Causal-Oscillator.html#freqModAntiAlias",
          "type": "function"
        },
        "index": {
          "description": "oscillator with modulated frequency",
          "hierarchy": "Synthesizer Causal Oscillator",
          "module": "Synthesizer.Causal.Oscillator",
          "name": "freqModAntiAlias",
          "normalized": "T a b-\u003eT a-\u003eT a b",
          "package": "synthesizer",
          "partial": "Mod Anti Alias",
          "signature": "T a b-\u003eT a-\u003eT a b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Causal-Oscillator.html#v:freqModAntiAlias"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "oscillator with a sampled waveform with modulated frequency\n     Should behave homogenously for different types of interpolation. \n",
          "module": "Synthesizer.Causal.Oscillator",
          "name": "freqModSample",
          "package": "synthesizer",
          "signature": "T a b -\u003e T b -\u003e T a -\u003e T a b",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Causal-Oscillator.html#freqModSample",
          "type": "function"
        },
        "index": {
          "description": "oscillator with sampled waveform with modulated frequency Should behave homogenously for different types of interpolation",
          "hierarchy": "Synthesizer Causal Oscillator",
          "module": "Synthesizer.Causal.Oscillator",
          "name": "freqModSample",
          "normalized": "T a b-\u003eT b-\u003eT a-\u003eT a b",
          "package": "synthesizer",
          "partial": "Mod Sample",
          "signature": "T a b-\u003eT b-\u003eT a-\u003eT a b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Causal-Oscillator.html#v:freqModSample"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "saw tooth oscillator with modulated frequency \n",
          "module": "Synthesizer.Causal.Oscillator",
          "name": "freqModSaw",
          "package": "synthesizer",
          "signature": "T a -\u003e T a a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Causal-Oscillator.html#freqModSaw",
          "type": "function"
        },
        "index": {
          "description": "saw tooth oscillator with modulated frequency",
          "hierarchy": "Synthesizer Causal Oscillator",
          "module": "Synthesizer.Causal.Oscillator",
          "name": "freqModSaw",
          "normalized": "T a-\u003eT a a",
          "package": "synthesizer",
          "partial": "Mod Saw",
          "signature": "T a-\u003eT a a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Causal-Oscillator.html#v:freqModSaw"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "sine oscillator with modulated frequency \n",
          "module": "Synthesizer.Causal.Oscillator",
          "name": "freqModSine",
          "package": "synthesizer",
          "signature": "T a -\u003e T a a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Causal-Oscillator.html#freqModSine",
          "type": "function"
        },
        "index": {
          "description": "sine oscillator with modulated frequency",
          "hierarchy": "Synthesizer Causal Oscillator",
          "module": "Synthesizer.Causal.Oscillator",
          "name": "freqModSine",
          "normalized": "T a-\u003eT a a",
          "package": "synthesizer",
          "partial": "Mod Sine",
          "signature": "T a-\u003eT a a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Causal-Oscillator.html#v:freqModSine"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Causal.Oscillator",
          "name": "freqToPhases",
          "package": "synthesizer",
          "signature": "T a -\u003e a -\u003e T (T a)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Causal-Oscillator.html#freqToPhases",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Causal Oscillator",
          "module": "Synthesizer.Causal.Oscillator",
          "name": "freqToPhases",
          "normalized": "T a-\u003ea-\u003eT(T a)",
          "package": "synthesizer",
          "partial": "To Phases",
          "signature": "T a-\u003ea-\u003eT(T a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Causal-Oscillator.html#v:freqToPhases"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "oscillator with both phase and frequency modulation \n",
          "module": "Synthesizer.Causal.Oscillator",
          "name": "phaseFreqMod",
          "package": "synthesizer",
          "signature": "T a b -\u003e T (a, a) b",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Causal-Oscillator.html#phaseFreqMod",
          "type": "function"
        },
        "index": {
          "description": "oscillator with both phase and frequency modulation",
          "hierarchy": "Synthesizer Causal Oscillator",
          "module": "Synthesizer.Causal.Oscillator",
          "name": "phaseFreqMod",
          "normalized": "T a b-\u003eT(a,a)b",
          "package": "synthesizer",
          "partial": "Freq Mod",
          "signature": "T a b-\u003eT(a,a)b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Causal-Oscillator.html#v:phaseFreqMod"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "oscillator with modulated phase \n",
          "module": "Synthesizer.Causal.Oscillator",
          "name": "phaseMod",
          "package": "synthesizer",
          "signature": "T a b -\u003e a -\u003e T a b",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Causal-Oscillator.html#phaseMod",
          "type": "function"
        },
        "index": {
          "description": "oscillator with modulated phase",
          "hierarchy": "Synthesizer Causal Oscillator",
          "module": "Synthesizer.Causal.Oscillator",
          "name": "phaseMod",
          "normalized": "T a b-\u003ea-\u003eT a b",
          "package": "synthesizer",
          "partial": "Mod",
          "signature": "T a b-\u003ea-\u003eT a b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Causal-Oscillator.html#v:phaseMod"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "sine oscillator with modulated phase, useful for FM synthesis \n",
          "module": "Synthesizer.Causal.Oscillator",
          "name": "phaseModSine",
          "package": "synthesizer",
          "signature": "a -\u003e T a a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Causal-Oscillator.html#phaseModSine",
          "type": "function"
        },
        "index": {
          "description": "sine oscillator with modulated phase useful for FM synthesis",
          "hierarchy": "Synthesizer Causal Oscillator",
          "module": "Synthesizer.Causal.Oscillator",
          "name": "phaseModSine",
          "normalized": "a-\u003eT a a",
          "package": "synthesizer",
          "partial": "Mod Sine",
          "signature": "a-\u003eT a a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Causal-Oscillator.html#v:phaseModSine"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "oscillator with both shape and frequency modulation \n",
          "module": "Synthesizer.Causal.Oscillator",
          "name": "shapeFreqMod",
          "package": "synthesizer",
          "signature": "(c -\u003e T a b) -\u003e T a -\u003e T (c, a) b",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Causal-Oscillator.html#shapeFreqMod",
          "type": "function"
        },
        "index": {
          "description": "oscillator with both shape and frequency modulation",
          "hierarchy": "Synthesizer Causal Oscillator",
          "module": "Synthesizer.Causal.Oscillator",
          "name": "shapeFreqMod",
          "normalized": "(a-\u003eT b c)-\u003eT b-\u003eT(a,b)c",
          "package": "synthesizer",
          "partial": "Freq Mod",
          "signature": "(c-\u003eT a b)-\u003eT a-\u003eT(c,a)b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Causal-Oscillator.html#v:shapeFreqMod"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Causal.Oscillator",
          "name": "shapeFreqModFromSampledTone",
          "package": "synthesizer",
          "signature": "T t y -\u003e T t y -\u003e t -\u003e sig y -\u003e t -\u003e T t -\u003e T (t, t) y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Causal-Oscillator.html#shapeFreqModFromSampledTone",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Causal Oscillator",
          "module": "Synthesizer.Causal.Oscillator",
          "name": "shapeFreqModFromSampledTone",
          "normalized": "T a b-\u003eT a b-\u003ea-\u003ec b-\u003ea-\u003eT a-\u003eT(a,a)b",
          "package": "synthesizer",
          "partial": "Freq Mod From Sampled Tone",
          "signature": "T t y-\u003eT t y-\u003et-\u003esig y-\u003et-\u003eT t-\u003eT(t,t)y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Causal-Oscillator.html#v:shapeFreqModFromSampledTone"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Causal.Oscillator",
          "name": "shapeFreqModSample",
          "package": "synthesizer",
          "signature": "T c (T b a) -\u003e T (T b a) -\u003e c -\u003e T b -\u003e T (c, b) a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Causal-Oscillator.html#shapeFreqModSample",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Causal Oscillator",
          "module": "Synthesizer.Causal.Oscillator",
          "name": "shapeFreqModSample",
          "normalized": "T a(T b c)-\u003eT(T b c)-\u003ea-\u003eT b-\u003eT(a,b)c",
          "package": "synthesizer",
          "partial": "Freq Mod Sample",
          "signature": "T c(T b a)-\u003eT(T b a)-\u003ec-\u003eT b-\u003eT(c,b)a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Causal-Oscillator.html#v:shapeFreqModSample"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "oscillator with modulated shape \n",
          "module": "Synthesizer.Causal.Oscillator",
          "name": "shapeMod",
          "package": "synthesizer",
          "signature": "(c -\u003e T a b) -\u003e T a -\u003e a -\u003e T c b",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Causal-Oscillator.html#shapeMod",
          "type": "function"
        },
        "index": {
          "description": "oscillator with modulated shape",
          "hierarchy": "Synthesizer Causal Oscillator",
          "module": "Synthesizer.Causal.Oscillator",
          "name": "shapeMod",
          "normalized": "(a-\u003eT b c)-\u003eT b-\u003eb-\u003eT a c",
          "package": "synthesizer",
          "partial": "Mod",
          "signature": "(c-\u003eT a b)-\u003eT a-\u003ea-\u003eT c b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Causal-Oscillator.html#v:shapeMod"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Causal.Oscillator",
          "name": "shapePhaseFreqModFromSampledTone",
          "package": "synthesizer",
          "signature": "T t y -\u003e T t y -\u003e t -\u003e sig y -\u003e t -\u003e T t -\u003e T (t, t, t) y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Causal-Oscillator.html#shapePhaseFreqModFromSampledTone",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Causal Oscillator",
          "module": "Synthesizer.Causal.Oscillator",
          "name": "shapePhaseFreqModFromSampledTone",
          "normalized": "T a b-\u003eT a b-\u003ea-\u003ec b-\u003ea-\u003eT a-\u003eT(a,a,a)b",
          "package": "synthesizer",
          "partial": "Phase Freq Mod From Sampled Tone",
          "signature": "T t y-\u003eT t y-\u003et-\u003esig y-\u003et-\u003eT t-\u003eT(t,t,t)y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Causal-Oscillator.html#v:shapePhaseFreqModFromSampledTone"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Causal.Process",
          "name": "T",
          "package": "synthesizer",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Causal-Process.html#T",
          "type": "data"
        },
        "index": {
          "hierarchy": "Synthesizer Causal Process",
          "module": "Synthesizer.Causal.Process",
          "name": "T",
          "package": "synthesizer",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Causal-Process.html#t:T"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Causal.Process",
          "name": "apply",
          "package": "synthesizer",
          "signature": "T a b -\u003e T a -\u003e T b",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Causal-Process.html#apply",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Causal Process",
          "module": "Synthesizer.Causal.Process",
          "name": "apply",
          "normalized": "T a b-\u003eT a-\u003eT b",
          "package": "synthesizer",
          "signature": "T a b-\u003eT a-\u003eT b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Causal-Process.html#v:apply"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Causal.Process",
          "name": "apply2",
          "package": "synthesizer",
          "signature": "T (a, b) c -\u003e T a -\u003e T b -\u003e T c",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Causal-Process.html#apply2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Causal Process",
          "module": "Synthesizer.Causal.Process",
          "name": "apply2",
          "normalized": "T(a,b)c-\u003eT a-\u003eT b-\u003eT c",
          "package": "synthesizer",
          "signature": "T(a,b)c-\u003eT a-\u003eT b-\u003eT c",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Causal-Process.html#v:apply2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Causal.Process",
          "name": "apply3",
          "package": "synthesizer",
          "signature": "T (a, b, c) d -\u003e T a -\u003e T b -\u003e T c -\u003e T d",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Causal-Process.html#apply3",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Causal Process",
          "module": "Synthesizer.Causal.Process",
          "name": "apply3",
          "normalized": "T(a,b,c)d-\u003eT a-\u003eT b-\u003eT c-\u003eT d",
          "package": "synthesizer",
          "signature": "T(a,b,c)d-\u003eT a-\u003eT b-\u003eT c-\u003eT d",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Causal-Process.html#v:apply3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "applyConst c x == apply c (repeat x)\n",
          "module": "Synthesizer.Causal.Process",
          "name": "applyConst",
          "package": "synthesizer",
          "signature": "T a b -\u003e a -\u003e T b",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Causal-Process.html#applyConst",
          "type": "function"
        },
        "index": {
          "description": "applyConst apply repeat",
          "hierarchy": "Synthesizer Causal Process",
          "module": "Synthesizer.Causal.Process",
          "name": "applyConst",
          "normalized": "T a b-\u003ea-\u003eT b",
          "package": "synthesizer",
          "partial": "Const",
          "signature": "T a b-\u003ea-\u003eT b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Causal-Process.html#v:applyConst"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Causal.Process",
          "name": "applyFst",
          "package": "synthesizer",
          "signature": "T (a, b) c -\u003e T a -\u003e T b c",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Causal-Process.html#applyFst",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Causal Process",
          "module": "Synthesizer.Causal.Process",
          "name": "applyFst",
          "normalized": "T(a,b)c-\u003eT a-\u003eT b c",
          "package": "synthesizer",
          "partial": "Fst",
          "signature": "T(a,b)c-\u003eT a-\u003eT b c",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Causal-Process.html#v:applyFst"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "I think this function does too much.\nBetter use \u003ctt\u003e\u003ca\u003efeedFst\u003c/a\u003e\u003c/tt\u003e and (\u003e\u003e\u003e).\n",
          "module": "Synthesizer.Causal.Process",
          "name": "applyFst'",
          "package": "synthesizer",
          "signature": "T (a, b) c -\u003e T a -\u003e T b c",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Causal-Process.html#applyFst%27",
          "type": "function"
        },
        "index": {
          "description": "think this function does too much Better use feedFst and",
          "hierarchy": "Synthesizer Causal Process",
          "module": "Synthesizer.Causal.Process",
          "name": "applyFst'",
          "normalized": "T(a,b)c-\u003eT a-\u003eT b c",
          "package": "synthesizer",
          "partial": "Fst'",
          "signature": "T(a,b)c-\u003eT a-\u003eT b c",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Causal-Process.html#v:applyFst'"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Causal.Process",
          "name": "applyGeneric",
          "package": "synthesizer",
          "signature": "T a b -\u003e sig a -\u003e sig b",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Causal-Process.html#applyGeneric",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Causal Process",
          "module": "Synthesizer.Causal.Process",
          "name": "applyGeneric",
          "normalized": "T a b-\u003ec a-\u003ec b",
          "package": "synthesizer",
          "partial": "Generic",
          "signature": "T a b-\u003esig a-\u003esig b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Causal-Process.html#v:applyGeneric"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Causal.Process",
          "name": "applyGenericSameType",
          "package": "synthesizer",
          "signature": "T a a -\u003e sig a -\u003e sig a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Causal-Process.html#applyGenericSameType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Causal Process",
          "module": "Synthesizer.Causal.Process",
          "name": "applyGenericSameType",
          "normalized": "T a a-\u003eb a-\u003eb a",
          "package": "synthesizer",
          "partial": "Generic Same Type",
          "signature": "T a a-\u003esig a-\u003esig a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Causal-Process.html#v:applyGenericSameType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Causal.Process",
          "name": "applySnd",
          "package": "synthesizer",
          "signature": "T (a, b) c -\u003e T b -\u003e T a c",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Causal-Process.html#applySnd",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Causal Process",
          "module": "Synthesizer.Causal.Process",
          "name": "applySnd",
          "normalized": "T(a,b)c-\u003eT b-\u003eT a c",
          "package": "synthesizer",
          "partial": "Snd",
          "signature": "T(a,b)c-\u003eT b-\u003eT a c",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Causal-Process.html#v:applySnd"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "I think this function does too much.\nBetter use \u003ctt\u003e\u003ca\u003efeedSnd\u003c/a\u003e\u003c/tt\u003e and (\u003e\u003e\u003e).\n",
          "module": "Synthesizer.Causal.Process",
          "name": "applySnd'",
          "package": "synthesizer",
          "signature": "T (a, b) c -\u003e T b -\u003e T a c",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Causal-Process.html#applySnd%27",
          "type": "function"
        },
        "index": {
          "description": "think this function does too much Better use feedSnd and",
          "hierarchy": "Synthesizer Causal Process",
          "module": "Synthesizer.Causal.Process",
          "name": "applySnd'",
          "normalized": "T(a,b)c-\u003eT b-\u003eT a c",
          "package": "synthesizer",
          "partial": "Snd'",
          "signature": "T(a,b)c-\u003eT b-\u003eT a c",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Causal-Process.html#v:applySnd'"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Causal.Process",
          "name": "chainControlled",
          "package": "synthesizer",
          "signature": "[T (c, x) x] -\u003e T (c, x) x",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Causal-Process.html#chainControlled",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Causal Process",
          "module": "Synthesizer.Causal.Process",
          "name": "chainControlled",
          "normalized": "[T(a,b)b]-\u003eT(a,b)b",
          "package": "synthesizer",
          "partial": "Controlled",
          "signature": "[T(c,x)x]-\u003eT(c,x)x",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Causal-Process.html#v:chainControlled"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Causal.Process",
          "name": "compose",
          "package": "synthesizer",
          "signature": "T a b -\u003e T b c -\u003e T a c",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Causal-Process.html#compose",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Causal Process",
          "module": "Synthesizer.Causal.Process",
          "name": "compose",
          "normalized": "T a b-\u003eT b c-\u003eT a c",
          "package": "synthesizer",
          "signature": "T a b-\u003eT b c-\u003eT a c",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Causal-Process.html#v:compose"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Prepend an element to a signal,\nbut keep the signal length,\ni.e. drop the last element.\n",
          "module": "Synthesizer.Causal.Process",
          "name": "consInit",
          "package": "synthesizer",
          "signature": "x -\u003e T x x",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Causal-Process.html#consInit",
          "type": "function"
        },
        "index": {
          "description": "Prepend an element to signal but keep the signal length i.e drop the last element",
          "hierarchy": "Synthesizer Causal Process",
          "module": "Synthesizer.Causal.Process",
          "name": "consInit",
          "normalized": "a-\u003eT a a",
          "package": "synthesizer",
          "partial": "Init",
          "signature": "x-\u003eT x x",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Causal-Process.html#v:consInit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Causal.Process",
          "name": "crochetL",
          "package": "synthesizer",
          "signature": "(x -\u003e acc -\u003e Maybe (y, acc)) -\u003e acc -\u003e T x y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Causal-Process.html#crochetL",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Causal Process",
          "module": "Synthesizer.Causal.Process",
          "name": "crochetL",
          "normalized": "(a-\u003eb-\u003eMaybe(c,b))-\u003eb-\u003eT a c",
          "package": "synthesizer",
          "signature": "(x-\u003eacc-\u003eMaybe(y,acc))-\u003eacc-\u003eT x y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Causal-Process.html#v:crochetL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Causal.Process",
          "name": "fanout",
          "package": "synthesizer",
          "signature": "T a b -\u003e T a c -\u003e T a (b, c)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Causal-Process.html#fanout",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Causal Process",
          "module": "Synthesizer.Causal.Process",
          "name": "fanout",
          "normalized": "T a b-\u003eT a c-\u003eT a(b,c)",
          "package": "synthesizer",
          "signature": "T a b-\u003eT a c-\u003eT a(b,c)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Causal-Process.html#v:fanout"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Causal.Process",
          "name": "feed",
          "package": "synthesizer",
          "signature": "T a -\u003e T () a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Causal-Process.html#feed",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Causal Process",
          "module": "Synthesizer.Causal.Process",
          "name": "feed",
          "normalized": "T a-\u003eT()a",
          "package": "synthesizer",
          "signature": "T a-\u003eT()a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Causal-Process.html#v:feed"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Causal.Process",
          "name": "feedConstFst",
          "package": "synthesizer",
          "signature": "a -\u003e T b (a, b)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Causal-Process.html#feedConstFst",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Causal Process",
          "module": "Synthesizer.Causal.Process",
          "name": "feedConstFst",
          "normalized": "a-\u003eT b(a,b)",
          "package": "synthesizer",
          "partial": "Const Fst",
          "signature": "a-\u003eT b(a,b)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Causal-Process.html#v:feedConstFst"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Causal.Process",
          "name": "feedConstSnd",
          "package": "synthesizer",
          "signature": "a -\u003e T b (b, a)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Causal-Process.html#feedConstSnd",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Causal Process",
          "module": "Synthesizer.Causal.Process",
          "name": "feedConstSnd",
          "normalized": "a-\u003eT b(b,a)",
          "package": "synthesizer",
          "partial": "Const Snd",
          "signature": "a-\u003eT b(b,a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Causal-Process.html#v:feedConstSnd"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Causal.Process",
          "name": "feedFst",
          "package": "synthesizer",
          "signature": "T a -\u003e T b (a, b)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Causal-Process.html#feedFst",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Causal Process",
          "module": "Synthesizer.Causal.Process",
          "name": "feedFst",
          "normalized": "T a-\u003eT b(a,b)",
          "package": "synthesizer",
          "partial": "Fst",
          "signature": "T a-\u003eT b(a,b)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Causal-Process.html#v:feedFst"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Causal.Process",
          "name": "feedGenericFst",
          "package": "synthesizer",
          "signature": "sig a -\u003e T b (a, b)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Causal-Process.html#feedGenericFst",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Causal Process",
          "module": "Synthesizer.Causal.Process",
          "name": "feedGenericFst",
          "normalized": "a b-\u003eT c(b,c)",
          "package": "synthesizer",
          "partial": "Generic Fst",
          "signature": "sig a-\u003eT b(a,b)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Causal-Process.html#v:feedGenericFst"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Causal.Process",
          "name": "feedGenericSnd",
          "package": "synthesizer",
          "signature": "sig a -\u003e T b (b, a)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Causal-Process.html#feedGenericSnd",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Causal Process",
          "module": "Synthesizer.Causal.Process",
          "name": "feedGenericSnd",
          "normalized": "a b-\u003eT c(c,b)",
          "package": "synthesizer",
          "partial": "Generic Snd",
          "signature": "sig a-\u003eT b(b,a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Causal-Process.html#v:feedGenericSnd"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Causal.Process",
          "name": "feedSnd",
          "package": "synthesizer",
          "signature": "T a -\u003e T b (b, a)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Causal-Process.html#feedSnd",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Causal Process",
          "module": "Synthesizer.Causal.Process",
          "name": "feedSnd",
          "normalized": "T a-\u003eT b(b,a)",
          "package": "synthesizer",
          "partial": "Snd",
          "signature": "T a-\u003eT b(b,a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Causal-Process.html#v:feedSnd"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Causal.Process",
          "name": "feedback",
          "package": "synthesizer",
          "signature": "T (a, c) b -\u003e T b c -\u003e T a b",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Causal-Process.html#feedback",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Causal Process",
          "module": "Synthesizer.Causal.Process",
          "name": "feedback",
          "normalized": "T(a,b)c-\u003eT c b-\u003eT a c",
          "package": "synthesizer",
          "signature": "T(a,c)b-\u003eT b c-\u003eT a b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Causal-Process.html#v:feedback"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Causal.Process",
          "name": "feedbackControlled",
          "package": "synthesizer",
          "signature": "T ((ctrl, a), c) b -\u003e T (ctrl, b) c -\u003e T (ctrl, a) b",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Causal-Process.html#feedbackControlled",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Causal Process",
          "module": "Synthesizer.Causal.Process",
          "name": "feedbackControlled",
          "normalized": "T((a,b),c)d-\u003eT(a,d)c-\u003eT(a,b)d",
          "package": "synthesizer",
          "partial": "Controlled",
          "signature": "T((ctrl,a),c)b-\u003eT(ctrl,b)c-\u003eT(ctrl,a)b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Causal-Process.html#v:feedbackControlled"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Causal.Process",
          "name": "fromSimpleModifier",
          "package": "synthesizer",
          "signature": "Simple s ctrl a b -\u003e T (ctrl, a) b",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Causal-Process.html#fromSimpleModifier",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Causal Process",
          "module": "Synthesizer.Causal.Process",
          "name": "fromSimpleModifier",
          "normalized": "Simple a b c d-\u003eT(b,c)d",
          "package": "synthesizer",
          "partial": "Simple Modifier",
          "signature": "Simple s ctrl a b-\u003eT(ctrl,a)b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Causal-Process.html#v:fromSimpleModifier"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Causal.Process",
          "name": "fromState",
          "package": "synthesizer",
          "signature": "(a -\u003e State s b) -\u003e s -\u003e T a b",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Causal-Process.html#fromState",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Causal Process",
          "module": "Synthesizer.Causal.Process",
          "name": "fromState",
          "normalized": "(a-\u003eState b c)-\u003eb-\u003eT a c",
          "package": "synthesizer",
          "partial": "State",
          "signature": "(a-\u003eState s b)-\u003es-\u003eT a b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Causal-Process.html#v:fromState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Causal.Process",
          "name": "fromStateMaybe",
          "package": "synthesizer",
          "signature": "(a -\u003e StateT s Maybe b) -\u003e s -\u003e T a b",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Causal-Process.html#fromStateMaybe",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Causal Process",
          "module": "Synthesizer.Causal.Process",
          "name": "fromStateMaybe",
          "normalized": "(a-\u003eStateT b Maybe c)-\u003eb-\u003eT a c",
          "package": "synthesizer",
          "partial": "State Maybe",
          "signature": "(a-\u003eStateT s Maybe b)-\u003es-\u003eT a b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Causal-Process.html#v:fromStateMaybe"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Causal.Process",
          "name": "id",
          "package": "synthesizer",
          "signature": "T a a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Causal-Process.html#id",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Causal Process",
          "module": "Synthesizer.Causal.Process",
          "name": "id",
          "package": "synthesizer",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Causal-Process.html#v:id"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Causal.Process",
          "name": "map",
          "package": "synthesizer",
          "signature": "(a -\u003e b) -\u003e T a b",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Causal-Process.html#map",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Causal Process",
          "module": "Synthesizer.Causal.Process",
          "name": "map",
          "normalized": "(a-\u003eb)-\u003eT a b",
          "package": "synthesizer",
          "signature": "(a-\u003eb)-\u003eT a b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Causal-Process.html#v:map"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "If \u003ctt\u003eT\u003c/tt\u003e would be the function type \u003ctt\u003e-\u003e\u003c/tt\u003e\nthen \u003ctt\u003ereplicateControlled 3 f\u003c/tt\u003e computes\n\u003ctt\u003e(c,x) -\u003e f(c, f(c, f(c, x)))\u003c/tt\u003e.\n",
          "module": "Synthesizer.Causal.Process",
          "name": "replicateControlled",
          "package": "synthesizer",
          "signature": "Int -\u003e T (c, x) x -\u003e T (c, x) x",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Causal-Process.html#replicateControlled",
          "type": "function"
        },
        "index": {
          "description": "If would be the function type then replicateControlled computes",
          "hierarchy": "Synthesizer Causal Process",
          "module": "Synthesizer.Causal.Process",
          "name": "replicateControlled",
          "normalized": "Int-\u003eT(a,b)b-\u003eT(a,b)b",
          "package": "synthesizer",
          "partial": "Controlled",
          "signature": "Int-\u003eT(c,x)x-\u003eT(c,x)x",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Causal-Process.html#v:replicateControlled"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Causal.Process",
          "name": "scanL",
          "package": "synthesizer",
          "signature": "(acc -\u003e x -\u003e acc) -\u003e acc -\u003e T x acc",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Causal-Process.html#scanL",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Causal Process",
          "module": "Synthesizer.Causal.Process",
          "name": "scanL",
          "normalized": "(a-\u003eb-\u003ea)-\u003ea-\u003eT b a",
          "package": "synthesizer",
          "signature": "(acc-\u003ex-\u003eacc)-\u003eacc-\u003eT x acc",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Causal-Process.html#v:scanL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Causal.Process",
          "name": "scanL1",
          "package": "synthesizer",
          "signature": "(x -\u003e x -\u003e x) -\u003e T x x",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Causal-Process.html#scanL1",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Causal Process",
          "module": "Synthesizer.Causal.Process",
          "name": "scanL1",
          "normalized": "(a-\u003ea-\u003ea)-\u003eT a a",
          "package": "synthesizer",
          "signature": "(x-\u003ex-\u003ex)-\u003eT x x",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Causal-Process.html#v:scanL1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Causal.Process",
          "name": "split",
          "package": "synthesizer",
          "signature": "T a b -\u003e T c d -\u003e T (a, c) (b, d)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Causal-Process.html#split",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Causal Process",
          "module": "Synthesizer.Causal.Process",
          "name": "split",
          "normalized": "T a b-\u003eT c d-\u003eT(a,c)(b,d)",
          "package": "synthesizer",
          "signature": "T a b-\u003eT c d-\u003eT(a,c)(b,d)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Causal-Process.html#v:split"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Causal.Process",
          "name": "zipWith",
          "package": "synthesizer",
          "signature": "(a -\u003e b -\u003e c) -\u003e T a -\u003e T b c",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Causal-Process.html#zipWith",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Causal Process",
          "module": "Synthesizer.Causal.Process",
          "name": "zipWith",
          "normalized": "(a-\u003eb-\u003ec)-\u003eT a-\u003eT b c",
          "package": "synthesizer",
          "partial": "With",
          "signature": "(a-\u003eb-\u003ec)-\u003eT a-\u003eT b c",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Causal-Process.html#v:zipWith"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Causal.ToneModulation",
          "name": "integrateFractional",
          "package": "synthesizer",
          "signature": "t -\u003e (t, T t) -\u003e (Skip t, T (t, t) (Skip t))",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Causal-ToneModulation.html#integrateFractional",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Causal ToneModulation",
          "module": "Synthesizer.Causal.ToneModulation",
          "name": "integrateFractional",
          "normalized": "a-\u003e(a,T a)-\u003e(Skip a,T(a,a)(Skip a))",
          "package": "synthesizer",
          "partial": "Fractional",
          "signature": "t-\u003e(t,T t)-\u003e(Skip t,T(t,t)(Skip t))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Causal-ToneModulation.html#v:integrateFractional"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Delays output by one element and shorten it by one element at the end.\n",
          "module": "Synthesizer.Causal.ToneModulation",
          "name": "integrateFractionalClip",
          "package": "synthesizer",
          "signature": "t -\u003e (t, T t) -\u003e T (t, t) (Skip t)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Causal-ToneModulation.html#integrateFractionalClip",
          "type": "function"
        },
        "index": {
          "description": "Delays output by one element and shorten it by one element at the end",
          "hierarchy": "Synthesizer Causal ToneModulation",
          "module": "Synthesizer.Causal.ToneModulation",
          "name": "integrateFractionalClip",
          "normalized": "a-\u003e(a,T a)-\u003eT(a,a)(Skip a)",
          "package": "synthesizer",
          "partial": "Fractional Clip",
          "signature": "t-\u003e(t,T t)-\u003eT(t,t)(Skip t)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Causal-ToneModulation.html#v:integrateFractionalClip"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Synthesizer.Causal.ToneModulation\",\"Synthesizer.State.ToneModulation\"]",
          "name": "interpolateCell",
          "package": "synthesizer",
          "signature": "T a y -\u003e T b y -\u003e (a, b) -\u003e Cell sig y -\u003e y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-ToneModulation.html#interpolateCell",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Causal-ToneModulation.html#v:interpolateCell\",\"http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-ToneModulation.html#v:interpolateCell\"]"
        },
        "index": {
          "hierarchy": "Synthesizer Causal ToneModulation",
          "module": "Synthesizer.Causal.ToneModulation",
          "name": "interpolateCell",
          "normalized": "T a b-\u003eT c b-\u003e(a,c)-\u003eCell d b-\u003eb",
          "package": "synthesizer",
          "partial": "Cell",
          "signature": "T a y-\u003eT b y-\u003e(a,b)-\u003eCell sig y-\u003ey",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Causal-ToneModulation.html#v:interpolateCell"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Causal.ToneModulation",
          "name": "limitMinRelativeValues",
          "package": "synthesizer",
          "signature": "t -\u003e t -\u003e (t, T t t)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Causal-ToneModulation.html#limitMinRelativeValues",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Causal ToneModulation",
          "module": "Synthesizer.Causal.ToneModulation",
          "name": "limitMinRelativeValues",
          "normalized": "a-\u003ea-\u003e(a,T a a)",
          "package": "synthesizer",
          "partial": "Min Relative Values",
          "signature": "t-\u003et-\u003e(t,T t t)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Causal-ToneModulation.html#v:limitMinRelativeValues"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Causal.ToneModulation",
          "name": "limitRelativeShapes",
          "package": "synthesizer",
          "signature": "Margin -\u003e Margin -\u003e Int -\u003e t -\u003e (t, T t t)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Causal-ToneModulation.html#limitRelativeShapes",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Causal ToneModulation",
          "module": "Synthesizer.Causal.ToneModulation",
          "name": "limitRelativeShapes",
          "normalized": "Margin-\u003eMargin-\u003eInt-\u003ea-\u003e(a,T a a)",
          "package": "synthesizer",
          "partial": "Relative Shapes",
          "signature": "Margin-\u003eMargin-\u003eInt-\u003et-\u003e(t,T t t)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Causal-ToneModulation.html#v:limitRelativeShapes"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Causal.ToneModulation",
          "name": "oscillatorCells",
          "package": "synthesizer",
          "signature": "Margin -\u003e Margin -\u003e Int -\u003e t -\u003e sig y -\u003e (t, T t) -\u003e T (t, t) ((t, t), Cell sig y)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Causal-ToneModulation.html#oscillatorCells",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Causal ToneModulation",
          "module": "Synthesizer.Causal.ToneModulation",
          "name": "oscillatorCells",
          "normalized": "Margin-\u003eMargin-\u003eInt-\u003ea-\u003eb c-\u003e(a,T a)-\u003eT(a,a)((a,a),Cell b c)",
          "package": "synthesizer",
          "partial": "Cells",
          "signature": "Margin-\u003eMargin-\u003eInt-\u003et-\u003esig y-\u003e(t,T t)-\u003eT(t,t)((t,t),Cell sig y)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Causal-ToneModulation.html#v:oscillatorCells"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "In contrast to the counterpart of this function for plain lists,\nit does not use sophisticated list transposition tricks,\nbut seeks through the prototype signal using \u003ctt\u003e\u003ca\u003edrop\u003c/a\u003e\u003c/tt\u003e.\nSince \u003ctt\u003e\u003ca\u003edrop\u003c/a\u003e\u003c/tt\u003e is used in an inner loop, it must be fast.\nThis is true for StorableVectors.\n",
          "module": "Synthesizer.Causal.ToneModulation",
          "name": "oscillatorSuffixes",
          "package": "synthesizer",
          "signature": "Margin -\u003e Margin -\u003e Int -\u003e t -\u003e sig y -\u003e (t, T t) -\u003e T (t, t) ((t, T t), sig y)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Causal-ToneModulation.html#oscillatorSuffixes",
          "type": "function"
        },
        "index": {
          "description": "In contrast to the counterpart of this function for plain lists it does not use sophisticated list transposition tricks but seeks through the prototype signal using drop Since drop is used in an inner loop it must be fast This is true for StorableVectors",
          "hierarchy": "Synthesizer Causal ToneModulation",
          "module": "Synthesizer.Causal.ToneModulation",
          "name": "oscillatorSuffixes",
          "normalized": "Margin-\u003eMargin-\u003eInt-\u003ea-\u003eb c-\u003e(a,T a)-\u003eT(a,a)((a,T a),b c)",
          "package": "synthesizer",
          "partial": "Suffixes",
          "signature": "Margin-\u003eMargin-\u003eInt-\u003et-\u003esig y-\u003e(t,T t)-\u003eT(t,t)((t,T t),sig y)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Causal-ToneModulation.html#v:oscillatorSuffixes"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Causal.ToneModulation",
          "name": "seekCell",
          "package": "synthesizer",
          "signature": "Int -\u003e t -\u003e ((t, T t), sig y) -\u003e ((t, t), Cell sig y)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Causal-ToneModulation.html#seekCell",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Causal ToneModulation",
          "module": "Synthesizer.Causal.ToneModulation",
          "name": "seekCell",
          "normalized": "Int-\u003ea-\u003e((a,T a),b c)-\u003e((a,a),Cell b c)",
          "package": "synthesizer",
          "partial": "Cell",
          "signature": "Int-\u003et-\u003e((t,T t),sig y)-\u003e((t,t),Cell sig y)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Causal-ToneModulation.html#v:seekCell"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.Abstraction.Flat",
          "name": "Amplitude",
          "package": "synthesizer",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Abstraction-Flat.html#Amplitude",
          "type": "class"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional Abstraction Flat",
          "module": "Synthesizer.Dimensional.Abstraction.Flat",
          "name": "Amplitude",
          "package": "synthesizer",
          "partial": "Amplitude",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Abstraction-Flat.html#v:Amplitude"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.Abstraction.Flat",
          "name": "C",
          "package": "synthesizer",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Abstraction-Flat.html#C",
          "type": "class"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional Abstraction Flat",
          "module": "Synthesizer.Dimensional.Abstraction.Flat",
          "name": "C",
          "package": "synthesizer",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Abstraction-Flat.html#v:C"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.Abstraction.Flat",
          "name": "toSamples",
          "package": "synthesizer",
          "signature": "T s sig y -\u003e T y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Abstraction-Flat.html#toSamples",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional Abstraction Flat",
          "module": "Synthesizer.Dimensional.Abstraction.Flat",
          "name": "toSamples",
          "normalized": "T a b c-\u003eT c",
          "package": "synthesizer",
          "partial": "Samples",
          "signature": "T s sig y-\u003eT y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Abstraction-Flat.html#v:toSamples"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.Abstraction.Flat",
          "name": "toScalar",
          "package": "synthesizer",
          "signature": "amp -\u003e y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Abstraction-Flat.html#toScalar",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional Abstraction Flat",
          "module": "Synthesizer.Dimensional.Abstraction.Flat",
          "name": "toScalar",
          "normalized": "a-\u003eb",
          "package": "synthesizer",
          "partial": "Scalar",
          "signature": "amp-\u003ey",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Abstraction-Flat.html#v:toScalar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.Abstraction.Flat",
          "name": "unwrappedToSamples",
          "package": "synthesizer",
          "signature": "sig y -\u003e T y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Abstraction-Flat.html#unwrappedToSamples",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional Abstraction Flat",
          "module": "Synthesizer.Dimensional.Abstraction.Flat",
          "name": "unwrappedToSamples",
          "normalized": "a b-\u003eT b",
          "package": "synthesizer",
          "partial": "To Samples",
          "signature": "sig y-\u003eT y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Abstraction-Flat.html#v:unwrappedToSamples"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.Abstraction.Homogeneous",
          "name": "C",
          "package": "synthesizer",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Abstraction-Homogeneous.html#C",
          "type": "class"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional Abstraction Homogeneous",
          "module": "Synthesizer.Dimensional.Abstraction.Homogeneous",
          "name": "C",
          "package": "synthesizer",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Abstraction-Homogeneous.html#v:C"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.Abstraction.Homogeneous",
          "name": "processSampleList",
          "package": "synthesizer",
          "signature": "([y0] -\u003e [y1]) -\u003e T s sig y0 -\u003e T s sig y1",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Abstraction-Homogeneous.html#processSampleList",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional Abstraction Homogeneous",
          "module": "Synthesizer.Dimensional.Abstraction.Homogeneous",
          "name": "processSampleList",
          "normalized": "([a]-\u003e[a])-\u003eT b c a-\u003eT b c a",
          "package": "synthesizer",
          "partial": "Sample List",
          "signature": "([y]-\u003e[y])-\u003eT s sig y-\u003eT s sig y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Abstraction-Homogeneous.html#v:processSampleList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.Abstraction.Homogeneous",
          "name": "processSamples",
          "package": "synthesizer",
          "signature": "(T y0 -\u003e T y1) -\u003e T s sig y0 -\u003e T s sig y1",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Abstraction-Homogeneous.html#processSamples",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional Abstraction Homogeneous",
          "module": "Synthesizer.Dimensional.Abstraction.Homogeneous",
          "name": "processSamples",
          "normalized": "(T a-\u003eT a)-\u003eT b c a-\u003eT b c a",
          "package": "synthesizer",
          "partial": "Samples",
          "signature": "(T y-\u003eT y)-\u003eT s sig y-\u003eT s sig y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Abstraction-Homogeneous.html#v:processSamples"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.Abstraction.Homogeneous",
          "name": "unwrappedProcessSamples",
          "package": "synthesizer",
          "signature": "(T y0 -\u003e T y1) -\u003e sig y0 -\u003e sig y1",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Abstraction-Homogeneous.html#unwrappedProcessSamples",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional Abstraction Homogeneous",
          "module": "Synthesizer.Dimensional.Abstraction.Homogeneous",
          "name": "unwrappedProcessSamples",
          "normalized": "(T a-\u003eT a)-\u003eb a-\u003eb a",
          "package": "synthesizer",
          "partial": "Process Samples",
          "signature": "(T y-\u003eT y)-\u003esig y-\u003esig y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Abstraction-Homogeneous.html#v:unwrappedProcessSamples"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.Abstraction.HomogeneousGen",
          "name": "C",
          "package": "synthesizer",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Abstraction-HomogeneousGen.html#C",
          "type": "class"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional Abstraction HomogeneousGen",
          "module": "Synthesizer.Dimensional.Abstraction.HomogeneousGen",
          "name": "C",
          "package": "synthesizer",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Abstraction-HomogeneousGen.html#v:C"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.Abstraction.HomogeneousGen",
          "name": "plainProcessSamples",
          "package": "synthesizer",
          "signature": "(storage0 y0 -\u003e storage1 y1) -\u003e signal0 y0 -\u003e signal1 y1",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Abstraction-HomogeneousGen.html#plainProcessSamples",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional Abstraction HomogeneousGen",
          "module": "Synthesizer.Dimensional.Abstraction.HomogeneousGen",
          "name": "plainProcessSamples",
          "normalized": "(a b-\u003ea b)-\u003ec b-\u003ec b",
          "package": "synthesizer",
          "partial": "Process Samples",
          "signature": "(storage y-\u003estorage y)-\u003esignal y-\u003esignal y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Abstraction-HomogeneousGen.html#v:plainProcessSamples"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.Abstraction.HomogeneousGen",
          "name": "plainUnwrap",
          "package": "synthesizer",
          "signature": "signal y -\u003e (amp, storage y)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Abstraction-HomogeneousGen.html#plainUnwrap",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional Abstraction HomogeneousGen",
          "module": "Synthesizer.Dimensional.Abstraction.HomogeneousGen",
          "name": "plainUnwrap",
          "normalized": "a b-\u003e(c,d b)",
          "package": "synthesizer",
          "partial": "Unwrap",
          "signature": "signal y-\u003e(amp,storage y)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Abstraction-HomogeneousGen.html#v:plainUnwrap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.Abstraction.HomogeneousGen",
          "name": "plainWrap",
          "package": "synthesizer",
          "signature": "(amp, storage y) -\u003e signal y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Abstraction-HomogeneousGen.html#plainWrap",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional Abstraction HomogeneousGen",
          "module": "Synthesizer.Dimensional.Abstraction.HomogeneousGen",
          "name": "plainWrap",
          "normalized": "(a,b c)-\u003ed c",
          "package": "synthesizer",
          "partial": "Wrap",
          "signature": "(amp,storage y)-\u003esignal y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Abstraction-HomogeneousGen.html#v:plainWrap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.Abstraction.HomogeneousGen",
          "name": "processSamples",
          "package": "synthesizer",
          "signature": "(storage0 y0 -\u003e storage1 y1) -\u003e T s signal0 y0 -\u003e T s signal1 y1",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Abstraction-HomogeneousGen.html#processSamples",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional Abstraction HomogeneousGen",
          "module": "Synthesizer.Dimensional.Abstraction.HomogeneousGen",
          "name": "processSamples",
          "normalized": "(a b-\u003ea b)-\u003eT c d b-\u003eT c d b",
          "package": "synthesizer",
          "partial": "Samples",
          "signature": "(storage y-\u003estorage y)-\u003eT s signal y-\u003eT s signal y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Abstraction-HomogeneousGen.html#v:processSamples"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.Abstraction.HomogeneousGen",
          "name": "unwrap",
          "package": "synthesizer",
          "signature": "T s signal y -\u003e (amp, storage y)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Abstraction-HomogeneousGen.html#unwrap",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional Abstraction HomogeneousGen",
          "module": "Synthesizer.Dimensional.Abstraction.HomogeneousGen",
          "name": "unwrap",
          "normalized": "T a b c-\u003e(d,e c)",
          "package": "synthesizer",
          "signature": "T s signal y-\u003e(amp,storage y)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Abstraction-HomogeneousGen.html#v:unwrap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.Abstraction.HomogeneousGen",
          "name": "wrap",
          "package": "synthesizer",
          "signature": "(amp, storage y) -\u003e T s signal y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Abstraction-HomogeneousGen.html#wrap",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional Abstraction HomogeneousGen",
          "module": "Synthesizer.Dimensional.Abstraction.HomogeneousGen",
          "name": "wrap",
          "normalized": "(a,b c)-\u003eT d e c",
          "package": "synthesizer",
          "signature": "(amp,storage y)-\u003eT s signal y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Abstraction-HomogeneousGen.html#v:wrap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.Abstraction.RateIndependent",
          "name": "C",
          "package": "synthesizer",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Abstraction-RateIndependent.html#C",
          "type": "class"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional Abstraction RateIndependent",
          "module": "Synthesizer.Dimensional.Abstraction.RateIndependent",
          "name": "C",
          "package": "synthesizer",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Abstraction-RateIndependent.html#v:C"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.Abstraction.RateIndependent",
          "name": "processSignal",
          "package": "synthesizer",
          "signature": "(sig0 y0 -\u003e sig1 y1) -\u003e w sig0 y0 -\u003e w sig1 y1",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Abstraction-RateIndependent.html#processSignal",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional Abstraction RateIndependent",
          "module": "Synthesizer.Dimensional.Abstraction.RateIndependent",
          "name": "processSignal",
          "normalized": "(a b-\u003ea b)-\u003ec a b-\u003ec a b",
          "package": "synthesizer",
          "partial": "Signal",
          "signature": "(sig y-\u003esig y)-\u003ew sig y-\u003ew sig y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Abstraction-RateIndependent.html#v:processSignal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.Abstraction.RateIndependent",
          "name": "toSignal",
          "package": "synthesizer",
          "signature": "w sig y -\u003e sig y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Abstraction-RateIndependent.html#toSignal",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional Abstraction RateIndependent",
          "module": "Synthesizer.Dimensional.Abstraction.RateIndependent",
          "name": "toSignal",
          "normalized": "a b c-\u003eb c",
          "package": "synthesizer",
          "partial": "Signal",
          "signature": "w sig y-\u003esig y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Abstraction-RateIndependent.html#v:toSignal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.Amplitude.Analysis",
          "name": "compare",
          "package": "synthesizer",
          "signature": "R s u y yv -\u003e R s u y yv -\u003e R s Ordering",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Amplitude-Analysis.html#compare",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional Amplitude Analysis",
          "module": "Synthesizer.Dimensional.Amplitude.Analysis",
          "name": "compare",
          "normalized": "R a b c d-\u003eR a b c d-\u003eR a Ordering",
          "package": "synthesizer",
          "signature": "R s u y yv-\u003eR s u y yv-\u003eR s Ordering",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Amplitude-Analysis.html#v:compare"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Requires finite length.\nThis is identical to the arithmetic mean.\n",
          "module": "Synthesizer.Dimensional.Amplitude.Analysis",
          "name": "directCurrentOffset",
          "package": "synthesizer",
          "signature": "w (S u y) y -\u003e T u y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Amplitude-Analysis.html#directCurrentOffset",
          "type": "function"
        },
        "index": {
          "description": "Requires finite length This is identical to the arithmetic mean",
          "hierarchy": "Synthesizer Dimensional Amplitude Analysis",
          "module": "Synthesizer.Dimensional.Amplitude.Analysis",
          "name": "directCurrentOffset",
          "normalized": "a(S b c)c-\u003eT b c",
          "package": "synthesizer",
          "partial": "Current Offset",
          "signature": "w(S u y)y-\u003eT u y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Amplitude-Analysis.html#v:directCurrentOffset"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Detect thresholds with a hysteresis.\n",
          "module": "Synthesizer.Dimensional.Amplitude.Analysis",
          "name": "flipFlopHysteresis",
          "package": "synthesizer",
          "signature": "(T u y, T u y) -\u003e Bool -\u003e w (S u y) y -\u003e w S Bool",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Amplitude-Analysis.html#flipFlopHysteresis",
          "type": "function"
        },
        "index": {
          "description": "Detect thresholds with hysteresis",
          "hierarchy": "Synthesizer Dimensional Amplitude Analysis",
          "module": "Synthesizer.Dimensional.Amplitude.Analysis",
          "name": "flipFlopHysteresis",
          "normalized": "(T a b,T a b)-\u003eBool-\u003ec(S a b)b-\u003ec S Bool",
          "package": "synthesizer",
          "partial": "Flop Hysteresis",
          "signature": "(T u y,T u y)-\u003eBool-\u003ew(S u y)y-\u003ew S Bool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Amplitude-Analysis.html#v:flipFlopHysteresis"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.Amplitude.Analysis",
          "name": "lessOrEqual",
          "package": "synthesizer",
          "signature": "R s u y yv -\u003e R s u y yv -\u003e Binary s",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Amplitude-Analysis.html#lessOrEqual",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional Amplitude Analysis",
          "module": "Synthesizer.Dimensional.Amplitude.Analysis",
          "name": "lessOrEqual",
          "normalized": "R a b c d-\u003eR a b c d-\u003eBinary a",
          "package": "synthesizer",
          "partial": "Or Equal",
          "signature": "R s u y yv-\u003eR s u y yv-\u003eBinary s",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Amplitude-Analysis.html#v:lessOrEqual"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.Amplitude.Analysis",
          "name": "rectify",
          "package": "synthesizer",
          "signature": "w sig y -\u003e w sig y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Amplitude-Analysis.html#rectify",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional Amplitude Analysis",
          "module": "Synthesizer.Dimensional.Amplitude.Analysis",
          "name": "rectify",
          "normalized": "a b c-\u003ea b c",
          "package": "synthesizer",
          "signature": "w sig y-\u003ew sig y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Amplitude-Analysis.html#v:rectify"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Volume based on Energy norm.\n",
          "module": "Synthesizer.Dimensional.Amplitude.Analysis",
          "name": "volumeEuclidean",
          "package": "synthesizer",
          "signature": "w (S u y) y -\u003e T u y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Amplitude-Analysis.html#volumeEuclidean",
          "type": "function"
        },
        "index": {
          "description": "Volume based on Energy norm",
          "hierarchy": "Synthesizer Dimensional Amplitude Analysis",
          "module": "Synthesizer.Dimensional.Amplitude.Analysis",
          "name": "volumeEuclidean",
          "normalized": "a(S b c)c-\u003eT b c",
          "package": "synthesizer",
          "partial": "Euclidean",
          "signature": "w(S u y)y-\u003eT u y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Amplitude-Analysis.html#v:volumeEuclidean"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Volume based on Manhattan norm.\n",
          "module": "Synthesizer.Dimensional.Amplitude.Analysis",
          "name": "volumeMaximum",
          "package": "synthesizer",
          "signature": "w (S u y) y -\u003e T u y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Amplitude-Analysis.html#volumeMaximum",
          "type": "function"
        },
        "index": {
          "description": "Volume based on Manhattan norm",
          "hierarchy": "Synthesizer Dimensional Amplitude Analysis",
          "module": "Synthesizer.Dimensional.Amplitude.Analysis",
          "name": "volumeMaximum",
          "normalized": "a(S b c)c-\u003eT b c",
          "package": "synthesizer",
          "partial": "Maximum",
          "signature": "w(S u y)y-\u003eT u y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Amplitude-Analysis.html#v:volumeMaximum"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Volume based on Sum norm.\n",
          "module": "Synthesizer.Dimensional.Amplitude.Analysis",
          "name": "volumeSum",
          "package": "synthesizer",
          "signature": "w (S u y) y -\u003e T u y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Amplitude-Analysis.html#volumeSum",
          "type": "function"
        },
        "index": {
          "description": "Volume based on Sum norm",
          "hierarchy": "Synthesizer Dimensional Amplitude Analysis",
          "module": "Synthesizer.Dimensional.Amplitude.Analysis",
          "name": "volumeSum",
          "normalized": "a(S b c)c-\u003eT b c",
          "package": "synthesizer",
          "partial": "Sum",
          "signature": "w(S u y)y-\u003eT u y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Amplitude-Analysis.html#v:volumeSum"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Volume based on Energy norm.\n",
          "module": "Synthesizer.Dimensional.Amplitude.Analysis",
          "name": "volumeVectorEuclidean",
          "package": "synthesizer",
          "signature": "w (S u y) yv -\u003e T u y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Amplitude-Analysis.html#volumeVectorEuclidean",
          "type": "function"
        },
        "index": {
          "description": "Volume based on Energy norm",
          "hierarchy": "Synthesizer Dimensional Amplitude Analysis",
          "module": "Synthesizer.Dimensional.Amplitude.Analysis",
          "name": "volumeVectorEuclidean",
          "normalized": "a(S b c)d-\u003eT b c",
          "package": "synthesizer",
          "partial": "Vector Euclidean",
          "signature": "w(S u y)yv-\u003eT u y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Amplitude-Analysis.html#v:volumeVectorEuclidean"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Volume based on Manhattan norm.\n",
          "module": "Synthesizer.Dimensional.Amplitude.Analysis",
          "name": "volumeVectorMaximum",
          "package": "synthesizer",
          "signature": "w (S u y) yv -\u003e T u y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Amplitude-Analysis.html#volumeVectorMaximum",
          "type": "function"
        },
        "index": {
          "description": "Volume based on Manhattan norm",
          "hierarchy": "Synthesizer Dimensional Amplitude Analysis",
          "module": "Synthesizer.Dimensional.Amplitude.Analysis",
          "name": "volumeVectorMaximum",
          "normalized": "a(S b c)d-\u003eT b c",
          "package": "synthesizer",
          "partial": "Vector Maximum",
          "signature": "w(S u y)yv-\u003eT u y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Amplitude-Analysis.html#v:volumeVectorMaximum"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Volume based on Sum norm.\n",
          "module": "Synthesizer.Dimensional.Amplitude.Analysis",
          "name": "volumeVectorSum",
          "package": "synthesizer",
          "signature": "w (S u y) yv -\u003e T u y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Amplitude-Analysis.html#volumeVectorSum",
          "type": "function"
        },
        "index": {
          "description": "Volume based on Sum norm",
          "hierarchy": "Synthesizer Dimensional Amplitude Analysis",
          "module": "Synthesizer.Dimensional.Amplitude.Analysis",
          "name": "volumeVectorSum",
          "normalized": "a(S b c)d-\u003eT b c",
          "package": "synthesizer",
          "partial": "Vector Sum",
          "signature": "w(S u y)yv-\u003eT u y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Amplitude-Analysis.html#v:volumeVectorSum"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "value \n",
          "module": "Synthesizer.Dimensional.Amplitude.Control",
          "name": "constant",
          "package": "synthesizer",
          "signature": "T u y-\u003e R s u y y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Amplitude-Control.html#constant",
          "type": "function"
        },
        "index": {
          "description": "value",
          "hierarchy": "Synthesizer Dimensional Amplitude Control",
          "module": "Synthesizer.Dimensional.Amplitude.Control",
          "name": "constant",
          "normalized": "T a b-\u003eR c a b b",
          "package": "synthesizer",
          "signature": "T u y-\u003eR s u y y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Amplitude-Control.html#v:constant"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "amplitude \nvalue \n",
          "module": "Synthesizer.Dimensional.Amplitude.Control",
          "name": "constantVector",
          "package": "synthesizer",
          "signature": "T u y-\u003e yv-\u003e R s u y yv",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Amplitude-Control.html#constantVector",
          "type": "function"
        },
        "index": {
          "description": "amplitude value",
          "hierarchy": "Synthesizer Dimensional Amplitude Control",
          "module": "Synthesizer.Dimensional.Amplitude.Control",
          "name": "constantVector",
          "normalized": "T a b-\u003ec-\u003eR d a b c",
          "package": "synthesizer",
          "partial": "Vector",
          "signature": "T u y-\u003eyv-\u003eR s u y yv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Amplitude-Control.html#v:constantVector"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.Amplitude.Control",
          "name": "mapExponential",
          "package": "synthesizer",
          "signature": "y -\u003e T u q -\u003e w flat y -\u003e w (S u q) y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Amplitude-Control.html#mapExponential",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional Amplitude Control",
          "module": "Synthesizer.Dimensional.Amplitude.Control",
          "name": "mapExponential",
          "normalized": "a-\u003eT b c-\u003ed e a-\u003ed(S b c)a",
          "package": "synthesizer",
          "partial": "Exponential",
          "signature": "y-\u003eT u q-\u003ew flat y-\u003ew(S u q)y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Amplitude-Control.html#v:mapExponential"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.Amplitude.Control",
          "name": "mapLinear",
          "package": "synthesizer",
          "signature": "y -\u003e T u y -\u003e w flat y -\u003e w (S u y) y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Amplitude-Control.html#mapLinear",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional Amplitude Control",
          "module": "Synthesizer.Dimensional.Amplitude.Control",
          "name": "mapLinear",
          "normalized": "a-\u003eT b a-\u003ec d a-\u003ec(S b a)a",
          "package": "synthesizer",
          "partial": "Linear",
          "signature": "y-\u003eT u y-\u003ew flat y-\u003ew(S u y)y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Amplitude-Control.html#v:mapLinear"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "range: one is mapped to \u003ctt\u003ecenter + range * ampX\u003c/tt\u003e \ncenter: zero is mapped to \u003ctt\u003ecenter\u003c/tt\u003e \n",
          "module": "Synthesizer.Dimensional.Amplitude.Control",
          "name": "mapLinearDimension",
          "package": "synthesizer",
          "signature": "T v y-\u003e T (Mul v u) y-\u003e w (S u y) y-\u003e w (S (Mul v u) y) y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Amplitude-Control.html#mapLinearDimension",
          "type": "function"
        },
        "index": {
          "description": "range one is mapped to center range ampX center zero is mapped to center",
          "hierarchy": "Synthesizer Dimensional Amplitude Control",
          "module": "Synthesizer.Dimensional.Amplitude.Control",
          "name": "mapLinearDimension",
          "normalized": "T a b-\u003eT(Mul a c)b-\u003ed(S c b)b-\u003ed(S(Mul a c)b)b",
          "package": "synthesizer",
          "partial": "Linear Dimension",
          "signature": "T v y-\u003eT(Mul v u)y-\u003ew(S u y)y-\u003ew(S(Mul v u)y)y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Amplitude-Control.html#v:mapLinearDimension"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.Amplitude.Cut",
          "name": "append",
          "package": "synthesizer",
          "signature": "R s u y yv -\u003e R s u y yv -\u003e R s u y yv",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Amplitude-Cut.html#append",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional Amplitude Cut",
          "module": "Synthesizer.Dimensional.Amplitude.Cut",
          "name": "append",
          "normalized": "R a b c d-\u003eR a b c d-\u003eR a b c d",
          "package": "synthesizer",
          "signature": "R s u y yv-\u003eR s u y yv-\u003eR s u y yv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Amplitude-Cut.html#v:append"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.Amplitude.Cut",
          "name": "appendVolume",
          "package": "synthesizer",
          "signature": "T u y -\u003e R s u y yv -\u003e R s u y yv -\u003e R s u y yv",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Amplitude-Cut.html#appendVolume",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional Amplitude Cut",
          "module": "Synthesizer.Dimensional.Amplitude.Cut",
          "name": "appendVolume",
          "normalized": "T a b-\u003eR c a b d-\u003eR c a b d-\u003eR c a b d",
          "package": "synthesizer",
          "partial": "Volume",
          "signature": "T u y-\u003eR s u y yv-\u003eR s u y yv-\u003eR s u y yv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Amplitude-Cut.html#v:appendVolume"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Similar to \u003ctt\u003efoldr1 append\u003c/tt\u003e but more efficient and accurate,\nbecause it reduces the number of amplifications.\nDoes not work for infinite lists,\nbecause no maximum amplitude can be computed.\n",
          "module": "Synthesizer.Dimensional.Amplitude.Cut",
          "name": "concat",
          "package": "synthesizer",
          "signature": "[R s u y yv] -\u003e R s u y yv",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Amplitude-Cut.html#concat",
          "type": "function"
        },
        "index": {
          "description": "Similar to foldr1 append but more efficient and accurate because it reduces the number of amplifications Does not work for infinite lists because no maximum amplitude can be computed",
          "hierarchy": "Synthesizer Dimensional Amplitude Cut",
          "module": "Synthesizer.Dimensional.Amplitude.Cut",
          "name": "concat",
          "normalized": "[R a b c d]-\u003eR a b c d",
          "package": "synthesizer",
          "signature": "[R s u y yv]-\u003eR s u y yv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Amplitude-Cut.html#v:concat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Give the output volume explicitly.\nDoes also work for infinite lists.\n",
          "module": "Synthesizer.Dimensional.Amplitude.Cut",
          "name": "concatVolume",
          "package": "synthesizer",
          "signature": "T u y -\u003e [R s u y yv] -\u003e R s u y yv",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Amplitude-Cut.html#concatVolume",
          "type": "function"
        },
        "index": {
          "description": "Give the output volume explicitly Does also work for infinite lists",
          "hierarchy": "Synthesizer Dimensional Amplitude Cut",
          "module": "Synthesizer.Dimensional.Amplitude.Cut",
          "name": "concatVolume",
          "normalized": "T a b-\u003e[R c a b d]-\u003eR c a b d",
          "package": "synthesizer",
          "partial": "Volume",
          "signature": "T u y-\u003e[R s u y yv]-\u003eR s u y yv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Amplitude-Cut.html#v:concatVolume"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.Amplitude.Cut",
          "name": "leftFromStereo",
          "package": "synthesizer",
          "signature": "R s u y (T yv) -\u003e R s u y yv",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Amplitude-Cut.html#leftFromStereo",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional Amplitude Cut",
          "module": "Synthesizer.Dimensional.Amplitude.Cut",
          "name": "leftFromStereo",
          "normalized": "R a b c(T d)-\u003eR a b c d",
          "package": "synthesizer",
          "partial": "From Stereo",
          "signature": "R s u y(T yv)-\u003eR s u y yv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Amplitude-Cut.html#v:leftFromStereo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.Amplitude.Cut",
          "name": "mergeStereo",
          "package": "synthesizer",
          "signature": "R s u y yv -\u003e R s u y yv -\u003e R s u y (T yv)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Amplitude-Cut.html#mergeStereo",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional Amplitude Cut",
          "module": "Synthesizer.Dimensional.Amplitude.Cut",
          "name": "mergeStereo",
          "normalized": "R a b c d-\u003eR a b c d-\u003eR a b c(T d)",
          "package": "synthesizer",
          "partial": "Stereo",
          "signature": "R s u y yv-\u003eR s u y yv-\u003eR s u y(T yv)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Amplitude-Cut.html#v:mergeStereo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.Amplitude.Cut",
          "name": "mergeStereoVolume",
          "package": "synthesizer",
          "signature": "T u y -\u003e R s u y yv -\u003e R s u y yv -\u003e R s u y (T yv)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Amplitude-Cut.html#mergeStereoVolume",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional Amplitude Cut",
          "module": "Synthesizer.Dimensional.Amplitude.Cut",
          "name": "mergeStereoVolume",
          "normalized": "T a b-\u003eR c a b d-\u003eR c a b d-\u003eR c a b(T d)",
          "package": "synthesizer",
          "partial": "Stereo Volume",
          "signature": "T u y-\u003eR s u y yv-\u003eR s u y yv-\u003eR s u y(T yv)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Amplitude-Cut.html#v:mergeStereoVolume"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.Amplitude.Cut",
          "name": "rightFromStereo",
          "package": "synthesizer",
          "signature": "R s u y (T yv) -\u003e R s u y yv",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Amplitude-Cut.html#rightFromStereo",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional Amplitude Cut",
          "module": "Synthesizer.Dimensional.Amplitude.Cut",
          "name": "rightFromStereo",
          "normalized": "R a b c(T d)-\u003eR a b c d",
          "package": "synthesizer",
          "partial": "From Stereo",
          "signature": "R s u y(T yv)-\u003eR s u y yv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Amplitude-Cut.html#v:rightFromStereo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "False \nTrue \n",
          "module": "Synthesizer.Dimensional.Amplitude.Cut",
          "name": "selectBool",
          "package": "synthesizer",
          "signature": "R s u y yv-\u003e R s u y yv-\u003e Binary s-\u003e R s u y yv",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Amplitude-Cut.html#selectBool",
          "type": "function"
        },
        "index": {
          "description": "False True",
          "hierarchy": "Synthesizer Dimensional Amplitude Cut",
          "module": "Synthesizer.Dimensional.Amplitude.Cut",
          "name": "selectBool",
          "normalized": "R a b c d-\u003eR a b c d-\u003eBinary a-\u003eR a b c d",
          "package": "synthesizer",
          "partial": "Bool",
          "signature": "R s u y yv-\u003eR s u y yv-\u003eBinary s-\u003eR s u y yv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Amplitude-Cut.html#v:selectBool"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.Amplitude.Cut",
          "name": "unzip",
          "package": "synthesizer",
          "signature": "R s u y (yv0, yv1) -\u003e (R s u y yv0, R s u y yv1)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Amplitude-Cut.html#unzip",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional Amplitude Cut",
          "module": "Synthesizer.Dimensional.Amplitude.Cut",
          "name": "unzip",
          "normalized": "R a b c(d,d)-\u003e(R a b c d,R a b c d)",
          "package": "synthesizer",
          "signature": "R s u y(yv,yv)-\u003e(R s u y yv,R s u y yv)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Amplitude-Cut.html#v:unzip"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.Amplitude.Cut",
          "name": "unzip3",
          "package": "synthesizer",
          "signature": "R s u y (yv0, yv1, yv2) -\u003e (R s u y yv0, R s u y yv1, R s u y yv2)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Amplitude-Cut.html#unzip3",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional Amplitude Cut",
          "module": "Synthesizer.Dimensional.Amplitude.Cut",
          "name": "unzip3",
          "normalized": "R a b c(d,d,d)-\u003e(R a b c d,R a b c d,R a b c d)",
          "package": "synthesizer",
          "signature": "R s u y(yv,yv,yv)-\u003e(R s u y yv,R s u y yv,R s u y yv)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Amplitude-Cut.html#v:unzip3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.Amplitude.Cut",
          "name": "zip",
          "package": "synthesizer",
          "signature": "R s u y yv0 -\u003e R s u y yv1 -\u003e R s u y (yv0, yv1)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Amplitude-Cut.html#zip",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional Amplitude Cut",
          "module": "Synthesizer.Dimensional.Amplitude.Cut",
          "name": "zip",
          "normalized": "R a b c d-\u003eR a b c d-\u003eR a b c(d,d)",
          "package": "synthesizer",
          "signature": "R s u y yv-\u003eR s u y yv-\u003eR s u y(yv,yv)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Amplitude-Cut.html#v:zip"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.Amplitude.Cut",
          "name": "zip3",
          "package": "synthesizer",
          "signature": "R s u y yv0 -\u003e R s u y yv1 -\u003e R s u y yv2 -\u003e R s u y (yv0, yv1, yv2)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Amplitude-Cut.html#zip3",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional Amplitude Cut",
          "module": "Synthesizer.Dimensional.Amplitude.Cut",
          "name": "zip3",
          "normalized": "R a b c d-\u003eR a b c d-\u003eR a b c d-\u003eR a b c(d,d,d)",
          "package": "synthesizer",
          "signature": "R s u y yv-\u003eR s u y yv-\u003eR s u y yv-\u003eR s u y(yv,yv,yv)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Amplitude-Cut.html#v:zip3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.Amplitude.Cut",
          "name": "zip3Volume",
          "package": "synthesizer",
          "signature": "T u y -\u003e R s u y yv0 -\u003e R s u y yv1 -\u003e R s u y yv2 -\u003e R s u y (yv0, yv1, yv2)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Amplitude-Cut.html#zip3Volume",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional Amplitude Cut",
          "module": "Synthesizer.Dimensional.Amplitude.Cut",
          "name": "zip3Volume",
          "normalized": "T a b-\u003eR c a b d-\u003eR c a b d-\u003eR c a b d-\u003eR c a b(d,d,d)",
          "package": "synthesizer",
          "partial": "Volume",
          "signature": "T u y-\u003eR s u y yv-\u003eR s u y yv-\u003eR s u y yv-\u003eR s u y(yv,yv,yv)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Amplitude-Cut.html#v:zip3Volume"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.Amplitude.Cut",
          "name": "zipVolume",
          "package": "synthesizer",
          "signature": "T u y -\u003e R s u y yv0 -\u003e R s u y yv1 -\u003e R s u y (yv0, yv1)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Amplitude-Cut.html#zipVolume",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional Amplitude Cut",
          "module": "Synthesizer.Dimensional.Amplitude.Cut",
          "name": "zipVolume",
          "normalized": "T a b-\u003eR c a b d-\u003eR c a b d-\u003eR c a b(d,d)",
          "package": "synthesizer",
          "partial": "Volume",
          "signature": "T u y-\u003eR s u y yv-\u003eR s u y yv-\u003eR s u y(yv,yv)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Amplitude-Cut.html#v:zipVolume"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Distort the signal using a flat function.\nThe first signal gives the scaling of the function.\nIf the scaling is c and the input sample is y,\nthen \u003ctt\u003ec * f(y/c)\u003c/tt\u003e is output.\nThis way we can use an (efficient) flat function\nand have a simple, yet dimension conform, way of controlling the distortion.\nE.g. if the distortion function is \u003ctt\u003etanh\u003c/tt\u003e\nthen the value \u003ctt\u003ec\u003c/tt\u003e controls the saturation level.\n",
          "module": "Synthesizer.Dimensional.Amplitude.Displacement",
          "name": "distort",
          "package": "synthesizer",
          "signature": "(yv -\u003e yv) -\u003e R s u y y -\u003e R s u y yv -\u003e R s u y yv",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Amplitude-Displacement.html#distort",
          "type": "function"
        },
        "index": {
          "description": "Distort the signal using flat function The first signal gives the scaling of the function If the scaling is and the input sample is then is output This way we can use an efficient flat function and have simple yet dimension conform way of controlling the distortion E.g if the distortion function is tanh then the value controls the saturation level",
          "hierarchy": "Synthesizer Dimensional Amplitude Displacement",
          "module": "Synthesizer.Dimensional.Amplitude.Displacement",
          "name": "distort",
          "normalized": "(a-\u003ea)-\u003eR b c d d-\u003eR b c d a-\u003eR b c d a",
          "package": "synthesizer",
          "signature": "(yv-\u003eyv)-\u003eR s u y y-\u003eR s u y yv-\u003eR s u y yv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Amplitude-Displacement.html#v:distort"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Mix two signals.\nIn contrast to \u003ctt\u003e\u003ca\u003ezipWith\u003c/a\u003e\u003c/tt\u003e the result has the length of the longer signal.\n",
          "module": "Synthesizer.Dimensional.Amplitude.Displacement",
          "name": "mix",
          "package": "synthesizer",
          "signature": "R s u y yv -\u003e R s u y yv -\u003e R s u y yv",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Amplitude-Displacement.html#mix",
          "type": "function"
        },
        "index": {
          "description": "Mix two signals In contrast to zipWith the result has the length of the longer signal",
          "hierarchy": "Synthesizer Dimensional Amplitude Displacement",
          "module": "Synthesizer.Dimensional.Amplitude.Displacement",
          "name": "mix",
          "normalized": "R a b c d-\u003eR a b c d-\u003eR a b c d",
          "package": "synthesizer",
          "signature": "R s u y yv-\u003eR s u y yv-\u003eR s u y yv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Amplitude-Displacement.html#v:mix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Mix one or more signals.\n",
          "module": "Synthesizer.Dimensional.Amplitude.Displacement",
          "name": "mixMulti",
          "package": "synthesizer",
          "signature": "[R s u y yv] -\u003e R s u y yv",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Amplitude-Displacement.html#mixMulti",
          "type": "function"
        },
        "index": {
          "description": "Mix one or more signals",
          "hierarchy": "Synthesizer Dimensional Amplitude Displacement",
          "module": "Synthesizer.Dimensional.Amplitude.Displacement",
          "name": "mixMulti",
          "normalized": "[R a b c d]-\u003eR a b c d",
          "package": "synthesizer",
          "partial": "Multi",
          "signature": "[R s u y yv]-\u003eR s u y yv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Amplitude-Displacement.html#v:mixMulti"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.Amplitude.Displacement",
          "name": "mixMultiVolume",
          "package": "synthesizer",
          "signature": "T u y -\u003e [R s u y yv] -\u003e R s u y yv",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Amplitude-Displacement.html#mixMultiVolume",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional Amplitude Displacement",
          "module": "Synthesizer.Dimensional.Amplitude.Displacement",
          "name": "mixMultiVolume",
          "normalized": "T a b-\u003e[R c a b d]-\u003eR c a b d",
          "package": "synthesizer",
          "partial": "Multi Volume",
          "signature": "T u y-\u003e[R s u y yv]-\u003eR s u y yv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Amplitude-Displacement.html#v:mixMultiVolume"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.Amplitude.Displacement",
          "name": "mixVolume",
          "package": "synthesizer",
          "signature": "T u y -\u003e R s u y yv -\u003e R s u y yv -\u003e R s u y yv",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Amplitude-Displacement.html#mixVolume",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional Amplitude Displacement",
          "module": "Synthesizer.Dimensional.Amplitude.Displacement",
          "name": "mixVolume",
          "normalized": "T a b-\u003eR c a b d-\u003eR c a b d-\u003eR c a b d",
          "package": "synthesizer",
          "partial": "Volume",
          "signature": "T u y-\u003eR s u y yv-\u003eR s u y yv-\u003eR s u y yv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Amplitude-Displacement.html#v:mixVolume"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Add a number to all of the signal values.\nThis is useful for adjusting the center of a modulation.\n",
          "module": "Synthesizer.Dimensional.Amplitude.Displacement",
          "name": "raise",
          "package": "synthesizer",
          "signature": "T u y -\u003e yv -\u003e w (S u y) yv -\u003e w (S u y) yv",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Amplitude-Displacement.html#raise",
          "type": "function"
        },
        "index": {
          "description": "Add number to all of the signal values This is useful for adjusting the center of modulation",
          "hierarchy": "Synthesizer Dimensional Amplitude Displacement",
          "module": "Synthesizer.Dimensional.Amplitude.Displacement",
          "name": "raise",
          "normalized": "T a b-\u003ec-\u003ed(S a b)c-\u003ed(S a b)c",
          "package": "synthesizer",
          "signature": "T u y-\u003eyv-\u003ew(S u y)yv-\u003ew(S u y)yv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Amplitude-Displacement.html#v:raise"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "The amplification factor must be positive. \n",
          "module": "Synthesizer.Dimensional.Amplitude.Filter",
          "name": "amplify",
          "package": "synthesizer",
          "signature": "y -\u003e w (S u y) yv -\u003e w (S u y) yv",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Amplitude-Filter.html#amplify",
          "type": "function"
        },
        "index": {
          "description": "The amplification factor must be positive",
          "hierarchy": "Synthesizer Dimensional Amplitude Filter",
          "module": "Synthesizer.Dimensional.Amplitude.Filter",
          "name": "amplify",
          "normalized": "a-\u003eb(S c a)d-\u003eb(S c a)d",
          "package": "synthesizer",
          "signature": "y-\u003ew(S u y)yv-\u003ew(S u y)yv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Amplitude-Filter.html#v:amplify"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.Amplitude.Filter",
          "name": "amplifyDimension",
          "package": "synthesizer",
          "signature": "T v y -\u003e w (S u y) yv -\u003e w (S (Mul v u) y) yv",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Amplitude-Filter.html#amplifyDimension",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional Amplitude Filter",
          "module": "Synthesizer.Dimensional.Amplitude.Filter",
          "name": "amplifyDimension",
          "normalized": "T a b-\u003ec(S d b)e-\u003ec(S(Mul a d)b)e",
          "package": "synthesizer",
          "partial": "Dimension",
          "signature": "T v y-\u003ew(S u y)yv-\u003ew(S(Mul v u)y)yv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Amplitude-Filter.html#v:amplifyDimension"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "the envelope \nthe signal to be enveloped \n",
          "module": "Synthesizer.Dimensional.Amplitude.Filter",
          "name": "envelope",
          "package": "synthesizer",
          "signature": "T s flat y0-\u003e T s sig y0-\u003e T s sig y0",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Amplitude-Filter.html#envelope",
          "type": "function"
        },
        "index": {
          "description": "the envelope the signal to be enveloped",
          "hierarchy": "Synthesizer Dimensional Amplitude Filter",
          "module": "Synthesizer.Dimensional.Amplitude.Filter",
          "name": "envelope",
          "normalized": "T a b c-\u003eT a d c-\u003eT a d c",
          "package": "synthesizer",
          "signature": "T s flat y-\u003eT s sig y-\u003eT s sig y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Amplitude-Filter.html#v:envelope"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "the envelope \nthe signal to be enveloped \n",
          "module": "Synthesizer.Dimensional.Amplitude.Filter",
          "name": "envelopeVector",
          "package": "synthesizer",
          "signature": "T s flat y0-\u003e T s sig yv-\u003e T s sig yv",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Amplitude-Filter.html#envelopeVector",
          "type": "function"
        },
        "index": {
          "description": "the envelope the signal to be enveloped",
          "hierarchy": "Synthesizer Dimensional Amplitude Filter",
          "module": "Synthesizer.Dimensional.Amplitude.Filter",
          "name": "envelopeVector",
          "normalized": "T a b c-\u003eT a d e-\u003eT a d e",
          "package": "synthesizer",
          "partial": "Vector",
          "signature": "T s flat y-\u003eT s sig yv-\u003eT s sig yv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Amplitude-Filter.html#v:envelopeVector"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "the envelope \nthe signal to be enveloped \n",
          "module": "Synthesizer.Dimensional.Amplitude.Filter",
          "name": "envelopeVectorDimension",
          "package": "synthesizer",
          "signature": "R s v y y0-\u003e R s u y yv-\u003e R s (Mul v u) y yv",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Amplitude-Filter.html#envelopeVectorDimension",
          "type": "function"
        },
        "index": {
          "description": "the envelope the signal to be enveloped",
          "hierarchy": "Synthesizer Dimensional Amplitude Filter",
          "module": "Synthesizer.Dimensional.Amplitude.Filter",
          "name": "envelopeVectorDimension",
          "normalized": "R a b c c-\u003eR a d c e-\u003eR a(Mul b d)c e",
          "package": "synthesizer",
          "partial": "Vector Dimension",
          "signature": "R s v y y-\u003eR s u y yv-\u003eR s(Mul v u)y yv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Amplitude-Filter.html#v:envelopeVectorDimension"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.Amplitude.Filter",
          "name": "negate",
          "package": "synthesizer",
          "signature": "w sig yv -\u003e w sig yv",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Amplitude-Filter.html#negate",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional Amplitude Filter",
          "module": "Synthesizer.Dimensional.Amplitude.Filter",
          "name": "negate",
          "normalized": "a b c-\u003ea b c",
          "package": "synthesizer",
          "signature": "w sig yv-\u003ew sig yv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Amplitude-Filter.html#v:negate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.Amplitude.Signal",
          "name": "D",
          "package": "synthesizer",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Amplitude-Signal.html#D",
          "type": "type"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional Amplitude Signal",
          "module": "Synthesizer.Dimensional.Amplitude.Signal",
          "name": "D",
          "package": "synthesizer",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Amplitude-Signal.html#t:D"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.Amplitude.Signal",
          "name": "R",
          "package": "synthesizer",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Amplitude-Signal.html#R",
          "type": "type"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional Amplitude Signal",
          "module": "Synthesizer.Dimensional.Amplitude.Signal",
          "name": "R",
          "package": "synthesizer",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Amplitude-Signal.html#t:R"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.Amplitude.Signal",
          "name": "S",
          "package": "synthesizer",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Amplitude-Signal.html#S",
          "type": "type"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional Amplitude Signal",
          "module": "Synthesizer.Dimensional.Amplitude.Signal",
          "name": "S",
          "package": "synthesizer",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Amplitude-Signal.html#t:S"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.Amplitude.Signal",
          "name": "T",
          "package": "synthesizer",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Amplitude-Signal.html#T",
          "type": "data"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional Amplitude Signal",
          "module": "Synthesizer.Dimensional.Amplitude.Signal",
          "name": "T",
          "package": "synthesizer",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Amplitude-Signal.html#t:T"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Synthesizer.Dimensional.Amplitude.Signal\",\"Synthesizer.Dimensional.RateAmplitude.Signal\"]",
          "name": "amplitude",
          "package": "synthesizer",
          "signature": "w (D v y sig) yv -\u003e T v y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Amplitude-Signal.html#amplitude",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Amplitude-Signal.html#v:amplitude\",\"http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-RateAmplitude-Signal.html#v:amplitude\"]"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional Amplitude Signal",
          "module": "Synthesizer.Dimensional.Amplitude.Signal",
          "name": "amplitude",
          "normalized": "a(D b c d)e-\u003eT b c",
          "package": "synthesizer",
          "signature": "w(D v y sig)yv-\u003eT v y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Amplitude-Signal.html#v:amplitude"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Synthesizer.Dimensional.Amplitude.Signal\",\"Synthesizer.Dimensional.RateAmplitude.Signal\"]",
          "name": "asTypeOfAmplitude",
          "package": "synthesizer",
          "signature": "y -\u003e w (D v y sig) yv -\u003e y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Amplitude-Signal.html#asTypeOfAmplitude",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Amplitude-Signal.html#v:asTypeOfAmplitude\",\"http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-RateAmplitude-Signal.html#v:asTypeOfAmplitude\"]"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional Amplitude Signal",
          "module": "Synthesizer.Dimensional.Amplitude.Signal",
          "name": "asTypeOfAmplitude",
          "normalized": "a-\u003eb(D c a d)e-\u003ea",
          "package": "synthesizer",
          "partial": "Type Of Amplitude",
          "signature": "y-\u003ew(D v y sig)yv-\u003ey",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Amplitude-Signal.html#v:asTypeOfAmplitude"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Synthesizer.Dimensional.Amplitude.Signal\",\"Synthesizer.Dimensional.RateAmplitude.Signal\"]",
          "name": "fromSamples",
          "package": "synthesizer",
          "signature": "amp -\u003e T yv -\u003e T s (T amp S) yv",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Amplitude-Signal.html#fromSamples",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Amplitude-Signal.html#v:fromSamples\",\"http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-RateAmplitude-Signal.html#v:fromSamples\"]"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional Amplitude Signal",
          "module": "Synthesizer.Dimensional.Amplitude.Signal",
          "name": "fromSamples",
          "normalized": "a-\u003eT b-\u003eT c(T a S)b",
          "package": "synthesizer",
          "partial": "Samples",
          "signature": "amp-\u003eT yv-\u003eT s(T amp S)yv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Amplitude-Signal.html#v:fromSamples"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Synthesizer.Dimensional.Amplitude.Signal\",\"Synthesizer.Dimensional.RateAmplitude.Signal\"]",
          "name": "fromScalarSamples",
          "package": "synthesizer",
          "signature": "amp -\u003e T y -\u003e T s (T amp S) y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Amplitude-Signal.html#fromScalarSamples",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Amplitude-Signal.html#v:fromScalarSamples\",\"http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-RateAmplitude-Signal.html#v:fromScalarSamples\"]"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional Amplitude Signal",
          "module": "Synthesizer.Dimensional.Amplitude.Signal",
          "name": "fromScalarSamples",
          "normalized": "a-\u003eT b-\u003eT c(T a S)b",
          "package": "synthesizer",
          "partial": "Scalar Samples",
          "signature": "amp-\u003eT y-\u003eT s(T amp S)y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Amplitude-Signal.html#v:fromScalarSamples"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Synthesizer.Dimensional.Amplitude.Signal\",\"Synthesizer.Dimensional.RateAmplitude.Signal\"]",
          "name": "fromSignal",
          "package": "synthesizer",
          "signature": "amp -\u003e R s yv -\u003e T s (T amp S) yv",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Amplitude-Signal.html#fromSignal",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Amplitude-Signal.html#v:fromSignal\",\"http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-RateAmplitude-Signal.html#v:fromSignal\"]"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional Amplitude Signal",
          "module": "Synthesizer.Dimensional.Amplitude.Signal",
          "name": "fromSignal",
          "normalized": "a-\u003eR b c-\u003eT b(T a S)c",
          "package": "synthesizer",
          "partial": "Signal",
          "signature": "amp-\u003eR s yv-\u003eT s(T amp S)yv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Amplitude-Signal.html#v:fromSignal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Synthesizer.Dimensional.Amplitude.Signal\",\"Synthesizer.Dimensional.RateAmplitude.Signal\"]",
          "name": "fromVectorSamples",
          "package": "synthesizer",
          "signature": "amp -\u003e T yv -\u003e T s (T amp S) yv",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Amplitude-Signal.html#fromVectorSamples",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Amplitude-Signal.html#v:fromVectorSamples\",\"http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-RateAmplitude-Signal.html#v:fromVectorSamples\"]"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional Amplitude Signal",
          "module": "Synthesizer.Dimensional.Amplitude.Signal",
          "name": "fromVectorSamples",
          "normalized": "a-\u003eT b-\u003eT c(T a S)b",
          "package": "synthesizer",
          "partial": "Vector Samples",
          "signature": "amp-\u003eT yv-\u003eT s(T amp S)yv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Amplitude-Signal.html#v:fromVectorSamples"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.Amplitude.Signal",
          "name": "phantomSignal",
          "package": "synthesizer",
          "signature": "T s (D v y sig) yv -\u003e T s sig yv",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Amplitude-Signal.html#phantomSignal",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional Amplitude Signal",
          "module": "Synthesizer.Dimensional.Amplitude.Signal",
          "name": "phantomSignal",
          "normalized": "T a(D b c d)e-\u003eT a d e",
          "package": "synthesizer",
          "partial": "Signal",
          "signature": "T s(D v y sig)yv-\u003eT s sig yv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Amplitude-Signal.html#v:phantomSignal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.Amplitude.Signal",
          "name": "privateSamples",
          "package": "synthesizer",
          "signature": "T amp (T sig) yv -\u003e sig yv",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Amplitude-Signal.html#privateSamples",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional Amplitude Signal",
          "module": "Synthesizer.Dimensional.Amplitude.Signal",
          "name": "privateSamples",
          "normalized": "T a(T b)c-\u003eb c",
          "package": "synthesizer",
          "partial": "Samples",
          "signature": "T amp(T sig)yv-\u003esig yv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Amplitude-Signal.html#v:privateSamples"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Synthesizer.Dimensional.Amplitude.Signal\",\"Synthesizer.Dimensional.RateAmplitude.Signal\"]",
          "name": "processSamples",
          "package": "synthesizer",
          "signature": "(sig0 yv0 -\u003e sig1 yv1) -\u003e w (D v y (T sig0)) yv0 -\u003e w (D v y (T sig1)) yv1",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Amplitude-Signal.html#processSamples",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Amplitude-Signal.html#v:processSamples\",\"http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-RateAmplitude-Signal.html#v:processSamples\"]"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional Amplitude Signal",
          "module": "Synthesizer.Dimensional.Amplitude.Signal",
          "name": "processSamples",
          "normalized": "(a b-\u003ea b)-\u003ec(D d e(T a))b-\u003ec(D d e(T a))b",
          "package": "synthesizer",
          "partial": "Samples",
          "signature": "(sig yv-\u003esig yv)-\u003ew(D v y(T sig))yv-\u003ew(D v y(T sig))yv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Amplitude-Signal.html#v:processSamples"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.Amplitude.Signal",
          "name": "processSamplesPrivate",
          "package": "synthesizer",
          "signature": "(sig0 yv0 -\u003e sig1 yv1) -\u003e D v y (T sig0) yv0 -\u003e D v y (T sig1) yv1",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Amplitude-Signal.html#processSamplesPrivate",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional Amplitude Signal",
          "module": "Synthesizer.Dimensional.Amplitude.Signal",
          "name": "processSamplesPrivate",
          "normalized": "(a b-\u003ea b)-\u003eD c d(T a)b-\u003eD c d(T a)b",
          "package": "synthesizer",
          "partial": "Samples Private",
          "signature": "(sig yv-\u003esig yv)-\u003eD v y(T sig)yv-\u003eD v y(T sig)yv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Amplitude-Signal.html#v:processSamplesPrivate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Synthesizer.Dimensional.Amplitude.Signal\",\"Synthesizer.Dimensional.RateAmplitude.Signal\"]",
          "name": "replaceAmplitude",
          "package": "synthesizer",
          "signature": "T v1 y -\u003e w (D v0 y sig) yv -\u003e w (D v1 y sig) yv",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Amplitude-Signal.html#replaceAmplitude",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Amplitude-Signal.html#v:replaceAmplitude\",\"http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-RateAmplitude-Signal.html#v:replaceAmplitude\"]"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional Amplitude Signal",
          "module": "Synthesizer.Dimensional.Amplitude.Signal",
          "name": "replaceAmplitude",
          "normalized": "T a b-\u003ec(D a b d)e-\u003ec(D a b d)e",
          "package": "synthesizer",
          "partial": "Amplitude",
          "signature": "T v y-\u003ew(D v y sig)yv-\u003ew(D v y sig)yv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Amplitude-Signal.html#v:replaceAmplitude"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.Amplitude.Signal",
          "name": "replaceAmplitudePrivate",
          "package": "synthesizer",
          "signature": "T v1 y -\u003e D v0 y sig yv -\u003e D v1 y sig yv",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Amplitude-Signal.html#replaceAmplitudePrivate",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional Amplitude Signal",
          "module": "Synthesizer.Dimensional.Amplitude.Signal",
          "name": "replaceAmplitudePrivate",
          "normalized": "T a b-\u003eD a b c d-\u003eD a b c d",
          "package": "synthesizer",
          "partial": "Amplitude Private",
          "signature": "T v y-\u003eD v y sig yv-\u003eD v y sig yv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Amplitude-Signal.html#v:replaceAmplitudePrivate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Synthesizer.Dimensional.Amplitude.Signal\",\"Synthesizer.Dimensional.RateAmplitude.Signal\"]",
          "name": "replaceSamples",
          "package": "synthesizer",
          "signature": "sig1 yv1 -\u003e w (D v y sig0) yv0 -\u003e w (D v y (T sig1)) yv1",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Amplitude-Signal.html#replaceSamples",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Amplitude-Signal.html#v:replaceSamples\",\"http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-RateAmplitude-Signal.html#v:replaceSamples\"]"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional Amplitude Signal",
          "module": "Synthesizer.Dimensional.Amplitude.Signal",
          "name": "replaceSamples",
          "normalized": "a b-\u003ec(D d e a)b-\u003ec(D d e(T a))b",
          "package": "synthesizer",
          "partial": "Samples",
          "signature": "sig yv-\u003ew(D v y sig)yv-\u003ew(D v y(T sig))yv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Amplitude-Signal.html#v:replaceSamples"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.Amplitude.Signal",
          "name": "replaceSamplesPrivate",
          "package": "synthesizer",
          "signature": "sig1 yv1 -\u003e D v y sig0 yv0 -\u003e D v y (T sig1) yv1",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Amplitude-Signal.html#replaceSamplesPrivate",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional Amplitude Signal",
          "module": "Synthesizer.Dimensional.Amplitude.Signal",
          "name": "replaceSamplesPrivate",
          "normalized": "a b-\u003eD c d a b-\u003eD c d(T a)b",
          "package": "synthesizer",
          "partial": "Samples Private",
          "signature": "sig yv-\u003eD v y sig yv-\u003eD v y(T sig)yv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Amplitude-Signal.html#v:replaceSamplesPrivate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.Amplitude.Signal",
          "name": "rewriteDimension",
          "package": "synthesizer",
          "signature": "(v0 -\u003e v1) -\u003e D v0 y sig yv -\u003e D v1 y sig yv",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Amplitude-Signal.html#rewriteDimension",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional Amplitude Signal",
          "module": "Synthesizer.Dimensional.Amplitude.Signal",
          "name": "rewriteDimension",
          "normalized": "(a-\u003ea)-\u003eD a b c d-\u003eD a b c d",
          "package": "synthesizer",
          "partial": "Dimension",
          "signature": "(v-\u003ev)-\u003eD v y sig yv-\u003eD v y sig yv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Amplitude-Signal.html#v:rewriteDimension"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Synthesizer.Dimensional.Amplitude.Signal\",\"Synthesizer.Dimensional.RateAmplitude.Signal\"]",
          "name": "samples",
          "package": "synthesizer",
          "signature": "w (D v y (T sig)) yv -\u003e sig yv",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Amplitude-Signal.html#samples",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Amplitude-Signal.html#v:samples\",\"http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-RateAmplitude-Signal.html#v:samples\"]"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional Amplitude Signal",
          "module": "Synthesizer.Dimensional.Amplitude.Signal",
          "name": "samples",
          "normalized": "a(D b c(T d))e-\u003ed e",
          "package": "synthesizer",
          "signature": "w(D v y(T sig))yv-\u003esig yv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Amplitude-Signal.html#v:samples"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Synthesizer.Dimensional.Amplitude.Signal\",\"Synthesizer.Dimensional.RateAmplitude.Signal\"]",
          "name": "scalarSamples",
          "package": "synthesizer",
          "signature": "(amp -\u003e y) -\u003e w (T amp S) y -\u003e T y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Amplitude-Signal.html#scalarSamples",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Amplitude-Signal.html#v:scalarSamples\",\"http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-RateAmplitude-Signal.html#v:scalarSamples\"]"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional Amplitude Signal",
          "module": "Synthesizer.Dimensional.Amplitude.Signal",
          "name": "scalarSamples",
          "normalized": "(a-\u003eb)-\u003ec(T a S)b-\u003eT b",
          "package": "synthesizer",
          "partial": "Samples",
          "signature": "(amp-\u003ey)-\u003ew(T amp S)y-\u003eT y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Amplitude-Signal.html#v:scalarSamples"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Synthesizer.Dimensional.Amplitude.Signal\",\"Synthesizer.Dimensional.RateAmplitude.Signal\"]",
          "name": "scalarSamplesGeneric",
          "package": "synthesizer",
          "signature": "(T v y -\u003e y) -\u003e w (D v y (T sig)) y -\u003e sig y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Amplitude-Signal.html#scalarSamplesGeneric",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Amplitude-Signal.html#v:scalarSamplesGeneric\",\"http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-RateAmplitude-Signal.html#v:scalarSamplesGeneric\"]"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional Amplitude Signal",
          "module": "Synthesizer.Dimensional.Amplitude.Signal",
          "name": "scalarSamplesGeneric",
          "normalized": "(T a b-\u003eb)-\u003ec(D a b(T d))b-\u003ed b",
          "package": "synthesizer",
          "partial": "Samples Generic",
          "signature": "(T v y-\u003ey)-\u003ew(D v y(T sig))y-\u003esig y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Amplitude-Signal.html#v:scalarSamplesGeneric"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.Amplitude.Signal",
          "name": "scalarSamplesPrivate",
          "package": "synthesizer",
          "signature": "(amp -\u003e y) -\u003e T amp S y -\u003e T y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Amplitude-Signal.html#scalarSamplesPrivate",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional Amplitude Signal",
          "module": "Synthesizer.Dimensional.Amplitude.Signal",
          "name": "scalarSamplesPrivate",
          "normalized": "(a-\u003eb)-\u003eT a S b-\u003eT b",
          "package": "synthesizer",
          "partial": "Samples Private",
          "signature": "(amp-\u003ey)-\u003eT amp S y-\u003eT y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Amplitude-Signal.html#v:scalarSamplesPrivate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.Amplitude.Signal",
          "name": "scalarSamplesPrivateGeneric",
          "package": "synthesizer",
          "signature": "(T v y -\u003e y) -\u003e D v y (T sig) y -\u003e sig y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Amplitude-Signal.html#scalarSamplesPrivateGeneric",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional Amplitude Signal",
          "module": "Synthesizer.Dimensional.Amplitude.Signal",
          "name": "scalarSamplesPrivateGeneric",
          "normalized": "(T a b-\u003eb)-\u003eD a b(T c)b-\u003ec b",
          "package": "synthesizer",
          "partial": "Samples Private Generic",
          "signature": "(T v y-\u003ey)-\u003eD v y(T sig)y-\u003esig y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Amplitude-Signal.html#v:scalarSamplesPrivateGeneric"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Synthesizer.Dimensional.Amplitude.Signal\",\"Synthesizer.Dimensional.RateAmplitude.Signal\"]",
          "name": "toAmplitudeScalar",
          "package": "synthesizer",
          "signature": "w (D v y sig) yv -\u003e T v y -\u003e y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Amplitude-Signal.html#toAmplitudeScalar",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Amplitude-Signal.html#v:toAmplitudeScalar\",\"http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-RateAmplitude-Signal.html#v:toAmplitudeScalar\"]"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional Amplitude Signal",
          "module": "Synthesizer.Dimensional.Amplitude.Signal",
          "name": "toAmplitudeScalar",
          "normalized": "a(D b c d)e-\u003eT b c-\u003ec",
          "package": "synthesizer",
          "partial": "Amplitude Scalar",
          "signature": "w(D v y sig)yv-\u003eT v y-\u003ey",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Amplitude-Signal.html#v:toAmplitudeScalar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.Amplitude.Signal",
          "name": "toScalarSignal",
          "package": "synthesizer",
          "signature": "T v y -\u003e w (S v y) y -\u003e w S y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Amplitude-Signal.html#toScalarSignal",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional Amplitude Signal",
          "module": "Synthesizer.Dimensional.Amplitude.Signal",
          "name": "toScalarSignal",
          "normalized": "T a b-\u003ec(S a b)b-\u003ec S b",
          "package": "synthesizer",
          "partial": "Scalar Signal",
          "signature": "T v y-\u003ew(S v y)y-\u003ew S y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Amplitude-Signal.html#v:toScalarSignal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.Amplitude.Signal",
          "name": "toVectorSignal",
          "package": "synthesizer",
          "signature": "T v y -\u003e w (S v y) yv -\u003e w S yv",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Amplitude-Signal.html#toVectorSignal",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional Amplitude Signal",
          "module": "Synthesizer.Dimensional.Amplitude.Signal",
          "name": "toVectorSignal",
          "normalized": "T a b-\u003ec(S a b)d-\u003ec S d",
          "package": "synthesizer",
          "partial": "Vector Signal",
          "signature": "T v y-\u003ew(S v y)yv-\u003ew S yv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Amplitude-Signal.html#v:toVectorSignal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Synthesizer.Dimensional.Amplitude.Signal\",\"Synthesizer.Dimensional.RateAmplitude.Signal\"]",
          "name": "vectorSamples",
          "package": "synthesizer",
          "signature": "(T v y -\u003e y) -\u003e w (S v y) yv -\u003e T yv",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Amplitude-Signal.html#vectorSamples",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Amplitude-Signal.html#v:vectorSamples\",\"http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-RateAmplitude-Signal.html#v:vectorSamples\"]"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional Amplitude Signal",
          "module": "Synthesizer.Dimensional.Amplitude.Signal",
          "name": "vectorSamples",
          "normalized": "(T a b-\u003eb)-\u003ec(S a b)d-\u003eT d",
          "package": "synthesizer",
          "partial": "Samples",
          "signature": "(T v y-\u003ey)-\u003ew(S v y)yv-\u003eT yv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Amplitude-Signal.html#v:vectorSamples"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.Amplitude.Signal",
          "name": "vectorSamplesPrivate",
          "package": "synthesizer",
          "signature": "(T v y -\u003e y) -\u003e S v y yv -\u003e T yv",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Amplitude-Signal.html#vectorSamplesPrivate",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional Amplitude Signal",
          "module": "Synthesizer.Dimensional.Amplitude.Signal",
          "name": "vectorSamplesPrivate",
          "normalized": "(T a b-\u003eb)-\u003eS a b c-\u003eT c",
          "package": "synthesizer",
          "partial": "Samples Private",
          "signature": "(T v y-\u003ey)-\u003eS v y yv-\u003eT yv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Amplitude-Signal.html#v:vectorSamplesPrivate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.Amplitude",
          "name": "Flat",
          "package": "synthesizer",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Amplitude.html#Flat",
          "type": "data"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional Amplitude",
          "module": "Synthesizer.Dimensional.Amplitude",
          "name": "Flat",
          "package": "synthesizer",
          "partial": "Flat",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Amplitude.html#t:Flat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.Amplitude",
          "name": "C",
          "package": "synthesizer",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Amplitude.html#C",
          "type": "class"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional Amplitude",
          "module": "Synthesizer.Dimensional.Amplitude",
          "name": "C",
          "package": "synthesizer",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Amplitude.html#v:C"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.Arrow",
          "package": "synthesizer",
          "signature": "arrow amp amp0 yv yv0 -\u003e arrow amp amp1 yv yv1 -\u003e arrow amp (amp0, amp1) yv (yv0, yv1)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Arrow.html#%26%26%26",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional Arrow",
          "module": "Synthesizer.Dimensional.Arrow",
          "normalized": "a b b c c-\u003ea b b c c-\u003ea b(b,b)c(c,c)",
          "package": "synthesizer",
          "signature": "arrow amp amp yv yv-\u003earrow amp amp yv yv-\u003earrow amp(amp,amp)yv(yv,yv)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Arrow.html#v:"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.Arrow",
          "name": "***",
          "package": "synthesizer",
          "signature": "arrow amp0 amp1 yv0 yv1 -\u003e arrow amp2 amp3 yv2 yv3 -\u003e arrow (amp0, amp2) (amp1, amp3) (yv0, yv2) (yv1, yv3)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Arrow.html#%2A%2A%2A",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional Arrow",
          "module": "Synthesizer.Dimensional.Arrow",
          "name": "***",
          "normalized": "a b b c c-\u003ea b b c c-\u003ea(b,b)(b,b)(c,c)(c,c)",
          "package": "synthesizer",
          "signature": "arrow amp amp yv yv-\u003earrow amp amp yv yv-\u003earrow(amp,amp)(amp,amp)(yv,yv)(yv,yv)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Arrow.html#v:***"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.Arrow",
          "name": "\u003c\u003c\u003c",
          "package": "synthesizer",
          "signature": "arrow amp1 amp2 yv1 yv2 -\u003e arrow amp0 amp1 yv0 yv1 -\u003e arrow amp0 amp2 yv0 yv2",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Arrow.html#%3C%3C%3C",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional Arrow",
          "module": "Synthesizer.Dimensional.Arrow",
          "name": "\u003c\u003c\u003c",
          "normalized": "a b b c c-\u003ea b b c c-\u003ea b b c c",
          "package": "synthesizer",
          "signature": "arrow amp amp yv yv-\u003earrow amp amp yv yv-\u003earrow amp amp yv yv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Arrow.html#v:\u003c\u003c\u003c"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Precomposition with a pure function (right-to-left variant).\n",
          "module": "Synthesizer.Dimensional.Arrow",
          "name": "\u003c\u003c^",
          "package": "synthesizer",
          "signature": "arrow amp1 amp2 yv1 yv2 -\u003e T amp0 amp1 yv0 yv1 -\u003e arrow amp0 amp2 yv0 yv2",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Arrow.html#%3C%3C%5E",
          "type": "function"
        },
        "index": {
          "description": "Precomposition with pure function right-to-left variant",
          "hierarchy": "Synthesizer Dimensional Arrow",
          "module": "Synthesizer.Dimensional.Arrow",
          "name": "\u003c\u003c^",
          "normalized": "a b b c c-\u003eT b b c c-\u003ea b b c c",
          "package": "synthesizer",
          "signature": "arrow amp amp yv yv-\u003eT amp amp yv yv-\u003earrow amp amp yv yv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Arrow.html#v:\u003c\u003c^"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.Arrow",
          "name": "\u003e\u003e\u003e",
          "package": "synthesizer",
          "signature": "arrow amp0 amp1 yv0 yv1 -\u003e arrow amp1 amp2 yv1 yv2 -\u003e arrow amp0 amp2 yv0 yv2",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Arrow.html#%3E%3E%3E",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional Arrow",
          "module": "Synthesizer.Dimensional.Arrow",
          "name": "\u003e\u003e\u003e",
          "normalized": "a b b c c-\u003ea b b c c-\u003ea b b c c",
          "package": "synthesizer",
          "signature": "arrow amp amp yv yv-\u003earrow amp amp yv yv-\u003earrow amp amp yv yv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Arrow.html#v:\u003e\u003e\u003e"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Postcomposition with a pure function.\n",
          "module": "Synthesizer.Dimensional.Arrow",
          "name": "\u003e\u003e^",
          "package": "synthesizer",
          "signature": "arrow amp0 amp1 yv0 yv1 -\u003e T amp1 amp2 yv1 yv2 -\u003e arrow amp0 amp2 yv0 yv2",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Arrow.html#%3E%3E%5E",
          "type": "function"
        },
        "index": {
          "description": "Postcomposition with pure function",
          "hierarchy": "Synthesizer Dimensional Arrow",
          "module": "Synthesizer.Dimensional.Arrow",
          "name": "\u003e\u003e^",
          "normalized": "a b b c c-\u003eT b b c c-\u003ea b b c c",
          "package": "synthesizer",
          "signature": "arrow amp amp yv yv-\u003eT amp amp yv yv-\u003earrow amp amp yv yv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Arrow.html#v:\u003e\u003e^"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.Arrow",
          "name": "C",
          "package": "synthesizer",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Arrow.html#C",
          "type": "class"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional Arrow",
          "module": "Synthesizer.Dimensional.Arrow",
          "name": "C",
          "package": "synthesizer",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Arrow.html#v:C"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Postcomposition with a pure function (right-to-left variant).\n",
          "module": "Synthesizer.Dimensional.Arrow",
          "name": "^\u003c\u003c",
          "package": "synthesizer",
          "signature": "T amp1 amp2 yv1 yv2 -\u003e arrow amp0 amp1 yv0 yv1 -\u003e arrow amp0 amp2 yv0 yv2",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Arrow.html#%5E%3C%3C",
          "type": "function"
        },
        "index": {
          "description": "Postcomposition with pure function right-to-left variant",
          "hierarchy": "Synthesizer Dimensional Arrow",
          "module": "Synthesizer.Dimensional.Arrow",
          "name": "^\u003c\u003c",
          "normalized": "T a a b b-\u003ec a a b b-\u003ec a a b b",
          "package": "synthesizer",
          "signature": "T amp amp yv yv-\u003earrow amp amp yv yv-\u003earrow amp amp yv yv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Arrow.html#v:^\u003c\u003c"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Precomposition with a pure function.\n",
          "module": "Synthesizer.Dimensional.Arrow",
          "name": "^\u003e\u003e",
          "package": "synthesizer",
          "signature": "T amp0 amp1 yv0 yv1 -\u003e arrow amp1 amp2 yv1 yv2 -\u003e arrow amp0 amp2 yv0 yv2",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Arrow.html#%5E%3E%3E",
          "type": "function"
        },
        "index": {
          "description": "Precomposition with pure function",
          "hierarchy": "Synthesizer Dimensional Arrow",
          "module": "Synthesizer.Dimensional.Arrow",
          "name": "^\u003e\u003e",
          "normalized": "T a a b b-\u003ec a a b b-\u003ec a a b b",
          "package": "synthesizer",
          "signature": "T amp amp yv yv-\u003earrow amp amp yv yv-\u003earrow amp amp yv yv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Arrow.html#v:^\u003e\u003e"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.Arrow",
          "name": "compose",
          "package": "synthesizer",
          "signature": "arrow amp0 amp1 yv0 yv1 -\u003e arrow amp1 amp2 yv1 yv2 -\u003e arrow amp0 amp2 yv0 yv2",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Arrow.html#compose",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional Arrow",
          "module": "Synthesizer.Dimensional.Arrow",
          "name": "compose",
          "normalized": "a b b c c-\u003ea b b c c-\u003ea b b c c",
          "package": "synthesizer",
          "signature": "arrow amp amp yv yv-\u003earrow amp amp yv yv-\u003earrow amp amp yv yv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Arrow.html#v:compose"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.Arrow",
          "name": "fanout",
          "package": "synthesizer",
          "signature": "arrow amp amp0 yv yv0 -\u003e arrow amp amp1 yv yv1 -\u003e arrow amp (amp0, amp1) yv (yv0, yv1)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Arrow.html#fanout",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional Arrow",
          "module": "Synthesizer.Dimensional.Arrow",
          "name": "fanout",
          "normalized": "a b b c c-\u003ea b b c c-\u003ea b(b,b)c(c,c)",
          "package": "synthesizer",
          "signature": "arrow amp amp yv yv-\u003earrow amp amp yv yv-\u003earrow amp(amp,amp)yv(yv,yv)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Arrow.html#v:fanout"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.Arrow",
          "name": "first",
          "package": "synthesizer",
          "signature": "arrow amp0 amp1 yv0 yv1 -\u003e arrow (amp0, amp) (amp1, amp) (yv0, yv) (yv1, yv)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Arrow.html#first",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional Arrow",
          "module": "Synthesizer.Dimensional.Arrow",
          "name": "first",
          "normalized": "a b b c c-\u003ea(b,b)(b,b)(c,c)(c,c)",
          "package": "synthesizer",
          "signature": "arrow amp amp yv yv-\u003earrow(amp,amp)(amp,amp)(yv,yv)(yv,yv)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Arrow.html#v:first"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.Arrow",
          "name": "map",
          "package": "synthesizer",
          "signature": "T amp0 amp1 yv0 yv1 -\u003e arrow amp0 amp1 yv0 yv1",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Arrow.html#map",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional Arrow",
          "module": "Synthesizer.Dimensional.Arrow",
          "name": "map",
          "normalized": "T a a b b-\u003ec a a b b",
          "package": "synthesizer",
          "signature": "T amp amp yv yv-\u003earrow amp amp yv yv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Arrow.html#v:map"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.Arrow",
          "name": "second",
          "package": "synthesizer",
          "signature": "arrow amp0 amp1 yv0 yv1 -\u003e arrow (amp, amp0) (amp, amp1) (yv, yv0) (yv, yv1)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Arrow.html#second",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional Arrow",
          "module": "Synthesizer.Dimensional.Arrow",
          "name": "second",
          "normalized": "a b b c c-\u003ea(b,b)(b,b)(c,c)(c,c)",
          "package": "synthesizer",
          "signature": "arrow amp amp yv yv-\u003earrow(amp,amp)(amp,amp)(yv,yv)(yv,yv)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Arrow.html#v:second"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.Arrow",
          "name": "split",
          "package": "synthesizer",
          "signature": "arrow amp0 amp1 yv0 yv1 -\u003e arrow amp2 amp3 yv2 yv3 -\u003e arrow (amp0, amp2) (amp1, amp3) (yv0, yv2) (yv1, yv3)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Arrow.html#split",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional Arrow",
          "module": "Synthesizer.Dimensional.Arrow",
          "name": "split",
          "normalized": "a b b c c-\u003ea b b c c-\u003ea(b,b)(b,b)(c,c)(c,c)",
          "package": "synthesizer",
          "signature": "arrow amp amp yv yv-\u003earrow amp amp yv yv-\u003earrow(amp,amp)(amp,amp)(yv,yv)(yv,yv)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Arrow.html#v:split"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003ctt\u003eecAmp\u003c/tt\u003e is a set of physical units for the external control parameters,\n\u003ctt\u003eec\u003c/tt\u003e is the type for the external control parameters,\n\u003ctt\u003eic\u003c/tt\u003e for internal control parameters.\n",
          "module": "Synthesizer.Dimensional.Causal.ControlledProcess",
          "name": "Converter",
          "package": "synthesizer",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Causal-ControlledProcess.html#Converter",
          "type": "type"
        },
        "index": {
          "description": "ecAmp is set of physical units for the external control parameters ec is the type for the external control parameters ic for internal control parameters",
          "hierarchy": "Synthesizer Dimensional Causal ControlledProcess",
          "module": "Synthesizer.Dimensional.Causal.ControlledProcess",
          "name": "Converter",
          "package": "synthesizer",
          "partial": "Converter",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Causal-ControlledProcess.html#t:Converter"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.Causal.ControlledProcess",
          "name": "RateDep",
          "package": "synthesizer",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Causal-ControlledProcess.html#RateDep",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional Causal ControlledProcess",
          "module": "Synthesizer.Dimensional.Causal.ControlledProcess",
          "name": "RateDep",
          "package": "synthesizer",
          "partial": "Rate Dep",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Causal-ControlledProcess.html#t:RateDep"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.Causal.ControlledProcess",
          "name": "T",
          "package": "synthesizer",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Causal-ControlledProcess.html#T",
          "type": "data"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional Causal ControlledProcess",
          "module": "Synthesizer.Dimensional.Causal.ControlledProcess",
          "name": "T",
          "package": "synthesizer",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Causal-ControlledProcess.html#t:T"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.Causal.ControlledProcess",
          "name": "applyConverter1",
          "package": "synthesizer",
          "signature": "Converter s (T v ecAmp) ec ic -\u003e R s v ecAmp ec -\u003e R s (RateDep s ic)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Causal-ControlledProcess.html#applyConverter1",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional Causal ControlledProcess",
          "module": "Synthesizer.Dimensional.Causal.ControlledProcess",
          "name": "applyConverter1",
          "normalized": "Converter a(T b c)d e-\u003eR a b c d-\u003eR a(RateDep a e)",
          "package": "synthesizer",
          "partial": "Converter",
          "signature": "Converter s(T v ecAmp)ec ic-\u003eR s v ecAmp ec-\u003eR s(RateDep s ic)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Causal-ControlledProcess.html#v:applyConverter1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.Causal.ControlledProcess",
          "name": "applyConverter2",
          "package": "synthesizer",
          "signature": "Converter s (T v0 ecAmp0, T v1 ecAmp1) (ec0, ec1) ic -\u003e R s v0 ecAmp0 ec0 -\u003e R s v1 ecAmp1 ec1 -\u003e R s (RateDep s ic)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Causal-ControlledProcess.html#applyConverter2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional Causal ControlledProcess",
          "module": "Synthesizer.Dimensional.Causal.ControlledProcess",
          "name": "applyConverter2",
          "normalized": "Converter a(T b c,T b c)(d,d)e-\u003eR a b c d-\u003eR a b c d-\u003eR a(RateDep a e)",
          "package": "synthesizer",
          "partial": "Converter",
          "signature": "Converter s(T v ecAmp,T v ecAmp)(ec,ec)ic-\u003eR s v ecAmp ec-\u003eR s v ecAmp ec-\u003eR s(RateDep s ic)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Causal-ControlledProcess.html#v:applyConverter2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.Causal.ControlledProcess",
          "name": "causalFromConverter",
          "package": "synthesizer",
          "signature": "Converter s ecAmp ec ic -\u003e T s ecAmp Flat ec (RateDep s ic)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Causal-ControlledProcess.html#causalFromConverter",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional Causal ControlledProcess",
          "module": "Synthesizer.Dimensional.Causal.ControlledProcess",
          "name": "causalFromConverter",
          "normalized": "Converter a b c d-\u003eT a b Flat c(RateDep a d)",
          "package": "synthesizer",
          "partial": "From Converter",
          "signature": "Converter s ecAmp ec ic-\u003eT s ecAmp Flat ec(RateDep s ic)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Causal-ControlledProcess.html#v:causalFromConverter"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.Causal.ControlledProcess",
          "name": "joinFirstSynchronous",
          "package": "synthesizer",
          "signature": "T s u t (T (Converter s ecAmp ec ic, a) (T s (ampIn, Flat) ampOut (sampIn, RateDep s ic) sampOut)) -\u003e T s u t (T a (T s (ecAmp, ampIn) ampOut (ec, sampIn) sampOut))",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Causal-ControlledProcess.html#joinFirstSynchronous",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional Causal ControlledProcess",
          "module": "Synthesizer.Dimensional.Causal.ControlledProcess",
          "name": "joinFirstSynchronous",
          "normalized": "T a b c(T(Converter a d e f,g)(T a(h,Flat)i(j,RateDep a f)k))-\u003eT a b c(T g(T a(d,h)i(e,j)k))",
          "package": "synthesizer",
          "partial": "First Synchronous",
          "signature": "T s u t(T(Converter s ecAmp ec ic,a)(T s(ampIn,Flat)ampOut(sampIn,RateDep s ic)sampOut))-\u003eT s u t(T a(T s(ecAmp,ampIn)ampOut(ec,sampIn)sampOut))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Causal-ControlledProcess.html#v:joinFirstSynchronous"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.Causal.ControlledProcess",
          "name": "joinFirstSynchronousPlain",
          "package": "synthesizer",
          "signature": "T (Converter s ecAmp ec ic, a) (T s (ampIn, Flat) ampOut (sampIn, RateDep s ic) sampOut) -\u003e T a (T s (ecAmp, ampIn) ampOut (ec, sampIn) sampOut)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Causal-ControlledProcess.html#joinFirstSynchronousPlain",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional Causal ControlledProcess",
          "module": "Synthesizer.Dimensional.Causal.ControlledProcess",
          "name": "joinFirstSynchronousPlain",
          "normalized": "T(Converter a b c d,e)(T a(f,Flat)g(h,RateDep a d)i)-\u003eT e(T a(b,f)g(c,h)i)",
          "package": "synthesizer",
          "partial": "First Synchronous Plain",
          "signature": "T(Converter s ecAmp ec ic,a)(T s(ampIn,Flat)ampOut(sampIn,RateDep s ic)sampOut)-\u003eT a(T s(ecAmp,ampIn)ampOut(ec,sampIn)sampOut)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Causal-ControlledProcess.html#v:joinFirstSynchronousPlain"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.Causal.ControlledProcess",
          "name": "joinSynchronous",
          "package": "synthesizer",
          "signature": "T s u t (T (Converter s ecAmp ec ic) (T s (ampIn, Flat) ampOut (sampIn, RateDep s ic) sampOut)) -\u003e T s u t (T s (ecAmp, ampIn) ampOut (ec, sampIn) sampOut)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Causal-ControlledProcess.html#joinSynchronous",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional Causal ControlledProcess",
          "module": "Synthesizer.Dimensional.Causal.ControlledProcess",
          "name": "joinSynchronous",
          "normalized": "T a b c(T(Converter a d e f)(T a(g,Flat)h(i,RateDep a f)j))-\u003eT a b c(T a(d,g)h(e,i)j)",
          "package": "synthesizer",
          "partial": "Synchronous",
          "signature": "T s u t(T(Converter s ecAmp ec ic)(T s(ampIn,Flat)ampOut(sampIn,RateDep s ic)sampOut))-\u003eT s u t(T s(ecAmp,ampIn)ampOut(ec,sampIn)sampOut)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Causal-ControlledProcess.html#v:joinSynchronous"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.Causal.ControlledProcess",
          "name": "joinSynchronousPlain",
          "package": "synthesizer",
          "signature": "T (Converter s ecAmp ec ic) (T s (ampIn, Flat) ampOut (sampIn, RateDep s ic) sampOut) -\u003e T s (ecAmp, ampIn) ampOut (ec, sampIn) sampOut",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Causal-ControlledProcess.html#joinSynchronousPlain",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional Causal ControlledProcess",
          "module": "Synthesizer.Dimensional.Causal.ControlledProcess",
          "name": "joinSynchronousPlain",
          "normalized": "T(Converter a b c d)(T a(e,Flat)f(g,RateDep a d)h)-\u003eT a(b,e)f(c,g)h",
          "package": "synthesizer",
          "partial": "Synchronous Plain",
          "signature": "T(Converter s ecAmp ec ic)(T s(ampIn,Flat)ampOut(sampIn,RateDep s ic)sampOut)-\u003eT s(ecAmp,ampIn)ampOut(ec,sampIn)sampOut",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Causal-ControlledProcess.html#v:joinSynchronousPlain"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "This function is intended for implementing high-level dimensional processors\nfrom low-level processors.\nIt introduces the sample rate tag \u003ctt\u003es\u003c/tt\u003e.\n",
          "module": "Synthesizer.Dimensional.Causal.ControlledProcess",
          "name": "makeConverter",
          "package": "synthesizer",
          "signature": "(ecAmp -\u003e ec -\u003e ic) -\u003e Converter s ecAmp ec ic",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Causal-ControlledProcess.html#makeConverter",
          "type": "function"
        },
        "index": {
          "description": "This function is intended for implementing high-level dimensional processors from low-level processors It introduces the sample rate tag",
          "hierarchy": "Synthesizer Dimensional Causal ControlledProcess",
          "module": "Synthesizer.Dimensional.Causal.ControlledProcess",
          "name": "makeConverter",
          "normalized": "(a-\u003eb-\u003ec)-\u003eConverter d a b c",
          "package": "synthesizer",
          "partial": "Converter",
          "signature": "(ecAmp-\u003eec-\u003eic)-\u003eConverter s ecAmp ec ic",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Causal-ControlledProcess.html#v:makeConverter"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.Causal.ControlledProcess",
          "name": "processAsynchronous1",
          "package": "synthesizer",
          "signature": "T t (RateDep s ic) -\u003e T s u t (T (Converter s (T v ecAmp) ec ic) (T s (ampIn, Flat) ampOut (sampIn, RateDep s ic) sampOut)) -\u003e T (Recip u) t -\u003e (forall r.  T r u t (R r v ecAmp ec)) -\u003e T s u t (T s ampIn ampOut sampIn sampOut)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Causal-ControlledProcess.html#processAsynchronous1",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional Causal ControlledProcess",
          "module": "Synthesizer.Dimensional.Causal.ControlledProcess",
          "name": "processAsynchronous1",
          "normalized": "T a(RateDep b c)-\u003eT b d a(T(Converter b(T e f)g c)(T b(h,Flat)i(j,RateDep b c)k))-\u003eT(Recip d)a-\u003e(l m T n d a(R n e f g))-\u003eT b d a(T b h i j k)",
          "package": "synthesizer",
          "partial": "Asynchronous",
          "signature": "T t(RateDep s ic)-\u003eT s u t(T(Converter s(T v ecAmp)ec ic)(T s(ampIn,Flat)ampOut(sampIn,RateDep s ic)sampOut))-\u003eT(Recip u)t-\u003e(forall r. T r u t(R r v ecAmp ec))-\u003eT s u t(T s ampIn ampOut sampIn sampOut)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Causal-ControlledProcess.html#v:processAsynchronous1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "This function will be more commonly used than \u003ctt\u003e\u003ca\u003erunAsynchronous2\u003c/a\u003e\u003c/tt\u003e,\nbut it disallows sharing of control signals.\nIt can be easily defined in terms of \u003ctt\u003e\u003ca\u003erunAsynchronous2\u003c/a\u003e\u003c/tt\u003e and \u003ctt\u003e\u003ca\u003erunProcess\u003c/a\u003e\u003c/tt\u003e,\nbut the implementation here does not need the check for equal sample rates.\n",
          "module": "Synthesizer.Dimensional.Causal.ControlledProcess",
          "name": "processAsynchronous2",
          "package": "synthesizer",
          "signature": "T t (RateDep s ic) -\u003e T s u t (T (Converter s (T v0 ecAmp0, T v1 ecAmp1) (ec0, ec1) ic) (T s (ampIn, Flat) ampOut (sampIn, RateDep s ic) sampOut)) -\u003e T (Recip u) t -\u003e (forall r.  T r u t (R r v0 ecAmp0 ec0)) -\u003e (forall r.  T r u t (R r v1 ecAmp1 ec1)) -\u003e T s u t (T s ampIn ampOut sampIn sampOut)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Causal-ControlledProcess.html#processAsynchronous2",
          "type": "function"
        },
        "index": {
          "description": "This function will be more commonly used than runAsynchronous2 but it disallows sharing of control signals It can be easily defined in terms of runAsynchronous2 and runProcess but the implementation here does not need the check for equal sample rates",
          "hierarchy": "Synthesizer Dimensional Causal ControlledProcess",
          "module": "Synthesizer.Dimensional.Causal.ControlledProcess",
          "name": "processAsynchronous2",
          "normalized": "T a(RateDep b c)-\u003eT b d a(T(Converter b(T e f,T e f)(g,g)c)(T b(h,Flat)i(j,RateDep b c)k))-\u003eT(Recip d)a-\u003e(l m T n d a(R n e f g))-\u003e(l m T n d a(R n e f g))-\u003eT b d a(T b h i j k)",
          "package": "synthesizer",
          "partial": "Asynchronous",
          "signature": "T t(RateDep s ic)-\u003eT s u t(T(Converter s(T v ecAmp,T v ecAmp)(ec,ec)ic)(T s(ampIn,Flat)ampOut(sampIn,RateDep s ic)sampOut))-\u003eT(Recip u)t-\u003e(forall r. T r u t(R r v ecAmp ec))-\u003e(forall r. T r u t(R r v ecAmp ec))-\u003eT s u t(T s ampIn ampOut sampIn sampOut)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Causal-ControlledProcess.html#v:processAsynchronous2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis buffers internal control parameters before interpolation.\nThis should be faster, since interpolation needs frequent look-ahead,\nand this is faster on a buffered signal than on a plain stateful signal generator.\n\u003c/p\u003e\u003cp\u003eSince the look-ahead is constant,\nit is interesting whether interpolation can be made more efficient\nwithout the inefficient intermediate list structure.\n\u003c/p\u003e",
          "module": "Synthesizer.Dimensional.Causal.ControlledProcess",
          "name": "processAsynchronousBuffered2",
          "package": "synthesizer",
          "signature": "T t (RateDep s ic) -\u003e T s u t (T (Converter s (T v0 ecAmp0, T v1 ecAmp1) (ec0, ec1) ic) (T s (ampIn, Flat) ampOut (sampIn, RateDep s ic) sampOut)) -\u003e T (Recip u) t -\u003e (forall r.  T r u t (R r v0 ecAmp0 ec0)) -\u003e (forall r.  T r u t (R r v1 ecAmp1 ec1)) -\u003e T s u t (T s ampIn ampOut sampIn sampOut)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Causal-ControlledProcess.html#processAsynchronousBuffered2",
          "type": "function"
        },
        "index": {
          "description": "This buffers internal control parameters before interpolation This should be faster since interpolation needs frequent look-ahead and this is faster on buffered signal than on plain stateful signal generator Since the look-ahead is constant it is interesting whether interpolation can be made more efficient without the inefficient intermediate list structure",
          "hierarchy": "Synthesizer Dimensional Causal ControlledProcess",
          "module": "Synthesizer.Dimensional.Causal.ControlledProcess",
          "name": "processAsynchronousBuffered2",
          "normalized": "T a(RateDep b c)-\u003eT b d a(T(Converter b(T e f,T e f)(g,g)c)(T b(h,Flat)i(j,RateDep b c)k))-\u003eT(Recip d)a-\u003e(l m T n d a(R n e f g))-\u003e(l m T n d a(R n e f g))-\u003eT b d a(T b h i j k)",
          "package": "synthesizer",
          "partial": "Asynchronous Buffered",
          "signature": "T t(RateDep s ic)-\u003eT s u t(T(Converter s(T v ecAmp,T v ecAmp)(ec,ec)ic)(T s(ampIn,Flat)ampOut(sampIn,RateDep s ic)sampOut))-\u003eT(Recip u)t-\u003e(forall r. T r u t(R r v ecAmp ec))-\u003e(forall r. T r u t(R r v ecAmp ec))-\u003eT s u t(T s ampIn ampOut sampIn sampOut)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Causal-ControlledProcess.html#v:processAsynchronousBuffered2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.Causal.ControlledProcess",
          "name": "processAsynchronousNaive2",
          "package": "synthesizer",
          "signature": "T t (RateDep s ic) -\u003e T s u t (T (Converter s (T v0 ecAmp0, T v1 ecAmp1) (ec0, ec1) ic) (T s (ampIn, Flat) ampOut (sampIn, RateDep s ic) sampOut)) -\u003e T (Recip u) t -\u003e (forall r.  T r u t (R r v0 ecAmp0 ec0)) -\u003e (forall r.  T r u t (R r v1 ecAmp1 ec1)) -\u003e T s u t (T s ampIn ampOut sampIn sampOut)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Causal-ControlledProcess.html#processAsynchronousNaive2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional Causal ControlledProcess",
          "module": "Synthesizer.Dimensional.Causal.ControlledProcess",
          "name": "processAsynchronousNaive2",
          "normalized": "T a(RateDep b c)-\u003eT b d a(T(Converter b(T e f,T e f)(g,g)c)(T b(h,Flat)i(j,RateDep b c)k))-\u003eT(Recip d)a-\u003e(l m T n d a(R n e f g))-\u003e(l m T n d a(R n e f g))-\u003eT b d a(T b h i j k)",
          "package": "synthesizer",
          "partial": "Asynchronous Naive",
          "signature": "T t(RateDep s ic)-\u003eT s u t(T(Converter s(T v ecAmp,T v ecAmp)(ec,ec)ic)(T s(ampIn,Flat)ampOut(sampIn,RateDep s ic)sampOut))-\u003eT(Recip u)t-\u003e(forall r. T r u t(R r v ecAmp ec))-\u003e(forall r. T r u t(R r v ecAmp ec))-\u003eT s u t(T s ampIn ampOut sampIn sampOut)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Causal-ControlledProcess.html#v:processAsynchronousNaive2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.Causal.ControlledProcess",
          "name": "runAsynchronous",
          "package": "synthesizer",
          "signature": "T t (RateDep s ic) -\u003e T s u t (T (Converter s ecAmp ec ic) (T s (ampIn, Flat) ampOut (sampIn, RateDep s ic) sampOut)) -\u003e T r u t -\u003e R r (RateDep s ic) -\u003e T s u t (T s ampIn ampOut sampIn sampOut)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Causal-ControlledProcess.html#runAsynchronous",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional Causal ControlledProcess",
          "module": "Synthesizer.Dimensional.Causal.ControlledProcess",
          "name": "runAsynchronous",
          "normalized": "T a(RateDep b c)-\u003eT b d a(T(Converter b e f c)(T b(g,Flat)h(i,RateDep b c)j))-\u003eT k d a-\u003eR k(RateDep b c)-\u003eT b d a(T b g h i j)",
          "package": "synthesizer",
          "partial": "Asynchronous",
          "signature": "T t(RateDep s ic)-\u003eT s u t(T(Converter s ecAmp ec ic)(T s(ampIn,Flat)ampOut(sampIn,RateDep s ic)sampOut))-\u003eT r u t-\u003eR r(RateDep s ic)-\u003eT s u t(T s ampIn ampOut sampIn sampOut)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Causal-ControlledProcess.html#v:runAsynchronous"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.Causal.ControlledProcess",
          "name": "runAsynchronous1",
          "package": "synthesizer",
          "signature": "T t (RateDep s ic) -\u003e T s u t (T (Converter s (T v ecAmp) ec ic) (T s (ampIn, Flat) ampOut (sampIn, RateDep s ic) sampOut)) -\u003e T u t (S v ecAmp) ec -\u003e T s u t (T s ampIn ampOut sampIn sampOut)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Causal-ControlledProcess.html#runAsynchronous1",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional Causal ControlledProcess",
          "module": "Synthesizer.Dimensional.Causal.ControlledProcess",
          "name": "runAsynchronous1",
          "normalized": "T a(RateDep b c)-\u003eT b d a(T(Converter b(T e f)g c)(T b(h,Flat)i(j,RateDep b c)k))-\u003eT d a(S e f)g-\u003eT b d a(T b h i j k)",
          "package": "synthesizer",
          "partial": "Asynchronous",
          "signature": "T t(RateDep s ic)-\u003eT s u t(T(Converter s(T v ecAmp)ec ic)(T s(ampIn,Flat)ampOut(sampIn,RateDep s ic)sampOut))-\u003eT u t(S v ecAmp)ec-\u003eT s u t(T s ampIn ampOut sampIn sampOut)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Causal-ControlledProcess.html#v:runAsynchronous1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Using two SigP.T's as input has the disadvantage\nthat their rates must be compared dynamically.\nIt is not possible with our data structures\nto use one rate for multiple signals.\nWe could also allow the input of a Rate.T and two Proc.T's,\nsince this is the form we get from the computation routines.\nBut this way we lose sharing.\n",
          "module": "Synthesizer.Dimensional.Causal.ControlledProcess",
          "name": "runAsynchronous2",
          "package": "synthesizer",
          "signature": "T t (RateDep s ic) -\u003e T s u t (T (Converter s (T v0 ecAmp0, T v1 ecAmp1) (ec0, ec1) ic) (T s (ampIn, Flat) ampOut (sampIn, RateDep s ic) sampOut)) -\u003e T u t (S v0 ecAmp0) ec0 -\u003e T u t (S v1 ecAmp1) ec1 -\u003e T s u t (T s ampIn ampOut sampIn sampOut)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Causal-ControlledProcess.html#runAsynchronous2",
          "type": "function"
        },
        "index": {
          "description": "Using two SigP.T as input has the disadvantage that their rates must be compared dynamically It is not possible with our data structures to use one rate for multiple signals We could also allow the input of Rate.T and two Proc.T since this is the form we get from the computation routines But this way we lose sharing",
          "hierarchy": "Synthesizer Dimensional Causal ControlledProcess",
          "module": "Synthesizer.Dimensional.Causal.ControlledProcess",
          "name": "runAsynchronous2",
          "normalized": "T a(RateDep b c)-\u003eT b d a(T(Converter b(T e f,T e f)(g,g)c)(T b(h,Flat)i(j,RateDep b c)k))-\u003eT d a(S e f)g-\u003eT d a(S e f)g-\u003eT b d a(T b h i j k)",
          "package": "synthesizer",
          "partial": "Asynchronous",
          "signature": "T t(RateDep s ic)-\u003eT s u t(T(Converter s(T v ecAmp,T v ecAmp)(ec,ec)ic)(T s(ampIn,Flat)ampOut(sampIn,RateDep s ic)sampOut))-\u003eT u t(S v ecAmp)ec-\u003eT u t(S v ecAmp)ec-\u003eT s u t(T s ampIn ampOut sampIn sampOut)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Causal-ControlledProcess.html#v:runAsynchronous2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.Causal.ControlledProcess",
          "name": "runAsynchronousBuffered",
          "package": "synthesizer",
          "signature": "T t (RateDep s ic) -\u003e T s u t (T (Converter s ecAmp ec ic) (T s (ampIn, Flat) ampOut (sampIn, RateDep s ic) sampOut)) -\u003e T r u t -\u003e R r (RateDep s ic) -\u003e T s u t (T s ampIn ampOut sampIn sampOut)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Causal-ControlledProcess.html#runAsynchronousBuffered",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional Causal ControlledProcess",
          "module": "Synthesizer.Dimensional.Causal.ControlledProcess",
          "name": "runAsynchronousBuffered",
          "normalized": "T a(RateDep b c)-\u003eT b d a(T(Converter b e f c)(T b(g,Flat)h(i,RateDep b c)j))-\u003eT k d a-\u003eR k(RateDep b c)-\u003eT b d a(T b g h i j)",
          "package": "synthesizer",
          "partial": "Asynchronous Buffered",
          "signature": "T t(RateDep s ic)-\u003eT s u t(T(Converter s ecAmp ec ic)(T s(ampIn,Flat)ampOut(sampIn,RateDep s ic)sampOut))-\u003eT r u t-\u003eR r(RateDep s ic)-\u003eT s u t(T s ampIn ampOut sampIn sampOut)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Causal-ControlledProcess.html#v:runAsynchronousBuffered"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.Causal.ControlledProcess",
          "name": "runSynchronous1",
          "package": "synthesizer",
          "signature": "T s u t (T (Converter s (T v ecAmp) ec ic) (T s (ampIn, Flat) ampOut (sampIn, RateDep s ic) sampOut)) -\u003e T s u t (R s v ecAmp ec -\u003e T s ampIn ampOut sampIn sampOut)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Causal-ControlledProcess.html#runSynchronous1",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional Causal ControlledProcess",
          "module": "Synthesizer.Dimensional.Causal.ControlledProcess",
          "name": "runSynchronous1",
          "normalized": "T a b c(T(Converter a(T d e)f g)(T a(h,Flat)i(j,RateDep a g)k))-\u003eT a b c(R a d e f-\u003eT a h i j k)",
          "package": "synthesizer",
          "partial": "Synchronous",
          "signature": "T s u t(T(Converter s(T v ecAmp)ec ic)(T s(ampIn,Flat)ampOut(sampIn,RateDep s ic)sampOut))-\u003eT s u t(R s v ecAmp ec-\u003eT s ampIn ampOut sampIn sampOut)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Causal-ControlledProcess.html#v:runSynchronous1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.Causal.ControlledProcess",
          "name": "runSynchronous2",
          "package": "synthesizer",
          "signature": "T s u t (T (Converter s (T v0 ecAmp0, T v1 ecAmp1) (ec0, ec1) ic) (T s (ampIn, Flat) ampOut (sampIn, RateDep s ic) sampOut)) -\u003e T s u t (R s v0 ecAmp0 ec0 -\u003e R s v1 ecAmp1 ec1 -\u003e T s ampIn ampOut sampIn sampOut)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Causal-ControlledProcess.html#runSynchronous2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional Causal ControlledProcess",
          "module": "Synthesizer.Dimensional.Causal.ControlledProcess",
          "name": "runSynchronous2",
          "normalized": "T a b c(T(Converter a(T d e,T d e)(f,f)g)(T a(h,Flat)i(j,RateDep a g)k))-\u003eT a b c(R a d e f-\u003eR a d e f-\u003eT a h i j k)",
          "package": "synthesizer",
          "partial": "Synchronous",
          "signature": "T s u t(T(Converter s(T v ecAmp,T v ecAmp)(ec,ec)ic)(T s(ampIn,Flat)ampOut(sampIn,RateDep s ic)sampOut))-\u003eT s u t(R s v ecAmp ec-\u003eR s v ecAmp ec-\u003eT s ampIn ampOut sampIn sampOut)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Causal-ControlledProcess.html#v:runSynchronous2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.Causal.ControlledProcess",
          "name": "runSynchronousPlain2",
          "package": "synthesizer",
          "signature": "T (Converter s (T v0 ecAmp0, T v1 ecAmp1) (ec0, ec1) ic) (T s (ampIn, Flat) ampOut (sampIn, RateDep s ic) sampOut) -\u003e R s v0 ecAmp0 ec0 -\u003e R s v1 ecAmp1 ec1 -\u003e T s ampIn ampOut sampIn sampOut",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Causal-ControlledProcess.html#runSynchronousPlain2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional Causal ControlledProcess",
          "module": "Synthesizer.Dimensional.Causal.ControlledProcess",
          "name": "runSynchronousPlain2",
          "normalized": "T(Converter a(T b c,T b c)(d,d)e)(T a(f,Flat)g(h,RateDep a e)i)-\u003eR a b c d-\u003eR a b c d-\u003eT a f g h i",
          "package": "synthesizer",
          "partial": "Synchronous Plain",
          "signature": "T(Converter s(T v ecAmp,T v ecAmp)(ec,ec)ic)(T s(ampIn,Flat)ampOut(sampIn,RateDep s ic)sampOut)-\u003eR s v ecAmp ec-\u003eR s v ecAmp ec-\u003eT s ampIn ampOut sampIn sampOut",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Causal-ControlledProcess.html#v:runSynchronousPlain2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Distort the signal using a flat function.\nThe first signal gives the scaling of the function.\nIf the scaling is c and the input sample is y,\nthen \u003ctt\u003ec * f(y/c)\u003c/tt\u003e is output.\nThis way we can use an (efficient) flat function\nand have a simple, yet dimension conform, way of controlling the distortion.\nE.g. if the distortion function is \u003ctt\u003etanh\u003c/tt\u003e\nthen the value \u003ctt\u003ec\u003c/tt\u003e controls the saturation level.\n",
          "module": "Synthesizer.Dimensional.Causal.Displacement",
          "name": "distort",
          "package": "synthesizer",
          "signature": "(yv -\u003e yv) -\u003e T s u t (T s (T v y, T v y) (T v y) (y, yv) yv)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Causal-Displacement.html#distort",
          "type": "function"
        },
        "index": {
          "description": "Distort the signal using flat function The first signal gives the scaling of the function If the scaling is and the input sample is then is output This way we can use an efficient flat function and have simple yet dimension conform way of controlling the distortion E.g if the distortion function is tanh then the value controls the saturation level",
          "hierarchy": "Synthesizer Dimensional Causal Displacement",
          "module": "Synthesizer.Dimensional.Causal.Displacement",
          "name": "distort",
          "normalized": "(a-\u003ea)-\u003eT b c d(T b(T e f,T e f)(T e f)(f,a)a)",
          "package": "synthesizer",
          "signature": "(yv-\u003eyv)-\u003eT s u t(T s(T v y,T v y)(T v y)(y,yv)yv)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Causal-Displacement.html#v:distort"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Mix one or more signals.\n",
          "module": "Synthesizer.Dimensional.Causal.Displacement",
          "name": "fanoutAndMixMulti",
          "package": "synthesizer",
          "signature": "[T s u t (T s ampIn (T v y) yvIn yv)] -\u003e T s u t (T s ampIn (T v y) yvIn yv)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Causal-Displacement.html#fanoutAndMixMulti",
          "type": "function"
        },
        "index": {
          "description": "Mix one or more signals",
          "hierarchy": "Synthesizer Dimensional Causal Displacement",
          "module": "Synthesizer.Dimensional.Causal.Displacement",
          "name": "fanoutAndMixMulti",
          "normalized": "[T a b c(T a d(T e f)g h)]-\u003eT a b c(T a d(T e f)g h)",
          "package": "synthesizer",
          "partial": "And Mix Multi",
          "signature": "[T s u t(T s ampIn(T v y)yvIn yv)]-\u003eT s u t(T s ampIn(T v y)yvIn yv)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Causal-Displacement.html#v:fanoutAndMixMulti"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.Causal.Displacement",
          "name": "fanoutAndMixMultiVolume",
          "package": "synthesizer",
          "signature": "T v y -\u003e [T s u t (T s ampIn (T v y) yvIn yv)] -\u003e T s u t (T s ampIn (T v y) yvIn yv)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Causal-Displacement.html#fanoutAndMixMultiVolume",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional Causal Displacement",
          "module": "Synthesizer.Dimensional.Causal.Displacement",
          "name": "fanoutAndMixMultiVolume",
          "normalized": "T a b-\u003e[T c d e(T c f(T a b)g h)]-\u003eT c d e(T c f(T a b)g h)",
          "package": "synthesizer",
          "partial": "And Mix Multi Volume",
          "signature": "T v y-\u003e[T s u t(T s ampIn(T v y)yvIn yv)]-\u003eT s u t(T s ampIn(T v y)yvIn yv)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Causal-Displacement.html#v:fanoutAndMixMultiVolume"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Mix two signals.\nIn contrast to \u003ctt\u003e\u003ca\u003ezipWith\u003c/a\u003e\u003c/tt\u003e the result has the length of the longer signal.\n",
          "module": "Synthesizer.Dimensional.Causal.Displacement",
          "name": "mix",
          "package": "synthesizer",
          "signature": "T s u t (T s (T v y, T v y) (T v y) (yv, yv) yv)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Causal-Displacement.html#mix",
          "type": "function"
        },
        "index": {
          "description": "Mix two signals In contrast to zipWith the result has the length of the longer signal",
          "hierarchy": "Synthesizer Dimensional Causal Displacement",
          "module": "Synthesizer.Dimensional.Causal.Displacement",
          "name": "mix",
          "normalized": "T a b c(T a(T d e,T d e)(T d e)(f,f)f)",
          "package": "synthesizer",
          "signature": "T s u t(T s(T v y,T v y)(T v y)(yv,yv)yv)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Causal-Displacement.html#v:mix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.Causal.Displacement",
          "name": "mixVolume",
          "package": "synthesizer",
          "signature": "T v y -\u003e T s u t (T s (T v y, T v y) (T v y) (yv, yv) yv)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Causal-Displacement.html#mixVolume",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional Causal Displacement",
          "module": "Synthesizer.Dimensional.Causal.Displacement",
          "name": "mixVolume",
          "normalized": "T a b-\u003eT c d e(T c(T a b,T a b)(T a b)(f,f)f)",
          "package": "synthesizer",
          "partial": "Volume",
          "signature": "T v y-\u003eT s u t(T s(T v y,T v y)(T v y)(yv,yv)yv)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Causal-Displacement.html#v:mixVolume"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Add a number to all of the signal values.\nThis is useful for adjusting the center of a modulation.\n",
          "module": "Synthesizer.Dimensional.Causal.Displacement",
          "name": "raise",
          "package": "synthesizer",
          "signature": "T v y -\u003e yv -\u003e T s u t (T s (T v y) (T v y) yv yv)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Causal-Displacement.html#raise",
          "type": "function"
        },
        "index": {
          "description": "Add number to all of the signal values This is useful for adjusting the center of modulation",
          "hierarchy": "Synthesizer Dimensional Causal Displacement",
          "module": "Synthesizer.Dimensional.Causal.Displacement",
          "name": "raise",
          "normalized": "T a b-\u003ec-\u003eT d e f(T d(T a b)(T a b)c c)",
          "package": "synthesizer",
          "signature": "T v y-\u003eyv-\u003eT s u t(T s(T v y)(T v y)yv yv)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Causal-Displacement.html#v:raise"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.Causal.Filter",
          "name": "FrequencyFilter",
          "package": "synthesizer",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Causal-Filter.html#FrequencyFilter",
          "type": "type"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional Causal Filter",
          "module": "Synthesizer.Dimensional.Causal.Filter",
          "name": "FrequencyFilter",
          "package": "synthesizer",
          "partial": "Frequency Filter",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Causal-Filter.html#t:FrequencyFilter"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.Causal.Filter",
          "name": "ResonantFilter",
          "package": "synthesizer",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Causal-Filter.html#ResonantFilter",
          "type": "type"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional Causal Filter",
          "module": "Synthesizer.Dimensional.Causal.Filter",
          "name": "ResonantFilter",
          "package": "synthesizer",
          "partial": "Resonant Filter",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Causal-Filter.html#t:ResonantFilter"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "order, number of filters in the cascade \nthe phase shift to be achieved for the given frequency \n",
          "module": "Synthesizer.Dimensional.Causal.Filter",
          "name": "allpassCascade",
          "package": "synthesizer",
          "signature": "Int-\u003e q-\u003e FrequencyFilter s u q (Parameter q) amp yv yv",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Causal-Filter.html#allpassCascade",
          "type": "function"
        },
        "index": {
          "description": "order number of filters in the cascade the phase shift to be achieved for the given frequency",
          "hierarchy": "Synthesizer Dimensional Causal Filter",
          "module": "Synthesizer.Dimensional.Causal.Filter",
          "name": "allpassCascade",
          "normalized": "Int-\u003ea-\u003eFrequencyFilter b c a(Parameter a)d e e",
          "package": "synthesizer",
          "partial": "Cascade",
          "signature": "Int-\u003eq-\u003eFrequencyFilter s u q(Parameter q)amp yv yv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Causal-Filter.html#v:allpassCascade"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Synthesizer.Dimensional.Causal.Filter\",\"Synthesizer.Dimensional.Rate.Filter\",\"Synthesizer.Dimensional.RateAmplitude.Filter\"]",
          "name": "allpassFlangerPhase",
          "package": "synthesizer",
          "signature": "a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Rate-Filter.html#allpassFlangerPhase",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Causal-Filter.html#v:allpassFlangerPhase\",\"http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Rate-Filter.html#v:allpassFlangerPhase\",\"http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-RateAmplitude-Filter.html#v:allpassFlangerPhase\"]"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional Causal Filter",
          "module": "Synthesizer.Dimensional.Causal.Filter",
          "name": "allpassFlangerPhase",
          "package": "synthesizer",
          "partial": "Flanger Phase",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Causal-Filter.html#v:allpassFlangerPhase"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "order, number of filters in the cascade \n",
          "module": "Synthesizer.Dimensional.Causal.Filter",
          "name": "allpassPhaser",
          "package": "synthesizer",
          "signature": "Int-\u003e ResonantFilter s u q (q, Parameter q) amp yv yv",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Causal-Filter.html#allpassPhaser",
          "type": "function"
        },
        "index": {
          "description": "order number of filters in the cascade",
          "hierarchy": "Synthesizer Dimensional Causal Filter",
          "module": "Synthesizer.Dimensional.Causal.Filter",
          "name": "allpassPhaser",
          "normalized": "Int-\u003eResonantFilter a b c(c,Parameter c)d e e",
          "package": "synthesizer",
          "partial": "Phaser",
          "signature": "Int-\u003eResonantFilter s u q(q,Parameter q)amp yv yv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Causal-Filter.html#v:allpassPhaser"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "The amplification factor must be positive. \n",
          "module": "Synthesizer.Dimensional.Causal.Filter",
          "name": "amplify",
          "package": "synthesizer",
          "signature": "y -\u003e T s u t (T s amp amp yv yv)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Causal-Filter.html#amplify",
          "type": "function"
        },
        "index": {
          "description": "The amplification factor must be positive",
          "hierarchy": "Synthesizer Dimensional Causal Filter",
          "module": "Synthesizer.Dimensional.Causal.Filter",
          "name": "amplify",
          "normalized": "a-\u003eT b c d(T b e e f f)",
          "package": "synthesizer",
          "signature": "y-\u003eT s u t(T s amp amp yv yv)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Causal-Filter.html#v:amplify"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.Causal.Filter",
          "name": "amplifyDimension",
          "package": "synthesizer",
          "signature": "T v0 y -\u003e T s u t (T s (T v1 y) (T (Mul v0 v1) y) yv yv)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Causal-Filter.html#amplifyDimension",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional Causal Filter",
          "module": "Synthesizer.Dimensional.Causal.Filter",
          "name": "amplifyDimension",
          "normalized": "T a b-\u003eT c d e(T c(T a b)(T(Mul a a)b)f f)",
          "package": "synthesizer",
          "partial": "Dimension",
          "signature": "T v y-\u003eT s u t(T s(T v y)(T(Mul v v)y)yv yv)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Causal-Filter.html#v:amplifyDimension"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.Causal.Filter",
          "name": "bandlimitFromUniversal",
          "package": "synthesizer",
          "signature": "T s amp amp (Result yv) yv",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Causal-Filter.html#bandlimitFromUniversal",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional Causal Filter",
          "module": "Synthesizer.Dimensional.Causal.Filter",
          "name": "bandlimitFromUniversal",
          "package": "synthesizer",
          "partial": "From Universal",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Causal-Filter.html#v:bandlimitFromUniversal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.Causal.Filter",
          "name": "bandpassFromUniversal",
          "package": "synthesizer",
          "signature": "T s amp amp (Result yv) yv",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Causal-Filter.html#bandpassFromUniversal",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional Causal Filter",
          "module": "Synthesizer.Dimensional.Causal.Filter",
          "name": "bandpassFromUniversal",
          "package": "synthesizer",
          "partial": "From Universal",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Causal-Filter.html#v:bandpassFromUniversal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Order of the filter, must be even,\n                     the higher the order, the sharper is the separation of frequencies. \n",
          "module": "Synthesizer.Dimensional.Causal.Filter",
          "name": "butterworthHighpass",
          "package": "synthesizer",
          "signature": "Int-\u003e ResonantFilter s u a (Parameter a) amp yv yv",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Causal-Filter.html#butterworthHighpass",
          "type": "function"
        },
        "index": {
          "description": "Order of the filter must be even the higher the order the sharper is the separation of frequencies",
          "hierarchy": "Synthesizer Dimensional Causal Filter",
          "module": "Synthesizer.Dimensional.Causal.Filter",
          "name": "butterworthHighpass",
          "normalized": "Int-\u003eResonantFilter a b c(Parameter c)d e e",
          "package": "synthesizer",
          "partial": "Highpass",
          "signature": "Int-\u003eResonantFilter s u a(Parameter a)amp yv yv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Causal-Filter.html#v:butterworthHighpass"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Order of the filter, must be even,\n                     the higher the order, the sharper is the separation of frequencies. \n",
          "module": "Synthesizer.Dimensional.Causal.Filter",
          "name": "butterworthHighpassPole",
          "package": "synthesizer",
          "signature": "Int-\u003e ResonantFilter s u q (Pole q) amp yv yv",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Causal-Filter.html#butterworthHighpassPole",
          "type": "function"
        },
        "index": {
          "description": "Order of the filter must be even the higher the order the sharper is the separation of frequencies",
          "hierarchy": "Synthesizer Dimensional Causal Filter",
          "module": "Synthesizer.Dimensional.Causal.Filter",
          "name": "butterworthHighpassPole",
          "normalized": "Int-\u003eResonantFilter a b c(Pole c)d e e",
          "package": "synthesizer",
          "partial": "Highpass Pole",
          "signature": "Int-\u003eResonantFilter s u q(Pole q)amp yv yv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Causal-Filter.html#v:butterworthHighpassPole"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Order of the filter, must be even,\n                     the higher the order, the sharper is the separation of frequencies. \n",
          "module": "Synthesizer.Dimensional.Causal.Filter",
          "name": "butterworthLowpass",
          "package": "synthesizer",
          "signature": "Int-\u003e ResonantFilter s u a (Parameter a) amp yv yv",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Causal-Filter.html#butterworthLowpass",
          "type": "function"
        },
        "index": {
          "description": "Order of the filter must be even the higher the order the sharper is the separation of frequencies",
          "hierarchy": "Synthesizer Dimensional Causal Filter",
          "module": "Synthesizer.Dimensional.Causal.Filter",
          "name": "butterworthLowpass",
          "normalized": "Int-\u003eResonantFilter a b c(Parameter c)d e e",
          "package": "synthesizer",
          "partial": "Lowpass",
          "signature": "Int-\u003eResonantFilter s u a(Parameter a)amp yv yv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Causal-Filter.html#v:butterworthLowpass"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Order of the filter, must be even,\n                     the higher the order, the sharper is the separation of frequencies. \n",
          "module": "Synthesizer.Dimensional.Causal.Filter",
          "name": "butterworthLowpassPole",
          "package": "synthesizer",
          "signature": "Int-\u003e ResonantFilter s u q (Pole q) amp yv yv",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Causal-Filter.html#butterworthLowpassPole",
          "type": "function"
        },
        "index": {
          "description": "Order of the filter must be even the higher the order the sharper is the separation of frequencies",
          "hierarchy": "Synthesizer Dimensional Causal Filter",
          "module": "Synthesizer.Dimensional.Causal.Filter",
          "name": "butterworthLowpassPole",
          "normalized": "Int-\u003eResonantFilter a b c(Pole c)d e e",
          "package": "synthesizer",
          "partial": "Lowpass Pole",
          "signature": "Int-\u003eResonantFilter s u q(Pole q)amp yv yv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Causal-Filter.html#v:butterworthLowpassPole"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.Causal.Filter",
          "name": "chebyshevAHighpass",
          "package": "synthesizer",
          "signature": "Int -\u003e ResonantFilter s u a (ParameterA a) amp yv yv",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Causal-Filter.html#chebyshevAHighpass",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional Causal Filter",
          "module": "Synthesizer.Dimensional.Causal.Filter",
          "name": "chebyshevAHighpass",
          "normalized": "Int-\u003eResonantFilter a b c(ParameterA c)d e e",
          "package": "synthesizer",
          "partial": "AHighpass",
          "signature": "Int-\u003eResonantFilter s u a(ParameterA a)amp yv yv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Causal-Filter.html#v:chebyshevAHighpass"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Order of the filter, must be even,\n                     the higher the order, the sharper is the separation of frequencies. \n",
          "module": "Synthesizer.Dimensional.Causal.Filter",
          "name": "chebyshevAHighpassPole",
          "package": "synthesizer",
          "signature": "Int-\u003e ResonantFilter s u q (Pole q) amp yv yv",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Causal-Filter.html#chebyshevAHighpassPole",
          "type": "function"
        },
        "index": {
          "description": "Order of the filter must be even the higher the order the sharper is the separation of frequencies",
          "hierarchy": "Synthesizer Dimensional Causal Filter",
          "module": "Synthesizer.Dimensional.Causal.Filter",
          "name": "chebyshevAHighpassPole",
          "normalized": "Int-\u003eResonantFilter a b c(Pole c)d e e",
          "package": "synthesizer",
          "partial": "AHighpass Pole",
          "signature": "Int-\u003eResonantFilter s u q(Pole q)amp yv yv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Causal-Filter.html#v:chebyshevAHighpassPole"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.Causal.Filter",
          "name": "chebyshevALowpass",
          "package": "synthesizer",
          "signature": "Int -\u003e ResonantFilter s u a (ParameterA a) amp yv yv",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Causal-Filter.html#chebyshevALowpass",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional Causal Filter",
          "module": "Synthesizer.Dimensional.Causal.Filter",
          "name": "chebyshevALowpass",
          "normalized": "Int-\u003eResonantFilter a b c(ParameterA c)d e e",
          "package": "synthesizer",
          "partial": "ALowpass",
          "signature": "Int-\u003eResonantFilter s u a(ParameterA a)amp yv yv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Causal-Filter.html#v:chebyshevALowpass"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Order of the filter, must be even,\n                     the higher the order, the sharper is the separation of frequencies. \n",
          "module": "Synthesizer.Dimensional.Causal.Filter",
          "name": "chebyshevALowpassPole",
          "package": "synthesizer",
          "signature": "Int-\u003e ResonantFilter s u q (Pole q) amp yv yv",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Causal-Filter.html#chebyshevALowpassPole",
          "type": "function"
        },
        "index": {
          "description": "Order of the filter must be even the higher the order the sharper is the separation of frequencies",
          "hierarchy": "Synthesizer Dimensional Causal Filter",
          "module": "Synthesizer.Dimensional.Causal.Filter",
          "name": "chebyshevALowpassPole",
          "normalized": "Int-\u003eResonantFilter a b c(Pole c)d e e",
          "package": "synthesizer",
          "partial": "ALowpass Pole",
          "signature": "Int-\u003eResonantFilter s u q(Pole q)amp yv yv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Causal-Filter.html#v:chebyshevALowpassPole"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.Causal.Filter",
          "name": "chebyshevBHighpass",
          "package": "synthesizer",
          "signature": "Int -\u003e ResonantFilter s u a (ParameterB a) amp yv yv",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Causal-Filter.html#chebyshevBHighpass",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional Causal Filter",
          "module": "Synthesizer.Dimensional.Causal.Filter",
          "name": "chebyshevBHighpass",
          "normalized": "Int-\u003eResonantFilter a b c(ParameterB c)d e e",
          "package": "synthesizer",
          "partial": "BHighpass",
          "signature": "Int-\u003eResonantFilter s u a(ParameterB a)amp yv yv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Causal-Filter.html#v:chebyshevBHighpass"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Order of the filter, must be even,\n                     the higher the order, the sharper is the separation of frequencies. \n",
          "module": "Synthesizer.Dimensional.Causal.Filter",
          "name": "chebyshevBHighpassPole",
          "package": "synthesizer",
          "signature": "Int-\u003e ResonantFilter s u q (Pole q) amp yv yv",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Causal-Filter.html#chebyshevBHighpassPole",
          "type": "function"
        },
        "index": {
          "description": "Order of the filter must be even the higher the order the sharper is the separation of frequencies",
          "hierarchy": "Synthesizer Dimensional Causal Filter",
          "module": "Synthesizer.Dimensional.Causal.Filter",
          "name": "chebyshevBHighpassPole",
          "normalized": "Int-\u003eResonantFilter a b c(Pole c)d e e",
          "package": "synthesizer",
          "partial": "BHighpass Pole",
          "signature": "Int-\u003eResonantFilter s u q(Pole q)amp yv yv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Causal-Filter.html#v:chebyshevBHighpassPole"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.Causal.Filter",
          "name": "chebyshevBLowpass",
          "package": "synthesizer",
          "signature": "Int -\u003e ResonantFilter s u a (ParameterB a) amp yv yv",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Causal-Filter.html#chebyshevBLowpass",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional Causal Filter",
          "module": "Synthesizer.Dimensional.Causal.Filter",
          "name": "chebyshevBLowpass",
          "normalized": "Int-\u003eResonantFilter a b c(ParameterB c)d e e",
          "package": "synthesizer",
          "partial": "BLowpass",
          "signature": "Int-\u003eResonantFilter s u a(ParameterB a)amp yv yv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Causal-Filter.html#v:chebyshevBLowpass"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Order of the filter, must be even,\n                     the higher the order, the sharper is the separation of frequencies. \n",
          "module": "Synthesizer.Dimensional.Causal.Filter",
          "name": "chebyshevBLowpassPole",
          "package": "synthesizer",
          "signature": "Int-\u003e ResonantFilter s u q (Pole q) amp yv yv",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Causal-Filter.html#chebyshevBLowpassPole",
          "type": "function"
        },
        "index": {
          "description": "Order of the filter must be even the higher the order the sharper is the separation of frequencies",
          "hierarchy": "Synthesizer Dimensional Causal Filter",
          "module": "Synthesizer.Dimensional.Causal.Filter",
          "name": "chebyshevBLowpassPole",
          "normalized": "Int-\u003eResonantFilter a b c(Pole c)d e e",
          "package": "synthesizer",
          "partial": "BLowpass Pole",
          "signature": "Int-\u003eResonantFilter s u q(Pole q)amp yv yv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Causal-Filter.html#v:chebyshevBLowpassPole"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.Causal.Filter",
          "name": "differentiate",
          "package": "synthesizer",
          "signature": "T s u q (T s (T v q) (T (DimensionGradient u v) q) yv yv)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Causal-Filter.html#differentiate",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional Causal Filter",
          "module": "Synthesizer.Dimensional.Causal.Filter",
          "name": "differentiate",
          "package": "synthesizer",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Causal-Filter.html#v:differentiate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.Causal.Filter",
          "name": "envelope",
          "package": "synthesizer",
          "signature": "T s u t (T s (Flat, amp) amp (y, y) y)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Causal-Filter.html#envelope",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional Causal Filter",
          "module": "Synthesizer.Dimensional.Causal.Filter",
          "name": "envelope",
          "normalized": "T a b c(T a(Flat,d)d(e,e)e)",
          "package": "synthesizer",
          "signature": "T s u t(T s(Flat,amp)amp(y,y)y)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Causal-Filter.html#v:envelope"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.Causal.Filter",
          "name": "envelopeVector",
          "package": "synthesizer",
          "signature": "T s u t (T s (Flat, amp) amp (y, yv) yv)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Causal-Filter.html#envelopeVector",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional Causal Filter",
          "module": "Synthesizer.Dimensional.Causal.Filter",
          "name": "envelopeVector",
          "normalized": "T a b c(T a(Flat,d)d(e,f)f)",
          "package": "synthesizer",
          "partial": "Vector",
          "signature": "T s u t(T s(Flat,amp)amp(y,yv)yv)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Causal-Filter.html#v:envelopeVector"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.Causal.Filter",
          "name": "envelopeVectorDimension",
          "package": "synthesizer",
          "signature": "T s u t (T s (T v0 y, T v1 y) (T (Mul v0 v1) y) (y0, yv) yv)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Causal-Filter.html#envelopeVectorDimension",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional Causal Filter",
          "module": "Synthesizer.Dimensional.Causal.Filter",
          "name": "envelopeVectorDimension",
          "normalized": "T a b c(T a(T d e,T d e)(T(Mul d d)e)(e,f)f)",
          "package": "synthesizer",
          "partial": "Vector Dimension",
          "signature": "T s u t(T s(T v y,T v y)(T(Mul v v)y)(y,yv)yv)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Causal-Filter.html#v:envelopeVectorDimension"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.Causal.Filter",
          "name": "firstOrderHighpass",
          "package": "synthesizer",
          "signature": "FrequencyFilter s u q (Parameter q) amp yv yv",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Causal-Filter.html#firstOrderHighpass",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional Causal Filter",
          "module": "Synthesizer.Dimensional.Causal.Filter",
          "name": "firstOrderHighpass",
          "package": "synthesizer",
          "partial": "Order Highpass",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Causal-Filter.html#v:firstOrderHighpass"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.Causal.Filter",
          "name": "firstOrderLowpass",
          "package": "synthesizer",
          "signature": "FrequencyFilter s u q (Parameter q) amp yv yv",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Causal-Filter.html#firstOrderLowpass",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional Causal Filter",
          "module": "Synthesizer.Dimensional.Causal.Filter",
          "name": "firstOrderLowpass",
          "package": "synthesizer",
          "partial": "Order Lowpass",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Causal-Filter.html#v:firstOrderLowpass"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.Causal.Filter",
          "name": "highpassFromUniversal",
          "package": "synthesizer",
          "signature": "T s amp amp (Result yv) yv",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Causal-Filter.html#highpassFromUniversal",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional Causal Filter",
          "module": "Synthesizer.Dimensional.Causal.Filter",
          "name": "highpassFromUniversal",
          "package": "synthesizer",
          "partial": "From Universal",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Causal-Filter.html#v:highpassFromUniversal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.Causal.Filter",
          "name": "integrate",
          "package": "synthesizer",
          "signature": "T s u q (T s (T v q) (T (Mul u v) q) yv yv)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Causal-Filter.html#integrate",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional Causal Filter",
          "module": "Synthesizer.Dimensional.Causal.Filter",
          "name": "integrate",
          "package": "synthesizer",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Causal-Filter.html#v:integrate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.Causal.Filter",
          "name": "lowpassFromUniversal",
          "package": "synthesizer",
          "signature": "T s amp amp (Result yv) yv",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Causal-Filter.html#lowpassFromUniversal",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional Causal Filter",
          "module": "Synthesizer.Dimensional.Causal.Filter",
          "name": "lowpassFromUniversal",
          "package": "synthesizer",
          "partial": "From Universal",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Causal-Filter.html#v:lowpassFromUniversal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.Causal.Filter",
          "name": "moogLowpass",
          "package": "synthesizer",
          "signature": "Int -\u003e ResonantFilter s u q (Parameter q) amp yv yv",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Causal-Filter.html#moogLowpass",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional Causal Filter",
          "module": "Synthesizer.Dimensional.Causal.Filter",
          "name": "moogLowpass",
          "normalized": "Int-\u003eResonantFilter a b c(Parameter c)d e e",
          "package": "synthesizer",
          "partial": "Lowpass",
          "signature": "Int-\u003eResonantFilter s u q(Parameter q)amp yv yv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Causal-Filter.html#v:moogLowpass"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.Causal.Filter",
          "name": "negate",
          "package": "synthesizer",
          "signature": "T s u t (T s amp amp yv yv)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Causal-Filter.html#negate",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional Causal Filter",
          "module": "Synthesizer.Dimensional.Causal.Filter",
          "name": "negate",
          "package": "synthesizer",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Causal-Filter.html#v:negate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.Causal.Filter",
          "name": "universal",
          "package": "synthesizer",
          "signature": "ResonantFilter s u q (Parameter q) amp yv (Result yv)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Causal-Filter.html#universal",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional Causal Filter",
          "module": "Synthesizer.Dimensional.Causal.Filter",
          "name": "universal",
          "package": "synthesizer",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Causal-Filter.html#v:universal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "waveform \nstart phase \n",
          "module": "Synthesizer.Dimensional.Causal.Oscillator",
          "name": "freqMod",
          "package": "synthesizer",
          "signature": "wave y-\u003e T t-\u003e T s u t (T s (T (Recip u) t) amp t y)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Causal-Oscillator.html#freqMod",
          "type": "function"
        },
        "index": {
          "description": "waveform start phase",
          "hierarchy": "Synthesizer Dimensional Causal Oscillator",
          "module": "Synthesizer.Dimensional.Causal.Oscillator",
          "name": "freqMod",
          "normalized": "a b-\u003eT c-\u003eT d e c(T d(T(Recip e)c)f c b)",
          "package": "synthesizer",
          "partial": "Mod",
          "signature": "wave y-\u003eT t-\u003eT s u t(T s(T(Recip u)t)amp t y)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Causal-Oscillator.html#v:freqMod"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "waveform \nstart phase \n",
          "module": "Synthesizer.Dimensional.Causal.Oscillator",
          "name": "freqModAntiAlias",
          "package": "synthesizer",
          "signature": "wave y-\u003e T t-\u003e T s u t (T s (T (Recip u) t) amp t y)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Causal-Oscillator.html#freqModAntiAlias",
          "type": "function"
        },
        "index": {
          "description": "waveform start phase",
          "hierarchy": "Synthesizer Dimensional Causal Oscillator",
          "module": "Synthesizer.Dimensional.Causal.Oscillator",
          "name": "freqModAntiAlias",
          "normalized": "a b-\u003eT c-\u003eT d e c(T d(T(Recip e)c)f c b)",
          "package": "synthesizer",
          "partial": "Mod Anti Alias",
          "signature": "wave y-\u003eT t-\u003eT s u t(T s(T(Recip u)t)amp t y)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Causal-Oscillator.html#v:freqModAntiAlias"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "waveform \n",
          "module": "Synthesizer.Dimensional.Causal.Oscillator",
          "name": "phaseFreqMod",
          "package": "synthesizer",
          "signature": "wave y-\u003e T s u t (T s (Flat, T (Recip u) t) amp (t, t) y)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Causal-Oscillator.html#phaseFreqMod",
          "type": "function"
        },
        "index": {
          "description": "waveform",
          "hierarchy": "Synthesizer Dimensional Causal Oscillator",
          "module": "Synthesizer.Dimensional.Causal.Oscillator",
          "name": "phaseFreqMod",
          "normalized": "a b-\u003eT c d e(T c(Flat,T(Recip d)e)f(e,e)b)",
          "package": "synthesizer",
          "partial": "Freq Mod",
          "signature": "wave y-\u003eT s u t(T s(Flat,T(Recip u)t)amp(t,t)y)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Causal-Oscillator.html#v:phaseFreqMod"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "waveform \nfrequency \n",
          "module": "Synthesizer.Dimensional.Causal.Oscillator",
          "name": "phaseMod",
          "package": "synthesizer",
          "signature": "wave y-\u003e T (Recip u) t-\u003e T s u t (T s Flat amp t y)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Causal-Oscillator.html#phaseMod",
          "type": "function"
        },
        "index": {
          "description": "waveform frequency",
          "hierarchy": "Synthesizer Dimensional Causal Oscillator",
          "module": "Synthesizer.Dimensional.Causal.Oscillator",
          "name": "phaseMod",
          "normalized": "a b-\u003eT(Recip c)d-\u003eT e c d(T e Flat f d b)",
          "package": "synthesizer",
          "partial": "Mod",
          "signature": "wave y-\u003eT(Recip u)t-\u003eT s u t(T s Flat amp t y)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Causal-Oscillator.html#v:phaseMod"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "waveform \nphase \n",
          "module": "Synthesizer.Dimensional.Causal.Oscillator",
          "name": "shapeFreqMod",
          "package": "synthesizer",
          "signature": "c -\u003e T t y-\u003e T t-\u003e T s u t (T s (Flat, T (Recip u) t) Flat (c, t) y)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Causal-Oscillator.html#shapeFreqMod",
          "type": "function"
        },
        "index": {
          "description": "waveform phase",
          "hierarchy": "Synthesizer Dimensional Causal Oscillator",
          "module": "Synthesizer.Dimensional.Causal.Oscillator",
          "name": "shapeFreqMod",
          "normalized": "a-\u003eT b c-\u003eT b-\u003eT d e b(T d(Flat,T(Recip e)b)Flat(a,b)c)",
          "package": "synthesizer",
          "partial": "Freq Mod",
          "signature": "c-\u003eT t y-\u003eT t-\u003eT s u t(T s(Flat,T(Recip u)t)Flat(c,t)y)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Causal-Oscillator.html#v:shapeFreqMod"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "source frequency \n",
          "module": "Synthesizer.Dimensional.Causal.Oscillator",
          "name": "shapeFreqModFromSampledTone",
          "package": "synthesizer",
          "signature": "T t yv-\u003e T t yv-\u003e T (Recip u) t-\u003e T u t signal yv-\u003e t-\u003e T t-\u003e T s u t (T s (Flat, T (Recip u) t) amp (t, t) yv)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Causal-Oscillator.html#shapeFreqModFromSampledTone",
          "type": "function"
        },
        "index": {
          "description": "source frequency",
          "hierarchy": "Synthesizer Dimensional Causal Oscillator",
          "module": "Synthesizer.Dimensional.Causal.Oscillator",
          "name": "shapeFreqModFromSampledTone",
          "normalized": "T a b-\u003eT a b-\u003eT(Recip c)a-\u003eT c a d b-\u003ea-\u003eT a-\u003eT e c a(T e(Flat,T(Recip c)a)f(a,a)b)",
          "package": "synthesizer",
          "partial": "Freq Mod From Sampled Tone",
          "signature": "T t yv-\u003eT t yv-\u003eT(Recip u)t-\u003eT u t signal yv-\u003et-\u003eT t-\u003eT s u t(T s(Flat,T(Recip u)t)amp(t,t)yv)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Causal-Oscillator.html#v:shapeFreqModFromSampledTone"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "waveform \nphase \nfrequency \n",
          "module": "Synthesizer.Dimensional.Causal.Oscillator",
          "name": "shapeMod",
          "package": "synthesizer",
          "signature": "c -\u003e T t y-\u003e T t-\u003e T (Recip u) t-\u003e T s u t (T s Flat Flat c y)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Causal-Oscillator.html#shapeMod",
          "type": "function"
        },
        "index": {
          "description": "waveform phase frequency",
          "hierarchy": "Synthesizer Dimensional Causal Oscillator",
          "module": "Synthesizer.Dimensional.Causal.Oscillator",
          "name": "shapeMod",
          "normalized": "a-\u003eT b c-\u003eT b-\u003eT(Recip d)b-\u003eT e d b(T e Flat Flat a c)",
          "package": "synthesizer",
          "partial": "Mod",
          "signature": "c-\u003eT t y-\u003eT t-\u003eT(Recip u)t-\u003eT s u t(T s Flat Flat c y)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Causal-Oscillator.html#v:shapeMod"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "source frequency \n",
          "module": "Synthesizer.Dimensional.Causal.Oscillator",
          "name": "shapePhaseFreqModFromSampledTone",
          "package": "synthesizer",
          "signature": "T t yv-\u003e T t yv-\u003e T (Recip u) t-\u003e T u t signal yv-\u003e t-\u003e T t-\u003e T s u t (T s (Flat, Flat, T (Recip u) t) amp (t, t, t) yv)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Causal-Oscillator.html#shapePhaseFreqModFromSampledTone",
          "type": "function"
        },
        "index": {
          "description": "source frequency",
          "hierarchy": "Synthesizer Dimensional Causal Oscillator",
          "module": "Synthesizer.Dimensional.Causal.Oscillator",
          "name": "shapePhaseFreqModFromSampledTone",
          "normalized": "T a b-\u003eT a b-\u003eT(Recip c)a-\u003eT c a d b-\u003ea-\u003eT a-\u003eT e c a(T e(Flat,Flat,T(Recip c)a)f(a,a,a)b)",
          "package": "synthesizer",
          "partial": "Phase Freq Mod From Sampled Tone",
          "signature": "T t yv-\u003eT t yv-\u003eT(Recip u)t-\u003eT u t signal yv-\u003et-\u003eT t-\u003eT s u t(T s(Flat,Flat,T(Recip u)t)amp(t,t,t)yv)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Causal-Oscillator.html#v:shapePhaseFreqModFromSampledTone"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.Causal.Process",
          "name": "Flat",
          "package": "synthesizer",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Amplitude.html#Flat",
          "type": "data"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional Causal Process",
          "module": "Synthesizer.Dimensional.Causal.Process",
          "name": "Flat",
          "package": "synthesizer",
          "partial": "Flat",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Causal-Process.html#t:Flat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.Causal.Process",
          "name": "T",
          "package": "synthesizer",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Causal-Process.html#T",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional Causal Process",
          "module": "Synthesizer.Dimensional.Causal.Process",
          "name": "T",
          "package": "synthesizer",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Causal-Process.html#t:T"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.Causal.Process",
          "package": "synthesizer",
          "signature": "T s amp amp0 yv yv0 -\u003e T s amp amp1 yv yv1 -\u003e T s amp (amp0, amp1) yv (yv0, yv1)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Causal-Process.html#%26%26%26",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional Causal Process",
          "module": "Synthesizer.Dimensional.Causal.Process",
          "normalized": "T a b b c c-\u003eT a b b c c-\u003eT a b(b,b)c(c,c)",
          "package": "synthesizer",
          "signature": "T s amp amp yv yv-\u003eT s amp amp yv yv-\u003eT s amp(amp,amp)yv(yv,yv)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Causal-Process.html#v:"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.Causal.Process",
          "name": "$/-",
          "package": "synthesizer",
          "signature": "f (T s (T v0 y0) (T v1 y1) y0 yv1) -\u003e T v0 y0 -\u003e f (R s v1 y1 yv1)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Causal-Process.html#%24%2F-",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional Causal Process",
          "module": "Synthesizer.Dimensional.Causal.Process",
          "name": "$/-",
          "normalized": "a(T b(T c d)(T c d)d e)-\u003eT c d-\u003ea(R b c d e)",
          "package": "synthesizer",
          "signature": "f(T s(T v y)(T v y)y yv)-\u003eT v y-\u003ef(R s v y yv)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Causal-Process.html#v:$/-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.Causal.Process",
          "name": "$/:",
          "package": "synthesizer",
          "signature": "f (T s (T v0 y0) (T v1 y1) yv0 yv1) -\u003e f (R s v0 y0 yv0) -\u003e f (R s v1 y1 yv1)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Causal-Process.html#%24%2F%3A",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional Causal Process",
          "module": "Synthesizer.Dimensional.Causal.Process",
          "name": "$/:",
          "normalized": "a(T b(T c d)(T c d)e e)-\u003ea(R b c d e)-\u003ea(R b c d e)",
          "package": "synthesizer",
          "signature": "f(T s(T v y)(T v y)yv yv)-\u003ef(R s v y yv)-\u003ef(R s v y yv)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Causal-Process.html#v:$/:"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.Causal.Process",
          "name": "***",
          "package": "synthesizer",
          "signature": "T s amp0 amp1 yv0 yv1 -\u003e T s amp2 amp3 yv2 yv3 -\u003e T s (amp0, amp2) (amp1, amp3) (yv0, yv2) (yv1, yv3)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Causal-Process.html#%2A%2A%2A",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional Causal Process",
          "module": "Synthesizer.Dimensional.Causal.Process",
          "name": "***",
          "normalized": "T a b b c c-\u003eT a b b c c-\u003eT a(b,b)(b,b)(c,c)(c,c)",
          "package": "synthesizer",
          "signature": "T s amp amp yv yv-\u003eT s amp amp yv yv-\u003eT s(amp,amp)(amp,amp)(yv,yv)(yv,yv)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Causal-Process.html#v:***"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.Causal.Process",
          "name": "\u003c\u003c\u003c",
          "package": "synthesizer",
          "signature": "T s amp1 amp2 yv1 yv2 -\u003e T s amp0 amp1 yv0 yv1 -\u003e T s amp0 amp2 yv0 yv2",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Causal-Process.html#%3C%3C%3C",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional Causal Process",
          "module": "Synthesizer.Dimensional.Causal.Process",
          "name": "\u003c\u003c\u003c",
          "normalized": "T a b b c c-\u003eT a b b c c-\u003eT a b b c c",
          "package": "synthesizer",
          "signature": "T s amp amp yv yv-\u003eT s amp amp yv yv-\u003eT s amp amp yv yv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Causal-Process.html#v:\u003c\u003c\u003c"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Precomposition with a pure function (right-to-left variant).\n",
          "module": "Synthesizer.Dimensional.Causal.Process",
          "name": "\u003c\u003c^",
          "package": "synthesizer",
          "signature": "T s amp1 amp2 yv1 yv2 -\u003e T amp0 amp1 yv0 yv1 -\u003e T s amp0 amp2 yv0 yv2",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Causal-Process.html#%3C%3C%5E",
          "type": "function"
        },
        "index": {
          "description": "Precomposition with pure function right-to-left variant",
          "hierarchy": "Synthesizer Dimensional Causal Process",
          "module": "Synthesizer.Dimensional.Causal.Process",
          "name": "\u003c\u003c^",
          "normalized": "T a b b c c-\u003eT b b c c-\u003eT a b b c c",
          "package": "synthesizer",
          "signature": "T s amp amp yv yv-\u003eT amp amp yv yv-\u003eT s amp amp yv yv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Causal-Process.html#v:\u003c\u003c^"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.Causal.Process",
          "name": "\u003e\u003e\u003e",
          "package": "synthesizer",
          "signature": "T s amp0 amp1 yv0 yv1 -\u003e T s amp1 amp2 yv1 yv2 -\u003e T s amp0 amp2 yv0 yv2",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Causal-Process.html#%3E%3E%3E",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional Causal Process",
          "module": "Synthesizer.Dimensional.Causal.Process",
          "name": "\u003e\u003e\u003e",
          "normalized": "T a b b c c-\u003eT a b b c c-\u003eT a b b c c",
          "package": "synthesizer",
          "signature": "T s amp amp yv yv-\u003eT s amp amp yv yv-\u003eT s amp amp yv yv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Causal-Process.html#v:\u003e\u003e\u003e"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Postcomposition with a pure function.\n",
          "module": "Synthesizer.Dimensional.Causal.Process",
          "name": "\u003e\u003e^",
          "package": "synthesizer",
          "signature": "T s amp0 amp1 yv0 yv1 -\u003e T amp1 amp2 yv1 yv2 -\u003e T s amp0 amp2 yv0 yv2",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Causal-Process.html#%3E%3E%5E",
          "type": "function"
        },
        "index": {
          "description": "Postcomposition with pure function",
          "hierarchy": "Synthesizer Dimensional Causal Process",
          "module": "Synthesizer.Dimensional.Causal.Process",
          "name": "\u003e\u003e^",
          "normalized": "T a b b c c-\u003eT b b c c-\u003eT a b b c c",
          "package": "synthesizer",
          "signature": "T s amp amp yv yv-\u003eT amp amp yv yv-\u003eT s amp amp yv yv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Causal-Process.html#v:\u003e\u003e^"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Postcomposition with a pure function (right-to-left variant).\n",
          "module": "Synthesizer.Dimensional.Causal.Process",
          "name": "^\u003c\u003c",
          "package": "synthesizer",
          "signature": "T amp1 amp2 yv1 yv2 -\u003e T s amp0 amp1 yv0 yv1 -\u003e T s amp0 amp2 yv0 yv2",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Causal-Process.html#%5E%3C%3C",
          "type": "function"
        },
        "index": {
          "description": "Postcomposition with pure function right-to-left variant",
          "hierarchy": "Synthesizer Dimensional Causal Process",
          "module": "Synthesizer.Dimensional.Causal.Process",
          "name": "^\u003c\u003c",
          "normalized": "T a a b b-\u003eT c a a b b-\u003eT c a a b b",
          "package": "synthesizer",
          "signature": "T amp amp yv yv-\u003eT s amp amp yv yv-\u003eT s amp amp yv yv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Causal-Process.html#v:^\u003c\u003c"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Precomposition with a pure function.\n",
          "module": "Synthesizer.Dimensional.Causal.Process",
          "name": "^\u003e\u003e",
          "package": "synthesizer",
          "signature": "T amp0 amp1 yv0 yv1 -\u003e T s amp1 amp2 yv1 yv2 -\u003e T s amp0 amp2 yv0 yv2",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Causal-Process.html#%5E%3E%3E",
          "type": "function"
        },
        "index": {
          "description": "Precomposition with pure function",
          "hierarchy": "Synthesizer Dimensional Causal Process",
          "module": "Synthesizer.Dimensional.Causal.Process",
          "name": "^\u003e\u003e",
          "normalized": "T a a b b-\u003eT c a a b b-\u003eT c a a b b",
          "package": "synthesizer",
          "signature": "T amp amp yv yv-\u003eT s amp amp yv yv-\u003eT s amp amp yv yv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Causal-Process.html#v:^\u003e\u003e"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.Causal.Process",
          "name": "apply",
          "package": "synthesizer",
          "signature": "T s amp0 amp1 yv0 yv1 -\u003e T s signal0 yv0 -\u003e T s signal1 yv1",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Causal-Process.html#apply",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional Causal Process",
          "module": "Synthesizer.Dimensional.Causal.Process",
          "name": "apply",
          "normalized": "T a b b c c-\u003eT a d c-\u003eT a d c",
          "package": "synthesizer",
          "signature": "T s amp amp yv yv-\u003eT s signal yv-\u003eT s signal yv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Causal-Process.html#v:apply"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.Causal.Process",
          "name": "applyConst",
          "package": "synthesizer",
          "signature": "T s (T v0 y0) (T v1 y1) y0 yv1 -\u003e T v0 y0 -\u003e R s v1 y1 yv1",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Causal-Process.html#applyConst",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional Causal Process",
          "module": "Synthesizer.Dimensional.Causal.Process",
          "name": "applyConst",
          "normalized": "T a(T b c)(T b c)c d-\u003eT b c-\u003eR a b c d",
          "package": "synthesizer",
          "partial": "Const",
          "signature": "T s(T v y)(T v y)y yv-\u003eT v y-\u003eR s v y yv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Causal-Process.html#v:applyConst"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.Causal.Process",
          "name": "applyFlat",
          "package": "synthesizer",
          "signature": "T s Flat (T v1 y1) yv0 yv1 -\u003e T s sig yv0 -\u003e R s v1 y1 yv1",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Causal-Process.html#applyFlat",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional Causal Process",
          "module": "Synthesizer.Dimensional.Causal.Process",
          "name": "applyFlat",
          "normalized": "T a Flat(T b c)d d-\u003eT a e d-\u003eR a b c d",
          "package": "synthesizer",
          "partial": "Flat",
          "signature": "T s Flat(T v y)yv yv-\u003eT s sig yv-\u003eR s v y yv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Causal-Process.html#v:applyFlat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.Causal.Process",
          "name": "applyFlatFst",
          "package": "synthesizer",
          "signature": "T s (Flat, restAmpIn) restAmpOut (yv, restSampIn) restSampOut -\u003e T s sig yv -\u003e T s restAmpIn restAmpOut restSampIn restSampOut",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Causal-Process.html#applyFlatFst",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional Causal Process",
          "module": "Synthesizer.Dimensional.Causal.Process",
          "name": "applyFlatFst",
          "normalized": "T a(Flat,b)c(d,e)f-\u003eT a g d-\u003eT a b c e f",
          "package": "synthesizer",
          "partial": "Flat Fst",
          "signature": "T s(Flat,restAmpIn)restAmpOut(yv,restSampIn)restSampOut-\u003eT s sig yv-\u003eT s restAmpIn restAmpOut restSampIn restSampOut",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Causal-Process.html#v:applyFlatFst"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.Causal.Process",
          "name": "applyFlatFst'",
          "package": "synthesizer",
          "signature": "T s (Flat, restAmpIn) restAmpOut (yv, restSampIn) restSampOut -\u003e T s sig yv -\u003e T s restAmpIn restAmpOut restSampIn restSampOut",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Causal-Process.html#applyFlatFst%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional Causal Process",
          "module": "Synthesizer.Dimensional.Causal.Process",
          "name": "applyFlatFst'",
          "normalized": "T a(Flat,b)c(d,e)f-\u003eT a g d-\u003eT a b c e f",
          "package": "synthesizer",
          "partial": "Flat Fst'",
          "signature": "T s(Flat,restAmpIn)restAmpOut(yv,restSampIn)restSampOut-\u003eT s sig yv-\u003eT s restAmpIn restAmpOut restSampIn restSampOut",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Causal-Process.html#v:applyFlatFst'"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.Causal.Process",
          "name": "applyFst",
          "package": "synthesizer",
          "signature": "T s (T v y, restAmpIn) restAmpOut (yv, restSampIn) restSampOut -\u003e R s v y yv -\u003e T s restAmpIn restAmpOut restSampIn restSampOut",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Causal-Process.html#applyFst",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional Causal Process",
          "module": "Synthesizer.Dimensional.Causal.Process",
          "name": "applyFst",
          "normalized": "T a(T b c,d)e(f,g)h-\u003eR a b c f-\u003eT a d e g h",
          "package": "synthesizer",
          "partial": "Fst",
          "signature": "T s(T v y,restAmpIn)restAmpOut(yv,restSampIn)restSampOut-\u003eR s v y yv-\u003eT s restAmpIn restAmpOut restSampIn restSampOut",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Causal-Process.html#v:applyFst"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.Causal.Process",
          "name": "applyFst'",
          "package": "synthesizer",
          "signature": "T s (T v y, restAmpIn) restAmpOut (yv, restSampIn) restSampOut -\u003e R s v y yv -\u003e T s restAmpIn restAmpOut restSampIn restSampOut",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Causal-Process.html#applyFst%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional Causal Process",
          "module": "Synthesizer.Dimensional.Causal.Process",
          "name": "applyFst'",
          "normalized": "T a(T b c,d)e(f,g)h-\u003eR a b c f-\u003eT a d e g h",
          "package": "synthesizer",
          "partial": "Fst'",
          "signature": "T s(T v y,restAmpIn)restAmpOut(yv,restSampIn)restSampOut-\u003eR s v y yv-\u003eT s restAmpIn restAmpOut restSampIn restSampOut",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Causal-Process.html#v:applyFst'"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.Causal.Process",
          "name": "applyGeneric",
          "package": "synthesizer",
          "signature": "T s amp0 amp1 yv0 yv1 -\u003e T s signal0 yv0 -\u003e T s signal1 yv1",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Causal-Process.html#applyGeneric",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional Causal Process",
          "module": "Synthesizer.Dimensional.Causal.Process",
          "name": "applyGeneric",
          "normalized": "T a b b c c-\u003eT a d c-\u003eT a d c",
          "package": "synthesizer",
          "partial": "Generic",
          "signature": "T s amp amp yv yv-\u003eT s signal yv-\u003eT s signal yv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Causal-Process.html#v:applyGeneric"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.Causal.Process",
          "name": "compose",
          "package": "synthesizer",
          "signature": "T s amp0 amp1 yv0 yv1 -\u003e T s amp1 amp2 yv1 yv2 -\u003e T s amp0 amp2 yv0 yv2",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Causal-Process.html#compose",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional Causal Process",
          "module": "Synthesizer.Dimensional.Causal.Process",
          "name": "compose",
          "normalized": "T a b b c c-\u003eT a b b c c-\u003eT a b b c c",
          "package": "synthesizer",
          "signature": "T s amp amp yv yv-\u003eT s amp amp yv yv-\u003eT s amp amp yv yv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Causal-Process.html#v:compose"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.Causal.Process",
          "name": "fanout",
          "package": "synthesizer",
          "signature": "T s amp amp0 yv yv0 -\u003e T s amp amp1 yv yv1 -\u003e T s amp (amp0, amp1) yv (yv0, yv1)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Causal-Process.html#fanout",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional Causal Process",
          "module": "Synthesizer.Dimensional.Causal.Process",
          "name": "fanout",
          "normalized": "T a b b c c-\u003eT a b b c c-\u003eT a b(b,b)c(c,c)",
          "package": "synthesizer",
          "signature": "T s amp amp yv yv-\u003eT s amp amp yv yv-\u003eT s amp(amp,amp)yv(yv,yv)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Causal-Process.html#v:fanout"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.Causal.Process",
          "name": "feedFlatFst",
          "package": "synthesizer",
          "signature": "T s sig yv -\u003e T s restAmp (Flat, restAmp) restSamp (yv, restSamp)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Causal-Process.html#feedFlatFst",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional Causal Process",
          "module": "Synthesizer.Dimensional.Causal.Process",
          "name": "feedFlatFst",
          "normalized": "T a b c-\u003eT a d(Flat,d)e(c,e)",
          "package": "synthesizer",
          "partial": "Flat Fst",
          "signature": "T s sig yv-\u003eT s restAmp(Flat,restAmp)restSamp(yv,restSamp)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Causal-Process.html#v:feedFlatFst"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.Causal.Process",
          "name": "feedFst",
          "package": "synthesizer",
          "signature": "R s v y yv -\u003e T s restAmp (T v y, restAmp) restSamp (yv, restSamp)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Causal-Process.html#feedFst",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional Causal Process",
          "module": "Synthesizer.Dimensional.Causal.Process",
          "name": "feedFst",
          "normalized": "R a b c d-\u003eT a e(T b c,e)f(d,f)",
          "package": "synthesizer",
          "partial": "Fst",
          "signature": "R s v y yv-\u003eT s restAmp(T v y,restAmp)restSamp(yv,restSamp)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Causal-Process.html#v:feedFst"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.Causal.Process",
          "name": "first",
          "package": "synthesizer",
          "signature": "T s amp0 amp1 yv0 yv1 -\u003e T s (amp0, amp) (amp1, amp) (yv0, yv) (yv1, yv)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Causal-Process.html#first",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional Causal Process",
          "module": "Synthesizer.Dimensional.Causal.Process",
          "name": "first",
          "normalized": "T a b b c c-\u003eT a(b,b)(b,b)(c,c)(c,c)",
          "package": "synthesizer",
          "signature": "T s amp amp yv yv-\u003eT s(amp,amp)(amp,amp)(yv,yv)(yv,yv)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Causal-Process.html#v:first"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLift a low-level homogeneous process to a dimensional one.\n\u003c/p\u003e\u003cp\u003eNote that the \u003ctt\u003eamp\u003c/tt\u003e type variable is unrestricted.\nThis way we show, that the amplitude is not touched,\nwhich also means that the underlying low-level process must be homogeneous.\n\u003c/p\u003e",
          "module": "Synthesizer.Dimensional.Causal.Process",
          "name": "homogeneous",
          "package": "synthesizer",
          "signature": "T yv0 yv1 -\u003e T s amp amp yv0 yv1",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Causal-Process.html#homogeneous",
          "type": "function"
        },
        "index": {
          "description": "Lift low-level homogeneous process to dimensional one Note that the amp type variable is unrestricted This way we show that the amplitude is not touched which also means that the underlying low-level process must be homogeneous",
          "hierarchy": "Synthesizer Dimensional Causal Process",
          "module": "Synthesizer.Dimensional.Causal.Process",
          "name": "homogeneous",
          "normalized": "T a a-\u003eT b c c a a",
          "package": "synthesizer",
          "signature": "T yv yv-\u003eT s amp amp yv yv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Causal-Process.html#v:homogeneous"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.Causal.Process",
          "name": "id",
          "package": "synthesizer",
          "signature": "T s amp amp yv yv",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Causal-Process.html#id",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional Causal Process",
          "module": "Synthesizer.Dimensional.Causal.Process",
          "name": "id",
          "package": "synthesizer",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Causal-Process.html#v:id"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.Causal.Process",
          "name": "loop",
          "package": "synthesizer",
          "signature": "T v y -\u003e T s (restAmpIn, T v y) (restAmpOut, T v y) (restSampIn, yv) (restSampOut, yv) -\u003e T s restAmpIn restAmpOut restSampIn restSampOut",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Causal-Process.html#loop",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional Causal Process",
          "module": "Synthesizer.Dimensional.Causal.Process",
          "name": "loop",
          "normalized": "T a b-\u003eT c(d,T a b)(e,T a b)(f,g)(h,g)-\u003eT c d e f h",
          "package": "synthesizer",
          "signature": "T v y-\u003eT s(restAmpIn,T v y)(restAmpOut,T v y)(restSampIn,yv)(restSampOut,yv)-\u003eT s restAmpIn restAmpOut restSampIn restSampOut",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Causal-Process.html#v:loop"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.Causal.Process",
          "name": "loop2",
          "package": "synthesizer",
          "signature": "(T v0 y0, T v1 y1) -\u003e T s (restAmpIn, (T v0 y0, T v1 y1)) (restAmpOut, (T v0 y0, T v1 y1)) (restSampIn, (yv0, yv1)) (restSampOut, (yv0, yv1)) -\u003e T s restAmpIn restAmpOut restSampIn restSampOut",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Causal-Process.html#loop2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional Causal Process",
          "module": "Synthesizer.Dimensional.Causal.Process",
          "name": "loop2",
          "normalized": "(T a b,T a b)-\u003eT c(d,(T a b,T a b))(e,(T a b,T a b))(f,(g,g))(h,(g,g))-\u003eT c d e f h",
          "package": "synthesizer",
          "signature": "(T v y,T v y)-\u003eT s(restAmpIn,(T v y,T v y))(restAmpOut,(T v y,T v y))(restSampIn,(yv,yv))(restSampOut,(yv,yv))-\u003eT s restAmpIn restAmpOut restSampIn restSampOut",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Causal-Process.html#v:loop2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.Causal.Process",
          "name": "loop2'",
          "package": "synthesizer",
          "signature": "(T v0 y0, T v1 y1) -\u003e T s (restAmpIn, (T v0 y0, T v1 y1)) (restAmpOut, (T v0 y0, T v1 y1)) (restSampIn, (yv0, yv1)) (restSampOut, (yv0, yv1)) -\u003e T s restAmpIn restAmpOut restSampIn restSampOut",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Causal-Process.html#loop2%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional Causal Process",
          "module": "Synthesizer.Dimensional.Causal.Process",
          "name": "loop2'",
          "normalized": "(T a b,T a b)-\u003eT c(d,(T a b,T a b))(e,(T a b,T a b))(f,(g,g))(h,(g,g))-\u003eT c d e f h",
          "package": "synthesizer",
          "signature": "(T v y,T v y)-\u003eT s(restAmpIn,(T v y,T v y))(restAmpOut,(T v y,T v y))(restSampIn,(yv,yv))(restSampOut,(yv,yv))-\u003eT s restAmpIn restAmpOut restSampIn restSampOut",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Causal-Process.html#v:loop2'"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.Causal.Process",
          "name": "map",
          "package": "synthesizer",
          "signature": "T amp0 amp1 yv0 yv1 -\u003e T s amp0 amp1 yv0 yv1",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Causal-Process.html#map",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional Causal Process",
          "module": "Synthesizer.Dimensional.Causal.Process",
          "name": "map",
          "normalized": "T a a b b-\u003eT c a a b b",
          "package": "synthesizer",
          "signature": "T amp amp yv yv-\u003eT s amp amp yv yv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Causal-Process.html#v:map"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "We restrict the amplitude types to those of class Amplitude.\nOtherwise \u003ctt\u003e\u003ca\u003emapAmplitude\u003c/a\u003e\u003c/tt\u003e could be abused\nfor bringing amplitudes and respective sample values out of sync.\nFor mapping amplitudes that are nested in some pairs,\nuse it in combination with \u003ctt\u003e\u003ca\u003efirst\u003c/a\u003e\u003c/tt\u003e and \u003ctt\u003e\u003ca\u003esecond\u003c/a\u003e\u003c/tt\u003e.\n",
          "module": "Synthesizer.Dimensional.Causal.Process",
          "name": "mapAmplitude",
          "package": "synthesizer",
          "signature": "(amp0 -\u003e amp1) -\u003e T s amp0 amp1 yv yv",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Causal-Process.html#mapAmplitude",
          "type": "function"
        },
        "index": {
          "description": "We restrict the amplitude types to those of class Amplitude Otherwise mapAmplitude could be abused for bringing amplitudes and respective sample values out of sync For mapping amplitudes that are nested in some pairs use it in combination with first and second",
          "hierarchy": "Synthesizer Dimensional Causal Process",
          "module": "Synthesizer.Dimensional.Causal.Process",
          "name": "mapAmplitude",
          "normalized": "(a-\u003ea)-\u003eT b a a c c",
          "package": "synthesizer",
          "partial": "Amplitude",
          "signature": "(amp-\u003eamp)-\u003eT s amp amp yv yv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Causal-Process.html#v:mapAmplitude"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.Causal.Process",
          "name": "mapAmplitudeSameType",
          "package": "synthesizer",
          "signature": "(amp -\u003e amp) -\u003e T s amp amp yv yv",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Causal-Process.html#mapAmplitudeSameType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional Causal Process",
          "module": "Synthesizer.Dimensional.Causal.Process",
          "name": "mapAmplitudeSameType",
          "normalized": "(a-\u003ea)-\u003eT b a a c c",
          "package": "synthesizer",
          "partial": "Amplitude Same Type",
          "signature": "(amp-\u003eamp)-\u003eT s amp amp yv yv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Causal-Process.html#v:mapAmplitudeSameType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.Causal.Process",
          "name": "second",
          "package": "synthesizer",
          "signature": "T s amp0 amp1 yv0 yv1 -\u003e T s (amp, amp0) (amp, amp1) (yv, yv0) (yv, yv1)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Causal-Process.html#second",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional Causal Process",
          "module": "Synthesizer.Dimensional.Causal.Process",
          "name": "second",
          "normalized": "T a b b c c-\u003eT a(b,b)(b,b)(c,c)(c,c)",
          "package": "synthesizer",
          "signature": "T s amp amp yv yv-\u003eT s(amp,amp)(amp,amp)(yv,yv)(yv,yv)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Causal-Process.html#v:second"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.Causal.Process",
          "name": "split",
          "package": "synthesizer",
          "signature": "T s amp0 amp1 yv0 yv1 -\u003e T s amp2 amp3 yv2 yv3 -\u003e T s (amp0, amp2) (amp1, amp3) (yv0, yv2) (yv1, yv3)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Causal-Process.html#split",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional Causal Process",
          "module": "Synthesizer.Dimensional.Causal.Process",
          "name": "split",
          "normalized": "T a b b c c-\u003eT a b b c c-\u003eT a(b,b)(b,b)(c,c)(c,c)",
          "package": "synthesizer",
          "signature": "T s amp amp yv yv-\u003eT s amp amp yv yv-\u003eT s(amp,amp)(amp,amp)(yv,yv)(yv,yv)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Causal-Process.html#v:split"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.ControlledProcess",
          "name": "T",
          "package": "synthesizer",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-ControlledProcess.html#T",
          "type": "data"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional ControlledProcess",
          "module": "Synthesizer.Dimensional.ControlledProcess",
          "name": "T",
          "package": "synthesizer",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-ControlledProcess.html#t:T"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.ControlledProcess",
          "name": "runAsynchronous",
          "package": "synthesizer",
          "signature": "T t ic -\u003e T s u t (T s ec ic a) -\u003e T r u t -\u003e ec -\u003e T s u t a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-ControlledProcess.html#runAsynchronous",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional ControlledProcess",
          "module": "Synthesizer.Dimensional.ControlledProcess",
          "name": "runAsynchronous",
          "normalized": "T a b-\u003eT c d a(T c e b f)-\u003eT g d a-\u003ee-\u003eT c d a f",
          "package": "synthesizer",
          "partial": "Asynchronous",
          "signature": "T t ic-\u003eT s u t(T s ec ic a)-\u003eT r u t-\u003eec-\u003eT s u t a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-ControlledProcess.html#v:runAsynchronous"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.ControlledProcess",
          "name": "runAsynchronous1",
          "package": "synthesizer",
          "signature": "T t ic -\u003e T s u t (T s (T r sig0 ec0) ic a) -\u003e T u t sig0 ec0 -\u003e T s u t a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-ControlledProcess.html#runAsynchronous1",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional ControlledProcess",
          "module": "Synthesizer.Dimensional.ControlledProcess",
          "name": "runAsynchronous1",
          "normalized": "T a b-\u003eT c d a(T c(T e f g)b h)-\u003eT d a f g-\u003eT c d a h",
          "package": "synthesizer",
          "partial": "Asynchronous",
          "signature": "T t ic-\u003eT s u t(T s(T r sig ec)ic a)-\u003eT u t sig ec-\u003eT s u t a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-ControlledProcess.html#v:runAsynchronous1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.ControlledProcess",
          "name": "runAsynchronous2",
          "package": "synthesizer",
          "signature": "T t ic -\u003e T s u t (T s (T r sig0 ec0, T r sig1 ec1) ic a) -\u003e T u t sig0 ec0 -\u003e T u t sig1 ec1 -\u003e T s u t a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-ControlledProcess.html#runAsynchronous2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional ControlledProcess",
          "module": "Synthesizer.Dimensional.ControlledProcess",
          "name": "runAsynchronous2",
          "normalized": "T a b-\u003eT c d a(T c(T e f g,T e f g)b h)-\u003eT d a f g-\u003eT d a f g-\u003eT c d a h",
          "package": "synthesizer",
          "partial": "Asynchronous",
          "signature": "T t ic-\u003eT s u t(T s(T r sig ec,T r sig ec)ic a)-\u003eT u t sig ec-\u003eT u t sig ec-\u003eT s u t a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-ControlledProcess.html#v:runAsynchronous2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.ControlledProcess",
          "name": "runAsynchronous3",
          "package": "synthesizer",
          "signature": "T t ic -\u003e T s u t (T s (T r sig0 ec0, T r sig1 ec1, T r sig2 ec2) ic a) -\u003e T u t sig0 ec0 -\u003e T u t sig1 ec1 -\u003e T u t sig2 ec2 -\u003e T s u t a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-ControlledProcess.html#runAsynchronous3",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional ControlledProcess",
          "module": "Synthesizer.Dimensional.ControlledProcess",
          "name": "runAsynchronous3",
          "normalized": "T a b-\u003eT c d a(T c(T e f g,T e f g,T e f g)b h)-\u003eT d a f g-\u003eT d a f g-\u003eT d a f g-\u003eT c d a h",
          "package": "synthesizer",
          "partial": "Asynchronous",
          "signature": "T t ic-\u003eT s u t(T s(T r sig ec,T r sig ec,T r sig ec)ic a)-\u003eT u t sig ec-\u003eT u t sig ec-\u003eT u t sig ec-\u003eT s u t a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-ControlledProcess.html#v:runAsynchronous3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.ControlledProcess",
          "name": "runSynchronous",
          "package": "synthesizer",
          "signature": "T s u t (T s ec ic a) -\u003e T s u t (ec -\u003e a)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-ControlledProcess.html#runSynchronous",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional ControlledProcess",
          "module": "Synthesizer.Dimensional.ControlledProcess",
          "name": "runSynchronous",
          "normalized": "T a b c(T a d e f)-\u003eT a b c(d-\u003ef)",
          "package": "synthesizer",
          "partial": "Synchronous",
          "signature": "T s u t(T s ec ic a)-\u003eT s u t(ec-\u003ea)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-ControlledProcess.html#v:runSynchronous"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.ControlledProcess",
          "name": "runSynchronous1",
          "package": "synthesizer",
          "signature": "T s u t (T s (T s sig0 ec0) ic a) -\u003e T s u t (T s sig0 ec0 -\u003e a)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-ControlledProcess.html#runSynchronous1",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional ControlledProcess",
          "module": "Synthesizer.Dimensional.ControlledProcess",
          "name": "runSynchronous1",
          "normalized": "T a b c(T a(T a d e)f g)-\u003eT a b c(T a d e-\u003eg)",
          "package": "synthesizer",
          "partial": "Synchronous",
          "signature": "T s u t(T s(T s sig ec)ic a)-\u003eT s u t(T s sig ec-\u003ea)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-ControlledProcess.html#v:runSynchronous1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.ControlledProcess",
          "name": "runSynchronous2",
          "package": "synthesizer",
          "signature": "T s u t (T s (T s sig0 ec0, T s sig1 ec1) ic a) -\u003e T s u t (T s sig0 ec0 -\u003e T s sig1 ec1 -\u003e a)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-ControlledProcess.html#runSynchronous2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional ControlledProcess",
          "module": "Synthesizer.Dimensional.ControlledProcess",
          "name": "runSynchronous2",
          "normalized": "T a b c(T a(T a d e,T a d e)f g)-\u003eT a b c(T a d e-\u003eT a d e-\u003eg)",
          "package": "synthesizer",
          "partial": "Synchronous",
          "signature": "T s u t(T s(T s sig ec,T s sig ec)ic a)-\u003eT s u t(T s sig ec-\u003eT s sig ec-\u003ea)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-ControlledProcess.html#v:runSynchronous2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.ControlledProcess",
          "name": "runSynchronous3",
          "package": "synthesizer",
          "signature": "T s u t (T s (T s sig0 ec0, T s sig1 ec1, T s sig2 ec2) ic a) -\u003e T s u t (T s sig0 ec0 -\u003e T s sig1 ec1 -\u003e T s sig2 ec2 -\u003e a)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-ControlledProcess.html#runSynchronous3",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional ControlledProcess",
          "module": "Synthesizer.Dimensional.ControlledProcess",
          "name": "runSynchronous3",
          "normalized": "T a b c(T a(T a d e,T a d e,T a d e)f g)-\u003eT a b c(T a d e-\u003eT a d e-\u003eT a d e-\u003eg)",
          "package": "synthesizer",
          "partial": "Synchronous",
          "signature": "T s u t(T s(T s sig ec,T s sig ec,T s sig ec)ic a)-\u003eT s u t(T s sig ec-\u003eT s sig ec-\u003eT s sig ec-\u003ea)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-ControlledProcess.html#v:runSynchronous3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.Cyclic.Signal",
          "name": "R",
          "package": "synthesizer",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Cyclic-Signal.html#R",
          "type": "type"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional Cyclic Signal",
          "module": "Synthesizer.Dimensional.Cyclic.Signal",
          "name": "R",
          "package": "synthesizer",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Cyclic-Signal.html#t:R"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.Cyclic.Signal",
          "name": "T",
          "package": "synthesizer",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Cyclic-Signal.html#T",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional Cyclic Signal",
          "module": "Synthesizer.Dimensional.Cyclic.Signal",
          "name": "T",
          "package": "synthesizer",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Cyclic-Signal.html#t:T"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.Cyclic.Signal",
          "name": "fromPeriod",
          "package": "synthesizer",
          "signature": "T yv -\u003e R s yv",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Cyclic-Signal.html#fromPeriod",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional Cyclic Signal",
          "module": "Synthesizer.Dimensional.Cyclic.Signal",
          "name": "fromPeriod",
          "normalized": "T a-\u003eR b a",
          "package": "synthesizer",
          "partial": "Period",
          "signature": "T yv-\u003eR s yv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Cyclic-Signal.html#v:fromPeriod"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.Cyclic.Signal",
          "name": "fromPeriodList",
          "package": "synthesizer",
          "signature": "[yv] -\u003e R s yv",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Cyclic-Signal.html#fromPeriodList",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional Cyclic Signal",
          "module": "Synthesizer.Dimensional.Cyclic.Signal",
          "name": "fromPeriodList",
          "normalized": "[a]-\u003eR b a",
          "package": "synthesizer",
          "partial": "Period List",
          "signature": "[yv]-\u003eR s yv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Cyclic-Signal.html#v:fromPeriodList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Periodization of a straight signal.\n",
          "module": "Synthesizer.Dimensional.Cyclic.Signal",
          "name": "fromSignal",
          "package": "synthesizer",
          "signature": "Int -\u003e R s yv -\u003e R s yv",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Cyclic-Signal.html#fromSignal",
          "type": "function"
        },
        "index": {
          "description": "Periodization of straight signal",
          "hierarchy": "Synthesizer Dimensional Cyclic Signal",
          "module": "Synthesizer.Dimensional.Cyclic.Signal",
          "name": "fromSignal",
          "normalized": "Int-\u003eR a b-\u003eR a b",
          "package": "synthesizer",
          "partial": "Signal",
          "signature": "Int-\u003eR s yv-\u003eR s yv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Cyclic-Signal.html#v:fromSignal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.Cyclic.Signal",
          "name": "toPeriod",
          "package": "synthesizer",
          "signature": "R s yv -\u003e T yv",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Cyclic-Signal.html#toPeriod",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional Cyclic Signal",
          "module": "Synthesizer.Dimensional.Cyclic.Signal",
          "name": "toPeriod",
          "normalized": "R a b-\u003eT b",
          "package": "synthesizer",
          "partial": "Period",
          "signature": "R s yv-\u003eT yv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Cyclic-Signal.html#v:toPeriod"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Convert a cyclic signal to a straight signal containing a loop.\n",
          "module": "Synthesizer.Dimensional.Cyclic.Signal",
          "name": "toSignal",
          "package": "synthesizer",
          "signature": "R s yv -\u003e R s yv",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Cyclic-Signal.html#toSignal",
          "type": "function"
        },
        "index": {
          "description": "Convert cyclic signal to straight signal containing loop",
          "hierarchy": "Synthesizer Dimensional Cyclic Signal",
          "module": "Synthesizer.Dimensional.Cyclic.Signal",
          "name": "toSignal",
          "normalized": "R a b-\u003eR a b",
          "package": "synthesizer",
          "partial": "Signal",
          "signature": "R s yv-\u003eR s yv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Cyclic-Signal.html#v:toSignal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.Map",
          "name": "T",
          "package": "synthesizer",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Map.html#T",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional Map",
          "module": "Synthesizer.Dimensional.Map",
          "name": "T",
          "package": "synthesizer",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Map.html#t:T"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.Map",
          "name": "balanceLeft",
          "package": "synthesizer",
          "signature": "T (amp0, (amp1, amp2)) ((amp0, amp1), amp2) (y0, (y1, y2)) ((y0, y1), y2)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Map.html#balanceLeft",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional Map",
          "module": "Synthesizer.Dimensional.Map",
          "name": "balanceLeft",
          "normalized": "T(a,(a,a))((a,a),a)(b,(b,b))((b,b),b)",
          "package": "synthesizer",
          "partial": "Left",
          "signature": "T(amp,(amp,amp))((amp,amp),amp)(y,(y,y))((y,y),y)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Map.html#v:balanceLeft"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.Map",
          "name": "balanceRight",
          "package": "synthesizer",
          "signature": "T ((amp0, amp1), amp2) (amp0, (amp1, amp2)) ((y0, y1), y2) (y0, (y1, y2))",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Map.html#balanceRight",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional Map",
          "module": "Synthesizer.Dimensional.Map",
          "name": "balanceRight",
          "normalized": "T((a,a),a)(a,(a,a))((b,b),b)(b,(b,b))",
          "package": "synthesizer",
          "partial": "Right",
          "signature": "T((amp,amp),amp)(amp,(amp,amp))((y,y),y)(y,(y,y))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Map.html#v:balanceRight"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.Map",
          "name": "double",
          "package": "synthesizer",
          "signature": "T amp (amp, amp) y (y, y)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Map.html#double",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional Map",
          "module": "Synthesizer.Dimensional.Map",
          "name": "double",
          "normalized": "T a(a,a)b(b,b)",
          "package": "synthesizer",
          "signature": "T amp(amp,amp)y(y,y)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Map.html#v:double"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.Map",
          "name": "fst",
          "package": "synthesizer",
          "signature": "T (amp0, amp1) amp0 (y0, y1) y0",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Map.html#fst",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional Map",
          "module": "Synthesizer.Dimensional.Map",
          "name": "fst",
          "normalized": "T(a,a)a(b,b)b",
          "package": "synthesizer",
          "signature": "T(amp,amp)amp(y,y)y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Map.html#v:fst"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.Map",
          "name": "independent",
          "package": "synthesizer",
          "signature": "(amp0 -\u003e amp1) -\u003e (yv0 -\u003e yv1) -\u003e T amp0 amp1 yv0 yv1",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Map.html#independent",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional Map",
          "module": "Synthesizer.Dimensional.Map",
          "name": "independent",
          "normalized": "(a-\u003ea)-\u003e(b-\u003eb)-\u003eT a a b b",
          "package": "synthesizer",
          "signature": "(amp-\u003eamp)-\u003e(yv-\u003eyv)-\u003eT amp amp yv yv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Map.html#v:independent"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.Map",
          "name": "packTriple",
          "package": "synthesizer",
          "signature": "T (amp0, (amp1, amp2)) (amp0, amp1, amp2) (y0, (y1, y2)) (y0, y1, y2)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Map.html#packTriple",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional Map",
          "module": "Synthesizer.Dimensional.Map",
          "name": "packTriple",
          "normalized": "T(a,(a,a))(a,a,a)(b,(b,b))(b,b,b)",
          "package": "synthesizer",
          "partial": "Triple",
          "signature": "T(amp,(amp,amp))(amp,amp,amp)(y,(y,y))(y,y,y)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Map.html#v:packTriple"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.Map",
          "name": "snd",
          "package": "synthesizer",
          "signature": "T (amp0, amp1) amp1 (y0, y1) y1",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Map.html#snd",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional Map",
          "module": "Synthesizer.Dimensional.Map",
          "name": "snd",
          "normalized": "T(a,a)a(b,b)b",
          "package": "synthesizer",
          "signature": "T(amp,amp)amp(y,y)y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Map.html#v:snd"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.Map",
          "name": "swap",
          "package": "synthesizer",
          "signature": "T (amp0, amp1) (amp1, amp0) (y0, y1) (y1, y0)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Map.html#swap",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional Map",
          "module": "Synthesizer.Dimensional.Map",
          "name": "swap",
          "normalized": "T(a,a)(a,a)(b,b)(b,b)",
          "package": "synthesizer",
          "signature": "T(amp,amp)(amp,amp)(y,y)(y,y)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Map.html#v:swap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.Map",
          "name": "unpackTriple",
          "package": "synthesizer",
          "signature": "T (amp0, amp1, amp2) (amp0, (amp1, amp2)) (y0, y1, y2) (y0, (y1, y2))",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Map.html#unpackTriple",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional Map",
          "module": "Synthesizer.Dimensional.Map",
          "name": "unpackTriple",
          "normalized": "T(a,a,a)(a,(a,a))(b,b,b)(b,(b,b))",
          "package": "synthesizer",
          "partial": "Triple",
          "signature": "T(amp,amp,amp)(amp,(amp,amp))(y,y,y)(y,(y,y))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Map.html#v:unpackTriple"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWe use a hierarchy of signal wrappers\nin order to capture all features of a signal.\n\u003c/p\u003e\u003cp\u003eAt the bottom there is the signal storage as described in \u003ca\u003eSynthesizer.Storage\u003c/a\u003e.\nWith the element type of the storage\nyou decide whether you want mono or stereo signal\n(\u003ca\u003eSynthesizer.Frame.Stereo\u003c/a\u003e),\nand you decide on the precision, fixed point vs. floating point and so on.\nHowever, due to Haskell's flexible type system\nyou don't need to decide finally on a type for your signal processing routines.\nE.g. mono and stereo signals can be handled together\nusing the \u003ca\u003eAlgebra.Module\u003c/a\u003e class from the numeric-prelude package.\n(An algebraic module is a vector space\nwithout requiring availability of a division of scalars).\n\u003c/p\u003e\u003cp\u003eYou can use the storage types directly\nusing the functions from \u003ca\u003eSynthesizer.Plain.Signal\u003c/a\u003e\nand \u003ca\u003eSynthesizer.Generic.Signal\u003c/a\u003e and its cousins.\nThis is in a way simple,\nsince you do not have bother with units and complicated types,\nbut you miss type safety and re-usability.\nE.g. you have to give frequencies in ratios of the sampling rate.\nIf you later decide to change the sampling rate, you must rewrite all time and frequency values.\nIf you anticipate changes in sampling rate,\nyou may write those values as ratios of a global sampling rate\nright from the start.\nBut you might want different sample rates\nfor some parts of the computation,\nor you may want sample rates that have no time dimension,\nbut say, length dimension.\nThe advanced system described below handles all these cases for you.\n\u003c/p\u003e\u003cp\u003eOk, we said that at the bottom, there is the signal storage.\nThe next level is the decision\nwhether the raw data is interpreted as straight or as cyclic signal.\nMost of the signals you are using,\nwill be \u003ca\u003eSynthesizer.Dimensional.Straight.Signal\u003c/a\u003e.\nCurrently, \u003ca\u003eSynthesizer.Dimensional.Cyclic.Signal\u003c/a\u003e\nis only needed for Fourier transform and as input to oscillators.\nTo get a straight signal out of storablevector data,\nyou will write\n\u003c/p\u003e\u003cpre\u003e import qualified Synthesizer.Storable.Signal as Store\n import qualified Synthesizer.Dimensional.Straight.Signal as Straight\n\n type MySignal y = Straight.T Store.T y\n\u003c/pre\u003e\u003cp\u003eNote that \u003ctt\u003eStraight.T\u003c/tt\u003e has the type constructor \u003ctt\u003eStore.T\u003c/tt\u003e as first argument,\nnot the entire storage type \u003ctt\u003eStore.T\u003c/tt\u003e.\nThis way compositions of such wrappers are automatically Functors.\nHowever, I'm not completely certain, that this is good,\nsince \u003ctt\u003e\u003ca\u003efmap\u003c/a\u003e\u003c/tt\u003e allows to do unintended things\n(e.g. switch from a numeric to a non-numeric element type).\n\u003c/p\u003e\u003cp\u003eThe next level copes with amplitudes and their units.\nAn amplitude and its unit are provided per signal, not per sample.\nWe think that it is the most natural way, and it is also an efficient one.\nSince the signal might be a stereo signal,\nthe numeric type of the amplitude can differ from the storage element type.\nUsually, the first and the latter one are related by an \u003ca\u003eAlgebra.Module\u003c/a\u003e constraint.\nYou get a signal with amplitude by\n\u003c/p\u003e\u003cpre\u003e import qualified Synthesizer.Dimensional.Amplitude.Signal as Amp\n\n type MySignal v y yv = Amp.T v y (Straight.T Store.T) yv\n\u003c/pre\u003e\u003cp\u003ewhere \u003ctt\u003ev\u003c/tt\u003e is the dimension of the amplitude of type \u003ctt\u003ey\u003c/tt\u003e.\nThe storage element type, a vector with respect to \u003ctt\u003ey\u003c/tt\u003e, is of type \u003ctt\u003eyv\u003c/tt\u003e.\n\u003c/p\u003e\u003cp\u003eIn some cases, an amplitude with a physical dimension just makes no sense.\nImagine a control signal consisting of \u003ctt\u003eBool\u003c/tt\u003e elements like a gate signal,\nor a signal containing elements of an enumeration\nfor switching between signals depending on the time.\n\u003c/p\u003e\u003cp\u003eFor some control signals the amplitude unit is one.\nWe call these signals flat.\nIn this case you can choose\nwhether you use an explicit amplitude with \u003ctt\u003eScalar\u003c/tt\u003e dimension\nor you use no amplitude wrapper at all.\nMost signal processors handle both kinds of flat signals\nby the corresponding type class in \u003ca\u003eSynthesizer.Dimensional.Abstraction.Flat\u003c/a\u003e.\n\u003c/p\u003e\u003cp\u003eThere is a special signal type for Dirac impulses,\nthat does not fit to that scheme,\nthat is, it cannot be equipped with an amplitude.\nSee \u003ca\u003eSynthesizer.Dimensional.Rate.Dirac\u003c/a\u003e.\n\u003c/p\u003e\u003cp\u003eLast but not least we want to look on how to handle sample rates.\nOur goal is to write signal processes\nthat do not depend on the sample rate.\nE.g. we want to have an exponential decay with a half-life of one second.\nA second means 44100 samples at 44100 Hz sample rate,\nor 22050 samples at 22050 Hz sample rate.\nWe want to abstract from the particular number of samples\nin order to be able generate a signal at any sample rate (i.e. quality) we like.\nThe ideal representation of a signal is be a real function,\nand we try to come close to it.\n(Not quite, because a Dirac impulse is not a real function,\nbut we need it as identity element of the convolution.)\n\u003c/p\u003e\u003cp\u003eTo this end we can equip a discrete signal with a sample rate,\nsee \u003ca\u003eSynthesizer.Dimensional.RateWrapper\u003c/a\u003e.\nThis alone however, leads to several problems:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e When combining some signals,\n  it is not clear how to cope with different sample rates.\n  Say you want to mix signals \u003ctt\u003ea\u003c/tt\u003e and \u003ctt\u003eb\u003c/tt\u003e.\n  Shall \u003ctt\u003emix a b\u003c/tt\u003e have the sample rate of \u003ctt\u003ea\u003c/tt\u003e or that of \u003ctt\u003eb\u003c/tt\u003e or a new one?\n  How shall the signals convert to a new rate?\n  Since an automatically chosen method\n  can always be inappropriate (either too slow or too low quality),\n  the caller have to explicitly give tell it to mix.\n  This is not only inconvenient for the caller,\n  but also requires a lot of boilerplate code in functions like mix.\n\u003c/li\u003e\u003cli\u003e An alternative solution to the problem above is,\n  to check before mixing whether sample rates are equal,\n  and abort with an error if they differ.\n  This way no decisions on the sample rate\n  and subsequent conversions are necessary.\n  This still needs boilerplate in signal processors.\n  It also does not tell the user by types,\n  whether a processor can handle differing sample rates.\n  Generally, dynamic checks are both inefficient\n  and an inferior way to indicate programming errors,\n  since they are only catched at run-time, if at all.\n\u003c/li\u003e\u003cli\u003e Both solutions suffer from the inconvenience\n  to specify the sample rate in all leaves,\n  e.g. \u003ctt\u003emix (oscillator 44100 10) (oscillator 44100 11)\u003c/tt\u003e.\n\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eNaturally, when you want to get a signal with rate 44100 Hz sample rate,\nyou perform all signal processes at this rate.\nEven if want to use oversampling,\nthen you will perform all signal processes at the higher rate\nand downsample only once at the end.\nThus we introduce a way\nto run a set of signal processes in the context of a sample rate.\nIt is still sensible and possible\nto escape from this context or enter it again.\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e You need to be to enter a sample rate context\n  with a signal read from disk,\n  with a sample rate that is not known at compile time.\n  You might also intensionally compute a control signal at a low sample rate\n  and convert it to a sample rate context for filtering.\n  Generally the scheme of functions that allow different sample rates is:\n  Use the sample rate of the output signal as context.\n  Take all signals with independent sample rate\n  as inputs outside the context.\n  The according function is Synthesizer.Dimensional.Rate.Filter.frequencyModulationDecoupled.\n\u003c/li\u003e\u003cli\u003e When you want to play a sound or write it to disk,\n  you must choose a sample rate and fix the computation to that rate.\n  This conversion however means to run the whole computation within one sample rate context,\n  since everything in that context depends on the sample rate.\n  The according function is Synthesizer.Dimensional.RateWrapper.runProcess.\n\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eThe sample rate context is provided by \u003ca\u003eSynthesizer.Dimensional.Process\u003c/a\u003e.\nIt is a Reader monad,\nbut we only need applicative functor methods for signal processing.\nThis context is equipped with the type parameter \u003ctt\u003es\u003c/tt\u003e,\njust as we know it from the Control.Monad.ST.ST monad.\nIt also serves the same purpose:\nWe tag both signals and the sample rate context with the type parameter \u003ctt\u003es\u003c/tt\u003e.\nThe \u003ctt\u003eforall s\u003c/tt\u003e constraint for \u003ctt\u003erunProcess\u003c/tt\u003e ensures,\nthat a signal with such a tag remains in the context.\nYou can only escape the sample rate context\nby rendering the signal and attach the sample rate to the rendered signal.\n\u003c/p\u003e\u003cp\u003eThe sample rate tag type is provided by\n\u003ca\u003eSynthesizer.Dimensional.RatePhantom\u003c/a\u003e.\nHaskell's type system does not allow to restrict the types that it can wrap.\nSo in principle you can abuse it to wrap many things.\nHowever we do not provide such functions\nand this way the wrappable types ar restricted anyway.\n\u003c/p\u003e",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Overview.html",
          "type": "unknown"
        },
        "index": {
          "description": "We use hierarchy of signal wrappers in order to capture all features of signal At the bottom there is the signal storage as described in Synthesizer.Storage With the element type of the storage you decide whether you want mono or stereo signal Synthesizer.Frame.Stereo and you decide on the precision fixed point vs floating point and so on However due to Haskell flexible type system you don need to decide finally on type for your signal processing routines E.g mono and stereo signals can be handled together using the Algebra.Module class from the numeric-prelude package An algebraic module is vector space without requiring availability of division of scalars You can use the storage types directly using the functions from Synthesizer.Plain.Signal and Synthesizer.Generic.Signal and its cousins This is in way simple since you do not have bother with units and complicated types but you miss type safety and re-usability E.g you have to give frequencies in ratios of the sampling rate If you later decide to change the sampling rate you must rewrite all time and frequency values If you anticipate changes in sampling rate you may write those values as ratios of global sampling rate right from the start But you might want different sample rates for some parts of the computation or you may want sample rates that have no time dimension but say length dimension The advanced system described below handles all these cases for you Ok we said that at the bottom there is the signal storage The next level is the decision whether the raw data is interpreted as straight or as cyclic signal Most of the signals you are using will be Synthesizer.Dimensional.Straight.Signal Currently Synthesizer.Dimensional.Cyclic.Signal is only needed for Fourier transform and as input to oscillators To get straight signal out of storablevector data you will write import qualified Synthesizer.Storable.Signal as Store import qualified Synthesizer.Dimensional.Straight.Signal as Straight type MySignal Straight.T Store.T Note that Straight.T has the type constructor Store.T as first argument not the entire storage type Store.T This way compositions of such wrappers are automatically Functors However not completely certain that this is good since fmap allows to do unintended things e.g switch from numeric to non-numeric element type The next level copes with amplitudes and their units An amplitude and its unit are provided per signal not per sample We think that it is the most natural way and it is also an efficient one Since the signal might be stereo signal the numeric type of the amplitude can differ from the storage element type Usually the first and the latter one are related by an Algebra.Module constraint You get signal with amplitude by import qualified Synthesizer.Dimensional.Amplitude.Signal as Amp type MySignal yv Amp.T Straight.T Store.T yv where is the dimension of the amplitude of type The storage element type vector with respect to is of type yv In some cases an amplitude with physical dimension just makes no sense Imagine control signal consisting of Bool elements like gate signal or signal containing elements of an enumeration for switching between signals depending on the time For some control signals the amplitude unit is one We call these signals flat In this case you can choose whether you use an explicit amplitude with Scalar dimension or you use no amplitude wrapper at all Most signal processors handle both kinds of flat signals by the corresponding type class in Synthesizer.Dimensional.Abstraction.Flat There is special signal type for Dirac impulses that does not fit to that scheme that is it cannot be equipped with an amplitude See Synthesizer.Dimensional.Rate.Dirac Last but not least we want to look on how to handle sample rates Our goal is to write signal processes that do not depend on the sample rate E.g we want to have an exponential decay with half-life of one second second means samples at Hz sample rate or samples at Hz sample rate We want to abstract from the particular number of samples in order to be able generate signal at any sample rate i.e quality we like The ideal representation of signal is be real function and we try to come close to it Not quite because Dirac impulse is not real function but we need it as identity element of the convolution To this end we can equip discrete signal with sample rate see Synthesizer.Dimensional.RateWrapper This alone however leads to several problems When combining some signals it is not clear how to cope with different sample rates Say you want to mix signals and Shall mix have the sample rate of or that of or new one How shall the signals convert to new rate Since an automatically chosen method can always be inappropriate either too slow or too low quality the caller have to explicitly give tell it to mix This is not only inconvenient for the caller but also requires lot of boilerplate code in functions like mix An alternative solution to the problem above is to check before mixing whether sample rates are equal and abort with an error if they differ This way no decisions on the sample rate and subsequent conversions are necessary This still needs boilerplate in signal processors It also does not tell the user by types whether processor can handle differing sample rates Generally dynamic checks are both inefficient and an inferior way to indicate programming errors since they are only catched at run-time if at all Both solutions suffer from the inconvenience to specify the sample rate in all leaves e.g mix oscillator oscillator Naturally when you want to get signal with rate Hz sample rate you perform all signal processes at this rate Even if want to use oversampling then you will perform all signal processes at the higher rate and downsample only once at the end Thus we introduce way to run set of signal processes in the context of sample rate It is still sensible and possible to escape from this context or enter it again You need to be to enter sample rate context with signal read from disk with sample rate that is not known at compile time You might also intensionally compute control signal at low sample rate and convert it to sample rate context for filtering Generally the scheme of functions that allow different sample rates is Use the sample rate of the output signal as context Take all signals with independent sample rate as inputs outside the context The according function is Synthesizer.Dimensional.Rate.Filter.frequencyModulationDecoupled When you want to play sound or write it to disk you must choose sample rate and fix the computation to that rate This conversion however means to run the whole computation within one sample rate context since everything in that context depends on the sample rate The according function is Synthesizer.Dimensional.RateWrapper.runProcess The sample rate context is provided by Synthesizer.Dimensional.Process It is Reader monad but we only need applicative functor methods for signal processing This context is equipped with the type parameter just as we know it from the Control.Monad.ST.ST monad It also serves the same purpose We tag both signals and the sample rate context with the type parameter The forall constraint for runProcess ensures that signal with such tag remains in the context You can only escape the sample rate context by rendering the signal and attach the sample rate to the rendered signal The sample rate tag type is provided by Synthesizer.Dimensional.RatePhantom Haskell type system does not allow to restrict the types that it can wrap So in principle you can abuse it to wrap many things However we do not provide such functions and this way the wrappable types ar restricted anyway",
          "type": "unknown"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Overview.html"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.Process",
          "name": "T",
          "package": "synthesizer",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Process.html#T",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional Process",
          "module": "Synthesizer.Dimensional.Process",
          "name": "T",
          "package": "synthesizer",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Process.html#t:T"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.Process",
          "name": "getSampleRate",
          "package": "synthesizer",
          "signature": "T s u t (T (Recip u) t)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Process.html#getSampleRate",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional Process",
          "module": "Synthesizer.Dimensional.Process",
          "name": "getSampleRate",
          "package": "synthesizer",
          "partial": "Sample Rate",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Process.html#v:getSampleRate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.Process",
          "name": "pure",
          "package": "synthesizer",
          "signature": "a -\u003e T s u t a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Process.html#pure",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional Process",
          "module": "Synthesizer.Dimensional.Process",
          "name": "pure",
          "normalized": "a-\u003eT b c d a",
          "package": "synthesizer",
          "signature": "a-\u003eT s u t a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Process.html#v:pure"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Get results from the Process monad.\nYou can obtain only signals (or other values)\nthat do not implicitly depend on the sample rate,\nthat is value without the \u003ctt\u003es\u003c/tt\u003e type parameter.\n",
          "module": "Synthesizer.Dimensional.Process",
          "name": "run",
          "package": "synthesizer",
          "signature": "T (Recip u) t -\u003e (forall s.  T s u t a) -\u003e a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Process.html#run",
          "type": "function"
        },
        "index": {
          "description": "Get results from the Process monad You can obtain only signals or other values that do not implicitly depend on the sample rate that is value without the type parameter",
          "hierarchy": "Synthesizer Dimensional Process",
          "module": "Synthesizer.Dimensional.Process",
          "name": "run",
          "normalized": "T(Recip a)b-\u003e(c d T e a b f)-\u003ef",
          "package": "synthesizer",
          "signature": "T(Recip u)t-\u003e(forall s. T s u t a)-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Process.html#v:run"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.Process",
          "name": "toFrequencyDimension",
          "package": "synthesizer",
          "signature": "t -\u003e T s u t (T (Recip u) t)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Process.html#toFrequencyDimension",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional Process",
          "module": "Synthesizer.Dimensional.Process",
          "name": "toFrequencyDimension",
          "normalized": "a-\u003eT b c a(T(Recip c)a)",
          "package": "synthesizer",
          "partial": "Frequency Dimension",
          "signature": "t-\u003eT s u t(T(Recip u)t)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Process.html#v:toFrequencyDimension"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Synthesizer.Dimensional.Process\",\"Synthesizer.Dimensional.RateAmplitude.Signal\"]",
          "name": "toFrequencyScalar",
          "package": "synthesizer",
          "signature": "T (Recip u) t -\u003e T s u t t",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Process.html#toFrequencyScalar",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Process.html#v:toFrequencyScalar\",\"http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-RateAmplitude-Signal.html#v:toFrequencyScalar\"]"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional Process",
          "module": "Synthesizer.Dimensional.Process",
          "name": "toFrequencyScalar",
          "normalized": "T(Recip a)b-\u003eT c a b b",
          "package": "synthesizer",
          "partial": "Frequency Scalar",
          "signature": "T(Recip u)t-\u003eT s u t t",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Process.html#v:toFrequencyScalar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.Process",
          "name": "toTimeDimension",
          "package": "synthesizer",
          "signature": "t -\u003e T s u t (T u t)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Process.html#toTimeDimension",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional Process",
          "module": "Synthesizer.Dimensional.Process",
          "name": "toTimeDimension",
          "normalized": "a-\u003eT b c a(T c a)",
          "package": "synthesizer",
          "partial": "Time Dimension",
          "signature": "t-\u003eT s u t(T u t)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Process.html#v:toTimeDimension"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Synthesizer.Dimensional.Process\",\"Synthesizer.Dimensional.RateAmplitude.Signal\"]",
          "name": "toTimeScalar",
          "package": "synthesizer",
          "signature": "T u t -\u003e T s u t t",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Process.html#toTimeScalar",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Process.html#v:toTimeScalar\",\"http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-RateAmplitude-Signal.html#v:toTimeScalar\"]"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional Process",
          "module": "Synthesizer.Dimensional.Process",
          "name": "toTimeScalar",
          "normalized": "T a b-\u003eT c a b b",
          "package": "synthesizer",
          "partial": "Time Scalar",
          "signature": "T u t-\u003eT s u t t",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Process.html#v:toTimeScalar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.Process",
          "name": "withParam",
          "package": "synthesizer",
          "signature": "(a -\u003e T s u t b) -\u003e T s u t (a -\u003e b)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Process.html#withParam",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional Process",
          "module": "Synthesizer.Dimensional.Process",
          "name": "withParam",
          "normalized": "(a-\u003eT b c d e)-\u003eT b c d(a-\u003ee)",
          "package": "synthesizer",
          "partial": "Param",
          "signature": "(a-\u003eT s u t b)-\u003eT s u t(a-\u003eb)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Process.html#v:withParam"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.Rate.Analysis",
          "name": "centroid",
          "package": "synthesizer",
          "signature": "T u q S q -\u003e T u q",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Rate-Analysis.html#centroid",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional Rate Analysis",
          "module": "Synthesizer.Dimensional.Rate.Analysis",
          "name": "centroid",
          "normalized": "T a b S b-\u003eT a b",
          "package": "synthesizer",
          "signature": "T u q S q-\u003eT u q",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Rate-Analysis.html#v:centroid"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.Rate.Analysis",
          "name": "centroidProc",
          "package": "synthesizer",
          "signature": "T s u y (R s y -\u003e T u y)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Rate-Analysis.html#centroidProc",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional Rate Analysis",
          "module": "Synthesizer.Dimensional.Rate.Analysis",
          "name": "centroidProc",
          "normalized": "T a b c(R a c-\u003eT b c)",
          "package": "synthesizer",
          "partial": "Proc",
          "signature": "T s u y(R s y-\u003eT u y)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Rate-Analysis.html#v:centroidProc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.Rate.Analysis",
          "name": "length",
          "package": "synthesizer",
          "signature": "T u t S yv -\u003e T u t",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Rate-Analysis.html#length",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional Rate Analysis",
          "module": "Synthesizer.Dimensional.Rate.Analysis",
          "name": "length",
          "normalized": "T a b S c-\u003eT a b",
          "package": "synthesizer",
          "signature": "T u t S yv-\u003eT u t",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Rate-Analysis.html#v:length"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.Rate.Analysis",
          "name": "lengthProc",
          "package": "synthesizer",
          "signature": "T s u y (R s y -\u003e T u y)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Rate-Analysis.html#lengthProc",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional Rate Analysis",
          "module": "Synthesizer.Dimensional.Rate.Analysis",
          "name": "lengthProc",
          "normalized": "T a b c(R a c-\u003eT b c)",
          "package": "synthesizer",
          "partial": "Proc",
          "signature": "T s u y(R s y-\u003eT u y)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Rate-Analysis.html#v:lengthProc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.Rate.Control",
          "name": "constant",
          "package": "synthesizer",
          "signature": "T s u t (R s y)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Rate-Control.html#constant",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional Rate Control",
          "module": "Synthesizer.Dimensional.Rate.Control",
          "name": "constant",
          "package": "synthesizer",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Rate-Control.html#v:constant"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "time where the function reaches 1/e of the initial value \n",
          "module": "Synthesizer.Dimensional.Rate.Control",
          "name": "exponential",
          "package": "synthesizer",
          "signature": "T u q-\u003e T s u q (R s q)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Rate-Control.html#exponential",
          "type": "function"
        },
        "index": {
          "description": "time where the function reaches of the initial value",
          "hierarchy": "Synthesizer Dimensional Rate Control",
          "module": "Synthesizer.Dimensional.Rate.Control",
          "name": "exponential",
          "normalized": "T a b-\u003eT c a b(R c b)",
          "package": "synthesizer",
          "signature": "T u q-\u003eT s u q(R s q)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Rate-Control.html#v:exponential"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "half life, time where the function reaches 1/2 of the initial value \n",
          "module": "Synthesizer.Dimensional.Rate.Control",
          "name": "exponential2",
          "package": "synthesizer",
          "signature": "T u q-\u003e T s u q (R s q)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Rate-Control.html#exponential2",
          "type": "function"
        },
        "index": {
          "description": "half life time where the function reaches of the initial value",
          "hierarchy": "Synthesizer Dimensional Rate Control",
          "module": "Synthesizer.Dimensional.Rate.Control",
          "name": "exponential2",
          "normalized": "T a b-\u003eT c a b(R c b)",
          "package": "synthesizer",
          "signature": "T u q-\u003eT s u q(R s q)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Rate-Control.html#v:exponential2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "distance until curve reaches one \n",
          "module": "Synthesizer.Dimensional.Rate.Control",
          "name": "linear",
          "package": "synthesizer",
          "signature": "T u q-\u003e T s u q (R s q)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Rate-Control.html#linear",
          "type": "function"
        },
        "index": {
          "description": "distance until curve reaches one",
          "hierarchy": "Synthesizer Dimensional Rate Control",
          "module": "Synthesizer.Dimensional.Rate.Control",
          "name": "linear",
          "normalized": "T a b-\u003eT c a b(R c b)",
          "package": "synthesizer",
          "signature": "T u q-\u003eT s u q(R s q)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Rate-Control.html#v:linear"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.Rate.Cut",
          "name": "drop",
          "package": "synthesizer",
          "signature": "T u t -\u003e T s u t (T s sig y -\u003e T s sig y)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Rate-Cut.html#drop",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional Rate Cut",
          "module": "Synthesizer.Dimensional.Rate.Cut",
          "name": "drop",
          "normalized": "T a b-\u003eT c a b(T c d e-\u003eT c d e)",
          "package": "synthesizer",
          "signature": "T u t-\u003eT s u t(T s sig y-\u003eT s sig y)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Rate-Cut.html#v:drop"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.Rate.Cut",
          "name": "take",
          "package": "synthesizer",
          "signature": "T u t -\u003e T s u t (T s sig y -\u003e T s sig y)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Rate-Cut.html#take",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional Rate Cut",
          "module": "Synthesizer.Dimensional.Rate.Cut",
          "name": "take",
          "normalized": "T a b-\u003eT c a b(T c d e-\u003eT c d e)",
          "package": "synthesizer",
          "signature": "T u t-\u003eT s u t(T s sig y-\u003eT s sig y)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Rate-Cut.html#v:take"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.Rate.Dirac",
          "name": "T",
          "package": "synthesizer",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Rate-Dirac.html#T",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional Rate Dirac",
          "module": "Synthesizer.Dimensional.Rate.Dirac",
          "name": "T",
          "package": "synthesizer",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Rate-Dirac.html#t:T"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "This is the most frequently needed transformation\nof a stream of peaks, if not the only one.\nIt converts to a signal of peaks with area 1.\nThis convention is especially useful for smoothing filters\nthat produce frequency progress curves from zero crossings.\n",
          "module": "Synthesizer.Dimensional.Rate.Dirac",
          "name": "toAmplitudeSignal",
          "package": "synthesizer",
          "signature": "T s u q (T s sig -\u003e T s (D (Recip u) q (T sig)) q)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Rate-Dirac.html#toAmplitudeSignal",
          "type": "function"
        },
        "index": {
          "description": "This is the most frequently needed transformation of stream of peaks if not the only one It converts to signal of peaks with area This convention is especially useful for smoothing filters that produce frequency progress curves from zero crossings",
          "hierarchy": "Synthesizer Dimensional Rate Dirac",
          "module": "Synthesizer.Dimensional.Rate.Dirac",
          "name": "toAmplitudeSignal",
          "normalized": "T a b c(T a d-\u003eT a(D(Recip b)c(T d))c)",
          "package": "synthesizer",
          "partial": "Amplitude Signal",
          "signature": "T s u q(T s sig-\u003eT s(D(Recip u)q(T sig))q)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Rate-Dirac.html#v:toAmplitudeSignal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "order, number of filters in the cascade \nthe phase shift to be achieved for the given frequency \n",
          "module": "Synthesizer.Dimensional.Rate.Filter",
          "name": "allpassCascade",
          "package": "synthesizer",
          "signature": "Int-\u003e q-\u003e T s u q (R s (Recip u) q q -\u003e T s sig yv -\u003e T s sig yv)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Rate-Filter.html#allpassCascade",
          "type": "function"
        },
        "index": {
          "description": "order number of filters in the cascade the phase shift to be achieved for the given frequency",
          "hierarchy": "Synthesizer Dimensional Rate Filter",
          "module": "Synthesizer.Dimensional.Rate.Filter",
          "name": "allpassCascade",
          "normalized": "Int-\u003ea-\u003eT b c a(R b(Recip c)a a-\u003eT b d e-\u003eT b d e)",
          "package": "synthesizer",
          "partial": "Cascade",
          "signature": "Int-\u003eq-\u003eT s u q(R s(Recip u)q q-\u003eT s sig yv-\u003eT s sig yv)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Rate-Filter.html#v:allpassCascade"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Synthesizer.Dimensional.Rate.Filter\",\"Synthesizer.Dimensional.RateAmplitude.Filter\"]",
          "name": "bandlimitFromUniversal",
          "package": "synthesizer",
          "signature": "T s sig (Result yv) -\u003e T s sig yv",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Rate-Filter.html#bandlimitFromUniversal",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Rate-Filter.html#v:bandlimitFromUniversal\",\"http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-RateAmplitude-Filter.html#v:bandlimitFromUniversal\"]"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional Rate Filter",
          "module": "Synthesizer.Dimensional.Rate.Filter",
          "name": "bandlimitFromUniversal",
          "normalized": "T a b(Result c)-\u003eT a b c",
          "package": "synthesizer",
          "partial": "From Universal",
          "signature": "T s sig(Result yv)-\u003eT s sig yv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Rate-Filter.html#v:bandlimitFromUniversal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Synthesizer.Dimensional.Rate.Filter\",\"Synthesizer.Dimensional.RateAmplitude.Filter\"]",
          "name": "bandpassFromUniversal",
          "package": "synthesizer",
          "signature": "T s sig (Result yv) -\u003e T s sig yv",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Rate-Filter.html#bandpassFromUniversal",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Rate-Filter.html#v:bandpassFromUniversal\",\"http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-RateAmplitude-Filter.html#v:bandpassFromUniversal\"]"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional Rate Filter",
          "module": "Synthesizer.Dimensional.Rate.Filter",
          "name": "bandpassFromUniversal",
          "normalized": "T a b(Result c)-\u003eT a b c",
          "package": "synthesizer",
          "partial": "From Universal",
          "signature": "T s sig(Result yv)-\u003eT s sig yv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Rate-Filter.html#v:bandpassFromUniversal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Order of the filter, must be even,\n                        the higher the order, the sharper is the separation of frequencies. \n",
          "module": "Synthesizer.Dimensional.Rate.Filter",
          "name": "butterworthHighpass",
          "package": "synthesizer",
          "signature": "Int-\u003e T s u q (T s flat q -\u003e R s (Recip u) q q -\u003e T s sig yv -\u003e T s sig yv)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Rate-Filter.html#butterworthHighpass",
          "type": "function"
        },
        "index": {
          "description": "Order of the filter must be even the higher the order the sharper is the separation of frequencies",
          "hierarchy": "Synthesizer Dimensional Rate Filter",
          "module": "Synthesizer.Dimensional.Rate.Filter",
          "name": "butterworthHighpass",
          "normalized": "Int-\u003eT a b c(T a d c-\u003eR a(Recip b)c c-\u003eT a e f-\u003eT a e f)",
          "package": "synthesizer",
          "partial": "Highpass",
          "signature": "Int-\u003eT s u q(T s flat q-\u003eR s(Recip u)q q-\u003eT s sig yv-\u003eT s sig yv)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Rate-Filter.html#v:butterworthHighpass"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Order of the filter, must be even,\n                        the higher the order, the sharper is the separation of frequencies. \n",
          "module": "Synthesizer.Dimensional.Rate.Filter",
          "name": "butterworthLowpass",
          "package": "synthesizer",
          "signature": "Int-\u003e T s u q (T s flat q -\u003e R s (Recip u) q q -\u003e T s sig yv -\u003e T s sig yv)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Rate-Filter.html#butterworthLowpass",
          "type": "function"
        },
        "index": {
          "description": "Order of the filter must be even the higher the order the sharper is the separation of frequencies",
          "hierarchy": "Synthesizer Dimensional Rate Filter",
          "module": "Synthesizer.Dimensional.Rate.Filter",
          "name": "butterworthLowpass",
          "normalized": "Int-\u003eT a b c(T a d c-\u003eR a(Recip b)c c-\u003eT a e f-\u003eT a e f)",
          "package": "synthesizer",
          "partial": "Lowpass",
          "signature": "Int-\u003eT s u q(T s flat q-\u003eR s(Recip u)q q-\u003eT s sig yv-\u003eT s sig yv)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Rate-Filter.html#v:butterworthLowpass"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Order of the filter, must be even,\n                        the higher the order, the sharper is the separation of frequencies. \n",
          "module": "Synthesizer.Dimensional.Rate.Filter",
          "name": "chebyshevAHighpass",
          "package": "synthesizer",
          "signature": "Int-\u003e T s u q (T s flat q -\u003e R s (Recip u) q q -\u003e T s sig yv -\u003e T s sig yv)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Rate-Filter.html#chebyshevAHighpass",
          "type": "function"
        },
        "index": {
          "description": "Order of the filter must be even the higher the order the sharper is the separation of frequencies",
          "hierarchy": "Synthesizer Dimensional Rate Filter",
          "module": "Synthesizer.Dimensional.Rate.Filter",
          "name": "chebyshevAHighpass",
          "normalized": "Int-\u003eT a b c(T a d c-\u003eR a(Recip b)c c-\u003eT a e f-\u003eT a e f)",
          "package": "synthesizer",
          "partial": "AHighpass",
          "signature": "Int-\u003eT s u q(T s flat q-\u003eR s(Recip u)q q-\u003eT s sig yv-\u003eT s sig yv)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Rate-Filter.html#v:chebyshevAHighpass"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Order of the filter, must be even,\n                        the higher the order, the sharper is the separation of frequencies. \n",
          "module": "Synthesizer.Dimensional.Rate.Filter",
          "name": "chebyshevALowpass",
          "package": "synthesizer",
          "signature": "Int-\u003e T s u q (T s flat q -\u003e R s (Recip u) q q -\u003e T s sig yv -\u003e T s sig yv)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Rate-Filter.html#chebyshevALowpass",
          "type": "function"
        },
        "index": {
          "description": "Order of the filter must be even the higher the order the sharper is the separation of frequencies",
          "hierarchy": "Synthesizer Dimensional Rate Filter",
          "module": "Synthesizer.Dimensional.Rate.Filter",
          "name": "chebyshevALowpass",
          "normalized": "Int-\u003eT a b c(T a d c-\u003eR a(Recip b)c c-\u003eT a e f-\u003eT a e f)",
          "package": "synthesizer",
          "partial": "ALowpass",
          "signature": "Int-\u003eT s u q(T s flat q-\u003eR s(Recip u)q q-\u003eT s sig yv-\u003eT s sig yv)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Rate-Filter.html#v:chebyshevALowpass"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Order of the filter, must be even,\n                        the higher the order, the sharper is the separation of frequencies. \n",
          "module": "Synthesizer.Dimensional.Rate.Filter",
          "name": "chebyshevBHighpass",
          "package": "synthesizer",
          "signature": "Int-\u003e T s u q (T s flat q -\u003e R s (Recip u) q q -\u003e T s sig yv -\u003e T s sig yv)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Rate-Filter.html#chebyshevBHighpass",
          "type": "function"
        },
        "index": {
          "description": "Order of the filter must be even the higher the order the sharper is the separation of frequencies",
          "hierarchy": "Synthesizer Dimensional Rate Filter",
          "module": "Synthesizer.Dimensional.Rate.Filter",
          "name": "chebyshevBHighpass",
          "normalized": "Int-\u003eT a b c(T a d c-\u003eR a(Recip b)c c-\u003eT a e f-\u003eT a e f)",
          "package": "synthesizer",
          "partial": "BHighpass",
          "signature": "Int-\u003eT s u q(T s flat q-\u003eR s(Recip u)q q-\u003eT s sig yv-\u003eT s sig yv)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Rate-Filter.html#v:chebyshevBHighpass"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Order of the filter, must be even,\n                        the higher the order, the sharper is the separation of frequencies. \n",
          "module": "Synthesizer.Dimensional.Rate.Filter",
          "name": "chebyshevBLowpass",
          "package": "synthesizer",
          "signature": "Int-\u003e T s u q (T s flat q -\u003e R s (Recip u) q q -\u003e T s sig yv -\u003e T s sig yv)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Rate-Filter.html#chebyshevBLowpass",
          "type": "function"
        },
        "index": {
          "description": "Order of the filter must be even the higher the order the sharper is the separation of frequencies",
          "hierarchy": "Synthesizer Dimensional Rate Filter",
          "module": "Synthesizer.Dimensional.Rate.Filter",
          "name": "chebyshevBLowpass",
          "normalized": "Int-\u003eT a b c(T a d c-\u003eR a(Recip b)c c-\u003eT a e f-\u003eT a e f)",
          "package": "synthesizer",
          "partial": "BLowpass",
          "signature": "Int-\u003eT s u q(T s flat q-\u003eR s(Recip u)q q-\u003eT s sig yv-\u003eT s sig yv)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Rate-Filter.html#v:chebyshevBLowpass"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Infinitely many equi-delayed exponentially decaying echos. \n",
          "module": "Synthesizer.Dimensional.Rate.Filter",
          "name": "comb",
          "package": "synthesizer",
          "signature": "T u t -\u003e y -\u003e T s u t (T s sig yv -\u003e T s sig yv)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Rate-Filter.html#comb",
          "type": "function"
        },
        "index": {
          "description": "Infinitely many equi-delayed exponentially decaying echos",
          "hierarchy": "Synthesizer Dimensional Rate Filter",
          "module": "Synthesizer.Dimensional.Rate.Filter",
          "name": "comb",
          "normalized": "T a b-\u003ec-\u003eT d a b(T d e f-\u003eT d e f)",
          "package": "synthesizer",
          "signature": "T u t-\u003ey-\u003eT s u t(T s sig yv-\u003eT s sig yv)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Rate-Filter.html#v:comb"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.Rate.Filter",
          "name": "convolveVector",
          "package": "synthesizer",
          "signature": "T s u q (R s (Recip u) q q -\u003e T s sig yv -\u003e T s sig yv)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Rate-Filter.html#convolveVector",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional Rate Filter",
          "module": "Synthesizer.Dimensional.Rate.Filter",
          "name": "convolveVector",
          "normalized": "T a b c(R a(Recip b)c c-\u003eT a d e-\u003eT a d e)",
          "package": "synthesizer",
          "partial": "Vector",
          "signature": "T s u q(R s(Recip u)q q-\u003eT s sig yv-\u003eT s sig yv)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Rate-Filter.html#v:convolveVector"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.Rate.Filter",
          "name": "delay",
          "package": "synthesizer",
          "signature": "T u t -\u003e T s u t (T s sig yv -\u003e T s sig yv)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Rate-Filter.html#delay",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional Rate Filter",
          "module": "Synthesizer.Dimensional.Rate.Filter",
          "name": "delay",
          "normalized": "T a b-\u003eT c a b(T c d e-\u003eT c d e)",
          "package": "synthesizer",
          "signature": "T u t-\u003eT s u t(T s sig yv-\u003eT s sig yv)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Rate-Filter.html#v:delay"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.Rate.Filter",
          "name": "envelope",
          "package": "synthesizer",
          "signature": "T s u t (T s flat y0 -\u003e T s sig y0 -\u003e T s sig y0)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Rate-Filter.html#envelope",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional Rate Filter",
          "module": "Synthesizer.Dimensional.Rate.Filter",
          "name": "envelope",
          "normalized": "T a b c(T a d e-\u003eT a f e-\u003eT a f e)",
          "package": "synthesizer",
          "signature": "T s u t(T s flat y-\u003eT s sig y-\u003eT s sig y)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Rate-Filter.html#v:envelope"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.Rate.Filter",
          "name": "envelopeVector",
          "package": "synthesizer",
          "signature": "T s u t (T s flat y0 -\u003e T s sig yv -\u003e T s sig yv)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Rate-Filter.html#envelopeVector",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional Rate Filter",
          "module": "Synthesizer.Dimensional.Rate.Filter",
          "name": "envelopeVector",
          "normalized": "T a b c(T a d e-\u003eT a f g-\u003eT a f g)",
          "package": "synthesizer",
          "partial": "Vector",
          "signature": "T s u t(T s flat y-\u003eT s sig yv-\u003eT s sig yv)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Rate-Filter.html#v:envelopeVector"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.Rate.Filter",
          "name": "firstOrderHighpass",
          "package": "synthesizer",
          "signature": "T s u q (R s (Recip u) q q -\u003e T s sig yv -\u003e T s sig yv)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Rate-Filter.html#firstOrderHighpass",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional Rate Filter",
          "module": "Synthesizer.Dimensional.Rate.Filter",
          "name": "firstOrderHighpass",
          "normalized": "T a b c(R a(Recip b)c c-\u003eT a d e-\u003eT a d e)",
          "package": "synthesizer",
          "partial": "Order Highpass",
          "signature": "T s u q(R s(Recip u)q q-\u003eT s sig yv-\u003eT s sig yv)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Rate-Filter.html#v:firstOrderHighpass"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.Rate.Filter",
          "name": "firstOrderLowpass",
          "package": "synthesizer",
          "signature": "T s u q (R s (Recip u) q q -\u003e T s sig yv -\u003e T s sig yv)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Rate-Filter.html#firstOrderLowpass",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional Rate Filter",
          "module": "Synthesizer.Dimensional.Rate.Filter",
          "name": "firstOrderLowpass",
          "normalized": "T a b c(R a(Recip b)c c-\u003eT a d e-\u003eT a d e)",
          "package": "synthesizer",
          "partial": "Order Lowpass",
          "signature": "T s u q(R s(Recip u)q q-\u003eT s sig yv-\u003eT s sig yv)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Rate-Filter.html#v:firstOrderLowpass"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.Rate.Filter",
          "name": "frequencyModulation",
          "package": "synthesizer",
          "signature": "T t yv -\u003e T s u t (T s flat t -\u003e T s sig yv -\u003e T s sig yv)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Rate-Filter.html#frequencyModulation",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional Rate Filter",
          "module": "Synthesizer.Dimensional.Rate.Filter",
          "name": "frequencyModulation",
          "normalized": "T a b-\u003eT c d a(T c e a-\u003eT c f b-\u003eT c f b)",
          "package": "synthesizer",
          "partial": "Modulation",
          "signature": "T t yv-\u003eT s u t(T s flat t-\u003eT s sig yv-\u003eT s sig yv)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Rate-Filter.html#v:frequencyModulation"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFrequency modulation where the input signal can have a sample rate\ndifferent from the output.\n(The sample rate values can differ, the unit must be the same.\nWe could lift that restriction,\nbut then the unit handling becomes more complicated,\nand I didn't have a use for it so far.)\n\u003c/p\u003e\u003cp\u003eThe function can be used for resampling.\n\u003c/p\u003e",
          "module": "Synthesizer.Dimensional.Rate.Filter",
          "name": "frequencyModulationDecoupled",
          "package": "synthesizer",
          "signature": "T t yv -\u003e T u t sig yv -\u003e T s u t (T s flat t -\u003e T s sig yv)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Rate-Filter.html#frequencyModulationDecoupled",
          "type": "function"
        },
        "index": {
          "description": "Frequency modulation where the input signal can have sample rate different from the output The sample rate values can differ the unit must be the same We could lift that restriction but then the unit handling becomes more complicated and didn have use for it so far The function can be used for resampling",
          "hierarchy": "Synthesizer Dimensional Rate Filter",
          "module": "Synthesizer.Dimensional.Rate.Filter",
          "name": "frequencyModulationDecoupled",
          "normalized": "T a b-\u003eT c a d b-\u003eT e c a(T e f a-\u003eT e d b)",
          "package": "synthesizer",
          "partial": "Modulation Decoupled",
          "signature": "T t yv-\u003eT u t sig yv-\u003eT s u t(T s flat t-\u003eT s sig yv)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Rate-Filter.html#v:frequencyModulationDecoupled"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Synthesizer.Dimensional.Rate.Filter\",\"Synthesizer.Dimensional.RateAmplitude.Filter\"]",
          "name": "highpassFromUniversal",
          "package": "synthesizer",
          "signature": "T s sig (Result yv) -\u003e T s sig yv",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Rate-Filter.html#highpassFromUniversal",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Rate-Filter.html#v:highpassFromUniversal\",\"http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-RateAmplitude-Filter.html#v:highpassFromUniversal\"]"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional Rate Filter",
          "module": "Synthesizer.Dimensional.Rate.Filter",
          "name": "highpassFromUniversal",
          "normalized": "T a b(Result c)-\u003eT a b c",
          "package": "synthesizer",
          "partial": "From Universal",
          "signature": "T s sig(Result yv)-\u003eT s sig yv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Rate-Filter.html#v:highpassFromUniversal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.Rate.Filter",
          "name": "interpolateMultiRelativeZeroPad",
          "package": "synthesizer",
          "signature": "T q yv -\u003e T q -\u003e T yv -\u003e T yv",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Rate-Filter.html#interpolateMultiRelativeZeroPad",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional Rate Filter",
          "module": "Synthesizer.Dimensional.Rate.Filter",
          "name": "interpolateMultiRelativeZeroPad",
          "normalized": "T a b-\u003eT a-\u003eT b-\u003eT b",
          "package": "synthesizer",
          "partial": "Multi Relative Zero Pad",
          "signature": "T q yv-\u003eT q-\u003eT yv-\u003eT yv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Rate-Filter.html#v:interpolateMultiRelativeZeroPad"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Synthesizer.Dimensional.Rate.Filter\",\"Synthesizer.Dimensional.RateAmplitude.Filter\"]",
          "name": "lowpassFromUniversal",
          "package": "synthesizer",
          "signature": "T s sig (Result yv) -\u003e T s sig yv",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Rate-Filter.html#lowpassFromUniversal",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Rate-Filter.html#v:lowpassFromUniversal\",\"http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-RateAmplitude-Filter.html#v:lowpassFromUniversal\"]"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional Rate Filter",
          "module": "Synthesizer.Dimensional.Rate.Filter",
          "name": "lowpassFromUniversal",
          "normalized": "T a b(Result c)-\u003eT a b c",
          "package": "synthesizer",
          "partial": "From Universal",
          "signature": "T s sig(Result yv)-\u003eT s sig yv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Rate-Filter.html#v:lowpassFromUniversal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "minimum cut-off freqeuncy \n",
          "module": "Synthesizer.Dimensional.Rate.Filter",
          "name": "mean",
          "package": "synthesizer",
          "signature": "T (Recip u) q-\u003e T s u q (R s (Recip u) q q -\u003e T s sig yv -\u003e T s sig yv)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Rate-Filter.html#mean",
          "type": "function"
        },
        "index": {
          "description": "minimum cut-off freqeuncy",
          "hierarchy": "Synthesizer Dimensional Rate Filter",
          "module": "Synthesizer.Dimensional.Rate.Filter",
          "name": "mean",
          "normalized": "T(Recip a)b-\u003eT c a b(R c(Recip a)b b-\u003eT c d e-\u003eT c d e)",
          "package": "synthesizer",
          "signature": "T(Recip u)q-\u003eT s u q(R s(Recip u)q q-\u003eT s sig yv-\u003eT s sig yv)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Rate-Filter.html#v:mean"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "cut-off freqeuncy \n",
          "module": "Synthesizer.Dimensional.Rate.Filter",
          "name": "meanStatic",
          "package": "synthesizer",
          "signature": "T (Recip u) q-\u003e T s u q (T s sig yv -\u003e T s sig yv)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Rate-Filter.html#meanStatic",
          "type": "function"
        },
        "index": {
          "description": "cut-off freqeuncy",
          "hierarchy": "Synthesizer Dimensional Rate Filter",
          "module": "Synthesizer.Dimensional.Rate.Filter",
          "name": "meanStatic",
          "normalized": "T(Recip a)b-\u003eT c a b(T c d e-\u003eT c d e)",
          "package": "synthesizer",
          "partial": "Static",
          "signature": "T(Recip u)q-\u003eT s u q(T s sig yv-\u003eT s sig yv)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Rate-Filter.html#v:meanStatic"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.Rate.Filter",
          "name": "moogLowpass",
          "package": "synthesizer",
          "signature": "Int -\u003e T s u q (T s flat q -\u003e R s (Recip u) q q -\u003e T s sig yv -\u003e T s sig yv)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Rate-Filter.html#moogLowpass",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional Rate Filter",
          "module": "Synthesizer.Dimensional.Rate.Filter",
          "name": "moogLowpass",
          "normalized": "Int-\u003eT a b c(T a d c-\u003eR a(Recip b)c c-\u003eT a e f-\u003eT a e f)",
          "package": "synthesizer",
          "partial": "Lowpass",
          "signature": "Int-\u003eT s u q(T s flat q-\u003eR s(Recip u)q q-\u003eT s sig yv-\u003eT s sig yv)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Rate-Filter.html#v:moogLowpass"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.Rate.Filter",
          "name": "negate",
          "package": "synthesizer",
          "signature": "T s u t (T s sig yv -\u003e T s sig yv)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Rate-Filter.html#negate",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional Rate Filter",
          "module": "Synthesizer.Dimensional.Rate.Filter",
          "name": "negate",
          "normalized": "T a b c(T a d e-\u003eT a d e)",
          "package": "synthesizer",
          "signature": "T s u t(T s sig yv-\u003eT s sig yv)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Rate-Filter.html#v:negate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "minimal deviation from current time, usually negative \nmaximal deviation, it must be \u003ctt\u003eminDev \u003c= maxDev\u003c/tt\u003e\n               and the modulation must always be\n               in the range [minDev,maxDev]. \n",
          "module": "Synthesizer.Dimensional.Rate.Filter",
          "name": "phaseModulation",
          "package": "synthesizer",
          "signature": "T q yv-\u003e T u q-\u003e T u q-\u003e T s u q (R s u q q -\u003e T s sig yv -\u003e T s sig yv)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Rate-Filter.html#phaseModulation",
          "type": "function"
        },
        "index": {
          "description": "minimal deviation from current time usually negative maximal deviation it must be minDev maxDev and the modulation must always be in the range minDev maxDev",
          "hierarchy": "Synthesizer Dimensional Rate Filter",
          "module": "Synthesizer.Dimensional.Rate.Filter",
          "name": "phaseModulation",
          "normalized": "T a b-\u003eT c a-\u003eT c a-\u003eT d c a(R d c a a-\u003eT d e b-\u003eT d e b)",
          "package": "synthesizer",
          "partial": "Modulation",
          "signature": "T q yv-\u003eT u q-\u003eT u q-\u003eT s u q(R s u q q-\u003eT s sig yv-\u003eT s sig yv)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Rate-Filter.html#v:phaseModulation"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "maxDev, must be positive \n",
          "module": "Synthesizer.Dimensional.Rate.Filter",
          "name": "phaser",
          "package": "synthesizer",
          "signature": "T q yv-\u003e T u q-\u003e T s u q (R s u q q -\u003e T s sig yv -\u003e T s sig yv)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Rate-Filter.html#phaser",
          "type": "function"
        },
        "index": {
          "description": "maxDev must be positive",
          "hierarchy": "Synthesizer Dimensional Rate Filter",
          "module": "Synthesizer.Dimensional.Rate.Filter",
          "name": "phaser",
          "normalized": "T a b-\u003eT c a-\u003eT d c a(R d c a a-\u003eT d e b-\u003eT d e b)",
          "package": "synthesizer",
          "signature": "T q yv-\u003eT u q-\u003eT s u q(R s u q q-\u003eT s sig yv-\u003eT s sig yv)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Rate-Filter.html#v:phaser"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "maxDev, must be positive \n",
          "module": "Synthesizer.Dimensional.Rate.Filter",
          "name": "phaserStereo",
          "package": "synthesizer",
          "signature": "T q yv-\u003e T u q-\u003e T s u q (R s u q q -\u003e T s sig yv -\u003e T s sig (T yv))",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Rate-Filter.html#phaserStereo",
          "type": "function"
        },
        "index": {
          "description": "maxDev must be positive",
          "hierarchy": "Synthesizer Dimensional Rate Filter",
          "module": "Synthesizer.Dimensional.Rate.Filter",
          "name": "phaserStereo",
          "normalized": "T a b-\u003eT c a-\u003eT d c a(R d c a a-\u003eT d e b-\u003eT d e(T b))",
          "package": "synthesizer",
          "partial": "Stereo",
          "signature": "T q yv-\u003eT u q-\u003eT s u q(R s u q q-\u003eT s sig yv-\u003eT s sig(T yv))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Rate-Filter.html#v:phaserStereo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "highpass, bandpass, lowpass filter \n",
          "module": "Synthesizer.Dimensional.Rate.Filter",
          "name": "universal",
          "package": "synthesizer",
          "signature": "T s u q (T s flat q -\u003e R s (Recip u) q q -\u003e T s sig yv -\u003e T s sig (Result yv))",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Rate-Filter.html#universal",
          "type": "function"
        },
        "index": {
          "description": "highpass bandpass lowpass filter",
          "hierarchy": "Synthesizer Dimensional Rate Filter",
          "module": "Synthesizer.Dimensional.Rate.Filter",
          "name": "universal",
          "normalized": "T a b c(T a d c-\u003eR a(Recip b)c c-\u003eT a e f-\u003eT a e(Result f))",
          "package": "synthesizer",
          "signature": "T s u q(T s flat q-\u003eR s(Recip u)q q-\u003eT s sig yv-\u003eT s sig(Result yv))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Rate-Filter.html#v:universal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "waveform \nstart phase \n",
          "module": "Synthesizer.Dimensional.Rate.Oscillator",
          "name": "freqMod",
          "package": "synthesizer",
          "signature": "wave y-\u003e T t-\u003e T s u t (R s (Recip u) t t -\u003e T s sig y)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Rate-Oscillator.html#freqMod",
          "type": "function"
        },
        "index": {
          "description": "waveform start phase",
          "hierarchy": "Synthesizer Dimensional Rate Oscillator",
          "module": "Synthesizer.Dimensional.Rate.Oscillator",
          "name": "freqMod",
          "normalized": "a b-\u003eT c-\u003eT d e c(R d(Recip e)c c-\u003eT d f b)",
          "package": "synthesizer",
          "partial": "Mod",
          "signature": "wave y-\u003eT t-\u003eT s u t(R s(Recip u)t t-\u003eT s sig y)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Rate-Oscillator.html#v:freqMod"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "waveform \nstart phase \n",
          "module": "Synthesizer.Dimensional.Rate.Oscillator",
          "name": "freqModAntiAlias",
          "package": "synthesizer",
          "signature": "wave y-\u003e T t-\u003e T s u t (R s (Recip u) t t -\u003e T s sig y)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Rate-Oscillator.html#freqModAntiAlias",
          "type": "function"
        },
        "index": {
          "description": "waveform start phase",
          "hierarchy": "Synthesizer Dimensional Rate Oscillator",
          "module": "Synthesizer.Dimensional.Rate.Oscillator",
          "name": "freqModAntiAlias",
          "normalized": "a b-\u003eT c-\u003eT d e c(R d(Recip e)c c-\u003eT d f b)",
          "package": "synthesizer",
          "partial": "Mod Anti Alias",
          "signature": "wave y-\u003eT t-\u003eT s u t(R s(Recip u)t t-\u003eT s sig y)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Rate-Oscillator.html#v:freqModAntiAlias"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "waveform \nstart phase \n",
          "module": "Synthesizer.Dimensional.Rate.Oscillator",
          "name": "freqModSample",
          "package": "synthesizer",
          "signature": "T t y-\u003e R r y-\u003e T t-\u003e T s u t (R s (Recip u) t t -\u003e R s y)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Rate-Oscillator.html#freqModSample",
          "type": "function"
        },
        "index": {
          "description": "waveform start phase",
          "hierarchy": "Synthesizer Dimensional Rate Oscillator",
          "module": "Synthesizer.Dimensional.Rate.Oscillator",
          "name": "freqModSample",
          "normalized": "T a b-\u003eR c b-\u003eT a-\u003eT d e a(R d(Recip e)a a-\u003eR d b)",
          "package": "synthesizer",
          "partial": "Mod Sample",
          "signature": "T t y-\u003eR r y-\u003eT t-\u003eT s u t(R s(Recip u)t t-\u003eR s y)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Rate-Oscillator.html#v:freqModSample"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "waveform \n",
          "module": "Synthesizer.Dimensional.Rate.Oscillator",
          "name": "phaseFreqMod",
          "package": "synthesizer",
          "signature": "wave y-\u003e T s u t (T s flat t -\u003e R s (Recip u) t t -\u003e T s sig y)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Rate-Oscillator.html#phaseFreqMod",
          "type": "function"
        },
        "index": {
          "description": "waveform",
          "hierarchy": "Synthesizer Dimensional Rate Oscillator",
          "module": "Synthesizer.Dimensional.Rate.Oscillator",
          "name": "phaseFreqMod",
          "normalized": "a b-\u003eT c d e(T c f e-\u003eR c(Recip d)e e-\u003eT c g b)",
          "package": "synthesizer",
          "partial": "Freq Mod",
          "signature": "wave y-\u003eT s u t(T s flat t-\u003eR s(Recip u)t t-\u003eT s sig y)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Rate-Oscillator.html#v:phaseFreqMod"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "waveform \nfrequency \n",
          "module": "Synthesizer.Dimensional.Rate.Oscillator",
          "name": "phaseMod",
          "package": "synthesizer",
          "signature": "wave y-\u003e T (Recip u) t-\u003e T s u t (T s flat t -\u003e T s sig y)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Rate-Oscillator.html#phaseMod",
          "type": "function"
        },
        "index": {
          "description": "waveform frequency",
          "hierarchy": "Synthesizer Dimensional Rate Oscillator",
          "module": "Synthesizer.Dimensional.Rate.Oscillator",
          "name": "phaseMod",
          "normalized": "a b-\u003eT(Recip c)d-\u003eT e c d(T e f d-\u003eT e g b)",
          "package": "synthesizer",
          "partial": "Mod",
          "signature": "wave y-\u003eT(Recip u)t-\u003eT s u t(T s flat t-\u003eT s sig y)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Rate-Oscillator.html#v:phaseMod"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "waveform \nphase \n",
          "module": "Synthesizer.Dimensional.Rate.Oscillator",
          "name": "shapeFreqMod",
          "package": "synthesizer",
          "signature": "c -\u003e T t y-\u003e T t-\u003e T s u t (T s flat c -\u003e R s (Recip u) t t -\u003e R s y)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Rate-Oscillator.html#shapeFreqMod",
          "type": "function"
        },
        "index": {
          "description": "waveform phase",
          "hierarchy": "Synthesizer Dimensional Rate Oscillator",
          "module": "Synthesizer.Dimensional.Rate.Oscillator",
          "name": "shapeFreqMod",
          "normalized": "a-\u003eT b c-\u003eT b-\u003eT d e b(T d f a-\u003eR d(Recip e)b b-\u003eR d c)",
          "package": "synthesizer",
          "partial": "Freq Mod",
          "signature": "c-\u003eT t y-\u003eT t-\u003eT s u t(T s flat c-\u003eR s(Recip u)t t-\u003eR s y)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Rate-Oscillator.html#v:shapeFreqMod"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "source frequency \n",
          "module": "Synthesizer.Dimensional.Rate.Oscillator",
          "name": "shapeFreqModFromSampledTone",
          "package": "synthesizer",
          "signature": "T t yv-\u003e T t yv-\u003e T (Recip u) t-\u003e T u t input yv-\u003e t-\u003e T t-\u003e T s u t (T s flat t -\u003e R s (Recip u) t t -\u003e T s output yv)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Rate-Oscillator.html#shapeFreqModFromSampledTone",
          "type": "function"
        },
        "index": {
          "description": "source frequency",
          "hierarchy": "Synthesizer Dimensional Rate Oscillator",
          "module": "Synthesizer.Dimensional.Rate.Oscillator",
          "name": "shapeFreqModFromSampledTone",
          "normalized": "T a b-\u003eT a b-\u003eT(Recip c)a-\u003eT c a d b-\u003ea-\u003eT a-\u003eT e c a(T e f a-\u003eR e(Recip c)a a-\u003eT e g b)",
          "package": "synthesizer",
          "partial": "Freq Mod From Sampled Tone",
          "signature": "T t yv-\u003eT t yv-\u003eT(Recip u)t-\u003eT u t input yv-\u003et-\u003eT t-\u003eT s u t(T s flat t-\u003eR s(Recip u)t t-\u003eT s output yv)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Rate-Oscillator.html#v:shapeFreqModFromSampledTone"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "waveform \nphase \nfrequency \n",
          "module": "Synthesizer.Dimensional.Rate.Oscillator",
          "name": "shapeMod",
          "package": "synthesizer",
          "signature": "c -\u003e T t y-\u003e T t-\u003e T (Recip u) t-\u003e T s u t (T s flat c -\u003e R s y)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Rate-Oscillator.html#shapeMod",
          "type": "function"
        },
        "index": {
          "description": "waveform phase frequency",
          "hierarchy": "Synthesizer Dimensional Rate Oscillator",
          "module": "Synthesizer.Dimensional.Rate.Oscillator",
          "name": "shapeMod",
          "normalized": "a-\u003eT b c-\u003eT b-\u003eT(Recip d)b-\u003eT e d b(T e f a-\u003eR e c)",
          "package": "synthesizer",
          "partial": "Mod",
          "signature": "c-\u003eT t y-\u003eT t-\u003eT(Recip u)t-\u003eT s u t(T s flat c-\u003eR s y)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Rate-Oscillator.html#v:shapeMod"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "source frequency \n",
          "module": "Synthesizer.Dimensional.Rate.Oscillator",
          "name": "shapePhaseFreqModFromSampledTone",
          "package": "synthesizer",
          "signature": "T t yv-\u003e T t yv-\u003e T (Recip u) t-\u003e T u t input yv-\u003e t-\u003e T t-\u003e T s u t (T s flatS t -\u003e T s flatP t -\u003e R s (Recip u) t t -\u003e T s output yv)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Rate-Oscillator.html#shapePhaseFreqModFromSampledTone",
          "type": "function"
        },
        "index": {
          "description": "source frequency",
          "hierarchy": "Synthesizer Dimensional Rate Oscillator",
          "module": "Synthesizer.Dimensional.Rate.Oscillator",
          "name": "shapePhaseFreqModFromSampledTone",
          "normalized": "T a b-\u003eT a b-\u003eT(Recip c)a-\u003eT c a d b-\u003ea-\u003eT a-\u003eT e c a(T e f a-\u003eT e g a-\u003eR e(Recip c)a a-\u003eT e h b)",
          "package": "synthesizer",
          "partial": "Phase Freq Mod From Sampled Tone",
          "signature": "T t yv-\u003eT t yv-\u003eT(Recip u)t-\u003eT u t input yv-\u003et-\u003eT t-\u003eT s u t(T s flatS t-\u003eT s flatP t-\u003eR s(Recip u)t t-\u003eT s output yv)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Rate-Oscillator.html#v:shapePhaseFreqModFromSampledTone"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "waveform \nstart phase \nfrequency \n",
          "module": "Synthesizer.Dimensional.Rate.Oscillator",
          "name": "static",
          "package": "synthesizer",
          "signature": "wave y-\u003e T t-\u003e T (Recip u) t-\u003e T s u t (T s sig y)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Rate-Oscillator.html#static",
          "type": "function"
        },
        "index": {
          "description": "waveform start phase frequency",
          "hierarchy": "Synthesizer Dimensional Rate Oscillator",
          "module": "Synthesizer.Dimensional.Rate.Oscillator",
          "name": "static",
          "normalized": "a b-\u003eT c-\u003eT(Recip d)c-\u003eT e d c(T e f b)",
          "package": "synthesizer",
          "signature": "wave y-\u003eT t-\u003eT(Recip u)t-\u003eT s u t(T s sig y)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Rate-Oscillator.html#v:static"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "waveform \nstart phase \nfrequency \n",
          "module": "Synthesizer.Dimensional.Rate.Oscillator",
          "name": "staticAntiAlias",
          "package": "synthesizer",
          "signature": "wave y-\u003e T t-\u003e T (Recip u) t-\u003e T s u t (T s sig y)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Rate-Oscillator.html#staticAntiAlias",
          "type": "function"
        },
        "index": {
          "description": "waveform start phase frequency",
          "hierarchy": "Synthesizer Dimensional Rate Oscillator",
          "module": "Synthesizer.Dimensional.Rate.Oscillator",
          "name": "staticAntiAlias",
          "normalized": "a b-\u003eT c-\u003eT(Recip d)c-\u003eT e d c(T e f b)",
          "package": "synthesizer",
          "partial": "Anti Alias",
          "signature": "wave y-\u003eT t-\u003eT(Recip u)t-\u003eT s u t(T s sig y)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Rate-Oscillator.html#v:staticAntiAlias"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "waveform \nstart phase \nfrequency \n",
          "module": "Synthesizer.Dimensional.Rate.Oscillator",
          "name": "staticSample",
          "package": "synthesizer",
          "signature": "T t y-\u003e R r y-\u003e T t-\u003e T (Recip u) t-\u003e T s u t (R s y)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Rate-Oscillator.html#staticSample",
          "type": "function"
        },
        "index": {
          "description": "waveform start phase frequency",
          "hierarchy": "Synthesizer Dimensional Rate Oscillator",
          "module": "Synthesizer.Dimensional.Rate.Oscillator",
          "name": "staticSample",
          "normalized": "T a b-\u003eR c b-\u003eT a-\u003eT(Recip d)a-\u003eT e d a(R e b)",
          "package": "synthesizer",
          "partial": "Sample",
          "signature": "T t y-\u003eR r y-\u003eT t-\u003eT(Recip u)t-\u003eT s u t(R s y)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Rate-Oscillator.html#v:staticSample"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.Rate",
          "name": "T",
          "package": "synthesizer",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Rate.html#T",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional Rate",
          "module": "Synthesizer.Dimensional.Rate",
          "name": "T",
          "package": "synthesizer",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Rate.html#t:T"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.Rate",
          "name": "common",
          "package": "synthesizer",
          "signature": "String -\u003e T s u t -\u003e T s u t -\u003e T s u t",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Rate.html#common",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional Rate",
          "module": "Synthesizer.Dimensional.Rate",
          "name": "common",
          "normalized": "String-\u003eT a b c-\u003eT a b c-\u003eT a b c",
          "package": "synthesizer",
          "signature": "String-\u003eT s u t-\u003eT s u t-\u003eT s u t",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Rate.html#v:common"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.Rate",
          "name": "fromDimensionNumber",
          "package": "synthesizer",
          "signature": "T (Recip u) t -\u003e T s u t",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Rate.html#fromDimensionNumber",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional Rate",
          "module": "Synthesizer.Dimensional.Rate",
          "name": "fromDimensionNumber",
          "normalized": "T(Recip a)b-\u003eT c a b",
          "package": "synthesizer",
          "partial": "Dimension Number",
          "signature": "T(Recip u)t-\u003eT s u t",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Rate.html#v:fromDimensionNumber"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.Rate",
          "name": "fromNumber",
          "package": "synthesizer",
          "signature": "Recip u -\u003e t -\u003e T s u t",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Rate.html#fromNumber",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional Rate",
          "module": "Synthesizer.Dimensional.Rate",
          "name": "fromNumber",
          "normalized": "Recip a-\u003eb-\u003eT c a b",
          "package": "synthesizer",
          "partial": "Number",
          "signature": "Recip u-\u003et-\u003eT s u t",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Rate.html#v:fromNumber"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "This function is somehow dangerous\nbecause it drops the s parameter.\n",
          "module": "Synthesizer.Dimensional.Rate",
          "name": "toDimensionNumber",
          "package": "synthesizer",
          "signature": "T s u t -\u003e T (Recip u) t",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Rate.html#toDimensionNumber",
          "type": "function"
        },
        "index": {
          "description": "This function is somehow dangerous because it drops the parameter",
          "hierarchy": "Synthesizer Dimensional Rate",
          "module": "Synthesizer.Dimensional.Rate",
          "name": "toDimensionNumber",
          "normalized": "T a b c-\u003eT(Recip b)c",
          "package": "synthesizer",
          "partial": "Dimension Number",
          "signature": "T s u t-\u003eT(Recip u)t",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Rate.html#v:toDimensionNumber"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "This function is somehow dangerous\nbecause it drops the s parameter.\n",
          "module": "Synthesizer.Dimensional.Rate",
          "name": "toNumber",
          "package": "synthesizer",
          "signature": "Recip u -\u003e T s u t -\u003e t",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Rate.html#toNumber",
          "type": "function"
        },
        "index": {
          "description": "This function is somehow dangerous because it drops the parameter",
          "hierarchy": "Synthesizer Dimensional Rate",
          "module": "Synthesizer.Dimensional.Rate",
          "name": "toNumber",
          "normalized": "Recip a-\u003eT b a c-\u003ec",
          "package": "synthesizer",
          "partial": "Number",
          "signature": "Recip u-\u003eT s u t-\u003et",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Rate.html#v:toNumber"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.RateAmplitude.Analysis",
          "name": "centroid",
          "package": "synthesizer",
          "signature": "T u q (S v y) q -\u003e T u q",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-RateAmplitude-Analysis.html#centroid",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional RateAmplitude Analysis",
          "module": "Synthesizer.Dimensional.RateAmplitude.Analysis",
          "name": "centroid",
          "normalized": "T a b(S c d)b-\u003eT a b",
          "package": "synthesizer",
          "signature": "T u q(S v y)q-\u003eT u q",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-RateAmplitude-Analysis.html#v:centroid"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Fourier synthesis\n",
          "module": "Synthesizer.Dimensional.RateAmplitude.Analysis",
          "name": "fromFrequencySpectrum",
          "package": "synthesizer",
          "signature": "T (Recip u) q (D (Mul u v) q (T T)) (T q) -\u003e T u q (D v q (T T)) (T q)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-RateAmplitude-Analysis.html#fromFrequencySpectrum",
          "type": "function"
        },
        "index": {
          "description": "Fourier synthesis",
          "hierarchy": "Synthesizer Dimensional RateAmplitude Analysis",
          "module": "Synthesizer.Dimensional.RateAmplitude.Analysis",
          "name": "fromFrequencySpectrum",
          "normalized": "T(Recip a)b(D(Mul a c)b(T T))(T b)-\u003eT a b(D c b(T T))(T b)",
          "package": "synthesizer",
          "partial": "Frequency Spectrum",
          "signature": "T(Recip u)q(D(Mul u v)q(T T))(T q)-\u003eT u q(D v q(T T))(T q)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-RateAmplitude-Analysis.html#v:fromFrequencySpectrum"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.RateAmplitude.Analysis",
          "name": "histogram",
          "package": "synthesizer",
          "signature": "T u q (S v q) q -\u003e T s v q (Int, R s (DimensionGradient v u) q q)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-RateAmplitude-Analysis.html#histogram",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional RateAmplitude Analysis",
          "module": "Synthesizer.Dimensional.RateAmplitude.Analysis",
          "name": "histogram",
          "normalized": "T a b(S c b)b-\u003eT d c b(Int,R d(DimensionGradient c a)b b)",
          "package": "synthesizer",
          "signature": "T u q(S v q)q-\u003eT s v q(Int,R s(DimensionGradient v u)q q)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-RateAmplitude-Analysis.html#v:histogram"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.RateAmplitude.Analysis",
          "name": "length",
          "package": "synthesizer",
          "signature": "T u t (S v y) yv -\u003e T u t",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-RateAmplitude-Analysis.html#length",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional RateAmplitude Analysis",
          "module": "Synthesizer.Dimensional.RateAmplitude.Analysis",
          "name": "length",
          "normalized": "T a b(S c d)e-\u003eT a b",
          "package": "synthesizer",
          "signature": "T u t(S v y)yv-\u003eT u t",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-RateAmplitude-Analysis.html#v:length"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSquare of energy norm.\n\u003c/p\u003e\u003cp\u003eCould also be called \u003ctt\u003evariance\u003c/tt\u003e.\n\u003c/p\u003e",
          "module": "Synthesizer.Dimensional.RateAmplitude.Analysis",
          "name": "normEuclideanSqr",
          "package": "synthesizer",
          "signature": "T u q (S v q) q -\u003e T (Mul u (Sqr v)) q",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-RateAmplitude-Analysis.html#normEuclideanSqr",
          "type": "function"
        },
        "index": {
          "description": "Square of energy norm Could also be called variance",
          "hierarchy": "Synthesizer Dimensional RateAmplitude Analysis",
          "module": "Synthesizer.Dimensional.RateAmplitude.Analysis",
          "name": "normEuclideanSqr",
          "normalized": "T a b(S c b)b-\u003eT(Mul a(Sqr c))b",
          "package": "synthesizer",
          "partial": "Euclidean Sqr",
          "signature": "T u q(S v q)q-\u003eT(Mul u(Sqr v))q",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-RateAmplitude-Analysis.html#v:normEuclideanSqr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSquare of energy norm.\n\u003c/p\u003e\u003cp\u003eCould also be called \u003ctt\u003evariance\u003c/tt\u003e.\n\u003c/p\u003e",
          "module": "Synthesizer.Dimensional.RateAmplitude.Analysis",
          "name": "normEuclideanSqrProc",
          "package": "synthesizer",
          "signature": "T s u q (R s v q q -\u003e T (Mul u (Sqr v)) q)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-RateAmplitude-Analysis.html#normEuclideanSqrProc",
          "type": "function"
        },
        "index": {
          "description": "Square of energy norm Could also be called variance",
          "hierarchy": "Synthesizer Dimensional RateAmplitude Analysis",
          "module": "Synthesizer.Dimensional.RateAmplitude.Analysis",
          "name": "normEuclideanSqrProc",
          "normalized": "T a b c(R a d c c-\u003eT(Mul b(Sqr d))c)",
          "package": "synthesizer",
          "partial": "Euclidean Sqr Proc",
          "signature": "T s u q(R s v q q-\u003eT(Mul u(Sqr v))q)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-RateAmplitude-Analysis.html#v:normEuclideanSqrProc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Manhattan norm.\n",
          "module": "Synthesizer.Dimensional.RateAmplitude.Analysis",
          "name": "normMaximum",
          "package": "synthesizer",
          "signature": "T u t (S v y) y -\u003e T v y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-RateAmplitude-Analysis.html#normMaximum",
          "type": "function"
        },
        "index": {
          "description": "Manhattan norm",
          "hierarchy": "Synthesizer Dimensional RateAmplitude Analysis",
          "module": "Synthesizer.Dimensional.RateAmplitude.Analysis",
          "name": "normMaximum",
          "normalized": "T a b(S c d)d-\u003eT c d",
          "package": "synthesizer",
          "partial": "Maximum",
          "signature": "T u t(S v y)y-\u003eT v y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-RateAmplitude-Analysis.html#v:normMaximum"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Manhattan norm.\n",
          "module": "Synthesizer.Dimensional.RateAmplitude.Analysis",
          "name": "normMaximumProc",
          "package": "synthesizer",
          "signature": "T s u y (R s v y y -\u003e T v y)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-RateAmplitude-Analysis.html#normMaximumProc",
          "type": "function"
        },
        "index": {
          "description": "Manhattan norm",
          "hierarchy": "Synthesizer Dimensional RateAmplitude Analysis",
          "module": "Synthesizer.Dimensional.RateAmplitude.Analysis",
          "name": "normMaximumProc",
          "normalized": "T a b c(R a d c c-\u003eT d c)",
          "package": "synthesizer",
          "partial": "Maximum Proc",
          "signature": "T s u y(R s v y y-\u003eT v y)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-RateAmplitude-Analysis.html#v:normMaximumProc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Sum norm.\n",
          "module": "Synthesizer.Dimensional.RateAmplitude.Analysis",
          "name": "normSum",
          "package": "synthesizer",
          "signature": "T u q (S v q) q -\u003e T (Mul u v) q",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-RateAmplitude-Analysis.html#normSum",
          "type": "function"
        },
        "index": {
          "description": "Sum norm",
          "hierarchy": "Synthesizer Dimensional RateAmplitude Analysis",
          "module": "Synthesizer.Dimensional.RateAmplitude.Analysis",
          "name": "normSum",
          "normalized": "T a b(S c b)b-\u003eT(Mul a c)b",
          "package": "synthesizer",
          "partial": "Sum",
          "signature": "T u q(S v q)q-\u003eT(Mul u v)q",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-RateAmplitude-Analysis.html#v:normSum"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Sum norm.\n",
          "module": "Synthesizer.Dimensional.RateAmplitude.Analysis",
          "name": "normSumProc",
          "package": "synthesizer",
          "signature": "T s u q (R s v q q -\u003e T (Mul u v) q)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-RateAmplitude-Analysis.html#normSumProc",
          "type": "function"
        },
        "index": {
          "description": "Sum norm",
          "hierarchy": "Synthesizer Dimensional RateAmplitude Analysis",
          "module": "Synthesizer.Dimensional.RateAmplitude.Analysis",
          "name": "normSumProc",
          "normalized": "T a b c(R a d c c-\u003eT(Mul b d)c)",
          "package": "synthesizer",
          "partial": "Sum Proc",
          "signature": "T s u q(R s v q q-\u003eT(Mul u v)q)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-RateAmplitude-Analysis.html#v:normSumProc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Energy norm.\n",
          "module": "Synthesizer.Dimensional.RateAmplitude.Analysis",
          "name": "normVectorEuclideanSqr",
          "package": "synthesizer",
          "signature": "T u q (S v q) yv -\u003e T (Mul u (Sqr v)) q",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-RateAmplitude-Analysis.html#normVectorEuclideanSqr",
          "type": "function"
        },
        "index": {
          "description": "Energy norm",
          "hierarchy": "Synthesizer Dimensional RateAmplitude Analysis",
          "module": "Synthesizer.Dimensional.RateAmplitude.Analysis",
          "name": "normVectorEuclideanSqr",
          "normalized": "T a b(S c b)d-\u003eT(Mul a(Sqr c))b",
          "package": "synthesizer",
          "partial": "Vector Euclidean Sqr",
          "signature": "T u q(S v q)yv-\u003eT(Mul u(Sqr v))q",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-RateAmplitude-Analysis.html#v:normVectorEuclideanSqr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Energy norm.\n",
          "module": "Synthesizer.Dimensional.RateAmplitude.Analysis",
          "name": "normVectorEuclideanSqrProc",
          "package": "synthesizer",
          "signature": "T s u y (R s v y yv -\u003e T (Mul u (Sqr v)) y)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-RateAmplitude-Analysis.html#normVectorEuclideanSqrProc",
          "type": "function"
        },
        "index": {
          "description": "Energy norm",
          "hierarchy": "Synthesizer Dimensional RateAmplitude Analysis",
          "module": "Synthesizer.Dimensional.RateAmplitude.Analysis",
          "name": "normVectorEuclideanSqrProc",
          "normalized": "T a b c(R a d c e-\u003eT(Mul b(Sqr d))c)",
          "package": "synthesizer",
          "partial": "Vector Euclidean Sqr Proc",
          "signature": "T s u y(R s v y yv-\u003eT(Mul u(Sqr v))y)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-RateAmplitude-Analysis.html#v:normVectorEuclideanSqrProc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Manhattan norm.\n",
          "module": "Synthesizer.Dimensional.RateAmplitude.Analysis",
          "name": "normVectorMaximum",
          "package": "synthesizer",
          "signature": "T u q (S v q) yv -\u003e T v q",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-RateAmplitude-Analysis.html#normVectorMaximum",
          "type": "function"
        },
        "index": {
          "description": "Manhattan norm",
          "hierarchy": "Synthesizer Dimensional RateAmplitude Analysis",
          "module": "Synthesizer.Dimensional.RateAmplitude.Analysis",
          "name": "normVectorMaximum",
          "normalized": "T a b(S c b)d-\u003eT c b",
          "package": "synthesizer",
          "partial": "Vector Maximum",
          "signature": "T u q(S v q)yv-\u003eT v q",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-RateAmplitude-Analysis.html#v:normVectorMaximum"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Manhattan norm.\n",
          "module": "Synthesizer.Dimensional.RateAmplitude.Analysis",
          "name": "normVectorMaximumProc",
          "package": "synthesizer",
          "signature": "T s u y (R s v y yv -\u003e T v y)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-RateAmplitude-Analysis.html#normVectorMaximumProc",
          "type": "function"
        },
        "index": {
          "description": "Manhattan norm",
          "hierarchy": "Synthesizer Dimensional RateAmplitude Analysis",
          "module": "Synthesizer.Dimensional.RateAmplitude.Analysis",
          "name": "normVectorMaximumProc",
          "normalized": "T a b c(R a d c e-\u003eT d c)",
          "package": "synthesizer",
          "partial": "Vector Maximum Proc",
          "signature": "T s u y(R s v y yv-\u003eT v y)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-RateAmplitude-Analysis.html#v:normVectorMaximumProc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Sum norm.\n",
          "module": "Synthesizer.Dimensional.RateAmplitude.Analysis",
          "name": "normVectorSum",
          "package": "synthesizer",
          "signature": "T u q (S v q) yv -\u003e T (Mul u v) q",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-RateAmplitude-Analysis.html#normVectorSum",
          "type": "function"
        },
        "index": {
          "description": "Sum norm",
          "hierarchy": "Synthesizer Dimensional RateAmplitude Analysis",
          "module": "Synthesizer.Dimensional.RateAmplitude.Analysis",
          "name": "normVectorSum",
          "normalized": "T a b(S c b)d-\u003eT(Mul a c)b",
          "package": "synthesizer",
          "partial": "Vector Sum",
          "signature": "T u q(S v q)yv-\u003eT(Mul u v)q",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-RateAmplitude-Analysis.html#v:normVectorSum"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Sum norm.\n",
          "module": "Synthesizer.Dimensional.RateAmplitude.Analysis",
          "name": "normVectorSumProc",
          "package": "synthesizer",
          "signature": "T s u y (R s v y yv -\u003e T (Mul u v) y)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-RateAmplitude-Analysis.html#normVectorSumProc",
          "type": "function"
        },
        "index": {
          "description": "Sum norm",
          "hierarchy": "Synthesizer Dimensional RateAmplitude Analysis",
          "module": "Synthesizer.Dimensional.RateAmplitude.Analysis",
          "name": "normVectorSumProc",
          "normalized": "T a b c(R a d c e-\u003eT(Mul b d)c)",
          "package": "synthesizer",
          "partial": "Vector Sum Proc",
          "signature": "T s u y(R s v y yv-\u003eT(Mul u v)y)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-RateAmplitude-Analysis.html#v:normVectorSumProc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Fourier analysis\n",
          "module": "Synthesizer.Dimensional.RateAmplitude.Analysis",
          "name": "toFrequencySpectrum",
          "package": "synthesizer",
          "signature": "T u q (D v q (T T)) (T q) -\u003e T (Recip u) q (D (Mul u v) q (T T)) (T q)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-RateAmplitude-Analysis.html#toFrequencySpectrum",
          "type": "function"
        },
        "index": {
          "description": "Fourier analysis",
          "hierarchy": "Synthesizer Dimensional RateAmplitude Analysis",
          "module": "Synthesizer.Dimensional.RateAmplitude.Analysis",
          "name": "toFrequencySpectrum",
          "normalized": "T a b(D c b(T T))(T b)-\u003eT(Recip a)b(D(Mul a c)b(T T))(T b)",
          "package": "synthesizer",
          "partial": "Frequency Spectrum",
          "signature": "T u q(D v q(T T))(T q)-\u003eT(Recip u)q(D(Mul u v)q(T T))(T q)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-RateAmplitude-Analysis.html#v:toFrequencySpectrum"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDetects zeros (sign changes) in a signal.\nThis can be used as a simple measure of the portion\nof high frequencies or noise in the signal.\nThe result has a frequency as amplitude.\nIf you smooth it, you will get a curve that represents a frequency progress.\nIt ca be used as voiced/unvoiced detector in a vocoder.\n\u003c/p\u003e\u003cp\u003eThe result will be one value shorter than the input.\n\u003c/p\u003e",
          "module": "Synthesizer.Dimensional.RateAmplitude.Analysis",
          "name": "zeros",
          "package": "synthesizer",
          "signature": "T s u q (R s v q q -\u003e R s (Recip u) q q)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-RateAmplitude-Analysis.html#zeros",
          "type": "function"
        },
        "index": {
          "description": "Detects zeros sign changes in signal This can be used as simple measure of the portion of high frequencies or noise in the signal The result has frequency as amplitude If you smooth it you will get curve that represents frequency progress It ca be used as voiced unvoiced detector in vocoder The result will be one value shorter than the input",
          "hierarchy": "Synthesizer Dimensional RateAmplitude Analysis",
          "module": "Synthesizer.Dimensional.RateAmplitude.Analysis",
          "name": "zeros",
          "normalized": "T a b c(R a d c c-\u003eR a(Recip b)c c)",
          "package": "synthesizer",
          "signature": "T s u q(R s v q q-\u003eR s(Recip u)q q)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-RateAmplitude-Analysis.html#v:zeros"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.RateAmplitude.Control",
          "name": "Piece",
          "package": "synthesizer",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-RateAmplitude-Control.html#Piece",
          "type": "type"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional RateAmplitude Control",
          "module": "Synthesizer.Dimensional.RateAmplitude.Control",
          "name": "Piece",
          "package": "synthesizer",
          "partial": "Piece",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-RateAmplitude-Control.html#t:Piece"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.RateAmplitude.Control",
          "name": "Piecewise",
          "package": "synthesizer",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-RateAmplitude-Control.html#Piecewise",
          "type": "type"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional RateAmplitude Control",
          "module": "Synthesizer.Dimensional.RateAmplitude.Control",
          "name": "Piecewise",
          "package": "synthesizer",
          "partial": "Piecewise",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-RateAmplitude-Control.html#t:Piecewise"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Synthesizer.Dimensional.RateAmplitude.Control\",\"Synthesizer.Piecewise\"]",
          "name": "#|",
          "package": "synthesizer",
          "signature": "(t, Piece t y sig) -\u003e y -\u003e (PieceDist t y sig, T t y sig)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Piecewise.html#%23%7C",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-RateAmplitude-Control.html#v:#|\",\"http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Piecewise.html#v:#|\"]"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional RateAmplitude Control",
          "module": "Synthesizer.Dimensional.RateAmplitude.Control",
          "name": "#|",
          "normalized": "(a,Piece a b c)-\u003eb-\u003e(PieceDist a b c,T a b c)",
          "package": "synthesizer",
          "signature": "(t,Piece t y sig)-\u003ey-\u003e(PieceDist t y sig,T t y sig)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-RateAmplitude-Control.html#v:#|"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe 6 operators simplify constructing a list of \u003ctt\u003ePieceData a\u003c/tt\u003e.\nThe description consists of nodes (namely the curve values at nodes)\nand the connecting curve types.\nThe naming scheme is as follows:\nIn the middle there is a bar \u003ctt\u003e|\u003c/tt\u003e.\nWith respect to the bar,\nthe pad symbol \u003ctt\u003e#\u003c/tt\u003e is at the side of the curve type,\nat the other side there is nothing, a minus sign \u003ctt\u003e-\u003c/tt\u003e, or an equality sign \u003ctt\u003e=\u003c/tt\u003e.\n\u003c/p\u003e\u003col\u003e\u003cli\u003e Nothing means that here is the start or the end node of a curve.\n\u003c/li\u003e\u003cli\u003e Minus means that here is a node where left and right curve meet at the same value.\n     The node description is thus one value.\n\u003c/li\u003e\u003cli\u003e Equality sign means that here is a split node,\n     where left and right curve might have different ending and beginning values, respectively.\n     The node description consists of a pair of values.\n\u003c/li\u003e\u003c/ol\u003e",
          "module": "[\"Synthesizer.Dimensional.RateAmplitude.Control\",\"Synthesizer.Piecewise\"]",
          "name": "#|-",
          "package": "synthesizer",
          "signature": "(t, Piece t y sig) -\u003e (PieceRightSingle y, T t y sig) -\u003e (PieceDist t y sig, T t y sig)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Piecewise.html#%23%7C-",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-RateAmplitude-Control.html#v:#|-\",\"http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Piecewise.html#v:#|-\"]"
        },
        "index": {
          "description": "The operators simplify constructing list of PieceData The description consists of nodes namely the curve values at nodes and the connecting curve types The naming scheme is as follows In the middle there is bar With respect to the bar the pad symbol is at the side of the curve type at the other side there is nothing minus sign or an equality sign Nothing means that here is the start or the end node of curve Minus means that here is node where left and right curve meet at the same value The node description is thus one value Equality sign means that here is split node where left and right curve might have different ending and beginning values respectively The node description consists of pair of values",
          "hierarchy": "Synthesizer Dimensional RateAmplitude Control",
          "module": "Synthesizer.Dimensional.RateAmplitude.Control",
          "name": "#|-",
          "normalized": "(a,Piece a b c)-\u003e(PieceRightSingle b,T a b c)-\u003e(PieceDist a b c,T a b c)",
          "package": "synthesizer",
          "signature": "(t,Piece t y sig)-\u003e(PieceRightSingle y,T t y sig)-\u003e(PieceDist t y sig,T t y sig)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-RateAmplitude-Control.html#v:#|-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Synthesizer.Dimensional.RateAmplitude.Control\",\"Synthesizer.Piecewise\"]",
          "name": "#|=",
          "package": "synthesizer",
          "signature": "(t, Piece t y sig) -\u003e (PieceRightDouble y, T t y sig) -\u003e (PieceDist t y sig, T t y sig)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Piecewise.html#%23%7C%3D",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-RateAmplitude-Control.html#v:#|=\",\"http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Piecewise.html#v:#|=\"]"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional RateAmplitude Control",
          "module": "Synthesizer.Dimensional.RateAmplitude.Control",
          "name": "#|=",
          "normalized": "(a,Piece a b c)-\u003e(PieceRightDouble b,T a b c)-\u003e(PieceDist a b c,T a b c)",
          "package": "synthesizer",
          "signature": "(t,Piece t y sig)-\u003e(PieceRightDouble y,T t y sig)-\u003e(PieceDist t y sig,T t y sig)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-RateAmplitude-Control.html#v:#|="
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Synthesizer.Dimensional.RateAmplitude.Control\",\"Synthesizer.Piecewise\"]",
          "name": "-|#",
          "package": "synthesizer",
          "signature": "y -\u003e (PieceDist t y sig, T t y sig) -\u003e (PieceRightSingle y, T t y sig)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Piecewise.html#-%7C%23",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-RateAmplitude-Control.html#v:-|#\",\"http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Piecewise.html#v:-|#\"]"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional RateAmplitude Control",
          "module": "Synthesizer.Dimensional.RateAmplitude.Control",
          "name": "-|#",
          "normalized": "a-\u003e(PieceDist b a c,T b a c)-\u003e(PieceRightSingle a,T b a c)",
          "package": "synthesizer",
          "signature": "y-\u003e(PieceDist t y sig,T t y sig)-\u003e(PieceRightSingle y,T t y sig)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-RateAmplitude-Control.html#v:-|#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Synthesizer.Dimensional.RateAmplitude.Control\",\"Synthesizer.Piecewise\"]",
          "name": "=|#",
          "package": "synthesizer",
          "signature": "(y, y) -\u003e (PieceDist t y sig, T t y sig) -\u003e (PieceRightDouble y, T t y sig)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Piecewise.html#%3D%7C%23",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-RateAmplitude-Control.html#v:=|#\",\"http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Piecewise.html#v:=|#\"]"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional RateAmplitude Control",
          "module": "Synthesizer.Dimensional.RateAmplitude.Control",
          "name": "=|#",
          "normalized": "(a,a)-\u003e(PieceDist b a c,T b a c)-\u003e(PieceRightDouble a,T b a c)",
          "package": "synthesizer",
          "signature": "(y,y)-\u003e(PieceDist t y sig,T t y sig)-\u003e(PieceRightDouble y,T t y sig)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-RateAmplitude-Control.html#v:=|#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "value \n",
          "module": "Synthesizer.Dimensional.RateAmplitude.Control",
          "name": "constant",
          "package": "synthesizer",
          "signature": "T v y-\u003e T s u t (R s v y y)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-RateAmplitude-Control.html#constant",
          "type": "function"
        },
        "index": {
          "description": "value",
          "hierarchy": "Synthesizer Dimensional RateAmplitude Control",
          "module": "Synthesizer.Dimensional.RateAmplitude.Control",
          "name": "constant",
          "normalized": "T a b-\u003eT c d e(R c a b b)",
          "package": "synthesizer",
          "signature": "T v y-\u003eT s u t(R s v y y)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-RateAmplitude-Control.html#v:constant"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "amplitude \nvalue \n",
          "module": "Synthesizer.Dimensional.RateAmplitude.Control",
          "name": "constantVector",
          "package": "synthesizer",
          "signature": "T v y-\u003e yv-\u003e T s u t (R s v y yv)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-RateAmplitude-Control.html#constantVector",
          "type": "function"
        },
        "index": {
          "description": "amplitude value",
          "hierarchy": "Synthesizer Dimensional RateAmplitude Control",
          "module": "Synthesizer.Dimensional.RateAmplitude.Control",
          "name": "constantVector",
          "normalized": "T a b-\u003ec-\u003eT d e f(R d a b c)",
          "package": "synthesizer",
          "partial": "Vector",
          "signature": "T v y-\u003eyv-\u003eT s u t(R s v y yv)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-RateAmplitude-Control.html#v:constantVector"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.RateAmplitude.Control",
          "name": "cosinePiece",
          "package": "synthesizer",
          "signature": "Piece s u v q",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-RateAmplitude-Control.html#cosinePiece",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional RateAmplitude Control",
          "module": "Synthesizer.Dimensional.RateAmplitude.Control",
          "name": "cosinePiece",
          "package": "synthesizer",
          "partial": "Piece",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-RateAmplitude-Control.html#v:cosinePiece"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.RateAmplitude.Control",
          "name": "cubicHermite",
          "package": "synthesizer",
          "signature": "(T u q, (T v q, T (DimensionGradient u v) q)) -\u003e (T u q, (T v q, T (DimensionGradient u v) q)) -\u003e T s u q (R s v q q)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-RateAmplitude-Control.html#cubicHermite",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional RateAmplitude Control",
          "module": "Synthesizer.Dimensional.RateAmplitude.Control",
          "name": "cubicHermite",
          "normalized": "(T a b,(T c b,T(DimensionGradient a c)b))-\u003e(T a b,(T c b,T(DimensionGradient a c)b))-\u003eT d a b(R d c b b)",
          "package": "synthesizer",
          "partial": "Hermite",
          "signature": "(T u q,(T v q,T(DimensionGradient u v)q))-\u003e(T u q,(T v q,T(DimensionGradient u v)q))-\u003eT s u q(R s v q q)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-RateAmplitude-Control.html#v:cubicHermite"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.RateAmplitude.Control",
          "name": "cubicPiece",
          "package": "synthesizer",
          "signature": "T (DimensionGradient u v) q -\u003e T (DimensionGradient u v) q -\u003e Piece s u v q",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-RateAmplitude-Control.html#cubicPiece",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional RateAmplitude Control",
          "module": "Synthesizer.Dimensional.RateAmplitude.Control",
          "name": "cubicPiece",
          "normalized": "T(DimensionGradient a b)c-\u003eT(DimensionGradient a b)c-\u003ePiece d a b c",
          "package": "synthesizer",
          "partial": "Piece",
          "signature": "T(DimensionGradient u v)q-\u003eT(DimensionGradient u v)q-\u003ePiece s u v q",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-RateAmplitude-Control.html#v:cubicPiece"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "time where the function reaches 1/e of the initial value \ninitial value \n",
          "module": "Synthesizer.Dimensional.RateAmplitude.Control",
          "name": "exponential",
          "package": "synthesizer",
          "signature": "T u q-\u003e T v q-\u003e T s u q (R s v q q)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-RateAmplitude-Control.html#exponential",
          "type": "function"
        },
        "index": {
          "description": "time where the function reaches of the initial value initial value",
          "hierarchy": "Synthesizer Dimensional RateAmplitude Control",
          "module": "Synthesizer.Dimensional.RateAmplitude.Control",
          "name": "exponential",
          "normalized": "T a b-\u003eT c b-\u003eT d a b(R d c b b)",
          "package": "synthesizer",
          "signature": "T u q-\u003eT v q-\u003eT s u q(R s v q q)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-RateAmplitude-Control.html#v:exponential"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "half life, time where the function reaches 1/2 of the initial value \ninitial value \n",
          "module": "Synthesizer.Dimensional.RateAmplitude.Control",
          "name": "exponential2",
          "package": "synthesizer",
          "signature": "T u q-\u003e T v q-\u003e T s u q (R s v q q)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-RateAmplitude-Control.html#exponential2",
          "type": "function"
        },
        "index": {
          "description": "half life time where the function reaches of the initial value initial value",
          "hierarchy": "Synthesizer Dimensional RateAmplitude Control",
          "module": "Synthesizer.Dimensional.RateAmplitude.Control",
          "name": "exponential2",
          "normalized": "T a b-\u003eT c b-\u003eT d a b(R d c b b)",
          "package": "synthesizer",
          "signature": "T u q-\u003eT v q-\u003eT s u q(R s v q q)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-RateAmplitude-Control.html#v:exponential2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "duration of the ramp \ninitial and final value \n",
          "module": "Synthesizer.Dimensional.RateAmplitude.Control",
          "name": "exponentialFromTo",
          "package": "synthesizer",
          "signature": "T u q-\u003e (T v q, T v q)-\u003e T s u q (R s v q q)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-RateAmplitude-Control.html#exponentialFromTo",
          "type": "function"
        },
        "index": {
          "description": "duration of the ramp initial and final value",
          "hierarchy": "Synthesizer Dimensional RateAmplitude Control",
          "module": "Synthesizer.Dimensional.RateAmplitude.Control",
          "name": "exponentialFromTo",
          "normalized": "T a b-\u003e(T c b,T c b)-\u003eT d a b(R d c b b)",
          "package": "synthesizer",
          "partial": "From To",
          "signature": "T u q-\u003e(T v q,T v q)-\u003eT s u q(R s v q q)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-RateAmplitude-Control.html#v:exponentialFromTo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.RateAmplitude.Control",
          "name": "exponentialPiece",
          "package": "synthesizer",
          "signature": "T v q -\u003e Piece s u v q",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-RateAmplitude-Control.html#exponentialPiece",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional RateAmplitude Control",
          "module": "Synthesizer.Dimensional.RateAmplitude.Control",
          "name": "exponentialPiece",
          "normalized": "T a b-\u003ePiece c d a b",
          "package": "synthesizer",
          "partial": "Piece",
          "signature": "T v q-\u003ePiece s u v q",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-RateAmplitude-Control.html#v:exponentialPiece"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "duration of the ramp \ninitial and final value \n",
          "module": "Synthesizer.Dimensional.RateAmplitude.Control",
          "name": "line",
          "package": "synthesizer",
          "signature": "T u q-\u003e (T v q, T v q)-\u003e T s u q (R s v q q)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-RateAmplitude-Control.html#line",
          "type": "function"
        },
        "index": {
          "description": "duration of the ramp initial and final value",
          "hierarchy": "Synthesizer Dimensional RateAmplitude Control",
          "module": "Synthesizer.Dimensional.RateAmplitude.Control",
          "name": "line",
          "normalized": "T a b-\u003e(T c b,T c b)-\u003eT d a b(R d c b b)",
          "package": "synthesizer",
          "signature": "T u q-\u003e(T v q,T v q)-\u003eT s u q(R s v q q)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-RateAmplitude-Control.html#v:line"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "slope of the curve \ninitial value \n",
          "module": "Synthesizer.Dimensional.RateAmplitude.Control",
          "name": "linear",
          "package": "synthesizer",
          "signature": "T (DimensionGradient u v) q-\u003e T v q-\u003e T s u q (R s v q q)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-RateAmplitude-Control.html#linear",
          "type": "function"
        },
        "index": {
          "description": "slope of the curve initial value",
          "hierarchy": "Synthesizer Dimensional RateAmplitude Control",
          "module": "Synthesizer.Dimensional.RateAmplitude.Control",
          "name": "linear",
          "normalized": "T(DimensionGradient a b)c-\u003eT b c-\u003eT d a c(R d b c c)",
          "package": "synthesizer",
          "signature": "T(DimensionGradient u v)q-\u003eT v q-\u003eT s u q(R s v q q)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-RateAmplitude-Control.html#v:linear"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.RateAmplitude.Control",
          "name": "linearPiece",
          "package": "synthesizer",
          "signature": "Piece s u v q",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-RateAmplitude-Control.html#linearPiece",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional RateAmplitude Control",
          "module": "Synthesizer.Dimensional.RateAmplitude.Control",
          "name": "linearPiece",
          "package": "synthesizer",
          "partial": "Piece",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-RateAmplitude-Control.html#v:linearPiece"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "range: one is mapped to \u003ctt\u003ecenter*range\u003c/tt\u003e, must be positive \ncenter: zero is mapped to \u003ctt\u003ecenter\u003c/tt\u003e \n",
          "module": "Synthesizer.Dimensional.RateAmplitude.Control",
          "name": "mapExponentialDimension",
          "package": "synthesizer",
          "signature": "y-\u003e T u y-\u003e T s u t (R s Scalar y y -\u003e R s u y y)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-RateAmplitude-Control.html#mapExponentialDimension",
          "type": "function"
        },
        "index": {
          "description": "range one is mapped to center range must be positive center zero is mapped to center",
          "hierarchy": "Synthesizer Dimensional RateAmplitude Control",
          "module": "Synthesizer.Dimensional.RateAmplitude.Control",
          "name": "mapExponentialDimension",
          "normalized": "a-\u003eT b a-\u003eT c b d(R c Scalar a a-\u003eR c b a a)",
          "package": "synthesizer",
          "partial": "Exponential Dimension",
          "signature": "y-\u003eT u y-\u003eT s u t(R s Scalar y y-\u003eR s u y y)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-RateAmplitude-Control.html#v:mapExponentialDimension"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "range: one is mapped to \u003ctt\u003ecenter + range * ampX\u003c/tt\u003e \ncenter: zero is mapped to \u003ctt\u003ecenter\u003c/tt\u003e \n",
          "module": "Synthesizer.Dimensional.RateAmplitude.Control",
          "name": "mapLinearDimension",
          "package": "synthesizer",
          "signature": "T v y-\u003e T (Mul v u) y-\u003e T s u t (R s u y y -\u003e R s (Mul v u) y y)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-RateAmplitude-Control.html#mapLinearDimension",
          "type": "function"
        },
        "index": {
          "description": "range one is mapped to center range ampX center zero is mapped to center",
          "hierarchy": "Synthesizer Dimensional RateAmplitude Control",
          "module": "Synthesizer.Dimensional.RateAmplitude.Control",
          "name": "mapLinearDimension",
          "normalized": "T a b-\u003eT(Mul a c)b-\u003eT d c e(R d c b b-\u003eR d(Mul a c)b b)",
          "package": "synthesizer",
          "partial": "Linear Dimension",
          "signature": "T v y-\u003eT(Mul v u)y-\u003eT s u t(R s u y y-\u003eR s(Mul v u)y y)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-RateAmplitude-Control.html#v:mapLinearDimension"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Since this function looks for the maximum node value,\nand since the signal parameter inference phase must be completed before signal processing,\ninfinite descriptions cannot be used here.\n",
          "module": "Synthesizer.Dimensional.RateAmplitude.Control",
          "name": "piecewise",
          "package": "synthesizer",
          "signature": "Piecewise s u v q -\u003e T s u q (R s v q q)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-RateAmplitude-Control.html#piecewise",
          "type": "function"
        },
        "index": {
          "description": "Since this function looks for the maximum node value and since the signal parameter inference phase must be completed before signal processing infinite descriptions cannot be used here",
          "hierarchy": "Synthesizer Dimensional RateAmplitude Control",
          "module": "Synthesizer.Dimensional.RateAmplitude.Control",
          "name": "piecewise",
          "normalized": "Piecewise a b c d-\u003eT a b d(R a c d d)",
          "package": "synthesizer",
          "signature": "Piecewise s u v q-\u003eT s u q(R s v q q)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-RateAmplitude-Control.html#v:piecewise"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.RateAmplitude.Control",
          "name": "piecewiseVolume",
          "package": "synthesizer",
          "signature": "Piecewise s u v q -\u003e T v q -\u003e T s u q (R s v q q)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-RateAmplitude-Control.html#piecewiseVolume",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional RateAmplitude Control",
          "module": "Synthesizer.Dimensional.RateAmplitude.Control",
          "name": "piecewiseVolume",
          "normalized": "Piecewise a b c d-\u003eT c d-\u003eT a b d(R a c d d)",
          "package": "synthesizer",
          "partial": "Volume",
          "signature": "Piecewise s u v q-\u003eT v q-\u003eT s u q(R s v q q)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-RateAmplitude-Control.html#v:piecewiseVolume"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.RateAmplitude.Control",
          "name": "stepPiece",
          "package": "synthesizer",
          "signature": "Piece s u v q",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-RateAmplitude-Control.html#stepPiece",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional RateAmplitude Control",
          "module": "Synthesizer.Dimensional.RateAmplitude.Control",
          "name": "stepPiece",
          "package": "synthesizer",
          "partial": "Piece",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-RateAmplitude-Control.html#v:stepPiece"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Synthesizer.Dimensional.RateAmplitude.Control\",\"Synthesizer.Piecewise\"]",
          "name": "|#",
          "package": "synthesizer",
          "signature": "y -\u003e (PieceDist t y sig, T t y sig) -\u003e T t y sig",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Piecewise.html#%7C%23",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-RateAmplitude-Control.html#v:|#\",\"http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Piecewise.html#v:|#\"]"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional RateAmplitude Control",
          "module": "Synthesizer.Dimensional.RateAmplitude.Control",
          "name": "|#",
          "normalized": "a-\u003e(PieceDist b a c,T b a c)-\u003eT b a c",
          "package": "synthesizer",
          "signature": "y-\u003e(PieceDist t y sig,T t y sig)-\u003eT t y sig",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-RateAmplitude-Control.html#v:|#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.RateAmplitude.Cut",
          "name": "append",
          "package": "synthesizer",
          "signature": "T s u t (R s v y yv -\u003e R s v y yv -\u003e R s v y yv)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-RateAmplitude-Cut.html#append",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional RateAmplitude Cut",
          "module": "Synthesizer.Dimensional.RateAmplitude.Cut",
          "name": "append",
          "normalized": "T a b c(R a d e f-\u003eR a d e f-\u003eR a d e f)",
          "package": "synthesizer",
          "signature": "T s u t(R s v y yv-\u003eR s v y yv-\u003eR s v y yv)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-RateAmplitude-Cut.html#v:append"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.RateAmplitude.Cut",
          "name": "appendVolume",
          "package": "synthesizer",
          "signature": "T v y -\u003e T s u t (R s v y yv -\u003e R s v y yv -\u003e R s v y yv)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-RateAmplitude-Cut.html#appendVolume",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional RateAmplitude Cut",
          "module": "Synthesizer.Dimensional.RateAmplitude.Cut",
          "name": "appendVolume",
          "normalized": "T a b-\u003eT c d e(R c a b f-\u003eR c a b f-\u003eR c a b f)",
          "package": "synthesizer",
          "partial": "Volume",
          "signature": "T v y-\u003eT s u t(R s v y yv-\u003eR s v y yv-\u003eR s v y yv)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-RateAmplitude-Cut.html#v:appendVolume"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Dim of the time values in the time ordered list. \nThe mixed signal. \n",
          "module": "Synthesizer.Dimensional.RateAmplitude.Cut",
          "name": "arrange",
          "package": "synthesizer",
          "signature": "T u t-\u003e T s u t (T t (R s v y yv) -\u003e R s v y yv)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-RateAmplitude-Cut.html#arrange",
          "type": "function"
        },
        "index": {
          "description": "Dim of the time values in the time ordered list The mixed signal",
          "hierarchy": "Synthesizer Dimensional RateAmplitude Cut",
          "module": "Synthesizer.Dimensional.RateAmplitude.Cut",
          "name": "arrange",
          "normalized": "T a b-\u003eT c a b(T b(R c d e f)-\u003eR c d e f)",
          "package": "synthesizer",
          "signature": "T u t-\u003eT s u t(T t(R s v y yv)-\u003eR s v y yv)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-RateAmplitude-Cut.html#v:arrange"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Output volume. \nDim of the time values in the time ordered list. \nThe mixed signal. \n",
          "module": "Synthesizer.Dimensional.RateAmplitude.Cut",
          "name": "arrangeVolume",
          "package": "synthesizer",
          "signature": "T v y-\u003e T u t-\u003e T s u t (T t (R s v y yv) -\u003e R s v y yv)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-RateAmplitude-Cut.html#arrangeVolume",
          "type": "function"
        },
        "index": {
          "description": "Output volume Dim of the time values in the time ordered list The mixed signal",
          "hierarchy": "Synthesizer Dimensional RateAmplitude Cut",
          "module": "Synthesizer.Dimensional.RateAmplitude.Cut",
          "name": "arrangeVolume",
          "normalized": "T a b-\u003eT c d-\u003eT e c d(T d(R e a b f)-\u003eR e a b f)",
          "package": "synthesizer",
          "partial": "Volume",
          "signature": "T v y-\u003eT u t-\u003eT s u t(T t(R s v y yv)-\u003eR s v y yv)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-RateAmplitude-Cut.html#v:arrangeVolume"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Similar to \u003ctt\u003efoldr1 append\u003c/tt\u003e but more efficient and accurate,\nbecause it reduces the number of amplifications.\nDoes not work for infinite lists,\nbecause no maximum amplitude can be computed.\n",
          "module": "Synthesizer.Dimensional.RateAmplitude.Cut",
          "name": "concat",
          "package": "synthesizer",
          "signature": "T s u t ([R s v y yv] -\u003e R s v y yv)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-RateAmplitude-Cut.html#concat",
          "type": "function"
        },
        "index": {
          "description": "Similar to foldr1 append but more efficient and accurate because it reduces the number of amplifications Does not work for infinite lists because no maximum amplitude can be computed",
          "hierarchy": "Synthesizer Dimensional RateAmplitude Cut",
          "module": "Synthesizer.Dimensional.RateAmplitude.Cut",
          "name": "concat",
          "normalized": "T a b c([R a d e f]-\u003eR a d e f)",
          "package": "synthesizer",
          "signature": "T s u t([R s v y yv]-\u003eR s v y yv)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-RateAmplitude-Cut.html#v:concat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Give the output volume explicitly.\nDoes also work for infinite lists.\n",
          "module": "Synthesizer.Dimensional.RateAmplitude.Cut",
          "name": "concatVolume",
          "package": "synthesizer",
          "signature": "T v y -\u003e T s u t ([R s v y yv] -\u003e R s v y yv)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-RateAmplitude-Cut.html#concatVolume",
          "type": "function"
        },
        "index": {
          "description": "Give the output volume explicitly Does also work for infinite lists",
          "hierarchy": "Synthesizer Dimensional RateAmplitude Cut",
          "module": "Synthesizer.Dimensional.RateAmplitude.Cut",
          "name": "concatVolume",
          "normalized": "T a b-\u003eT c d e([R c a b f]-\u003eR c a b f)",
          "package": "synthesizer",
          "partial": "Volume",
          "signature": "T v y-\u003eT s u t([R s v y yv]-\u003eR s v y yv)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-RateAmplitude-Cut.html#v:concatVolume"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.RateAmplitude.Cut",
          "name": "drop",
          "package": "synthesizer",
          "signature": "T u t -\u003e T s u t (R s v y yv -\u003e R s v y yv)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-RateAmplitude-Cut.html#drop",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional RateAmplitude Cut",
          "module": "Synthesizer.Dimensional.RateAmplitude.Cut",
          "name": "drop",
          "normalized": "T a b-\u003eT c a b(R c d e f-\u003eR c d e f)",
          "package": "synthesizer",
          "signature": "T u t-\u003eT s u t(R s v y yv-\u003eR s v y yv)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-RateAmplitude-Cut.html#v:drop"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.RateAmplitude.Cut",
          "name": "leftFromStereo",
          "package": "synthesizer",
          "signature": "T s u t (R s u y (T yv) -\u003e R s u y yv)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-RateAmplitude-Cut.html#leftFromStereo",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional RateAmplitude Cut",
          "module": "Synthesizer.Dimensional.RateAmplitude.Cut",
          "name": "leftFromStereo",
          "normalized": "T a b c(R a b d(T e)-\u003eR a b d e)",
          "package": "synthesizer",
          "partial": "From Stereo",
          "signature": "T s u t(R s u y(T yv)-\u003eR s u y yv)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-RateAmplitude-Cut.html#v:leftFromStereo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.RateAmplitude.Cut",
          "name": "mergeStereo",
          "package": "synthesizer",
          "signature": "T s u t (R s v y yv -\u003e R s v y yv -\u003e R s v y (T yv))",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-RateAmplitude-Cut.html#mergeStereo",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional RateAmplitude Cut",
          "module": "Synthesizer.Dimensional.RateAmplitude.Cut",
          "name": "mergeStereo",
          "normalized": "T a b c(R a d e f-\u003eR a d e f-\u003eR a d e(T f))",
          "package": "synthesizer",
          "partial": "Stereo",
          "signature": "T s u t(R s v y yv-\u003eR s v y yv-\u003eR s v y(T yv))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-RateAmplitude-Cut.html#v:mergeStereo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.RateAmplitude.Cut",
          "name": "mergeStereoVolume",
          "package": "synthesizer",
          "signature": "T v y -\u003e T s u t (R s v y yv -\u003e R s v y yv -\u003e R s v y (T yv))",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-RateAmplitude-Cut.html#mergeStereoVolume",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional RateAmplitude Cut",
          "module": "Synthesizer.Dimensional.RateAmplitude.Cut",
          "name": "mergeStereoVolume",
          "normalized": "T a b-\u003eT c d e(R c a b f-\u003eR c a b f-\u003eR c a b(T f))",
          "package": "synthesizer",
          "partial": "Stereo Volume",
          "signature": "T v y-\u003eT s u t(R s v y yv-\u003eR s v y yv-\u003eR s v y(T yv))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-RateAmplitude-Cut.html#v:mergeStereoVolume"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.RateAmplitude.Cut",
          "name": "rightFromStereo",
          "package": "synthesizer",
          "signature": "T s u t (R s u y (T yv) -\u003e R s u y yv)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-RateAmplitude-Cut.html#rightFromStereo",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional RateAmplitude Cut",
          "module": "Synthesizer.Dimensional.RateAmplitude.Cut",
          "name": "rightFromStereo",
          "normalized": "T a b c(R a b d(T e)-\u003eR a b d e)",
          "package": "synthesizer",
          "partial": "From Stereo",
          "signature": "T s u t(R s u y(T yv)-\u003eR s u y yv)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-RateAmplitude-Cut.html#v:rightFromStereo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.RateAmplitude.Cut",
          "name": "splitAt",
          "package": "synthesizer",
          "signature": "T u t -\u003e T s u t (R s v y yv -\u003e (R s v y yv, R s v y yv))",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-RateAmplitude-Cut.html#splitAt",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional RateAmplitude Cut",
          "module": "Synthesizer.Dimensional.RateAmplitude.Cut",
          "name": "splitAt",
          "normalized": "T a b-\u003eT c a b(R c d e f-\u003e(R c d e f,R c d e f))",
          "package": "synthesizer",
          "partial": "At",
          "signature": "T u t-\u003eT s u t(R s v y yv-\u003e(R s v y yv,R s v y yv))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-RateAmplitude-Cut.html#v:splitAt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.RateAmplitude.Cut",
          "name": "take",
          "package": "synthesizer",
          "signature": "T u t -\u003e T s u t (R s v y yv -\u003e R s v y yv)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-RateAmplitude-Cut.html#take",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional RateAmplitude Cut",
          "module": "Synthesizer.Dimensional.RateAmplitude.Cut",
          "name": "take",
          "normalized": "T a b-\u003eT c a b(R c d e f-\u003eR c d e f)",
          "package": "synthesizer",
          "signature": "T u t-\u003eT s u t(R s v y yv-\u003eR s v y yv)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-RateAmplitude-Cut.html#v:take"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.RateAmplitude.Cut",
          "name": "takeUntilPause",
          "package": "synthesizer",
          "signature": "T v y -\u003e T u t -\u003e T s u t (R s v y yv -\u003e R s v y yv)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-RateAmplitude-Cut.html#takeUntilPause",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional RateAmplitude Cut",
          "module": "Synthesizer.Dimensional.RateAmplitude.Cut",
          "name": "takeUntilPause",
          "normalized": "T a b-\u003eT c d-\u003eT e c d(R e a b f-\u003eR e a b f)",
          "package": "synthesizer",
          "partial": "Until Pause",
          "signature": "T v y-\u003eT u t-\u003eT s u t(R s v y yv-\u003eR s v y yv)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-RateAmplitude-Cut.html#v:takeUntilPause"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.RateAmplitude.Cut",
          "name": "unzip",
          "package": "synthesizer",
          "signature": "T s u t (R s v y (yv0, yv1) -\u003e (R s v y yv0, R s v y yv1))",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-RateAmplitude-Cut.html#unzip",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional RateAmplitude Cut",
          "module": "Synthesizer.Dimensional.RateAmplitude.Cut",
          "name": "unzip",
          "normalized": "T a b c(R a d e(f,f)-\u003e(R a d e f,R a d e f))",
          "package": "synthesizer",
          "signature": "T s u t(R s v y(yv,yv)-\u003e(R s v y yv,R s v y yv))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-RateAmplitude-Cut.html#v:unzip"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.RateAmplitude.Cut",
          "name": "unzip3",
          "package": "synthesizer",
          "signature": "T s u t (R s v y (yv0, yv1, yv2) -\u003e (R s v y yv0, R s v y yv1, R s v y yv2))",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-RateAmplitude-Cut.html#unzip3",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional RateAmplitude Cut",
          "module": "Synthesizer.Dimensional.RateAmplitude.Cut",
          "name": "unzip3",
          "normalized": "T a b c(R a d e(f,f,f)-\u003e(R a d e f,R a d e f,R a d e f))",
          "package": "synthesizer",
          "signature": "T s u t(R s v y(yv,yv,yv)-\u003e(R s v y yv,R s v y yv,R s v y yv))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-RateAmplitude-Cut.html#v:unzip3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.RateAmplitude.Cut",
          "name": "zip",
          "package": "synthesizer",
          "signature": "T s u t (R s v y yv0 -\u003e R s v y yv1 -\u003e R s v y (yv0, yv1))",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-RateAmplitude-Cut.html#zip",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional RateAmplitude Cut",
          "module": "Synthesizer.Dimensional.RateAmplitude.Cut",
          "name": "zip",
          "normalized": "T a b c(R a d e f-\u003eR a d e f-\u003eR a d e(f,f))",
          "package": "synthesizer",
          "signature": "T s u t(R s v y yv-\u003eR s v y yv-\u003eR s v y(yv,yv))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-RateAmplitude-Cut.html#v:zip"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.RateAmplitude.Cut",
          "name": "zip3",
          "package": "synthesizer",
          "signature": "T s u t (R s v y yv0 -\u003e R s v y yv1 -\u003e R s v y yv2 -\u003e R s v y (yv0, yv1, yv2))",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-RateAmplitude-Cut.html#zip3",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional RateAmplitude Cut",
          "module": "Synthesizer.Dimensional.RateAmplitude.Cut",
          "name": "zip3",
          "normalized": "T a b c(R a d e f-\u003eR a d e f-\u003eR a d e f-\u003eR a d e(f,f,f))",
          "package": "synthesizer",
          "signature": "T s u t(R s v y yv-\u003eR s v y yv-\u003eR s v y yv-\u003eR s v y(yv,yv,yv))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-RateAmplitude-Cut.html#v:zip3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.RateAmplitude.Cut",
          "name": "zip3Volume",
          "package": "synthesizer",
          "signature": "T v y -\u003e T s u t (R s v y yv0 -\u003e R s v y yv1 -\u003e R s v y yv2 -\u003e R s v y (yv0, yv1, yv2))",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-RateAmplitude-Cut.html#zip3Volume",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional RateAmplitude Cut",
          "module": "Synthesizer.Dimensional.RateAmplitude.Cut",
          "name": "zip3Volume",
          "normalized": "T a b-\u003eT c d e(R c a b f-\u003eR c a b f-\u003eR c a b f-\u003eR c a b(f,f,f))",
          "package": "synthesizer",
          "partial": "Volume",
          "signature": "T v y-\u003eT s u t(R s v y yv-\u003eR s v y yv-\u003eR s v y yv-\u003eR s v y(yv,yv,yv))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-RateAmplitude-Cut.html#v:zip3Volume"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.RateAmplitude.Cut",
          "name": "zipVolume",
          "package": "synthesizer",
          "signature": "T v y -\u003e T s u t (R s v y yv0 -\u003e R s v y yv1 -\u003e R s v y (yv0, yv1))",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-RateAmplitude-Cut.html#zipVolume",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional RateAmplitude Cut",
          "module": "Synthesizer.Dimensional.RateAmplitude.Cut",
          "name": "zipVolume",
          "normalized": "T a b-\u003eT c d e(R c a b f-\u003eR c a b f-\u003eR c a b(f,f))",
          "package": "synthesizer",
          "partial": "Volume",
          "signature": "T v y-\u003eT s u t(R s v y yv-\u003eR s v y yv-\u003eR s v y(yv,yv))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-RateAmplitude-Cut.html#v:zipVolume"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Distort the signal using a flat function.\nThe first signal gives the scaling of the function.\nIf the scaling is c and the input sample is y,\nthen \u003ctt\u003ec * f(y/c)\u003c/tt\u003e is output.\nThis way we can use an (efficient) flat function\nand have a simple, yet dimension conform, way of controlling the distortion.\nE.g. if the distortion function is \u003ctt\u003etanh\u003c/tt\u003e\nthen the value \u003ctt\u003ec\u003c/tt\u003e controls the saturation level.\n",
          "module": "Synthesizer.Dimensional.RateAmplitude.Displacement",
          "name": "distort",
          "package": "synthesizer",
          "signature": "(yv -\u003e yv) -\u003e T s u t (R s v y y -\u003e R s v y yv -\u003e R s v y yv)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-RateAmplitude-Displacement.html#distort",
          "type": "function"
        },
        "index": {
          "description": "Distort the signal using flat function The first signal gives the scaling of the function If the scaling is and the input sample is then is output This way we can use an efficient flat function and have simple yet dimension conform way of controlling the distortion E.g if the distortion function is tanh then the value controls the saturation level",
          "hierarchy": "Synthesizer Dimensional RateAmplitude Displacement",
          "module": "Synthesizer.Dimensional.RateAmplitude.Displacement",
          "name": "distort",
          "normalized": "(a-\u003ea)-\u003eT b c d(R b e f f-\u003eR b e f a-\u003eR b e f a)",
          "package": "synthesizer",
          "signature": "(yv-\u003eyv)-\u003eT s u t(R s v y y-\u003eR s v y yv-\u003eR s v y yv)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-RateAmplitude-Displacement.html#v:distort"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Mix two signals.\n    In opposition to \u003ctt\u003e\u003ca\u003ezipWith\u003c/a\u003e\u003c/tt\u003e the result has the length of the longer signal. \n",
          "module": "Synthesizer.Dimensional.RateAmplitude.Displacement",
          "name": "mix",
          "package": "synthesizer",
          "signature": "T s u t (R s v y yv -\u003e R s v y yv -\u003e R s v y yv)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-RateAmplitude-Displacement.html#mix",
          "type": "function"
        },
        "index": {
          "description": "Mix two signals In opposition to zipWith the result has the length of the longer signal",
          "hierarchy": "Synthesizer Dimensional RateAmplitude Displacement",
          "module": "Synthesizer.Dimensional.RateAmplitude.Displacement",
          "name": "mix",
          "normalized": "T a b c(R a d e f-\u003eR a d e f-\u003eR a d e f)",
          "package": "synthesizer",
          "signature": "T s u t(R s v y yv-\u003eR s v y yv-\u003eR s v y yv)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-RateAmplitude-Displacement.html#v:mix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Mix one or more signals.\n",
          "module": "Synthesizer.Dimensional.RateAmplitude.Displacement",
          "name": "mixMulti",
          "package": "synthesizer",
          "signature": "T s u t ([R s v y yv] -\u003e R s v y yv)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-RateAmplitude-Displacement.html#mixMulti",
          "type": "function"
        },
        "index": {
          "description": "Mix one or more signals",
          "hierarchy": "Synthesizer Dimensional RateAmplitude Displacement",
          "module": "Synthesizer.Dimensional.RateAmplitude.Displacement",
          "name": "mixMulti",
          "normalized": "T a b c([R a d e f]-\u003eR a d e f)",
          "package": "synthesizer",
          "partial": "Multi",
          "signature": "T s u t([R s v y yv]-\u003eR s v y yv)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-RateAmplitude-Displacement.html#v:mixMulti"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.RateAmplitude.Displacement",
          "name": "mixMultiVolume",
          "package": "synthesizer",
          "signature": "T v y -\u003e T s u t ([R s v y yv] -\u003e R s v y yv)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-RateAmplitude-Displacement.html#mixMultiVolume",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional RateAmplitude Displacement",
          "module": "Synthesizer.Dimensional.RateAmplitude.Displacement",
          "name": "mixMultiVolume",
          "normalized": "T a b-\u003eT c d e([R c a b f]-\u003eR c a b f)",
          "package": "synthesizer",
          "partial": "Multi Volume",
          "signature": "T v y-\u003eT s u t([R s v y yv]-\u003eR s v y yv)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-RateAmplitude-Displacement.html#v:mixMultiVolume"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.RateAmplitude.Displacement",
          "name": "mixVolume",
          "package": "synthesizer",
          "signature": "T v y -\u003e T s u t (R s v y yv -\u003e R s v y yv -\u003e R s v y yv)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-RateAmplitude-Displacement.html#mixVolume",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional RateAmplitude Displacement",
          "module": "Synthesizer.Dimensional.RateAmplitude.Displacement",
          "name": "mixVolume",
          "normalized": "T a b-\u003eT c d e(R c a b f-\u003eR c a b f-\u003eR c a b f)",
          "package": "synthesizer",
          "partial": "Volume",
          "signature": "T v y-\u003eT s u t(R s v y yv-\u003eR s v y yv-\u003eR s v y yv)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-RateAmplitude-Displacement.html#v:mixVolume"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Add a number to all of the signal values.\nThis is useful for adjusting the center of a modulation.\n",
          "module": "Synthesizer.Dimensional.RateAmplitude.Displacement",
          "name": "raise",
          "package": "synthesizer",
          "signature": "T v y -\u003e yv -\u003e T s u t (R s v y yv -\u003e R s v y yv)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-RateAmplitude-Displacement.html#raise",
          "type": "function"
        },
        "index": {
          "description": "Add number to all of the signal values This is useful for adjusting the center of modulation",
          "hierarchy": "Synthesizer Dimensional RateAmplitude Displacement",
          "module": "Synthesizer.Dimensional.RateAmplitude.Displacement",
          "name": "raise",
          "normalized": "T a b-\u003ec-\u003eT d e f(R d a b c-\u003eR d a b c)",
          "package": "synthesizer",
          "signature": "T v y-\u003eyv-\u003eT s u t(R s v y yv-\u003eR s v y yv)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-RateAmplitude-Displacement.html#v:raise"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.RateAmplitude.File",
          "name": "renderTimeVoltageMonoDoubleToInt16",
          "package": "synthesizer",
          "signature": "T Frequency Double -\u003e FilePath -\u003e (forall s.  T s Time Double (R s Voltage Double Double)) -\u003e IO ExitCode",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-RateAmplitude-File.html#renderTimeVoltageMonoDoubleToInt16",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional RateAmplitude File",
          "module": "Synthesizer.Dimensional.RateAmplitude.File",
          "name": "renderTimeVoltageMonoDoubleToInt16",
          "normalized": "T Frequency Double-\u003eFilePath-\u003e(a b T c Time Double(R c Voltage Double Double))-\u003eIO ExitCode",
          "package": "synthesizer",
          "partial": "Time Voltage Mono Double To Int",
          "signature": "T Frequency Double-\u003eFilePath-\u003e(forall s. T s Time Double(R s Voltage Double Double))-\u003eIO ExitCode",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-RateAmplitude-File.html#v:renderTimeVoltageMonoDoubleToInt16"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.RateAmplitude.File",
          "name": "renderTimeVoltageStereoDoubleToInt16",
          "package": "synthesizer",
          "signature": "T Frequency Double -\u003e FilePath -\u003e (forall s.  T s Time Double (R s Voltage Double (T Double))) -\u003e IO ExitCode",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-RateAmplitude-File.html#renderTimeVoltageStereoDoubleToInt16",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional RateAmplitude File",
          "module": "Synthesizer.Dimensional.RateAmplitude.File",
          "name": "renderTimeVoltageStereoDoubleToInt16",
          "normalized": "T Frequency Double-\u003eFilePath-\u003e(a b T c Time Double(R c Voltage Double(T Double)))-\u003eIO ExitCode",
          "package": "synthesizer",
          "partial": "Time Voltage Stereo Double To Int",
          "signature": "T Frequency Double-\u003eFilePath-\u003e(forall s. T s Time Double(R s Voltage Double(T Double)))-\u003eIO ExitCode",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-RateAmplitude-File.html#v:renderTimeVoltageStereoDoubleToInt16"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe output format is determined by SoX by the file name extension.\nThe sample precision is determined by the provided \u003ctt\u003e\u003ca\u003eBuilder\u003c/a\u003e\u003c/tt\u003e function.\n\u003c/p\u003e\u003cp\u003eExample:\n\u003c/p\u003e\u003cpre\u003e import qualified Data.StorableVector.Lazy.Builder as Builder\n\n write (DN.frequency one) (DN.voltage one) (\\i -\u003e Builder.put (i::Int16)) \"test.aiff\" sound\n\u003c/pre\u003e",
          "module": "Synthesizer.Dimensional.RateAmplitude.File",
          "name": "write",
          "package": "synthesizer",
          "signature": "T (Recip u) t -\u003e T v y -\u003e (int -\u003e Builder int) -\u003e FilePath -\u003e T u t (S v y) yv -\u003e IO ExitCode",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-RateAmplitude-File.html#write",
          "type": "function"
        },
        "index": {
          "description": "The output format is determined by SoX by the file name extension The sample precision is determined by the provided Builder function Example import qualified Data.StorableVector.Lazy.Builder as Builder write DN.frequency one DN.voltage one Builder.put Int16 test.aiff sound",
          "hierarchy": "Synthesizer Dimensional RateAmplitude File",
          "module": "Synthesizer.Dimensional.RateAmplitude.File",
          "name": "write",
          "normalized": "T(Recip a)b-\u003eT c d-\u003e(e-\u003eBuilder e)-\u003eFilePath-\u003eT a b(S c d)f-\u003eIO ExitCode",
          "package": "synthesizer",
          "signature": "T(Recip u)t-\u003eT v y-\u003e(int-\u003eBuilder int)-\u003eFilePath-\u003eT u t(S v y)yv-\u003eIO ExitCode",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-RateAmplitude-File.html#v:write"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.RateAmplitude.File",
          "name": "writeTimeVoltage",
          "package": "synthesizer",
          "signature": "(int -\u003e Builder int) -\u003e FilePath -\u003e T Time t (S Voltage y) yv -\u003e IO ExitCode",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-RateAmplitude-File.html#writeTimeVoltage",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional RateAmplitude File",
          "module": "Synthesizer.Dimensional.RateAmplitude.File",
          "name": "writeTimeVoltage",
          "normalized": "(a-\u003eBuilder a)-\u003eFilePath-\u003eT Time b(S Voltage c)d-\u003eIO ExitCode",
          "package": "synthesizer",
          "partial": "Time Voltage",
          "signature": "(int-\u003eBuilder int)-\u003eFilePath-\u003eT Time t(S Voltage y)yv-\u003eIO ExitCode",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-RateAmplitude-File.html#v:writeTimeVoltage"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.RateAmplitude.File",
          "name": "writeTimeVoltageMonoDoubleToInt16",
          "package": "synthesizer",
          "signature": "FilePath -\u003e T Time Double (S Voltage Double) Double -\u003e IO ExitCode",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-RateAmplitude-File.html#writeTimeVoltageMonoDoubleToInt16",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional RateAmplitude File",
          "module": "Synthesizer.Dimensional.RateAmplitude.File",
          "name": "writeTimeVoltageMonoDoubleToInt16",
          "normalized": "FilePath-\u003eT Time Double(S Voltage Double)Double-\u003eIO ExitCode",
          "package": "synthesizer",
          "partial": "Time Voltage Mono Double To Int",
          "signature": "FilePath-\u003eT Time Double(S Voltage Double)Double-\u003eIO ExitCode",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-RateAmplitude-File.html#v:writeTimeVoltageMonoDoubleToInt16"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.RateAmplitude.File",
          "name": "writeTimeVoltageStereoDoubleToInt16",
          "package": "synthesizer",
          "signature": "FilePath -\u003e T Time Double (S Voltage Double) (T Double) -\u003e IO ExitCode",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-RateAmplitude-File.html#writeTimeVoltageStereoDoubleToInt16",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional RateAmplitude File",
          "module": "Synthesizer.Dimensional.RateAmplitude.File",
          "name": "writeTimeVoltageStereoDoubleToInt16",
          "normalized": "FilePath-\u003eT Time Double(S Voltage Double)(T Double)-\u003eIO ExitCode",
          "package": "synthesizer",
          "partial": "Time Voltage Stereo Double To Int",
          "signature": "FilePath-\u003eT Time Double(S Voltage Double)(T Double)-\u003eIO ExitCode",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-RateAmplitude-File.html#v:writeTimeVoltageStereoDoubleToInt16"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "order, number of filters in the cascade \nthe phase shift to be achieved for the given frequency \n",
          "module": "Synthesizer.Dimensional.RateAmplitude.Filter",
          "name": "allpassCascade",
          "package": "synthesizer",
          "signature": "Int-\u003e q-\u003e FrequencyFilter s u q r (Parameter q) v yv yv",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-RateAmplitude-Filter.html#allpassCascade",
          "type": "function"
        },
        "index": {
          "description": "order number of filters in the cascade the phase shift to be achieved for the given frequency",
          "hierarchy": "Synthesizer Dimensional RateAmplitude Filter",
          "module": "Synthesizer.Dimensional.RateAmplitude.Filter",
          "name": "allpassCascade",
          "normalized": "Int-\u003ea-\u003eFrequencyFilter b c a d(Parameter a)e f f",
          "package": "synthesizer",
          "partial": "Cascade",
          "signature": "Int-\u003eq-\u003eFrequencyFilter s u q r(Parameter q)v yv yv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-RateAmplitude-Filter.html#v:allpassCascade"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "The amplification factor must be positive. \n",
          "module": "Synthesizer.Dimensional.RateAmplitude.Filter",
          "name": "amplify",
          "package": "synthesizer",
          "signature": "y -\u003e T s u t (R s v y yv -\u003e R s v y yv)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-RateAmplitude-Filter.html#amplify",
          "type": "function"
        },
        "index": {
          "description": "The amplification factor must be positive",
          "hierarchy": "Synthesizer Dimensional RateAmplitude Filter",
          "module": "Synthesizer.Dimensional.RateAmplitude.Filter",
          "name": "amplify",
          "normalized": "a-\u003eT b c d(R b e a f-\u003eR b e a f)",
          "package": "synthesizer",
          "signature": "y-\u003eT s u t(R s v y yv-\u003eR s v y yv)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-RateAmplitude-Filter.html#v:amplify"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.RateAmplitude.Filter",
          "name": "amplifyDimension",
          "package": "synthesizer",
          "signature": "T v0 y -\u003e T s u t (R s v1 y yv -\u003e R s (Mul v0 v1) y yv)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-RateAmplitude-Filter.html#amplifyDimension",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional RateAmplitude Filter",
          "module": "Synthesizer.Dimensional.RateAmplitude.Filter",
          "name": "amplifyDimension",
          "normalized": "T a b-\u003eT c d e(R c a b f-\u003eR c(Mul a a)b f)",
          "package": "synthesizer",
          "partial": "Dimension",
          "signature": "T v y-\u003eT s u t(R s v y yv-\u003eR s(Mul v v)y yv)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-RateAmplitude-Filter.html#v:amplifyDimension"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Order of the filter, must be even,\n                        the higher the order, the sharper is the separation of frequencies. \n",
          "module": "Synthesizer.Dimensional.RateAmplitude.Filter",
          "name": "butterworthHighpass",
          "package": "synthesizer",
          "signature": "Int-\u003e ResonantFilter s u q r flat (Pole q) v yv yv",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-RateAmplitude-Filter.html#butterworthHighpass",
          "type": "function"
        },
        "index": {
          "description": "Order of the filter must be even the higher the order the sharper is the separation of frequencies",
          "hierarchy": "Synthesizer Dimensional RateAmplitude Filter",
          "module": "Synthesizer.Dimensional.RateAmplitude.Filter",
          "name": "butterworthHighpass",
          "normalized": "Int-\u003eResonantFilter a b c d e(Pole c)f g g",
          "package": "synthesizer",
          "partial": "Highpass",
          "signature": "Int-\u003eResonantFilter s u q r flat(Pole q)v yv yv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-RateAmplitude-Filter.html#v:butterworthHighpass"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Order of the filter, must be even,\n                        the higher the order, the sharper is the separation of frequencies. \n",
          "module": "Synthesizer.Dimensional.RateAmplitude.Filter",
          "name": "butterworthLowpass",
          "package": "synthesizer",
          "signature": "Int-\u003e ResonantFilter s u q r flat (Pole q) v yv yv",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-RateAmplitude-Filter.html#butterworthLowpass",
          "type": "function"
        },
        "index": {
          "description": "Order of the filter must be even the higher the order the sharper is the separation of frequencies",
          "hierarchy": "Synthesizer Dimensional RateAmplitude Filter",
          "module": "Synthesizer.Dimensional.RateAmplitude.Filter",
          "name": "butterworthLowpass",
          "normalized": "Int-\u003eResonantFilter a b c d e(Pole c)f g g",
          "package": "synthesizer",
          "partial": "Lowpass",
          "signature": "Int-\u003eResonantFilter s u q r flat(Pole q)v yv yv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-RateAmplitude-Filter.html#v:butterworthLowpass"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Order of the filter, must be even,\n                        the higher the order, the sharper is the separation of frequencies. \n",
          "module": "Synthesizer.Dimensional.RateAmplitude.Filter",
          "name": "chebyshevAHighpass",
          "package": "synthesizer",
          "signature": "Int-\u003e ResonantFilter s u q r flat (Pole q) v yv yv",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-RateAmplitude-Filter.html#chebyshevAHighpass",
          "type": "function"
        },
        "index": {
          "description": "Order of the filter must be even the higher the order the sharper is the separation of frequencies",
          "hierarchy": "Synthesizer Dimensional RateAmplitude Filter",
          "module": "Synthesizer.Dimensional.RateAmplitude.Filter",
          "name": "chebyshevAHighpass",
          "normalized": "Int-\u003eResonantFilter a b c d e(Pole c)f g g",
          "package": "synthesizer",
          "partial": "AHighpass",
          "signature": "Int-\u003eResonantFilter s u q r flat(Pole q)v yv yv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-RateAmplitude-Filter.html#v:chebyshevAHighpass"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Order of the filter, must be even,\n                        the higher the order, the sharper is the separation of frequencies. \n",
          "module": "Synthesizer.Dimensional.RateAmplitude.Filter",
          "name": "chebyshevALowpass",
          "package": "synthesizer",
          "signature": "Int-\u003e ResonantFilter s u q r flat (Pole q) v yv yv",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-RateAmplitude-Filter.html#chebyshevALowpass",
          "type": "function"
        },
        "index": {
          "description": "Order of the filter must be even the higher the order the sharper is the separation of frequencies",
          "hierarchy": "Synthesizer Dimensional RateAmplitude Filter",
          "module": "Synthesizer.Dimensional.RateAmplitude.Filter",
          "name": "chebyshevALowpass",
          "normalized": "Int-\u003eResonantFilter a b c d e(Pole c)f g g",
          "package": "synthesizer",
          "partial": "ALowpass",
          "signature": "Int-\u003eResonantFilter s u q r flat(Pole q)v yv yv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-RateAmplitude-Filter.html#v:chebyshevALowpass"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Order of the filter, must be even,\n                        the higher the order, the sharper is the separation of frequencies. \n",
          "module": "Synthesizer.Dimensional.RateAmplitude.Filter",
          "name": "chebyshevBHighpass",
          "package": "synthesizer",
          "signature": "Int-\u003e ResonantFilter s u q r flat (Pole q) v yv yv",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-RateAmplitude-Filter.html#chebyshevBHighpass",
          "type": "function"
        },
        "index": {
          "description": "Order of the filter must be even the higher the order the sharper is the separation of frequencies",
          "hierarchy": "Synthesizer Dimensional RateAmplitude Filter",
          "module": "Synthesizer.Dimensional.RateAmplitude.Filter",
          "name": "chebyshevBHighpass",
          "normalized": "Int-\u003eResonantFilter a b c d e(Pole c)f g g",
          "package": "synthesizer",
          "partial": "BHighpass",
          "signature": "Int-\u003eResonantFilter s u q r flat(Pole q)v yv yv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-RateAmplitude-Filter.html#v:chebyshevBHighpass"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Order of the filter, must be even,\n                        the higher the order, the sharper is the separation of frequencies. \n",
          "module": "Synthesizer.Dimensional.RateAmplitude.Filter",
          "name": "chebyshevBLowpass",
          "package": "synthesizer",
          "signature": "Int-\u003e ResonantFilter s u q r flat (Pole q) v yv yv",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-RateAmplitude-Filter.html#chebyshevBLowpass",
          "type": "function"
        },
        "index": {
          "description": "Order of the filter must be even the higher the order the sharper is the separation of frequencies",
          "hierarchy": "Synthesizer Dimensional RateAmplitude Filter",
          "module": "Synthesizer.Dimensional.RateAmplitude.Filter",
          "name": "chebyshevBLowpass",
          "normalized": "Int-\u003eResonantFilter a b c d e(Pole c)f g g",
          "package": "synthesizer",
          "partial": "BLowpass",
          "signature": "Int-\u003eResonantFilter s u q r flat(Pole q)v yv yv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-RateAmplitude-Filter.html#v:chebyshevBLowpass"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Infinitely many equi-delayed exponentially decaying echos. \n",
          "module": "Synthesizer.Dimensional.RateAmplitude.Filter",
          "name": "comb",
          "package": "synthesizer",
          "signature": "T u t -\u003e y -\u003e T s u t (R s v y yv -\u003e R s v y yv)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-RateAmplitude-Filter.html#comb",
          "type": "function"
        },
        "index": {
          "description": "Infinitely many equi-delayed exponentially decaying echos",
          "hierarchy": "Synthesizer Dimensional RateAmplitude Filter",
          "module": "Synthesizer.Dimensional.RateAmplitude.Filter",
          "name": "comb",
          "normalized": "T a b-\u003ec-\u003eT d a b(R d e c f-\u003eR d e c f)",
          "package": "synthesizer",
          "signature": "T u t-\u003ey-\u003eT s u t(R s v y yv-\u003eR s v y yv)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-RateAmplitude-Filter.html#v:comb"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Infinitely many equi-delayed echos processed by an arbitrary time-preserving signal processor. \n",
          "module": "Synthesizer.Dimensional.RateAmplitude.Filter",
          "name": "combProc",
          "package": "synthesizer",
          "signature": "T u t -\u003e T s u t (R s v y yv -\u003e R s v y yv) -\u003e T s u t (R s v y yv -\u003e R s v y yv)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-RateAmplitude-Filter.html#combProc",
          "type": "function"
        },
        "index": {
          "description": "Infinitely many equi-delayed echos processed by an arbitrary time-preserving signal processor",
          "hierarchy": "Synthesizer Dimensional RateAmplitude Filter",
          "module": "Synthesizer.Dimensional.RateAmplitude.Filter",
          "name": "combProc",
          "normalized": "T a b-\u003eT c a b(R c d e f-\u003eR c d e f)-\u003eT c a b(R c d e f-\u003eR c d e f)",
          "package": "synthesizer",
          "partial": "Proc",
          "signature": "T u t-\u003eT s u t(R s v y yv-\u003eR s v y yv)-\u003eT s u t(R s v y yv-\u003eR s v y yv)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-RateAmplitude-Filter.html#v:combProc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.RateAmplitude.Filter",
          "name": "delay",
          "package": "synthesizer",
          "signature": "T u t -\u003e T s u t (R s v y yv -\u003e R s v y yv)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-RateAmplitude-Filter.html#delay",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional RateAmplitude Filter",
          "module": "Synthesizer.Dimensional.RateAmplitude.Filter",
          "name": "delay",
          "normalized": "T a b-\u003eT c a b(R c d e f-\u003eR c d e f)",
          "package": "synthesizer",
          "signature": "T u t-\u003eT s u t(R s v y yv-\u003eR s v y yv)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-RateAmplitude-Filter.html#v:delay"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.RateAmplitude.Filter",
          "name": "differentiate",
          "package": "synthesizer",
          "signature": "T s u q (R s v q yv -\u003e R s (DimensionGradient u v) q yv)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-RateAmplitude-Filter.html#differentiate",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional RateAmplitude Filter",
          "module": "Synthesizer.Dimensional.RateAmplitude.Filter",
          "name": "differentiate",
          "normalized": "T a b c(R a d c e-\u003eR a(DimensionGradient b d)c e)",
          "package": "synthesizer",
          "signature": "T s u q(R s v q yv-\u003eR s(DimensionGradient u v)q yv)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-RateAmplitude-Filter.html#v:differentiate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.RateAmplitude.Filter",
          "name": "envelope",
          "package": "synthesizer",
          "signature": "T s u t (T s flat y0 -\u003e R s v y y0 -\u003e R s v y y0)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-RateAmplitude-Filter.html#envelope",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional RateAmplitude Filter",
          "module": "Synthesizer.Dimensional.RateAmplitude.Filter",
          "name": "envelope",
          "normalized": "T a b c(T a d e-\u003eR a f e e-\u003eR a f e e)",
          "package": "synthesizer",
          "signature": "T s u t(T s flat y-\u003eR s v y y-\u003eR s v y y)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-RateAmplitude-Filter.html#v:envelope"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.RateAmplitude.Filter",
          "name": "envelopeVector",
          "package": "synthesizer",
          "signature": "T s u t (T s flat y0 -\u003e R s v y yv -\u003e R s v y yv)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-RateAmplitude-Filter.html#envelopeVector",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional RateAmplitude Filter",
          "module": "Synthesizer.Dimensional.RateAmplitude.Filter",
          "name": "envelopeVector",
          "normalized": "T a b c(T a d e-\u003eR a f e g-\u003eR a f e g)",
          "package": "synthesizer",
          "partial": "Vector",
          "signature": "T s u t(T s flat y-\u003eR s v y yv-\u003eR s v y yv)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-RateAmplitude-Filter.html#v:envelopeVector"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.RateAmplitude.Filter",
          "name": "envelopeVectorDimension",
          "package": "synthesizer",
          "signature": "T s u t (R s v0 y y0 -\u003e R s v1 y yv -\u003e R s (Mul v0 v1) y yv)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-RateAmplitude-Filter.html#envelopeVectorDimension",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional RateAmplitude Filter",
          "module": "Synthesizer.Dimensional.RateAmplitude.Filter",
          "name": "envelopeVectorDimension",
          "normalized": "T a b c(R a d e e-\u003eR a d e f-\u003eR a(Mul d d)e f)",
          "package": "synthesizer",
          "partial": "Vector Dimension",
          "signature": "T s u t(R s v y y-\u003eR s v y yv-\u003eR s(Mul v v)y yv)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-RateAmplitude-Filter.html#v:envelopeVectorDimension"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.RateAmplitude.Filter",
          "name": "firstOrderHighpass",
          "package": "synthesizer",
          "signature": "FrequencyFilter s u q r (Parameter q) v yv yv",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-RateAmplitude-Filter.html#firstOrderHighpass",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional RateAmplitude Filter",
          "module": "Synthesizer.Dimensional.RateAmplitude.Filter",
          "name": "firstOrderHighpass",
          "package": "synthesizer",
          "partial": "Order Highpass",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-RateAmplitude-Filter.html#v:firstOrderHighpass"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.RateAmplitude.Filter",
          "name": "firstOrderLowpass",
          "package": "synthesizer",
          "signature": "FrequencyFilter s u q r (Parameter q) v yv yv",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-RateAmplitude-Filter.html#firstOrderLowpass",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional RateAmplitude Filter",
          "module": "Synthesizer.Dimensional.RateAmplitude.Filter",
          "name": "firstOrderLowpass",
          "package": "synthesizer",
          "partial": "Order Lowpass",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-RateAmplitude-Filter.html#v:firstOrderLowpass"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.RateAmplitude.Filter",
          "name": "frequencyModulation",
          "package": "synthesizer",
          "signature": "T q yv -\u003e T s u q (T s flat q -\u003e R s v q yv -\u003e R s v q yv)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-RateAmplitude-Filter.html#frequencyModulation",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional RateAmplitude Filter",
          "module": "Synthesizer.Dimensional.RateAmplitude.Filter",
          "name": "frequencyModulation",
          "normalized": "T a b-\u003eT c d a(T c e a-\u003eR c f a b-\u003eR c f a b)",
          "package": "synthesizer",
          "partial": "Modulation",
          "signature": "T q yv-\u003eT s u q(T s flat q-\u003eR s v q yv-\u003eR s v q yv)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-RateAmplitude-Filter.html#v:frequencyModulation"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFrequency modulation where the input signal can have a sample rate\ndifferent from the output.\n(The sample rate values can differ, the unit must be the same.\nWe could lift that restriction,\nbut then the unit handling becomes more complicated,\nand I didn't have a use for it so far.)\n\u003c/p\u003e\u003cp\u003eThe function can be used for resampling.\n\u003c/p\u003e",
          "module": "Synthesizer.Dimensional.RateAmplitude.Filter",
          "name": "frequencyModulationDecoupled",
          "package": "synthesizer",
          "signature": "T q yv -\u003e T s u q (T s flat q -\u003e T u q (D v q S) yv -\u003e R s v q yv)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-RateAmplitude-Filter.html#frequencyModulationDecoupled",
          "type": "function"
        },
        "index": {
          "description": "Frequency modulation where the input signal can have sample rate different from the output The sample rate values can differ the unit must be the same We could lift that restriction but then the unit handling becomes more complicated and didn have use for it so far The function can be used for resampling",
          "hierarchy": "Synthesizer Dimensional RateAmplitude Filter",
          "module": "Synthesizer.Dimensional.RateAmplitude.Filter",
          "name": "frequencyModulationDecoupled",
          "normalized": "T a b-\u003eT c d a(T c e a-\u003eT d a(D f a S)b-\u003eR c f a b)",
          "package": "synthesizer",
          "partial": "Modulation Decoupled",
          "signature": "T q yv-\u003eT s u q(T s flat q-\u003eT u q(D v q S)yv-\u003eR s v q yv)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-RateAmplitude-Filter.html#v:frequencyModulationDecoupled"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.RateAmplitude.Filter",
          "name": "integrate",
          "package": "synthesizer",
          "signature": "T s u q (R s v q yv -\u003e R s (Mul u v) q yv)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-RateAmplitude-Filter.html#integrate",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional RateAmplitude Filter",
          "module": "Synthesizer.Dimensional.RateAmplitude.Filter",
          "name": "integrate",
          "normalized": "T a b c(R a d c e-\u003eR a(Mul b d)c e)",
          "package": "synthesizer",
          "signature": "T s u q(R s v q yv-\u003eR s(Mul u v)q yv)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-RateAmplitude-Filter.html#v:integrate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "minimum cut-off freqeuncy \n",
          "module": "Synthesizer.Dimensional.RateAmplitude.Filter",
          "name": "mean",
          "package": "synthesizer",
          "signature": "T (Recip u) q-\u003e T s u q (R s (Recip u) q q -\u003e R s v q yv -\u003e R s v q yv)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-RateAmplitude-Filter.html#mean",
          "type": "function"
        },
        "index": {
          "description": "minimum cut-off freqeuncy",
          "hierarchy": "Synthesizer Dimensional RateAmplitude Filter",
          "module": "Synthesizer.Dimensional.RateAmplitude.Filter",
          "name": "mean",
          "normalized": "T(Recip a)b-\u003eT c a b(R c(Recip a)b b-\u003eR c d b e-\u003eR c d b e)",
          "package": "synthesizer",
          "signature": "T(Recip u)q-\u003eT s u q(R s(Recip u)q q-\u003eR s v q yv-\u003eR s v q yv)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-RateAmplitude-Filter.html#v:mean"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "cut-off freqeuncy \n",
          "module": "Synthesizer.Dimensional.RateAmplitude.Filter",
          "name": "meanStatic",
          "package": "synthesizer",
          "signature": "T (Recip u) q-\u003e T s u q (R s v q yv -\u003e R s v q yv)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-RateAmplitude-Filter.html#meanStatic",
          "type": "function"
        },
        "index": {
          "description": "cut-off freqeuncy",
          "hierarchy": "Synthesizer Dimensional RateAmplitude Filter",
          "module": "Synthesizer.Dimensional.RateAmplitude.Filter",
          "name": "meanStatic",
          "normalized": "T(Recip a)b-\u003eT c a b(R c d b e-\u003eR c d b e)",
          "package": "synthesizer",
          "partial": "Static",
          "signature": "T(Recip u)q-\u003eT s u q(R s v q yv-\u003eR s v q yv)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-RateAmplitude-Filter.html#v:meanStatic"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.RateAmplitude.Filter",
          "name": "moogLowpass",
          "package": "synthesizer",
          "signature": "Int -\u003e ResonantFilter s u q r flat (Parameter q) v yv yv",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-RateAmplitude-Filter.html#moogLowpass",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional RateAmplitude Filter",
          "module": "Synthesizer.Dimensional.RateAmplitude.Filter",
          "name": "moogLowpass",
          "normalized": "Int-\u003eResonantFilter a b c d e(Parameter c)f g g",
          "package": "synthesizer",
          "partial": "Lowpass",
          "signature": "Int-\u003eResonantFilter s u q r flat(Parameter q)v yv yv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-RateAmplitude-Filter.html#v:moogLowpass"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.RateAmplitude.Filter",
          "name": "negate",
          "package": "synthesizer",
          "signature": "T s u t (R s v y yv -\u003e R s v y yv)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-RateAmplitude-Filter.html#negate",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional RateAmplitude Filter",
          "module": "Synthesizer.Dimensional.RateAmplitude.Filter",
          "name": "negate",
          "normalized": "T a b c(R a d e f-\u003eR a d e f)",
          "package": "synthesizer",
          "signature": "T s u t(R s v y yv-\u003eR s v y yv)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-RateAmplitude-Filter.html#v:negate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "minDelay, minimal delay, may be negative \nmaxDelay, maximal delay, it must be \u003ctt\u003eminDelay \u003c= maxDelay\u003c/tt\u003e\n               and the modulation must always be\n               in the range [minDelay,maxDelay]. \n",
          "module": "Synthesizer.Dimensional.RateAmplitude.Filter",
          "name": "phaseModulation",
          "package": "synthesizer",
          "signature": "T q yv-\u003e T u q-\u003e T u q-\u003e T s u q (R s u q q -\u003e R s v q yv -\u003e R s v q yv)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-RateAmplitude-Filter.html#phaseModulation",
          "type": "function"
        },
        "index": {
          "description": "minDelay minimal delay may be negative maxDelay maximal delay it must be minDelay maxDelay and the modulation must always be in the range minDelay maxDelay",
          "hierarchy": "Synthesizer Dimensional RateAmplitude Filter",
          "module": "Synthesizer.Dimensional.RateAmplitude.Filter",
          "name": "phaseModulation",
          "normalized": "T a b-\u003eT c a-\u003eT c a-\u003eT d c a(R d c a a-\u003eR d e a b-\u003eR d e a b)",
          "package": "synthesizer",
          "partial": "Modulation",
          "signature": "T q yv-\u003eT u q-\u003eT u q-\u003eT s u q(R s u q q-\u003eR s v q yv-\u003eR s v q yv)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-RateAmplitude-Filter.html#v:phaseModulation"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "maxDelay, must be positive \n",
          "module": "Synthesizer.Dimensional.RateAmplitude.Filter",
          "name": "phaser",
          "package": "synthesizer",
          "signature": "T q yv-\u003e T u q-\u003e T s u q (R s u q q -\u003e R s v q yv -\u003e R s v q yv)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-RateAmplitude-Filter.html#phaser",
          "type": "function"
        },
        "index": {
          "description": "maxDelay must be positive",
          "hierarchy": "Synthesizer Dimensional RateAmplitude Filter",
          "module": "Synthesizer.Dimensional.RateAmplitude.Filter",
          "name": "phaser",
          "normalized": "T a b-\u003eT c a-\u003eT d c a(R d c a a-\u003eR d e a b-\u003eR d e a b)",
          "package": "synthesizer",
          "signature": "T q yv-\u003eT u q-\u003eT s u q(R s u q q-\u003eR s v q yv-\u003eR s v q yv)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-RateAmplitude-Filter.html#v:phaser"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "maxDelay, must be positive \n",
          "module": "Synthesizer.Dimensional.RateAmplitude.Filter",
          "name": "phaserStereo",
          "package": "synthesizer",
          "signature": "T q yv-\u003e T u q-\u003e T s u q (R s u q q -\u003e R s v q yv -\u003e R s v q (T yv))",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-RateAmplitude-Filter.html#phaserStereo",
          "type": "function"
        },
        "index": {
          "description": "maxDelay must be positive",
          "hierarchy": "Synthesizer Dimensional RateAmplitude Filter",
          "module": "Synthesizer.Dimensional.RateAmplitude.Filter",
          "name": "phaserStereo",
          "normalized": "T a b-\u003eT c a-\u003eT d c a(R d c a a-\u003eR d e a b-\u003eR d e a(T b))",
          "package": "synthesizer",
          "partial": "Stereo",
          "signature": "T q yv-\u003eT u q-\u003eT s u q(R s u q q-\u003eR s v q yv-\u003eR s v q(T yv))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-RateAmplitude-Filter.html#v:phaserStereo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.RateAmplitude.Filter",
          "name": "universal",
          "package": "synthesizer",
          "signature": "ResonantFilter s u q r flat (Parameter q) v yv (Result yv)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-RateAmplitude-Filter.html#universal",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional RateAmplitude Filter",
          "module": "Synthesizer.Dimensional.RateAmplitude.Filter",
          "name": "universal",
          "package": "synthesizer",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-RateAmplitude-Filter.html#v:universal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.RateAmplitude.Instrument",
          "name": "accumulatedSaws",
          "package": "synthesizer",
          "signature": "T Frequency a -\u003e T s Time a (R s Voltage a a)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-RateAmplitude-Instrument.html#accumulatedSaws",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional RateAmplitude Instrument",
          "module": "Synthesizer.Dimensional.RateAmplitude.Instrument",
          "name": "accumulatedSaws",
          "normalized": "T Frequency a-\u003eT b Time a(R b Voltage a a)",
          "package": "synthesizer",
          "partial": "Saws",
          "signature": "T Frequency a-\u003eT s Time a(R s Voltage a a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-RateAmplitude-Instrument.html#v:accumulatedSaws"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.RateAmplitude.Instrument",
          "name": "accumulationParameters",
          "package": "synthesizer",
          "signature": "[(T a, a, T a, T Frequency a)]",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-RateAmplitude-Instrument.html#accumulationParameters",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional RateAmplitude Instrument",
          "module": "Synthesizer.Dimensional.RateAmplitude.Instrument",
          "name": "accumulationParameters",
          "normalized": "[(T a,a,T a,T Frequency a)]",
          "package": "synthesizer",
          "partial": "Parameters",
          "signature": "[(T a,a,T a,T Frequency a)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-RateAmplitude-Instrument.html#v:accumulationParameters"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.RateAmplitude.Instrument",
          "name": "allpassDown",
          "package": "synthesizer",
          "signature": "Int -\u003e T Time a -\u003e T Frequency a -\u003e T Frequency a -\u003e T s Time a (R s Voltage a a)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-RateAmplitude-Instrument.html#allpassDown",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional RateAmplitude Instrument",
          "module": "Synthesizer.Dimensional.RateAmplitude.Instrument",
          "name": "allpassDown",
          "normalized": "Int-\u003eT Time a-\u003eT Frequency a-\u003eT Frequency a-\u003eT b Time a(R b Voltage a a)",
          "package": "synthesizer",
          "partial": "Down",
          "signature": "Int-\u003eT Time a-\u003eT Frequency a-\u003eT Frequency a-\u003eT s Time a(R s Voltage a a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-RateAmplitude-Instrument.html#v:allpassDown"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.RateAmplitude.Instrument",
          "name": "ampVolt",
          "package": "synthesizer",
          "signature": "T s u y (a -\u003e R s y) -\u003e T s u y (a -\u003e R s Voltage y y)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-RateAmplitude-Instrument.html#ampVolt",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional RateAmplitude Instrument",
          "module": "Synthesizer.Dimensional.RateAmplitude.Instrument",
          "name": "ampVolt",
          "normalized": "T a b c(d-\u003eR a c)-\u003eT a b c(d-\u003eR a Voltage c c)",
          "package": "synthesizer",
          "partial": "Volt",
          "signature": "T s u y(a-\u003eR s y)-\u003eT s u y(a-\u003eR s Voltage y y)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-RateAmplitude-Instrument.html#v:ampVolt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.RateAmplitude.Instrument",
          "name": "bassDrum",
          "package": "synthesizer",
          "signature": "T s Time q (R s Voltage q q)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-RateAmplitude-Instrument.html#bassDrum",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional RateAmplitude Instrument",
          "module": "Synthesizer.Dimensional.RateAmplitude.Instrument",
          "name": "bassDrum",
          "package": "synthesizer",
          "partial": "Drum",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-RateAmplitude-Instrument.html#v:bassDrum"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.RateAmplitude.Instrument",
          "name": "bell",
          "package": "synthesizer",
          "signature": "T Frequency a -\u003e T s Time a (R s Voltage a a)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-RateAmplitude-Instrument.html#bell",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional RateAmplitude Instrument",
          "module": "Synthesizer.Dimensional.RateAmplitude.Instrument",
          "name": "bell",
          "normalized": "T Frequency a-\u003eT b Time a(R b Voltage a a)",
          "package": "synthesizer",
          "signature": "T Frequency a-\u003eT s Time a(R s Voltage a a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-RateAmplitude-Instrument.html#v:bell"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.RateAmplitude.Instrument",
          "name": "bellHarmonic",
          "package": "synthesizer",
          "signature": "a -\u003e T Time a -\u003e T Frequency a -\u003e T s Time a (R s Voltage a a)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-RateAmplitude-Instrument.html#bellHarmonic",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional RateAmplitude Instrument",
          "module": "Synthesizer.Dimensional.RateAmplitude.Instrument",
          "name": "bellHarmonic",
          "normalized": "a-\u003eT Time a-\u003eT Frequency a-\u003eT b Time a(R b Voltage a a)",
          "package": "synthesizer",
          "partial": "Harmonic",
          "signature": "a-\u003eT Time a-\u003eT Frequency a-\u003eT s Time a(R s Voltage a a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-RateAmplitude-Instrument.html#v:bellHarmonic"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.RateAmplitude.Instrument",
          "name": "brass",
          "package": "synthesizer",
          "signature": "T Frequency a -\u003e T s Time a (R s Voltage a a)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-RateAmplitude-Instrument.html#brass",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional RateAmplitude Instrument",
          "module": "Synthesizer.Dimensional.RateAmplitude.Instrument",
          "name": "brass",
          "normalized": "T Frequency a-\u003eT b Time a(R b Voltage a a)",
          "package": "synthesizer",
          "signature": "T Frequency a-\u003eT s Time a(R s Voltage a a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-RateAmplitude-Instrument.html#v:brass"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.RateAmplitude.Instrument",
          "name": "choir",
          "package": "synthesizer",
          "signature": "T Frequency a -\u003e T s Time a (R s Voltage a a)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-RateAmplitude-Instrument.html#choir",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional RateAmplitude Instrument",
          "module": "Synthesizer.Dimensional.RateAmplitude.Instrument",
          "name": "choir",
          "normalized": "T Frequency a-\u003eT b Time a(R b Voltage a a)",
          "package": "synthesizer",
          "signature": "T Frequency a-\u003eT s Time a(R s Voltage a a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-RateAmplitude-Instrument.html#v:choir"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Drum sound using the Karplus-Strong-Algorithm\nThis is a Noise.white enveloped by an exponential2\nwhich is piped through the Karplus-Strong machine\nfor generating some frequency.\nThe whole thing is then frequency modulated\nto give a falling frequency.\n",
          "module": "Synthesizer.Dimensional.RateAmplitude.Instrument",
          "name": "electroTom",
          "package": "synthesizer",
          "signature": "T s Time a (R s Voltage a a)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-RateAmplitude-Instrument.html#electroTom",
          "type": "function"
        },
        "index": {
          "description": "Drum sound using the Karplus-Strong-Algorithm This is Noise.white enveloped by an exponential2 which is piped through the Karplus-Strong machine for generating some frequency The whole thing is then frequency modulated to give falling frequency",
          "hierarchy": "Synthesizer Dimensional RateAmplitude Instrument",
          "module": "Synthesizer.Dimensional.RateAmplitude.Instrument",
          "name": "electroTom",
          "package": "synthesizer",
          "partial": "Tom",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-RateAmplitude-Instrument.html#v:electroTom"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.RateAmplitude.Instrument",
          "name": "fastBell",
          "package": "synthesizer",
          "signature": "T Frequency a -\u003e T s Time a (R s Voltage a a)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-RateAmplitude-Instrument.html#fastBell",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional RateAmplitude Instrument",
          "module": "Synthesizer.Dimensional.RateAmplitude.Instrument",
          "name": "fastBell",
          "normalized": "T Frequency a-\u003eT b Time a(R b Voltage a a)",
          "package": "synthesizer",
          "partial": "Bell",
          "signature": "T Frequency a-\u003eT s Time a(R s Voltage a a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-RateAmplitude-Instrument.html#v:fastBell"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.RateAmplitude.Instrument",
          "name": "fatPad",
          "package": "synthesizer",
          "signature": "T Frequency a -\u003e T s Time a (R s Voltage a a)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-RateAmplitude-Instrument.html#fatPad",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional RateAmplitude Instrument",
          "module": "Synthesizer.Dimensional.RateAmplitude.Instrument",
          "name": "fatPad",
          "normalized": "T Frequency a-\u003eT b Time a(R b Voltage a a)",
          "package": "synthesizer",
          "partial": "Pad",
          "signature": "T Frequency a-\u003eT s Time a(R s Voltage a a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-RateAmplitude-Instrument.html#v:fatPad"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.RateAmplitude.Instrument",
          "name": "fatSaw",
          "package": "synthesizer",
          "signature": "T Frequency a -\u003e T s Time a (R s Voltage a a)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-RateAmplitude-Instrument.html#fatSaw",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional RateAmplitude Instrument",
          "module": "Synthesizer.Dimensional.RateAmplitude.Instrument",
          "name": "fatSaw",
          "normalized": "T Frequency a-\u003eT b Time a(R b Voltage a a)",
          "package": "synthesizer",
          "partial": "Saw",
          "signature": "T Frequency a-\u003eT s Time a(R s Voltage a a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-RateAmplitude-Instrument.html#v:fatSaw"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.RateAmplitude.Instrument",
          "name": "fatSawChord",
          "package": "synthesizer",
          "signature": "T Frequency a -\u003e T s Time a (R s Voltage a a)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-RateAmplitude-Instrument.html#fatSawChord",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional RateAmplitude Instrument",
          "module": "Synthesizer.Dimensional.RateAmplitude.Instrument",
          "name": "fatSawChord",
          "normalized": "T Frequency a-\u003eT b Time a(R b Voltage a a)",
          "package": "synthesizer",
          "partial": "Saw Chord",
          "signature": "T Frequency a-\u003eT s Time a(R s Voltage a a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-RateAmplitude-Instrument.html#v:fatSawChord"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.RateAmplitude.Instrument",
          "name": "fatSawChordFilter",
          "package": "synthesizer",
          "signature": "T Frequency a -\u003e T s Time a (R s Voltage a a)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-RateAmplitude-Instrument.html#fatSawChordFilter",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional RateAmplitude Instrument",
          "module": "Synthesizer.Dimensional.RateAmplitude.Instrument",
          "name": "fatSawChordFilter",
          "normalized": "T Frequency a-\u003eT b Time a(R b Voltage a a)",
          "package": "synthesizer",
          "partial": "Saw Chord Filter",
          "signature": "T Frequency a-\u003eT s Time a(R s Voltage a a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-RateAmplitude-Instrument.html#v:fatSawChordFilter"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.RateAmplitude.Instrument",
          "name": "filterDown",
          "package": "synthesizer",
          "signature": "T s Time a (R s Frequency a a)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-RateAmplitude-Instrument.html#filterDown",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional RateAmplitude Instrument",
          "module": "Synthesizer.Dimensional.RateAmplitude.Instrument",
          "name": "filterDown",
          "package": "synthesizer",
          "partial": "Down",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-RateAmplitude-Instrument.html#v:filterDown"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.RateAmplitude.Instrument",
          "name": "filterSaw",
          "package": "synthesizer",
          "signature": "T Frequency a -\u003e T Frequency a -\u003e T s Time a (R s Voltage a a)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-RateAmplitude-Instrument.html#filterSaw",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional RateAmplitude Instrument",
          "module": "Synthesizer.Dimensional.RateAmplitude.Instrument",
          "name": "filterSaw",
          "normalized": "T Frequency a-\u003eT Frequency a-\u003eT b Time a(R b Voltage a a)",
          "package": "synthesizer",
          "partial": "Saw",
          "signature": "T Frequency a-\u003eT Frequency a-\u003eT s Time a(R s Voltage a a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-RateAmplitude-Instrument.html#v:filterSaw"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "low pass with resonance \n",
          "module": "Synthesizer.Dimensional.RateAmplitude.Instrument",
          "name": "filterSweep",
          "package": "synthesizer",
          "signature": "T a -\u003e T s Time a (R s Voltage a v -\u003e R s Voltage a v)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-RateAmplitude-Instrument.html#filterSweep",
          "type": "function"
        },
        "index": {
          "description": "low pass with resonance",
          "hierarchy": "Synthesizer Dimensional RateAmplitude Instrument",
          "module": "Synthesizer.Dimensional.RateAmplitude.Instrument",
          "name": "filterSweep",
          "normalized": "T a-\u003eT b Time a(R b Voltage a c-\u003eR b Voltage a c)",
          "package": "synthesizer",
          "partial": "Sweep",
          "signature": "T a-\u003eT s Time a(R s Voltage a v-\u003eR s Voltage a v)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-RateAmplitude-Instrument.html#v:filterSweep"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.RateAmplitude.Instrument",
          "name": "fmBell",
          "package": "synthesizer",
          "signature": "a -\u003e a -\u003e T Frequency a -\u003e T s Time a (R s Voltage a a)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-RateAmplitude-Instrument.html#fmBell",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional RateAmplitude Instrument",
          "module": "Synthesizer.Dimensional.RateAmplitude.Instrument",
          "name": "fmBell",
          "normalized": "a-\u003ea-\u003eT Frequency a-\u003eT b Time a(R b Voltage a a)",
          "package": "synthesizer",
          "partial": "Bell",
          "signature": "a-\u003ea-\u003eT Frequency a-\u003eT s Time a(R s Voltage a a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-RateAmplitude-Instrument.html#v:fmBell"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Phase modulation using a ring modulated signal.\nMay be used as some kind of e-guitar.\n",
          "module": "Synthesizer.Dimensional.RateAmplitude.Instrument",
          "name": "fmRing",
          "package": "synthesizer",
          "signature": "T Frequency a -\u003e T s Time a (R s Voltage a a)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-RateAmplitude-Instrument.html#fmRing",
          "type": "function"
        },
        "index": {
          "description": "Phase modulation using ring modulated signal May be used as some kind of e-guitar",
          "hierarchy": "Synthesizer Dimensional RateAmplitude Instrument",
          "module": "Synthesizer.Dimensional.RateAmplitude.Instrument",
          "name": "fmRing",
          "normalized": "T Frequency a-\u003eT b Time a(R b Voltage a a)",
          "package": "synthesizer",
          "partial": "Ring",
          "signature": "T Frequency a-\u003eT s Time a(R s Voltage a a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-RateAmplitude-Instrument.html#v:fmRing"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "accumulate multiple similar saw sounds and observe the increase of volume\n    The oscillator \u003ctt\u003eosc\u003c/tt\u003e must accept relative frequencies. \n",
          "module": "Synthesizer.Dimensional.RateAmplitude.Instrument",
          "name": "modulatedWave",
          "package": "synthesizer",
          "signature": "T s u a (R s (Recip u) a a -\u003e R s Voltage a a) -\u003e T (Recip u) a -\u003e a -\u003e T a -\u003e T (Recip u) a -\u003e T s u a (R s Voltage a a)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-RateAmplitude-Instrument.html#modulatedWave",
          "type": "function"
        },
        "index": {
          "description": "accumulate multiple similar saw sounds and observe the increase of volume The oscillator osc must accept relative frequencies",
          "hierarchy": "Synthesizer Dimensional RateAmplitude Instrument",
          "module": "Synthesizer.Dimensional.RateAmplitude.Instrument",
          "name": "modulatedWave",
          "normalized": "T a b c(R a(Recip b)c c-\u003eR a Voltage c c)-\u003eT(Recip b)c-\u003ec-\u003eT c-\u003eT(Recip b)c-\u003eT a b c(R a Voltage c c)",
          "package": "synthesizer",
          "partial": "Wave",
          "signature": "T s u a(R s(Recip u)a a-\u003eR s Voltage a a)-\u003eT(Recip u)a-\u003ea-\u003eT a-\u003eT(Recip u)a-\u003eT s u a(R s Voltage a a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-RateAmplitude-Instrument.html#v:modulatedWave"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.RateAmplitude.Instrument",
          "name": "moogDown",
          "package": "synthesizer",
          "signature": "Int -\u003e T Time a -\u003e T Frequency a -\u003e T Frequency a -\u003e T s Time a (R s Voltage a a)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-RateAmplitude-Instrument.html#moogDown",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional RateAmplitude Instrument",
          "module": "Synthesizer.Dimensional.RateAmplitude.Instrument",
          "name": "moogDown",
          "normalized": "Int-\u003eT Time a-\u003eT Frequency a-\u003eT Frequency a-\u003eT b Time a(R b Voltage a a)",
          "package": "synthesizer",
          "partial": "Down",
          "signature": "Int-\u003eT Time a-\u003eT Frequency a-\u003eT Frequency a-\u003eT s Time a(R s Voltage a a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-RateAmplitude-Instrument.html#v:moogDown"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.RateAmplitude.Instrument",
          "name": "moogGuitar",
          "package": "synthesizer",
          "signature": "T Frequency a -\u003e T s Time a (R s Voltage a a)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-RateAmplitude-Instrument.html#moogGuitar",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional RateAmplitude Instrument",
          "module": "Synthesizer.Dimensional.RateAmplitude.Instrument",
          "name": "moogGuitar",
          "normalized": "T Frequency a-\u003eT b Time a(R b Voltage a a)",
          "package": "synthesizer",
          "partial": "Guitar",
          "signature": "T Frequency a-\u003eT s Time a(R s Voltage a a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-RateAmplitude-Instrument.html#v:moogGuitar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.RateAmplitude.Instrument",
          "name": "moogGuitarSoft",
          "package": "synthesizer",
          "signature": "T Frequency a -\u003e T s Time a (R s Voltage a a)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-RateAmplitude-Instrument.html#moogGuitarSoft",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional RateAmplitude Instrument",
          "module": "Synthesizer.Dimensional.RateAmplitude.Instrument",
          "name": "moogGuitarSoft",
          "normalized": "T Frequency a-\u003eT b Time a(R b Voltage a a)",
          "package": "synthesizer",
          "partial": "Guitar Soft",
          "signature": "T Frequency a-\u003eT s Time a(R s Voltage a a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-RateAmplitude-Instrument.html#v:moogGuitarSoft"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.RateAmplitude.Instrument",
          "name": "moogReso",
          "package": "synthesizer",
          "signature": "Int -\u003e T Time a -\u003e T Frequency a -\u003e T Frequency a -\u003e T s Time a (R s Voltage a a)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-RateAmplitude-Instrument.html#moogReso",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional RateAmplitude Instrument",
          "module": "Synthesizer.Dimensional.RateAmplitude.Instrument",
          "name": "moogReso",
          "normalized": "Int-\u003eT Time a-\u003eT Frequency a-\u003eT Frequency a-\u003eT b Time a(R b Voltage a a)",
          "package": "synthesizer",
          "partial": "Reso",
          "signature": "Int-\u003eT Time a-\u003eT Frequency a-\u003eT Frequency a-\u003eT s Time a(R s Voltage a a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-RateAmplitude-Instrument.html#v:moogReso"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.RateAmplitude.Instrument",
          "name": "noiseBass",
          "package": "synthesizer",
          "signature": "T Frequency a -\u003e T s Time a (R s Voltage a a)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-RateAmplitude-Instrument.html#noiseBass",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional RateAmplitude Instrument",
          "module": "Synthesizer.Dimensional.RateAmplitude.Instrument",
          "name": "noiseBass",
          "normalized": "T Frequency a-\u003eT b Time a(R b Voltage a a)",
          "package": "synthesizer",
          "partial": "Bass",
          "signature": "T Frequency a-\u003eT s Time a(R s Voltage a a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-RateAmplitude-Instrument.html#v:noiseBass"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.RateAmplitude.Instrument",
          "name": "noisePerc",
          "package": "synthesizer",
          "signature": "T s Time a (R s Voltage a a)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-RateAmplitude-Instrument.html#noisePerc",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional RateAmplitude Instrument",
          "module": "Synthesizer.Dimensional.RateAmplitude.Instrument",
          "name": "noisePerc",
          "package": "synthesizer",
          "partial": "Perc",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-RateAmplitude-Instrument.html#v:noisePerc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Build a saw sound from its harmonics and modulate it.\nDifferent to normal modulation\nI modulate each harmonic with the same depth rather than a proportional one.\n",
          "module": "Synthesizer.Dimensional.RateAmplitude.Instrument",
          "name": "osciAbsModSaw",
          "package": "synthesizer",
          "signature": "T Frequency a -\u003e T s Time a (R s Voltage a a)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-RateAmplitude-Instrument.html#osciAbsModSaw",
          "type": "function"
        },
        "index": {
          "description": "Build saw sound from its harmonics and modulate it Different to normal modulation modulate each harmonic with the same depth rather than proportional one",
          "hierarchy": "Synthesizer Dimensional RateAmplitude Instrument",
          "module": "Synthesizer.Dimensional.RateAmplitude.Instrument",
          "name": "osciAbsModSaw",
          "normalized": "T Frequency a-\u003eT b Time a(R b Voltage a a)",
          "package": "synthesizer",
          "partial": "Abs Mod Saw",
          "signature": "T Frequency a-\u003eT s Time a(R s Voltage a a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-RateAmplitude-Instrument.html#v:osciAbsModSaw"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.RateAmplitude.Instrument",
          "name": "osciDoubleSaw",
          "package": "synthesizer",
          "signature": "T s u a (R s (Recip u) a a -\u003e R s Voltage a a)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-RateAmplitude-Instrument.html#osciDoubleSaw",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional RateAmplitude Instrument",
          "module": "Synthesizer.Dimensional.RateAmplitude.Instrument",
          "name": "osciDoubleSaw",
          "normalized": "T a b c(R a(Recip b)c c-\u003eR a Voltage c c)",
          "package": "synthesizer",
          "partial": "Double Saw",
          "signature": "T s u a(R s(Recip u)a a-\u003eR s Voltage a a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-RateAmplitude-Instrument.html#v:osciDoubleSaw"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "A tone with a waveform with roughly the dependency \u003ctt\u003ex -\u003e x^?p\u003c/tt\u003e,\nwhere the waveform is normalized to constant quadratic norm\n",
          "module": "Synthesizer.Dimensional.RateAmplitude.Instrument",
          "name": "osciSharp",
          "package": "synthesizer",
          "signature": "T Frequency a -\u003e T s Time a (R s Voltage a a)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-RateAmplitude-Instrument.html#osciSharp",
          "type": "function"
        },
        "index": {
          "description": "tone with waveform with roughly the dependency where the waveform is normalized to constant quadratic norm",
          "hierarchy": "Synthesizer Dimensional RateAmplitude Instrument",
          "module": "Synthesizer.Dimensional.RateAmplitude.Instrument",
          "name": "osciSharp",
          "normalized": "T Frequency a-\u003eT b Time a(R b Voltage a a)",
          "package": "synthesizer",
          "partial": "Sharp",
          "signature": "T Frequency a-\u003eT s Time a(R s Voltage a a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-RateAmplitude-Instrument.html#v:osciSharp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "frequency of the pulses, interesting ones are around 100 Hz and below \n",
          "module": "Synthesizer.Dimensional.RateAmplitude.Instrument",
          "name": "pulsedNoise",
          "package": "synthesizer",
          "signature": "T Frequency a-\u003e T s Time a (R s Voltage a a)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-RateAmplitude-Instrument.html#pulsedNoise",
          "type": "function"
        },
        "index": {
          "description": "frequency of the pulses interesting ones are around Hz and below",
          "hierarchy": "Synthesizer Dimensional RateAmplitude Instrument",
          "module": "Synthesizer.Dimensional.RateAmplitude.Instrument",
          "name": "pulsedNoise",
          "normalized": "T Frequency a-\u003eT b Time a(R b Voltage a a)",
          "package": "synthesizer",
          "partial": "Noise",
          "signature": "T Frequency a-\u003eT s Time a(R s Voltage a a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-RateAmplitude-Instrument.html#v:pulsedNoise"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.RateAmplitude.Instrument",
          "name": "simpleSaw",
          "package": "synthesizer",
          "signature": "T (Recip u) v -\u003e T s u v (R s Voltage a v)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-RateAmplitude-Instrument.html#simpleSaw",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional RateAmplitude Instrument",
          "module": "Synthesizer.Dimensional.RateAmplitude.Instrument",
          "name": "simpleSaw",
          "normalized": "T(Recip a)b-\u003eT c a b(R c Voltage d b)",
          "package": "synthesizer",
          "partial": "Saw",
          "signature": "T(Recip u)v-\u003eT s u v(R s Voltage a v)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-RateAmplitude-Instrument.html#v:simpleSaw"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.RateAmplitude.Instrument",
          "name": "squareBell",
          "package": "synthesizer",
          "signature": "T Frequency a -\u003e T s Time a (R s Voltage a a)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-RateAmplitude-Instrument.html#squareBell",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional RateAmplitude Instrument",
          "module": "Synthesizer.Dimensional.RateAmplitude.Instrument",
          "name": "squareBell",
          "normalized": "T Frequency a-\u003eT b Time a(R b Voltage a a)",
          "package": "synthesizer",
          "partial": "Bell",
          "signature": "T Frequency a-\u003eT s Time a(R s Voltage a a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-RateAmplitude-Instrument.html#v:squareBell"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "A function mapping a frequency to a signal. \nThe factor to the frequency, should be close to 1. \nThe base (undeviated) frequency of the sound. \n",
          "module": "Synthesizer.Dimensional.RateAmplitude.Instrument",
          "name": "stereoPhaser",
          "package": "synthesizer",
          "signature": "T Frequency a -\u003e T s Time a (R s u b b)-\u003e a-\u003e T Frequency a-\u003e T s Time a (R s u b b)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-RateAmplitude-Instrument.html#stereoPhaser",
          "type": "function"
        },
        "index": {
          "description": "function mapping frequency to signal The factor to the frequency should be close to The base undeviated frequency of the sound",
          "hierarchy": "Synthesizer Dimensional RateAmplitude Instrument",
          "module": "Synthesizer.Dimensional.RateAmplitude.Instrument",
          "name": "stereoPhaser",
          "normalized": "T Frequency a-\u003eT b Time a(R b c d d)-\u003ea-\u003eT Frequency a-\u003eT b Time a(R b c d d)",
          "package": "synthesizer",
          "partial": "Phaser",
          "signature": "T Frequency a-\u003eT s Time a(R s u b b)-\u003ea-\u003eT Frequency a-\u003eT s Time a(R s u b b)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-RateAmplitude-Instrument.html#v:stereoPhaser"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "A good choice is \u003ctt\u003efreq = DN.frequency 110\u003c/tt\u003e\n",
          "module": "Synthesizer.Dimensional.RateAmplitude.Instrument",
          "name": "wasp",
          "package": "synthesizer",
          "signature": "T (Recip u) q -\u003e T s u q (R s Voltage q q)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-RateAmplitude-Instrument.html#wasp",
          "type": "function"
        },
        "index": {
          "description": "good choice is freq DN.frequency",
          "hierarchy": "Synthesizer Dimensional RateAmplitude Instrument",
          "module": "Synthesizer.Dimensional.RateAmplitude.Instrument",
          "name": "wasp",
          "normalized": "T(Recip a)b-\u003eT c a b(R c Voltage b b)",
          "package": "synthesizer",
          "signature": "T(Recip u)q-\u003eT s u q(R s Voltage q q)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-RateAmplitude-Instrument.html#v:wasp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Every occurrence is represented by a peak of area 1.\n               If you smooth the input and the output signal to the same degree\n               they should be rather similar. \n",
          "module": "Synthesizer.Dimensional.RateAmplitude.Noise",
          "name": "randomPeeks",
          "package": "synthesizer",
          "signature": "T s u q (R s (Recip u) q q -\u003e R s (Recip u) q q)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-RateAmplitude-Noise.html#randomPeeks",
          "type": "function"
        },
        "index": {
          "description": "Every occurrence is represented by peak of area If you smooth the input and the output signal to the same degree they should be rather similar",
          "hierarchy": "Synthesizer Dimensional RateAmplitude Noise",
          "module": "Synthesizer.Dimensional.RateAmplitude.Noise",
          "name": "randomPeeks",
          "normalized": "T a b c(R a(Recip b)c c-\u003eR a(Recip b)c c)",
          "package": "synthesizer",
          "partial": "Peeks",
          "signature": "T s u q(R s(Recip u)q q-\u003eR s(Recip u)q q)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-RateAmplitude-Noise.html#v:randomPeeks"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "random generator, can be used to choose a seed \nEvery occurrence is represented by a peak of area 1. \n",
          "module": "Synthesizer.Dimensional.RateAmplitude.Noise",
          "name": "randomPeeksGen",
          "package": "synthesizer",
          "signature": "g-\u003e T s u q (R s (Recip u) q q -\u003e R s (Recip u) q q)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-RateAmplitude-Noise.html#randomPeeksGen",
          "type": "function"
        },
        "index": {
          "description": "random generator can be used to choose seed Every occurrence is represented by peak of area",
          "hierarchy": "Synthesizer Dimensional RateAmplitude Noise",
          "module": "Synthesizer.Dimensional.RateAmplitude.Noise",
          "name": "randomPeeksGen",
          "normalized": "a-\u003eT b c d(R b(Recip c)d d-\u003eR b(Recip c)d d)",
          "package": "synthesizer",
          "partial": "Peeks Gen",
          "signature": "g-\u003eT s u q(R s(Recip u)q q-\u003eR s(Recip u)q q)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-RateAmplitude-Noise.html#v:randomPeeksGen"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "width of the frequency band \nvolume caused by the given frequency band \nnoise \n",
          "module": "Synthesizer.Dimensional.RateAmplitude.Noise",
          "name": "white",
          "package": "synthesizer",
          "signature": "T (Recip u) q-\u003e T v q-\u003e T s u q (R s v q yv)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-RateAmplitude-Noise.html#white",
          "type": "function"
        },
        "index": {
          "description": "width of the frequency band volume caused by the given frequency band noise",
          "hierarchy": "Synthesizer Dimensional RateAmplitude Noise",
          "module": "Synthesizer.Dimensional.RateAmplitude.Noise",
          "name": "white",
          "normalized": "T(Recip a)b-\u003eT c b-\u003eT d a b(R d c b e)",
          "package": "synthesizer",
          "signature": "T(Recip u)q-\u003eT v q-\u003eT s u q(R s v q yv)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-RateAmplitude-Noise.html#v:white"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "energy per frequency band \nnoise \n",
          "module": "Synthesizer.Dimensional.RateAmplitude.Noise",
          "name": "whiteBandEnergy",
          "package": "synthesizer",
          "signature": "T (Mul u (Sqr v)) q-\u003e T s u q (R s v q yv)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-RateAmplitude-Noise.html#whiteBandEnergy",
          "type": "function"
        },
        "index": {
          "description": "energy per frequency band noise",
          "hierarchy": "Synthesizer Dimensional RateAmplitude Noise",
          "module": "Synthesizer.Dimensional.RateAmplitude.Noise",
          "name": "whiteBandEnergy",
          "normalized": "T(Mul a(Sqr b))c-\u003eT d a c(R d b c e)",
          "package": "synthesizer",
          "partial": "Band Energy",
          "signature": "T(Mul u(Sqr v))q-\u003eT s u q(R s v q yv)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-RateAmplitude-Noise.html#v:whiteBandEnergy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "random generator, can be used to choose a seed \nenergy per frequency band \nnoise \n",
          "module": "Synthesizer.Dimensional.RateAmplitude.Noise",
          "name": "whiteBandEnergyGen",
          "package": "synthesizer",
          "signature": "g-\u003e T (Mul u (Sqr v)) q-\u003e T s u q (R s v q yv)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-RateAmplitude-Noise.html#whiteBandEnergyGen",
          "type": "function"
        },
        "index": {
          "description": "random generator can be used to choose seed energy per frequency band noise",
          "hierarchy": "Synthesizer Dimensional RateAmplitude Noise",
          "module": "Synthesizer.Dimensional.RateAmplitude.Noise",
          "name": "whiteBandEnergyGen",
          "normalized": "a-\u003eT(Mul b(Sqr c))d-\u003eT e b d(R e c d f)",
          "package": "synthesizer",
          "partial": "Band Energy Gen",
          "signature": "g-\u003eT(Mul u(Sqr v))q-\u003eT s u q(R s v q yv)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-RateAmplitude-Noise.html#v:whiteBandEnergyGen"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "random generator, can be used to choose a seed \nwidth of the frequency band \nvolume caused by the given frequency band \nnoise \n",
          "module": "Synthesizer.Dimensional.RateAmplitude.Noise",
          "name": "whiteGen",
          "package": "synthesizer",
          "signature": "g-\u003e T (Recip u) q-\u003e T v q-\u003e T s u q (R s v q yv)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-RateAmplitude-Noise.html#whiteGen",
          "type": "function"
        },
        "index": {
          "description": "random generator can be used to choose seed width of the frequency band volume caused by the given frequency band noise",
          "hierarchy": "Synthesizer Dimensional RateAmplitude Noise",
          "module": "Synthesizer.Dimensional.RateAmplitude.Noise",
          "name": "whiteGen",
          "normalized": "a-\u003eT(Recip b)c-\u003eT d c-\u003eT e b c(R e d c f)",
          "package": "synthesizer",
          "partial": "Gen",
          "signature": "g-\u003eT(Recip u)q-\u003eT v q-\u003eT s u q(R s v q yv)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-RateAmplitude-Noise.html#v:whiteGen"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.RateAmplitude.Play",
          "name": "auto",
          "package": "synthesizer",
          "signature": "T (Recip u) t -\u003e T v y -\u003e (int -\u003e Builder int) -\u003e T u t (S v y) yv -\u003e IO ExitCode",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-RateAmplitude-Play.html#auto",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional RateAmplitude Play",
          "module": "Synthesizer.Dimensional.RateAmplitude.Play",
          "name": "auto",
          "normalized": "T(Recip a)b-\u003eT c d-\u003e(e-\u003eBuilder e)-\u003eT a b(S c d)f-\u003eIO ExitCode",
          "package": "synthesizer",
          "signature": "T(Recip u)t-\u003eT v y-\u003e(int-\u003eBuilder int)-\u003eT u t(S v y)yv-\u003eIO ExitCode",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-RateAmplitude-Play.html#v:auto"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.RateAmplitude.Play",
          "name": "renderTimeVoltageMonoDoubleToInt16",
          "package": "synthesizer",
          "signature": "T Frequency Double -\u003e (forall s.  T s Time Double (R s Voltage Double Double)) -\u003e IO ExitCode",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-RateAmplitude-Play.html#renderTimeVoltageMonoDoubleToInt16",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional RateAmplitude Play",
          "module": "Synthesizer.Dimensional.RateAmplitude.Play",
          "name": "renderTimeVoltageMonoDoubleToInt16",
          "normalized": "T Frequency Double-\u003e(a b T c Time Double(R c Voltage Double Double))-\u003eIO ExitCode",
          "package": "synthesizer",
          "partial": "Time Voltage Mono Double To Int",
          "signature": "T Frequency Double-\u003e(forall s. T s Time Double(R s Voltage Double Double))-\u003eIO ExitCode",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-RateAmplitude-Play.html#v:renderTimeVoltageMonoDoubleToInt16"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.RateAmplitude.Play",
          "name": "renderTimeVoltageStereoDoubleToInt16",
          "package": "synthesizer",
          "signature": "T Frequency Double -\u003e (forall s.  T s Time Double (R s Voltage Double (T Double))) -\u003e IO ExitCode",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-RateAmplitude-Play.html#renderTimeVoltageStereoDoubleToInt16",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional RateAmplitude Play",
          "module": "Synthesizer.Dimensional.RateAmplitude.Play",
          "name": "renderTimeVoltageStereoDoubleToInt16",
          "normalized": "T Frequency Double-\u003e(a b T c Time Double(R c Voltage Double(T Double)))-\u003eIO ExitCode",
          "package": "synthesizer",
          "partial": "Time Voltage Stereo Double To Int",
          "signature": "T Frequency Double-\u003e(forall s. T s Time Double(R s Voltage Double(T Double)))-\u003eIO ExitCode",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-RateAmplitude-Play.html#v:renderTimeVoltageStereoDoubleToInt16"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.RateAmplitude.Play",
          "name": "timeVoltage",
          "package": "synthesizer",
          "signature": "(int -\u003e Builder int) -\u003e T Time t (S Voltage y) yv -\u003e IO ExitCode",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-RateAmplitude-Play.html#timeVoltage",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional RateAmplitude Play",
          "module": "Synthesizer.Dimensional.RateAmplitude.Play",
          "name": "timeVoltage",
          "normalized": "(a-\u003eBuilder a)-\u003eT Time b(S Voltage c)d-\u003eIO ExitCode",
          "package": "synthesizer",
          "partial": "Voltage",
          "signature": "(int-\u003eBuilder int)-\u003eT Time t(S Voltage y)yv-\u003eIO ExitCode",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-RateAmplitude-Play.html#v:timeVoltage"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.RateAmplitude.Play",
          "name": "timeVoltageMonoDoubleToInt16",
          "package": "synthesizer",
          "signature": "T Time Double (S Voltage Double) Double -\u003e IO ExitCode",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-RateAmplitude-Play.html#timeVoltageMonoDoubleToInt16",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional RateAmplitude Play",
          "module": "Synthesizer.Dimensional.RateAmplitude.Play",
          "name": "timeVoltageMonoDoubleToInt16",
          "normalized": "T Time Double(S Voltage Double)Double-\u003eIO ExitCode",
          "package": "synthesizer",
          "partial": "Voltage Mono Double To Int",
          "signature": "T Time Double(S Voltage Double)Double-\u003eIO ExitCode",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-RateAmplitude-Play.html#v:timeVoltageMonoDoubleToInt16"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.RateAmplitude.Play",
          "name": "timeVoltageStereoDoubleToInt16",
          "package": "synthesizer",
          "signature": "T Time Double (S Voltage Double) (T Double) -\u003e IO ExitCode",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-RateAmplitude-Play.html#timeVoltageStereoDoubleToInt16",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional RateAmplitude Play",
          "module": "Synthesizer.Dimensional.RateAmplitude.Play",
          "name": "timeVoltageStereoDoubleToInt16",
          "normalized": "T Time Double(S Voltage Double)(T Double)-\u003eIO ExitCode",
          "package": "synthesizer",
          "partial": "Voltage Stereo Double To Int",
          "signature": "T Time Double(S Voltage Double)(T Double)-\u003eIO ExitCode",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-RateAmplitude-Play.html#v:timeVoltageStereoDoubleToInt16"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.RateAmplitude.Signal",
          "name": "D",
          "package": "synthesizer",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Amplitude-Signal.html#D",
          "type": "type"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional RateAmplitude Signal",
          "module": "Synthesizer.Dimensional.RateAmplitude.Signal",
          "name": "D",
          "package": "synthesizer",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-RateAmplitude-Signal.html#t:D"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.RateAmplitude.Signal",
          "name": "DimensionGradient",
          "package": "synthesizer",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-RateAmplitude-Signal.html#DimensionGradient",
          "type": "type"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional RateAmplitude Signal",
          "module": "Synthesizer.Dimensional.RateAmplitude.Signal",
          "name": "DimensionGradient",
          "package": "synthesizer",
          "partial": "Dimension Gradient",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-RateAmplitude-Signal.html#t:DimensionGradient"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.RateAmplitude.Signal",
          "name": "R",
          "package": "synthesizer",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Amplitude-Signal.html#R",
          "type": "type"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional RateAmplitude Signal",
          "module": "Synthesizer.Dimensional.RateAmplitude.Signal",
          "name": "R",
          "package": "synthesizer",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-RateAmplitude-Signal.html#t:R"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.RateAmplitude.Signal",
          "package": "synthesizer",
          "signature": "T v y -\u003e T s u t (R s yv) -\u003e T s u t (R s v y yv)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-RateAmplitude-Signal.html#%26%2A%3E%5E",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional RateAmplitude Signal",
          "module": "Synthesizer.Dimensional.RateAmplitude.Signal",
          "normalized": "T a b-\u003eT c d e(R c f)-\u003eT c d e(R c a b f)",
          "package": "synthesizer",
          "signature": "T v y-\u003eT s u t(R s yv)-\u003eT s u t(R s v y yv)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-RateAmplitude-Signal.html#v:"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Take a signal with \u003ctt\u003e\u003ca\u003eScalar\u003c/a\u003e\u003c/tt\u003e unit in amplitude\nwhere the process expects a plain \u003ctt\u003e\u003ca\u003eT\u003c/a\u003e\u003c/tt\u003e.\nThis is no longer important\nsince the processes which expects those inputs\ncan use the Flat type class.\n",
          "module": "Synthesizer.Dimensional.RateAmplitude.Signal",
          "name": "$",
          "package": "synthesizer",
          "signature": "T s u t (R s y -\u003e a) -\u003e T s u t (R s Scalar y y) -\u003e T s u t a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-RateAmplitude-Signal.html#%24%26",
          "type": "function"
        },
        "index": {
          "description": "Take signal with Scalar unit in amplitude where the process expects plain This is no longer important since the processes which expects those inputs can use the Flat type class",
          "hierarchy": "Synthesizer Dimensional RateAmplitude Signal",
          "module": "Synthesizer.Dimensional.RateAmplitude.Signal",
          "name": "$",
          "normalized": "T a b c(R a d-\u003ee)-\u003eT a b c(R a Scalar d d)-\u003eT a b c e",
          "package": "synthesizer",
          "signature": "T s u t(R s y-\u003ea)-\u003eT s u t(R s Scalar y y)-\u003eT s u t a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-RateAmplitude-Signal.html#v:$"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Take a scalar argument where a process expects a signal.\nOnly possible for non-negative values so far.\n",
          "module": "Synthesizer.Dimensional.RateAmplitude.Signal",
          "name": "$-",
          "package": "synthesizer",
          "signature": "T s u t (R s v y y -\u003e a) -\u003e T v y -\u003e T s u t a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-RateAmplitude-Signal.html#%24-",
          "type": "function"
        },
        "index": {
          "description": "Take scalar argument where process expects signal Only possible for non-negative values so far",
          "hierarchy": "Synthesizer Dimensional RateAmplitude Signal",
          "module": "Synthesizer.Dimensional.RateAmplitude.Signal",
          "name": "$-",
          "normalized": "T a b c(R a d e e-\u003ef)-\u003eT d e-\u003eT a b c f",
          "package": "synthesizer",
          "signature": "T s u t(R s v y y-\u003ea)-\u003eT v y-\u003eT s u t a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-RateAmplitude-Signal.html#v:$-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.RateAmplitude.Signal",
          "name": "bindCached",
          "package": "synthesizer",
          "signature": "T s u t (w (D v y S) yv0) -\u003e (w (D v y S) yv0 -\u003e T s u t b) -\u003e T s u t b",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-RateAmplitude-Signal.html#bindCached",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional RateAmplitude Signal",
          "module": "Synthesizer.Dimensional.RateAmplitude.Signal",
          "name": "bindCached",
          "normalized": "T a b c(d(D e f S)g)-\u003e(d(D e f S)g-\u003eT a b c h)-\u003eT a b c h",
          "package": "synthesizer",
          "partial": "Cached",
          "signature": "T s u t(w(D v y S)yv)-\u003e(w(D v y S)yv-\u003eT s u t b)-\u003eT s u t b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-RateAmplitude-Signal.html#v:bindCached"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.RateAmplitude.Signal",
          "name": "cache",
          "package": "synthesizer",
          "signature": "T s u t (w (D v y S) yv0) -\u003e T s u t (w (D v y S) yv0)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-RateAmplitude-Signal.html#cache",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional RateAmplitude Signal",
          "module": "Synthesizer.Dimensional.RateAmplitude.Signal",
          "name": "cache",
          "normalized": "T a b c(d(D e f S)g)-\u003eT a b c(d(D e f S)g)",
          "package": "synthesizer",
          "signature": "T s u t(w(D v y S)yv)-\u003eT s u t(w(D v y S)yv)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-RateAmplitude-Signal.html#v:cache"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.RateAmplitude.Signal",
          "name": "share",
          "package": "synthesizer",
          "signature": "T s u t (w (D v y S) yv0) -\u003e (T s u t (w (D v y S) yv0) -\u003e T s u t b) -\u003e T s u t b",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-RateAmplitude-Signal.html#share",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional RateAmplitude Signal",
          "module": "Synthesizer.Dimensional.RateAmplitude.Signal",
          "name": "share",
          "normalized": "T a b c(d(D e f S)g)-\u003e(T a b c(d(D e f S)g)-\u003eT a b c h)-\u003eT a b c h",
          "package": "synthesizer",
          "signature": "T s u t(w(D v y S)yv)-\u003e(T s u t(w(D v y S)yv)-\u003eT s u t b)-\u003eT s u t b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-RateAmplitude-Signal.html#v:share"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.RateAmplitude.Signal",
          "name": "toGradientScalar",
          "package": "synthesizer",
          "signature": "T v q -\u003e T (DimensionGradient u v) q -\u003e T s u q q",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-RateAmplitude-Signal.html#toGradientScalar",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional RateAmplitude Signal",
          "module": "Synthesizer.Dimensional.RateAmplitude.Signal",
          "name": "toGradientScalar",
          "normalized": "T a b-\u003eT(DimensionGradient c a)b-\u003eT d c b b",
          "package": "synthesizer",
          "partial": "Gradient Scalar",
          "signature": "T v q-\u003eT(DimensionGradient u v)q-\u003eT s u q q",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-RateAmplitude-Signal.html#v:toGradientScalar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.RateAmplitude.Signal",
          "name": "toStorableInt16Mono",
          "package": "synthesizer",
          "signature": "w (S Voltage a) a -\u003e w T Int16",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-RateAmplitude-Signal.html#toStorableInt16Mono",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional RateAmplitude Signal",
          "module": "Synthesizer.Dimensional.RateAmplitude.Signal",
          "name": "toStorableInt16Mono",
          "normalized": "a(S Voltage b)b-\u003ea T Int",
          "package": "synthesizer",
          "partial": "Storable Int Mono",
          "signature": "w(S Voltage a)a-\u003ew T Int",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-RateAmplitude-Signal.html#v:toStorableInt16Mono"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.RateAmplitude.Signal",
          "name": "toStorableInt16Stereo",
          "package": "synthesizer",
          "signature": "w (S Voltage a) (T a) -\u003e w T (T Int16)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-RateAmplitude-Signal.html#toStorableInt16Stereo",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional RateAmplitude Signal",
          "module": "Synthesizer.Dimensional.RateAmplitude.Signal",
          "name": "toStorableInt16Stereo",
          "normalized": "a(S Voltage b)(T b)-\u003ea T(T Int)",
          "package": "synthesizer",
          "partial": "Storable Int Stereo",
          "signature": "w(S Voltage a)(T a)-\u003ew T(T Int)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-RateAmplitude-Signal.html#v:toStorableInt16Stereo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.RatePhantom",
          "name": "T",
          "package": "synthesizer",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-RatePhantom.html#T",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional RatePhantom",
          "module": "Synthesizer.Dimensional.RatePhantom",
          "name": "T",
          "package": "synthesizer",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-RatePhantom.html#t:T"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.RatePhantom",
          "name": "fromSignal",
          "package": "synthesizer",
          "signature": "sig y -\u003e T s sig y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-RatePhantom.html#fromSignal",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional RatePhantom",
          "module": "Synthesizer.Dimensional.RatePhantom",
          "name": "fromSignal",
          "normalized": "a b-\u003eT c a b",
          "package": "synthesizer",
          "partial": "Signal",
          "signature": "sig y-\u003eT s sig y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-RatePhantom.html#v:fromSignal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.RatePhantom",
          "name": "processSignal",
          "package": "synthesizer",
          "signature": "(sig0 y0 -\u003e sig1 y1) -\u003e T s sig0 y0 -\u003e T s sig1 y1",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-RatePhantom.html#processSignal",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional RatePhantom",
          "module": "Synthesizer.Dimensional.RatePhantom",
          "name": "processSignal",
          "normalized": "(a b-\u003ea b)-\u003eT c a b-\u003eT c a b",
          "package": "synthesizer",
          "partial": "Signal",
          "signature": "(sig y-\u003esig y)-\u003eT s sig y-\u003eT s sig y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-RatePhantom.html#v:processSignal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.RatePhantom",
          "name": "toSignal",
          "package": "synthesizer",
          "signature": "T s sig y -\u003e sig y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-RatePhantom.html#toSignal",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional RatePhantom",
          "module": "Synthesizer.Dimensional.RatePhantom",
          "name": "toSignal",
          "normalized": "T a b c-\u003eb c",
          "package": "synthesizer",
          "partial": "Signal",
          "signature": "T s sig y-\u003esig y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-RatePhantom.html#v:toSignal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.RateWrapper",
          "name": "T",
          "package": "synthesizer",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-RateWrapper.html#T",
          "type": "data"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional RateWrapper",
          "module": "Synthesizer.Dimensional.RateWrapper",
          "name": "T",
          "package": "synthesizer",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-RateWrapper.html#t:T"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.RateWrapper",
          "name": "fromProcess",
          "package": "synthesizer",
          "signature": "T s u t (T s sig yv -\u003e T u t sig yv)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-RateWrapper.html#fromProcess",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional RateWrapper",
          "module": "Synthesizer.Dimensional.RateWrapper",
          "name": "fromProcess",
          "normalized": "T a b c(T a d e-\u003eT b c d e)",
          "package": "synthesizer",
          "partial": "Process",
          "signature": "T s u t(T s sig yv-\u003eT u t sig yv)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-RateWrapper.html#v:fromProcess"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "internal function\n",
          "module": "Synthesizer.Dimensional.RateWrapper",
          "name": "fromSignal",
          "package": "synthesizer",
          "signature": "T s u t -\u003e T s sig yv -\u003e T u t sig yv",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-RateWrapper.html#fromSignal",
          "type": "function"
        },
        "index": {
          "description": "internal function",
          "hierarchy": "Synthesizer Dimensional RateWrapper",
          "module": "Synthesizer.Dimensional.RateWrapper",
          "name": "fromSignal",
          "normalized": "T a b c-\u003eT a d e-\u003eT b c d e",
          "package": "synthesizer",
          "partial": "Signal",
          "signature": "T s u t-\u003eT s sig yv-\u003eT u t sig yv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-RateWrapper.html#v:fromSignal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.RateWrapper",
          "name": "processSignal",
          "package": "synthesizer",
          "signature": "(sig0 yv0 -\u003e sig1 yv1) -\u003e T u t sig0 yv0 -\u003e T u t sig1 yv1",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-RateWrapper.html#processSignal",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional RateWrapper",
          "module": "Synthesizer.Dimensional.RateWrapper",
          "name": "processSignal",
          "normalized": "(a b-\u003ea b)-\u003eT c d a b-\u003eT c d a b",
          "package": "synthesizer",
          "partial": "Signal",
          "signature": "(sig yv-\u003esig yv)-\u003eT u t sig yv-\u003eT u t sig yv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-RateWrapper.html#v:processSignal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Render a signal generated by a signal processor\nat the given sample rate,\nand leave the sample rate context.\nIf you want to render multiple signals,\nthen convert them with \u003ctt\u003e\u003ca\u003efromProcess\u003c/a\u003e\u003c/tt\u003e\nand move them out of the sample rate context\nall at once using \u003ctt\u003e\u003ca\u003erun\u003c/a\u003e\u003c/tt\u003e.\n",
          "module": "Synthesizer.Dimensional.RateWrapper",
          "name": "runProcess",
          "package": "synthesizer",
          "signature": "T (Recip u) t -\u003e (forall s.  T s u t (T s sig yv)) -\u003e T u t sig yv",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-RateWrapper.html#runProcess",
          "type": "function"
        },
        "index": {
          "description": "Render signal generated by signal processor at the given sample rate and leave the sample rate context If you want to render multiple signals then convert them with fromProcess and move them out of the sample rate context all at once using run",
          "hierarchy": "Synthesizer Dimensional RateWrapper",
          "module": "Synthesizer.Dimensional.RateWrapper",
          "name": "runProcess",
          "normalized": "T(Recip a)b-\u003e(c d T e a b(T e f g))-\u003eT a b f g",
          "package": "synthesizer",
          "partial": "Process",
          "signature": "T(Recip u)t-\u003e(forall s. T s u t(T s sig yv))-\u003eT u t sig yv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-RateWrapper.html#v:runProcess"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.RateWrapper",
          "name": "runProcessOn",
          "package": "synthesizer",
          "signature": "(forall s.  T s u t (T s sig0 yv0 -\u003e T s sig1 yv1)) -\u003e T u t sig0 yv0 -\u003e T u t sig1 yv1",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-RateWrapper.html#runProcessOn",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional RateWrapper",
          "module": "Synthesizer.Dimensional.RateWrapper",
          "name": "runProcessOn",
          "normalized": "(a b T c d e(T c f g-\u003eT c f g))-\u003eT d e f g-\u003eT d e f g",
          "package": "synthesizer",
          "partial": "Process On",
          "signature": "(forall s. T s u t(T s sig yv-\u003eT s sig yv))-\u003eT u t sig yv-\u003eT u t sig yv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-RateWrapper.html#v:runProcessOn"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.RateWrapper",
          "name": "toProcess",
          "package": "synthesizer",
          "signature": "(T u t sig yv -\u003e a) -\u003e T s u t (T s sig yv -\u003e a)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-RateWrapper.html#toProcess",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional RateWrapper",
          "module": "Synthesizer.Dimensional.RateWrapper",
          "name": "toProcess",
          "normalized": "(T a b c d-\u003ee)-\u003eT f a b(T f c d-\u003ee)",
          "package": "synthesizer",
          "partial": "Process",
          "signature": "(T u t sig yv-\u003ea)-\u003eT s u t(T s sig yv-\u003ea)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-RateWrapper.html#v:toProcess"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.RateWrapper",
          "name": "toSignal",
          "package": "synthesizer",
          "signature": "T u t sig yv -\u003e (T s u t, T s sig yv)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-RateWrapper.html#toSignal",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional RateWrapper",
          "module": "Synthesizer.Dimensional.RateWrapper",
          "name": "toSignal",
          "normalized": "T a b c d-\u003e(T e a b,T e c d)",
          "package": "synthesizer",
          "partial": "Signal",
          "signature": "T u t sig yv-\u003e(T s u t,T s sig yv)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-RateWrapper.html#v:toSignal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "In \u003ca\u003eSynthesizer.State.Distortion\u003c/a\u003e you find a collection\nof appropriate distortion functions.\n",
          "module": "Synthesizer.Dimensional.Straight.Displacement",
          "name": "distort",
          "package": "synthesizer",
          "signature": "(c -\u003e a -\u003e a) -\u003e R s c -\u003e R s a -\u003e R s a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Straight-Displacement.html#distort",
          "type": "function"
        },
        "index": {
          "description": "In Synthesizer.State.Distortion you find collection of appropriate distortion functions",
          "hierarchy": "Synthesizer Dimensional Straight Displacement",
          "module": "Synthesizer.Dimensional.Straight.Displacement",
          "name": "distort",
          "normalized": "(a-\u003eb-\u003eb)-\u003eR c a-\u003eR c b-\u003eR c b",
          "package": "synthesizer",
          "signature": "(c-\u003ea-\u003ea)-\u003eR s c-\u003eR s a-\u003eR s a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Straight-Displacement.html#v:distort"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.Straight.Displacement",
          "name": "map",
          "package": "synthesizer",
          "signature": "(y0 -\u003e y1) -\u003e w flat y0 -\u003e w S y1",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Straight-Displacement.html#map",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional Straight Displacement",
          "module": "Synthesizer.Dimensional.Straight.Displacement",
          "name": "map",
          "normalized": "(a-\u003ea)-\u003eb c a-\u003eb S a",
          "package": "synthesizer",
          "signature": "(y-\u003ey)-\u003ew flat y-\u003ew S y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Straight-Displacement.html#v:map"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Mix two signals.\nIn opposition to \u003ctt\u003e\u003ca\u003ezipWith\u003c/a\u003e\u003c/tt\u003e the result has the length of the longer signal.\n",
          "module": "Synthesizer.Dimensional.Straight.Displacement",
          "name": "mix",
          "package": "synthesizer",
          "signature": "R s v -\u003e R s v -\u003e R s v",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Straight-Displacement.html#mix",
          "type": "function"
        },
        "index": {
          "description": "Mix two signals In opposition to zipWith the result has the length of the longer signal",
          "hierarchy": "Synthesizer Dimensional Straight Displacement",
          "module": "Synthesizer.Dimensional.Straight.Displacement",
          "name": "mix",
          "normalized": "R a b-\u003eR a b-\u003eR a b",
          "package": "synthesizer",
          "signature": "R s v-\u003eR s v-\u003eR s v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Straight-Displacement.html#v:mix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Add a number to all of the signal values.\n    This is useful for adjusting the center of a modulation. \n",
          "module": "Synthesizer.Dimensional.Straight.Displacement",
          "name": "raise",
          "package": "synthesizer",
          "signature": "v -\u003e w S v -\u003e w S v",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Straight-Displacement.html#raise",
          "type": "function"
        },
        "index": {
          "description": "Add number to all of the signal values This is useful for adjusting the center of modulation",
          "hierarchy": "Synthesizer Dimensional Straight Displacement",
          "module": "Synthesizer.Dimensional.Straight.Displacement",
          "name": "raise",
          "normalized": "a-\u003eb S a-\u003eb S a",
          "package": "synthesizer",
          "signature": "v-\u003ew S v-\u003ew S v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Straight-Displacement.html#v:raise"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "In contrast to Synthesizer.Dimensional.Rate.Dirac\nwhere only booleans are possible (peak or not peak)\nwe can also have signals of booleans or other enumerations.\nIn this case we consider the signal as piecewise constant.\n",
          "module": "Synthesizer.Dimensional.Straight.Signal",
          "name": "Binary",
          "package": "synthesizer",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Straight-Signal.html#Binary",
          "type": "type"
        },
        "index": {
          "description": "In contrast to Synthesizer.Dimensional.Rate.Dirac where only booleans are possible peak or not peak we can also have signals of booleans or other enumerations In this case we consider the signal as piecewise constant",
          "hierarchy": "Synthesizer Dimensional Straight Signal",
          "module": "Synthesizer.Dimensional.Straight.Signal",
          "name": "Binary",
          "package": "synthesizer",
          "partial": "Binary",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Straight-Signal.html#t:Binary"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.Straight.Signal",
          "name": "R",
          "package": "synthesizer",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Straight-Signal.html#R",
          "type": "type"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional Straight Signal",
          "module": "Synthesizer.Dimensional.Straight.Signal",
          "name": "R",
          "package": "synthesizer",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Straight-Signal.html#t:R"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.Straight.Signal",
          "name": "S",
          "package": "synthesizer",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Straight-Signal.html#S",
          "type": "type"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional Straight Signal",
          "module": "Synthesizer.Dimensional.Straight.Signal",
          "name": "S",
          "package": "synthesizer",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Straight-Signal.html#t:S"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.Straight.Signal",
          "name": "T",
          "package": "synthesizer",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Straight-Signal.html#T",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional Straight Signal",
          "module": "Synthesizer.Dimensional.Straight.Signal",
          "name": "T",
          "package": "synthesizer",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Straight-Signal.html#t:T"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.Straight.Signal",
          "name": "fromSamples",
          "package": "synthesizer",
          "signature": "T yv -\u003e R s yv",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Straight-Signal.html#fromSamples",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional Straight Signal",
          "module": "Synthesizer.Dimensional.Straight.Signal",
          "name": "fromSamples",
          "normalized": "T a-\u003eR b a",
          "package": "synthesizer",
          "partial": "Samples",
          "signature": "T yv-\u003eR s yv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Straight-Signal.html#v:fromSamples"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.Straight.Signal",
          "name": "processSamples",
          "package": "synthesizer",
          "signature": "(seq0 yv0 -\u003e seq1 yv1) -\u003e w (T seq0) yv0 -\u003e w (T seq1) yv1",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Straight-Signal.html#processSamples",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional Straight Signal",
          "module": "Synthesizer.Dimensional.Straight.Signal",
          "name": "processSamples",
          "normalized": "(a b-\u003ea b)-\u003ec(T a)b-\u003ec(T a)b",
          "package": "synthesizer",
          "partial": "Samples",
          "signature": "(seq yv-\u003eseq yv)-\u003ew(T seq)yv-\u003ew(T seq)yv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Straight-Signal.html#v:processSamples"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.Straight.Signal",
          "name": "processSamplesPrivate",
          "package": "synthesizer",
          "signature": "(seq0 yv0 -\u003e seq1 yv1) -\u003e T seq0 yv0 -\u003e T seq1 yv1",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Straight-Signal.html#processSamplesPrivate",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional Straight Signal",
          "module": "Synthesizer.Dimensional.Straight.Signal",
          "name": "processSamplesPrivate",
          "normalized": "(a b-\u003ea b)-\u003eT a b-\u003eT a b",
          "package": "synthesizer",
          "partial": "Samples Private",
          "signature": "(seq yv-\u003eseq yv)-\u003eT seq yv-\u003eT seq yv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Straight-Signal.html#v:processSamplesPrivate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.Straight.Signal",
          "name": "replaceSamples",
          "package": "synthesizer",
          "signature": "T yv1 -\u003e R s yv0 -\u003e R s yv1",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Straight-Signal.html#replaceSamples",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional Straight Signal",
          "module": "Synthesizer.Dimensional.Straight.Signal",
          "name": "replaceSamples",
          "normalized": "T a-\u003eR b a-\u003eR b a",
          "package": "synthesizer",
          "partial": "Samples",
          "signature": "T yv-\u003eR s yv-\u003eR s yv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Straight-Signal.html#v:replaceSamples"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Dimensional.Straight.Signal",
          "name": "toSamples",
          "package": "synthesizer",
          "signature": "w (T seq) yv -\u003e seq yv",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Dimensional-Straight-Signal.html#toSamples",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Dimensional Straight Signal",
          "module": "Synthesizer.Dimensional.Straight.Signal",
          "name": "toSamples",
          "normalized": "a(T b)c-\u003eb c",
          "package": "synthesizer",
          "partial": "Samples",
          "signature": "w(T seq)yv-\u003eseq yv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Dimensional-Straight-Signal.html#v:toSamples"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Filter.Basic",
          "name": "Filter",
          "package": "synthesizer",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Filter-Basic.html#Filter",
          "type": "class"
        },
        "index": {
          "hierarchy": "Synthesizer Filter Basic",
          "module": "Synthesizer.Filter.Basic",
          "name": "Filter",
          "package": "synthesizer",
          "partial": "Filter",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Filter-Basic.html#v:Filter"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Apply a filter to a signal. \n",
          "module": "Synthesizer.Filter.Basic",
          "name": "apply",
          "package": "synthesizer",
          "signature": "filter t a v -\u003e list v -\u003e list v",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Filter-Basic.html#apply",
          "type": "function"
        },
        "index": {
          "description": "Apply filter to signal",
          "hierarchy": "Synthesizer Filter Basic",
          "module": "Synthesizer.Filter.Basic",
          "name": "apply",
          "normalized": "a b c d-\u003ee d-\u003ee d",
          "package": "synthesizer",
          "signature": "filter t a v-\u003elist v-\u003elist v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Filter-Basic.html#v:apply"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Filter.Basic",
          "name": "screw",
          "package": "synthesizer",
          "signature": "a -\u003e [T a]",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Filter-Basic.html#screw",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Filter Basic",
          "module": "Synthesizer.Filter.Basic",
          "name": "screw",
          "normalized": "a-\u003e[T a]",
          "package": "synthesizer",
          "signature": "a-\u003e[T a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Filter-Basic.html#v:screw"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Compute the complex amplification factor\n       that is applied to the given frequency. \n",
          "module": "Synthesizer.Filter.Basic",
          "name": "transferFunction",
          "package": "synthesizer",
          "signature": "filter t a v -\u003e t -\u003e T t",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Filter-Basic.html#transferFunction",
          "type": "function"
        },
        "index": {
          "description": "Compute the complex amplification factor that is applied to the given frequency",
          "hierarchy": "Synthesizer Filter Basic",
          "module": "Synthesizer.Filter.Basic",
          "name": "transferFunction",
          "normalized": "a b c d-\u003eb-\u003eT b",
          "package": "synthesizer",
          "partial": "Function",
          "signature": "filter t a v-\u003et-\u003eT t",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Filter-Basic.html#v:transferFunction"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Filter.Composition",
          "name": "SocketSpec",
          "package": "synthesizer",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Filter-Composition.html#SocketSpec",
          "type": "data"
        },
        "index": {
          "hierarchy": "Synthesizer Filter Composition",
          "module": "Synthesizer.Filter.Composition",
          "name": "SocketSpec",
          "package": "synthesizer",
          "partial": "Socket Spec",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Filter-Composition.html#t:SocketSpec"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Filter.Composition",
          "name": "Sockets",
          "package": "synthesizer",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Filter-Composition.html#Sockets",
          "type": "data"
        },
        "index": {
          "hierarchy": "Synthesizer Filter Composition",
          "module": "Synthesizer.Filter.Composition",
          "name": "Sockets",
          "package": "synthesizer",
          "partial": "Sockets",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Filter-Composition.html#t:Sockets"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Filter.Composition",
          "name": "T",
          "package": "synthesizer",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Filter-Composition.html#T",
          "type": "data"
        },
        "index": {
          "hierarchy": "Synthesizer Filter Composition",
          "module": "Synthesizer.Filter.Composition",
          "name": "T",
          "package": "synthesizer",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Filter-Composition.html#t:T"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Apply a filter network to a signal and keep the output of all nodes.\n    Generic function that is wrapped by \u003ctt\u003e\u003ca\u003eapply\u003c/a\u003e\u003c/tt\u003e. \n",
          "module": "Synthesizer.Filter.Composition",
          "name": "applyMulti",
          "package": "synthesizer",
          "signature": "T filter t a v -\u003e list v -\u003e Sockets (list v)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Filter-Composition.html#applyMulti",
          "type": "function"
        },
        "index": {
          "description": "Apply filter network to signal and keep the output of all nodes Generic function that is wrapped by apply",
          "hierarchy": "Synthesizer Filter Composition",
          "module": "Synthesizer.Filter.Composition",
          "name": "applyMulti",
          "normalized": "T a b c d-\u003ee d-\u003eSockets(e d)",
          "package": "synthesizer",
          "partial": "Multi",
          "signature": "T filter t a v-\u003elist v-\u003eSockets(list v)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Filter-Composition.html#v:applyMulti"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Make the results from \u003ctt\u003e\u003ca\u003etfRelative\u003c/a\u003e\u003c/tt\u003e absolute. \n",
          "module": "Synthesizer.Filter.Composition",
          "name": "tfAbsolutize",
          "package": "synthesizer",
          "signature": "a -\u003e Sockets a -\u003e Sockets a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Filter-Composition.html#tfAbsolutize",
          "type": "function"
        },
        "index": {
          "description": "Make the results from tfRelative absolute",
          "hierarchy": "Synthesizer Filter Composition",
          "module": "Synthesizer.Filter.Composition",
          "name": "tfAbsolutize",
          "normalized": "a-\u003eSockets a-\u003eSockets a",
          "package": "synthesizer",
          "partial": "Absolutize",
          "signature": "a-\u003eSockets a-\u003eSockets a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Filter-Composition.html#v:tfAbsolutize"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Compute the transitivity for each part of the filter network.\n    We must do this in such a relative manner to be able\n    to compute feedback. \n",
          "module": "Synthesizer.Filter.Composition",
          "name": "tfRelative",
          "package": "synthesizer",
          "signature": "t -\u003e T filter t a v -\u003e Sockets (T t)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Filter-Composition.html#tfRelative",
          "type": "function"
        },
        "index": {
          "description": "Compute the transitivity for each part of the filter network We must do this in such relative manner to be able to compute feedback",
          "hierarchy": "Synthesizer Filter Composition",
          "module": "Synthesizer.Filter.Composition",
          "name": "tfRelative",
          "normalized": "a-\u003eT b a c d-\u003eSockets(T a)",
          "package": "synthesizer",
          "partial": "Relative",
          "signature": "t-\u003eT filter t a v-\u003eSockets(T t)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Filter-Composition.html#v:tfRelative"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Filter.Composition",
          "name": "transferFunctionMulti",
          "package": "synthesizer",
          "signature": "T filter t a v -\u003e t -\u003e Sockets (T t)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Filter-Composition.html#transferFunctionMulti",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Filter Composition",
          "module": "Synthesizer.Filter.Composition",
          "name": "transferFunctionMulti",
          "normalized": "T a b c d-\u003eb-\u003eSockets(T b)",
          "package": "synthesizer",
          "partial": "Function Multi",
          "signature": "T filter t a v-\u003et-\u003eSockets(T t)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Filter-Composition.html#v:transferFunctionMulti"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Filter.Example",
          "name": "CompositionDouble",
          "package": "synthesizer",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Filter-Example.html#CompositionDouble",
          "type": "type"
        },
        "index": {
          "hierarchy": "Synthesizer Filter Example",
          "module": "Synthesizer.Filter.Example",
          "name": "CompositionDouble",
          "package": "synthesizer",
          "partial": "Composition Double",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Filter-Example.html#t:CompositionDouble"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Filter.Example",
          "name": "GraphDouble",
          "package": "synthesizer",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Filter-Example.html#GraphDouble",
          "type": "type"
        },
        "index": {
          "hierarchy": "Synthesizer Filter Example",
          "module": "Synthesizer.Filter.Example",
          "name": "GraphDouble",
          "package": "synthesizer",
          "partial": "Graph Double",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Filter-Example.html#t:GraphDouble"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "a simple lowpass used to create an exponential2 \n",
          "module": "Synthesizer.Filter.Example",
          "name": "expo",
          "package": "synthesizer",
          "signature": "Signal Double",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Filter-Example.html#expo",
          "type": "function"
        },
        "index": {
          "description": "simple lowpass used to create an exponential2",
          "hierarchy": "Synthesizer Filter Example",
          "module": "Synthesizer.Filter.Example",
          "name": "expo",
          "package": "synthesizer",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Filter-Example.html#v:expo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Filter.Example",
          "name": "expoGraph",
          "package": "synthesizer",
          "signature": "[Double]",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Filter-Example.html#expoGraph",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Filter Example",
          "module": "Synthesizer.Filter.Example",
          "name": "expoGraph",
          "normalized": "[Double]",
          "package": "synthesizer",
          "partial": "Graph",
          "signature": "[Double]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Filter-Example.html#v:expoGraph"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Filter.Example",
          "name": "expoGraphTwoWay",
          "package": "synthesizer",
          "signature": "[Double]",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Filter-Example.html#expoGraphTwoWay",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Filter Example",
          "module": "Synthesizer.Filter.Example",
          "name": "expoGraphTwoWay",
          "normalized": "[Double]",
          "package": "synthesizer",
          "partial": "Graph Two Way",
          "signature": "[Double]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Filter-Example.html#v:expoGraphTwoWay"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "make recursive flanger with help of the two way interpolation \n",
          "module": "Synthesizer.Filter.Example",
          "name": "flangedSaw",
          "package": "synthesizer",
          "signature": "Double -\u003e [Double]",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Filter-Example.html#flangedSaw",
          "type": "function"
        },
        "index": {
          "description": "make recursive flanger with help of the two way interpolation",
          "hierarchy": "Synthesizer Filter Example",
          "module": "Synthesizer.Filter.Example",
          "name": "flangedSaw",
          "normalized": "Double-\u003e[Double]",
          "package": "synthesizer",
          "partial": "Saw",
          "signature": "Double-\u003e[Double]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Filter-Example.html#v:flangedSaw"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Resample the reconstructed string sound\n    so that notes can be played. \n",
          "module": "Synthesizer.Filter.Example",
          "name": "guitar",
          "package": "synthesizer",
          "signature": "a -\u003e [a]",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Filter-Example.html#guitar",
          "type": "function"
        },
        "index": {
          "description": "Resample the reconstructed string sound so that notes can be played",
          "hierarchy": "Synthesizer Filter Example",
          "module": "Synthesizer.Filter.Example",
          "name": "guitar",
          "normalized": "a-\u003e[a]",
          "package": "synthesizer",
          "signature": "a-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Filter-Example.html#v:guitar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Filter.Example",
          "name": "guitarCompLong",
          "package": "synthesizer",
          "signature": "[a] -\u003e T T Double a a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Filter-Example.html#guitarCompLong",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Filter Example",
          "module": "Synthesizer.Filter.Example",
          "name": "guitarCompLong",
          "normalized": "[a]-\u003eT T Double a a",
          "package": "synthesizer",
          "partial": "Comp Long",
          "signature": "[a]-\u003eT T Double a a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Filter-Example.html#v:guitarCompLong"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Filter.Example",
          "name": "guitarCompShort",
          "package": "synthesizer",
          "signature": "[a] -\u003e T T Double a a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Filter-Example.html#guitarCompShort",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Filter Example",
          "module": "Synthesizer.Filter.Example",
          "name": "guitarCompShort",
          "normalized": "[a]-\u003eT T Double a a",
          "package": "synthesizer",
          "partial": "Comp Short",
          "signature": "[a]-\u003eT T Double a a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Filter-Example.html#v:guitarCompShort"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Filter.Example",
          "name": "guitarInit",
          "package": "synthesizer",
          "signature": "[a]",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Filter-Example.html#guitarInit",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Filter Example",
          "module": "Synthesizer.Filter.Example",
          "name": "guitarInit",
          "normalized": "[a]",
          "package": "synthesizer",
          "partial": "Init",
          "signature": "[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Filter-Example.html#v:guitarInit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Reconstruct the guitar sound from the sampled initial wave\n    and the analysed feedback factors.\n    This sounds pretty like the sampled sound. \n",
          "module": "Synthesizer.Filter.Example",
          "name": "guitarRaw",
          "package": "synthesizer",
          "signature": "[a]",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Filter-Example.html#guitarRaw",
          "type": "function"
        },
        "index": {
          "description": "Reconstruct the guitar sound from the sampled initial wave and the analysed feedback factors This sounds pretty like the sampled sound",
          "hierarchy": "Synthesizer Filter Example",
          "module": "Synthesizer.Filter.Example",
          "name": "guitarRaw",
          "normalized": "[a]",
          "package": "synthesizer",
          "partial": "Raw",
          "signature": "[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Filter-Example.html#v:guitarRaw"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Reconstruct the guitar sound from the sampled initial wave\n    but with simple smoothing on feedback.\n    This sounds more statically. \n",
          "module": "Synthesizer.Filter.Example",
          "name": "guitarRawSimple",
          "package": "synthesizer",
          "signature": "[a]",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Filter-Example.html#guitarRawSimple",
          "type": "function"
        },
        "index": {
          "description": "Reconstruct the guitar sound from the sampled initial wave but with simple smoothing on feedback This sounds more statically",
          "hierarchy": "Synthesizer Filter Example",
          "module": "Synthesizer.Filter.Example",
          "name": "guitarRawSimple",
          "normalized": "[a]",
          "package": "synthesizer",
          "partial": "Raw Simple",
          "signature": "[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Filter-Example.html#v:guitarRawSimple"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Reconstruct the guitar sound with the analysed feedback factors\n    but with an synthetic initial wave.\n    The sharpness of the initial wave can be controlled.\n    This is used to implement various velocities. \n",
          "module": "Synthesizer.Filter.Example",
          "name": "guitarRawVelo",
          "package": "synthesizer",
          "signature": "a -\u003e [a]",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Filter-Example.html#guitarRawVelo",
          "type": "function"
        },
        "index": {
          "description": "Reconstruct the guitar sound with the analysed feedback factors but with an synthetic initial wave The sharpness of the initial wave can be controlled This is used to implement various velocities",
          "hierarchy": "Synthesizer Filter Example",
          "module": "Synthesizer.Filter.Example",
          "name": "guitarRawVelo",
          "normalized": "a-\u003e[a]",
          "package": "synthesizer",
          "partial": "Raw Velo",
          "signature": "a-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Filter-Example.html#v:guitarRawVelo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Filter.Example",
          "name": "simpleGraph",
          "package": "synthesizer",
          "signature": "Signal Double",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Filter-Example.html#simpleGraph",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Filter Example",
          "module": "Synthesizer.Filter.Example",
          "name": "simpleGraph",
          "package": "synthesizer",
          "partial": "Graph",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Filter-Example.html#v:simpleGraph"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Filter.Fix",
          "name": "Channel",
          "package": "synthesizer",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Filter-Fix.html#Channel",
          "type": "data"
        },
        "index": {
          "hierarchy": "Synthesizer Filter Fix",
          "module": "Synthesizer.Filter.Fix",
          "name": "Channel",
          "package": "synthesizer",
          "partial": "Channel",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Filter-Fix.html#t:Channel"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Filter.Fix",
          "name": "ChannelId",
          "package": "synthesizer",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Filter-Fix.html#ChannelId",
          "type": "type"
        },
        "index": {
          "hierarchy": "Synthesizer Filter Fix",
          "module": "Synthesizer.Filter.Fix",
          "name": "ChannelId",
          "package": "synthesizer",
          "partial": "Channel Id",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Filter-Fix.html#t:ChannelId"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA \u003ctt\u003e\u003ca\u003eT\u003c/a\u003e\u003c/tt\u003e with numbered nodes is not very comfortable.\nBetter provide a Control.Monad.Fix.fix-like function\nwhich allows to enter a graph this way:\n\u003c/p\u003e\u003cpre\u003e fix $ \\[v,w,y] -\u003e\n [a(u + dw),\n  b(v + ey),\n  c w]\n\u003c/pre\u003e",
          "module": "Synthesizer.Filter.Fix",
          "name": "T",
          "package": "synthesizer",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Filter-Fix.html#T",
          "type": "type"
        },
        "index": {
          "description": "with numbered nodes is not very comfortable Better provide Control.Monad.Fix.fix-like function which allows to enter graph this way fix dw ey",
          "hierarchy": "Synthesizer Filter Fix",
          "module": "Synthesizer.Filter.Fix",
          "name": "T",
          "package": "synthesizer",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Filter-Fix.html#t:T"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Filter.Fix",
          "name": "fix",
          "package": "synthesizer",
          "signature": "T filter t a v -\u003e [Channel filter t a v]",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Filter-Fix.html#fix",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Filter Fix",
          "module": "Synthesizer.Filter.Fix",
          "name": "fix",
          "normalized": "T a b c d-\u003e[Channel a b c d]",
          "package": "synthesizer",
          "signature": "T filter t a v-\u003e[Channel filter t a v]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Filter-Fix.html#v:fix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Filter.Fix",
          "name": "toGraph",
          "package": "synthesizer",
          "signature": "T filter t a v -\u003e T filter Int t a v",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Filter-Fix.html#toGraph",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Filter Fix",
          "module": "Synthesizer.Filter.Fix",
          "name": "toGraph",
          "normalized": "T a b c d-\u003eT a Int b c d",
          "package": "synthesizer",
          "partial": "Graph",
          "signature": "T filter t a v-\u003eT filter Int t a v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Filter-Fix.html#v:toGraph"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Filter.Graph",
          "name": "Signal",
          "package": "synthesizer",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Filter-Graph.html#Signal",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "Synthesizer Filter Graph",
          "module": "Synthesizer.Filter.Graph",
          "name": "Signal",
          "package": "synthesizer",
          "partial": "Signal",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Filter-Graph.html#t:Signal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Filter.Graph",
          "name": "T",
          "package": "synthesizer",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Filter-Graph.html#T",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "Synthesizer Filter Graph",
          "module": "Synthesizer.Filter.Graph",
          "name": "T",
          "package": "synthesizer",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Filter-Graph.html#t:T"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Filter.Graph",
          "name": "apply",
          "package": "synthesizer",
          "signature": "T filter i t a v -\u003e Signal list i v -\u003e Signal list i v",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Filter-Graph.html#apply",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Filter Graph",
          "module": "Synthesizer.Filter.Graph",
          "name": "apply",
          "normalized": "T a b c d e-\u003eSignal f b e-\u003eSignal f b e",
          "package": "synthesizer",
          "signature": "T filter i t a v-\u003eSignal list i v-\u003eSignal list i v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Filter-Graph.html#v:apply"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Filter.Graph",
          "name": "fromList",
          "package": "synthesizer",
          "signature": "[(i, [(i, filter t a v)])] -\u003e T filter i t a v",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Filter-Graph.html#fromList",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Filter Graph",
          "module": "Synthesizer.Filter.Graph",
          "name": "fromList",
          "normalized": "[(a,[(a,b c d e)])]-\u003eT b a c d e",
          "package": "synthesizer",
          "partial": "List",
          "signature": "[(i,[(i,filter t a v)])]-\u003eT filter i t a v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Filter-Graph.html#v:fromList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Filter.Graph",
          "name": "lookupSignal",
          "package": "synthesizer",
          "signature": "Signal list i v -\u003e i -\u003e Maybe (list v)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Filter-Graph.html#lookupSignal",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Filter Graph",
          "module": "Synthesizer.Filter.Graph",
          "name": "lookupSignal",
          "normalized": "Signal a b c-\u003eb-\u003eMaybe(a c)",
          "package": "synthesizer",
          "partial": "Signal",
          "signature": "Signal list i v-\u003ei-\u003eMaybe(list v)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Filter-Graph.html#v:lookupSignal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Filter.Graph",
          "name": "signalFromList",
          "package": "synthesizer",
          "signature": "[(i, list v)] -\u003e Signal list i v",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Filter-Graph.html#signalFromList",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Filter Graph",
          "module": "Synthesizer.Filter.Graph",
          "name": "signalFromList",
          "normalized": "[(a,b c)]-\u003eSignal b a c",
          "package": "synthesizer",
          "partial": "From List",
          "signature": "[(i,list v)]-\u003eSignal list i v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Filter-Graph.html#v:signalFromList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Filter.Graph",
          "name": "signalToList",
          "package": "synthesizer",
          "signature": "Signal list i v -\u003e [(i, list v)]",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Filter-Graph.html#signalToList",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Filter Graph",
          "module": "Synthesizer.Filter.Graph",
          "name": "signalToList",
          "normalized": "Signal a b c-\u003e[(b,a c)]",
          "package": "synthesizer",
          "partial": "To List",
          "signature": "Signal list i v-\u003e[(i,list v)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Filter-Graph.html#v:signalToList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Filter.Graph",
          "name": "toList",
          "package": "synthesizer",
          "signature": "T filter i t a v -\u003e [(i, [(i, filter t a v)])]",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Filter-Graph.html#toList",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Filter Graph",
          "module": "Synthesizer.Filter.Graph",
          "name": "toList",
          "normalized": "T a b c d e-\u003e[(b,[(b,a c d e)])]",
          "package": "synthesizer",
          "partial": "List",
          "signature": "T filter i t a v-\u003e[(i,[(i,filter t a v)])]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Filter-Graph.html#v:toList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCompute a matrix that tells how an input frequency\n    is mapped to the various output nodes.\n\u003c/p\u003e\u003cp\u003eAccording to the formulation given above\n   we have to invert the matrix (I-A).\n\u003c/p\u003e\u003cp\u003eCurrently this is done by a QR decomposition for each frequency.\n   It would be probably faster if we decompose\n   the matrix containing polynomial elements.\n   Then the inverted matrix would consist of some\n   polynomial ratios which can be evaluated for each frequency.\n\u003c/p\u003e",
          "module": "Synthesizer.Filter.Graph",
          "name": "transferFunction",
          "package": "synthesizer",
          "signature": "T filter i t a v -\u003e t -\u003e [[T t]]",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Filter-Graph.html#transferFunction",
          "type": "function"
        },
        "index": {
          "description": "Compute matrix that tells how an input frequency is mapped to the various output nodes According to the formulation given above we have to invert the matrix I-A Currently this is done by QR decomposition for each frequency It would be probably faster if we decompose the matrix containing polynomial elements Then the inverted matrix would consist of some polynomial ratios which can be evaluated for each frequency",
          "hierarchy": "Synthesizer Filter Graph",
          "module": "Synthesizer.Filter.Graph",
          "name": "transferFunction",
          "normalized": "T a b c d e-\u003ec-\u003e[[T c]]",
          "package": "synthesizer",
          "partial": "Function",
          "signature": "T filter i t a v-\u003et-\u003e[[T t]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Filter-Graph.html#v:transferFunction"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIf you find Filter.Fix.T still inconvenient,\nand if you don't care about portability,\nyou can also use the following monad with the \u003ctt\u003emdo\u003c/tt\u003e notation.\n\u003c/p\u003e\u003cpre\u003e mdo\n   v \u003c- a(u + dw)\n   w \u003c- b(v + ey)\n   y \u003c- c w\n\u003c/pre\u003e",
          "module": "Synthesizer.Filter.MonadFix",
          "name": "T",
          "package": "synthesizer",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Filter-MonadFix.html#T",
          "type": "type"
        },
        "index": {
          "description": "If you find Filter.Fix.T still inconvenient and if you don care about portability you can also use the following monad with the mdo notation mdo dw ey",
          "hierarchy": "Synthesizer Filter MonadFix",
          "module": "Synthesizer.Filter.MonadFix",
          "name": "T",
          "package": "synthesizer",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Filter-MonadFix.html#t:T"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Filter.MonadFix",
          "name": "makeChannel",
          "package": "synthesizer",
          "signature": "[(ChannelId, filter t a v)] -\u003e T filter t a v ChannelId",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Filter-MonadFix.html#makeChannel",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Filter MonadFix",
          "module": "Synthesizer.Filter.MonadFix",
          "name": "makeChannel",
          "normalized": "[(ChannelId,a b c d)]-\u003eT a b c d ChannelId",
          "package": "synthesizer",
          "partial": "Channel",
          "signature": "[(ChannelId,filter t a v)]-\u003eT filter t a v ChannelId",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Filter-MonadFix.html#v:makeChannel"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Filter.MonadFix",
          "name": "run",
          "package": "synthesizer",
          "signature": "T filter t a v x -\u003e [Channel filter t a v]",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Filter-MonadFix.html#run",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Filter MonadFix",
          "module": "Synthesizer.Filter.MonadFix",
          "name": "run",
          "normalized": "T a b c d e-\u003e[Channel a b c d]",
          "package": "synthesizer",
          "signature": "T filter t a v x-\u003e[Channel filter t a v]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Filter-MonadFix.html#v:run"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Filter.MonadFix",
          "name": "toGraph",
          "package": "synthesizer",
          "signature": "T filter t a v x -\u003e T filter Int t a v",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Filter-MonadFix.html#toGraph",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Filter MonadFix",
          "module": "Synthesizer.Filter.MonadFix",
          "name": "toGraph",
          "normalized": "T a b c d e-\u003eT a Int b c d",
          "package": "synthesizer",
          "partial": "Graph",
          "signature": "T filter t a v x-\u003eT filter Int t a v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Filter-MonadFix.html#v:toGraph"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Filter.OneWay",
          "name": "Signal",
          "package": "synthesizer",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Filter-OneWay.html#Signal",
          "type": "type"
        },
        "index": {
          "hierarchy": "Synthesizer Filter OneWay",
          "module": "Synthesizer.Filter.OneWay",
          "name": "Signal",
          "package": "synthesizer",
          "partial": "Signal",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Filter-OneWay.html#t:Signal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Filter.OneWay",
          "name": "T",
          "package": "synthesizer",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Filter-OneWay.html#T",
          "type": "data"
        },
        "index": {
          "hierarchy": "Synthesizer Filter OneWay",
          "module": "Synthesizer.Filter.OneWay",
          "name": "T",
          "package": "synthesizer",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Filter-OneWay.html#t:T"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "shift signal in time \n",
          "module": "Synthesizer.Filter.OneWay",
          "name": "delay",
          "package": "synthesizer",
          "signature": "Int -\u003e Signal v -\u003e Signal v",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Filter-OneWay.html#delay",
          "type": "function"
        },
        "index": {
          "description": "shift signal in time",
          "hierarchy": "Synthesizer Filter OneWay",
          "module": "Synthesizer.Filter.OneWay",
          "name": "delay",
          "normalized": "Int-\u003eSignal a-\u003eSignal a",
          "package": "synthesizer",
          "signature": "Int-\u003eSignal v-\u003eSignal v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Filter-OneWay.html#v:delay"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Filter.OneWay",
          "name": "delayOnce",
          "package": "synthesizer",
          "signature": "Signal v -\u003e Signal v",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Filter-OneWay.html#delayOnce",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Filter OneWay",
          "module": "Synthesizer.Filter.OneWay",
          "name": "delayOnce",
          "normalized": "Signal a-\u003eSignal a",
          "package": "synthesizer",
          "partial": "Once",
          "signature": "Signal v-\u003eSignal v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Filter-OneWay.html#v:delayOnce"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Unmodulated non-recursive filter \n",
          "module": "Synthesizer.Filter.OneWay",
          "name": "nonRecursiveFilter",
          "package": "synthesizer",
          "signature": "[a] -\u003e [v] -\u003e [v]",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Filter-OneWay.html#nonRecursiveFilter",
          "type": "function"
        },
        "index": {
          "description": "Unmodulated non-recursive filter",
          "hierarchy": "Synthesizer Filter OneWay",
          "module": "Synthesizer.Filter.OneWay",
          "name": "nonRecursiveFilter",
          "normalized": "[a]-\u003e[b]-\u003e[b]",
          "package": "synthesizer",
          "partial": "Recursive Filter",
          "signature": "[a]-\u003e[v]-\u003e[v]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Filter-OneWay.html#v:nonRecursiveFilter"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Modulated non-recursive filter. \n",
          "module": "Synthesizer.Filter.OneWay",
          "name": "nonRecursiveFilterMod",
          "package": "synthesizer",
          "signature": "[[a]] -\u003e [v] -\u003e [v]",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Filter-OneWay.html#nonRecursiveFilterMod",
          "type": "function"
        },
        "index": {
          "description": "Modulated non-recursive filter",
          "hierarchy": "Synthesizer Filter OneWay",
          "module": "Synthesizer.Filter.OneWay",
          "name": "nonRecursiveFilterMod",
          "normalized": "[[a]]-\u003e[b]-\u003e[b]",
          "package": "synthesizer",
          "partial": "Recursive Filter Mod",
          "signature": "[[a]]-\u003e[v]-\u003e[v]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Filter-OneWay.html#v:nonRecursiveFilterMod"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Filter.TwoWay",
          "name": "Signal",
          "package": "synthesizer",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Filter-TwoWay.html#Signal",
          "type": "data"
        },
        "index": {
          "hierarchy": "Synthesizer Filter TwoWay",
          "module": "Synthesizer.Filter.TwoWay",
          "name": "Signal",
          "package": "synthesizer",
          "partial": "Signal",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Filter-TwoWay.html#t:Signal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Filter.TwoWay",
          "name": "T",
          "package": "synthesizer",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Filter-TwoWay.html#T",
          "type": "data"
        },
        "index": {
          "hierarchy": "Synthesizer Filter TwoWay",
          "module": "Synthesizer.Filter.TwoWay",
          "name": "T",
          "package": "synthesizer",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Filter-TwoWay.html#t:T"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "shift signal in time,\n    keep all values but if required pad with zeros \n",
          "module": "Synthesizer.Filter.TwoWay",
          "name": "delay",
          "package": "synthesizer",
          "signature": "Int -\u003e Signal v -\u003e Signal v",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Filter-TwoWay.html#delay",
          "type": "function"
        },
        "index": {
          "description": "shift signal in time keep all values but if required pad with zeros",
          "hierarchy": "Synthesizer Filter TwoWay",
          "module": "Synthesizer.Filter.TwoWay",
          "name": "delay",
          "normalized": "Int-\u003eSignal a-\u003eSignal a",
          "package": "synthesizer",
          "signature": "Int-\u003eSignal v-\u003eSignal v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Filter-TwoWay.html#v:delay"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "General routine that supports delaying and prefetching\n    using a general one-sample delaying routine. \n",
          "module": "Synthesizer.Filter.TwoWay",
          "name": "delayGen",
          "package": "synthesizer",
          "signature": "(Signal v -\u003e Signal v) -\u003e Int -\u003e Signal v -\u003e Signal v",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Filter-TwoWay.html#delayGen",
          "type": "function"
        },
        "index": {
          "description": "General routine that supports delaying and prefetching using general one-sample delaying routine",
          "hierarchy": "Synthesizer Filter TwoWay",
          "module": "Synthesizer.Filter.TwoWay",
          "name": "delayGen",
          "normalized": "(Signal a-\u003eSignal a)-\u003eInt-\u003eSignal a-\u003eSignal a",
          "package": "synthesizer",
          "partial": "Gen",
          "signature": "(Signal v-\u003eSignal v)-\u003eInt-\u003eSignal v-\u003eSignal v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Filter-TwoWay.html#v:delayGen"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Delay by one sample. \n",
          "module": "Synthesizer.Filter.TwoWay",
          "name": "delayOnce",
          "package": "synthesizer",
          "signature": "Signal v -\u003e Signal v",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Filter-TwoWay.html#delayOnce",
          "type": "function"
        },
        "index": {
          "description": "Delay by one sample",
          "hierarchy": "Synthesizer Filter TwoWay",
          "module": "Synthesizer.Filter.TwoWay",
          "name": "delayOnce",
          "normalized": "Signal a-\u003eSignal a",
          "package": "synthesizer",
          "partial": "Once",
          "signature": "Signal v-\u003eSignal v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Filter-TwoWay.html#v:delayOnce"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "shift signal in time,\n    zero values at either ends will be flushed \n",
          "module": "Synthesizer.Filter.TwoWay",
          "name": "delayOpt",
          "package": "synthesizer",
          "signature": "Int -\u003e Signal v -\u003e Signal v",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Filter-TwoWay.html#delayOpt",
          "type": "function"
        },
        "index": {
          "description": "shift signal in time zero values at either ends will be flushed",
          "hierarchy": "Synthesizer Filter TwoWay",
          "module": "Synthesizer.Filter.TwoWay",
          "name": "delayOpt",
          "normalized": "Int-\u003eSignal a-\u003eSignal a",
          "package": "synthesizer",
          "partial": "Opt",
          "signature": "Int-\u003eSignal v-\u003eSignal v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Filter-TwoWay.html#v:delayOpt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Filter.TwoWay",
          "name": "delayOptOnce",
          "package": "synthesizer",
          "signature": "Signal v -\u003e Signal v",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Filter-TwoWay.html#delayOptOnce",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Filter TwoWay",
          "module": "Synthesizer.Filter.TwoWay",
          "name": "delayOptOnce",
          "normalized": "Signal a-\u003eSignal a",
          "package": "synthesizer",
          "partial": "Opt Once",
          "signature": "Signal v-\u003eSignal v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Filter-TwoWay.html#v:delayOptOnce"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Filter.TwoWay",
          "name": "delayPad",
          "package": "synthesizer",
          "signature": "v -\u003e Int -\u003e Signal v -\u003e Signal v",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Filter-TwoWay.html#delayPad",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Filter TwoWay",
          "module": "Synthesizer.Filter.TwoWay",
          "name": "delayPad",
          "normalized": "a-\u003eInt-\u003eSignal a-\u003eSignal a",
          "package": "synthesizer",
          "partial": "Pad",
          "signature": "v-\u003eInt-\u003eSignal v-\u003eSignal v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Filter-TwoWay.html#v:delayPad"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Filter.TwoWay",
          "name": "delayPadOnce",
          "package": "synthesizer",
          "signature": "v -\u003e Signal v -\u003e Signal v",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Filter-TwoWay.html#delayPadOnce",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Filter TwoWay",
          "module": "Synthesizer.Filter.TwoWay",
          "name": "delayPadOnce",
          "normalized": "a-\u003eSignal a-\u003eSignal a",
          "package": "synthesizer",
          "partial": "Pad Once",
          "signature": "v-\u003eSignal v-\u003eSignal v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Filter-TwoWay.html#v:delayPadOnce"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "for a Signal this means a reversion of the elements \n",
          "module": "Synthesizer.Filter.TwoWay",
          "name": "flipPair",
          "package": "synthesizer",
          "signature": "(a, b) -\u003e (b, a)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Filter-TwoWay.html#flipPair",
          "type": "function"
        },
        "index": {
          "description": "for Signal this means reversion of the elements",
          "hierarchy": "Synthesizer Filter TwoWay",
          "module": "Synthesizer.Filter.TwoWay",
          "name": "flipPair",
          "normalized": "(a,b)-\u003e(b,a)",
          "package": "synthesizer",
          "partial": "Pair",
          "signature": "(a,b)-\u003e(b,a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Filter-TwoWay.html#v:flipPair"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Filter.TwoWay",
          "name": "interpolateCore",
          "package": "synthesizer",
          "signature": "T a b -\u003e a -\u003e Signal a -\u003e Signal b -\u003e Signal b",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Filter-TwoWay.html#interpolateCore",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Filter TwoWay",
          "module": "Synthesizer.Filter.TwoWay",
          "name": "interpolateCore",
          "normalized": "T a b-\u003ea-\u003eSignal a-\u003eSignal b-\u003eSignal b",
          "package": "synthesizer",
          "partial": "Core",
          "signature": "T a b-\u003ea-\u003eSignal a-\u003eSignal b-\u003eSignal b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Filter-TwoWay.html#v:interpolateCore"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Filter.TwoWay",
          "name": "interpolateHalfWay",
          "package": "synthesizer",
          "signature": "T a b -\u003e a -\u003e [a] -\u003e Signal b -\u003e [b]",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Filter-TwoWay.html#interpolateHalfWay",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Filter TwoWay",
          "module": "Synthesizer.Filter.TwoWay",
          "name": "interpolateHalfWay",
          "normalized": "T a b-\u003ea-\u003e[a]-\u003eSignal b-\u003e[b]",
          "package": "synthesizer",
          "partial": "Half Way",
          "signature": "T a b-\u003ea-\u003e[a]-\u003eSignal b-\u003e[b]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Filter-TwoWay.html#v:interpolateHalfWay"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Filter.TwoWay",
          "name": "interpolatePaddedCyclic",
          "package": "synthesizer",
          "signature": "T a b -\u003e a -\u003e Signal a -\u003e Signal b -\u003e Signal b",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Filter-TwoWay.html#interpolatePaddedCyclic",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Filter TwoWay",
          "module": "Synthesizer.Filter.TwoWay",
          "name": "interpolatePaddedCyclic",
          "normalized": "T a b-\u003ea-\u003eSignal a-\u003eSignal b-\u003eSignal b",
          "package": "synthesizer",
          "partial": "Padded Cyclic",
          "signature": "T a b-\u003ea-\u003eSignal a-\u003eSignal b-\u003eSignal b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Filter-TwoWay.html#v:interpolatePaddedCyclic"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Filter.TwoWay",
          "name": "interpolatePaddedExtrapolation",
          "package": "synthesizer",
          "signature": "T a b -\u003e a -\u003e Signal a -\u003e Signal b -\u003e Signal b",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Filter-TwoWay.html#interpolatePaddedExtrapolation",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Filter TwoWay",
          "module": "Synthesizer.Filter.TwoWay",
          "name": "interpolatePaddedExtrapolation",
          "normalized": "T a b-\u003ea-\u003eSignal a-\u003eSignal b-\u003eSignal b",
          "package": "synthesizer",
          "partial": "Padded Extrapolation",
          "signature": "T a b-\u003ea-\u003eSignal a-\u003eSignal b-\u003eSignal b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Filter-TwoWay.html#v:interpolatePaddedExtrapolation"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Interpolation allowing negative frequencies,\n    but requires storage of all past values. \n",
          "module": "Synthesizer.Filter.TwoWay",
          "name": "interpolatePaddedZero",
          "package": "synthesizer",
          "signature": "b -\u003e T a b -\u003e a -\u003e Signal a -\u003e Signal b -\u003e Signal b",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Filter-TwoWay.html#interpolatePaddedZero",
          "type": "function"
        },
        "index": {
          "description": "Interpolation allowing negative frequencies but requires storage of all past values",
          "hierarchy": "Synthesizer Filter TwoWay",
          "module": "Synthesizer.Filter.TwoWay",
          "name": "interpolatePaddedZero",
          "normalized": "a-\u003eT b a-\u003eb-\u003eSignal b-\u003eSignal a-\u003eSignal a",
          "package": "synthesizer",
          "partial": "Padded Zero",
          "signature": "b-\u003eT a b-\u003ea-\u003eSignal a-\u003eSignal b-\u003eSignal b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Filter-TwoWay.html#v:interpolatePaddedZero"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Unmodulated non-recursive filter \n",
          "module": "Synthesizer.Filter.TwoWay",
          "name": "nonRecursiveFilter",
          "package": "synthesizer",
          "signature": "[a] -\u003e Signal v -\u003e Signal v",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Filter-TwoWay.html#nonRecursiveFilter",
          "type": "function"
        },
        "index": {
          "description": "Unmodulated non-recursive filter",
          "hierarchy": "Synthesizer Filter TwoWay",
          "module": "Synthesizer.Filter.TwoWay",
          "name": "nonRecursiveFilter",
          "normalized": "[a]-\u003eSignal b-\u003eSignal b",
          "package": "synthesizer",
          "partial": "Recursive Filter",
          "signature": "[a]-\u003eSignal v-\u003eSignal v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Filter-TwoWay.html#v:nonRecursiveFilter"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Modulated non-recursive filter.\n    The number of values before time 0 (past) or\n    the filter mask lengths must be at most finite. \n",
          "module": "Synthesizer.Filter.TwoWay",
          "name": "nonRecursiveFilterMod",
          "package": "synthesizer",
          "signature": "Signal [a] -\u003e Signal v -\u003e Signal v",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Filter-TwoWay.html#nonRecursiveFilterMod",
          "type": "function"
        },
        "index": {
          "description": "Modulated non-recursive filter The number of values before time past or the filter mask lengths must be at most finite",
          "hierarchy": "Synthesizer Filter TwoWay",
          "module": "Synthesizer.Filter.TwoWay",
          "name": "nonRecursiveFilterMod",
          "normalized": "Signal[a]-\u003eSignal b-\u003eSignal b",
          "package": "synthesizer",
          "partial": "Recursive Filter Mod",
          "signature": "Signal[a]-\u003eSignal v-\u003eSignal v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Filter-TwoWay.html#v:nonRecursiveFilterMod"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "A signal that consists entirely of ones \n",
          "module": "Synthesizer.Filter.TwoWay",
          "name": "ones",
          "package": "synthesizer",
          "signature": "Signal a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Filter-TwoWay.html#ones",
          "type": "function"
        },
        "index": {
          "description": "signal that consists entirely of ones",
          "hierarchy": "Synthesizer Filter TwoWay",
          "module": "Synthesizer.Filter.TwoWay",
          "name": "ones",
          "package": "synthesizer",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Filter-TwoWay.html#v:ones"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Take the value at time zero. \n",
          "module": "Synthesizer.Filter.TwoWay",
          "name": "origin",
          "package": "synthesizer",
          "signature": "Signal a -\u003e a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Filter-TwoWay.html#origin",
          "type": "function"
        },
        "index": {
          "description": "Take the value at time zero",
          "hierarchy": "Synthesizer Filter TwoWay",
          "module": "Synthesizer.Filter.TwoWay",
          "name": "origin",
          "normalized": "Signal a-\u003ea",
          "package": "synthesizer",
          "signature": "Signal a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Filter-TwoWay.html#v:origin"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Filter.TwoWay",
          "name": "reverseTwoWay",
          "package": "synthesizer",
          "signature": "Signal v -\u003e Signal v",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Filter-TwoWay.html#reverseTwoWay",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Filter TwoWay",
          "module": "Synthesizer.Filter.TwoWay",
          "name": "reverseTwoWay",
          "normalized": "Signal a-\u003eSignal a",
          "package": "synthesizer",
          "partial": "Two Way",
          "signature": "Signal v-\u003eSignal v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Filter-TwoWay.html#v:reverseTwoWay"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Take n values starting from time zero.\n    If you want clips from elsewhere,\n    call \u003ctt\u003e\u003ca\u003etake\u003c/a\u003e\u003c/tt\u003e after \u003ctt\u003e\u003ca\u003edelay\u003c/a\u003e\u003c/tt\u003e. \n",
          "module": "Synthesizer.Filter.TwoWay",
          "name": "take",
          "package": "synthesizer",
          "signature": "Int -\u003e Signal v -\u003e [v]",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Filter-TwoWay.html#take",
          "type": "function"
        },
        "index": {
          "description": "Take values starting from time zero If you want clips from elsewhere call take after delay",
          "hierarchy": "Synthesizer Filter TwoWay",
          "module": "Synthesizer.Filter.TwoWay",
          "name": "take",
          "normalized": "Int-\u003eSignal a-\u003e[a]",
          "package": "synthesizer",
          "signature": "Int-\u003eSignal v-\u003e[v]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Filter-TwoWay.html#v:take"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Filter.TwoWay",
          "name": "testDelayGen",
          "package": "synthesizer",
          "signature": "Signal Double",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Filter-TwoWay.html#testDelayGen",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Filter TwoWay",
          "module": "Synthesizer.Filter.TwoWay",
          "name": "testDelayGen",
          "package": "synthesizer",
          "partial": "Delay Gen",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Filter-TwoWay.html#v:testDelayGen"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Filter.TwoWay",
          "name": "zipSignalWith",
          "package": "synthesizer",
          "signature": "(a -\u003e b -\u003e c) -\u003e Signal a -\u003e Signal b -\u003e Signal c",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Filter-TwoWay.html#zipSignalWith",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Filter TwoWay",
          "module": "Synthesizer.Filter.TwoWay",
          "name": "zipSignalWith",
          "normalized": "(a-\u003eb-\u003ec)-\u003eSignal a-\u003eSignal b-\u003eSignal c",
          "package": "synthesizer",
          "partial": "Signal With",
          "signature": "(a-\u003eb-\u003ec)-\u003eSignal a-\u003eSignal b-\u003eSignal c",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Filter-TwoWay.html#v:zipSignalWith"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Format",
          "name": "C",
          "package": "synthesizer",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Format.html#C",
          "type": "class"
        },
        "index": {
          "hierarchy": "Synthesizer Format",
          "module": "Synthesizer.Format",
          "name": "C",
          "package": "synthesizer",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Format.html#v:C"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Format",
          "name": "format",
          "package": "synthesizer",
          "signature": "Int -\u003e sig x -\u003e ShowS",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Format.html#format",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Format",
          "module": "Synthesizer.Format",
          "name": "format",
          "normalized": "Int-\u003ea b-\u003eShowS",
          "package": "synthesizer",
          "signature": "Int-\u003esig x-\u003eShowS",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Format.html#v:format"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Frame.Stereo",
          "name": "T",
          "package": "synthesizer",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Frame-Stereo.html#T",
          "type": "data"
        },
        "index": {
          "hierarchy": "Synthesizer Frame Stereo",
          "module": "Synthesizer.Frame.Stereo",
          "name": "T",
          "package": "synthesizer",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Frame-Stereo.html#t:T"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Frame.Stereo",
          "name": "cons",
          "package": "synthesizer",
          "signature": "a -\u003e a -\u003e T a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Frame-Stereo.html#cons",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Frame Stereo",
          "module": "Synthesizer.Frame.Stereo",
          "name": "cons",
          "normalized": "a-\u003ea-\u003eT a",
          "package": "synthesizer",
          "signature": "a-\u003ea-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Frame-Stereo.html#v:cons"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Frame.Stereo",
          "name": "left",
          "package": "synthesizer",
          "signature": "T a -\u003e a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Frame-Stereo.html#left",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Frame Stereo",
          "module": "Synthesizer.Frame.Stereo",
          "name": "left",
          "normalized": "T a-\u003ea",
          "package": "synthesizer",
          "signature": "T a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Frame-Stereo.html#v:left"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Frame.Stereo",
          "name": "map",
          "package": "synthesizer",
          "signature": "(a -\u003e b) -\u003e T a -\u003e T b",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Frame-Stereo.html#map",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Frame Stereo",
          "module": "Synthesizer.Frame.Stereo",
          "name": "map",
          "normalized": "(a-\u003eb)-\u003eT a-\u003eT b",
          "package": "synthesizer",
          "signature": "(a-\u003eb)-\u003eT a-\u003eT b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Frame-Stereo.html#v:map"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Frame.Stereo",
          "name": "right",
          "package": "synthesizer",
          "signature": "T a -\u003e a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Frame-Stereo.html#right",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Frame Stereo",
          "module": "Synthesizer.Frame.Stereo",
          "name": "right",
          "normalized": "T a-\u003ea",
          "package": "synthesizer",
          "signature": "T a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Frame-Stereo.html#v:right"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.FusionList.Control",
          "name": "Piece",
          "package": "synthesizer",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-FusionList-Control.html#Piece",
          "type": "type"
        },
        "index": {
          "hierarchy": "Synthesizer FusionList Control",
          "module": "Synthesizer.FusionList.Control",
          "name": "Piece",
          "package": "synthesizer",
          "partial": "Piece",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-FusionList-Control.html#t:Piece"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.FusionList.Control",
          "name": "constant",
          "package": "synthesizer",
          "signature": "a -\u003e T a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-FusionList-Control.html#constant",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer FusionList Control",
          "module": "Synthesizer.FusionList.Control",
          "name": "constant",
          "normalized": "a-\u003eT a",
          "package": "synthesizer",
          "signature": "a-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-FusionList-Control.html#v:constant"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "time t0 where  1 is approached \ntime t1 where -1 is approached \na cosine wave where one half wave is between t0 and t1 \n",
          "module": "Synthesizer.FusionList.Control",
          "name": "cosine",
          "package": "synthesizer",
          "signature": "a-\u003e a-\u003e T a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-FusionList-Control.html#cosine",
          "type": "function"
        },
        "index": {
          "description": "time t0 where is approached time t1 where is approached cosine wave where one half wave is between t0 and t1",
          "hierarchy": "Synthesizer FusionList Control",
          "module": "Synthesizer.FusionList.Control",
          "name": "cosine",
          "normalized": "a-\u003ea-\u003eT a",
          "package": "synthesizer",
          "signature": "a-\u003ea-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-FusionList-Control.html#v:cosine"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.FusionList.Control",
          "name": "cosinePiece",
          "package": "synthesizer",
          "signature": "Piece a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-FusionList-Control.html#cosinePiece",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer FusionList Control",
          "module": "Synthesizer.FusionList.Control",
          "name": "cosinePiece",
          "package": "synthesizer",
          "partial": "Piece",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-FusionList-Control.html#v:cosinePiece"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.FusionList.Control",
          "name": "cubicHermite",
          "package": "synthesizer",
          "signature": "(a, (a, a)) -\u003e (a, (a, a)) -\u003e T a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-FusionList-Control.html#cubicHermite",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer FusionList Control",
          "module": "Synthesizer.FusionList.Control",
          "name": "cubicHermite",
          "normalized": "(a,(a,a))-\u003e(a,(a,a))-\u003eT a",
          "package": "synthesizer",
          "partial": "Hermite",
          "signature": "(a,(a,a))-\u003e(a,(a,a))-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-FusionList-Control.html#v:cubicHermite"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.FusionList.Control",
          "name": "cubicPiece",
          "package": "synthesizer",
          "signature": "a -\u003e a -\u003e Piece a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-FusionList-Control.html#cubicPiece",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer FusionList Control",
          "module": "Synthesizer.FusionList.Control",
          "name": "cubicPiece",
          "normalized": "a-\u003ea-\u003ePiece a",
          "package": "synthesizer",
          "partial": "Piece",
          "signature": "a-\u003ea-\u003ePiece a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-FusionList-Control.html#v:cubicPiece"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.FusionList.Control",
          "name": "curveMultiscale",
          "package": "synthesizer",
          "signature": "(y -\u003e y -\u003e y) -\u003e y -\u003e y -\u003e T y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-FusionList-Control.html#curveMultiscale",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer FusionList Control",
          "module": "Synthesizer.FusionList.Control",
          "name": "curveMultiscale",
          "normalized": "(a-\u003ea-\u003ea)-\u003ea-\u003ea-\u003eT a",
          "package": "synthesizer",
          "partial": "Multiscale",
          "signature": "(y-\u003ey-\u003ey)-\u003ey-\u003ey-\u003eT y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-FusionList-Control.html#v:curveMultiscale"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.FusionList.Control",
          "name": "curveMultiscaleNeutral",
          "package": "synthesizer",
          "signature": "(y -\u003e y -\u003e y) -\u003e y -\u003e y -\u003e T y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-FusionList-Control.html#curveMultiscaleNeutral",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer FusionList Control",
          "module": "Synthesizer.FusionList.Control",
          "name": "curveMultiscaleNeutral",
          "normalized": "(a-\u003ea-\u003ea)-\u003ea-\u003ea-\u003eT a",
          "package": "synthesizer",
          "partial": "Multiscale Neutral",
          "signature": "(y-\u003ey-\u003ey)-\u003ey-\u003ey-\u003eT y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-FusionList-Control.html#v:curveMultiscaleNeutral"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "time where the function reaches 1/e of the initial value \ninitial value \nexponential decay \n",
          "module": "Synthesizer.FusionList.Control",
          "name": "exponential",
          "package": "synthesizer",
          "signature": "a-\u003e a-\u003e T a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-FusionList-Control.html#exponential",
          "type": "function"
        },
        "index": {
          "description": "time where the function reaches of the initial value initial value exponential decay",
          "hierarchy": "Synthesizer FusionList Control",
          "module": "Synthesizer.FusionList.Control",
          "name": "exponential",
          "normalized": "a-\u003ea-\u003eT a",
          "package": "synthesizer",
          "signature": "a-\u003ea-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-FusionList-Control.html#v:exponential"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "half life \ninitial value \nexponential decay \n",
          "module": "Synthesizer.FusionList.Control",
          "name": "exponential2",
          "package": "synthesizer",
          "signature": "a-\u003e a-\u003e T a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-FusionList-Control.html#exponential2",
          "type": "function"
        },
        "index": {
          "description": "half life initial value exponential decay",
          "hierarchy": "Synthesizer FusionList Control",
          "module": "Synthesizer.FusionList.Control",
          "name": "exponential2",
          "normalized": "a-\u003ea-\u003eT a",
          "package": "synthesizer",
          "signature": "a-\u003ea-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-FusionList-Control.html#v:exponential2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "half life \ninitial value \nexponential decay \n",
          "module": "Synthesizer.FusionList.Control",
          "name": "exponential2Multiscale",
          "package": "synthesizer",
          "signature": "a-\u003e a-\u003e T a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-FusionList-Control.html#exponential2Multiscale",
          "type": "function"
        },
        "index": {
          "description": "half life initial value exponential decay",
          "hierarchy": "Synthesizer FusionList Control",
          "module": "Synthesizer.FusionList.Control",
          "name": "exponential2Multiscale",
          "normalized": "a-\u003ea-\u003eT a",
          "package": "synthesizer",
          "partial": "Multiscale",
          "signature": "a-\u003ea-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-FusionList-Control.html#v:exponential2Multiscale"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "half life \nexponential decay \n",
          "module": "Synthesizer.FusionList.Control",
          "name": "exponential2MultiscaleNeutral",
          "package": "synthesizer",
          "signature": "y-\u003e T y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-FusionList-Control.html#exponential2MultiscaleNeutral",
          "type": "function"
        },
        "index": {
          "description": "half life exponential decay",
          "hierarchy": "Synthesizer FusionList Control",
          "module": "Synthesizer.FusionList.Control",
          "name": "exponential2MultiscaleNeutral",
          "normalized": "a-\u003eT a",
          "package": "synthesizer",
          "partial": "Multiscale Neutral",
          "signature": "y-\u003eT y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-FusionList-Control.html#v:exponential2MultiscaleNeutral"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "time where the function reaches 1/e of the initial value \ninitial value \nvalue after given time \nexponential decay \n",
          "module": "Synthesizer.FusionList.Control",
          "name": "exponentialFromTo",
          "package": "synthesizer",
          "signature": "y-\u003e y-\u003e y-\u003e T y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-FusionList-Control.html#exponentialFromTo",
          "type": "function"
        },
        "index": {
          "description": "time where the function reaches of the initial value initial value value after given time exponential decay",
          "hierarchy": "Synthesizer FusionList Control",
          "module": "Synthesizer.FusionList.Control",
          "name": "exponentialFromTo",
          "normalized": "a-\u003ea-\u003ea-\u003eT a",
          "package": "synthesizer",
          "partial": "From To",
          "signature": "y-\u003ey-\u003ey-\u003eT y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-FusionList-Control.html#v:exponentialFromTo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "time where the function reaches 1/e of the initial value \ninitial value \nvalue after given time \nexponential decay \n",
          "module": "Synthesizer.FusionList.Control",
          "name": "exponentialFromToMultiscale",
          "package": "synthesizer",
          "signature": "y-\u003e y-\u003e y-\u003e T y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-FusionList-Control.html#exponentialFromToMultiscale",
          "type": "function"
        },
        "index": {
          "description": "time where the function reaches of the initial value initial value value after given time exponential decay",
          "hierarchy": "Synthesizer FusionList Control",
          "module": "Synthesizer.FusionList.Control",
          "name": "exponentialFromToMultiscale",
          "normalized": "a-\u003ea-\u003ea-\u003eT a",
          "package": "synthesizer",
          "partial": "From To Multiscale",
          "signature": "y-\u003ey-\u003ey-\u003eT y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-FusionList-Control.html#v:exponentialFromToMultiscale"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "time where the function reaches 1/e of the initial value \ninitial value \nexponential decay \n",
          "module": "Synthesizer.FusionList.Control",
          "name": "exponentialMultiscale",
          "package": "synthesizer",
          "signature": "a-\u003e a-\u003e T a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-FusionList-Control.html#exponentialMultiscale",
          "type": "function"
        },
        "index": {
          "description": "time where the function reaches of the initial value initial value exponential decay",
          "hierarchy": "Synthesizer FusionList Control",
          "module": "Synthesizer.FusionList.Control",
          "name": "exponentialMultiscale",
          "normalized": "a-\u003ea-\u003eT a",
          "package": "synthesizer",
          "partial": "Multiscale",
          "signature": "a-\u003ea-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-FusionList-Control.html#v:exponentialMultiscale"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "time where the function reaches 1/e of the initial value \nexponential decay \n",
          "module": "Synthesizer.FusionList.Control",
          "name": "exponentialMultiscaleNeutral",
          "package": "synthesizer",
          "signature": "y-\u003e T y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-FusionList-Control.html#exponentialMultiscaleNeutral",
          "type": "function"
        },
        "index": {
          "description": "time where the function reaches of the initial value exponential decay",
          "hierarchy": "Synthesizer FusionList Control",
          "module": "Synthesizer.FusionList.Control",
          "name": "exponentialMultiscaleNeutral",
          "normalized": "a-\u003eT a",
          "package": "synthesizer",
          "partial": "Multiscale Neutral",
          "signature": "y-\u003eT y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-FusionList-Control.html#v:exponentialMultiscaleNeutral"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.FusionList.Control",
          "name": "exponentialPiece",
          "package": "synthesizer",
          "signature": "a -\u003e Piece a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-FusionList-Control.html#exponentialPiece",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer FusionList Control",
          "module": "Synthesizer.FusionList.Control",
          "name": "exponentialPiece",
          "normalized": "a-\u003ePiece a",
          "package": "synthesizer",
          "partial": "Piece",
          "signature": "a-\u003ePiece a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-FusionList-Control.html#v:exponentialPiece"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "steepness \ninitial value \nlinear progression \n",
          "module": "Synthesizer.FusionList.Control",
          "name": "linear",
          "package": "synthesizer",
          "signature": "a-\u003e a-\u003e T a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-FusionList-Control.html#linear",
          "type": "function"
        },
        "index": {
          "description": "steepness initial value linear progression",
          "hierarchy": "Synthesizer FusionList Control",
          "module": "Synthesizer.FusionList.Control",
          "name": "linear",
          "normalized": "a-\u003ea-\u003eT a",
          "package": "synthesizer",
          "signature": "a-\u003ea-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-FusionList-Control.html#v:linear"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "As stable as the addition of time values.\n",
          "module": "Synthesizer.FusionList.Control",
          "name": "linearMultiscale",
          "package": "synthesizer",
          "signature": "y -\u003e y -\u003e T y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-FusionList-Control.html#linearMultiscale",
          "type": "function"
        },
        "index": {
          "description": "As stable as the addition of time values",
          "hierarchy": "Synthesizer FusionList Control",
          "module": "Synthesizer.FusionList.Control",
          "name": "linearMultiscale",
          "normalized": "a-\u003ea-\u003eT a",
          "package": "synthesizer",
          "partial": "Multiscale",
          "signature": "y-\u003ey-\u003eT y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-FusionList-Control.html#v:linearMultiscale"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Linear curve starting at zero.\n",
          "module": "Synthesizer.FusionList.Control",
          "name": "linearMultiscaleNeutral",
          "package": "synthesizer",
          "signature": "y -\u003e T y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-FusionList-Control.html#linearMultiscaleNeutral",
          "type": "function"
        },
        "index": {
          "description": "Linear curve starting at zero",
          "hierarchy": "Synthesizer FusionList Control",
          "module": "Synthesizer.FusionList.Control",
          "name": "linearMultiscaleNeutral",
          "normalized": "a-\u003eT a",
          "package": "synthesizer",
          "partial": "Multiscale Neutral",
          "signature": "y-\u003eT y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-FusionList-Control.html#v:linearMultiscaleNeutral"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.FusionList.Control",
          "name": "linearPiece",
          "package": "synthesizer",
          "signature": "Piece a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-FusionList-Control.html#linearPiece",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer FusionList Control",
          "module": "Synthesizer.FusionList.Control",
          "name": "linearPiece",
          "package": "synthesizer",
          "partial": "Piece",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-FusionList-Control.html#v:linearPiece"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.FusionList.Control",
          "name": "piecewise",
          "package": "synthesizer",
          "signature": "T a a (a -\u003e T a) -\u003e T a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-FusionList-Control.html#piecewise",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer FusionList Control",
          "module": "Synthesizer.FusionList.Control",
          "name": "piecewise",
          "normalized": "T a a(a-\u003eT a)-\u003eT a",
          "package": "synthesizer",
          "signature": "T a a(a-\u003eT a)-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-FusionList-Control.html#v:piecewise"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.FusionList.Control",
          "name": "raise",
          "package": "synthesizer",
          "signature": "a -\u003e T a -\u003e T a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-FusionList-Control.html#raise",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer FusionList Control",
          "module": "Synthesizer.FusionList.Control",
          "name": "raise",
          "normalized": "a-\u003eT a-\u003eT a",
          "package": "synthesizer",
          "signature": "a-\u003eT a-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-FusionList-Control.html#v:raise"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.FusionList.Control",
          "name": "splitDurations",
          "package": "synthesizer",
          "signature": "[t] -\u003e [(Int, t)]",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-FusionList-Control.html#splitDurations",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer FusionList Control",
          "module": "Synthesizer.FusionList.Control",
          "name": "splitDurations",
          "normalized": "[a]-\u003e[(Int,a)]",
          "package": "synthesizer",
          "partial": "Durations",
          "signature": "[t]-\u003e[(Int,t)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-FusionList-Control.html#v:splitDurations"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.FusionList.Control",
          "name": "stepPiece",
          "package": "synthesizer",
          "signature": "Piece a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-FusionList-Control.html#stepPiece",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer FusionList Control",
          "module": "Synthesizer.FusionList.Control",
          "name": "stepPiece",
          "package": "synthesizer",
          "partial": "Piece",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-FusionList-Control.html#v:stepPiece"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "time where the function reaches 1/e of the initial value \ninitial value \nexponential decay \n",
          "module": "Synthesizer.FusionList.Control",
          "name": "vectorExponential",
          "package": "synthesizer",
          "signature": "a-\u003e v-\u003e T v",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-FusionList-Control.html#vectorExponential",
          "type": "function"
        },
        "index": {
          "description": "time where the function reaches of the initial value initial value exponential decay",
          "hierarchy": "Synthesizer FusionList Control",
          "module": "Synthesizer.FusionList.Control",
          "name": "vectorExponential",
          "normalized": "a-\u003eb-\u003eT b",
          "package": "synthesizer",
          "partial": "Exponential",
          "signature": "a-\u003ev-\u003eT v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-FusionList-Control.html#v:vectorExponential"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "half life \ninitial value \nexponential decay \n",
          "module": "Synthesizer.FusionList.Control",
          "name": "vectorExponential2",
          "package": "synthesizer",
          "signature": "a-\u003e v-\u003e T v",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-FusionList-Control.html#vectorExponential2",
          "type": "function"
        },
        "index": {
          "description": "half life initial value exponential decay",
          "hierarchy": "Synthesizer FusionList Control",
          "module": "Synthesizer.FusionList.Control",
          "name": "vectorExponential2",
          "normalized": "a-\u003eb-\u003eT b",
          "package": "synthesizer",
          "partial": "Exponential",
          "signature": "a-\u003ev-\u003eT v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-FusionList-Control.html#v:vectorExponential2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.FusionList.Filter.NonRecursive",
          "name": "amplify",
          "package": "synthesizer",
          "signature": "a -\u003e T a -\u003e T a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-FusionList-Filter-NonRecursive.html#amplify",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer FusionList Filter NonRecursive",
          "module": "Synthesizer.FusionList.Filter.NonRecursive",
          "name": "amplify",
          "normalized": "a-\u003eT a-\u003eT a",
          "package": "synthesizer",
          "signature": "a-\u003eT a-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-FusionList-Filter-NonRecursive.html#v:amplify"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.FusionList.Filter.NonRecursive",
          "name": "amplifyVector",
          "package": "synthesizer",
          "signature": "a -\u003e T v -\u003e T v",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-FusionList-Filter-NonRecursive.html#amplifyVector",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer FusionList Filter NonRecursive",
          "module": "Synthesizer.FusionList.Filter.NonRecursive",
          "name": "amplifyVector",
          "normalized": "a-\u003eT b-\u003eT b",
          "package": "synthesizer",
          "partial": "Vector",
          "signature": "a-\u003eT v-\u003eT v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-FusionList-Filter-NonRecursive.html#v:amplifyVector"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.FusionList.Filter.NonRecursive",
          "name": "binomial",
          "package": "synthesizer",
          "signature": "a -\u003e a -\u003e T v -\u003e T v",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-FusionList-Filter-NonRecursive.html#binomial",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer FusionList Filter NonRecursive",
          "module": "Synthesizer.FusionList.Filter.NonRecursive",
          "name": "binomial",
          "normalized": "a-\u003ea-\u003eT b-\u003eT b",
          "package": "synthesizer",
          "signature": "a-\u003ea-\u003eT v-\u003eT v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-FusionList-Filter-NonRecursive.html#v:binomial"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.FusionList.Filter.NonRecursive",
          "name": "binomial1",
          "package": "synthesizer",
          "signature": "T v -\u003e T v",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-FusionList-Filter-NonRecursive.html#binomial1",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer FusionList Filter NonRecursive",
          "module": "Synthesizer.FusionList.Filter.NonRecursive",
          "name": "binomial1",
          "normalized": "T a-\u003eT a",
          "package": "synthesizer",
          "signature": "T v-\u003eT v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-FusionList-Filter-NonRecursive.html#v:binomial1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.FusionList.Filter.NonRecursive",
          "name": "delay",
          "package": "synthesizer",
          "signature": "Int -\u003e T y -\u003e T y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-FusionList-Filter-NonRecursive.html#delay",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer FusionList Filter NonRecursive",
          "module": "Synthesizer.FusionList.Filter.NonRecursive",
          "name": "delay",
          "normalized": "Int-\u003eT a-\u003eT a",
          "package": "synthesizer",
          "signature": "Int-\u003eT y-\u003eT y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-FusionList-Filter-NonRecursive.html#v:delay"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.FusionList.Filter.NonRecursive",
          "name": "delayPad",
          "package": "synthesizer",
          "signature": "y -\u003e Int -\u003e T y -\u003e T y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-FusionList-Filter-NonRecursive.html#delayPad",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer FusionList Filter NonRecursive",
          "module": "Synthesizer.FusionList.Filter.NonRecursive",
          "name": "delayPad",
          "normalized": "a-\u003eInt-\u003eT a-\u003eT a",
          "package": "synthesizer",
          "partial": "Pad",
          "signature": "y-\u003eInt-\u003eT y-\u003eT y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-FusionList-Filter-NonRecursive.html#v:delayPad"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Forward difference quotient.\nShortens the signal by one.\nInverts Synthesizer.Plain.Filter.Recursive.Integration.run in the sense that\n\u003ctt\u003edifferentiate (zero : integrate x) == x\u003c/tt\u003e.\nThe signal is shifted by a half time unit.\n",
          "module": "Synthesizer.FusionList.Filter.NonRecursive",
          "name": "differentiate",
          "package": "synthesizer",
          "signature": "T v -\u003e T v",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-FusionList-Filter-NonRecursive.html#differentiate",
          "type": "function"
        },
        "index": {
          "description": "Forward difference quotient Shortens the signal by one Inverts Synthesizer.Plain.Filter.Recursive.Integration.run in the sense that differentiate zero integrate The signal is shifted by half time unit",
          "hierarchy": "Synthesizer FusionList Filter NonRecursive",
          "module": "Synthesizer.FusionList.Filter.NonRecursive",
          "name": "differentiate",
          "normalized": "T a-\u003eT a",
          "package": "synthesizer",
          "signature": "T v-\u003eT v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-FusionList-Filter-NonRecursive.html#v:differentiate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Second derivative.\nIt is \u003ctt\u003edifferentiate2 == differentiate . differentiate\u003c/tt\u003e\nbut \u003ctt\u003e\u003ca\u003edifferentiate2\u003c/a\u003e\u003c/tt\u003e should be faster.\n",
          "module": "Synthesizer.FusionList.Filter.NonRecursive",
          "name": "differentiate2",
          "package": "synthesizer",
          "signature": "T v -\u003e T v",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-FusionList-Filter-NonRecursive.html#differentiate2",
          "type": "function"
        },
        "index": {
          "description": "Second derivative It is differentiate2 differentiate differentiate but differentiate2 should be faster",
          "hierarchy": "Synthesizer FusionList Filter NonRecursive",
          "module": "Synthesizer.FusionList.Filter.NonRecursive",
          "name": "differentiate2",
          "normalized": "T a-\u003eT a",
          "package": "synthesizer",
          "signature": "T v-\u003eT v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-FusionList-Filter-NonRecursive.html#v:differentiate2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCentral difference quotient.\nShortens the signal by two elements,\nand shifts the signal by one element.\n(Which can be fixed by prepending an appropriate value.)\nFor linear functions this will yield\nessentially the same result as \u003ctt\u003e\u003ca\u003edifferentiate\u003c/a\u003e\u003c/tt\u003e.\nYou obtain the result of \u003ctt\u003e\u003ca\u003edifferentiateCenter\u003c/a\u003e\u003c/tt\u003e\nif you smooth the one of \u003ctt\u003e\u003ca\u003edifferentiate\u003c/a\u003e\u003c/tt\u003e\nby averaging pairs of adjacent values.\n\u003c/p\u003e\u003cp\u003eToDo: Vector variant\n\u003c/p\u003e",
          "module": "Synthesizer.FusionList.Filter.NonRecursive",
          "name": "differentiateCenter",
          "package": "synthesizer",
          "signature": "T v -\u003e T v",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-FusionList-Filter-NonRecursive.html#differentiateCenter",
          "type": "function"
        },
        "index": {
          "description": "Central difference quotient Shortens the signal by two elements and shifts the signal by one element Which can be fixed by prepending an appropriate value For linear functions this will yield essentially the same result as differentiate You obtain the result of differentiateCenter if you smooth the one of differentiate by averaging pairs of adjacent values ToDo Vector variant",
          "hierarchy": "Synthesizer FusionList Filter NonRecursive",
          "module": "Synthesizer.FusionList.Filter.NonRecursive",
          "name": "differentiateCenter",
          "normalized": "T a-\u003eT a",
          "package": "synthesizer",
          "partial": "Center",
          "signature": "T v-\u003eT v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-FusionList-Filter-NonRecursive.html#v:differentiateCenter"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "the envelope \nthe signal to be enveloped \n",
          "module": "Synthesizer.FusionList.Filter.NonRecursive",
          "name": "envelope",
          "package": "synthesizer",
          "signature": "T a-\u003e T a-\u003e T a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-FusionList-Filter-NonRecursive.html#envelope",
          "type": "function"
        },
        "index": {
          "description": "the envelope the signal to be enveloped",
          "hierarchy": "Synthesizer FusionList Filter NonRecursive",
          "module": "Synthesizer.FusionList.Filter.NonRecursive",
          "name": "envelope",
          "normalized": "T a-\u003eT a-\u003eT a",
          "package": "synthesizer",
          "signature": "T a-\u003eT a-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-FusionList-Filter-NonRecursive.html#v:envelope"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "the envelope \nthe signal to be enveloped \n",
          "module": "Synthesizer.FusionList.Filter.NonRecursive",
          "name": "envelopeVector",
          "package": "synthesizer",
          "signature": "T a-\u003e T v-\u003e T v",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-FusionList-Filter-NonRecursive.html#envelopeVector",
          "type": "function"
        },
        "index": {
          "description": "the envelope the signal to be enveloped",
          "hierarchy": "Synthesizer FusionList Filter NonRecursive",
          "module": "Synthesizer.FusionList.Filter.NonRecursive",
          "name": "envelopeVector",
          "normalized": "T a-\u003eT b-\u003eT b",
          "package": "synthesizer",
          "partial": "Vector",
          "signature": "T a-\u003eT v-\u003eT v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-FusionList-Filter-NonRecursive.html#v:envelopeVector"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.FusionList.Filter.NonRecursive",
          "name": "fadeInOut",
          "package": "synthesizer",
          "signature": "Int -\u003e Int -\u003e Int -\u003e T a -\u003e T a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-FusionList-Filter-NonRecursive.html#fadeInOut",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer FusionList Filter NonRecursive",
          "module": "Synthesizer.FusionList.Filter.NonRecursive",
          "name": "fadeInOut",
          "normalized": "Int-\u003eInt-\u003eInt-\u003eT a-\u003eT a",
          "package": "synthesizer",
          "partial": "In Out",
          "signature": "Int-\u003eInt-\u003eInt-\u003eT a-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-FusionList-Filter-NonRecursive.html#v:fadeInOut"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.FusionList.Filter.NonRecursive",
          "name": "fadeInOutStored",
          "package": "synthesizer",
          "signature": "Int -\u003e Int -\u003e Int -\u003e T a -\u003e T a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-FusionList-Filter-NonRecursive.html#fadeInOutStored",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer FusionList Filter NonRecursive",
          "module": "Synthesizer.FusionList.Filter.NonRecursive",
          "name": "fadeInOutStored",
          "normalized": "Int-\u003eInt-\u003eInt-\u003eT a-\u003eT a",
          "package": "synthesizer",
          "partial": "In Out Stored",
          "signature": "Int-\u003eInt-\u003eInt-\u003eT a-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-FusionList-Filter-NonRecursive.html#v:fadeInOutStored"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Unmodulated non-recursive filter \n",
          "module": "Synthesizer.FusionList.Filter.NonRecursive",
          "name": "generic",
          "package": "synthesizer",
          "signature": "T a -\u003e T v -\u003e T v",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-FusionList-Filter-NonRecursive.html#generic",
          "type": "function"
        },
        "index": {
          "description": "Unmodulated non-recursive filter",
          "hierarchy": "Synthesizer FusionList Filter NonRecursive",
          "module": "Synthesizer.FusionList.Filter.NonRecursive",
          "name": "generic",
          "normalized": "T a-\u003eT b-\u003eT b",
          "package": "synthesizer",
          "signature": "T a-\u003eT v-\u003eT v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-FusionList-Filter-NonRecursive.html#v:generic"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Compute the variance of the Gaussian\n  such that its Fourier transform has value \u003ctt\u003eratio\u003c/tt\u003e at frequency \u003ctt\u003efreq\u003c/tt\u003e.\n",
          "module": "Synthesizer.FusionList.Filter.NonRecursive",
          "name": "ratioFreqToVariance",
          "package": "synthesizer",
          "signature": "a -\u003e a -\u003e a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-FusionList-Filter-NonRecursive.html#ratioFreqToVariance",
          "type": "function"
        },
        "index": {
          "description": "Compute the variance of the Gaussian such that its Fourier transform has value ratio at frequency freq",
          "hierarchy": "Synthesizer FusionList Filter NonRecursive",
          "module": "Synthesizer.FusionList.Filter.NonRecursive",
          "name": "ratioFreqToVariance",
          "normalized": "a-\u003ea-\u003ea",
          "package": "synthesizer",
          "partial": "Freq To Variance",
          "signature": "a-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-FusionList-Filter-NonRecursive.html#v:ratioFreqToVariance"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Moving (uniformly weighted) average in the most trivial form.\nThis is very slow and needs about \u003ctt\u003en * length x\u003c/tt\u003e operations.\n",
          "module": "Synthesizer.FusionList.Filter.NonRecursive",
          "name": "sums",
          "package": "synthesizer",
          "signature": "Int -\u003e T v -\u003e T v",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-FusionList-Filter-NonRecursive.html#sums",
          "type": "function"
        },
        "index": {
          "description": "Moving uniformly weighted average in the most trivial form This is very slow and needs about length operations",
          "hierarchy": "Synthesizer FusionList Filter NonRecursive",
          "module": "Synthesizer.FusionList.Filter.NonRecursive",
          "name": "sums",
          "normalized": "Int-\u003eT a-\u003eT a",
          "package": "synthesizer",
          "signature": "Int-\u003eT v-\u003eT v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-FusionList-Filter-NonRecursive.html#v:sums"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "oscillator with modulated frequency \n",
          "module": "Synthesizer.FusionList.Oscillator",
          "name": "freqMod",
          "package": "synthesizer",
          "signature": "T a b -\u003e T a -\u003e T a -\u003e T b",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-FusionList-Oscillator.html#freqMod",
          "type": "function"
        },
        "index": {
          "description": "oscillator with modulated frequency",
          "hierarchy": "Synthesizer FusionList Oscillator",
          "module": "Synthesizer.FusionList.Oscillator",
          "name": "freqMod",
          "normalized": "T a b-\u003eT a-\u003eT a-\u003eT b",
          "package": "synthesizer",
          "partial": "Mod",
          "signature": "T a b-\u003eT a-\u003eT a-\u003eT b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-FusionList-Oscillator.html#v:freqMod"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "saw tooth oscillator with modulated frequency \n",
          "module": "Synthesizer.FusionList.Oscillator",
          "name": "freqModSaw",
          "package": "synthesizer",
          "signature": "T a -\u003e T a -\u003e T a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-FusionList-Oscillator.html#freqModSaw",
          "type": "function"
        },
        "index": {
          "description": "saw tooth oscillator with modulated frequency",
          "hierarchy": "Synthesizer FusionList Oscillator",
          "module": "Synthesizer.FusionList.Oscillator",
          "name": "freqModSaw",
          "normalized": "T a-\u003eT a-\u003eT a",
          "package": "synthesizer",
          "partial": "Mod Saw",
          "signature": "T a-\u003eT a-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-FusionList-Oscillator.html#v:freqModSaw"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "sine oscillator with modulated frequency \n",
          "module": "Synthesizer.FusionList.Oscillator",
          "name": "freqModSine",
          "package": "synthesizer",
          "signature": "T a -\u003e T a -\u003e T a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-FusionList-Oscillator.html#freqModSine",
          "type": "function"
        },
        "index": {
          "description": "sine oscillator with modulated frequency",
          "hierarchy": "Synthesizer FusionList Oscillator",
          "module": "Synthesizer.FusionList.Oscillator",
          "name": "freqModSine",
          "normalized": "T a-\u003eT a-\u003eT a",
          "package": "synthesizer",
          "partial": "Mod Sine",
          "signature": "T a-\u003eT a-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-FusionList-Oscillator.html#v:freqModSine"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Convert a list of phase steps into a list of momentum phases\n     phase is a number in the interval [0,1)\n     freq contains the phase steps \n",
          "module": "Synthesizer.FusionList.Oscillator",
          "name": "freqToPhase",
          "package": "synthesizer",
          "signature": "T a -\u003e T a -\u003e T (T a)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-FusionList-Oscillator.html#freqToPhase",
          "type": "function"
        },
        "index": {
          "description": "Convert list of phase steps into list of momentum phases phase is number in the interval freq contains the phase steps",
          "hierarchy": "Synthesizer FusionList Oscillator",
          "module": "Synthesizer.FusionList.Oscillator",
          "name": "freqToPhase",
          "normalized": "T a-\u003eT a-\u003eT(T a)",
          "package": "synthesizer",
          "partial": "To Phase",
          "signature": "T a-\u003eT a-\u003eT(T a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-FusionList-Oscillator.html#v:freqToPhase"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "oscillator with both phase and frequency modulation \n",
          "module": "Synthesizer.FusionList.Oscillator",
          "name": "phaseFreqMod",
          "package": "synthesizer",
          "signature": "T a b -\u003e T a -\u003e T a -\u003e T b",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-FusionList-Oscillator.html#phaseFreqMod",
          "type": "function"
        },
        "index": {
          "description": "oscillator with both phase and frequency modulation",
          "hierarchy": "Synthesizer FusionList Oscillator",
          "module": "Synthesizer.FusionList.Oscillator",
          "name": "phaseFreqMod",
          "normalized": "T a b-\u003eT a-\u003eT a-\u003eT b",
          "package": "synthesizer",
          "partial": "Freq Mod",
          "signature": "T a b-\u003eT a-\u003eT a-\u003eT b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-FusionList-Oscillator.html#v:phaseFreqMod"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "oscillator with modulated phase \n",
          "module": "Synthesizer.FusionList.Oscillator",
          "name": "phaseMod",
          "package": "synthesizer",
          "signature": "T a b -\u003e a -\u003e T a -\u003e T b",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-FusionList-Oscillator.html#phaseMod",
          "type": "function"
        },
        "index": {
          "description": "oscillator with modulated phase",
          "hierarchy": "Synthesizer FusionList Oscillator",
          "module": "Synthesizer.FusionList.Oscillator",
          "name": "phaseMod",
          "normalized": "T a b-\u003ea-\u003eT a-\u003eT b",
          "package": "synthesizer",
          "partial": "Mod",
          "signature": "T a b-\u003ea-\u003eT a-\u003eT b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-FusionList-Oscillator.html#v:phaseMod"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "sine oscillator with modulated phase, useful for FM synthesis \n",
          "module": "Synthesizer.FusionList.Oscillator",
          "name": "phaseModSine",
          "package": "synthesizer",
          "signature": "a -\u003e T a -\u003e T a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-FusionList-Oscillator.html#phaseModSine",
          "type": "function"
        },
        "index": {
          "description": "sine oscillator with modulated phase useful for FM synthesis",
          "hierarchy": "Synthesizer FusionList Oscillator",
          "module": "Synthesizer.FusionList.Oscillator",
          "name": "phaseModSine",
          "normalized": "a-\u003eT a-\u003eT a",
          "package": "synthesizer",
          "partial": "Mod Sine",
          "signature": "a-\u003eT a-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-FusionList-Oscillator.html#v:phaseModSine"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "oscillator with both shape and frequency modulation \n",
          "module": "Synthesizer.FusionList.Oscillator",
          "name": "shapeFreqMod",
          "package": "synthesizer",
          "signature": "(c -\u003e T a b) -\u003e T a -\u003e T c -\u003e T a -\u003e T b",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-FusionList-Oscillator.html#shapeFreqMod",
          "type": "function"
        },
        "index": {
          "description": "oscillator with both shape and frequency modulation",
          "hierarchy": "Synthesizer FusionList Oscillator",
          "module": "Synthesizer.FusionList.Oscillator",
          "name": "shapeFreqMod",
          "normalized": "(a-\u003eT b c)-\u003eT b-\u003eT a-\u003eT b-\u003eT c",
          "package": "synthesizer",
          "partial": "Freq Mod",
          "signature": "(c-\u003eT a b)-\u003eT a-\u003eT c-\u003eT a-\u003eT b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-FusionList-Oscillator.html#v:shapeFreqMod"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "oscillator with modulated shape \n",
          "module": "Synthesizer.FusionList.Oscillator",
          "name": "shapeMod",
          "package": "synthesizer",
          "signature": "(c -\u003e T a b) -\u003e T a -\u003e a -\u003e T c -\u003e T b",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-FusionList-Oscillator.html#shapeMod",
          "type": "function"
        },
        "index": {
          "description": "oscillator with modulated shape",
          "hierarchy": "Synthesizer FusionList Oscillator",
          "module": "Synthesizer.FusionList.Oscillator",
          "name": "shapeMod",
          "normalized": "(a-\u003eT b c)-\u003eT b-\u003eb-\u003eT a-\u003eT c",
          "package": "synthesizer",
          "partial": "Mod",
          "signature": "(c-\u003eT a b)-\u003eT a-\u003ea-\u003eT c-\u003eT b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-FusionList-Oscillator.html#v:shapeMod"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "oscillator with constant frequency \n",
          "module": "Synthesizer.FusionList.Oscillator",
          "name": "static",
          "package": "synthesizer",
          "signature": "T a b -\u003e T a -\u003e a -\u003e T b",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-FusionList-Oscillator.html#static",
          "type": "function"
        },
        "index": {
          "description": "oscillator with constant frequency",
          "hierarchy": "Synthesizer FusionList Oscillator",
          "module": "Synthesizer.FusionList.Oscillator",
          "name": "static",
          "normalized": "T a b-\u003eT a-\u003ea-\u003eT b",
          "package": "synthesizer",
          "signature": "T a b-\u003eT a-\u003ea-\u003eT b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-FusionList-Oscillator.html#v:static"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "saw tooth oscillator with modulated frequency \n",
          "module": "Synthesizer.FusionList.Oscillator",
          "name": "staticSaw",
          "package": "synthesizer",
          "signature": "T a -\u003e a -\u003e T a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-FusionList-Oscillator.html#staticSaw",
          "type": "function"
        },
        "index": {
          "description": "saw tooth oscillator with modulated frequency",
          "hierarchy": "Synthesizer FusionList Oscillator",
          "module": "Synthesizer.FusionList.Oscillator",
          "name": "staticSaw",
          "normalized": "T a-\u003ea-\u003eT a",
          "package": "synthesizer",
          "partial": "Saw",
          "signature": "T a-\u003ea-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-FusionList-Oscillator.html#v:staticSaw"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "sine oscillator with static frequency \n",
          "module": "Synthesizer.FusionList.Oscillator",
          "name": "staticSine",
          "package": "synthesizer",
          "signature": "T a -\u003e a -\u003e T a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-FusionList-Oscillator.html#staticSine",
          "type": "function"
        },
        "index": {
          "description": "sine oscillator with static frequency",
          "hierarchy": "Synthesizer FusionList Oscillator",
          "module": "Synthesizer.FusionList.Oscillator",
          "name": "staticSine",
          "normalized": "T a-\u003ea-\u003eT a",
          "package": "synthesizer",
          "partial": "Sine",
          "signature": "T a-\u003ea-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-FusionList-Oscillator.html#v:staticSine"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.FusionList.Signal",
          "name": "T",
          "package": "synthesizer",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-FusionList-Signal.html#T",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "Synthesizer FusionList Signal",
          "module": "Synthesizer.FusionList.Signal",
          "name": "T",
          "package": "synthesizer",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-FusionList-Signal.html#t:T"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.FusionList.Signal",
          "name": "append",
          "package": "synthesizer",
          "signature": "T a -\u003e T a -\u003e T a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-FusionList-Signal.html#append",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer FusionList Signal",
          "module": "Synthesizer.FusionList.Signal",
          "name": "append",
          "normalized": "T a-\u003eT a-\u003eT a",
          "package": "synthesizer",
          "signature": "T a-\u003eT a-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-FusionList-Signal.html#v:append"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.FusionList.Signal",
          "name": "concat",
          "package": "synthesizer",
          "signature": "[T a] -\u003e T a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-FusionList-Signal.html#concat",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer FusionList Signal",
          "module": "Synthesizer.FusionList.Signal",
          "name": "concat",
          "normalized": "[T a]-\u003eT a",
          "package": "synthesizer",
          "signature": "[T a]-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-FusionList-Signal.html#v:concat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.FusionList.Signal",
          "name": "cons",
          "package": "synthesizer",
          "signature": "a -\u003e T a -\u003e T a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-FusionList-Signal.html#cons",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer FusionList Signal",
          "module": "Synthesizer.FusionList.Signal",
          "name": "cons",
          "normalized": "a-\u003eT a-\u003eT a",
          "package": "synthesizer",
          "signature": "a-\u003eT a-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-FusionList-Signal.html#v:cons"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.FusionList.Signal",
          "name": "crochetL",
          "package": "synthesizer",
          "signature": "(x -\u003e acc -\u003e Maybe (y, acc)) -\u003e acc -\u003e T x -\u003e T y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-FusionList-Signal.html#crochetL",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer FusionList Signal",
          "module": "Synthesizer.FusionList.Signal",
          "name": "crochetL",
          "normalized": "(a-\u003eb-\u003eMaybe(c,b))-\u003eb-\u003eT a-\u003eT c",
          "package": "synthesizer",
          "signature": "(x-\u003eacc-\u003eMaybe(y,acc))-\u003eacc-\u003eT x-\u003eT y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-FusionList-Signal.html#v:crochetL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.FusionList.Signal",
          "name": "crochetLCons",
          "package": "synthesizer",
          "signature": "(a -\u003e acc -\u003e Maybe (b, acc)) -\u003e acc -\u003e a -\u003e T a -\u003e T b",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-FusionList-Signal.html#crochetLCons",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer FusionList Signal",
          "module": "Synthesizer.FusionList.Signal",
          "name": "crochetLCons",
          "normalized": "(a-\u003eb-\u003eMaybe(c,b))-\u003eb-\u003ea-\u003eT a-\u003eT c",
          "package": "synthesizer",
          "partial": "LCons",
          "signature": "(a-\u003eacc-\u003eMaybe(b,acc))-\u003eacc-\u003ea-\u003eT a-\u003eT b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-FusionList-Signal.html#v:crochetLCons"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.FusionList.Signal",
          "name": "cycle",
          "package": "synthesizer",
          "signature": "T a -\u003e T a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-FusionList-Signal.html#cycle",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer FusionList Signal",
          "module": "Synthesizer.FusionList.Signal",
          "name": "cycle",
          "normalized": "T a-\u003eT a",
          "package": "synthesizer",
          "signature": "T a-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-FusionList-Signal.html#v:cycle"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.FusionList.Signal",
          "name": "delay",
          "package": "synthesizer",
          "signature": "y -\u003e Int -\u003e T y -\u003e T y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-FusionList-Signal.html#delay",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer FusionList Signal",
          "module": "Synthesizer.FusionList.Signal",
          "name": "delay",
          "normalized": "a-\u003eInt-\u003eT a-\u003eT a",
          "package": "synthesizer",
          "signature": "y-\u003eInt-\u003eT y-\u003eT y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-FusionList-Signal.html#v:delay"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "This is a fusion friendly implementation of delay.\nHowever, in order to be a \u003ctt\u003e\u003ca\u003ecrochetL\u003c/a\u003e\u003c/tt\u003e\nthe output has the same length as the input,\nthat is, the last element is removed - at least for finite input.\n",
          "module": "Synthesizer.FusionList.Signal",
          "name": "delay1",
          "package": "synthesizer",
          "signature": "a -\u003e T a -\u003e T a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-FusionList-Signal.html#delay1",
          "type": "function"
        },
        "index": {
          "description": "This is fusion friendly implementation of delay However in order to be crochetL the output has the same length as the input that is the last element is removed at least for finite input",
          "hierarchy": "Synthesizer FusionList Signal",
          "module": "Synthesizer.FusionList.Signal",
          "name": "delay1",
          "normalized": "a-\u003eT a-\u003eT a",
          "package": "synthesizer",
          "signature": "a-\u003eT a-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-FusionList-Signal.html#v:delay1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "processor that shall be run in a feedback loop\nprefix of the output, its length determines the delay\n",
          "module": "Synthesizer.FusionList.Signal",
          "name": "delayLoop",
          "package": "synthesizer",
          "signature": "T y -\u003e T y-\u003e T y-\u003e T y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-FusionList-Signal.html#delayLoop",
          "type": "function"
        },
        "index": {
          "description": "processor that shall be run in feedback loop prefix of the output its length determines the delay",
          "hierarchy": "Synthesizer FusionList Signal",
          "module": "Synthesizer.FusionList.Signal",
          "name": "delayLoop",
          "normalized": "T a-\u003eT a-\u003eT a-\u003eT a",
          "package": "synthesizer",
          "partial": "Loop",
          "signature": "T y-\u003eT y-\u003eT y-\u003eT y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-FusionList-Signal.html#v:delayLoop"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "processor that shall be run in a feedback loop\ninput\noutput has the same length as the input\n",
          "module": "Synthesizer.FusionList.Signal",
          "name": "delayLoopOverlap",
          "package": "synthesizer",
          "signature": "Int-\u003e T y -\u003e T y-\u003e T y-\u003e T y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-FusionList-Signal.html#delayLoopOverlap",
          "type": "function"
        },
        "index": {
          "description": "processor that shall be run in feedback loop input output has the same length as the input",
          "hierarchy": "Synthesizer FusionList Signal",
          "module": "Synthesizer.FusionList.Signal",
          "name": "delayLoopOverlap",
          "normalized": "Int-\u003eT a-\u003eT a-\u003eT a-\u003eT a",
          "package": "synthesizer",
          "partial": "Loop Overlap",
          "signature": "Int-\u003eT y-\u003eT y-\u003eT y-\u003eT y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-FusionList-Signal.html#v:delayLoopOverlap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.FusionList.Signal",
          "name": "drop",
          "package": "synthesizer",
          "signature": "Int -\u003e T a -\u003e T a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-FusionList-Signal.html#drop",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer FusionList Signal",
          "module": "Synthesizer.FusionList.Signal",
          "name": "drop",
          "normalized": "Int-\u003eT a-\u003eT a",
          "package": "synthesizer",
          "signature": "Int-\u003eT a-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-FusionList-Signal.html#v:drop"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.FusionList.Signal",
          "name": "dropMargin",
          "package": "synthesizer",
          "signature": "Int -\u003e Int -\u003e T a -\u003e T a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-FusionList-Signal.html#dropMargin",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer FusionList Signal",
          "module": "Synthesizer.FusionList.Signal",
          "name": "dropMargin",
          "normalized": "Int-\u003eInt-\u003eT a-\u003eT a",
          "package": "synthesizer",
          "partial": "Margin",
          "signature": "Int-\u003eInt-\u003eT a-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-FusionList-Signal.html#v:dropMargin"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.FusionList.Signal",
          "name": "dropMarginRem",
          "package": "synthesizer",
          "signature": "Int -\u003e Int -\u003e T a -\u003e (Int, T a)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-FusionList-Signal.html#dropMarginRem",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer FusionList Signal",
          "module": "Synthesizer.FusionList.Signal",
          "name": "dropMarginRem",
          "normalized": "Int-\u003eInt-\u003eT a-\u003e(Int,T a)",
          "package": "synthesizer",
          "partial": "Margin Rem",
          "signature": "Int-\u003eInt-\u003eT a-\u003e(Int,T a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-FusionList-Signal.html#v:dropMarginRem"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.FusionList.Signal",
          "name": "dropWhile",
          "package": "synthesizer",
          "signature": "(a -\u003e Bool) -\u003e T a -\u003e T a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-FusionList-Signal.html#dropWhile",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer FusionList Signal",
          "module": "Synthesizer.FusionList.Signal",
          "name": "dropWhile",
          "normalized": "(a-\u003eBool)-\u003eT a-\u003eT a",
          "package": "synthesizer",
          "partial": "While",
          "signature": "(a-\u003eBool)-\u003eT a-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-FusionList-Signal.html#v:dropWhile"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.FusionList.Signal",
          "name": "empty",
          "package": "synthesizer",
          "signature": "T a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-FusionList-Signal.html#empty",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer FusionList Signal",
          "module": "Synthesizer.FusionList.Signal",
          "name": "empty",
          "package": "synthesizer",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-FusionList-Signal.html#v:empty"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.FusionList.Signal",
          "name": "extendConstant",
          "package": "synthesizer",
          "signature": "T a -\u003e T a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-FusionList-Signal.html#extendConstant",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer FusionList Signal",
          "module": "Synthesizer.FusionList.Signal",
          "name": "extendConstant",
          "normalized": "T a-\u003eT a",
          "package": "synthesizer",
          "partial": "Constant",
          "signature": "T a-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-FusionList-Signal.html#v:extendConstant"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.FusionList.Signal",
          "name": "foldL",
          "package": "synthesizer",
          "signature": "(acc -\u003e x -\u003e acc) -\u003e acc -\u003e T x -\u003e acc",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-FusionList-Signal.html#foldL",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer FusionList Signal",
          "module": "Synthesizer.FusionList.Signal",
          "name": "foldL",
          "normalized": "(a-\u003eb-\u003ea)-\u003ea-\u003eT b-\u003ea",
          "package": "synthesizer",
          "signature": "(acc-\u003ex-\u003eacc)-\u003eacc-\u003eT x-\u003eacc",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-FusionList-Signal.html#v:foldL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.FusionList.Signal",
          "name": "foldL'",
          "package": "synthesizer",
          "signature": "(x -\u003e acc -\u003e acc) -\u003e acc -\u003e T x -\u003e acc",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-FusionList-Signal.html#foldL%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer FusionList Signal",
          "module": "Synthesizer.FusionList.Signal",
          "name": "foldL'",
          "normalized": "(a-\u003eb-\u003eb)-\u003eb-\u003eT a-\u003eb",
          "package": "synthesizer",
          "partial": "L'",
          "signature": "(x-\u003eacc-\u003eacc)-\u003eacc-\u003eT x-\u003eacc",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-FusionList-Signal.html#v:foldL'"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.FusionList.Signal",
          "name": "fromList",
          "package": "synthesizer",
          "signature": "[y] -\u003e T y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-FusionList-Signal.html#fromList",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer FusionList Signal",
          "module": "Synthesizer.FusionList.Signal",
          "name": "fromList",
          "normalized": "[a]-\u003eT a",
          "package": "synthesizer",
          "partial": "List",
          "signature": "[y]-\u003eT y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-FusionList-Signal.html#v:fromList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.FusionList.Signal",
          "name": "fromStorableSignal",
          "package": "synthesizer",
          "signature": "Vector y -\u003e T y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-FusionList-Signal.html#fromStorableSignal",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer FusionList Signal",
          "module": "Synthesizer.FusionList.Signal",
          "name": "fromStorableSignal",
          "normalized": "Vector a-\u003eT a",
          "package": "synthesizer",
          "partial": "Storable Signal",
          "signature": "Vector y-\u003eT y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-FusionList-Signal.html#v:fromStorableSignal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.FusionList.Signal",
          "name": "generate",
          "package": "synthesizer",
          "signature": "(acc -\u003e Maybe (y, acc)) -\u003e acc -\u003e T y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-FusionList-Signal.html#generate",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer FusionList Signal",
          "module": "Synthesizer.FusionList.Signal",
          "name": "generate",
          "normalized": "(a-\u003eMaybe(b,a))-\u003ea-\u003eT b",
          "package": "synthesizer",
          "signature": "(acc-\u003eMaybe(y,acc))-\u003eacc-\u003eT y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-FusionList-Signal.html#v:generate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.FusionList.Signal",
          "name": "generateInfinite",
          "package": "synthesizer",
          "signature": "(acc -\u003e (y, acc)) -\u003e acc -\u003e T y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-FusionList-Signal.html#generateInfinite",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer FusionList Signal",
          "module": "Synthesizer.FusionList.Signal",
          "name": "generateInfinite",
          "normalized": "(a-\u003e(b,a))-\u003ea-\u003eT b",
          "package": "synthesizer",
          "partial": "Infinite",
          "signature": "(acc-\u003e(y,acc))-\u003eacc-\u003eT y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-FusionList-Signal.html#v:generateInfinite"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.FusionList.Signal",
          "name": "head",
          "package": "synthesizer",
          "signature": "T a -\u003e a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-FusionList-Signal.html#head",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer FusionList Signal",
          "module": "Synthesizer.FusionList.Signal",
          "name": "head",
          "normalized": "T a-\u003ea",
          "package": "synthesizer",
          "signature": "T a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-FusionList-Signal.html#v:head"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.FusionList.Signal",
          "name": "index",
          "package": "synthesizer",
          "signature": "Int -\u003e T a -\u003e a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-FusionList-Signal.html#index",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer FusionList Signal",
          "module": "Synthesizer.FusionList.Signal",
          "name": "index",
          "normalized": "Int-\u003eT a-\u003ea",
          "package": "synthesizer",
          "signature": "Int-\u003eT a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-FusionList-Signal.html#v:index"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.FusionList.Signal",
          "name": "init",
          "package": "synthesizer",
          "signature": "T y -\u003e T y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-FusionList-Signal.html#init",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer FusionList Signal",
          "module": "Synthesizer.FusionList.Signal",
          "name": "init",
          "normalized": "T a-\u003eT a",
          "package": "synthesizer",
          "signature": "T y-\u003eT y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-FusionList-Signal.html#v:init"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.FusionList.Signal",
          "name": "iterate",
          "package": "synthesizer",
          "signature": "(a -\u003e a) -\u003e a -\u003e T a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-FusionList-Signal.html#iterate",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer FusionList Signal",
          "module": "Synthesizer.FusionList.Signal",
          "name": "iterate",
          "normalized": "(a-\u003ea)-\u003ea-\u003eT a",
          "package": "synthesizer",
          "signature": "(a-\u003ea)-\u003ea-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-FusionList-Signal.html#v:iterate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.FusionList.Signal",
          "name": "iterateAssociative",
          "package": "synthesizer",
          "signature": "(a -\u003e a -\u003e a) -\u003e a -\u003e T a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-FusionList-Signal.html#iterateAssociative",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer FusionList Signal",
          "module": "Synthesizer.FusionList.Signal",
          "name": "iterateAssociative",
          "normalized": "(a-\u003ea-\u003ea)-\u003ea-\u003eT a",
          "package": "synthesizer",
          "partial": "Associative",
          "signature": "(a-\u003ea-\u003ea)-\u003ea-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-FusionList-Signal.html#v:iterateAssociative"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.FusionList.Signal",
          "name": "length",
          "package": "synthesizer",
          "signature": "T a -\u003e Int",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-FusionList-Signal.html#length",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer FusionList Signal",
          "module": "Synthesizer.FusionList.Signal",
          "name": "length",
          "normalized": "T a-\u003eInt",
          "package": "synthesizer",
          "signature": "T a-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-FusionList-Signal.html#v:length"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "can be used to check against native length implementation \n",
          "module": "Synthesizer.FusionList.Signal",
          "name": "lengthSlow",
          "package": "synthesizer",
          "signature": "T a -\u003e Int",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-FusionList-Signal.html#lengthSlow",
          "type": "function"
        },
        "index": {
          "description": "can be used to check against native length implementation",
          "hierarchy": "Synthesizer FusionList Signal",
          "module": "Synthesizer.FusionList.Signal",
          "name": "lengthSlow",
          "normalized": "T a-\u003eInt",
          "package": "synthesizer",
          "partial": "Slow",
          "signature": "T a-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-FusionList-Signal.html#v:lengthSlow"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.FusionList.Signal",
          "name": "linearComb",
          "package": "synthesizer",
          "signature": "T t -\u003e T y -\u003e y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-FusionList-Signal.html#linearComb",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer FusionList Signal",
          "module": "Synthesizer.FusionList.Signal",
          "name": "linearComb",
          "normalized": "T a-\u003eT b-\u003eb",
          "package": "synthesizer",
          "partial": "Comb",
          "signature": "T t-\u003eT y-\u003ey",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-FusionList-Signal.html#v:linearComb"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.FusionList.Signal",
          "name": "map",
          "package": "synthesizer",
          "signature": "(a -\u003e b) -\u003e T a -\u003e T b",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-FusionList-Signal.html#map",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer FusionList Signal",
          "module": "Synthesizer.FusionList.Signal",
          "name": "map",
          "normalized": "(a-\u003eb)-\u003eT a-\u003eT b",
          "package": "synthesizer",
          "signature": "(a-\u003eb)-\u003eT a-\u003eT b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-FusionList-Signal.html#v:map"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.FusionList.Signal",
          "name": "mapAccumL",
          "package": "synthesizer",
          "signature": "(acc -\u003e x -\u003e (acc, y)) -\u003e acc -\u003e T x -\u003e (acc, T y)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-FusionList-Signal.html#mapAccumL",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer FusionList Signal",
          "module": "Synthesizer.FusionList.Signal",
          "name": "mapAccumL",
          "normalized": "(a-\u003eb-\u003e(a,c))-\u003ea-\u003eT b-\u003e(a,T c)",
          "package": "synthesizer",
          "partial": "Accum",
          "signature": "(acc-\u003ex-\u003e(acc,y))-\u003eacc-\u003eT x-\u003e(acc,T y)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-FusionList-Signal.html#v:mapAccumL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.FusionList.Signal",
          "name": "mapAccumR",
          "package": "synthesizer",
          "signature": "(acc -\u003e x -\u003e (acc, y)) -\u003e acc -\u003e T x -\u003e (acc, T y)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-FusionList-Signal.html#mapAccumR",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer FusionList Signal",
          "module": "Synthesizer.FusionList.Signal",
          "name": "mapAccumR",
          "normalized": "(a-\u003eb-\u003e(a,c))-\u003ea-\u003eT b-\u003e(a,T c)",
          "package": "synthesizer",
          "partial": "Accum",
          "signature": "(acc-\u003ex-\u003e(acc,y))-\u003eacc-\u003eT x-\u003e(acc,T y)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-FusionList-Signal.html#v:mapAccumR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.FusionList.Signal",
          "name": "mapTails",
          "package": "synthesizer",
          "signature": "(T y0 -\u003e y1) -\u003e T y0 -\u003e T y1",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-FusionList-Signal.html#mapTails",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer FusionList Signal",
          "module": "Synthesizer.FusionList.Signal",
          "name": "mapTails",
          "normalized": "(T a-\u003ea)-\u003eT a-\u003eT a",
          "package": "synthesizer",
          "partial": "Tails",
          "signature": "(T y-\u003ey)-\u003eT y-\u003eT y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-FusionList-Signal.html#v:mapTails"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.FusionList.Signal",
          "name": "maximum",
          "package": "synthesizer",
          "signature": "T a -\u003e a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-FusionList-Signal.html#maximum",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer FusionList Signal",
          "module": "Synthesizer.FusionList.Signal",
          "name": "maximum",
          "normalized": "T a-\u003ea",
          "package": "synthesizer",
          "signature": "T a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-FusionList-Signal.html#v:maximum"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.FusionList.Signal",
          "name": "mix",
          "package": "synthesizer",
          "signature": "T a -\u003e T a -\u003e T a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-FusionList-Signal.html#mix",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer FusionList Signal",
          "module": "Synthesizer.FusionList.Signal",
          "name": "mix",
          "normalized": "T a-\u003eT a-\u003eT a",
          "package": "synthesizer",
          "signature": "T a-\u003eT a-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-FusionList-Signal.html#v:mix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.FusionList.Signal",
          "name": "mixGenerate",
          "package": "synthesizer",
          "signature": "(a -\u003e a -\u003e a) -\u003e (acc -\u003e Maybe (a, acc)) -\u003e acc -\u003e T a -\u003e T a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-FusionList-Signal.html#mixGenerate",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer FusionList Signal",
          "module": "Synthesizer.FusionList.Signal",
          "name": "mixGenerate",
          "normalized": "(a-\u003ea-\u003ea)-\u003e(b-\u003eMaybe(a,b))-\u003eb-\u003eT a-\u003eT a",
          "package": "synthesizer",
          "partial": "Generate",
          "signature": "(a-\u003ea-\u003ea)-\u003e(acc-\u003eMaybe(a,acc))-\u003eacc-\u003eT a-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-FusionList-Signal.html#v:mixGenerate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Here the control may vary over the time. \n",
          "module": "Synthesizer.FusionList.Signal",
          "name": "modifyModulated",
          "package": "synthesizer",
          "signature": "Simple s ctrl a b -\u003e T ctrl -\u003e T a -\u003e T b",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-FusionList-Signal.html#modifyModulated",
          "type": "function"
        },
        "index": {
          "description": "Here the control may vary over the time",
          "hierarchy": "Synthesizer FusionList Signal",
          "module": "Synthesizer.FusionList.Signal",
          "name": "modifyModulated",
          "normalized": "Simple a b c d-\u003eT b-\u003eT c-\u003eT d",
          "package": "synthesizer",
          "partial": "Modulated",
          "signature": "Simple s ctrl a b-\u003eT ctrl-\u003eT a-\u003eT b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-FusionList-Signal.html#v:modifyModulated"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.FusionList.Signal",
          "name": "modifyStatic",
          "package": "synthesizer",
          "signature": "Simple s ctrl a b -\u003e ctrl -\u003e T a -\u003e T b",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-FusionList-Signal.html#modifyStatic",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer FusionList Signal",
          "module": "Synthesizer.FusionList.Signal",
          "name": "modifyStatic",
          "normalized": "Simple a b c d-\u003eb-\u003eT c-\u003eT d",
          "package": "synthesizer",
          "partial": "Static",
          "signature": "Simple s ctrl a b-\u003ectrl-\u003eT a-\u003eT b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-FusionList-Signal.html#v:modifyStatic"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.FusionList.Signal",
          "name": "neg",
          "package": "synthesizer",
          "signature": "T a -\u003e T a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-FusionList-Signal.html#neg",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer FusionList Signal",
          "module": "Synthesizer.FusionList.Signal",
          "name": "neg",
          "normalized": "T a-\u003eT a",
          "package": "synthesizer",
          "signature": "T a-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-FusionList-Signal.html#v:neg"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.FusionList.Signal",
          "name": "null",
          "package": "synthesizer",
          "signature": "T a -\u003e Bool",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-FusionList-Signal.html#null",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer FusionList Signal",
          "module": "Synthesizer.FusionList.Signal",
          "name": "null",
          "normalized": "T a-\u003eBool",
          "package": "synthesizer",
          "signature": "T a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-FusionList-Signal.html#v:null"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.FusionList.Signal",
          "name": "recourse",
          "package": "synthesizer",
          "signature": "(acc -\u003e Maybe acc) -\u003e acc -\u003e acc",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-FusionList-Signal.html#recourse",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer FusionList Signal",
          "module": "Synthesizer.FusionList.Signal",
          "name": "recourse",
          "normalized": "(a-\u003eMaybe a)-\u003ea-\u003ea",
          "package": "synthesizer",
          "signature": "(acc-\u003eMaybe acc)-\u003eacc-\u003eacc",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-FusionList-Signal.html#v:recourse"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.FusionList.Signal",
          "name": "reduceL",
          "package": "synthesizer",
          "signature": "(x -\u003e acc -\u003e Maybe acc) -\u003e acc -\u003e T x -\u003e acc",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-FusionList-Signal.html#reduceL",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer FusionList Signal",
          "module": "Synthesizer.FusionList.Signal",
          "name": "reduceL",
          "normalized": "(a-\u003eb-\u003eMaybe b)-\u003eb-\u003eT a-\u003eb",
          "package": "synthesizer",
          "signature": "(x-\u003eacc-\u003eMaybe acc)-\u003eacc-\u003eT x-\u003eacc",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-FusionList-Signal.html#v:reduceL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.FusionList.Signal",
          "name": "reduceLCons",
          "package": "synthesizer",
          "signature": "(a -\u003e acc -\u003e Maybe acc) -\u003e acc -\u003e a -\u003e T a -\u003e acc",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-FusionList-Signal.html#reduceLCons",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer FusionList Signal",
          "module": "Synthesizer.FusionList.Signal",
          "name": "reduceLCons",
          "normalized": "(a-\u003eb-\u003eMaybe b)-\u003eb-\u003ea-\u003eT a-\u003eb",
          "package": "synthesizer",
          "partial": "LCons",
          "signature": "(a-\u003eacc-\u003eMaybe acc)-\u003eacc-\u003ea-\u003eT a-\u003eacc",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-FusionList-Signal.html#v:reduceLCons"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.FusionList.Signal",
          "name": "repeat",
          "package": "synthesizer",
          "signature": "a -\u003e T a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-FusionList-Signal.html#repeat",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer FusionList Signal",
          "module": "Synthesizer.FusionList.Signal",
          "name": "repeat",
          "normalized": "a-\u003eT a",
          "package": "synthesizer",
          "signature": "a-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-FusionList-Signal.html#v:repeat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.FusionList.Signal",
          "name": "replicate",
          "package": "synthesizer",
          "signature": "Int -\u003e a -\u003e T a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-FusionList-Signal.html#replicate",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer FusionList Signal",
          "module": "Synthesizer.FusionList.Signal",
          "name": "replicate",
          "normalized": "Int-\u003ea-\u003eT a",
          "package": "synthesizer",
          "signature": "Int-\u003ea-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-FusionList-Signal.html#v:replicate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.FusionList.Signal",
          "name": "reverse",
          "package": "synthesizer",
          "signature": "T a -\u003e T a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-FusionList-Signal.html#reverse",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer FusionList Signal",
          "module": "Synthesizer.FusionList.Signal",
          "name": "reverse",
          "normalized": "T a-\u003eT a",
          "package": "synthesizer",
          "signature": "T a-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-FusionList-Signal.html#v:reverse"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.FusionList.Signal",
          "name": "scanL",
          "package": "synthesizer",
          "signature": "(acc -\u003e x -\u003e acc) -\u003e acc -\u003e T x -\u003e T acc",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-FusionList-Signal.html#scanL",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer FusionList Signal",
          "module": "Synthesizer.FusionList.Signal",
          "name": "scanL",
          "normalized": "(a-\u003eb-\u003ea)-\u003ea-\u003eT b-\u003eT a",
          "package": "synthesizer",
          "signature": "(acc-\u003ex-\u003eacc)-\u003eacc-\u003eT x-\u003eT acc",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-FusionList-Signal.html#v:scanL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "input and output have equal length, that's better for fusion\n",
          "module": "Synthesizer.FusionList.Signal",
          "name": "scanLClip",
          "package": "synthesizer",
          "signature": "(acc -\u003e x -\u003e acc) -\u003e acc -\u003e T x -\u003e T acc",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-FusionList-Signal.html#scanLClip",
          "type": "function"
        },
        "index": {
          "description": "input and output have equal length that better for fusion",
          "hierarchy": "Synthesizer FusionList Signal",
          "module": "Synthesizer.FusionList.Signal",
          "name": "scanLClip",
          "normalized": "(a-\u003eb-\u003ea)-\u003ea-\u003eT b-\u003eT a",
          "package": "synthesizer",
          "partial": "LClip",
          "signature": "(acc-\u003ex-\u003eacc)-\u003eacc-\u003eT x-\u003eT acc",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-FusionList-Signal.html#v:scanLClip"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.FusionList.Signal",
          "name": "singleton",
          "package": "synthesizer",
          "signature": "a -\u003e T a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-FusionList-Signal.html#singleton",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer FusionList Signal",
          "module": "Synthesizer.FusionList.Signal",
          "name": "singleton",
          "normalized": "a-\u003eT a",
          "package": "synthesizer",
          "signature": "a-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-FusionList-Signal.html#v:singleton"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.FusionList.Signal",
          "name": "sliceVert",
          "package": "synthesizer",
          "signature": "Int -\u003e T y -\u003e [T y]",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-FusionList-Signal.html#sliceVert",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer FusionList Signal",
          "module": "Synthesizer.FusionList.Signal",
          "name": "sliceVert",
          "normalized": "Int-\u003eT a-\u003e[T a]",
          "package": "synthesizer",
          "partial": "Vert",
          "signature": "Int-\u003eT y-\u003e[T y]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-FusionList-Signal.html#v:sliceVert"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.FusionList.Signal",
          "name": "span",
          "package": "synthesizer",
          "signature": "(a -\u003e Bool) -\u003e T a -\u003e (T a, T a)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-FusionList-Signal.html#span",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer FusionList Signal",
          "module": "Synthesizer.FusionList.Signal",
          "name": "span",
          "normalized": "(a-\u003eBool)-\u003eT a-\u003e(T a,T a)",
          "package": "synthesizer",
          "signature": "(a-\u003eBool)-\u003eT a-\u003e(T a,T a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-FusionList-Signal.html#v:span"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.FusionList.Signal",
          "name": "splitAt",
          "package": "synthesizer",
          "signature": "Int -\u003e T a -\u003e (T a, T a)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-FusionList-Signal.html#splitAt",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer FusionList Signal",
          "module": "Synthesizer.FusionList.Signal",
          "name": "splitAt",
          "normalized": "Int-\u003eT a-\u003e(T a,T a)",
          "package": "synthesizer",
          "partial": "At",
          "signature": "Int-\u003eT a-\u003e(T a,T a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-FusionList-Signal.html#v:splitAt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.FusionList.Signal",
          "name": "sub",
          "package": "synthesizer",
          "signature": "T a -\u003e T a -\u003e T a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-FusionList-Signal.html#sub",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer FusionList Signal",
          "module": "Synthesizer.FusionList.Signal",
          "name": "sub",
          "normalized": "T a-\u003eT a-\u003eT a",
          "package": "synthesizer",
          "signature": "T a-\u003eT a-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-FusionList-Signal.html#v:sub"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.FusionList.Signal",
          "name": "sum",
          "package": "synthesizer",
          "signature": "T a -\u003e a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-FusionList-Signal.html#sum",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer FusionList Signal",
          "module": "Synthesizer.FusionList.Signal",
          "name": "sum",
          "normalized": "T a-\u003ea",
          "package": "synthesizer",
          "signature": "T a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-FusionList-Signal.html#v:sum"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.FusionList.Signal",
          "name": "tail",
          "package": "synthesizer",
          "signature": "T a -\u003e T a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-FusionList-Signal.html#tail",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer FusionList Signal",
          "module": "Synthesizer.FusionList.Signal",
          "name": "tail",
          "normalized": "T a-\u003eT a",
          "package": "synthesizer",
          "signature": "T a-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-FusionList-Signal.html#v:tail"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.FusionList.Signal",
          "name": "tails",
          "package": "synthesizer",
          "signature": "T y -\u003e [T y]",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-FusionList-Signal.html#tails",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer FusionList Signal",
          "module": "Synthesizer.FusionList.Signal",
          "name": "tails",
          "normalized": "T a-\u003e[T a]",
          "package": "synthesizer",
          "signature": "T y-\u003e[T y]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-FusionList-Signal.html#v:tails"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.FusionList.Signal",
          "name": "take",
          "package": "synthesizer",
          "signature": "Int -\u003e T a -\u003e T a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-FusionList-Signal.html#take",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer FusionList Signal",
          "module": "Synthesizer.FusionList.Signal",
          "name": "take",
          "normalized": "Int-\u003eT a-\u003eT a",
          "package": "synthesizer",
          "signature": "Int-\u003eT a-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-FusionList-Signal.html#v:take"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.FusionList.Signal",
          "name": "takeWhile",
          "package": "synthesizer",
          "signature": "(a -\u003e Bool) -\u003e T a -\u003e T a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-FusionList-Signal.html#takeWhile",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer FusionList Signal",
          "module": "Synthesizer.FusionList.Signal",
          "name": "takeWhile",
          "normalized": "(a-\u003eBool)-\u003eT a-\u003eT a",
          "package": "synthesizer",
          "partial": "While",
          "signature": "(a-\u003eBool)-\u003eT a-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-FusionList-Signal.html#v:takeWhile"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.FusionList.Signal",
          "name": "toList",
          "package": "synthesizer",
          "signature": "T y -\u003e [y]",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-FusionList-Signal.html#toList",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer FusionList Signal",
          "module": "Synthesizer.FusionList.Signal",
          "name": "toList",
          "normalized": "T a-\u003e[a]",
          "package": "synthesizer",
          "partial": "List",
          "signature": "T y-\u003e[y]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-FusionList-Signal.html#v:toList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.FusionList.Signal",
          "name": "toStorableSignal",
          "package": "synthesizer",
          "signature": "ChunkSize -\u003e T y -\u003e Vector y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-FusionList-Signal.html#toStorableSignal",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer FusionList Signal",
          "module": "Synthesizer.FusionList.Signal",
          "name": "toStorableSignal",
          "normalized": "ChunkSize-\u003eT a-\u003eVector a",
          "package": "synthesizer",
          "partial": "Storable Signal",
          "signature": "ChunkSize-\u003eT y-\u003eVector y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-FusionList-Signal.html#v:toStorableSignal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.FusionList.Signal",
          "name": "unfoldR",
          "package": "synthesizer",
          "signature": "(acc -\u003e Maybe (y, acc)) -\u003e acc -\u003e T y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-FusionList-Signal.html#unfoldR",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer FusionList Signal",
          "module": "Synthesizer.FusionList.Signal",
          "name": "unfoldR",
          "normalized": "(a-\u003eMaybe(b,a))-\u003ea-\u003eT b",
          "package": "synthesizer",
          "signature": "(acc-\u003eMaybe(y,acc))-\u003eacc-\u003eT y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-FusionList-Signal.html#v:unfoldR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.FusionList.Signal",
          "name": "unzip",
          "package": "synthesizer",
          "signature": "T (a, b) -\u003e (T a, T b)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-FusionList-Signal.html#unzip",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer FusionList Signal",
          "module": "Synthesizer.FusionList.Signal",
          "name": "unzip",
          "normalized": "T(a,b)-\u003e(T a,T b)",
          "package": "synthesizer",
          "signature": "T(a,b)-\u003e(T a,T b)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-FusionList-Signal.html#v:unzip"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.FusionList.Signal",
          "name": "unzip3",
          "package": "synthesizer",
          "signature": "T (a, b, c) -\u003e (T a, T b, T c)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-FusionList-Signal.html#unzip3",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer FusionList Signal",
          "module": "Synthesizer.FusionList.Signal",
          "name": "unzip3",
          "normalized": "T(a,b,c)-\u003e(T a,T b,T c)",
          "package": "synthesizer",
          "signature": "T(a,b,c)-\u003e(T a,T b,T c)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-FusionList-Signal.html#v:unzip3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.FusionList.Signal",
          "name": "viewL",
          "package": "synthesizer",
          "signature": "T a -\u003e Maybe (a, T a)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-FusionList-Signal.html#viewL",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer FusionList Signal",
          "module": "Synthesizer.FusionList.Signal",
          "name": "viewL",
          "normalized": "T a-\u003eMaybe(a,T a)",
          "package": "synthesizer",
          "signature": "T a-\u003eMaybe(a,T a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-FusionList-Signal.html#v:viewL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.FusionList.Signal",
          "name": "viewR",
          "package": "synthesizer",
          "signature": "T a -\u003e Maybe (T a, a)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-FusionList-Signal.html#viewR",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer FusionList Signal",
          "module": "Synthesizer.FusionList.Signal",
          "name": "viewR",
          "normalized": "T a-\u003eMaybe(T a,a)",
          "package": "synthesizer",
          "signature": "T a-\u003eMaybe(T a,a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-FusionList-Signal.html#v:viewR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.FusionList.Signal",
          "name": "zapWith",
          "package": "synthesizer",
          "signature": "(a -\u003e a -\u003e b) -\u003e T a -\u003e T b",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-FusionList-Signal.html#zapWith",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer FusionList Signal",
          "module": "Synthesizer.FusionList.Signal",
          "name": "zapWith",
          "normalized": "(a-\u003ea-\u003eb)-\u003eT a-\u003eT b",
          "package": "synthesizer",
          "partial": "With",
          "signature": "(a-\u003ea-\u003eb)-\u003eT a-\u003eT b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-FusionList-Signal.html#v:zapWith"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.FusionList.Signal",
          "name": "zip",
          "package": "synthesizer",
          "signature": "T a -\u003e T b -\u003e T (a, b)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-FusionList-Signal.html#zip",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer FusionList Signal",
          "module": "Synthesizer.FusionList.Signal",
          "name": "zip",
          "normalized": "T a-\u003eT b-\u003eT(a,b)",
          "package": "synthesizer",
          "signature": "T a-\u003eT b-\u003eT(a,b)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-FusionList-Signal.html#v:zip"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.FusionList.Signal",
          "name": "zip3",
          "package": "synthesizer",
          "signature": "T a -\u003e T b -\u003e T c -\u003e T (a, b, c)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-FusionList-Signal.html#zip3",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer FusionList Signal",
          "module": "Synthesizer.FusionList.Signal",
          "name": "zip3",
          "normalized": "T a-\u003eT b-\u003eT c-\u003eT(a,b,c)",
          "package": "synthesizer",
          "signature": "T a-\u003eT b-\u003eT c-\u003eT(a,b,c)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-FusionList-Signal.html#v:zip3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.FusionList.Signal",
          "name": "zip4",
          "package": "synthesizer",
          "signature": "T a -\u003e T b -\u003e T c -\u003e T d -\u003e T (a, b, c, d)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-FusionList-Signal.html#zip4",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer FusionList Signal",
          "module": "Synthesizer.FusionList.Signal",
          "name": "zip4",
          "normalized": "T a-\u003eT b-\u003eT c-\u003eT d-\u003eT(a,b,c,d)",
          "package": "synthesizer",
          "signature": "T a-\u003eT b-\u003eT c-\u003eT d-\u003eT(a,b,c,d)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-FusionList-Signal.html#v:zip4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.FusionList.Signal",
          "name": "zipWith",
          "package": "synthesizer",
          "signature": "(a -\u003e b -\u003e c) -\u003e T a -\u003e T b -\u003e T c",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-FusionList-Signal.html#zipWith",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer FusionList Signal",
          "module": "Synthesizer.FusionList.Signal",
          "name": "zipWith",
          "normalized": "(a-\u003eb-\u003ec)-\u003eT a-\u003eT b-\u003eT c",
          "package": "synthesizer",
          "partial": "With",
          "signature": "(a-\u003eb-\u003ec)-\u003eT a-\u003eT b-\u003eT c",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-FusionList-Signal.html#v:zipWith"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.FusionList.Signal",
          "name": "zipWith3",
          "package": "synthesizer",
          "signature": "(a -\u003e b -\u003e c -\u003e d) -\u003e T a -\u003e T b -\u003e T c -\u003e T d",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-FusionList-Signal.html#zipWith3",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer FusionList Signal",
          "module": "Synthesizer.FusionList.Signal",
          "name": "zipWith3",
          "normalized": "(a-\u003eb-\u003ec-\u003ed)-\u003eT a-\u003eT b-\u003eT c-\u003eT d",
          "package": "synthesizer",
          "partial": "With",
          "signature": "(a-\u003eb-\u003ec-\u003ed)-\u003eT a-\u003eT b-\u003eT c-\u003eT d",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-FusionList-Signal.html#v:zipWith3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.FusionList.Signal",
          "name": "zipWith4",
          "package": "synthesizer",
          "signature": "(a -\u003e b -\u003e c -\u003e d -\u003e e) -\u003e T a -\u003e T b -\u003e T c -\u003e T d -\u003e T e",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-FusionList-Signal.html#zipWith4",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer FusionList Signal",
          "module": "Synthesizer.FusionList.Signal",
          "name": "zipWith4",
          "normalized": "(a-\u003eb-\u003ec-\u003ed-\u003ee)-\u003eT a-\u003eT b-\u003eT c-\u003eT d-\u003eT e",
          "package": "synthesizer",
          "partial": "With",
          "signature": "(a-\u003eb-\u003ec-\u003ed-\u003ee)-\u003eT a-\u003eT b-\u003eT c-\u003eT d-\u003eT e",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-FusionList-Signal.html#v:zipWith4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.FusionList.Signal",
          "name": "zipWithAppend",
          "package": "synthesizer",
          "signature": "(y -\u003e y -\u003e y) -\u003e T y -\u003e T y -\u003e T y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-FusionList-Signal.html#zipWithAppend",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer FusionList Signal",
          "module": "Synthesizer.FusionList.Signal",
          "name": "zipWithAppend",
          "normalized": "(a-\u003ea-\u003ea)-\u003eT a-\u003eT a-\u003eT a",
          "package": "synthesizer",
          "partial": "With Append",
          "signature": "(y-\u003ey-\u003ey)-\u003eT y-\u003eT y-\u003eT y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-FusionList-Signal.html#v:zipWithAppend"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.FusionList.Signal",
          "name": "zipWithCons",
          "package": "synthesizer",
          "signature": "(a -\u003e b -\u003e c) -\u003e a -\u003e T a -\u003e T b -\u003e T c",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-FusionList-Signal.html#zipWithCons",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer FusionList Signal",
          "module": "Synthesizer.FusionList.Signal",
          "name": "zipWithCons",
          "normalized": "(a-\u003eb-\u003ec)-\u003ea-\u003eT a-\u003eT b-\u003eT c",
          "package": "synthesizer",
          "partial": "With Cons",
          "signature": "(a-\u003eb-\u003ec)-\u003ea-\u003eT a-\u003eT b-\u003eT c",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-FusionList-Signal.html#v:zipWithCons"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.FusionList.Signal",
          "name": "zipWithCrochetL",
          "package": "synthesizer",
          "signature": "(a -\u003e b -\u003e c) -\u003e (x -\u003e acc -\u003e Maybe (a, acc)) -\u003e acc -\u003e T x -\u003e T b -\u003e T c",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-FusionList-Signal.html#zipWithCrochetL",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer FusionList Signal",
          "module": "Synthesizer.FusionList.Signal",
          "name": "zipWithCrochetL",
          "normalized": "(a-\u003eb-\u003ec)-\u003e(d-\u003ee-\u003eMaybe(a,e))-\u003ee-\u003eT d-\u003eT b-\u003eT c",
          "package": "synthesizer",
          "partial": "With Crochet",
          "signature": "(a-\u003eb-\u003ec)-\u003e(x-\u003eacc-\u003eMaybe(a,acc))-\u003eacc-\u003eT x-\u003eT b-\u003eT c",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-FusionList-Signal.html#v:zipWithCrochetL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.FusionList.Signal",
          "name": "zipWithGenerate",
          "package": "synthesizer",
          "signature": "(a -\u003e b -\u003e c) -\u003e (acc -\u003e Maybe (a, acc)) -\u003e acc -\u003e T b -\u003e T c",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-FusionList-Signal.html#zipWithGenerate",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer FusionList Signal",
          "module": "Synthesizer.FusionList.Signal",
          "name": "zipWithGenerate",
          "normalized": "(a-\u003eb-\u003ec)-\u003e(d-\u003eMaybe(a,d))-\u003ed-\u003eT b-\u003eT c",
          "package": "synthesizer",
          "partial": "With Generate",
          "signature": "(a-\u003eb-\u003ec)-\u003e(acc-\u003eMaybe(a,acc))-\u003eacc-\u003eT b-\u003eT c",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-FusionList-Signal.html#v:zipWithGenerate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.FusionList.Signal",
          "name": "zipWithRest",
          "package": "synthesizer",
          "signature": "(y0 -\u003e y0 -\u003e y1) -\u003e T y0 -\u003e T y0 -\u003e (T y1, (Bool, T y0))",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-FusionList-Signal.html#zipWithRest",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer FusionList Signal",
          "module": "Synthesizer.FusionList.Signal",
          "name": "zipWithRest",
          "normalized": "(a-\u003ea-\u003ea)-\u003eT a-\u003eT a-\u003e(T a,(Bool,T a))",
          "package": "synthesizer",
          "partial": "With Rest",
          "signature": "(y-\u003ey-\u003ey)-\u003eT y-\u003eT y-\u003e(T y,(Bool,T y))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-FusionList-Signal.html#v:zipWithRest"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.FusionList.Signal",
          "name": "zipWithTails",
          "package": "synthesizer",
          "signature": "(y0 -\u003e T y1 -\u003e y2) -\u003e T y0 -\u003e T y1 -\u003e T y2",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-FusionList-Signal.html#zipWithTails",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer FusionList Signal",
          "module": "Synthesizer.FusionList.Signal",
          "name": "zipWithTails",
          "normalized": "(a-\u003eT a-\u003ea)-\u003eT a-\u003eT a-\u003eT a",
          "package": "synthesizer",
          "partial": "With Tails",
          "signature": "(y-\u003eT y-\u003ey)-\u003eT y-\u003eT y-\u003eT y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-FusionList-Signal.html#v:zipWithTails"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Generic.Analysis",
          "name": "average",
          "package": "synthesizer",
          "signature": "sig y -\u003e y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Generic-Analysis.html#average",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Generic Analysis",
          "module": "Synthesizer.Generic.Analysis",
          "name": "average",
          "normalized": "a b-\u003eb",
          "package": "synthesizer",
          "signature": "sig y-\u003ey",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Analysis.html#v:average"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Compute minimum and maximum value of the stream the efficient way.\nInput list must be non-empty and finite.\n",
          "module": "Synthesizer.Generic.Analysis",
          "name": "bounds",
          "package": "synthesizer",
          "signature": "sig y -\u003e (y, y)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Generic-Analysis.html#bounds",
          "type": "function"
        },
        "index": {
          "description": "Compute minimum and maximum value of the stream the efficient way Input list must be non-empty and finite",
          "hierarchy": "Synthesizer Generic Analysis",
          "module": "Synthesizer.Generic.Analysis",
          "name": "bounds",
          "normalized": "a b-\u003e(b,b)",
          "package": "synthesizer",
          "signature": "sig y-\u003e(y,y)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Analysis.html#v:bounds"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003ctt\u003e\u003ca\u003edirectCurrentOffset\u003c/a\u003e\u003c/tt\u003e must be non-zero.\n",
          "module": "Synthesizer.Generic.Analysis",
          "name": "centroid",
          "package": "synthesizer",
          "signature": "sig y -\u003e y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Generic-Analysis.html#centroid",
          "type": "function"
        },
        "index": {
          "description": "directCurrentOffset must be non-zero",
          "hierarchy": "Synthesizer Generic Analysis",
          "module": "Synthesizer.Generic.Analysis",
          "name": "centroid",
          "normalized": "a b-\u003eb",
          "package": "synthesizer",
          "signature": "sig y-\u003ey",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Analysis.html#v:centroid"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Requires finite length.\nThis is identical to the arithmetic mean.\n",
          "module": "Synthesizer.Generic.Analysis",
          "name": "directCurrentOffset",
          "package": "synthesizer",
          "signature": "sig y -\u003e y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Generic-Analysis.html#directCurrentOffset",
          "type": "function"
        },
        "index": {
          "description": "Requires finite length This is identical to the arithmetic mean",
          "hierarchy": "Synthesizer Generic Analysis",
          "module": "Synthesizer.Generic.Analysis",
          "name": "directCurrentOffset",
          "normalized": "a b-\u003eb",
          "package": "synthesizer",
          "partial": "Current Offset",
          "signature": "sig y-\u003ey",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Analysis.html#v:directCurrentOffset"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Detect thresholds with a hysteresis.\n",
          "module": "Synthesizer.Generic.Analysis",
          "name": "flipFlopHysteresis",
          "package": "synthesizer",
          "signature": "(y, y) -\u003e Bool -\u003e sig y -\u003e sig Bool",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Generic-Analysis.html#flipFlopHysteresis",
          "type": "function"
        },
        "index": {
          "description": "Detect thresholds with hysteresis",
          "hierarchy": "Synthesizer Generic Analysis",
          "module": "Synthesizer.Generic.Analysis",
          "name": "flipFlopHysteresis",
          "normalized": "(a,a)-\u003eBool-\u003eb a-\u003eb Bool",
          "package": "synthesizer",
          "partial": "Flop Hysteresis",
          "signature": "(y,y)-\u003eBool-\u003esig y-\u003esig Bool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Analysis.html#v:flipFlopHysteresis"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Generic.Analysis",
          "name": "rectify",
          "package": "synthesizer",
          "signature": "sig y -\u003e sig y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Generic-Analysis.html#rectify",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Generic Analysis",
          "module": "Synthesizer.Generic.Analysis",
          "name": "rectify",
          "normalized": "a b-\u003ea b",
          "package": "synthesizer",
          "signature": "sig y-\u003esig y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Analysis.html#v:rectify"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Generic.Analysis",
          "name": "scalarProduct",
          "package": "synthesizer",
          "signature": "sig y -\u003e sig y -\u003e y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Generic-Analysis.html#scalarProduct",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Generic Analysis",
          "module": "Synthesizer.Generic.Analysis",
          "name": "scalarProduct",
          "normalized": "a b-\u003ea b-\u003eb",
          "package": "synthesizer",
          "partial": "Product",
          "signature": "sig y-\u003esig y-\u003ey",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Analysis.html#v:scalarProduct"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Volume based on Energy norm.\n",
          "module": "Synthesizer.Generic.Analysis",
          "name": "volumeEuclidean",
          "package": "synthesizer",
          "signature": "sig y -\u003e y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Generic-Analysis.html#volumeEuclidean",
          "type": "function"
        },
        "index": {
          "description": "Volume based on Energy norm",
          "hierarchy": "Synthesizer Generic Analysis",
          "module": "Synthesizer.Generic.Analysis",
          "name": "volumeEuclidean",
          "normalized": "a b-\u003eb",
          "package": "synthesizer",
          "partial": "Euclidean",
          "signature": "sig y-\u003ey",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Analysis.html#v:volumeEuclidean"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Generic.Analysis",
          "name": "volumeEuclideanSqr",
          "package": "synthesizer",
          "signature": "sig y -\u003e y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Generic-Analysis.html#volumeEuclideanSqr",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Generic Analysis",
          "module": "Synthesizer.Generic.Analysis",
          "name": "volumeEuclideanSqr",
          "normalized": "a b-\u003eb",
          "package": "synthesizer",
          "partial": "Euclidean Sqr",
          "signature": "sig y-\u003ey",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Analysis.html#v:volumeEuclideanSqr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Volume based on Manhattan norm.\n",
          "module": "Synthesizer.Generic.Analysis",
          "name": "volumeMaximum",
          "package": "synthesizer",
          "signature": "sig y -\u003e y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Generic-Analysis.html#volumeMaximum",
          "type": "function"
        },
        "index": {
          "description": "Volume based on Manhattan norm",
          "hierarchy": "Synthesizer Generic Analysis",
          "module": "Synthesizer.Generic.Analysis",
          "name": "volumeMaximum",
          "normalized": "a b-\u003eb",
          "package": "synthesizer",
          "partial": "Maximum",
          "signature": "sig y-\u003ey",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Analysis.html#v:volumeMaximum"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Volume based on Sum norm.\n",
          "module": "Synthesizer.Generic.Analysis",
          "name": "volumeSum",
          "package": "synthesizer",
          "signature": "sig y -\u003e y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Generic-Analysis.html#volumeSum",
          "type": "function"
        },
        "index": {
          "description": "Volume based on Sum norm",
          "hierarchy": "Synthesizer Generic Analysis",
          "module": "Synthesizer.Generic.Analysis",
          "name": "volumeSum",
          "normalized": "a b-\u003eb",
          "package": "synthesizer",
          "partial": "Sum",
          "signature": "sig y-\u003ey",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Analysis.html#v:volumeSum"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Volume based on Energy norm.\n",
          "module": "Synthesizer.Generic.Analysis",
          "name": "volumeVectorEuclidean",
          "package": "synthesizer",
          "signature": "sig yv -\u003e y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Generic-Analysis.html#volumeVectorEuclidean",
          "type": "function"
        },
        "index": {
          "description": "Volume based on Energy norm",
          "hierarchy": "Synthesizer Generic Analysis",
          "module": "Synthesizer.Generic.Analysis",
          "name": "volumeVectorEuclidean",
          "normalized": "a b-\u003ec",
          "package": "synthesizer",
          "partial": "Vector Euclidean",
          "signature": "sig yv-\u003ey",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Analysis.html#v:volumeVectorEuclidean"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Generic.Analysis",
          "name": "volumeVectorEuclideanSqr",
          "package": "synthesizer",
          "signature": "sig yv -\u003e y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Generic-Analysis.html#volumeVectorEuclideanSqr",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Generic Analysis",
          "module": "Synthesizer.Generic.Analysis",
          "name": "volumeVectorEuclideanSqr",
          "normalized": "a b-\u003ec",
          "package": "synthesizer",
          "partial": "Vector Euclidean Sqr",
          "signature": "sig yv-\u003ey",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Analysis.html#v:volumeVectorEuclideanSqr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Volume based on Manhattan norm.\n",
          "module": "Synthesizer.Generic.Analysis",
          "name": "volumeVectorMaximum",
          "package": "synthesizer",
          "signature": "sig yv -\u003e y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Generic-Analysis.html#volumeVectorMaximum",
          "type": "function"
        },
        "index": {
          "description": "Volume based on Manhattan norm",
          "hierarchy": "Synthesizer Generic Analysis",
          "module": "Synthesizer.Generic.Analysis",
          "name": "volumeVectorMaximum",
          "normalized": "a b-\u003ec",
          "package": "synthesizer",
          "partial": "Vector Maximum",
          "signature": "sig yv-\u003ey",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Analysis.html#v:volumeVectorMaximum"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Volume based on Sum norm.\n",
          "module": "Synthesizer.Generic.Analysis",
          "name": "volumeVectorSum",
          "package": "synthesizer",
          "signature": "sig yv -\u003e y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Generic-Analysis.html#volumeVectorSum",
          "type": "function"
        },
        "index": {
          "description": "Volume based on Sum norm",
          "hierarchy": "Synthesizer Generic Analysis",
          "module": "Synthesizer.Generic.Analysis",
          "name": "volumeVectorSum",
          "normalized": "a b-\u003ec",
          "package": "synthesizer",
          "partial": "Vector Sum",
          "signature": "sig yv-\u003ey",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Analysis.html#v:volumeVectorSum"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDetects zeros (sign changes) in a signal.\nThis can be used as a simple measure of the portion\nof high frequencies or noise in the signal.\nIt ca be used as voiced/unvoiced detector in a vocoder.\n\u003c/p\u003e\u003cp\u003e\u003ctt\u003ezeros x !! n\u003c/tt\u003e is \u003ctt\u003eTrue\u003c/tt\u003e if and only if\n\u003ctt\u003e(x !! n \u003e= 0) /= (x !! (n+1) \u003e= 0)\u003c/tt\u003e.\nThe result will be one value shorter than the input.\n\u003c/p\u003e",
          "module": "Synthesizer.Generic.Analysis",
          "name": "zeros",
          "package": "synthesizer",
          "signature": "sig y -\u003e sig Bool",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Generic-Analysis.html#zeros",
          "type": "function"
        },
        "index": {
          "description": "Detects zeros sign changes in signal This can be used as simple measure of the portion of high frequencies or noise in the signal It ca be used as voiced unvoiced detector in vocoder zeros is True if and only if The result will be one value shorter than the input",
          "hierarchy": "Synthesizer Generic Analysis",
          "module": "Synthesizer.Generic.Analysis",
          "name": "zeros",
          "normalized": "a b-\u003ea Bool",
          "package": "synthesizer",
          "signature": "sig y-\u003esig Bool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Analysis.html#v:zeros"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Generic.Control",
          "name": "Control",
          "package": "synthesizer",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Generic-Control.html#Control",
          "type": "data"
        },
        "index": {
          "hierarchy": "Synthesizer Generic Control",
          "module": "Synthesizer.Generic.Control",
          "name": "Control",
          "package": "synthesizer",
          "partial": "Control",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Control.html#t:Control"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Generic.Control",
          "name": "ControlDist",
          "package": "synthesizer",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Generic-Control.html#ControlDist",
          "type": "type"
        },
        "index": {
          "hierarchy": "Synthesizer Generic Control",
          "module": "Synthesizer.Generic.Control",
          "name": "ControlDist",
          "package": "synthesizer",
          "partial": "Control Dist",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Control.html#t:ControlDist"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Generic.Control",
          "name": "ControlPiece",
          "package": "synthesizer",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Generic-Control.html#ControlPiece",
          "type": "data"
        },
        "index": {
          "hierarchy": "Synthesizer Generic Control",
          "module": "Synthesizer.Generic.Control",
          "name": "ControlPiece",
          "package": "synthesizer",
          "partial": "Control Piece",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Control.html#t:ControlPiece"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Generic.Control",
          "name": "PieceRightDouble",
          "package": "synthesizer",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Generic-Control.html#PieceRightDouble",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "Synthesizer Generic Control",
          "module": "Synthesizer.Generic.Control",
          "name": "PieceRightDouble",
          "package": "synthesizer",
          "partial": "Piece Right Double",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Control.html#t:PieceRightDouble"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Generic.Control",
          "name": "PieceRightSingle",
          "package": "synthesizer",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Generic-Control.html#PieceRightSingle",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "Synthesizer Generic Control",
          "module": "Synthesizer.Generic.Control",
          "name": "PieceRightSingle",
          "package": "synthesizer",
          "partial": "Piece Right Single",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Control.html#t:PieceRightSingle"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Generic.Control",
          "name": "#|",
          "package": "synthesizer",
          "signature": "(y, Control y) -\u003e y -\u003e (ControlDist y, [ControlPiece y])",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Generic-Control.html#%23%7C",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Generic Control",
          "module": "Synthesizer.Generic.Control",
          "name": "#|",
          "normalized": "(a,Control a)-\u003ea-\u003e(ControlDist a,[ControlPiece a])",
          "package": "synthesizer",
          "signature": "(y,Control y)-\u003ey-\u003e(ControlDist y,[ControlPiece y])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Control.html#v:#|"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe 6 operators simplify constructing a list of \u003ctt\u003eControlPiece a\u003c/tt\u003e.\nThe description consists of nodes (namely the curve values at nodes)\nand the connecting curve types.\nThe naming scheme is as follows:\nIn the middle there is a bar \u003ctt\u003e|\u003c/tt\u003e.\nWith respect to the bar,\nthe pad symbol \u003ctt\u003e#\u003c/tt\u003e is at the side of the curve type,\nat the other side there is nothing, a minus sign \u003ctt\u003e-\u003c/tt\u003e, or an equality sign \u003ctt\u003e=\u003c/tt\u003e.\n\u003c/p\u003e\u003col\u003e\u003cli\u003e Nothing means that here is the start or the end node of a curve.\n\u003c/li\u003e\u003cli\u003e Minus means that here is a node where left and right curve meet at the same value.\n     The node description is thus one value.\n\u003c/li\u003e\u003cli\u003e Equality sign means that here is a split node,\n     where left and right curve might have different ending and beginning values, respectively.\n     The node description consists of a pair of values.\n\u003c/li\u003e\u003c/ol\u003e",
          "module": "Synthesizer.Generic.Control",
          "name": "#|-",
          "package": "synthesizer",
          "signature": "(y, Control y) -\u003e (PieceRightSingle y, [ControlPiece y]) -\u003e (ControlDist y, [ControlPiece y])",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Generic-Control.html#%23%7C-",
          "type": "function"
        },
        "index": {
          "description": "The operators simplify constructing list of ControlPiece The description consists of nodes namely the curve values at nodes and the connecting curve types The naming scheme is as follows In the middle there is bar With respect to the bar the pad symbol is at the side of the curve type at the other side there is nothing minus sign or an equality sign Nothing means that here is the start or the end node of curve Minus means that here is node where left and right curve meet at the same value The node description is thus one value Equality sign means that here is split node where left and right curve might have different ending and beginning values respectively The node description consists of pair of values",
          "hierarchy": "Synthesizer Generic Control",
          "module": "Synthesizer.Generic.Control",
          "name": "#|-",
          "normalized": "(a,Control a)-\u003e(PieceRightSingle a,[ControlPiece a])-\u003e(ControlDist a,[ControlPiece a])",
          "package": "synthesizer",
          "signature": "(y,Control y)-\u003e(PieceRightSingle y,[ControlPiece y])-\u003e(ControlDist y,[ControlPiece y])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Control.html#v:#|-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Generic.Control",
          "name": "#|=",
          "package": "synthesizer",
          "signature": "(y, Control y) -\u003e (PieceRightDouble y, [ControlPiece y]) -\u003e (ControlDist y, [ControlPiece y])",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Generic-Control.html#%23%7C%3D",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Generic Control",
          "module": "Synthesizer.Generic.Control",
          "name": "#|=",
          "normalized": "(a,Control a)-\u003e(PieceRightDouble a,[ControlPiece a])-\u003e(ControlDist a,[ControlPiece a])",
          "package": "synthesizer",
          "signature": "(y,Control y)-\u003e(PieceRightDouble y,[ControlPiece y])-\u003e(ControlDist y,[ControlPiece y])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Control.html#v:#|="
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Generic.Control",
          "name": "-|#",
          "package": "synthesizer",
          "signature": "y -\u003e (ControlDist y, [ControlPiece y]) -\u003e (PieceRightSingle y, [ControlPiece y])",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Generic-Control.html#-%7C%23",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Generic Control",
          "module": "Synthesizer.Generic.Control",
          "name": "-|#",
          "normalized": "a-\u003e(ControlDist a,[ControlPiece a])-\u003e(PieceRightSingle a,[ControlPiece a])",
          "package": "synthesizer",
          "signature": "y-\u003e(ControlDist y,[ControlPiece y])-\u003e(PieceRightSingle y,[ControlPiece y])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Control.html#v:-|#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Generic.Control",
          "name": "=|#",
          "package": "synthesizer",
          "signature": "(y, y) -\u003e (ControlDist y, [ControlPiece y]) -\u003e (PieceRightDouble y, [ControlPiece y])",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Generic-Control.html#%3D%7C%23",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Generic Control",
          "module": "Synthesizer.Generic.Control",
          "name": "=|#",
          "normalized": "(a,a)-\u003e(ControlDist a,[ControlPiece a])-\u003e(PieceRightDouble a,[ControlPiece a])",
          "package": "synthesizer",
          "signature": "(y,y)-\u003e(ControlDist y,[ControlPiece y])-\u003e(PieceRightDouble y,[ControlPiece y])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Control.html#v:=|#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Generic.Control",
          "name": "constant",
          "package": "synthesizer",
          "signature": "LazySize -\u003e y -\u003e sig y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Generic-Control.html#constant",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Generic Control",
          "module": "Synthesizer.Generic.Control",
          "name": "constant",
          "normalized": "LazySize-\u003ea-\u003eb a",
          "package": "synthesizer",
          "signature": "LazySize-\u003ey-\u003esig y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Control.html#v:constant"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "time t0 where  1 is approached \ntime t1 where -1 is approached \na cosine wave where one half wave is between t0 and t1 \n",
          "module": "Synthesizer.Generic.Control",
          "name": "cosine",
          "package": "synthesizer",
          "signature": "LazySize-\u003e y-\u003e y-\u003e sig y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Generic-Control.html#cosine",
          "type": "function"
        },
        "index": {
          "description": "time t0 where is approached time t1 where is approached cosine wave where one half wave is between t0 and t1",
          "hierarchy": "Synthesizer Generic Control",
          "module": "Synthesizer.Generic.Control",
          "name": "cosine",
          "normalized": "LazySize-\u003ea-\u003ea-\u003eb a",
          "package": "synthesizer",
          "signature": "LazySize-\u003ey-\u003ey-\u003esig y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Control.html#v:cosine"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "time t0 where  1 is approached \ntime t1 where -1 is approached \na cosine wave where one half wave is between t0 and t1 \n",
          "module": "Synthesizer.Generic.Control",
          "name": "cosineMultiscale",
          "package": "synthesizer",
          "signature": "LazySize-\u003e y-\u003e y-\u003e sig y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Generic-Control.html#cosineMultiscale",
          "type": "function"
        },
        "index": {
          "description": "time t0 where is approached time t1 where is approached cosine wave where one half wave is between t0 and t1",
          "hierarchy": "Synthesizer Generic Control",
          "module": "Synthesizer.Generic.Control",
          "name": "cosineMultiscale",
          "normalized": "LazySize-\u003ea-\u003ea-\u003eb a",
          "package": "synthesizer",
          "partial": "Multiscale",
          "signature": "LazySize-\u003ey-\u003ey-\u003esig y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Control.html#v:cosineMultiscale"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "time t0 where  1 is approached \ntime t1 where -1 is approached \na cosine wave where one half wave is between t0 and t1 \n",
          "module": "Synthesizer.Generic.Control",
          "name": "cosineMultiscaleLinear",
          "package": "synthesizer",
          "signature": "LazySize-\u003e y-\u003e y-\u003e sig y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Generic-Control.html#cosineMultiscaleLinear",
          "type": "function"
        },
        "index": {
          "description": "time t0 where is approached time t1 where is approached cosine wave where one half wave is between t0 and t1",
          "hierarchy": "Synthesizer Generic Control",
          "module": "Synthesizer.Generic.Control",
          "name": "cosineMultiscaleLinear",
          "normalized": "LazySize-\u003ea-\u003ea-\u003eb a",
          "package": "synthesizer",
          "partial": "Multiscale Linear",
          "signature": "LazySize-\u003ey-\u003ey-\u003esig y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Control.html#v:cosineMultiscaleLinear"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Generic.Control",
          "name": "cosineWithSlope",
          "package": "synthesizer",
          "signature": "(y -\u003e y -\u003e signal) -\u003e y -\u003e y -\u003e signal",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Generic-Control.html#cosineWithSlope",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Generic Control",
          "module": "Synthesizer.Generic.Control",
          "name": "cosineWithSlope",
          "normalized": "(a-\u003ea-\u003eb)-\u003ea-\u003ea-\u003eb",
          "package": "synthesizer",
          "partial": "With Slope",
          "signature": "(y-\u003ey-\u003esignal)-\u003ey-\u003ey-\u003esignal",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Control.html#v:cosineWithSlope"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "0                                     16\n0               8                     16\n0       4       8         12          16\n0   2   4   6   8   10    12    14    16\n0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16\n",
          "module": "Synthesizer.Generic.Control",
          "name": "cubicFunc",
          "package": "synthesizer",
          "signature": "(y, (y, y)) -\u003e (y, (y, y)) -\u003e y -\u003e y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Generic-Control.html#cubicFunc",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Generic Control",
          "module": "Synthesizer.Generic.Control",
          "name": "cubicFunc",
          "normalized": "(a,(a,a))-\u003e(a,(a,a))-\u003ea-\u003ea",
          "package": "synthesizer",
          "partial": "Func",
          "signature": "(y,(y,y))-\u003e(y,(y,y))-\u003ey-\u003ey",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Control.html#v:cubicFunc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Generic.Control",
          "name": "cubicHermite",
          "package": "synthesizer",
          "signature": "LazySize -\u003e (y, (y, y)) -\u003e (y, (y, y)) -\u003e sig y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Generic-Control.html#cubicHermite",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Generic Control",
          "module": "Synthesizer.Generic.Control",
          "name": "cubicHermite",
          "normalized": "LazySize-\u003e(a,(a,a))-\u003e(a,(a,a))-\u003eb a",
          "package": "synthesizer",
          "partial": "Hermite",
          "signature": "LazySize-\u003e(y,(y,y))-\u003e(y,(y,y))-\u003esig y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Control.html#v:cubicHermite"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Generic.Control",
          "name": "curveMultiscale",
          "package": "synthesizer",
          "signature": "LazySize -\u003e (y -\u003e y -\u003e y) -\u003e y -\u003e y -\u003e sig y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Generic-Control.html#curveMultiscale",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Generic Control",
          "module": "Synthesizer.Generic.Control",
          "name": "curveMultiscale",
          "normalized": "LazySize-\u003e(a-\u003ea-\u003ea)-\u003ea-\u003ea-\u003eb a",
          "package": "synthesizer",
          "partial": "Multiscale",
          "signature": "LazySize-\u003e(y-\u003ey-\u003ey)-\u003ey-\u003ey-\u003esig y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Control.html#v:curveMultiscale"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Generic.Control",
          "name": "curveMultiscaleNeutral",
          "package": "synthesizer",
          "signature": "LazySize -\u003e (y -\u003e y -\u003e y) -\u003e y -\u003e y -\u003e sig y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Generic-Control.html#curveMultiscaleNeutral",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Generic Control",
          "module": "Synthesizer.Generic.Control",
          "name": "curveMultiscaleNeutral",
          "normalized": "LazySize-\u003e(a-\u003ea-\u003ea)-\u003ea-\u003ea-\u003eb a",
          "package": "synthesizer",
          "partial": "Multiscale Neutral",
          "signature": "LazySize-\u003e(y-\u003ey-\u003ey)-\u003ey-\u003ey-\u003esig y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Control.html#v:curveMultiscaleNeutral"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "time where the function reaches 1/e of the initial value \ninitial value \nexponential decay \n",
          "module": "Synthesizer.Generic.Control",
          "name": "exponential",
          "package": "synthesizer",
          "signature": "LazySize-\u003e y-\u003e y-\u003e sig y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Generic-Control.html#exponential",
          "type": "function"
        },
        "index": {
          "description": "time where the function reaches of the initial value initial value exponential decay",
          "hierarchy": "Synthesizer Generic Control",
          "module": "Synthesizer.Generic.Control",
          "name": "exponential",
          "normalized": "LazySize-\u003ea-\u003ea-\u003eb a",
          "package": "synthesizer",
          "signature": "LazySize-\u003ey-\u003ey-\u003esig y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Control.html#v:exponential"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "half life \ninitial value \nexponential decay \n",
          "module": "Synthesizer.Generic.Control",
          "name": "exponential2",
          "package": "synthesizer",
          "signature": "LazySize-\u003e y-\u003e y-\u003e sig y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Generic-Control.html#exponential2",
          "type": "function"
        },
        "index": {
          "description": "half life initial value exponential decay",
          "hierarchy": "Synthesizer Generic Control",
          "module": "Synthesizer.Generic.Control",
          "name": "exponential2",
          "normalized": "LazySize-\u003ea-\u003ea-\u003eb a",
          "package": "synthesizer",
          "signature": "LazySize-\u003ey-\u003ey-\u003esig y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Control.html#v:exponential2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "half life \ninitial value \nexponential decay \n",
          "module": "Synthesizer.Generic.Control",
          "name": "exponential2Multiscale",
          "package": "synthesizer",
          "signature": "LazySize-\u003e y-\u003e y-\u003e sig y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Generic-Control.html#exponential2Multiscale",
          "type": "function"
        },
        "index": {
          "description": "half life initial value exponential decay",
          "hierarchy": "Synthesizer Generic Control",
          "module": "Synthesizer.Generic.Control",
          "name": "exponential2Multiscale",
          "normalized": "LazySize-\u003ea-\u003ea-\u003eb a",
          "package": "synthesizer",
          "partial": "Multiscale",
          "signature": "LazySize-\u003ey-\u003ey-\u003esig y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Control.html#v:exponential2Multiscale"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "half life \nexponential decay \n",
          "module": "Synthesizer.Generic.Control",
          "name": "exponential2MultiscaleNeutral",
          "package": "synthesizer",
          "signature": "LazySize-\u003e y-\u003e sig y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Generic-Control.html#exponential2MultiscaleNeutral",
          "type": "function"
        },
        "index": {
          "description": "half life exponential decay",
          "hierarchy": "Synthesizer Generic Control",
          "module": "Synthesizer.Generic.Control",
          "name": "exponential2MultiscaleNeutral",
          "normalized": "LazySize-\u003ea-\u003eb a",
          "package": "synthesizer",
          "partial": "Multiscale Neutral",
          "signature": "LazySize-\u003ey-\u003esig y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Control.html#v:exponential2MultiscaleNeutral"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "time where the function reaches 1/e of the initial value \ninitial value \nexponential decay \n",
          "module": "Synthesizer.Generic.Control",
          "name": "exponentialMultiscale",
          "package": "synthesizer",
          "signature": "LazySize-\u003e y-\u003e y-\u003e sig y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Generic-Control.html#exponentialMultiscale",
          "type": "function"
        },
        "index": {
          "description": "time where the function reaches of the initial value initial value exponential decay",
          "hierarchy": "Synthesizer Generic Control",
          "module": "Synthesizer.Generic.Control",
          "name": "exponentialMultiscale",
          "normalized": "LazySize-\u003ea-\u003ea-\u003eb a",
          "package": "synthesizer",
          "partial": "Multiscale",
          "signature": "LazySize-\u003ey-\u003ey-\u003esig y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Control.html#v:exponentialMultiscale"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "time where the function reaches 1/e of the initial value \nexponential decay \n",
          "module": "Synthesizer.Generic.Control",
          "name": "exponentialMultiscaleNeutral",
          "package": "synthesizer",
          "signature": "LazySize-\u003e y-\u003e sig y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Generic-Control.html#exponentialMultiscaleNeutral",
          "type": "function"
        },
        "index": {
          "description": "time where the function reaches of the initial value exponential decay",
          "hierarchy": "Synthesizer Generic Control",
          "module": "Synthesizer.Generic.Control",
          "name": "exponentialMultiscaleNeutral",
          "normalized": "LazySize-\u003ea-\u003eb a",
          "package": "synthesizer",
          "partial": "Multiscale Neutral",
          "signature": "LazySize-\u003ey-\u003esig y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Control.html#v:exponentialMultiscaleNeutral"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "length \ninitial and final value \nlinear progression \n",
          "module": "Synthesizer.Generic.Control",
          "name": "line",
          "package": "synthesizer",
          "signature": "LazySize-\u003e Int-\u003e (y, y)-\u003e sig y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Generic-Control.html#line",
          "type": "function"
        },
        "index": {
          "description": "length initial and final value linear progression",
          "hierarchy": "Synthesizer Generic Control",
          "module": "Synthesizer.Generic.Control",
          "name": "line",
          "normalized": "LazySize-\u003eInt-\u003e(a,a)-\u003eb a",
          "package": "synthesizer",
          "signature": "LazySize-\u003eInt-\u003e(y,y)-\u003esig y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Control.html#v:line"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "steepness \ninitial value \nlinear progression \n",
          "module": "Synthesizer.Generic.Control",
          "name": "linear",
          "package": "synthesizer",
          "signature": "LazySize-\u003e y-\u003e y-\u003e sig y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Generic-Control.html#linear",
          "type": "function"
        },
        "index": {
          "description": "steepness initial value linear progression",
          "hierarchy": "Synthesizer Generic Control",
          "module": "Synthesizer.Generic.Control",
          "name": "linear",
          "normalized": "LazySize-\u003ea-\u003ea-\u003eb a",
          "package": "synthesizer",
          "signature": "LazySize-\u003ey-\u003ey-\u003esig y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Control.html#v:linear"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Minimize rounding errors by reducing number of operations per element\nto a logarithmuc number.\n",
          "module": "Synthesizer.Generic.Control",
          "name": "linearMultiscale",
          "package": "synthesizer",
          "signature": "LazySize -\u003e y -\u003e y -\u003e sig y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Generic-Control.html#linearMultiscale",
          "type": "function"
        },
        "index": {
          "description": "Minimize rounding errors by reducing number of operations per element to logarithmuc number",
          "hierarchy": "Synthesizer Generic Control",
          "module": "Synthesizer.Generic.Control",
          "name": "linearMultiscale",
          "normalized": "LazySize-\u003ea-\u003ea-\u003eb a",
          "package": "synthesizer",
          "partial": "Multiscale",
          "signature": "LazySize-\u003ey-\u003ey-\u003esig y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Control.html#v:linearMultiscale"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Linear curve starting at zero.\n",
          "module": "Synthesizer.Generic.Control",
          "name": "linearMultiscaleNeutral",
          "package": "synthesizer",
          "signature": "LazySize -\u003e y -\u003e sig y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Generic-Control.html#linearMultiscaleNeutral",
          "type": "function"
        },
        "index": {
          "description": "Linear curve starting at zero",
          "hierarchy": "Synthesizer Generic Control",
          "module": "Synthesizer.Generic.Control",
          "name": "linearMultiscaleNeutral",
          "normalized": "LazySize-\u003ea-\u003eb a",
          "package": "synthesizer",
          "partial": "Multiscale Neutral",
          "signature": "LazySize-\u003ey-\u003esig y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Control.html#v:linearMultiscaleNeutral"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Generic.Control",
          "name": "piecewise",
          "package": "synthesizer",
          "signature": "LazySize -\u003e [ControlPiece y] -\u003e sig y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Generic-Control.html#piecewise",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Generic Control",
          "module": "Synthesizer.Generic.Control",
          "name": "piecewise",
          "normalized": "LazySize-\u003e[ControlPiece a]-\u003eb a",
          "package": "synthesizer",
          "signature": "LazySize-\u003e[ControlPiece y]-\u003esig y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Control.html#v:piecewise"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Generic.Control",
          "name": "piecewisePart",
          "package": "synthesizer",
          "signature": "LazySize -\u003e y -\u003e y -\u003e y -\u003e y -\u003e Int -\u003e Control y -\u003e sig y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Generic-Control.html#piecewisePart",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Generic Control",
          "module": "Synthesizer.Generic.Control",
          "name": "piecewisePart",
          "normalized": "LazySize-\u003ea-\u003ea-\u003ea-\u003ea-\u003eInt-\u003eControl a-\u003eb a",
          "package": "synthesizer",
          "partial": "Part",
          "signature": "LazySize-\u003ey-\u003ey-\u003ey-\u003ey-\u003eInt-\u003eControl y-\u003esig y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Control.html#v:piecewisePart"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "time where the function reaches 1/e of the initial value \ninitial value \nexponential decay \n",
          "module": "Synthesizer.Generic.Control",
          "name": "vectorExponential",
          "package": "synthesizer",
          "signature": "LazySize-\u003e y-\u003e v-\u003e sig v",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Generic-Control.html#vectorExponential",
          "type": "function"
        },
        "index": {
          "description": "time where the function reaches of the initial value initial value exponential decay",
          "hierarchy": "Synthesizer Generic Control",
          "module": "Synthesizer.Generic.Control",
          "name": "vectorExponential",
          "normalized": "LazySize-\u003ea-\u003eb-\u003ec b",
          "package": "synthesizer",
          "partial": "Exponential",
          "signature": "LazySize-\u003ey-\u003ev-\u003esig v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Control.html#v:vectorExponential"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "half life \ninitial value \nexponential decay \n",
          "module": "Synthesizer.Generic.Control",
          "name": "vectorExponential2",
          "package": "synthesizer",
          "signature": "LazySize-\u003e y-\u003e v-\u003e sig v",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Generic-Control.html#vectorExponential2",
          "type": "function"
        },
        "index": {
          "description": "half life initial value exponential decay",
          "hierarchy": "Synthesizer Generic Control",
          "module": "Synthesizer.Generic.Control",
          "name": "vectorExponential2",
          "normalized": "LazySize-\u003ea-\u003eb-\u003ec b",
          "package": "synthesizer",
          "partial": "Exponential",
          "signature": "LazySize-\u003ey-\u003ev-\u003esig v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Control.html#v:vectorExponential2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Generic.Control",
          "name": "|#",
          "package": "synthesizer",
          "signature": "y -\u003e (ControlDist y, [ControlPiece y]) -\u003e [ControlPiece y]",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Generic-Control.html#%7C%23",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Generic Control",
          "module": "Synthesizer.Generic.Control",
          "name": "|#",
          "normalized": "a-\u003e(ControlDist a,[ControlPiece a])-\u003e[ControlPiece a]",
          "package": "synthesizer",
          "signature": "y-\u003e(ControlDist y,[ControlPiece y])-\u003e[ControlPiece y]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Control.html#v:|#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Generic.Cut",
          "name": "Read",
          "package": "synthesizer",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Generic-Cut.html#Read",
          "type": "class"
        },
        "index": {
          "hierarchy": "Synthesizer Generic Cut",
          "module": "Synthesizer.Generic.Cut",
          "name": "Read",
          "package": "synthesizer",
          "partial": "Read",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Cut.html#v:Read"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Generic.Cut",
          "name": "Transform",
          "package": "synthesizer",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Generic-Cut.html#Transform",
          "type": "class"
        },
        "index": {
          "hierarchy": "Synthesizer Generic Cut",
          "module": "Synthesizer.Generic.Cut",
          "name": "Transform",
          "package": "synthesizer",
          "partial": "Transform",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Cut.html#v:Transform"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Synthesizer.Generic.Cut\",\"Synthesizer.Generic.Signal\"]",
          "name": "append",
          "package": "synthesizer",
          "signature": "sig -\u003e sig -\u003e sig",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Generic-Cut.html#append",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Cut.html#v:append\",\"http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Signal.html#v:append\"]"
        },
        "index": {
          "hierarchy": "Synthesizer Generic Cut",
          "module": "Synthesizer.Generic.Cut",
          "name": "append",
          "normalized": "a-\u003ea-\u003ea",
          "package": "synthesizer",
          "signature": "sig-\u003esig-\u003esig",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Cut.html#v:append"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Synthesizer.Generic.Cut\",\"Synthesizer.Generic.Signal\"]",
          "name": "concat",
          "package": "synthesizer",
          "signature": "[sig] -\u003e sig",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Generic-Cut.html#concat",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Cut.html#v:concat\",\"http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Signal.html#v:concat\"]"
        },
        "index": {
          "hierarchy": "Synthesizer Generic Cut",
          "module": "Synthesizer.Generic.Cut",
          "name": "concat",
          "normalized": "[a]-\u003ea",
          "package": "synthesizer",
          "signature": "[sig]-\u003esig",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Cut.html#v:concat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Synthesizer.Generic.Cut\",\"Synthesizer.Generic.Signal\"]",
          "name": "cycle",
          "package": "synthesizer",
          "signature": "sig -\u003e sig",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Generic-Cut.html#cycle",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Cut.html#v:cycle\",\"http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Signal.html#v:cycle\"]"
        },
        "index": {
          "hierarchy": "Synthesizer Generic Cut",
          "module": "Synthesizer.Generic.Cut",
          "name": "cycle",
          "normalized": "a-\u003ea",
          "package": "synthesizer",
          "signature": "sig-\u003esig",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Cut.html#v:cycle"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Synthesizer.Generic.Cut\",\"Synthesizer.Generic.Signal\"]",
          "name": "drop",
          "package": "synthesizer",
          "signature": "Int -\u003e sig -\u003e sig",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Generic-Cut.html#drop",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Cut.html#v:drop\",\"http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Signal.html#v:drop\"]"
        },
        "index": {
          "hierarchy": "Synthesizer Generic Cut",
          "module": "Synthesizer.Generic.Cut",
          "name": "drop",
          "normalized": "Int-\u003ea-\u003ea",
          "package": "synthesizer",
          "signature": "Int-\u003esig-\u003esig",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Cut.html#v:drop"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Synthesizer.Generic.Cut\",\"Synthesizer.Generic.Signal\"]",
          "name": "dropMarginRem",
          "package": "synthesizer",
          "signature": "Int -\u003e Int -\u003e sig -\u003e (Int, sig)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Generic-Cut.html#dropMarginRem",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Cut.html#v:dropMarginRem\",\"http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Signal.html#v:dropMarginRem\"]"
        },
        "index": {
          "hierarchy": "Synthesizer Generic Cut",
          "module": "Synthesizer.Generic.Cut",
          "name": "dropMarginRem",
          "normalized": "Int-\u003eInt-\u003ea-\u003e(Int,a)",
          "package": "synthesizer",
          "partial": "Margin Rem",
          "signature": "Int-\u003eInt-\u003esig-\u003e(Int,sig)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Cut.html#v:dropMarginRem"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Synthesizer.Generic.Cut\",\"Synthesizer.Generic.Signal\"]",
          "name": "empty",
          "package": "synthesizer",
          "signature": "sig",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Generic-Cut.html#empty",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Cut.html#v:empty\",\"http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Signal.html#v:empty\"]"
        },
        "index": {
          "hierarchy": "Synthesizer Generic Cut",
          "module": "Synthesizer.Generic.Cut",
          "name": "empty",
          "package": "synthesizer",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Cut.html#v:empty"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Generic.Cut",
          "name": "intToChunky",
          "package": "synthesizer",
          "signature": "String -\u003e Int -\u003e T a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Generic-Cut.html#intToChunky",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Generic Cut",
          "module": "Synthesizer.Generic.Cut",
          "name": "intToChunky",
          "normalized": "String-\u003eInt-\u003eT a",
          "package": "synthesizer",
          "partial": "To Chunky",
          "signature": "String-\u003eInt-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Cut.html#v:intToChunky"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Synthesizer.Generic.Cut\",\"Synthesizer.Generic.Signal\"]",
          "name": "length",
          "package": "synthesizer",
          "signature": "sig -\u003e Int",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Generic-Cut.html#length",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Cut.html#v:length\",\"http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Signal.html#v:length\"]"
        },
        "index": {
          "hierarchy": "Synthesizer Generic Cut",
          "module": "Synthesizer.Generic.Cut",
          "name": "length",
          "normalized": "a-\u003eInt",
          "package": "synthesizer",
          "signature": "sig-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Cut.html#v:length"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Like \u003ctt\u003elengthAtLeast n xs  =  length xs \u003e= n\u003c/tt\u003e,\nbut is more efficient, because it is more lazy.\n",
          "module": "[\"Synthesizer.Generic.Cut\",\"Synthesizer.Generic.Signal\"]",
          "name": "lengthAtLeast",
          "package": "synthesizer",
          "signature": "Int -\u003e sig -\u003e Bool",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Generic-Cut.html#lengthAtLeast",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Cut.html#v:lengthAtLeast\",\"http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Signal.html#v:lengthAtLeast\"]"
        },
        "index": {
          "description": "Like lengthAtLeast xs length xs but is more efficient because it is more lazy",
          "hierarchy": "Synthesizer Generic Cut",
          "module": "Synthesizer.Generic.Cut",
          "name": "lengthAtLeast",
          "normalized": "Int-\u003ea-\u003eBool",
          "package": "synthesizer",
          "partial": "At Least",
          "signature": "Int-\u003esig-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Cut.html#v:lengthAtLeast"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Synthesizer.Generic.Cut\",\"Synthesizer.Generic.Signal\"]",
          "name": "lengthAtMost",
          "package": "synthesizer",
          "signature": "Int -\u003e sig -\u003e Bool",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Generic-Cut.html#lengthAtMost",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Cut.html#v:lengthAtMost\",\"http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Signal.html#v:lengthAtMost\"]"
        },
        "index": {
          "hierarchy": "Synthesizer Generic Cut",
          "module": "Synthesizer.Generic.Cut",
          "name": "lengthAtMost",
          "normalized": "Int-\u003ea-\u003eBool",
          "package": "synthesizer",
          "partial": "At Most",
          "signature": "Int-\u003esig-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Cut.html#v:lengthAtMost"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Synthesizer.Generic.Cut\",\"Synthesizer.Generic.Signal\"]",
          "name": "null",
          "package": "synthesizer",
          "signature": "sig -\u003e Bool",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Generic-Cut.html#null",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Cut.html#v:null\",\"http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Signal.html#v:null\"]"
        },
        "index": {
          "hierarchy": "Synthesizer Generic Cut",
          "module": "Synthesizer.Generic.Cut",
          "name": "null",
          "normalized": "a-\u003eBool",
          "package": "synthesizer",
          "signature": "sig-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Cut.html#v:null"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Synthesizer.Generic.Cut\",\"Synthesizer.Generic.Signal\"]",
          "name": "reverse",
          "package": "synthesizer",
          "signature": "sig -\u003e sig",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Generic-Cut.html#reverse",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Cut.html#v:reverse\",\"http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Signal.html#v:reverse\"]"
        },
        "index": {
          "hierarchy": "Synthesizer Generic Cut",
          "module": "Synthesizer.Generic.Cut",
          "name": "reverse",
          "normalized": "a-\u003ea",
          "package": "synthesizer",
          "signature": "sig-\u003esig",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Cut.html#v:reverse"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Synthesizer.Generic.Cut\",\"Synthesizer.Generic.Signal\"]",
          "name": "sliceVertical",
          "package": "synthesizer",
          "signature": "Int -\u003e sig -\u003e T sig",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Generic-Cut.html#sliceVertical",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Cut.html#v:sliceVertical\",\"http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Signal.html#v:sliceVertical\"]"
        },
        "index": {
          "hierarchy": "Synthesizer Generic Cut",
          "module": "Synthesizer.Generic.Cut",
          "name": "sliceVertical",
          "normalized": "Int-\u003ea-\u003eT a",
          "package": "synthesizer",
          "partial": "Vertical",
          "signature": "Int-\u003esig-\u003eT sig",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Cut.html#v:sliceVertical"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Synthesizer.Generic.Cut\",\"Synthesizer.Generic.Signal\"]",
          "name": "splitAt",
          "package": "synthesizer",
          "signature": "Int -\u003e sig -\u003e (sig, sig)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Generic-Cut.html#splitAt",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Cut.html#v:splitAt\",\"http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Signal.html#v:splitAt\"]"
        },
        "index": {
          "hierarchy": "Synthesizer Generic Cut",
          "module": "Synthesizer.Generic.Cut",
          "name": "splitAt",
          "normalized": "Int-\u003ea-\u003e(a,a)",
          "package": "synthesizer",
          "partial": "At",
          "signature": "Int-\u003esig-\u003e(sig,sig)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Cut.html#v:splitAt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Synthesizer.Generic.Cut\",\"Synthesizer.Generic.Signal\"]",
          "name": "take",
          "package": "synthesizer",
          "signature": "Int -\u003e sig -\u003e sig",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Generic-Cut.html#take",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Cut.html#v:take\",\"http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Signal.html#v:take\"]"
        },
        "index": {
          "hierarchy": "Synthesizer Generic Cut",
          "module": "Synthesizer.Generic.Cut",
          "name": "take",
          "normalized": "Int-\u003ea-\u003ea",
          "package": "synthesizer",
          "signature": "Int-\u003esig-\u003esig",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Cut.html#v:take"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "In \u003ca\u003eSynthesizer.Basic.Distortion\u003c/a\u003e you find a collection\nof appropriate distortion functions.\n",
          "module": "Synthesizer.Generic.Displacement",
          "name": "distort",
          "package": "synthesizer",
          "signature": "(c -\u003e v -\u003e v) -\u003e sig c -\u003e sig v -\u003e sig v",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Generic-Displacement.html#distort",
          "type": "function"
        },
        "index": {
          "description": "In Synthesizer.Basic.Distortion you find collection of appropriate distortion functions",
          "hierarchy": "Synthesizer Generic Displacement",
          "module": "Synthesizer.Generic.Displacement",
          "name": "distort",
          "normalized": "(a-\u003eb-\u003eb)-\u003ec a-\u003ec b-\u003ec b",
          "package": "synthesizer",
          "signature": "(c-\u003ev-\u003ev)-\u003esig c-\u003esig v-\u003esig v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Displacement.html#v:distort"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Mix two signals.\n    In opposition to \u003ctt\u003e\u003ca\u003ezipWith\u003c/a\u003e\u003c/tt\u003e the result has the length of the longer signal. \n",
          "module": "Synthesizer.Generic.Displacement",
          "name": "mix",
          "package": "synthesizer",
          "signature": "sig v -\u003e sig v -\u003e sig v",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Generic-Displacement.html#mix",
          "type": "function"
        },
        "index": {
          "description": "Mix two signals In opposition to zipWith the result has the length of the longer signal",
          "hierarchy": "Synthesizer Generic Displacement",
          "module": "Synthesizer.Generic.Displacement",
          "name": "mix",
          "normalized": "a b-\u003ea b-\u003ea b",
          "package": "synthesizer",
          "signature": "sig v-\u003esig v-\u003esig v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Displacement.html#v:mix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Mix one or more signals. \n",
          "module": "Synthesizer.Generic.Displacement",
          "name": "mixMulti",
          "package": "synthesizer",
          "signature": "[sig v] -\u003e sig v",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Generic-Displacement.html#mixMulti",
          "type": "function"
        },
        "index": {
          "description": "Mix one or more signals",
          "hierarchy": "Synthesizer Generic Displacement",
          "module": "Synthesizer.Generic.Displacement",
          "name": "mixMulti",
          "normalized": "[a b]-\u003ea b",
          "package": "synthesizer",
          "partial": "Multi",
          "signature": "[sig v]-\u003esig v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Displacement.html#v:mixMulti"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Add a number to all of the signal values.\n    This is useful for adjusting the center of a modulation. \n",
          "module": "Synthesizer.Generic.Displacement",
          "name": "raise",
          "package": "synthesizer",
          "signature": "v -\u003e sig v -\u003e sig v",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Generic-Displacement.html#raise",
          "type": "function"
        },
        "index": {
          "description": "Add number to all of the signal values This is useful for adjusting the center of modulation",
          "hierarchy": "Synthesizer Generic Displacement",
          "module": "Synthesizer.Generic.Displacement",
          "name": "raise",
          "normalized": "a-\u003eb a-\u003eb a",
          "package": "synthesizer",
          "signature": "v-\u003esig v-\u003esig v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Displacement.html#v:raise"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "This is essentially different for constant interpolation,\nbecause this function \u003ca\u003elooks forward\u003c/a\u003e\nwhereas the other two variants \u003ca\u003elook backward\u003c/a\u003e.\nFor the symmetric interpolation functions\nof linear and cubic interpolation, this does not really matter.\n",
          "module": "Synthesizer.Generic.Filter.Delay",
          "name": "modulated",
          "package": "synthesizer",
          "signature": "T t y -\u003e Int -\u003e sig t -\u003e sig y -\u003e sig y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Generic-Filter-Delay.html#modulated",
          "type": "function"
        },
        "index": {
          "description": "This is essentially different for constant interpolation because this function looks forward whereas the other two variants look backward For the symmetric interpolation functions of linear and cubic interpolation this does not really matter",
          "hierarchy": "Synthesizer Generic Filter Delay",
          "module": "Synthesizer.Generic.Filter.Delay",
          "name": "modulated",
          "normalized": "T a b-\u003eInt-\u003ec a-\u003ec b-\u003ec b",
          "package": "synthesizer",
          "signature": "T t y-\u003eInt-\u003esig t-\u003esig y-\u003esig y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Filter-Delay.html#v:modulated"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Generic.Filter.Delay",
          "name": "modulatedCore",
          "package": "synthesizer",
          "signature": "T t y -\u003e Int -\u003e sig t -\u003e sig y -\u003e sig y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Generic-Filter-Delay.html#modulatedCore",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Generic Filter Delay",
          "module": "Synthesizer.Generic.Filter.Delay",
          "name": "modulatedCore",
          "normalized": "T a b-\u003eInt-\u003ec a-\u003ec b-\u003ec b",
          "package": "synthesizer",
          "partial": "Core",
          "signature": "T t y-\u003eInt-\u003esig t-\u003esig y-\u003esig y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Filter-Delay.html#v:modulatedCore"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Generic.Filter.Delay",
          "name": "static",
          "package": "synthesizer",
          "signature": "Int -\u003e sig y -\u003e sig y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Generic-Filter-Delay.html#static",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Generic Filter Delay",
          "module": "Synthesizer.Generic.Filter.Delay",
          "name": "static",
          "normalized": "Int-\u003ea b-\u003ea b",
          "package": "synthesizer",
          "signature": "Int-\u003esig y-\u003esig y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Filter-Delay.html#v:static"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Generic.Filter.Delay",
          "name": "staticNeg",
          "package": "synthesizer",
          "signature": "Int -\u003e sig y -\u003e sig y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Generic-Filter-Delay.html#staticNeg",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Generic Filter Delay",
          "module": "Synthesizer.Generic.Filter.Delay",
          "name": "staticNeg",
          "normalized": "Int-\u003ea b-\u003ea b",
          "package": "synthesizer",
          "partial": "Neg",
          "signature": "Int-\u003esig y-\u003esig y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Filter-Delay.html#v:staticNeg"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Generic.Filter.Delay",
          "name": "staticPad",
          "package": "synthesizer",
          "signature": "y -\u003e Int -\u003e sig y -\u003e sig y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Generic-Filter-Delay.html#staticPad",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Generic Filter Delay",
          "module": "Synthesizer.Generic.Filter.Delay",
          "name": "staticPad",
          "normalized": "a-\u003eInt-\u003eb a-\u003eb a",
          "package": "synthesizer",
          "partial": "Pad",
          "signature": "y-\u003eInt-\u003esig y-\u003esig y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Filter-Delay.html#v:staticPad"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Generic.Filter.Delay",
          "name": "staticPos",
          "package": "synthesizer",
          "signature": "Int -\u003e sig y -\u003e sig y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Generic-Filter-Delay.html#staticPos",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Generic Filter Delay",
          "module": "Synthesizer.Generic.Filter.Delay",
          "name": "staticPos",
          "normalized": "Int-\u003ea b-\u003ea b",
          "package": "synthesizer",
          "partial": "Pos",
          "signature": "Int-\u003esig y-\u003esig y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Filter-Delay.html#v:staticPos"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Generic.Filter.NonRecursive",
          "name": "amplify",
          "package": "synthesizer",
          "signature": "a -\u003e sig a -\u003e sig a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Generic-Filter-NonRecursive.html#amplify",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Generic Filter NonRecursive",
          "module": "Synthesizer.Generic.Filter.NonRecursive",
          "name": "amplify",
          "normalized": "a-\u003eb a-\u003eb a",
          "package": "synthesizer",
          "signature": "a-\u003esig a-\u003esig a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Filter-NonRecursive.html#v:amplify"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Generic.Filter.NonRecursive",
          "name": "amplifyVector",
          "package": "synthesizer",
          "signature": "a -\u003e sig v -\u003e sig v",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Generic-Filter-NonRecursive.html#amplifyVector",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Generic Filter NonRecursive",
          "module": "Synthesizer.Generic.Filter.NonRecursive",
          "name": "amplifyVector",
          "normalized": "a-\u003eb c-\u003eb c",
          "package": "synthesizer",
          "partial": "Vector",
          "signature": "a-\u003esig v-\u003esig v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Filter-NonRecursive.html#v:amplifyVector"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Generic.Filter.NonRecursive",
          "name": "binomial",
          "package": "synthesizer",
          "signature": "a -\u003e a -\u003e sig v -\u003e sig v",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Generic-Filter-NonRecursive.html#binomial",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Generic Filter NonRecursive",
          "module": "Synthesizer.Generic.Filter.NonRecursive",
          "name": "binomial",
          "normalized": "a-\u003ea-\u003eb c-\u003eb c",
          "package": "synthesizer",
          "signature": "a-\u003ea-\u003esig v-\u003esig v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Filter-NonRecursive.html#v:binomial"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Generic.Filter.NonRecursive",
          "name": "binomial1",
          "package": "synthesizer",
          "signature": "sig v -\u003e sig v",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Generic-Filter-NonRecursive.html#binomial1",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Generic Filter NonRecursive",
          "module": "Synthesizer.Generic.Filter.NonRecursive",
          "name": "binomial1",
          "normalized": "a b-\u003ea b",
          "package": "synthesizer",
          "signature": "sig v-\u003esig v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Filter-NonRecursive.html#v:binomial1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Generic.Filter.NonRecursive",
          "name": "delay",
          "package": "synthesizer",
          "signature": "Int -\u003e sig y -\u003e sig y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Generic-Filter-NonRecursive.html#delay",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Generic Filter NonRecursive",
          "module": "Synthesizer.Generic.Filter.NonRecursive",
          "name": "delay",
          "normalized": "Int-\u003ea b-\u003ea b",
          "package": "synthesizer",
          "signature": "Int-\u003esig y-\u003esig y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Filter-NonRecursive.html#v:delay"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Generic.Filter.NonRecursive",
          "name": "delayLazySize",
          "package": "synthesizer",
          "signature": "LazySize -\u003e Int -\u003e sig y -\u003e sig y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Generic-Filter-NonRecursive.html#delayLazySize",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Generic Filter NonRecursive",
          "module": "Synthesizer.Generic.Filter.NonRecursive",
          "name": "delayLazySize",
          "normalized": "LazySize-\u003eInt-\u003ea b-\u003ea b",
          "package": "synthesizer",
          "partial": "Lazy Size",
          "signature": "LazySize-\u003eInt-\u003esig y-\u003esig y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Filter-NonRecursive.html#v:delayLazySize"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Generic.Filter.NonRecursive",
          "name": "delayNeg",
          "package": "synthesizer",
          "signature": "Int -\u003e sig y -\u003e sig y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Generic-Filter-NonRecursive.html#delayNeg",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Generic Filter NonRecursive",
          "module": "Synthesizer.Generic.Filter.NonRecursive",
          "name": "delayNeg",
          "normalized": "Int-\u003ea b-\u003ea b",
          "package": "synthesizer",
          "partial": "Neg",
          "signature": "Int-\u003esig y-\u003esig y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Filter-NonRecursive.html#v:delayNeg"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Generic.Filter.NonRecursive",
          "name": "delayPad",
          "package": "synthesizer",
          "signature": "y -\u003e Int -\u003e sig y -\u003e sig y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Generic-Filter-NonRecursive.html#delayPad",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Generic Filter NonRecursive",
          "module": "Synthesizer.Generic.Filter.NonRecursive",
          "name": "delayPad",
          "normalized": "a-\u003eInt-\u003eb a-\u003eb a",
          "package": "synthesizer",
          "partial": "Pad",
          "signature": "y-\u003eInt-\u003esig y-\u003esig y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Filter-NonRecursive.html#v:delayPad"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "The pad value \u003ctt\u003ey\u003c/tt\u003e must be defined,\notherwise the chunk size of the padding can be observed.\n",
          "module": "Synthesizer.Generic.Filter.NonRecursive",
          "name": "delayPadLazySize",
          "package": "synthesizer",
          "signature": "LazySize -\u003e y -\u003e Int -\u003e sig y -\u003e sig y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Generic-Filter-NonRecursive.html#delayPadLazySize",
          "type": "function"
        },
        "index": {
          "description": "The pad value must be defined otherwise the chunk size of the padding can be observed",
          "hierarchy": "Synthesizer Generic Filter NonRecursive",
          "module": "Synthesizer.Generic.Filter.NonRecursive",
          "name": "delayPadLazySize",
          "normalized": "LazySize-\u003ea-\u003eInt-\u003eb a-\u003eb a",
          "package": "synthesizer",
          "partial": "Pad Lazy Size",
          "signature": "LazySize-\u003ey-\u003eInt-\u003esig y-\u003esig y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Filter-NonRecursive.html#v:delayPadLazySize"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Generic.Filter.NonRecursive",
          "name": "delayPos",
          "package": "synthesizer",
          "signature": "Int -\u003e sig y -\u003e sig y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Generic-Filter-NonRecursive.html#delayPos",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Generic Filter NonRecursive",
          "module": "Synthesizer.Generic.Filter.NonRecursive",
          "name": "delayPos",
          "normalized": "Int-\u003ea b-\u003ea b",
          "package": "synthesizer",
          "partial": "Pos",
          "signature": "Int-\u003esig y-\u003esig y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Filter-NonRecursive.html#v:delayPos"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Generic.Filter.NonRecursive",
          "name": "delayPosLazySize",
          "package": "synthesizer",
          "signature": "LazySize -\u003e Int -\u003e sig y -\u003e sig y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Generic-Filter-NonRecursive.html#delayPosLazySize",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Generic Filter NonRecursive",
          "module": "Synthesizer.Generic.Filter.NonRecursive",
          "name": "delayPosLazySize",
          "normalized": "LazySize-\u003eInt-\u003ea b-\u003ea b",
          "package": "synthesizer",
          "partial": "Pos Lazy Size",
          "signature": "LazySize-\u003eInt-\u003esig y-\u003esig y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Filter-NonRecursive.html#v:delayPosLazySize"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Forward difference quotient.\nShortens the signal by one.\nInverts Synthesizer.Generic.Filter.Recursive.Integration.run in the sense that\n\u003ctt\u003edifferentiate (zero : integrate x) == x\u003c/tt\u003e.\nThe signal is shifted by a half time unit.\n",
          "module": "Synthesizer.Generic.Filter.NonRecursive",
          "name": "differentiate",
          "package": "synthesizer",
          "signature": "sig v -\u003e sig v",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Generic-Filter-NonRecursive.html#differentiate",
          "type": "function"
        },
        "index": {
          "description": "Forward difference quotient Shortens the signal by one Inverts Synthesizer.Generic.Filter.Recursive.Integration.run in the sense that differentiate zero integrate The signal is shifted by half time unit",
          "hierarchy": "Synthesizer Generic Filter NonRecursive",
          "module": "Synthesizer.Generic.Filter.NonRecursive",
          "name": "differentiate",
          "normalized": "a b-\u003ea b",
          "package": "synthesizer",
          "signature": "sig v-\u003esig v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Filter-NonRecursive.html#v:differentiate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Second derivative.\nIt is \u003ctt\u003edifferentiate2 == differentiate . differentiate\u003c/tt\u003e\nbut \u003ctt\u003e\u003ca\u003edifferentiate2\u003c/a\u003e\u003c/tt\u003e should be faster.\n",
          "module": "Synthesizer.Generic.Filter.NonRecursive",
          "name": "differentiate2",
          "package": "synthesizer",
          "signature": "sig v -\u003e sig v",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Generic-Filter-NonRecursive.html#differentiate2",
          "type": "function"
        },
        "index": {
          "description": "Second derivative It is differentiate2 differentiate differentiate but differentiate2 should be faster",
          "hierarchy": "Synthesizer Generic Filter NonRecursive",
          "module": "Synthesizer.Generic.Filter.NonRecursive",
          "name": "differentiate2",
          "normalized": "a b-\u003ea b",
          "package": "synthesizer",
          "signature": "sig v-\u003esig v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Filter-NonRecursive.html#v:differentiate2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCentral difference quotient.\nShortens the signal by two elements,\nand shifts the signal by one element.\n(Which can be fixed by prepending an appropriate value.)\nFor linear functions this will yield\nessentially the same result as \u003ctt\u003e\u003ca\u003edifferentiate\u003c/a\u003e\u003c/tt\u003e.\nYou obtain the result of \u003ctt\u003e\u003ca\u003edifferentiateCenter\u003c/a\u003e\u003c/tt\u003e\nif you smooth the one of \u003ctt\u003e\u003ca\u003edifferentiate\u003c/a\u003e\u003c/tt\u003e\nby averaging pairs of adjacent values.\n\u003c/p\u003e\u003cp\u003eToDo: Vector variant\n\u003c/p\u003e",
          "module": "Synthesizer.Generic.Filter.NonRecursive",
          "name": "differentiateCenter",
          "package": "synthesizer",
          "signature": "sig v -\u003e sig v",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Generic-Filter-NonRecursive.html#differentiateCenter",
          "type": "function"
        },
        "index": {
          "description": "Central difference quotient Shortens the signal by two elements and shifts the signal by one element Which can be fixed by prepending an appropriate value For linear functions this will yield essentially the same result as differentiate You obtain the result of differentiateCenter if you smooth the one of differentiate by averaging pairs of adjacent values ToDo Vector variant",
          "hierarchy": "Synthesizer Generic Filter NonRecursive",
          "module": "Synthesizer.Generic.Filter.NonRecursive",
          "name": "differentiateCenter",
          "normalized": "a b-\u003ea b",
          "package": "synthesizer",
          "partial": "Center",
          "signature": "sig v-\u003esig v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Filter-NonRecursive.html#v:differentiateCenter"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "the envelope \nthe signal to be enveloped \n",
          "module": "Synthesizer.Generic.Filter.NonRecursive",
          "name": "envelope",
          "package": "synthesizer",
          "signature": "sig a-\u003e sig a-\u003e sig a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Generic-Filter-NonRecursive.html#envelope",
          "type": "function"
        },
        "index": {
          "description": "the envelope the signal to be enveloped",
          "hierarchy": "Synthesizer Generic Filter NonRecursive",
          "module": "Synthesizer.Generic.Filter.NonRecursive",
          "name": "envelope",
          "normalized": "a b-\u003ea b-\u003ea b",
          "package": "synthesizer",
          "signature": "sig a-\u003esig a-\u003esig a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Filter-NonRecursive.html#v:envelope"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "the envelope \nthe signal to be enveloped \n",
          "module": "Synthesizer.Generic.Filter.NonRecursive",
          "name": "envelopeVector",
          "package": "synthesizer",
          "signature": "sig a-\u003e sig v-\u003e sig v",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Generic-Filter-NonRecursive.html#envelopeVector",
          "type": "function"
        },
        "index": {
          "description": "the envelope the signal to be enveloped",
          "hierarchy": "Synthesizer Generic Filter NonRecursive",
          "module": "Synthesizer.Generic.Filter.NonRecursive",
          "name": "envelopeVector",
          "normalized": "a b-\u003ea c-\u003ea c",
          "package": "synthesizer",
          "partial": "Vector",
          "signature": "sig a-\u003esig v-\u003esig v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Filter-NonRecursive.html#v:envelopeVector"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Generic.Filter.NonRecursive",
          "name": "fadeInOut",
          "package": "synthesizer",
          "signature": "Int -\u003e Int -\u003e Int -\u003e sig a -\u003e sig a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Generic-Filter-NonRecursive.html#fadeInOut",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Generic Filter NonRecursive",
          "module": "Synthesizer.Generic.Filter.NonRecursive",
          "name": "fadeInOut",
          "normalized": "Int-\u003eInt-\u003eInt-\u003ea b-\u003ea b",
          "package": "synthesizer",
          "partial": "In Out",
          "signature": "Int-\u003eInt-\u003eInt-\u003esig a-\u003esig a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Filter-NonRecursive.html#v:fadeInOut"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Unmodulated non-recursive filter \n",
          "module": "Synthesizer.Generic.Filter.NonRecursive",
          "name": "generic",
          "package": "synthesizer",
          "signature": "sig a -\u003e sig v -\u003e sig v",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Generic-Filter-NonRecursive.html#generic",
          "type": "function"
        },
        "index": {
          "description": "Unmodulated non-recursive filter",
          "hierarchy": "Synthesizer Generic Filter NonRecursive",
          "module": "Synthesizer.Generic.Filter.NonRecursive",
          "name": "generic",
          "normalized": "a b-\u003ea c-\u003ea c",
          "package": "synthesizer",
          "signature": "sig a-\u003esig v-\u003esig v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Filter-NonRecursive.html#v:generic"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Generic.Filter.NonRecursive",
          "name": "negate",
          "package": "synthesizer",
          "signature": "sig a -\u003e sig a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Generic-Filter-NonRecursive.html#negate",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Generic Filter NonRecursive",
          "module": "Synthesizer.Generic.Filter.NonRecursive",
          "name": "negate",
          "normalized": "a b-\u003ea b",
          "package": "synthesizer",
          "signature": "sig a-\u003esig a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Filter-NonRecursive.html#v:negate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Compute the variance of the Gaussian\n  such that its Fourier transform has value \u003ctt\u003eratio\u003c/tt\u003e at frequency \u003ctt\u003efreq\u003c/tt\u003e.\n",
          "module": "Synthesizer.Generic.Filter.NonRecursive",
          "name": "ratioFreqToVariance",
          "package": "synthesizer",
          "signature": "a -\u003e a -\u003e a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Generic-Filter-NonRecursive.html#ratioFreqToVariance",
          "type": "function"
        },
        "index": {
          "description": "Compute the variance of the Gaussian such that its Fourier transform has value ratio at frequency freq",
          "hierarchy": "Synthesizer Generic Filter NonRecursive",
          "module": "Synthesizer.Generic.Filter.NonRecursive",
          "name": "ratioFreqToVariance",
          "normalized": "a-\u003ea-\u003ea",
          "package": "synthesizer",
          "partial": "Freq To Variance",
          "signature": "a-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Filter-NonRecursive.html#v:ratioFreqToVariance"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Moving (uniformly weighted) average in the most trivial form.\nThis is very slow and needs about \u003ctt\u003en * length x\u003c/tt\u003e operations.\n",
          "module": "Synthesizer.Generic.Filter.NonRecursive",
          "name": "sums",
          "package": "synthesizer",
          "signature": "Int -\u003e sig v -\u003e sig v",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Generic-Filter-NonRecursive.html#sums",
          "type": "function"
        },
        "index": {
          "description": "Moving uniformly weighted average in the most trivial form This is very slow and needs about length operations",
          "hierarchy": "Synthesizer Generic Filter NonRecursive",
          "module": "Synthesizer.Generic.Filter.NonRecursive",
          "name": "sums",
          "normalized": "Int-\u003ea b-\u003ea b",
          "package": "synthesizer",
          "signature": "Int-\u003esig v-\u003esig v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Filter-NonRecursive.html#v:sums"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "The most simple version of the Karplus-Strong algorithm\nwhich is suitable to simulate a plucked string.\nIt is similar to the \u003ctt\u003e\u003ca\u003erunProc\u003c/a\u003e\u003c/tt\u003e function.\n",
          "module": "Synthesizer.Generic.Filter.Recursive.Comb",
          "name": "karplusStrong",
          "package": "synthesizer",
          "signature": "Parameter t -\u003e sig y -\u003e sig y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Generic-Filter-Recursive-Comb.html#karplusStrong",
          "type": "function"
        },
        "index": {
          "description": "The most simple version of the Karplus-Strong algorithm which is suitable to simulate plucked string It is similar to the runProc function",
          "hierarchy": "Synthesizer Generic Filter Recursive Comb",
          "module": "Synthesizer.Generic.Filter.Recursive.Comb",
          "name": "karplusStrong",
          "normalized": "Parameter a-\u003eb c-\u003eb c",
          "package": "synthesizer",
          "partial": "Strong",
          "signature": "Parameter t-\u003esig y-\u003esig y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Filter-Recursive-Comb.html#v:karplusStrong"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Infinitely many equi-delayed exponentially decaying echos.\nThe echos are clipped to the input length.\nWe think it is easier (and simpler to do efficiently)\nto pad the input with zeros or whatever\ninstead of cutting the result according to the input length.\n",
          "module": "Synthesizer.Generic.Filter.Recursive.Comb",
          "name": "run",
          "package": "synthesizer",
          "signature": "Int -\u003e t -\u003e sig y -\u003e sig y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Generic-Filter-Recursive-Comb.html#run",
          "type": "function"
        },
        "index": {
          "description": "Infinitely many equi-delayed exponentially decaying echos The echos are clipped to the input length We think it is easier and simpler to do efficiently to pad the input with zeros or whatever instead of cutting the result according to the input length",
          "hierarchy": "Synthesizer Generic Filter Recursive Comb",
          "module": "Synthesizer.Generic.Filter.Recursive.Comb",
          "name": "run",
          "normalized": "Int-\u003ea-\u003eb c-\u003eb c",
          "package": "synthesizer",
          "signature": "Int-\u003et-\u003esig y-\u003esig y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Filter-Recursive-Comb.html#v:run"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Echos of different delays.\nChunk size must be smaller than all of the delay times.\n",
          "module": "Synthesizer.Generic.Filter.Recursive.Comb",
          "name": "runMulti",
          "package": "synthesizer",
          "signature": "[Int] -\u003e t -\u003e sig y -\u003e sig y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Generic-Filter-Recursive-Comb.html#runMulti",
          "type": "function"
        },
        "index": {
          "description": "Echos of different delays Chunk size must be smaller than all of the delay times",
          "hierarchy": "Synthesizer Generic Filter Recursive Comb",
          "module": "Synthesizer.Generic.Filter.Recursive.Comb",
          "name": "runMulti",
          "normalized": "[Int]-\u003ea-\u003eb c-\u003eb c",
          "package": "synthesizer",
          "partial": "Multi",
          "signature": "[Int]-\u003et-\u003esig y-\u003esig y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Filter-Recursive-Comb.html#v:runMulti"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Echos can be piped through an arbitrary signal processor. \n",
          "module": "Synthesizer.Generic.Filter.Recursive.Comb",
          "name": "runProc",
          "package": "synthesizer",
          "signature": "Int -\u003e (sig y -\u003e sig y) -\u003e sig y -\u003e sig y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Generic-Filter-Recursive-Comb.html#runProc",
          "type": "function"
        },
        "index": {
          "description": "Echos can be piped through an arbitrary signal processor",
          "hierarchy": "Synthesizer Generic Filter Recursive Comb",
          "module": "Synthesizer.Generic.Filter.Recursive.Comb",
          "name": "runProc",
          "normalized": "Int-\u003e(a b-\u003ea b)-\u003ea b-\u003ea b",
          "package": "synthesizer",
          "partial": "Proc",
          "signature": "Int-\u003e(sig y-\u003esig y)-\u003esig y-\u003esig y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Filter-Recursive-Comb.html#v:runProc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Integrate with initial value zero.\nHowever the first emitted value is the value of the input signal.\nIt maintains the length of the signal.\n",
          "module": "Synthesizer.Generic.Filter.Recursive.Integration",
          "name": "run",
          "package": "synthesizer",
          "signature": "sig v -\u003e sig v",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Generic-Filter-Recursive-Integration.html#run",
          "type": "function"
        },
        "index": {
          "description": "Integrate with initial value zero However the first emitted value is the value of the input signal It maintains the length of the signal",
          "hierarchy": "Synthesizer Generic Filter Recursive Integration",
          "module": "Synthesizer.Generic.Filter.Recursive.Integration",
          "name": "run",
          "normalized": "a b-\u003ea b",
          "package": "synthesizer",
          "signature": "sig v-\u003esig v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Filter-Recursive-Integration.html#v:run"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Integrate with initial condition.\nFirst emitted value is the initial condition.\nThe signal become one element longer.\n",
          "module": "Synthesizer.Generic.Filter.Recursive.Integration",
          "name": "runInit",
          "package": "synthesizer",
          "signature": "v -\u003e sig v -\u003e sig v",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Generic-Filter-Recursive-Integration.html#runInit",
          "type": "function"
        },
        "index": {
          "description": "Integrate with initial condition First emitted value is the initial condition The signal become one element longer",
          "hierarchy": "Synthesizer Generic Filter Recursive Integration",
          "module": "Synthesizer.Generic.Filter.Recursive.Integration",
          "name": "runInit",
          "normalized": "a-\u003eb a-\u003eb a",
          "package": "synthesizer",
          "partial": "Init",
          "signature": "v-\u003esig v-\u003esig v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Filter-Recursive-Integration.html#v:runInit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Generic.Filter.Recursive.MovingAverage",
          "name": "modulatedFrac",
          "package": "synthesizer",
          "signature": "Int -\u003e sig a -\u003e sig v -\u003e sig v",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Generic-Filter-Recursive-MovingAverage.html#modulatedFrac",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Generic Filter Recursive MovingAverage",
          "module": "Synthesizer.Generic.Filter.Recursive.MovingAverage",
          "name": "modulatedFrac",
          "normalized": "Int-\u003ea b-\u003ea c-\u003ea c",
          "package": "synthesizer",
          "partial": "Frac",
          "signature": "Int-\u003esig a-\u003esig v-\u003esig v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Filter-Recursive-MovingAverage.html#v:modulatedFrac"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLike Synthesizer.Generic.Filter.NonRecursive.sums but in a recursive form.\nThis needs only linear time (independent of the window size)\nbut may accumulate rounding errors.\n\u003c/p\u003e\u003cpre\u003e\nys = xs * (1,0,0,0,-1) / (1,-1)\nys * (1,-1) = xs * (1,0,0,0,-1)\nys = xs * (1,0,0,0,-1) + ys * (0,1)\n\u003c/pre\u003e",
          "module": "Synthesizer.Generic.Filter.Recursive.MovingAverage",
          "name": "sumsStaticInt",
          "package": "synthesizer",
          "signature": "Int -\u003e sig v -\u003e sig v",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Generic-Filter-Recursive-MovingAverage.html#sumsStaticInt",
          "type": "function"
        },
        "index": {
          "description": "Like Synthesizer.Generic.Filter.NonRecursive.sums but in recursive form This needs only linear time independent of the window size but may accumulate rounding errors ys xs ys xs ys xs ys",
          "hierarchy": "Synthesizer Generic Filter Recursive MovingAverage",
          "module": "Synthesizer.Generic.Filter.Recursive.MovingAverage",
          "name": "sumsStaticInt",
          "normalized": "Int-\u003ea b-\u003ea b",
          "package": "synthesizer",
          "partial": "Static Int",
          "signature": "Int-\u003esig v-\u003esig v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Filter-Recursive-MovingAverage.html#v:sumsStaticInt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Generic.Interpolation",
          "name": "T",
          "package": "synthesizer",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Interpolation.html#T",
          "type": "data"
        },
        "index": {
          "hierarchy": "Synthesizer Generic Interpolation",
          "module": "Synthesizer.Generic.Interpolation",
          "name": "T",
          "package": "synthesizer",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Interpolation.html#t:T"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Generic.Interpolation",
          "name": "constantPad",
          "package": "synthesizer",
          "signature": "(T t y -\u003e t -\u003e sig y -\u003e a) -\u003e T t y -\u003e t -\u003e sig y -\u003e a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Generic-Interpolation.html#constantPad",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Generic Interpolation",
          "module": "Synthesizer.Generic.Interpolation",
          "name": "constantPad",
          "normalized": "(T a b-\u003ea-\u003ec b-\u003ed)-\u003eT a b-\u003ea-\u003ec b-\u003ed",
          "package": "synthesizer",
          "partial": "Pad",
          "signature": "(T t y-\u003et-\u003esig y-\u003ea)-\u003eT t y-\u003et-\u003esig y-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Interpolation.html#v:constantPad"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Only for finite input signals.\n",
          "module": "Synthesizer.Generic.Interpolation",
          "name": "cyclicPad",
          "package": "synthesizer",
          "signature": "(T t y -\u003e t -\u003e sig y -\u003e a) -\u003e T t y -\u003e t -\u003e sig y -\u003e a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Generic-Interpolation.html#cyclicPad",
          "type": "function"
        },
        "index": {
          "description": "Only for finite input signals",
          "hierarchy": "Synthesizer Generic Interpolation",
          "module": "Synthesizer.Generic.Interpolation",
          "name": "cyclicPad",
          "normalized": "(T a b-\u003ea-\u003ec b-\u003ed)-\u003eT a b-\u003ea-\u003ec b-\u003ed",
          "package": "synthesizer",
          "partial": "Pad",
          "signature": "(T t y-\u003et-\u003esig y-\u003ea)-\u003eT t y-\u003et-\u003esig y-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Interpolation.html#v:cyclicPad"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "The extrapolation may miss some of the first and some of the last points\n",
          "module": "Synthesizer.Generic.Interpolation",
          "name": "extrapolationPad",
          "package": "synthesizer",
          "signature": "(T t y -\u003e t -\u003e sig y -\u003e a) -\u003e T t y -\u003e t -\u003e sig y -\u003e a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Generic-Interpolation.html#extrapolationPad",
          "type": "function"
        },
        "index": {
          "description": "The extrapolation may miss some of the first and some of the last points",
          "hierarchy": "Synthesizer Generic Interpolation",
          "module": "Synthesizer.Generic.Interpolation",
          "name": "extrapolationPad",
          "normalized": "(T a b-\u003ea-\u003ec b-\u003ed)-\u003eT a b-\u003ea-\u003ec b-\u003ed",
          "package": "synthesizer",
          "partial": "Pad",
          "signature": "(T t y-\u003et-\u003esig y-\u003ea)-\u003eT t y-\u003et-\u003esig y-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Interpolation.html#v:extrapolationPad"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Generic.Interpolation",
          "name": "func",
          "package": "synthesizer",
          "signature": "T t y -\u003e t -\u003e sig y -\u003e y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Generic-Interpolation.html#func",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Generic Interpolation",
          "module": "Synthesizer.Generic.Interpolation",
          "name": "func",
          "normalized": "T a b-\u003ea-\u003ec b-\u003eb",
          "package": "synthesizer",
          "signature": "T t y-\u003et-\u003esig y-\u003ey",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Interpolation.html#v:func"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "All values of frequency control must be non-negative. \n",
          "module": "Synthesizer.Generic.Interpolation",
          "name": "multiRelative",
          "package": "synthesizer",
          "signature": "T t y -\u003e t -\u003e sig y -\u003e sig t -\u003e sig y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Generic-Interpolation.html#multiRelative",
          "type": "function"
        },
        "index": {
          "description": "All values of frequency control must be non-negative",
          "hierarchy": "Synthesizer Generic Interpolation",
          "module": "Synthesizer.Generic.Interpolation",
          "name": "multiRelative",
          "normalized": "T a b-\u003ea-\u003ec b-\u003ec a-\u003ec b",
          "package": "synthesizer",
          "partial": "Relative",
          "signature": "T t y-\u003et-\u003esig y-\u003esig t-\u003esig y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Interpolation.html#v:multiRelative"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Generic.Interpolation",
          "name": "multiRelativeConstantPad",
          "package": "synthesizer",
          "signature": "T t y -\u003e t -\u003e sig t -\u003e sig y -\u003e sig y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Generic-Interpolation.html#multiRelativeConstantPad",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Generic Interpolation",
          "module": "Synthesizer.Generic.Interpolation",
          "name": "multiRelativeConstantPad",
          "normalized": "T a b-\u003ea-\u003ec a-\u003ec b-\u003ec b",
          "package": "synthesizer",
          "partial": "Relative Constant Pad",
          "signature": "T t y-\u003et-\u003esig t-\u003esig y-\u003esig y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Interpolation.html#v:multiRelativeConstantPad"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Generic.Interpolation",
          "name": "multiRelativeCyclicPad",
          "package": "synthesizer",
          "signature": "T t y -\u003e t -\u003e sig t -\u003e sig y -\u003e sig y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Generic-Interpolation.html#multiRelativeCyclicPad",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Generic Interpolation",
          "module": "Synthesizer.Generic.Interpolation",
          "name": "multiRelativeCyclicPad",
          "normalized": "T a b-\u003ea-\u003ec a-\u003ec b-\u003ec b",
          "package": "synthesizer",
          "partial": "Relative Cyclic Pad",
          "signature": "T t y-\u003et-\u003esig t-\u003esig y-\u003esig y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Interpolation.html#v:multiRelativeCyclicPad"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "The extrapolation may miss some of the first and some of the last points\n",
          "module": "Synthesizer.Generic.Interpolation",
          "name": "multiRelativeExtrapolationPad",
          "package": "synthesizer",
          "signature": "T t y -\u003e t -\u003e sig t -\u003e sig y -\u003e sig y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Generic-Interpolation.html#multiRelativeExtrapolationPad",
          "type": "function"
        },
        "index": {
          "description": "The extrapolation may miss some of the first and some of the last points",
          "hierarchy": "Synthesizer Generic Interpolation",
          "module": "Synthesizer.Generic.Interpolation",
          "name": "multiRelativeExtrapolationPad",
          "normalized": "T a b-\u003ea-\u003ec a-\u003ec b-\u003ec b",
          "package": "synthesizer",
          "partial": "Relative Extrapolation Pad",
          "signature": "T t y-\u003et-\u003esig t-\u003esig y-\u003esig y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Interpolation.html#v:multiRelativeExtrapolationPad"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Generic.Interpolation",
          "name": "multiRelativeZeroPad",
          "package": "synthesizer",
          "signature": "y -\u003e T t y -\u003e t -\u003e sig t -\u003e sig y -\u003e sig y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Generic-Interpolation.html#multiRelativeZeroPad",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Generic Interpolation",
          "module": "Synthesizer.Generic.Interpolation",
          "name": "multiRelativeZeroPad",
          "normalized": "a-\u003eT b a-\u003eb-\u003ec b-\u003ec a-\u003ec a",
          "package": "synthesizer",
          "partial": "Relative Zero Pad",
          "signature": "y-\u003eT t y-\u003et-\u003esig t-\u003esig y-\u003esig y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Interpolation.html#v:multiRelativeZeroPad"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Generic.Interpolation",
          "name": "multiRelativeZeroPadConstant",
          "package": "synthesizer",
          "signature": "t -\u003e sig t -\u003e sig y -\u003e sig y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Generic-Interpolation.html#multiRelativeZeroPadConstant",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Generic Interpolation",
          "module": "Synthesizer.Generic.Interpolation",
          "name": "multiRelativeZeroPadConstant",
          "normalized": "a-\u003eb a-\u003eb c-\u003eb c",
          "package": "synthesizer",
          "partial": "Relative Zero Pad Constant",
          "signature": "t-\u003esig t-\u003esig y-\u003esig y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Interpolation.html#v:multiRelativeZeroPadConstant"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Generic.Interpolation",
          "name": "multiRelativeZeroPadCubic",
          "package": "synthesizer",
          "signature": "t -\u003e sig t -\u003e sig y -\u003e sig y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Generic-Interpolation.html#multiRelativeZeroPadCubic",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Generic Interpolation",
          "module": "Synthesizer.Generic.Interpolation",
          "name": "multiRelativeZeroPadCubic",
          "normalized": "a-\u003eb a-\u003eb c-\u003eb c",
          "package": "synthesizer",
          "partial": "Relative Zero Pad Cubic",
          "signature": "t-\u003esig t-\u003esig y-\u003esig y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Interpolation.html#v:multiRelativeZeroPadCubic"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Generic.Interpolation",
          "name": "multiRelativeZeroPadLinear",
          "package": "synthesizer",
          "signature": "t -\u003e sig t -\u003e sig y -\u003e sig y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Generic-Interpolation.html#multiRelativeZeroPadLinear",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Generic Interpolation",
          "module": "Synthesizer.Generic.Interpolation",
          "name": "multiRelativeZeroPadLinear",
          "normalized": "a-\u003eb a-\u003eb c-\u003eb c",
          "package": "synthesizer",
          "partial": "Relative Zero Pad Linear",
          "signature": "t-\u003esig t-\u003esig y-\u003esig y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Interpolation.html#v:multiRelativeZeroPadLinear"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Synthesizer.Generic.Interpolation\",\"Synthesizer.Interpolation\",\"Synthesizer.Plain.Interpolation\"]",
          "name": "number",
          "package": "synthesizer",
          "signature": "T t y -\u003e Int",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Interpolation.html#number",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Interpolation.html#v:number\",\"http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Interpolation.html#v:number\",\"http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Interpolation.html#v:number\"]"
        },
        "index": {
          "hierarchy": "Synthesizer Generic Interpolation",
          "module": "Synthesizer.Generic.Interpolation",
          "name": "number",
          "normalized": "T a b-\u003eInt",
          "package": "synthesizer",
          "signature": "T t y-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Interpolation.html#v:number"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Synthesizer.Generic.Interpolation\",\"Synthesizer.Interpolation\",\"Synthesizer.Plain.Interpolation\"]",
          "name": "offset",
          "package": "synthesizer",
          "signature": "T t y -\u003e Int",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Interpolation.html#offset",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Interpolation.html#v:offset\",\"http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Interpolation.html#v:offset\",\"http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Interpolation.html#v:offset\"]"
        },
        "index": {
          "hierarchy": "Synthesizer Generic Interpolation",
          "module": "Synthesizer.Generic.Interpolation",
          "name": "offset",
          "normalized": "T a b-\u003eInt",
          "package": "synthesizer",
          "signature": "T t y-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Interpolation.html#v:offset"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Generic.Interpolation",
          "name": "single",
          "package": "synthesizer",
          "signature": "T t y -\u003e t -\u003e sig y -\u003e y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Generic-Interpolation.html#single",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Generic Interpolation",
          "module": "Synthesizer.Generic.Interpolation",
          "name": "single",
          "normalized": "T a b-\u003ea-\u003ec b-\u003eb",
          "package": "synthesizer",
          "signature": "T t y-\u003et-\u003esig y-\u003ey",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Interpolation.html#v:single"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Generic.Interpolation",
          "name": "zeroPad",
          "package": "synthesizer",
          "signature": "(T t y -\u003e t -\u003e sig y -\u003e a) -\u003e y -\u003e T t y -\u003e t -\u003e sig y -\u003e a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Generic-Interpolation.html#zeroPad",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Generic Interpolation",
          "module": "Synthesizer.Generic.Interpolation",
          "name": "zeroPad",
          "normalized": "(T a b-\u003ea-\u003ec b-\u003ed)-\u003eb-\u003eT a b-\u003ea-\u003ec b-\u003ed",
          "package": "synthesizer",
          "partial": "Pad",
          "signature": "(T t y-\u003et-\u003esig y-\u003ea)-\u003ey-\u003eT t y-\u003et-\u003esig y-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Interpolation.html#v:zeroPad"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "momentary densities, \u003ctt\u003ep\u003c/tt\u003e means that there is about one peak\n                      in the time range of \u003ctt\u003e1/p\u003c/tt\u003e samples \nEvery occurence of \u003ctt\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/tt\u003e represents a peak. \n",
          "module": "Synthesizer.Generic.Noise",
          "name": "randomPeeks",
          "package": "synthesizer",
          "signature": "sig y-\u003e sig Bool",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Generic-Noise.html#randomPeeks",
          "type": "function"
        },
        "index": {
          "description": "momentary densities means that there is about one peak in the time range of samples Every occurence of True represents peak",
          "hierarchy": "Synthesizer Generic Noise",
          "module": "Synthesizer.Generic.Noise",
          "name": "randomPeeks",
          "normalized": "a b-\u003ea Bool",
          "package": "synthesizer",
          "partial": "Peeks",
          "signature": "sig y-\u003esig Bool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Noise.html#v:randomPeeks"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Generic.Noise",
          "name": "randomPeeksGen",
          "package": "synthesizer",
          "signature": "g -\u003e sig y -\u003e sig Bool",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Generic-Noise.html#randomPeeksGen",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Generic Noise",
          "module": "Synthesizer.Generic.Noise",
          "name": "randomPeeksGen",
          "normalized": "a-\u003eb c-\u003eb Bool",
          "package": "synthesizer",
          "partial": "Peeks Gen",
          "signature": "g-\u003esig y-\u003esig Bool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Noise.html#v:randomPeeksGen"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Deterministic white noise, uniformly distributed between -1 and 1.\nThat is, variance is 1/3.\n",
          "module": "Synthesizer.Generic.Noise",
          "name": "white",
          "package": "synthesizer",
          "signature": "LazySize -\u003e sig y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Generic-Noise.html#white",
          "type": "function"
        },
        "index": {
          "description": "Deterministic white noise uniformly distributed between and That is variance is",
          "hierarchy": "Synthesizer Generic Noise",
          "module": "Synthesizer.Generic.Noise",
          "name": "white",
          "normalized": "LazySize-\u003ea b",
          "package": "synthesizer",
          "signature": "LazySize-\u003esig y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Noise.html#v:white"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Generic.Noise",
          "name": "whiteGen",
          "package": "synthesizer",
          "signature": "LazySize -\u003e g -\u003e sig y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Generic-Noise.html#whiteGen",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Generic Noise",
          "module": "Synthesizer.Generic.Noise",
          "name": "whiteGen",
          "normalized": "LazySize-\u003ea-\u003eb c",
          "package": "synthesizer",
          "partial": "Gen",
          "signature": "LazySize-\u003eg-\u003esig y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Noise.html#v:whiteGen"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Approximates normal distribution with variance 1\nby a quadratic B-spline distribution.\n",
          "module": "Synthesizer.Generic.Noise",
          "name": "whiteQuadraticBSplineGen",
          "package": "synthesizer",
          "signature": "LazySize -\u003e g -\u003e sig y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Generic-Noise.html#whiteQuadraticBSplineGen",
          "type": "function"
        },
        "index": {
          "description": "Approximates normal distribution with variance by quadratic B-spline distribution",
          "hierarchy": "Synthesizer Generic Noise",
          "module": "Synthesizer.Generic.Noise",
          "name": "whiteQuadraticBSplineGen",
          "normalized": "LazySize-\u003ea-\u003eb c",
          "package": "synthesizer",
          "partial": "Quadratic BSpline Gen",
          "signature": "LazySize-\u003eg-\u003esig y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Noise.html#v:whiteQuadraticBSplineGen"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "oscillator with modulated frequency \n",
          "module": "Synthesizer.Generic.Oscillator",
          "name": "freqMod",
          "package": "synthesizer",
          "signature": "T a b -\u003e T a -\u003e sig a -\u003e sig b",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Generic-Oscillator.html#freqMod",
          "type": "function"
        },
        "index": {
          "description": "oscillator with modulated frequency",
          "hierarchy": "Synthesizer Generic Oscillator",
          "module": "Synthesizer.Generic.Oscillator",
          "name": "freqMod",
          "normalized": "T a b-\u003eT a-\u003ec a-\u003ec b",
          "package": "synthesizer",
          "partial": "Mod",
          "signature": "T a b-\u003eT a-\u003esig a-\u003esig b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Oscillator.html#v:freqMod"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "oscillator with a sampled waveform with modulated frequency\nShould behave homogenously for different types of interpolation.\n",
          "module": "Synthesizer.Generic.Oscillator",
          "name": "freqModSample",
          "package": "synthesizer",
          "signature": "T a b -\u003e wave b -\u003e T a -\u003e sig a -\u003e sig b",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Generic-Oscillator.html#freqModSample",
          "type": "function"
        },
        "index": {
          "description": "oscillator with sampled waveform with modulated frequency Should behave homogenously for different types of interpolation",
          "hierarchy": "Synthesizer Generic Oscillator",
          "module": "Synthesizer.Generic.Oscillator",
          "name": "freqModSample",
          "normalized": "T a b-\u003ec b-\u003eT a-\u003ed a-\u003ed b",
          "package": "synthesizer",
          "partial": "Mod Sample",
          "signature": "T a b-\u003ewave b-\u003eT a-\u003esig a-\u003esig b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Oscillator.html#v:freqModSample"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "saw tooth oscillator with modulated frequency \n",
          "module": "Synthesizer.Generic.Oscillator",
          "name": "freqModSaw",
          "package": "synthesizer",
          "signature": "T a -\u003e sig a -\u003e sig a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Generic-Oscillator.html#freqModSaw",
          "type": "function"
        },
        "index": {
          "description": "saw tooth oscillator with modulated frequency",
          "hierarchy": "Synthesizer Generic Oscillator",
          "module": "Synthesizer.Generic.Oscillator",
          "name": "freqModSaw",
          "normalized": "T a-\u003eb a-\u003eb a",
          "package": "synthesizer",
          "partial": "Mod Saw",
          "signature": "T a-\u003esig a-\u003esig a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Oscillator.html#v:freqModSaw"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "sine oscillator with modulated frequency \n",
          "module": "Synthesizer.Generic.Oscillator",
          "name": "freqModSine",
          "package": "synthesizer",
          "signature": "T a -\u003e sig a -\u003e sig a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Generic-Oscillator.html#freqModSine",
          "type": "function"
        },
        "index": {
          "description": "sine oscillator with modulated frequency",
          "hierarchy": "Synthesizer Generic Oscillator",
          "module": "Synthesizer.Generic.Oscillator",
          "name": "freqModSine",
          "normalized": "T a-\u003eb a-\u003eb a",
          "package": "synthesizer",
          "partial": "Mod Sine",
          "signature": "T a-\u003esig a-\u003esig a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Oscillator.html#v:freqModSine"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "oscillator with both phase and frequency modulation \n",
          "module": "Synthesizer.Generic.Oscillator",
          "name": "phaseFreqMod",
          "package": "synthesizer",
          "signature": "T a b -\u003e sig a -\u003e sig a -\u003e sig b",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Generic-Oscillator.html#phaseFreqMod",
          "type": "function"
        },
        "index": {
          "description": "oscillator with both phase and frequency modulation",
          "hierarchy": "Synthesizer Generic Oscillator",
          "module": "Synthesizer.Generic.Oscillator",
          "name": "phaseFreqMod",
          "normalized": "T a b-\u003ec a-\u003ec a-\u003ec b",
          "package": "synthesizer",
          "partial": "Freq Mod",
          "signature": "T a b-\u003esig a-\u003esig a-\u003esig b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Oscillator.html#v:phaseFreqMod"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "oscillator with modulated phase \n",
          "module": "Synthesizer.Generic.Oscillator",
          "name": "phaseMod",
          "package": "synthesizer",
          "signature": "T a b -\u003e a -\u003e sig a -\u003e sig b",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Generic-Oscillator.html#phaseMod",
          "type": "function"
        },
        "index": {
          "description": "oscillator with modulated phase",
          "hierarchy": "Synthesizer Generic Oscillator",
          "module": "Synthesizer.Generic.Oscillator",
          "name": "phaseMod",
          "normalized": "T a b-\u003ea-\u003ec a-\u003ec b",
          "package": "synthesizer",
          "partial": "Mod",
          "signature": "T a b-\u003ea-\u003esig a-\u003esig b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Oscillator.html#v:phaseMod"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "sine oscillator with modulated phase, useful for FM synthesis \n",
          "module": "Synthesizer.Generic.Oscillator",
          "name": "phaseModSine",
          "package": "synthesizer",
          "signature": "a -\u003e sig a -\u003e sig a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Generic-Oscillator.html#phaseModSine",
          "type": "function"
        },
        "index": {
          "description": "sine oscillator with modulated phase useful for FM synthesis",
          "hierarchy": "Synthesizer Generic Oscillator",
          "module": "Synthesizer.Generic.Oscillator",
          "name": "phaseModSine",
          "normalized": "a-\u003eb a-\u003eb a",
          "package": "synthesizer",
          "partial": "Mod Sine",
          "signature": "a-\u003esig a-\u003esig a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Oscillator.html#v:phaseModSine"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "oscillator with both shape and frequency modulation \n",
          "module": "Synthesizer.Generic.Oscillator",
          "name": "shapeFreqMod",
          "package": "synthesizer",
          "signature": "(c -\u003e T a b) -\u003e T a -\u003e sig c -\u003e sig a -\u003e sig b",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Generic-Oscillator.html#shapeFreqMod",
          "type": "function"
        },
        "index": {
          "description": "oscillator with both shape and frequency modulation",
          "hierarchy": "Synthesizer Generic Oscillator",
          "module": "Synthesizer.Generic.Oscillator",
          "name": "shapeFreqMod",
          "normalized": "(a-\u003eT b c)-\u003eT b-\u003ed a-\u003ed b-\u003ed c",
          "package": "synthesizer",
          "partial": "Freq Mod",
          "signature": "(c-\u003eT a b)-\u003eT a-\u003esig c-\u003esig a-\u003esig b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Oscillator.html#v:shapeFreqMod"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "oscillator with modulated shape \n",
          "module": "Synthesizer.Generic.Oscillator",
          "name": "shapeMod",
          "package": "synthesizer",
          "signature": "(c -\u003e T a b) -\u003e T a -\u003e a -\u003e sig c -\u003e sig b",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Generic-Oscillator.html#shapeMod",
          "type": "function"
        },
        "index": {
          "description": "oscillator with modulated shape",
          "hierarchy": "Synthesizer Generic Oscillator",
          "module": "Synthesizer.Generic.Oscillator",
          "name": "shapeMod",
          "normalized": "(a-\u003eT b c)-\u003eT b-\u003eb-\u003ed a-\u003ed c",
          "package": "synthesizer",
          "partial": "Mod",
          "signature": "(c-\u003eT a b)-\u003eT a-\u003ea-\u003esig c-\u003esig b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Oscillator.html#v:shapeMod"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "oscillator with constant frequency \n",
          "module": "Synthesizer.Generic.Oscillator",
          "name": "static",
          "package": "synthesizer",
          "signature": "LazySize -\u003e T a b -\u003e T a -\u003e a -\u003e sig b",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Generic-Oscillator.html#static",
          "type": "function"
        },
        "index": {
          "description": "oscillator with constant frequency",
          "hierarchy": "Synthesizer Generic Oscillator",
          "module": "Synthesizer.Generic.Oscillator",
          "name": "static",
          "normalized": "LazySize-\u003eT a b-\u003eT a-\u003ea-\u003ec b",
          "package": "synthesizer",
          "signature": "LazySize-\u003eT a b-\u003eT a-\u003ea-\u003esig b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Oscillator.html#v:static"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "oscillator with a sampled waveform with constant frequency\nThis is essentially an interpolation with cyclic padding.\n",
          "module": "Synthesizer.Generic.Oscillator",
          "name": "staticSample",
          "package": "synthesizer",
          "signature": "LazySize -\u003e T a b -\u003e wave b -\u003e T a -\u003e a -\u003e sig b",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Generic-Oscillator.html#staticSample",
          "type": "function"
        },
        "index": {
          "description": "oscillator with sampled waveform with constant frequency This is essentially an interpolation with cyclic padding",
          "hierarchy": "Synthesizer Generic Oscillator",
          "module": "Synthesizer.Generic.Oscillator",
          "name": "staticSample",
          "normalized": "LazySize-\u003eT a b-\u003ec b-\u003eT a-\u003ea-\u003ed b",
          "package": "synthesizer",
          "partial": "Sample",
          "signature": "LazySize-\u003eT a b-\u003ewave b-\u003eT a-\u003ea-\u003esig b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Oscillator.html#v:staticSample"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "saw tooth oscillator with modulated frequency \n",
          "module": "Synthesizer.Generic.Oscillator",
          "name": "staticSaw",
          "package": "synthesizer",
          "signature": "LazySize -\u003e T a -\u003e a -\u003e sig a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Generic-Oscillator.html#staticSaw",
          "type": "function"
        },
        "index": {
          "description": "saw tooth oscillator with modulated frequency",
          "hierarchy": "Synthesizer Generic Oscillator",
          "module": "Synthesizer.Generic.Oscillator",
          "name": "staticSaw",
          "normalized": "LazySize-\u003eT a-\u003ea-\u003eb a",
          "package": "synthesizer",
          "partial": "Saw",
          "signature": "LazySize-\u003eT a-\u003ea-\u003esig a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Oscillator.html#v:staticSaw"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "sine oscillator with static frequency \n",
          "module": "Synthesizer.Generic.Oscillator",
          "name": "staticSine",
          "package": "synthesizer",
          "signature": "LazySize -\u003e T a -\u003e a -\u003e sig a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Generic-Oscillator.html#staticSine",
          "type": "function"
        },
        "index": {
          "description": "sine oscillator with static frequency",
          "hierarchy": "Synthesizer Generic Oscillator",
          "module": "Synthesizer.Generic.Oscillator",
          "name": "staticSine",
          "normalized": "LazySize-\u003eT a-\u003ea-\u003eb a",
          "package": "synthesizer",
          "partial": "Sine",
          "signature": "LazySize-\u003eT a-\u003ea-\u003esig a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Oscillator.html#v:staticSine"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Generic.Signal",
          "name": "LazySize",
          "package": "synthesizer",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Generic-Signal.html#LazySize",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "Synthesizer Generic Signal",
          "module": "Synthesizer.Generic.Signal",
          "name": "LazySize",
          "package": "synthesizer",
          "partial": "Lazy Size",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Signal.html#t:LazySize"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Generic.Signal",
          "name": "Read",
          "package": "synthesizer",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Generic-Signal.html#Read",
          "type": "class"
        },
        "index": {
          "hierarchy": "Synthesizer Generic Signal",
          "module": "Synthesizer.Generic.Signal",
          "name": "Read",
          "package": "synthesizer",
          "partial": "Read",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Signal.html#v:Read"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Generic.Signal",
          "name": "Transform",
          "package": "synthesizer",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Generic-Signal.html#Transform",
          "type": "class"
        },
        "index": {
          "hierarchy": "Synthesizer Generic Signal",
          "module": "Synthesizer.Generic.Signal",
          "name": "Transform",
          "package": "synthesizer",
          "partial": "Transform",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Signal.html#v:Transform"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Generic.Signal",
          "name": "Write",
          "package": "synthesizer",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Generic-Signal.html#Write",
          "type": "class"
        },
        "index": {
          "hierarchy": "Synthesizer Generic Signal",
          "module": "Synthesizer.Generic.Signal",
          "name": "Write",
          "package": "synthesizer",
          "partial": "Write",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Signal.html#v:Write"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "This function belongs logically to the Write class,\n   but since an empty signal contains no data,\n   the maximum package size is irrelevant.\n   This makes e.g. the definition of mixMulti more general.\n",
          "module": "Synthesizer.Generic.Signal",
          "name": "cons",
          "package": "synthesizer",
          "signature": "y -\u003e sig y -\u003e sig y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Generic-Signal.html#cons",
          "type": "function"
        },
        "index": {
          "description": "This function belongs logically to the Write class but since an empty signal contains no data the maximum package size is irrelevant This makes e.g the definition of mixMulti more general",
          "hierarchy": "Synthesizer Generic Signal",
          "module": "Synthesizer.Generic.Signal",
          "name": "cons",
          "normalized": "a-\u003eb a-\u003eb a",
          "package": "synthesizer",
          "signature": "y-\u003esig y-\u003esig y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Signal.html#v:cons"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Generic.Signal",
          "name": "crochetL",
          "package": "synthesizer",
          "signature": "(y -\u003e s -\u003e Maybe (y, s)) -\u003e s -\u003e sig y -\u003e sig y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Generic-Signal.html#crochetL",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Generic Signal",
          "module": "Synthesizer.Generic.Signal",
          "name": "crochetL",
          "normalized": "(a-\u003eb-\u003eMaybe(a,b))-\u003eb-\u003ec a-\u003ec a",
          "package": "synthesizer",
          "signature": "(y-\u003es-\u003eMaybe(y,s))-\u003es-\u003esig y-\u003esig y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Signal.html#v:crochetL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "This can be used for internal signals\nthat have no observable effect on laziness.\nE.g. when you construct a list\nby \u003ctt\u003erepeat defaultLazySize zero\u003c/tt\u003e\nwe assume that zero is defined for all Additive types.\n",
          "module": "Synthesizer.Generic.Signal",
          "name": "defaultLazySize",
          "package": "synthesizer",
          "signature": "LazySize",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Generic-Signal.html#defaultLazySize",
          "type": "function"
        },
        "index": {
          "description": "This can be used for internal signals that have no observable effect on laziness E.g when you construct list by repeat defaultLazySize zero we assume that zero is defined for all Additive types",
          "hierarchy": "Synthesizer Generic Signal",
          "module": "Synthesizer.Generic.Signal",
          "name": "defaultLazySize",
          "package": "synthesizer",
          "partial": "Lazy Size",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Signal.html#v:defaultLazySize"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Generic.Signal",
          "name": "delay",
          "package": "synthesizer",
          "signature": "LazySize -\u003e y -\u003e Int -\u003e sig y -\u003e sig y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Generic-Signal.html#delay",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Generic Signal",
          "module": "Synthesizer.Generic.Signal",
          "name": "delay",
          "normalized": "LazySize-\u003ea-\u003eInt-\u003eb a-\u003eb a",
          "package": "synthesizer",
          "signature": "LazySize-\u003ey-\u003eInt-\u003esig y-\u003esig y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Signal.html#v:delay"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "processor that shall be run in a feedback loop\nprefix of the output, its length determines the delay\n",
          "module": "Synthesizer.Generic.Signal",
          "name": "delayLoop",
          "package": "synthesizer",
          "signature": "sig y -\u003e sig y-\u003e sig y-\u003e sig y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Generic-Signal.html#delayLoop",
          "type": "function"
        },
        "index": {
          "description": "processor that shall be run in feedback loop prefix of the output its length determines the delay",
          "hierarchy": "Synthesizer Generic Signal",
          "module": "Synthesizer.Generic.Signal",
          "name": "delayLoop",
          "normalized": "a b-\u003ea b-\u003ea b-\u003ea b",
          "package": "synthesizer",
          "partial": "Loop",
          "signature": "sig y-\u003esig y-\u003esig y-\u003esig y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Signal.html#v:delayLoop"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Processor that shall be run in a feedback loop.\n                 It's absolutely necessary that this function preserves the chunk structure\n                 and that it does not look a chunk ahead.\n                 That's guaranteed for processes that do not look ahead at all,\n                 like \u003ctt\u003e\u003ca\u003emap\u003c/a\u003e\u003c/tt\u003e, \u003ctt\u003e\u003ca\u003ecrochetL\u003c/a\u003e\u003c/tt\u003e and\n                 all of type \u003ctt\u003eCausal.Process\u003c/tt\u003e. \ninput\noutput has the same length as the input\n",
          "module": "Synthesizer.Generic.Signal",
          "name": "delayLoopOverlap",
          "package": "synthesizer",
          "signature": "Int-\u003e sig y -\u003e sig y-\u003e sig y-\u003e sig y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Generic-Signal.html#delayLoopOverlap",
          "type": "function"
        },
        "index": {
          "description": "Processor that shall be run in feedback loop It absolutely necessary that this function preserves the chunk structure and that it does not look chunk ahead That guaranteed for processes that do not look ahead at all like map crochetL and all of type Causal.Process input output has the same length as the input",
          "hierarchy": "Synthesizer Generic Signal",
          "module": "Synthesizer.Generic.Signal",
          "name": "delayLoopOverlap",
          "normalized": "Int-\u003ea b-\u003ea b-\u003ea b-\u003ea b",
          "package": "synthesizer",
          "partial": "Loop Overlap",
          "signature": "Int-\u003esig y-\u003esig y-\u003esig y-\u003esig y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Signal.html#v:delayLoopOverlap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Generic.Signal",
          "name": "dropWhile",
          "package": "synthesizer",
          "signature": "(y -\u003e Bool) -\u003e sig y -\u003e sig y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Generic-Signal.html#dropWhile",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Generic Signal",
          "module": "Synthesizer.Generic.Signal",
          "name": "dropWhile",
          "normalized": "(a-\u003eBool)-\u003eb a-\u003eb a",
          "package": "synthesizer",
          "partial": "While",
          "signature": "(y-\u003eBool)-\u003esig y-\u003esig y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Signal.html#v:dropWhile"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Generic.Signal",
          "name": "extendConstant",
          "package": "synthesizer",
          "signature": "LazySize -\u003e sig y -\u003e sig y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Generic-Signal.html#extendConstant",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Generic Signal",
          "module": "Synthesizer.Generic.Signal",
          "name": "extendConstant",
          "normalized": "LazySize-\u003ea b-\u003ea b",
          "package": "synthesizer",
          "partial": "Constant",
          "signature": "LazySize-\u003esig y-\u003esig y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Signal.html#v:extendConstant"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Generic.Signal",
          "name": "foldL",
          "package": "synthesizer",
          "signature": "(s -\u003e y -\u003e s) -\u003e s -\u003e sig y -\u003e s",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Generic-Signal.html#foldL",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Generic Signal",
          "module": "Synthesizer.Generic.Signal",
          "name": "foldL",
          "normalized": "(a-\u003eb-\u003ea)-\u003ea-\u003ec b-\u003ea",
          "package": "synthesizer",
          "signature": "(s-\u003ey-\u003es)-\u003es-\u003esig y-\u003es",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Signal.html#v:foldL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Generic.Signal",
          "name": "fromList",
          "package": "synthesizer",
          "signature": "LazySize -\u003e [y] -\u003e sig y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Generic-Signal.html#fromList",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Generic Signal",
          "module": "Synthesizer.Generic.Signal",
          "name": "fromList",
          "normalized": "LazySize-\u003e[a]-\u003eb a",
          "package": "synthesizer",
          "partial": "List",
          "signature": "LazySize-\u003e[y]-\u003esig y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Signal.html#v:fromList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Generic.Signal",
          "name": "fromState",
          "package": "synthesizer",
          "signature": "LazySize -\u003e T y -\u003e sig y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Generic-Signal.html#fromState",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Generic Signal",
          "module": "Synthesizer.Generic.Signal",
          "name": "fromState",
          "normalized": "LazySize-\u003eT a-\u003eb a",
          "package": "synthesizer",
          "partial": "State",
          "signature": "LazySize-\u003eT y-\u003esig y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Signal.html#v:fromState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Generic.Signal",
          "name": "iterate",
          "package": "synthesizer",
          "signature": "LazySize -\u003e (y -\u003e y) -\u003e y -\u003e sig y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Generic-Signal.html#iterate",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Generic Signal",
          "module": "Synthesizer.Generic.Signal",
          "name": "iterate",
          "normalized": "LazySize-\u003e(a-\u003ea)-\u003ea-\u003eb a",
          "package": "synthesizer",
          "signature": "LazySize-\u003e(y-\u003ey)-\u003ey-\u003esig y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Signal.html#v:iterate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Generic.Signal",
          "name": "iterateAssociative",
          "package": "synthesizer",
          "signature": "LazySize -\u003e (y -\u003e y -\u003e y) -\u003e y -\u003e sig y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Generic-Signal.html#iterateAssociative",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Generic Signal",
          "module": "Synthesizer.Generic.Signal",
          "name": "iterateAssociative",
          "normalized": "LazySize-\u003e(a-\u003ea-\u003ea)-\u003ea-\u003eb a",
          "package": "synthesizer",
          "partial": "Associative",
          "signature": "LazySize-\u003e(y-\u003ey-\u003ey)-\u003ey-\u003esig y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Signal.html#v:iterateAssociative"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Generic.Signal",
          "name": "linearComb",
          "package": "synthesizer",
          "signature": "sig t -\u003e sig y -\u003e y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Generic-Signal.html#linearComb",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Generic Signal",
          "module": "Synthesizer.Generic.Signal",
          "name": "linearComb",
          "normalized": "a b-\u003ea c-\u003ec",
          "package": "synthesizer",
          "partial": "Comb",
          "signature": "sig t-\u003esig y-\u003ey",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Signal.html#v:linearComb"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Generic.Signal",
          "name": "map",
          "package": "synthesizer",
          "signature": "(y -\u003e y) -\u003e sig y -\u003e sig y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Generic-Signal.html#map",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Generic Signal",
          "module": "Synthesizer.Generic.Signal",
          "name": "map",
          "normalized": "(a-\u003ea)-\u003eb a-\u003eb a",
          "package": "synthesizer",
          "signature": "(y-\u003ey)-\u003esig y-\u003esig y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Signal.html#v:map"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Generic.Signal",
          "name": "mapAdjacent",
          "package": "synthesizer",
          "signature": "(a -\u003e a -\u003e a) -\u003e sig a -\u003e sig a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Generic-Signal.html#mapAdjacent",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Generic Signal",
          "module": "Synthesizer.Generic.Signal",
          "name": "mapAdjacent",
          "normalized": "(a-\u003ea-\u003ea)-\u003eb a-\u003eb a",
          "package": "synthesizer",
          "partial": "Adjacent",
          "signature": "(a-\u003ea-\u003ea)-\u003esig a-\u003esig a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Signal.html#v:mapAdjacent"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Generic.Signal",
          "name": "mapTails",
          "package": "synthesizer",
          "signature": "(sig a -\u003e a) -\u003e sig a -\u003e sig a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Generic-Signal.html#mapTails",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Generic Signal",
          "module": "Synthesizer.Generic.Signal",
          "name": "mapTails",
          "normalized": "(a b-\u003eb)-\u003ea b-\u003ea b",
          "package": "synthesizer",
          "partial": "Tails",
          "signature": "(sig a-\u003ea)-\u003esig a-\u003esig a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Signal.html#v:mapTails"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Generic.Signal",
          "name": "mapTailsAlt",
          "package": "synthesizer",
          "signature": "LazySize -\u003e (sig a -\u003e b) -\u003e sig a -\u003e sig b",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Generic-Signal.html#mapTailsAlt",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Generic Signal",
          "module": "Synthesizer.Generic.Signal",
          "name": "mapTailsAlt",
          "normalized": "LazySize-\u003e(a b-\u003ec)-\u003ea b-\u003ea c",
          "package": "synthesizer",
          "partial": "Tails Alt",
          "signature": "LazySize-\u003e(sig a-\u003eb)-\u003esig a-\u003esig b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Signal.html#v:mapTailsAlt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Generic.Signal",
          "name": "mix",
          "package": "synthesizer",
          "signature": "sig y -\u003e sig y -\u003e sig y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Generic-Signal.html#mix",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Generic Signal",
          "module": "Synthesizer.Generic.Signal",
          "name": "mix",
          "normalized": "a b-\u003ea b-\u003ea b",
          "package": "synthesizer",
          "signature": "sig y-\u003esig y-\u003esig y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Signal.html#v:mix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Here the control may vary over the time. \n",
          "module": "Synthesizer.Generic.Signal",
          "name": "modifyModulated",
          "package": "synthesizer",
          "signature": "Simple s ctrl a a -\u003e sig ctrl -\u003e sig a -\u003e sig a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Generic-Signal.html#modifyModulated",
          "type": "function"
        },
        "index": {
          "description": "Here the control may vary over the time",
          "hierarchy": "Synthesizer Generic Signal",
          "module": "Synthesizer.Generic.Signal",
          "name": "modifyModulated",
          "normalized": "Simple a b c c-\u003ed b-\u003ed c-\u003ed c",
          "package": "synthesizer",
          "partial": "Modulated",
          "signature": "Simple s ctrl a a-\u003esig ctrl-\u003esig a-\u003esig a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Signal.html#v:modifyModulated"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Generic.Signal",
          "name": "modifyStatic",
          "package": "synthesizer",
          "signature": "Simple s ctrl a a -\u003e ctrl -\u003e sig a -\u003e sig a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Generic-Signal.html#modifyStatic",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Generic Signal",
          "module": "Synthesizer.Generic.Signal",
          "name": "modifyStatic",
          "normalized": "Simple a b c c-\u003eb-\u003ed c-\u003ed c",
          "package": "synthesizer",
          "partial": "Static",
          "signature": "Simple s ctrl a a-\u003ectrl-\u003esig a-\u003esig a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Signal.html#v:modifyStatic"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Generic.Signal",
          "name": "repeat",
          "package": "synthesizer",
          "signature": "LazySize -\u003e y -\u003e sig y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Generic-Signal.html#repeat",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Generic Signal",
          "module": "Synthesizer.Generic.Signal",
          "name": "repeat",
          "normalized": "LazySize-\u003ea-\u003eb a",
          "package": "synthesizer",
          "signature": "LazySize-\u003ey-\u003esig y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Signal.html#v:repeat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Generic.Signal",
          "name": "replicate",
          "package": "synthesizer",
          "signature": "LazySize -\u003e Int -\u003e y -\u003e sig y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Generic-Signal.html#replicate",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Generic Signal",
          "module": "Synthesizer.Generic.Signal",
          "name": "replicate",
          "normalized": "LazySize-\u003eInt-\u003ea-\u003eb a",
          "package": "synthesizer",
          "signature": "LazySize-\u003eInt-\u003ey-\u003esig y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Signal.html#v:replicate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Generic.Signal",
          "name": "scanL",
          "package": "synthesizer",
          "signature": "(y -\u003e y -\u003e y) -\u003e y -\u003e sig y -\u003e sig y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Generic-Signal.html#scanL",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Generic Signal",
          "module": "Synthesizer.Generic.Signal",
          "name": "scanL",
          "normalized": "(a-\u003ea-\u003ea)-\u003ea-\u003eb a-\u003eb a",
          "package": "synthesizer",
          "signature": "(y-\u003ey-\u003ey)-\u003ey-\u003esig y-\u003esig y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Signal.html#v:scanL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Generic.Signal",
          "name": "span",
          "package": "synthesizer",
          "signature": "(y -\u003e Bool) -\u003e sig y -\u003e (sig y, sig y)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Generic-Signal.html#span",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Generic Signal",
          "module": "Synthesizer.Generic.Signal",
          "name": "span",
          "normalized": "(a-\u003eBool)-\u003eb a-\u003e(b a,b a)",
          "package": "synthesizer",
          "signature": "(y-\u003eBool)-\u003esig y-\u003e(sig y,sig y)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Signal.html#v:span"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Generic.Signal",
          "name": "sum",
          "package": "synthesizer",
          "signature": "sig a -\u003e a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Generic-Signal.html#sum",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Generic Signal",
          "module": "Synthesizer.Generic.Signal",
          "name": "sum",
          "normalized": "a b-\u003eb",
          "package": "synthesizer",
          "signature": "sig a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Signal.html#v:sum"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Generic.Signal",
          "name": "switchL",
          "package": "synthesizer",
          "signature": "a -\u003e (y -\u003e sig y -\u003e a) -\u003e sig y -\u003e a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Generic-Signal.html#switchL",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Generic Signal",
          "module": "Synthesizer.Generic.Signal",
          "name": "switchL",
          "normalized": "a-\u003e(b-\u003ec b-\u003ea)-\u003ec b-\u003ea",
          "package": "synthesizer",
          "signature": "a-\u003e(y-\u003esig y-\u003ea)-\u003esig y-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Signal.html#v:switchL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Generic.Signal",
          "name": "tails",
          "package": "synthesizer",
          "signature": "sig y -\u003e T (sig y)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Generic-Signal.html#tails",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Generic Signal",
          "module": "Synthesizer.Generic.Signal",
          "name": "tails",
          "normalized": "a b-\u003eT(a b)",
          "package": "synthesizer",
          "signature": "sig y-\u003eT(sig y)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Signal.html#v:tails"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Generic.Signal",
          "name": "takeWhile",
          "package": "synthesizer",
          "signature": "(y -\u003e Bool) -\u003e sig y -\u003e sig y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Generic-Signal.html#takeWhile",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Generic Signal",
          "module": "Synthesizer.Generic.Signal",
          "name": "takeWhile",
          "normalized": "(a-\u003eBool)-\u003eb a-\u003eb a",
          "package": "synthesizer",
          "partial": "While",
          "signature": "(y-\u003eBool)-\u003esig y-\u003esig y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Signal.html#v:takeWhile"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Generic.Signal",
          "name": "toList",
          "package": "synthesizer",
          "signature": "sig y -\u003e [y]",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Generic-Signal.html#toList",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Generic Signal",
          "module": "Synthesizer.Generic.Signal",
          "name": "toList",
          "normalized": "a b-\u003e[b]",
          "package": "synthesizer",
          "partial": "List",
          "signature": "sig y-\u003e[y]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Signal.html#v:toList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Generic.Signal",
          "name": "toState",
          "package": "synthesizer",
          "signature": "sig y -\u003e T y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Generic-Signal.html#toState",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Generic Signal",
          "module": "Synthesizer.Generic.Signal",
          "name": "toState",
          "normalized": "a b-\u003eT b",
          "package": "synthesizer",
          "partial": "State",
          "signature": "sig y-\u003eT y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Signal.html#v:toState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Generic.Signal",
          "name": "unfoldR",
          "package": "synthesizer",
          "signature": "LazySize -\u003e (s -\u003e Maybe (y, s)) -\u003e s -\u003e sig y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Generic-Signal.html#unfoldR",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Generic Signal",
          "module": "Synthesizer.Generic.Signal",
          "name": "unfoldR",
          "normalized": "LazySize-\u003e(a-\u003eMaybe(b,a))-\u003ea-\u003ec b",
          "package": "synthesizer",
          "signature": "LazySize-\u003e(s-\u003eMaybe(y,s))-\u003es-\u003esig y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Signal.html#v:unfoldR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Generic.Signal",
          "name": "viewL",
          "package": "synthesizer",
          "signature": "sig y -\u003e Maybe (y, sig y)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Generic-Signal.html#viewL",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Generic Signal",
          "module": "Synthesizer.Generic.Signal",
          "name": "viewL",
          "normalized": "a b-\u003eMaybe(b,a b)",
          "package": "synthesizer",
          "signature": "sig y-\u003eMaybe(y,sig y)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Signal.html#v:viewL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Generic.Signal",
          "name": "viewR",
          "package": "synthesizer",
          "signature": "sig y -\u003e Maybe (sig y, y)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Generic-Signal.html#viewR",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Generic Signal",
          "module": "Synthesizer.Generic.Signal",
          "name": "viewR",
          "normalized": "a b-\u003eMaybe(a b,b)",
          "package": "synthesizer",
          "signature": "sig y-\u003eMaybe(sig y,y)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Signal.html#v:viewR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Generic.Signal",
          "name": "withStorableContext",
          "package": "synthesizer",
          "signature": "(ChunkSize -\u003e a) -\u003e LazySize -\u003e a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Generic-Signal.html#withStorableContext",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Generic Signal",
          "module": "Synthesizer.Generic.Signal",
          "name": "withStorableContext",
          "normalized": "(ChunkSize-\u003ea)-\u003eLazySize-\u003ea",
          "package": "synthesizer",
          "partial": "Storable Context",
          "signature": "(ChunkSize-\u003ea)-\u003eLazySize-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Signal.html#v:withStorableContext"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Generic.Signal",
          "name": "zipWith",
          "package": "synthesizer",
          "signature": "(a -\u003e b -\u003e b) -\u003e sig a -\u003e sig b -\u003e sig b",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Generic-Signal.html#zipWith",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Generic Signal",
          "module": "Synthesizer.Generic.Signal",
          "name": "zipWith",
          "normalized": "(a-\u003eb-\u003eb)-\u003ec a-\u003ec b-\u003ec b",
          "package": "synthesizer",
          "partial": "With",
          "signature": "(a-\u003eb-\u003eb)-\u003esig a-\u003esig b-\u003esig b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Signal.html#v:zipWith"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Generic.Signal",
          "name": "zipWithAppend",
          "package": "synthesizer",
          "signature": "(y -\u003e y -\u003e y) -\u003e sig y -\u003e sig y -\u003e sig y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Generic-Signal.html#zipWithAppend",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Generic Signal",
          "module": "Synthesizer.Generic.Signal",
          "name": "zipWithAppend",
          "normalized": "(a-\u003ea-\u003ea)-\u003eb a-\u003eb a-\u003eb a",
          "package": "synthesizer",
          "partial": "With Append",
          "signature": "(y-\u003ey-\u003ey)-\u003esig y-\u003esig y-\u003esig y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Signal.html#v:zipWithAppend"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eOnly non-empty suffixes are processed.\nMore oftenly we might need\n\u003c/p\u003e\u003cpre\u003e zipWithTails :: (Read sig b, Transform2 sig a) =\u003e\n    (b -\u003e sig a -\u003e a) -\u003e sig b -\u003e sig a -\u003e sig a\n\u003c/pre\u003e\u003cp\u003ethis would preserve the chunk structure of \u003ctt\u003esig a\u003c/tt\u003e,\nbut it is a bit more hassle to implement that.\n\u003c/p\u003e",
          "module": "Synthesizer.Generic.Signal",
          "name": "zipWithTails",
          "package": "synthesizer",
          "signature": "(a -\u003e sig b -\u003e a) -\u003e sig a -\u003e sig b -\u003e sig a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Generic-Signal.html#zipWithTails",
          "type": "function"
        },
        "index": {
          "description": "Only non-empty suffixes are processed More oftenly we might need zipWithTails Read sig Transform2 sig sig sig sig sig this would preserve the chunk structure of sig but it is bit more hassle to implement that",
          "hierarchy": "Synthesizer Generic Signal",
          "module": "Synthesizer.Generic.Signal",
          "name": "zipWithTails",
          "normalized": "(a-\u003eb c-\u003ea)-\u003eb a-\u003eb c-\u003eb a",
          "package": "synthesizer",
          "partial": "With Tails",
          "signature": "(a-\u003esig b-\u003ea)-\u003esig a-\u003esig b-\u003esig a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Signal.html#v:zipWithTails"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Generic.Signal2",
          "name": "Transform",
          "package": "synthesizer",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Generic-Signal2.html#Transform",
          "type": "class"
        },
        "index": {
          "hierarchy": "Synthesizer Generic Signal2",
          "module": "Synthesizer.Generic.Signal2",
          "name": "Transform",
          "package": "synthesizer",
          "partial": "Transform",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Signal2.html#v:Transform"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Generic.Signal2",
          "name": "crochetL",
          "package": "synthesizer",
          "signature": "(y0 -\u003e s -\u003e Maybe (y1, s)) -\u003e s -\u003e sig y0 -\u003e sig y1",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Generic-Signal2.html#crochetL",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Generic Signal2",
          "module": "Synthesizer.Generic.Signal2",
          "name": "crochetL",
          "normalized": "(a-\u003eb-\u003eMaybe(a,b))-\u003eb-\u003ec a-\u003ec a",
          "package": "synthesizer",
          "signature": "(y-\u003es-\u003eMaybe(y,s))-\u003es-\u003esig y-\u003esig y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Signal2.html#v:crochetL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Generic.Signal2",
          "name": "linearComb",
          "package": "synthesizer",
          "signature": "sig t -\u003e sig y -\u003e y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Generic-Signal2.html#linearComb",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Generic Signal2",
          "module": "Synthesizer.Generic.Signal2",
          "name": "linearComb",
          "normalized": "a b-\u003ea c-\u003ec",
          "package": "synthesizer",
          "partial": "Comb",
          "signature": "sig t-\u003esig y-\u003ey",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Signal2.html#v:linearComb"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Generic.Signal2",
          "name": "map",
          "package": "synthesizer",
          "signature": "(y0 -\u003e y1) -\u003e sig y0 -\u003e sig y1",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Generic-Signal2.html#map",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Generic Signal2",
          "module": "Synthesizer.Generic.Signal2",
          "name": "map",
          "normalized": "(a-\u003ea)-\u003eb a-\u003eb a",
          "package": "synthesizer",
          "signature": "(y-\u003ey)-\u003esig y-\u003esig y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Signal2.html#v:map"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Generic.Signal2",
          "name": "mapAdjacent",
          "package": "synthesizer",
          "signature": "(a -\u003e a -\u003e b) -\u003e sig a -\u003e sig b",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Generic-Signal2.html#mapAdjacent",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Generic Signal2",
          "module": "Synthesizer.Generic.Signal2",
          "name": "mapAdjacent",
          "normalized": "(a-\u003ea-\u003eb)-\u003ec a-\u003ec b",
          "package": "synthesizer",
          "partial": "Adjacent",
          "signature": "(a-\u003ea-\u003eb)-\u003esig a-\u003esig b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Signal2.html#v:mapAdjacent"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Generic.Signal2",
          "name": "mapTails",
          "package": "synthesizer",
          "signature": "(sig a -\u003e b) -\u003e sig a -\u003e sig b",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Generic-Signal2.html#mapTails",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Generic Signal2",
          "module": "Synthesizer.Generic.Signal2",
          "name": "mapTails",
          "normalized": "(a b-\u003ec)-\u003ea b-\u003ea c",
          "package": "synthesizer",
          "partial": "Tails",
          "signature": "(sig a-\u003eb)-\u003esig a-\u003esig b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Signal2.html#v:mapTails"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Here the control may vary over the time. \n",
          "module": "Synthesizer.Generic.Signal2",
          "name": "modifyModulated",
          "package": "synthesizer",
          "signature": "Simple s ctrl a b -\u003e sig ctrl -\u003e sig a -\u003e sig b",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Generic-Signal2.html#modifyModulated",
          "type": "function"
        },
        "index": {
          "description": "Here the control may vary over the time",
          "hierarchy": "Synthesizer Generic Signal2",
          "module": "Synthesizer.Generic.Signal2",
          "name": "modifyModulated",
          "normalized": "Simple a b c d-\u003ee b-\u003ee c-\u003ee d",
          "package": "synthesizer",
          "partial": "Modulated",
          "signature": "Simple s ctrl a b-\u003esig ctrl-\u003esig a-\u003esig b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Signal2.html#v:modifyModulated"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Generic.Signal2",
          "name": "modifyStatic",
          "package": "synthesizer",
          "signature": "Simple s ctrl a b -\u003e ctrl -\u003e sig a -\u003e sig b",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Generic-Signal2.html#modifyStatic",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Generic Signal2",
          "module": "Synthesizer.Generic.Signal2",
          "name": "modifyStatic",
          "normalized": "Simple a b c d-\u003eb-\u003ee c-\u003ee d",
          "package": "synthesizer",
          "partial": "Static",
          "signature": "Simple s ctrl a b-\u003ectrl-\u003esig a-\u003esig b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Signal2.html#v:modifyStatic"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Generic.Signal2",
          "name": "scanL",
          "package": "synthesizer",
          "signature": "(y1 -\u003e y0 -\u003e y1) -\u003e y1 -\u003e sig y0 -\u003e sig y1",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Generic-Signal2.html#scanL",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Generic Signal2",
          "module": "Synthesizer.Generic.Signal2",
          "name": "scanL",
          "normalized": "(a-\u003ea-\u003ea)-\u003ea-\u003eb a-\u003eb a",
          "package": "synthesizer",
          "signature": "(y-\u003ey-\u003ey)-\u003ey-\u003esig y-\u003esig y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Signal2.html#v:scanL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Generic.Signal2",
          "name": "unzip",
          "package": "synthesizer",
          "signature": "sig (a, b) -\u003e (sig a, sig b)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Generic-Signal2.html#unzip",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Generic Signal2",
          "module": "Synthesizer.Generic.Signal2",
          "name": "unzip",
          "normalized": "a(b,c)-\u003e(a b,a c)",
          "package": "synthesizer",
          "signature": "sig(a,b)-\u003e(sig a,sig b)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Signal2.html#v:unzip"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Generic.Signal2",
          "name": "unzip3",
          "package": "synthesizer",
          "signature": "sig (a, b, c) -\u003e (sig a, sig b, sig c)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Generic-Signal2.html#unzip3",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Generic Signal2",
          "module": "Synthesizer.Generic.Signal2",
          "name": "unzip3",
          "normalized": "a(b,c,d)-\u003e(a b,a c,a d)",
          "package": "synthesizer",
          "signature": "sig(a,b,c)-\u003e(sig a,sig b,sig c)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Signal2.html#v:unzip3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Generic.Signal2",
          "name": "zip",
          "package": "synthesizer",
          "signature": "sig a -\u003e sig b -\u003e sig (a, b)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Generic-Signal2.html#zip",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Generic Signal2",
          "module": "Synthesizer.Generic.Signal2",
          "name": "zip",
          "normalized": "a b-\u003ea c-\u003ea(b,c)",
          "package": "synthesizer",
          "signature": "sig a-\u003esig b-\u003esig(a,b)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Signal2.html#v:zip"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Generic.Signal2",
          "name": "zipWith",
          "package": "synthesizer",
          "signature": "(a -\u003e b -\u003e c) -\u003e sig a -\u003e sig b -\u003e sig c",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Generic-Signal2.html#zipWith",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Generic Signal2",
          "module": "Synthesizer.Generic.Signal2",
          "name": "zipWith",
          "normalized": "(a-\u003eb-\u003ec)-\u003ed a-\u003ed b-\u003ed c",
          "package": "synthesizer",
          "partial": "With",
          "signature": "(a-\u003eb-\u003ec)-\u003esig a-\u003esig b-\u003esig c",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Signal2.html#v:zipWith"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Generic.Signal2",
          "name": "zipWith2Tails",
          "package": "synthesizer",
          "signature": "(a -\u003e sig b -\u003e sig c -\u003e d) -\u003e sig a -\u003e sig b -\u003e sig c -\u003e sig d",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Generic-Signal2.html#zipWith2Tails",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Generic Signal2",
          "module": "Synthesizer.Generic.Signal2",
          "name": "zipWith2Tails",
          "normalized": "(a-\u003eb c-\u003eb d-\u003ee)-\u003eb a-\u003eb c-\u003eb d-\u003eb e",
          "package": "synthesizer",
          "partial": "With Tails",
          "signature": "(a-\u003esig b-\u003esig c-\u003ed)-\u003esig a-\u003esig b-\u003esig c-\u003esig d",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Signal2.html#v:zipWith2Tails"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Generic.Signal2",
          "name": "zipWithState",
          "package": "synthesizer",
          "signature": "(a -\u003e b -\u003e c) -\u003e T a -\u003e sig b -\u003e sig c",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Generic-Signal2.html#zipWithState",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Generic Signal2",
          "module": "Synthesizer.Generic.Signal2",
          "name": "zipWithState",
          "normalized": "(a-\u003eb-\u003ec)-\u003eT a-\u003ed b-\u003ed c",
          "package": "synthesizer",
          "partial": "With State",
          "signature": "(a-\u003eb-\u003ec)-\u003eT a-\u003esig b-\u003esig c",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Signal2.html#v:zipWithState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Generic.Signal2",
          "name": "zipWithTails",
          "package": "synthesizer",
          "signature": "(a -\u003e sig b -\u003e c) -\u003e sig a -\u003e sig b -\u003e sig c",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Generic-Signal2.html#zipWithTails",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Generic Signal2",
          "module": "Synthesizer.Generic.Signal2",
          "name": "zipWithTails",
          "normalized": "(a-\u003eb c-\u003ed)-\u003eb a-\u003eb c-\u003eb d",
          "package": "synthesizer",
          "partial": "With Tails",
          "signature": "(a-\u003esig b-\u003ec)-\u003esig a-\u003esig b-\u003esig c",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Signal2.html#v:zipWithTails"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIt is however not uncommon that all readers read with the same speed.\nIn this case we would in principle only need to share the input signal per sample.\nThis way we would not need a data structure\nfor storing a sub-sequence of samples temporarily.\nBut how to do that practically?\n\u003c/p\u003e\u003cp\u003eThe solution is not to think in terms of signals and signal processors,\ne.g. \u003ctt\u003eSig.T a\u003c/tt\u003e and \u003ctt\u003eSig.T a -\u003e Sig.T b -\u003e Sig.T c\u003c/tt\u003e, respectively,\nbut in terms of signal processors, that are guaranteed to run in sync.\nThat is we must assert that signal processors\nprocess the samples in chronological order and emit one sample per input sample.\nWe call such processes \"causal\" processes.\nFor example \u003ctt\u003eCausal.T (a,b) c\u003c/tt\u003e represents the function \u003ctt\u003eSig.T (a,b) -\u003e Sig.T c\u003c/tt\u003e\nbut it also carries the guarantee,\nthat for each input of type \u003ctt\u003e(a,b)\u003c/tt\u003e\none sample of type \u003ctt\u003ec\u003c/tt\u003e is emitted or the output terminates.\nInternally it is the Kleisli arrow of the \u003ctt\u003eStateT Maybe\u003c/tt\u003e monad.\n\u003c/p\u003e\u003cp\u003eAnother important application of the Causal arrow is feedback.\nUsing causal processes guarantees, that a process cannot read ahead,\nsuch that it runs into future data, which does still not exist due to recursion.\n\u003c/p\u003e\u003cp\u003eProgramming with arrows needs a bit experience or Haskell extensions.\nHaskell extensions are either an \u003ctt\u003eArrow\u003c/tt\u003e syntax preprocessor\nor the preprocessor that is built into GHC.\nHowever, for computing with physical dimensions\nyou can no longer use the original \u003ctt\u003eArrow\u003c/tt\u003e class\nand thus you cannot use the arrow syntax.\nSo here is an example of how to program \u003ctt\u003e\u003ca\u003efilterPingShare\u003c/a\u003e\u003c/tt\u003e\nusing \u003ctt\u003eArrow\u003c/tt\u003e combinators.\n\u003c/p\u003e",
          "module": "Synthesizer.Generic.Tutorial",
          "name": "filterPingCausal",
          "package": "synthesizer",
          "signature": "IO ExitCode",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Generic-Tutorial.html#filterPingCausal",
          "type": "function"
        },
        "index": {
          "description": "It is however not uncommon that all readers read with the same speed In this case we would in principle only need to share the input signal per sample This way we would not need data structure for storing sub-sequence of samples temporarily But how to do that practically The solution is not to think in terms of signals and signal processors e.g Sig.T and Sig.T Sig.T Sig.T respectively but in terms of signal processors that are guaranteed to run in sync That is we must assert that signal processors process the samples in chronological order and emit one sample per input sample We call such processes causal processes For example Causal.T represents the function Sig.T Sig.T but it also carries the guarantee that for each input of type one sample of type is emitted or the output terminates Internally it is the Kleisli arrow of the StateT Maybe monad Another important application of the Causal arrow is feedback Using causal processes guarantees that process cannot read ahead such that it runs into future data which does still not exist due to recursion Programming with arrows needs bit experience or Haskell extensions Haskell extensions are either an Arrow syntax preprocessor or the preprocessor that is built into GHC However for computing with physical dimensions you can no longer use the original Arrow class and thus you cannot use the arrow syntax So here is an example of how to program filterPingShare using Arrow combinators",
          "hierarchy": "Synthesizer Generic Tutorial",
          "module": "Synthesizer.Generic.Tutorial",
          "name": "filterPingCausal",
          "package": "synthesizer",
          "partial": "Ping Causal",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Tutorial.html#v:filterPingCausal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eYou can achieve sharing by a very simple way.\nYou can write the result of the signal generator in a list (\u003ctt\u003e\u003ca\u003etoList\u003c/a\u003e\u003c/tt\u003e)\nand use this list as source for a new generator (\u003ctt\u003e\u003ca\u003efromList\u003c/a\u003e\u003c/tt\u003e).\n\u003ctt\u003e\u003ca\u003efromList\u003c/a\u003e\u003c/tt\u003e provides a signal generator that generates new sample values\nby delivering the next sample from the list.\n\u003c/p\u003e\u003cp\u003eIn a real world implementation you would move\nthe \u003ctt\u003eSig.fromList . Sig.toList\u003c/tt\u003e to \u003ctt\u003e\u003ca\u003efilterPingStateProc\u003c/a\u003e\u003c/tt\u003e,\nsince the caller cannot know, that this function uses the signal twice,\nand the implementor of \u003ctt\u003e\u003ca\u003efilterPingStateProc\u003c/a\u003e\u003c/tt\u003e cannot know,\nhow expensive the computation of \u003ctt\u003eenv\u003c/tt\u003e is.\n\u003c/p\u003e\u003cp\u003eYou can use any other signal type for sharing, e.g. storable vectors,\nbut whatever type you choose, you also get its disadvantages.\nNamely, storable vectors only work for storable samples\nand lists are generally slow,\nand they also cannot be optimized away,\nsince this only works, when no sharing is required.\n\u003c/p\u003e\u003cp\u003eWhenever a signal is shared as input between several signal processes,\nthe actual materialized data is that\nbetween the slowest and the fastest reading process.\nThis is due to lazy evaluation and garbage collection.\nIf the different readers read with different speed,\nthen you will certainly need a temporary sample storage.\n\u003c/p\u003e",
          "module": "Synthesizer.Generic.Tutorial",
          "name": "filterPingShare",
          "package": "synthesizer",
          "signature": "IO ExitCode",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Generic-Tutorial.html#filterPingShare",
          "type": "function"
        },
        "index": {
          "description": "You can achieve sharing by very simple way You can write the result of the signal generator in list toList and use this list as source for new generator fromList fromList provides signal generator that generates new sample values by delivering the next sample from the list In real world implementation you would move the Sig.fromList Sig.toList to filterPingStateProc since the caller cannot know that this function uses the signal twice and the implementor of filterPingStateProc cannot know how expensive the computation of env is You can use any other signal type for sharing e.g storable vectors but whatever type you choose you also get its disadvantages Namely storable vectors only work for storable samples and lists are generally slow and they also cannot be optimized away since this only works when no sharing is required Whenever signal is shared as input between several signal processes the actual materialized data is that between the slowest and the fastest reading process This is due to lazy evaluation and garbage collection If the different readers read with different speed then you will certainly need temporary sample storage",
          "hierarchy": "Synthesizer Generic Tutorial",
          "module": "Synthesizer.Generic.Tutorial",
          "name": "filterPingShare",
          "package": "synthesizer",
          "partial": "Ping Share",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Tutorial.html#v:filterPingShare"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "In the following example we generate an exponential curve\nwhich shall be used both as envelope\nand as resonance frequency control of a resonant lowpass.\nActually, recomputing an exponential curve is not an issue,\nsince it only needs one multiplication per sample.\nBut it is simple enough to demonstrate the problem and its solutions.\nThe expression \u003ctt\u003elet env = exponential2 50000 1\u003c/tt\u003e fools the reader of the program,\nsince the \u003ctt\u003eenv\u003c/tt\u003e that is shared, is only the signal generator,\nthat is, the description of how to compute the exponential curve successively.\nThat is wherever a signal process reads \u003ctt\u003eenv\u003c/tt\u003e, it is computed again.\n",
          "module": "Synthesizer.Generic.Tutorial",
          "name": "filterPingState",
          "package": "synthesizer",
          "signature": "IO ExitCode",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Generic-Tutorial.html#filterPingState",
          "type": "function"
        },
        "index": {
          "description": "In the following example we generate an exponential curve which shall be used both as envelope and as resonance frequency control of resonant lowpass Actually recomputing an exponential curve is not an issue since it only needs one multiplication per sample But it is simple enough to demonstrate the problem and its solutions The expression let env exponential2 fools the reader of the program since the env that is shared is only the signal generator that is the description of how to compute the exponential curve successively That is wherever signal process reads env it is computed again",
          "hierarchy": "Synthesizer Generic Tutorial",
          "module": "Synthesizer.Generic.Tutorial",
          "name": "filterPingState",
          "package": "synthesizer",
          "partial": "Ping State",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Tutorial.html#v:filterPingState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Merging subsequent signal processes based on signal generators\ninto an efficient large signal processor is easy.\nNot storing intermediate results is however a problem in another situation:\nSometimes you want to share one signal between several processes.\n",
          "module": "Synthesizer.Generic.Tutorial",
          "name": "filterPingStateProc",
          "package": "synthesizer",
          "signature": "T Double -\u003e T Double",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Generic-Tutorial.html#filterPingStateProc",
          "type": "function"
        },
        "index": {
          "description": "Merging subsequent signal processes based on signal generators into an efficient large signal processor is easy Not storing intermediate results is however problem in another situation Sometimes you want to share one signal between several processes",
          "hierarchy": "Synthesizer Generic Tutorial",
          "module": "Synthesizer.Generic.Tutorial",
          "name": "filterPingStateProc",
          "normalized": "T Double-\u003eT Double",
          "package": "synthesizer",
          "partial": "Ping State Proc",
          "signature": "T Double-\u003eT Double",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Tutorial.html#v:filterPingStateProc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Here we instantiate \u003ctt\u003e\u003ca\u003efilterSawSig\u003c/a\u003e\u003c/tt\u003e for storable vectors and play it.\nThis means that all operations convert a storable vector into another storable vector.\nWhile every single operation probably is as efficient as possible,\nthe composition of all those processes could be more efficient.\nSo keep on reading.\n",
          "module": "Synthesizer.Generic.Tutorial",
          "name": "filterSaw",
          "package": "synthesizer",
          "signature": "IO ExitCode",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Generic-Tutorial.html#filterSaw",
          "type": "function"
        },
        "index": {
          "description": "Here we instantiate filterSawSig for storable vectors and play it This means that all operations convert storable vector into another storable vector While every single operation probably is as efficient as possible the composition of all those processes could be more efficient So keep on reading",
          "hierarchy": "Synthesizer Generic Tutorial",
          "module": "Synthesizer.Generic.Tutorial",
          "name": "filterSaw",
          "package": "synthesizer",
          "partial": "Saw",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Tutorial.html#v:filterSaw"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "We rewrite the filter example \u003ctt\u003e\u003ca\u003efilterSaw\u003c/a\u003e\u003c/tt\u003e\nin terms of type classes for more signal types.\nThe constraints become quite large\nbecause we must assert, that a particular sample type\ncan be used in the addressed signal type.\n",
          "module": "Synthesizer.Generic.Tutorial",
          "name": "filterSawSig",
          "package": "synthesizer",
          "signature": "sig Double",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Generic-Tutorial.html#filterSawSig",
          "type": "function"
        },
        "index": {
          "description": "We rewrite the filter example filterSaw in terms of type classes for more signal types The constraints become quite large because we must assert that particular sample type can be used in the addressed signal type",
          "hierarchy": "Synthesizer Generic Tutorial",
          "module": "Synthesizer.Generic.Tutorial",
          "name": "filterSawSig",
          "package": "synthesizer",
          "partial": "Saw Sig",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Tutorial.html#v:filterSawSig"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "We demonstrate the stateful signal generator using the known \u003ctt\u003e\u003ca\u003efilterSaw\u003c/a\u003e\u003c/tt\u003e example.\nActually we can reuse the code from above,\nbecause the signal generator is also an instance of the generic signal class.\n",
          "module": "Synthesizer.Generic.Tutorial",
          "name": "filterSawState",
          "package": "synthesizer",
          "signature": "IO ExitCode",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Generic-Tutorial.html#filterSawState",
          "type": "function"
        },
        "index": {
          "description": "We demonstrate the stateful signal generator using the known filterSaw example Actually we can reuse the code from above because the signal generator is also an instance of the generic signal class",
          "hierarchy": "Synthesizer Generic Tutorial",
          "module": "Synthesizer.Generic.Tutorial",
          "name": "filterSawState",
          "package": "synthesizer",
          "partial": "Saw State",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Tutorial.html#v:filterSawState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Here is a simple oscillator generated as lazy storable vector.\nAn oscillator is a signal generator,\nthat is it produces a signal\nwithout consuming other signals that correspond in time.\nSignal generators have the maximal block size as parameter.\nThis is the lower limit of possible feedback delays.\n",
          "module": "Synthesizer.Generic.Tutorial",
          "name": "oscillator",
          "package": "synthesizer",
          "signature": "IO ExitCode",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Generic-Tutorial.html#oscillator",
          "type": "function"
        },
        "index": {
          "description": "Here is simple oscillator generated as lazy storable vector An oscillator is signal generator that is it produces signal without consuming other signals that correspond in time Signal generators have the maximal block size as parameter This is the lower limit of possible feedback delays",
          "hierarchy": "Synthesizer Generic Tutorial",
          "module": "Synthesizer.Generic.Tutorial",
          "name": "oscillator",
          "package": "synthesizer",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Tutorial.html#v:oscillator"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "First, we define a play routine for lazy storable vectors.\nStorable lazy vectors are lazy lists of low-level arrays.\nThey are both efficient in time and memory consumption,\nbut the blocks disallow feedback by small delays.\nElements of a storable vector must be of type class Storable.\nThis means that elements must have fixed size\nand advanced data types like functions cannot be used.\n",
          "module": "Synthesizer.Generic.Tutorial",
          "name": "play",
          "package": "synthesizer",
          "signature": "T Double -\u003e IO ExitCode",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Generic-Tutorial.html#play",
          "type": "function"
        },
        "index": {
          "description": "First we define play routine for lazy storable vectors Storable lazy vectors are lazy lists of low-level arrays They are both efficient in time and memory consumption but the blocks disallow feedback by small delays Elements of storable vector must be of type class Storable This means that elements must have fixed size and advanced data types like functions cannot be used",
          "hierarchy": "Synthesizer Generic Tutorial",
          "module": "Synthesizer.Generic.Tutorial",
          "name": "play",
          "normalized": "T Double-\u003eIO ExitCode",
          "package": "synthesizer",
          "signature": "T Double-\u003eIO ExitCode",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Tutorial.html#v:play"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "The next signal type we want to consider is the stateful signal generator.\nIt is not a common data structure, where the sample values are materialized.\nInstead it is a description of how to generate sample values iteratively.\nThis is almost identical to the \u003ctt\u003eData.Stream\u003c/tt\u003e module from the \u003ctt\u003estream-fusion\u003c/tt\u003e package.\nWith respect to laziness and restrictions of the sample type (namely none),\nthis signal representation is equivalent to lists.\nYou can convert one into the other in a lossless way.\nThat is, function as sample type is possible.\nCombination of such signal generators is easily possible\nand does not require temporary storage,\nbecause this signal representation needs no sample value storage at all.\nHowever at the end of such processes, the signal must be materialized.\nHere we write the result into a lazy storable vector and play that.\nWhat the compiler actually does is to create a single loop,\nthat generates the storable vector to be played in one go.\n",
          "module": "Synthesizer.Generic.Tutorial",
          "name": "playState",
          "package": "synthesizer",
          "signature": "T Double -\u003e IO ExitCode",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Generic-Tutorial.html#playState",
          "type": "function"
        },
        "index": {
          "description": "The next signal type we want to consider is the stateful signal generator It is not common data structure where the sample values are materialized Instead it is description of how to generate sample values iteratively This is almost identical to the Data.Stream module from the stream-fusion package With respect to laziness and restrictions of the sample type namely none this signal representation is equivalent to lists You can convert one into the other in lossless way That is function as sample type is possible Combination of such signal generators is easily possible and does not require temporary storage because this signal representation needs no sample value storage at all However at the end of such processes the signal must be materialized Here we write the result into lazy storable vector and play that What the compiler actually does is to create single loop that generates the storable vector to be played in one go",
          "hierarchy": "Synthesizer Generic Tutorial",
          "module": "Synthesizer.Generic.Tutorial",
          "name": "playState",
          "normalized": "T Double-\u003eIO ExitCode",
          "package": "synthesizer",
          "partial": "State",
          "signature": "T Double-\u003eIO ExitCode",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Tutorial.html#v:playState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Generic.Wave",
          "name": "sample",
          "package": "synthesizer",
          "signature": "T a v -\u003e sig v -\u003e T a v",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Generic-Wave.html#sample",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Generic Wave",
          "module": "Synthesizer.Generic.Wave",
          "name": "sample",
          "normalized": "T a b-\u003ec b-\u003eT a b",
          "package": "synthesizer",
          "signature": "T a v-\u003esig v-\u003eT a v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Wave.html#v:sample"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Interpolate first within waves and then across waves,\nwhich is simpler but maybe less efficient for lists.\nHowever for types with fast indexing/drop like StorableVector this is optimal.\n",
          "module": "Synthesizer.Generic.Wave",
          "name": "sampledTone",
          "package": "synthesizer",
          "signature": "T a v -\u003e T a v -\u003e a -\u003e sig v -\u003e a -\u003e T a v",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Generic-Wave.html#sampledTone",
          "type": "function"
        },
        "index": {
          "description": "Interpolate first within waves and then across waves which is simpler but maybe less efficient for lists However for types with fast indexing drop like StorableVector this is optimal",
          "hierarchy": "Synthesizer Generic Wave",
          "module": "Synthesizer.Generic.Wave",
          "name": "sampledTone",
          "normalized": "T a b-\u003eT a b-\u003ea-\u003ec b-\u003ea-\u003eT a b",
          "package": "synthesizer",
          "partial": "Tone",
          "signature": "T a v-\u003eT a v-\u003ea-\u003esig v-\u003ea-\u003eT a v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Generic-Wave.html#v:sampledTone"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThere are still several alternatives\nof how to handle the sample rates\n(that can be equipped with physical dimensions).\n\u003c/p\u003e\u003col\u003e\u003cli\u003e Stick to simple lists as data and\n    pass additional information directly to the functions.\n    E.g. mixing several signals is easy\n    since only one sample rate is given\n    which applies to all signals.\n    But it leads to the problem\n    that subsequent function calls must receive the same value.\n    This cannot be guaranteed and is thus a source of error.\n    E.g. the mistake\n       \u003ctt\u003eplay (44100*hertz) (osciSine (22050*hertz) (440*hertz))\u003c/tt\u003e\n    can't be detected.\n    In this approach the signal data structure is very simple,\n    the values may be passed to multiple functions,\n    the combinations are simply done by function application,\n    a supervisor is not necessary,\n    consistency checks can hardly be performed.\n    This approach is certainly the most basic one,\n    on which others, more safer ones, can sit on top.\n    It is implemented in \u003ca\u003eSynthesizer.Plain.Signal\u003c/a\u003e with numbers without units.\n\u003c/li\u003e\u003cli\u003e Equip signals with sample rate and amplitude.\n    Processors without input need the sample rate as explicit parameter.\n    If there is more than one signal as input,\n    then there must be additional checks.\n    The error in\n    \u003ctt\u003e\n       mix (osciSine (22050*hertz) (440*hertz))\n           (osciSine (44100*hertz) (330*hertz))\n    \u003c/tt\u003e\n    can be detected at runtime.\n    However the sample rate has to be specified for both input signals,\n    although it is obvious, that both signals have to share the sample rate.\n    In this approach the data structure is more complex,\n    the values may be passed to multiple functions\n    but consistency checks can be performed\n    and a supervisor is still not necessary.\n    This strategy is implemented in the \u003ca\u003eSynthesizer.Physical.Signal\u003c/a\u003e modules.\n\u003c/li\u003e\u003cli\u003e We still like to hide the sample rate where possible.\n    All processors should work as good as possible at each rate.\n    Here we provide the sample rate to each processor.\n    The result of a processor is not just a list of samples\n    but it is a function, which computes the list of samples\n    depending on the sample rate.\n    Sample rate is fixed not until it comes to the rendering of a sound,\n    e.g. for playing or writing of a file.\n       \u003ctt\u003eplay (44100*hertz) (osciSine (440*hertz))\u003c/tt\u003e\n    Returning a function instead of computed data\n    has the disadvantage that multiply used data cannot be shared.\n    For these situations we need a \u003ctt\u003eshare\u003c/tt\u003e function.\n    Combinator functions similar to \u003ctt\u003e($)\u003c/tt\u003e are used\n    to plug sample rate dependent output from one processor\n    into plain signal parameters.\n    With this approach, the type signature tells\n    which signals share the sample rate.\n    Infinitely many signals can be handled.\n    Types for time and volume can be chosen quite freely.\n    Supervision is not necessary.\n    This strategy is implemented in the \u003ca\u003eSynthesizer.Inference.Reader.Signal\u003c/a\u003e modules,\n    where we hide the sample rate in a \u003ca\u003eControl.Monad.Trans.Reader\u003c/a\u003e.\n    There is also \u003ca\u003eSynthesizer.SampleRateContext.Signal\u003c/a\u003e\n    which exposes the sample rate.\n    It is more convenient to implement and to call,\n    but I think it is more unsafe,\n    because you can mix sample rates from different sources accidentally.\n    The same is available for numbers with dimension terms in types.\n    See \u003ca\u003eSynthesizer.Dimensional.Process\u003c/a\u003e.\n    \u003cem\u003eIn most cases this will be the method of choice!\u003c/em\u003e\n    Maybe I'm going to wrap this in a Reader monad/applicative functor.\n    It also requires that Haddock supports comments in parameters of type constructors.\n\u003c/li\u003e\u003cli\u003e I have tried more sophisticated approaches\n    in order to handle not only the sample rates but also the amplitudes.\n    However I feel that I wanted more than I actually needed.\n    I do no longer maintain these approaches but explain them for completeness.\n    The most convenient solution for handling sample rates and amplitudes\n    is certainly an inference system like Haskell's type system.\n    If some input and output signals of a processor\n    must have the same sampling rate,\n    then the concrete rate must only be known for one of these signals.\n    If no participating signal has a fixed rate, this is an error.\n    The dependencies of sampling rates become very large by this system.\n    The direction can be from inputs to outputs and vice versa,\n    not to mention loops.\n    This approach needs a lot of management,\n    e.g. a supervisor which runs the network,\n    but it is very convenient and safe.\n    However, sometimes you have to fiddle with monads.\n    Unfortunately it is restricted to finitely many monads\n    and the types for time and volume are restricted.\n    Thus this concept does not scale to physical units expressed in types.\n    This strategy is implemented in the modules under \u003ca\u003eSynthesizer.Inference.Monad.Signal\u003c/a\u003e.\n\u003c/li\u003e\u003cli\u003e We tried to work-around the restrictions\n    using a function based approach.\n    Since the parameters are functions,\n    sharing cannot take place.\n    There is no way to spread sample rate from one consumer to another one.\n    E.g. If there is\n    \u003ctt\u003e\n       let y = f x;\n           z = g x\n    \u003c/tt\u003e\n    and it is known that \u003ctt\u003ef\u003c/tt\u003e and \u003ctt\u003eg\u003c/tt\u003e maintain the sample rate,\n    and the sample rate of \u003ctt\u003ez\u003c/tt\u003e is known - how to infer the sample rate of \u003ctt\u003ey\u003c/tt\u003e?\n    This approach was dropped quickly and\n    exists for historical reasons in \u003ca\u003eSynthesizer.Inference.Func.Signal\u003c/a\u003e.\n\u003c/li\u003e\u003cli\u003e There is a very cool approach,\n    which implements the equation solver of the monadic approach\n    by lazy evaluation and Peano numbers.\n    This poses no restriction on types\n    and works for infinitely many equations as well.\n    The drawbacks are difficult application\n    (you cannot simply apply a function to a signal,\n    but you must compose functions in an arrow like way),\n    and slow solution of the equation system\n    (quadratic time although in principle\n    only run-time around linear time is necessary,\n    it's similar to topological sort).\n    However it's as slow as the explicit solver using monads in \u003ca\u003eSynthesizer.Inference.Monad.Signal\u003c/a\u003e.\n    This strategy is tested in the modules under \u003ca\u003eSynthesizer.Inference.Fix\u003c/a\u003e.\n\u003c/li\u003e\u003c/ol\u003e",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Inference-Overview.html",
          "type": "unknown"
        },
        "index": {
          "description": "There are still several alternatives of how to handle the sample rates that can be equipped with physical dimensions Stick to simple lists as data and pass additional information directly to the functions E.g mixing several signals is easy since only one sample rate is given which applies to all signals But it leads to the problem that subsequent function calls must receive the same value This cannot be guaranteed and is thus source of error E.g the mistake play hertz osciSine hertz hertz can be detected In this approach the signal data structure is very simple the values may be passed to multiple functions the combinations are simply done by function application supervisor is not necessary consistency checks can hardly be performed This approach is certainly the most basic one on which others more safer ones can sit on top It is implemented in Synthesizer.Plain.Signal with numbers without units Equip signals with sample rate and amplitude Processors without input need the sample rate as explicit parameter If there is more than one signal as input then there must be additional checks The error in mix osciSine hertz hertz osciSine hertz hertz can be detected at runtime However the sample rate has to be specified for both input signals although it is obvious that both signals have to share the sample rate In this approach the data structure is more complex the values may be passed to multiple functions but consistency checks can be performed and supervisor is still not necessary This strategy is implemented in the Synthesizer.Physical.Signal modules We still like to hide the sample rate where possible All processors should work as good as possible at each rate Here we provide the sample rate to each processor The result of processor is not just list of samples but it is function which computes the list of samples depending on the sample rate Sample rate is fixed not until it comes to the rendering of sound e.g for playing or writing of file play hertz osciSine hertz Returning function instead of computed data has the disadvantage that multiply used data cannot be shared For these situations we need share function Combinator functions similar to are used to plug sample rate dependent output from one processor into plain signal parameters With this approach the type signature tells which signals share the sample rate Infinitely many signals can be handled Types for time and volume can be chosen quite freely Supervision is not necessary This strategy is implemented in the Synthesizer.Inference.Reader.Signal modules where we hide the sample rate in Control.Monad.Trans.Reader There is also Synthesizer.SampleRateContext.Signal which exposes the sample rate It is more convenient to implement and to call but think it is more unsafe because you can mix sample rates from different sources accidentally The same is available for numbers with dimension terms in types See Synthesizer.Dimensional.Process In most cases this will be the method of choice Maybe going to wrap this in Reader monad applicative functor It also requires that Haddock supports comments in parameters of type constructors have tried more sophisticated approaches in order to handle not only the sample rates but also the amplitudes However feel that wanted more than actually needed do no longer maintain these approaches but explain them for completeness The most convenient solution for handling sample rates and amplitudes is certainly an inference system like Haskell type system If some input and output signals of processor must have the same sampling rate then the concrete rate must only be known for one of these signals If no participating signal has fixed rate this is an error The dependencies of sampling rates become very large by this system The direction can be from inputs to outputs and vice versa not to mention loops This approach needs lot of management e.g supervisor which runs the network but it is very convenient and safe However sometimes you have to fiddle with monads Unfortunately it is restricted to finitely many monads and the types for time and volume are restricted Thus this concept does not scale to physical units expressed in types This strategy is implemented in the modules under Synthesizer.Inference.Monad.Signal We tried to work-around the restrictions using function based approach Since the parameters are functions sharing cannot take place There is no way to spread sample rate from one consumer to another one E.g If there is let and it is known that and maintain the sample rate and the sample rate of is known how to infer the sample rate of This approach was dropped quickly and exists for historical reasons in Synthesizer.Inference.Func.Signal There is very cool approach which implements the equation solver of the monadic approach by lazy evaluation and Peano numbers This poses no restriction on types and works for infinitely many equations as well The drawbacks are difficult application you cannot simply apply function to signal but you must compose functions in an arrow like way and slow solution of the equation system quadratic time although in principle only run-time around linear time is necessary it similar to topological sort However it as slow as the explicit solver using monads in Synthesizer.Inference.Monad.Signal This strategy is tested in the modules under Synthesizer.Inference.Fix",
          "type": "unknown"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Inference-Overview.html"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Interpolation.Class",
          "name": "MAC",
          "package": "synthesizer",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Interpolation-Class.html#MAC",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "Synthesizer Interpolation Class",
          "module": "Synthesizer.Interpolation.Class",
          "name": "MAC",
          "package": "synthesizer",
          "partial": "MAC",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Interpolation-Class.html#t:MAC"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Infix variant of \u003ctt\u003e\u003ca\u003escaleAccumulate\u003c/a\u003e\u003c/tt\u003e.\n",
          "module": "Synthesizer.Interpolation.Class",
          "name": "+.*",
          "package": "synthesizer",
          "signature": "v -\u003e (a, v) -\u003e v",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Interpolation-Class.html#%2B.%2A",
          "type": "function"
        },
        "index": {
          "description": "Infix variant of scaleAccumulate",
          "hierarchy": "Synthesizer Interpolation Class",
          "module": "Synthesizer.Interpolation.Class",
          "name": "+.*",
          "normalized": "a-\u003e(b,a)-\u003ea",
          "package": "synthesizer",
          "signature": "v-\u003e(a,v)-\u003ev",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Interpolation-Class.html#v:+.*"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Interpolation.Class",
          "name": "C",
          "package": "synthesizer",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Interpolation-Class.html#C",
          "type": "class"
        },
        "index": {
          "hierarchy": "Synthesizer Interpolation Class",
          "module": "Synthesizer.Interpolation.Class",
          "name": "C",
          "package": "synthesizer",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Interpolation-Class.html#v:C"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Interpolation.Class",
          "name": "combine2",
          "package": "synthesizer",
          "signature": "a -\u003e (v, v) -\u003e v",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Interpolation-Class.html#combine2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Interpolation Class",
          "module": "Synthesizer.Interpolation.Class",
          "name": "combine2",
          "normalized": "a-\u003e(b,b)-\u003eb",
          "package": "synthesizer",
          "signature": "a-\u003e(v,v)-\u003ev",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Interpolation-Class.html#v:combine2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Interpolation.Class",
          "name": "combineMany",
          "package": "synthesizer",
          "signature": "(a, T a) -\u003e (v, T v) -\u003e v",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Interpolation-Class.html#combineMany",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Interpolation Class",
          "module": "Synthesizer.Interpolation.Class",
          "name": "combineMany",
          "normalized": "(a,T a)-\u003e(b,T b)-\u003eb",
          "package": "synthesizer",
          "partial": "Many",
          "signature": "(a,T a)-\u003e(v,T v)-\u003ev",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Interpolation-Class.html#v:combineMany"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Interpolation.Class",
          "name": "element",
          "package": "synthesizer",
          "signature": "(v -\u003e x) -\u003e MAC a v x",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Interpolation-Class.html#element",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Interpolation Class",
          "module": "Synthesizer.Interpolation.Class",
          "name": "element",
          "normalized": "(a-\u003eb)-\u003eMAC c a b",
          "package": "synthesizer",
          "signature": "(v-\u003ex)-\u003eMAC a v x",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Interpolation-Class.html#v:element"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Interpolation.Class",
          "name": "makeMac",
          "package": "synthesizer",
          "signature": "(x -\u003e v) -\u003e (v -\u003e x) -\u003e (a, v) -\u003e (v, v -\u003e v)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Interpolation-Class.html#makeMac",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Interpolation Class",
          "module": "Synthesizer.Interpolation.Class",
          "name": "makeMac",
          "normalized": "(a-\u003eb)-\u003e(b-\u003ea)-\u003e(c,b)-\u003e(b,b-\u003eb)",
          "package": "synthesizer",
          "partial": "Mac",
          "signature": "(x-\u003ev)-\u003e(v-\u003ex)-\u003e(a,v)-\u003e(v,v-\u003ev)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Interpolation-Class.html#v:makeMac"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Interpolation.Class",
          "name": "makeMac2",
          "package": "synthesizer",
          "signature": "(x -\u003e y -\u003e v) -\u003e (v -\u003e x) -\u003e (v -\u003e y) -\u003e (a, v) -\u003e (v, v -\u003e v)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Interpolation-Class.html#makeMac2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Interpolation Class",
          "module": "Synthesizer.Interpolation.Class",
          "name": "makeMac2",
          "normalized": "(a-\u003eb-\u003ec)-\u003e(c-\u003ea)-\u003e(c-\u003eb)-\u003e(d,c)-\u003e(c,c-\u003ec)",
          "package": "synthesizer",
          "partial": "Mac",
          "signature": "(x-\u003ey-\u003ev)-\u003e(v-\u003ex)-\u003e(v-\u003ey)-\u003e(a,v)-\u003e(v,v-\u003ev)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Interpolation-Class.html#v:makeMac2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Interpolation.Class",
          "name": "makeMac3",
          "package": "synthesizer",
          "signature": "(x -\u003e y -\u003e z -\u003e v) -\u003e (v -\u003e x) -\u003e (v -\u003e y) -\u003e (v -\u003e z) -\u003e (a, v) -\u003e (v, v -\u003e v)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Interpolation-Class.html#makeMac3",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Interpolation Class",
          "module": "Synthesizer.Interpolation.Class",
          "name": "makeMac3",
          "normalized": "(a-\u003eb-\u003ec-\u003ed)-\u003e(d-\u003ea)-\u003e(d-\u003eb)-\u003e(d-\u003ec)-\u003e(e,d)-\u003e(d,d-\u003ed)",
          "package": "synthesizer",
          "partial": "Mac",
          "signature": "(x-\u003ey-\u003ez-\u003ev)-\u003e(v-\u003ex)-\u003e(v-\u003ey)-\u003e(v-\u003ez)-\u003e(a,v)-\u003e(v,v-\u003ev)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Interpolation-Class.html#v:makeMac3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Interpolation.Class",
          "name": "scale",
          "package": "synthesizer",
          "signature": "(a, v) -\u003e v",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Interpolation-Class.html#scale",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Interpolation Class",
          "module": "Synthesizer.Interpolation.Class",
          "name": "scale",
          "normalized": "(a,b)-\u003eb",
          "package": "synthesizer",
          "signature": "(a,v)-\u003ev",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Interpolation-Class.html#v:scale"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Interpolation.Class",
          "name": "scaleAccumulate",
          "package": "synthesizer",
          "signature": "(a, v) -\u003e v -\u003e v",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Interpolation-Class.html#scaleAccumulate",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Interpolation Class",
          "module": "Synthesizer.Interpolation.Class",
          "name": "scaleAccumulate",
          "normalized": "(a,b)-\u003eb-\u003eb",
          "package": "synthesizer",
          "partial": "Accumulate",
          "signature": "(a,v)-\u003ev-\u003ev",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Interpolation-Class.html#v:scaleAccumulate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Interpolation.Class",
          "name": "scaleAndAccumulate",
          "package": "synthesizer",
          "signature": "(a, v) -\u003e (v, v -\u003e v)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Interpolation-Class.html#scaleAndAccumulate",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Interpolation Class",
          "module": "Synthesizer.Interpolation.Class",
          "name": "scaleAndAccumulate",
          "normalized": "(a,b)-\u003e(b,b-\u003eb)",
          "package": "synthesizer",
          "partial": "And Accumulate",
          "signature": "(a,v)-\u003e(v,v-\u003ev)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Interpolation-Class.html#v:scaleAndAccumulate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Interpolation.Class",
          "name": "scaleAndAccumulateModule",
          "package": "synthesizer",
          "signature": "(a, v) -\u003e (v, v -\u003e v)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Interpolation-Class.html#scaleAndAccumulateModule",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Interpolation Class",
          "module": "Synthesizer.Interpolation.Class",
          "name": "scaleAndAccumulateModule",
          "normalized": "(a,b)-\u003e(b,b-\u003eb)",
          "package": "synthesizer",
          "partial": "And Accumulate Module",
          "signature": "(a,v)-\u003e(v,v-\u003ev)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Interpolation-Class.html#v:scaleAndAccumulateModule"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Interpolation.Class",
          "name": "scaleAndAccumulateRing",
          "package": "synthesizer",
          "signature": "(a, a) -\u003e (a, a -\u003e a)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Interpolation-Class.html#scaleAndAccumulateRing",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Interpolation Class",
          "module": "Synthesizer.Interpolation.Class",
          "name": "scaleAndAccumulateRing",
          "normalized": "(a,a)-\u003e(a,a-\u003ea)",
          "package": "synthesizer",
          "partial": "And Accumulate Ring",
          "signature": "(a,a)-\u003e(a,a-\u003ea)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Interpolation-Class.html#v:scaleAndAccumulateRing"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Interpolation.Custom",
          "name": "T",
          "package": "synthesizer",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Interpolation.html#T",
          "type": "data"
        },
        "index": {
          "hierarchy": "Synthesizer Interpolation Custom",
          "module": "Synthesizer.Interpolation.Custom",
          "name": "T",
          "package": "synthesizer",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Interpolation-Custom.html#t:T"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Consider the signal to be piecewise constant. \n",
          "module": "[\"Synthesizer.Interpolation.Custom\",\"Synthesizer.Interpolation.Module\",\"Synthesizer.Interpolation\",\"Synthesizer.Plain.Interpolation\"]",
          "name": "constant",
          "package": "synthesizer",
          "signature": "T t y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Interpolation.html#constant",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Interpolation-Custom.html#v:constant\",\"http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Interpolation-Module.html#v:constant\",\"http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Interpolation.html#v:constant\",\"http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Interpolation.html#v:constant\"]"
        },
        "index": {
          "description": "Consider the signal to be piecewise constant",
          "hierarchy": "Synthesizer Interpolation Custom",
          "module": "Synthesizer.Interpolation.Custom",
          "name": "constant",
          "package": "synthesizer",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Interpolation-Custom.html#v:constant"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Consider the signal to be piecewise cubic,\nwith smooth connections at the nodes.\nIt uses a cubic curve which has node values\nx0 at 0 and x1 at 1 and derivatives\n(x1-xm1)\u003cem\u003e2 and (x2-x0)\u003c/em\u003e2, respectively.\nYou can see how it works\nif you evaluate the expression for t=0 and t=1\nas well as the derivative at these points.\n",
          "module": "Synthesizer.Interpolation.Custom",
          "name": "cubic",
          "package": "synthesizer",
          "signature": "T t y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Interpolation-Custom.html#cubic",
          "type": "function"
        },
        "index": {
          "description": "Consider the signal to be piecewise cubic with smooth connections at the nodes It uses cubic curve which has node values x0 at and x1 at and derivatives x1-xm1 and x2-x0 respectively You can see how it works if you evaluate the expression for and as well as the derivative at these points",
          "hierarchy": "Synthesizer Interpolation Custom",
          "module": "Synthesizer.Interpolation.Custom",
          "name": "cubic",
          "package": "synthesizer",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Interpolation-Custom.html#v:cubic"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003ctt\u003e(left extent, right extent)\u003c/tt\u003e, e.g. \u003ctt\u003e(1,1)\u003c/tt\u003e for linear hat \n",
          "module": "Synthesizer.Interpolation.Custom",
          "name": "function",
          "package": "synthesizer",
          "signature": "(Int, Int)-\u003e t -\u003e t-\u003e T t y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Interpolation-Custom.html#function",
          "type": "function"
        },
        "index": {
          "description": "left extent right extent e.g for linear hat",
          "hierarchy": "Synthesizer Interpolation Custom",
          "module": "Synthesizer.Interpolation.Custom",
          "name": "function",
          "normalized": "(Int,Int)-\u003ea-\u003ea-\u003eT a b",
          "package": "synthesizer",
          "signature": "(Int,Int)-\u003et-\u003et-\u003eT t y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Interpolation-Custom.html#v:function"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Consider the signal to be piecewise linear. \n",
          "module": "Synthesizer.Interpolation.Custom",
          "name": "linear",
          "package": "synthesizer",
          "signature": "T t y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Interpolation-Custom.html#linear",
          "type": "function"
        },
        "index": {
          "description": "Consider the signal to be piecewise linear",
          "hierarchy": "Synthesizer Interpolation Custom",
          "module": "Synthesizer.Interpolation.Custom",
          "name": "linear",
          "package": "synthesizer",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Interpolation-Custom.html#v:linear"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "List of functions must be non-empty.\n",
          "module": "Synthesizer.Interpolation.Custom",
          "name": "piecewise",
          "package": "synthesizer",
          "signature": "Int -\u003e [t -\u003e t] -\u003e T t y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Interpolation-Custom.html#piecewise",
          "type": "function"
        },
        "index": {
          "description": "List of functions must be non-empty",
          "hierarchy": "Synthesizer Interpolation Custom",
          "module": "Synthesizer.Interpolation.Custom",
          "name": "piecewise",
          "normalized": "Int-\u003e[a-\u003ea]-\u003eT a b",
          "package": "synthesizer",
          "signature": "Int-\u003e[t-\u003et]-\u003eT t y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Interpolation-Custom.html#v:piecewise"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Interpolation.Custom",
          "name": "piecewiseConstant",
          "package": "synthesizer",
          "signature": "T t y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Interpolation-Custom.html#piecewiseConstant",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Interpolation Custom",
          "module": "Synthesizer.Interpolation.Custom",
          "name": "piecewiseConstant",
          "package": "synthesizer",
          "partial": "Constant",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Interpolation-Custom.html#v:piecewiseConstant"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Interpolation.Custom",
          "name": "piecewiseCubic",
          "package": "synthesizer",
          "signature": "T t y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Interpolation-Custom.html#piecewiseCubic",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Interpolation Custom",
          "module": "Synthesizer.Interpolation.Custom",
          "name": "piecewiseCubic",
          "package": "synthesizer",
          "partial": "Cubic",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Interpolation-Custom.html#v:piecewiseCubic"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Interpolation.Custom",
          "name": "piecewiseLinear",
          "package": "synthesizer",
          "signature": "T t y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Interpolation-Custom.html#piecewiseLinear",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Interpolation Custom",
          "module": "Synthesizer.Interpolation.Custom",
          "name": "piecewiseLinear",
          "package": "synthesizer",
          "partial": "Linear",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Interpolation-Custom.html#v:piecewiseLinear"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Interpolation.Module",
          "name": "T",
          "package": "synthesizer",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Interpolation.html#T",
          "type": "data"
        },
        "index": {
          "hierarchy": "Synthesizer Interpolation Module",
          "module": "Synthesizer.Interpolation.Module",
          "name": "T",
          "package": "synthesizer",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Interpolation-Module.html#t:T"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Consider the signal to be piecewise cubic,\nwith smooth connections at the nodes.\nIt uses a cubic curve which has node values\nx0 at 0 and x1 at 1 and derivatives\n(x1-xm1)\u003cem\u003e2 and (x2-x0)\u003c/em\u003e2, respectively.\nYou can see how it works\nif you evaluate the expression for t=0 and t=1\nas well as the derivative at these points.\n",
          "module": "[\"Synthesizer.Interpolation.Module\",\"Synthesizer.Plain.Interpolation\"]",
          "name": "cubic",
          "package": "synthesizer",
          "signature": "T t y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Interpolation-Module.html#cubic",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Interpolation-Module.html#v:cubic\",\"http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Interpolation.html#v:cubic\"]"
        },
        "index": {
          "description": "Consider the signal to be piecewise cubic with smooth connections at the nodes It uses cubic curve which has node values x0 at and x1 at and derivatives x1-xm1 and x2-x0 respectively You can see how it works if you evaluate the expression for and as well as the derivative at these points",
          "hierarchy": "Synthesizer Interpolation Module",
          "module": "Synthesizer.Interpolation.Module",
          "name": "cubic",
          "package": "synthesizer",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Interpolation-Module.html#v:cubic"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "The interpolators for module operations\ndo not simply compute a straight linear combination of some vectors.\nInstead they add then scale, then add again, and so on.\nThis is efficient whenever scaling and addition is cheap.\nIn this case they might save multiplications.\nI can't say much about numeric cancellations, however.\n",
          "module": "Synthesizer.Interpolation.Module",
          "name": "cubicAlt",
          "package": "synthesizer",
          "signature": "T t y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Interpolation-Module.html#cubicAlt",
          "type": "function"
        },
        "index": {
          "description": "The interpolators for module operations do not simply compute straight linear combination of some vectors Instead they add then scale then add again and so on This is efficient whenever scaling and addition is cheap In this case they might save multiplications can say much about numeric cancellations however",
          "hierarchy": "Synthesizer Interpolation Module",
          "module": "Synthesizer.Interpolation.Module",
          "name": "cubicAlt",
          "package": "synthesizer",
          "partial": "Alt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Interpolation-Module.html#v:cubicAlt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003ctt\u003e(left extent, right extent)\u003c/tt\u003e, e.g. \u003ctt\u003e(1,1)\u003c/tt\u003e for linear hat \n",
          "module": "[\"Synthesizer.Interpolation.Module\",\"Synthesizer.Plain.Interpolation\"]",
          "name": "function",
          "package": "synthesizer",
          "signature": "(Int, Int)-\u003e t -\u003e t-\u003e T t y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Interpolation-Module.html#function",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Interpolation-Module.html#v:function\",\"http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Interpolation.html#v:function\"]"
        },
        "index": {
          "description": "left extent right extent e.g for linear hat",
          "hierarchy": "Synthesizer Interpolation Module",
          "module": "Synthesizer.Interpolation.Module",
          "name": "function",
          "normalized": "(Int,Int)-\u003ea-\u003ea-\u003eT a b",
          "package": "synthesizer",
          "signature": "(Int,Int)-\u003et-\u003et-\u003eT t y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Interpolation-Module.html#v:function"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Consider the signal to be piecewise linear. \n",
          "module": "[\"Synthesizer.Interpolation.Module\",\"Synthesizer.Plain.Interpolation\"]",
          "name": "linear",
          "package": "synthesizer",
          "signature": "T t y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Interpolation-Module.html#linear",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Interpolation-Module.html#v:linear\",\"http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Interpolation.html#v:linear\"]"
        },
        "index": {
          "description": "Consider the signal to be piecewise linear",
          "hierarchy": "Synthesizer Interpolation Module",
          "module": "Synthesizer.Interpolation.Module",
          "name": "linear",
          "package": "synthesizer",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Interpolation-Module.html#v:linear"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Synthesizer.Interpolation.Module\",\"Synthesizer.Plain.Interpolation\"]",
          "name": "piecewise",
          "package": "synthesizer",
          "signature": "Int -\u003e [t -\u003e t] -\u003e T t y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Interpolation-Module.html#piecewise",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Interpolation-Module.html#v:piecewise\",\"http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Interpolation.html#v:piecewise\"]"
        },
        "index": {
          "hierarchy": "Synthesizer Interpolation Module",
          "module": "Synthesizer.Interpolation.Module",
          "name": "piecewise",
          "normalized": "Int-\u003e[a-\u003ea]-\u003eT a b",
          "package": "synthesizer",
          "signature": "Int-\u003e[t-\u003et]-\u003eT t y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Interpolation-Module.html#v:piecewise"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Interpolation.Module",
          "name": "piecewiseConstant",
          "package": "synthesizer",
          "signature": "T t y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Interpolation-Module.html#piecewiseConstant",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Interpolation Module",
          "module": "Synthesizer.Interpolation.Module",
          "name": "piecewiseConstant",
          "package": "synthesizer",
          "partial": "Constant",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Interpolation-Module.html#v:piecewiseConstant"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Interpolation.Module",
          "name": "piecewiseCubic",
          "package": "synthesizer",
          "signature": "T t y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Interpolation-Module.html#piecewiseCubic",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Interpolation Module",
          "module": "Synthesizer.Interpolation.Module",
          "name": "piecewiseCubic",
          "package": "synthesizer",
          "partial": "Cubic",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Interpolation-Module.html#v:piecewiseCubic"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Interpolation.Module",
          "name": "piecewiseLinear",
          "package": "synthesizer",
          "signature": "T t y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Interpolation-Module.html#piecewiseLinear",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Interpolation Module",
          "module": "Synthesizer.Interpolation.Module",
          "name": "piecewiseLinear",
          "package": "synthesizer",
          "partial": "Linear",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Interpolation-Module.html#v:piecewiseLinear"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Interpolation",
          "name": "Margin",
          "package": "synthesizer",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Interpolation.html#Margin",
          "type": "data"
        },
        "index": {
          "hierarchy": "Synthesizer Interpolation",
          "module": "Synthesizer.Interpolation",
          "name": "Margin",
          "package": "synthesizer",
          "partial": "Margin",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Interpolation.html#t:Margin"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Interpolation",
          "name": "PrefixReader",
          "package": "synthesizer",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Interpolation.html#PrefixReader",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "Synthesizer Interpolation",
          "module": "Synthesizer.Interpolation",
          "name": "PrefixReader",
          "package": "synthesizer",
          "partial": "Prefix Reader",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Interpolation.html#t:PrefixReader"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Interpolation",
          "name": "T",
          "package": "synthesizer",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Interpolation.html#T",
          "type": "data"
        },
        "index": {
          "hierarchy": "Synthesizer Interpolation",
          "module": "Synthesizer.Interpolation",
          "name": "T",
          "package": "synthesizer",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Interpolation.html#t:T"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Interpolation",
          "name": "cons",
          "package": "synthesizer",
          "signature": "Int -\u003e Int -\u003e (t -\u003e T y -\u003e y) -\u003e T t y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Interpolation.html#cons",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Interpolation",
          "module": "Synthesizer.Interpolation",
          "name": "cons",
          "normalized": "Int-\u003eInt-\u003e(a-\u003eT b-\u003eb)-\u003eT a b",
          "package": "synthesizer",
          "signature": "Int-\u003eInt-\u003e(t-\u003eT y-\u003ey)-\u003eT t y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Interpolation.html#v:cons"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Interpolation",
          "name": "fromPrefixReader",
          "package": "synthesizer",
          "signature": "String -\u003e Int -\u003e PrefixReader y (t -\u003e y) -\u003e T t y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Interpolation.html#fromPrefixReader",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Interpolation",
          "module": "Synthesizer.Interpolation",
          "name": "fromPrefixReader",
          "normalized": "String-\u003eInt-\u003ePrefixReader a(b-\u003ea)-\u003eT b a",
          "package": "synthesizer",
          "partial": "Prefix Reader",
          "signature": "String-\u003eInt-\u003ePrefixReader y(t-\u003ey)-\u003eT t y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Interpolation.html#v:fromPrefixReader"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Interpolation",
          "name": "getNode",
          "package": "synthesizer",
          "signature": "PrefixReader y y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Interpolation.html#getNode",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Interpolation",
          "module": "Synthesizer.Interpolation",
          "name": "getNode",
          "package": "synthesizer",
          "partial": "Node",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Interpolation.html#v:getNode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis module gives an overview of the library.\n\u003c/p\u003e\u003cp\u003eThe library is a collection of modules for synthesizing and processing audio signals.\nIt allows generation of effects, instruments and\neven music using the Haskore package.\nIt can write raw audio data to files,\nconvert them to common audio formats or\nplay them using external commands from the Sox package.\nIf used properly, it can run in real-time.\n\u003c/p\u003e\u003cp\u003eA signal is modeled by a sequence of sample values.\nE.g. \u003ctt\u003e[Double]\u003c/tt\u003e represents a mono signal,\n\u003ctt\u003e[(Double, Double)]\u003c/tt\u003e stores a stereo signal.\nSince a list is lazy, it can be infinitely long,\nand it also supports feedback.\n(The drawback is, that its implementation is very slow.\nYou have to use other signal presentations of this library for real-time processing.)\nWe are using the NumericPrelude type class hierarchy\nwhich is cleaner than the one of Haskell 98\nand provides us with a type class for vector spaces and other structures.\nThis allows us to formulate many algorithms for mono, stereo and multi-channel signals at once.\nThe drawback is that the vector space type class has multiple type parameters.\nThis type extension is available in GHC and Hugs and maybe other compilers.\nIt may hurt you, because type inference fails sometimes,\nresulting in strange type errors.\n(To be precise: GHC suggests type constraints intended for fixing the problem,\nbut if you copy them to your program, they won't fix the problem,\nbecause the constraint refers to local variables\nthat you have no access to at the signature.\nIn this case you have to use \u003ctt\u003e\u003ca\u003easTypeOf\u003c/a\u003e\u003c/tt\u003e or similar self-written helpers.)\n\u003c/p\u003e\u003cp\u003eThere must also be information about how fast sample values are emitted.\nThis is specified by the sample rate.\n44100 Hz means that 44100 sample values are emitted per second.\nThis information must be stored along with the sample values.\nThis is where things become complicated.\n\u003c/p\u003e\u003cp\u003eIn the very basic modules in the \u003ca\u003eSynthesizer.Plain.Signal\u003c/a\u003e directory,\nthere is no notion of sample rate.\nYou have to base all computations on the number of samples.\nThis is unintuitive and disallows easy adaption to different audio devices\n(CD, DAT, ...).\nBut it is very simple and can be re-used in the higher level modules.\n\u003c/p\u003e\u003cp\u003eLet's continue with the sample rate issue.\nSounds of different sources may differ in their sampling rate\n(and also with respect to its amplitude and the unit of the values).\nSampled sounds have 44100 Hz on a compact disk,\n48000 Hz or 32000 Hz on DAT recorders.\nWe want to respect different sampling rates and volumes,\nwe want to let signals in different formats coexist nicely,\nand we want to let the user choose when to do which conversion\n(called \u003cem\u003eresampling\u003c/em\u003e)\nin order to bring them together.\n\u003c/p\u003e\u003cp\u003eIn fact this view generalizes the concept of note, control, and audio rates,\nwhich is found in some software synthesizers,\nlike CSound and SuperCollider.\nIf signals of different rate are fed to a signal processor\nin such a software synthesizer,\nall signals are converted to the highest rate among the inputs.\nThen the processor runs at this rate.\nThe conversion is usually done by \"constant\" interpolation,\nin order to minimize recomputation of internal parameters.\nHowever the handling of different signal rates must be built into every processor,\nand may even reduce the computation speed.\nConsider an exponential envelope which is computed at control rate\nand an amplifier which applies this envelope to an audio signal.\nThe amplifier has to upsample the exponential envelope before applying it to the signal.\nBut the generation of the exponential is very simple,\none multiplication per sample,\nand the amplifier is very simple, too,\nagain only one multiplication per sample.\nSo, is there a need for trouble of the resampling?\nDoes it really accelerates computation?\nMany other envelope generators like straight lines, sines, oscillators,\nare comparably simple.\nHowever there are some processors like filters,\nwhich need some recomputation when a control parameter changes.\n\u003c/p\u003e\u003cp\u003eOur approach is this one:\nWe try to avoid resampling and compute all signals at the same rate,\nif no speed loss must be expected.\nIf a speed loss is to be expected,\nwe can interpolate the internal parameters of the processor explicitly.\nThis way we can also specify an interpolation method.\nAlternatively we can move the interpolation into the processor\nbut let the user specify an interpolation method.\n(Currently it can be used only manually for the low-level routines in \u003ca\u003eSynthesizer.Plain.Signal\u003c/a\u003e\nand for the high level modules there is \u003ca\u003eSynthesizer.Dimensional.ControlledProcess\u003c/a\u003e.)\n\u003c/p\u003e\u003cp\u003eAdditional to the treatment of sampling rates,\nwe also want to separate amplitude information from the signal.\nThe separated amplitude serves two purposes:\n\u003c/p\u003e\u003col\u003e\u003cli\u003e The amplitude can be equipped with a physical unit,\n    whereas this information is omitted for the samples.\n    Since I can hardly imagine that it is sensible to mix samples\n    with different physical units,\n    it would be only wasted time to always check\n    if all physical values of a sequence have the same unit.\n\u003c/li\u003e\u003cli\u003e The amplitude can be a floating point number,\n    but the samples can be fixed point numbers.\n    This is interesting for hardware digital signal processors\n    or other low-level applications.\n    With this method we can separate the overall dynamics from the samples.\n\u003c/li\u003e\u003c/ol\u003e\u003cp\u003eLet's elaborate on the physical units now.\nWith them we can work with values from the real world immediately\nand we have additional safety by unit checks.\nI have not fixed the physical dimensions for the signal processors,\ne.g. an oscillator can well generate a signal\nover the length dimension mapping to forces.\nThis is useful for interim results in physically motivated signal generation\nbut it can be useful on its own for non-audio signal processing.\nThe processors only check whether the dimensions match,\ne.g. an oscillator generating a time-to-voltage signal\nmust have a frequency in Hertz\nand a length-to-force oscillator must have \u003ctt\u003e1/meter\u003c/tt\u003e as frequency.\n\u003c/p\u003e\u003cp\u003eOf course I prefer static safety.\nE.g. I want to avoid\nto accidentally call a function with conflicting parameters.\nHowever, I see no way for both applying the unit checks statically\nand let check physical quantities that are provided by an application user via I/O.\nSince there seems to be no one solution for all problems,\nwe have two distinct ones:\n\u003c/p\u003e\u003col\u003e\u003cli\u003e Store units in a data structure and check them dynamically.\n    This is imported from NumericPrelude's \u003ca\u003eNumber.Physical\u003c/a\u003e.\n    Units can be fetched from the user.\n    The API of signal processing functions is generic enough\n    to cover both values without units and values with units.\n    Debugging of unit errors is cumbersome.\n\u003c/li\u003e\u003cli\u003e Store physical dimensions in types\n    either using Buckwalter's dimensional package\n    or using NumericPrelude's \u003ca\u003eNumber.DimensionTerm\u003c/a\u003e.\n    Here we use the latter one.\n    This is the most useful if user interaction is not needed.\n    If data is fetched from an audio file\n    the dimensions are statically fixed.\n\u003c/li\u003e\u003c/ol\u003e\u003cul\u003e\u003cli\u003e The various signal storage types are described in \u003ca\u003eSynthesizer.Storage\u003c/a\u003e.\n\u003c/li\u003e\u003cli\u003e The various attributes, that can be attached to plain signal storages\n  are described in \u003ca\u003eSynthesizer.Dimensional.Overview\u003c/a\u003e.\n\u003c/li\u003e\u003cli\u003e Various abstractions are described in \u003ca\u003eSynthesizer.Dimensional.Abstraction.Overview\u003c/a\u003e.\n\u003c/li\u003e\u003cli\u003e For historical reasons there is a survey on various approaches\n  of sample rate abstraction in \u003ca\u003eSynthesizer.Inference.Overview\u003c/a\u003e.\n\u003c/li\u003e\u003cli\u003e Some introductory examples are described\n  in \u003ca\u003eSynthesizer.Tutorial\u003c/a\u003e.\n\u003c/li\u003e\u003c/ul\u003e\u003cp\u003ePackages based on this one:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e \u003ctt\u003edafx\u003c/tt\u003e package:\n  The module \u003ca\u003ePresentation\u003c/a\u003e contains functions\n  for demonstrating synthesizer functions in GHCi\n  and \u003ca\u003eDAFx\u003c/a\u003e contains some examples based on them.\n  Just hit \u003ctt\u003emake dafx\u003c/tt\u003e in a shell in order to compile the modules\n  and enter the interactive GHC with all modules loaded.\n\u003c/li\u003e\u003cli\u003e An interface to the music composition library Haskore\n  together with various examples\n  can be found in the \u003ctt\u003ehaskore-synthesizer\u003c/tt\u003e package.\n\u003c/li\u003e\u003cli\u003e \u003ctt\u003esynthesizer-alsa\u003c/tt\u003e allows to receive MIDI events via ALSA\n  and convert them to control signals.\n  This way you can do interactive signal processing via MIDI input devices.\n\u003c/li\u003e\u003c/ul\u003e",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Overview.html",
          "type": "unknown"
        },
        "index": {
          "description": "This module gives an overview of the library The library is collection of modules for synthesizing and processing audio signals It allows generation of effects instruments and even music using the Haskore package It can write raw audio data to files convert them to common audio formats or play them using external commands from the Sox package If used properly it can run in real-time signal is modeled by sequence of sample values E.g Double represents mono signal Double Double stores stereo signal Since list is lazy it can be infinitely long and it also supports feedback The drawback is that its implementation is very slow You have to use other signal presentations of this library for real-time processing We are using the NumericPrelude type class hierarchy which is cleaner than the one of Haskell and provides us with type class for vector spaces and other structures This allows us to formulate many algorithms for mono stereo and multi-channel signals at once The drawback is that the vector space type class has multiple type parameters This type extension is available in GHC and Hugs and maybe other compilers It may hurt you because type inference fails sometimes resulting in strange type errors To be precise GHC suggests type constraints intended for fixing the problem but if you copy them to your program they won fix the problem because the constraint refers to local variables that you have no access to at the signature In this case you have to use asTypeOf or similar self-written helpers There must also be information about how fast sample values are emitted This is specified by the sample rate Hz means that sample values are emitted per second This information must be stored along with the sample values This is where things become complicated In the very basic modules in the Synthesizer.Plain.Signal directory there is no notion of sample rate You have to base all computations on the number of samples This is unintuitive and disallows easy adaption to different audio devices CD DAT But it is very simple and can be re-used in the higher level modules Let continue with the sample rate issue Sounds of different sources may differ in their sampling rate and also with respect to its amplitude and the unit of the values Sampled sounds have Hz on compact disk Hz or Hz on DAT recorders We want to respect different sampling rates and volumes we want to let signals in different formats coexist nicely and we want to let the user choose when to do which conversion called resampling in order to bring them together In fact this view generalizes the concept of note control and audio rates which is found in some software synthesizers like CSound and SuperCollider If signals of different rate are fed to signal processor in such software synthesizer all signals are converted to the highest rate among the inputs Then the processor runs at this rate The conversion is usually done by constant interpolation in order to minimize recomputation of internal parameters However the handling of different signal rates must be built into every processor and may even reduce the computation speed Consider an exponential envelope which is computed at control rate and an amplifier which applies this envelope to an audio signal The amplifier has to upsample the exponential envelope before applying it to the signal But the generation of the exponential is very simple one multiplication per sample and the amplifier is very simple too again only one multiplication per sample So is there need for trouble of the resampling Does it really accelerates computation Many other envelope generators like straight lines sines oscillators are comparably simple However there are some processors like filters which need some recomputation when control parameter changes Our approach is this one We try to avoid resampling and compute all signals at the same rate if no speed loss must be expected If speed loss is to be expected we can interpolate the internal parameters of the processor explicitly This way we can also specify an interpolation method Alternatively we can move the interpolation into the processor but let the user specify an interpolation method Currently it can be used only manually for the low-level routines in Synthesizer.Plain.Signal and for the high level modules there is Synthesizer.Dimensional.ControlledProcess Additional to the treatment of sampling rates we also want to separate amplitude information from the signal The separated amplitude serves two purposes The amplitude can be equipped with physical unit whereas this information is omitted for the samples Since can hardly imagine that it is sensible to mix samples with different physical units it would be only wasted time to always check if all physical values of sequence have the same unit The amplitude can be floating point number but the samples can be fixed point numbers This is interesting for hardware digital signal processors or other low-level applications With this method we can separate the overall dynamics from the samples Let elaborate on the physical units now With them we can work with values from the real world immediately and we have additional safety by unit checks have not fixed the physical dimensions for the signal processors e.g an oscillator can well generate signal over the length dimension mapping to forces This is useful for interim results in physically motivated signal generation but it can be useful on its own for non-audio signal processing The processors only check whether the dimensions match e.g an oscillator generating time-to-voltage signal must have frequency in Hertz and length-to-force oscillator must have meter as frequency Of course prefer static safety E.g want to avoid to accidentally call function with conflicting parameters However see no way for both applying the unit checks statically and let check physical quantities that are provided by an application user via Since there seems to be no one solution for all problems we have two distinct ones Store units in data structure and check them dynamically This is imported from NumericPrelude Number.Physical Units can be fetched from the user The API of signal processing functions is generic enough to cover both values without units and values with units Debugging of unit errors is cumbersome Store physical dimensions in types either using Buckwalter dimensional package or using NumericPrelude Number.DimensionTerm Here we use the latter one This is the most useful if user interaction is not needed If data is fetched from an audio file the dimensions are statically fixed The various signal storage types are described in Synthesizer.Storage The various attributes that can be attached to plain signal storages are described in Synthesizer.Dimensional.Overview Various abstractions are described in Synthesizer.Dimensional.Abstraction.Overview For historical reasons there is survey on various approaches of sample rate abstraction in Synthesizer.Inference.Overview Some introductory examples are described in Synthesizer.Tutorial Packages based on this one dafx package The module Presentation contains functions for demonstrating synthesizer functions in GHCi and DAFx contains some examples based on them Just hit make dafx in shell in order to compile the modules and enter the interactive GHC with all modules loaded An interface to the music composition library Haskore together with various examples can be found in the haskore-synthesizer package synthesizer-alsa allows to receive MIDI events via ALSA and convert them to control signals This way you can do interactive signal processing via MIDI input devices",
          "type": "unknown"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Overview.html"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "sample rate \ntime where the function reaches 1/e of the initial value \ninitial value \nexponential decay \n",
          "module": "Synthesizer.Physical.Control",
          "name": "exponential",
          "package": "synthesizer",
          "signature": "a'-\u003e a'-\u003e a'-\u003e T a a' a a' a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Physical-Control.html#exponential",
          "type": "function"
        },
        "index": {
          "description": "sample rate time where the function reaches of the initial value initial value exponential decay",
          "hierarchy": "Synthesizer Physical Control",
          "module": "Synthesizer.Physical.Control",
          "name": "exponential",
          "normalized": "a-\u003ea-\u003ea-\u003eT b a b a b",
          "package": "synthesizer",
          "signature": "a'-\u003ea'-\u003ea'-\u003eT a a' a a' a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Physical-Control.html#v:exponential"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "sample rate \nhalf life \ninitial value \nexponential decay \n",
          "module": "Synthesizer.Physical.Control",
          "name": "exponential2",
          "package": "synthesizer",
          "signature": "a'-\u003e a'-\u003e a'-\u003e T a a' a a' a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Physical-Control.html#exponential2",
          "type": "function"
        },
        "index": {
          "description": "sample rate half life initial value exponential decay",
          "hierarchy": "Synthesizer Physical Control",
          "module": "Synthesizer.Physical.Control",
          "name": "exponential2",
          "normalized": "a-\u003ea-\u003ea-\u003eT b a b a b",
          "package": "synthesizer",
          "signature": "a'-\u003ea'-\u003ea'-\u003eT a a' a a' a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Physical-Control.html#v:exponential2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "sample rate \ntime where the function reaches 1/e of the initial value \namplitude unit \ninitial value \nexponential decay \n",
          "module": "Synthesizer.Physical.Control",
          "name": "vectorExponential",
          "package": "synthesizer",
          "signature": "t'-\u003e t'-\u003e y'-\u003e yv-\u003e T t t' y y' yv",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Physical-Control.html#vectorExponential",
          "type": "function"
        },
        "index": {
          "description": "sample rate time where the function reaches of the initial value amplitude unit initial value exponential decay",
          "hierarchy": "Synthesizer Physical Control",
          "module": "Synthesizer.Physical.Control",
          "name": "vectorExponential",
          "normalized": "a-\u003ea-\u003eb-\u003ec-\u003eT d a e b c",
          "package": "synthesizer",
          "partial": "Exponential",
          "signature": "t'-\u003et'-\u003ey'-\u003eyv-\u003eT t t' y y' yv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Physical-Control.html#v:vectorExponential"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "sample rate \nhalf life \namplitude unit \ninitial value \nexponential decay \n",
          "module": "Synthesizer.Physical.Control",
          "name": "vectorExponential2",
          "package": "synthesizer",
          "signature": "t'-\u003e t'-\u003e y'-\u003e yv-\u003e T t t' y y' yv",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Physical-Control.html#vectorExponential2",
          "type": "function"
        },
        "index": {
          "description": "sample rate half life amplitude unit initial value exponential decay",
          "hierarchy": "Synthesizer Physical Control",
          "module": "Synthesizer.Physical.Control",
          "name": "vectorExponential2",
          "normalized": "a-\u003ea-\u003eb-\u003ec-\u003eT d a e b c",
          "package": "synthesizer",
          "partial": "Exponential",
          "signature": "t'-\u003et'-\u003ey'-\u003eyv-\u003eT t t' y y' yv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Physical-Control.html#v:vectorExponential2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Physical.Cut",
          "name": "append",
          "package": "synthesizer",
          "signature": "T t t' y y' yv -\u003e T t t' y y' yv -\u003e T t t' y y' yv",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Physical-Cut.html#append",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Physical Cut",
          "module": "Synthesizer.Physical.Cut",
          "name": "append",
          "normalized": "T a b c d e-\u003eT a b c d e-\u003eT a b c d e",
          "package": "synthesizer",
          "signature": "T t t' y y' yv-\u003eT t t' y y' yv-\u003eT t t' y y' yv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Physical-Cut.html#v:append"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Unit of the time values in the time ordered list. \nA list of pairs: (relative start time, signal part),\n              The start time is relative\n              to the start time of the previous event. \nThe mixed signal. \n",
          "module": "Synthesizer.Physical.Cut",
          "name": "arrange",
          "package": "synthesizer",
          "signature": "t'-\u003e T t (T t t' y y' yv)-\u003e T t t' y y' yv",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Physical-Cut.html#arrange",
          "type": "function"
        },
        "index": {
          "description": "Unit of the time values in the time ordered list list of pairs relative start time signal part The start time is relative to the start time of the previous event The mixed signal",
          "hierarchy": "Synthesizer Physical Cut",
          "module": "Synthesizer.Physical.Cut",
          "name": "arrange",
          "normalized": "a-\u003eT b(T b a c d e)-\u003eT b a c d e",
          "package": "synthesizer",
          "signature": "t'-\u003eT t(T t t' y y' yv)-\u003eT t t' y y' yv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Physical-Cut.html#v:arrange"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Amplitude of output. \nUnit of the time values in the time ordered list. \nA list of pairs: (relative start time, signal part),\n              The start time is relative\n              to the start time of the previous event. \nThe mixed signal. \n",
          "module": "Synthesizer.Physical.Cut",
          "name": "arrangeVolume",
          "package": "synthesizer",
          "signature": "y'-\u003e t'-\u003e T t (T t t' y y' yv)-\u003e T t t' y y' yv",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Physical-Cut.html#arrangeVolume",
          "type": "function"
        },
        "index": {
          "description": "Amplitude of output Unit of the time values in the time ordered list list of pairs relative start time signal part The start time is relative to the start time of the previous event The mixed signal",
          "hierarchy": "Synthesizer Physical Cut",
          "module": "Synthesizer.Physical.Cut",
          "name": "arrangeVolume",
          "normalized": "a-\u003eb-\u003eT c(T c b d a e)-\u003eT c b d a e",
          "package": "synthesizer",
          "partial": "Volume",
          "signature": "y'-\u003et'-\u003eT t(T t t' y y' yv)-\u003eT t t' y y' yv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Physical-Cut.html#v:arrangeVolume"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Similar to \u003ctt\u003efoldr1 append\u003c/tt\u003e but more efficient and accurate,\n  because it reduces the number of amplifications.\n  Does not work for infinite lists,\n  because in this case a maximum amplitude cannot be computed.\n",
          "module": "Synthesizer.Physical.Cut",
          "name": "concat",
          "package": "synthesizer",
          "signature": "[T t t' y y' yv] -\u003e T t t' y y' yv",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Physical-Cut.html#concat",
          "type": "function"
        },
        "index": {
          "description": "Similar to foldr1 append but more efficient and accurate because it reduces the number of amplifications Does not work for infinite lists because in this case maximum amplitude cannot be computed",
          "hierarchy": "Synthesizer Physical Cut",
          "module": "Synthesizer.Physical.Cut",
          "name": "concat",
          "normalized": "[T a b c d e]-\u003eT a b c d e",
          "package": "synthesizer",
          "signature": "[T t t' y y' yv]-\u003eT t t' y y' yv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Physical-Cut.html#v:concat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Like \u003ctt\u003e\u003ca\u003econcat\u003c/a\u003e\u003c/tt\u003e, but you have to specify the amplitude of the resulting signal.\n  This way we can process infinite lists, too.\n  The list must contain at least one element for getting a sample rate.\n",
          "module": "Synthesizer.Physical.Cut",
          "name": "concatVolume",
          "package": "synthesizer",
          "signature": "y' -\u003e [T t t' y y' yv] -\u003e T t t' y y' yv",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Physical-Cut.html#concatVolume",
          "type": "function"
        },
        "index": {
          "description": "Like concat but you have to specify the amplitude of the resulting signal This way we can process infinite lists too The list must contain at least one element for getting sample rate",
          "hierarchy": "Synthesizer Physical Cut",
          "module": "Synthesizer.Physical.Cut",
          "name": "concatVolume",
          "normalized": "a-\u003e[T b c d a e]-\u003eT b c d a e",
          "package": "synthesizer",
          "partial": "Volume",
          "signature": "y'-\u003e[T t t' y y' yv]-\u003eT t t' y y' yv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Physical-Cut.html#v:concatVolume"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Physical.Cut",
          "name": "drop",
          "package": "synthesizer",
          "signature": "t' -\u003e T t t' y y' yv -\u003e T t t' y y' yv",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Physical-Cut.html#drop",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Physical Cut",
          "module": "Synthesizer.Physical.Cut",
          "name": "drop",
          "normalized": "a-\u003eT b a c d e-\u003eT b a c d e",
          "package": "synthesizer",
          "signature": "t'-\u003eT t t' y y' yv-\u003eT t t' y y' yv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Physical-Cut.html#v:drop"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Physical.Cut",
          "name": "propAppendSplit",
          "package": "synthesizer",
          "signature": "t' -\u003e T t t' y y' yv -\u003e Bool",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Physical-Cut.html#propAppendSplit",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Physical Cut",
          "module": "Synthesizer.Physical.Cut",
          "name": "propAppendSplit",
          "normalized": "a-\u003eT b a c d e-\u003eBool",
          "package": "synthesizer",
          "partial": "Append Split",
          "signature": "t'-\u003eT t t' y y' yv-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Physical-Cut.html#v:propAppendSplit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Physical.Cut",
          "name": "propConcatAppend",
          "package": "synthesizer",
          "signature": "T t t' y y' yv -\u003e T t t' y y' yv -\u003e Bool",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Physical-Cut.html#propConcatAppend",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Physical Cut",
          "module": "Synthesizer.Physical.Cut",
          "name": "propConcatAppend",
          "normalized": "T a b c d e-\u003eT a b c d e-\u003eBool",
          "package": "synthesizer",
          "partial": "Concat Append",
          "signature": "T t t' y y' yv-\u003eT t t' y y' yv-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Physical-Cut.html#v:propConcatAppend"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Physical.Cut",
          "name": "propSplit",
          "package": "synthesizer",
          "signature": "t' -\u003e T t t' y y' yv -\u003e Bool",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Physical-Cut.html#propSplit",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Physical Cut",
          "module": "Synthesizer.Physical.Cut",
          "name": "propSplit",
          "normalized": "a-\u003eT b a c d e-\u003eBool",
          "package": "synthesizer",
          "partial": "Split",
          "signature": "t'-\u003eT t t' y y' yv-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Physical-Cut.html#v:propSplit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Physical.Cut",
          "name": "propZip",
          "package": "synthesizer",
          "signature": "T t t' y y' (yv0, yv1) -\u003e Bool",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Physical-Cut.html#propZip",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Physical Cut",
          "module": "Synthesizer.Physical.Cut",
          "name": "propZip",
          "normalized": "T a b c d(e,e)-\u003eBool",
          "package": "synthesizer",
          "partial": "Zip",
          "signature": "T t t' y y'(yv,yv)-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Physical-Cut.html#v:propZip"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Physical.Cut",
          "name": "propZip3",
          "package": "synthesizer",
          "signature": "T t t' y y' (yv0, yv1, yv2) -\u003e Bool",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Physical-Cut.html#propZip3",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Physical Cut",
          "module": "Synthesizer.Physical.Cut",
          "name": "propZip3",
          "normalized": "T a b c d(e,e,e)-\u003eBool",
          "package": "synthesizer",
          "partial": "Zip",
          "signature": "T t t' y y'(yv,yv,yv)-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Physical-Cut.html#v:propZip3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Physical.Cut",
          "name": "splitAt",
          "package": "synthesizer",
          "signature": "t' -\u003e T t t' y y' yv -\u003e (T t t' y y' yv, T t t' y y' yv)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Physical-Cut.html#splitAt",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Physical Cut",
          "module": "Synthesizer.Physical.Cut",
          "name": "splitAt",
          "normalized": "a-\u003eT b a c d e-\u003e(T b a c d e,T b a c d e)",
          "package": "synthesizer",
          "partial": "At",
          "signature": "t'-\u003eT t t' y y' yv-\u003e(T t t' y y' yv,T t t' y y' yv)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Physical-Cut.html#v:splitAt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Physical.Cut",
          "name": "splitSampleRateEventList",
          "package": "synthesizer",
          "signature": "T time (T t t' y y' yv) -\u003e (T t t', T time (T y y' yv))",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Physical-Cut.html#splitSampleRateEventList",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Physical Cut",
          "module": "Synthesizer.Physical.Cut",
          "name": "splitSampleRateEventList",
          "normalized": "T a(T b c d e f)-\u003e(T b c,T a(T d e f))",
          "package": "synthesizer",
          "partial": "Sample Rate Event List",
          "signature": "T time(T t t' y y' yv)-\u003e(T t t',T time(T y y' yv))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Physical-Cut.html#v:splitSampleRateEventList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Physical.Cut",
          "name": "take",
          "package": "synthesizer",
          "signature": "t' -\u003e T t t' y y' yv -\u003e T t t' y y' yv",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Physical-Cut.html#take",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Physical Cut",
          "module": "Synthesizer.Physical.Cut",
          "name": "take",
          "normalized": "a-\u003eT b a c d e-\u003eT b a c d e",
          "package": "synthesizer",
          "signature": "t'-\u003eT t t' y y' yv-\u003eT t t' y y' yv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Physical-Cut.html#v:take"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Physical.Cut",
          "name": "takeUntilPause",
          "package": "synthesizer",
          "signature": "y' -\u003e t' -\u003e T t t' y y' yv -\u003e T t t' y y' yv",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Physical-Cut.html#takeUntilPause",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Physical Cut",
          "module": "Synthesizer.Physical.Cut",
          "name": "takeUntilPause",
          "normalized": "a-\u003eb-\u003eT c b d a e-\u003eT c b d a e",
          "package": "synthesizer",
          "partial": "Until Pause",
          "signature": "y'-\u003et'-\u003eT t t' y y' yv-\u003eT t t' y y' yv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Physical-Cut.html#v:takeUntilPause"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Physical.Cut",
          "name": "unzip",
          "package": "synthesizer",
          "signature": "T t t' y y' (yv0, yv1) -\u003e (T t t' y y' yv0, T t t' y y' yv1)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Physical-Cut.html#unzip",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Physical Cut",
          "module": "Synthesizer.Physical.Cut",
          "name": "unzip",
          "normalized": "T a b c d(e,e)-\u003e(T a b c d e,T a b c d e)",
          "package": "synthesizer",
          "signature": "T t t' y y'(yv,yv)-\u003e(T t t' y y' yv,T t t' y y' yv)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Physical-Cut.html#v:unzip"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Physical.Cut",
          "name": "unzip3",
          "package": "synthesizer",
          "signature": "T t t' y y' (yv0, yv1, yv2) -\u003e (T t t' y y' yv0, T t t' y y' yv1, T t t' y y' yv2)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Physical-Cut.html#unzip3",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Physical Cut",
          "module": "Synthesizer.Physical.Cut",
          "name": "unzip3",
          "normalized": "T a b c d(e,e,e)-\u003e(T a b c d e,T a b c d e,T a b c d e)",
          "package": "synthesizer",
          "signature": "T t t' y y'(yv,yv,yv)-\u003e(T t t' y y' yv,T t t' y y' yv,T t t' y y' yv)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Physical-Cut.html#v:unzip3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Physical.Cut",
          "name": "zip",
          "package": "synthesizer",
          "signature": "T t t' y y' yv0 -\u003e T t t' y y' yv1 -\u003e T t t' y y' (yv0, yv1)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Physical-Cut.html#zip",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Physical Cut",
          "module": "Synthesizer.Physical.Cut",
          "name": "zip",
          "normalized": "T a b c d e-\u003eT a b c d e-\u003eT a b c d(e,e)",
          "package": "synthesizer",
          "signature": "T t t' y y' yv-\u003eT t t' y y' yv-\u003eT t t' y y'(yv,yv)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Physical-Cut.html#v:zip"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Physical.Cut",
          "name": "zip3",
          "package": "synthesizer",
          "signature": "T t t' y y' yv0 -\u003e T t t' y y' yv1 -\u003e T t t' y y' yv2 -\u003e T t t' y y' (yv0, yv1, yv2)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Physical-Cut.html#zip3",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Physical Cut",
          "module": "Synthesizer.Physical.Cut",
          "name": "zip3",
          "normalized": "T a b c d e-\u003eT a b c d e-\u003eT a b c d e-\u003eT a b c d(e,e,e)",
          "package": "synthesizer",
          "signature": "T t t' y y' yv-\u003eT t t' y y' yv-\u003eT t t' y y' yv-\u003eT t t' y y'(yv,yv,yv)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Physical-Cut.html#v:zip3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Mix two signals.\n    In opposition to \u003ctt\u003e\u003ca\u003ezipWith\u003c/a\u003e\u003c/tt\u003e the result has the length of the longer signal. \n",
          "module": "Synthesizer.Physical.Displacement",
          "name": "mix",
          "package": "synthesizer",
          "signature": "T t t' y y' yv -\u003e T t t' y y' yv -\u003e T t t' y y' yv",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Physical-Displacement.html#mix",
          "type": "function"
        },
        "index": {
          "description": "Mix two signals In opposition to zipWith the result has the length of the longer signal",
          "hierarchy": "Synthesizer Physical Displacement",
          "module": "Synthesizer.Physical.Displacement",
          "name": "mix",
          "normalized": "T a b c d e-\u003eT a b c d e-\u003eT a b c d e",
          "package": "synthesizer",
          "signature": "T t t' y y' yv-\u003eT t t' y y' yv-\u003eT t t' y y' yv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Physical-Displacement.html#v:mix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Mix one or more signals. \n",
          "module": "Synthesizer.Physical.Displacement",
          "name": "mixMulti",
          "package": "synthesizer",
          "signature": "[T t t' y y' yv] -\u003e T t t' y y' yv",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Physical-Displacement.html#mixMulti",
          "type": "function"
        },
        "index": {
          "description": "Mix one or more signals",
          "hierarchy": "Synthesizer Physical Displacement",
          "module": "Synthesizer.Physical.Displacement",
          "name": "mixMulti",
          "normalized": "[T a b c d e]-\u003eT a b c d e",
          "package": "synthesizer",
          "partial": "Multi",
          "signature": "[T t t' y y' yv]-\u003eT t t' y y' yv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Physical-Displacement.html#v:mixMulti"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Add a number to all of the signal values.\n    This is useful for adjusting the center of a modulation. \n",
          "module": "Synthesizer.Physical.Displacement",
          "name": "raise",
          "package": "synthesizer",
          "signature": "y' -\u003e yv -\u003e T t t' y y' yv -\u003e T t t' y y' yv",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Physical-Displacement.html#raise",
          "type": "function"
        },
        "index": {
          "description": "Add number to all of the signal values This is useful for adjusting the center of modulation",
          "hierarchy": "Synthesizer Physical Displacement",
          "module": "Synthesizer.Physical.Displacement",
          "name": "raise",
          "normalized": "a-\u003eb-\u003eT c d e a b-\u003eT c d e a b",
          "package": "synthesizer",
          "signature": "y'-\u003eyv-\u003eT t t' y y' yv-\u003eT t t' y y' yv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Physical-Displacement.html#v:raise"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Physical.File",
          "name": "writeToInt16",
          "package": "synthesizer",
          "signature": "t' -\u003e y' -\u003e FilePath -\u003e T t t' y y' yv -\u003e IO ExitCode",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Physical-File.html#writeToInt16",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Physical File",
          "module": "Synthesizer.Physical.File",
          "name": "writeToInt16",
          "normalized": "a-\u003eb-\u003eFilePath-\u003eT c a d b e-\u003eIO ExitCode",
          "package": "synthesizer",
          "partial": "To Int",
          "signature": "t'-\u003ey'-\u003eFilePath-\u003eT t t' y y' yv-\u003eIO ExitCode",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Physical-File.html#v:writeToInt16"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Physical.Filter",
          "name": "amplify",
          "package": "synthesizer",
          "signature": "y' -\u003e T t t' y y' yv -\u003e T t t' y y' yv",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Physical-Filter.html#amplify",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Physical Filter",
          "module": "Synthesizer.Physical.Filter",
          "name": "amplify",
          "normalized": "a-\u003eT b c d a e-\u003eT b c d a e",
          "package": "synthesizer",
          "signature": "y'-\u003eT t t' y y' yv-\u003eT t t' y y' yv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Physical-Filter.html#v:amplify"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Infinitely many equi-delayed exponentially decaying echos. \n",
          "module": "Synthesizer.Physical.Filter",
          "name": "comb",
          "package": "synthesizer",
          "signature": "t' -\u003e y -\u003e T t t' y y' yv -\u003e T t t' y y' yv",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Physical-Filter.html#comb",
          "type": "function"
        },
        "index": {
          "description": "Infinitely many equi-delayed exponentially decaying echos",
          "hierarchy": "Synthesizer Physical Filter",
          "module": "Synthesizer.Physical.Filter",
          "name": "comb",
          "normalized": "a-\u003eb-\u003eT c a b d e-\u003eT c a b d e",
          "package": "synthesizer",
          "signature": "t'-\u003ey-\u003eT t t' y y' yv-\u003eT t t' y y' yv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Physical-Filter.html#v:comb"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Physical.Filter",
          "name": "differentiate",
          "package": "synthesizer",
          "signature": "T t a' y a' yv -\u003e T t a' y a' yv",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Physical-Filter.html#differentiate",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Physical Filter",
          "module": "Synthesizer.Physical.Filter",
          "name": "differentiate",
          "normalized": "T a b c b d-\u003eT a b c b d",
          "package": "synthesizer",
          "signature": "T t a' y a' yv-\u003eT t a' y a' yv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Physical-Filter.html#v:differentiate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "the envelope \nthe signal to be enveloped \n",
          "module": "Synthesizer.Physical.Filter",
          "name": "envelope",
          "package": "synthesizer",
          "signature": "T t t' y y' y0-\u003e T t t' y y' yv-\u003e T t t' y y' yv",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Physical-Filter.html#envelope",
          "type": "function"
        },
        "index": {
          "description": "the envelope the signal to be enveloped",
          "hierarchy": "Synthesizer Physical Filter",
          "module": "Synthesizer.Physical.Filter",
          "name": "envelope",
          "normalized": "T a b c d c-\u003eT a b c d e-\u003eT a b c d e",
          "package": "synthesizer",
          "signature": "T t t' y y' y-\u003eT t t' y y' yv-\u003eT t t' y y' yv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Physical-Filter.html#v:envelope"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Physical.Filter",
          "name": "integrate",
          "package": "synthesizer",
          "signature": "T t a' y a' yv -\u003e T t a' y a' yv",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Physical-Filter.html#integrate",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Physical Filter",
          "module": "Synthesizer.Physical.Filter",
          "name": "integrate",
          "normalized": "T a b c b d-\u003eT a b c b d",
          "package": "synthesizer",
          "signature": "T t a' y a' yv-\u003eT t a' y a' yv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Physical-Filter.html#v:integrate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "sample rate \nwidth of the frequency band \nvolume caused by the given frequency band \nnoise \n",
          "module": "Synthesizer.Physical.Noise",
          "name": "white",
          "package": "synthesizer",
          "signature": "q'-\u003e q'-\u003e q'-\u003e T t q' y q' yv",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Physical-Noise.html#white",
          "type": "function"
        },
        "index": {
          "description": "sample rate width of the frequency band volume caused by the given frequency band noise",
          "hierarchy": "Synthesizer Physical Noise",
          "module": "Synthesizer.Physical.Noise",
          "name": "white",
          "normalized": "a-\u003ea-\u003ea-\u003eT b a c a d",
          "package": "synthesizer",
          "signature": "q'-\u003eq'-\u003eq'-\u003eT t q' y q' yv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Physical-Noise.html#v:white"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "oscillator with a functional waveform with modulated frequency \n",
          "module": "Synthesizer.Physical.Oscillator",
          "name": "freqMod",
          "package": "synthesizer",
          "signature": "T t yv -\u003e y' -\u003e t -\u003e T t t' t t' t -\u003e T t t' y y' yv",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Physical-Oscillator.html#freqMod",
          "type": "function"
        },
        "index": {
          "description": "oscillator with functional waveform with modulated frequency",
          "hierarchy": "Synthesizer Physical Oscillator",
          "module": "Synthesizer.Physical.Oscillator",
          "name": "freqMod",
          "normalized": "T a b-\u003ec-\u003ea-\u003eT a d a d a-\u003eT a d e c b",
          "package": "synthesizer",
          "partial": "Mod",
          "signature": "T t yv-\u003ey'-\u003et-\u003eT t t' t t' t-\u003eT t t' y y' yv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Physical-Oscillator.html#v:freqMod"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "saw tooth oscillator with modulated frequency \n",
          "module": "Synthesizer.Physical.Oscillator",
          "name": "freqModSaw",
          "package": "synthesizer",
          "signature": "y' -\u003e a -\u003e T a t' a t' a -\u003e T a t' a y' a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Physical-Oscillator.html#freqModSaw",
          "type": "function"
        },
        "index": {
          "description": "saw tooth oscillator with modulated frequency",
          "hierarchy": "Synthesizer Physical Oscillator",
          "module": "Synthesizer.Physical.Oscillator",
          "name": "freqModSaw",
          "normalized": "a-\u003eb-\u003eT b c b c b-\u003eT b c b a b",
          "package": "synthesizer",
          "partial": "Mod Saw",
          "signature": "y'-\u003ea-\u003eT a t' a t' a-\u003eT a t' a y' a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Physical-Oscillator.html#v:freqModSaw"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "sine oscillator with modulated frequency \n",
          "module": "Synthesizer.Physical.Oscillator",
          "name": "freqModSine",
          "package": "synthesizer",
          "signature": "y' -\u003e a -\u003e T a t' a t' a -\u003e T a t' a y' a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Physical-Oscillator.html#freqModSine",
          "type": "function"
        },
        "index": {
          "description": "sine oscillator with modulated frequency",
          "hierarchy": "Synthesizer Physical Oscillator",
          "module": "Synthesizer.Physical.Oscillator",
          "name": "freqModSine",
          "normalized": "a-\u003eb-\u003eT b c b c b-\u003eT b c b a b",
          "package": "synthesizer",
          "partial": "Mod Sine",
          "signature": "y'-\u003ea-\u003eT a t' a t' a-\u003eT a t' a y' a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Physical-Oscillator.html#v:freqModSine"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "oscillator with a functional waveform with constant frequency \n",
          "module": "Synthesizer.Physical.Oscillator",
          "name": "static",
          "package": "synthesizer",
          "signature": "T t yv -\u003e t' -\u003e y' -\u003e t -\u003e t' -\u003e T t t' y y' yv",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Physical-Oscillator.html#static",
          "type": "function"
        },
        "index": {
          "description": "oscillator with functional waveform with constant frequency",
          "hierarchy": "Synthesizer Physical Oscillator",
          "module": "Synthesizer.Physical.Oscillator",
          "name": "static",
          "normalized": "T a b-\u003ec-\u003ed-\u003ea-\u003ec-\u003eT a c e d b",
          "package": "synthesizer",
          "signature": "T t yv-\u003et'-\u003ey'-\u003et-\u003et'-\u003eT t t' y y' yv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Physical-Oscillator.html#v:static"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "saw tooth oscillator with modulated frequency \n",
          "module": "Synthesizer.Physical.Oscillator",
          "name": "staticSaw",
          "package": "synthesizer",
          "signature": "t' -\u003e y' -\u003e a -\u003e t' -\u003e T a t' a y' a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Physical-Oscillator.html#staticSaw",
          "type": "function"
        },
        "index": {
          "description": "saw tooth oscillator with modulated frequency",
          "hierarchy": "Synthesizer Physical Oscillator",
          "module": "Synthesizer.Physical.Oscillator",
          "name": "staticSaw",
          "normalized": "a-\u003eb-\u003ec-\u003ea-\u003eT c a c b c",
          "package": "synthesizer",
          "partial": "Saw",
          "signature": "t'-\u003ey'-\u003ea-\u003et'-\u003eT a t' a y' a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Physical-Oscillator.html#v:staticSaw"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "sine oscillator with static frequency \n",
          "module": "Synthesizer.Physical.Oscillator",
          "name": "staticSine",
          "package": "synthesizer",
          "signature": "t' -\u003e y' -\u003e a -\u003e t' -\u003e T a t' a y' a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Physical-Oscillator.html#staticSine",
          "type": "function"
        },
        "index": {
          "description": "sine oscillator with static frequency",
          "hierarchy": "Synthesizer Physical Oscillator",
          "module": "Synthesizer.Physical.Oscillator",
          "name": "staticSine",
          "normalized": "a-\u003eb-\u003ec-\u003ea-\u003eT c a c b c",
          "package": "synthesizer",
          "partial": "Sine",
          "signature": "t'-\u003ey'-\u003ea-\u003et'-\u003eT a t' a y' a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Physical-Oscillator.html#v:staticSine"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Physical.Play",
          "name": "toInt16",
          "package": "synthesizer",
          "signature": "t' -\u003e y' -\u003e T t t' y y' yv -\u003e IO ExitCode",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Physical-Play.html#toInt16",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Physical Play",
          "module": "Synthesizer.Physical.Play",
          "name": "toInt16",
          "normalized": "a-\u003eb-\u003eT c a d b e-\u003eIO ExitCode",
          "package": "synthesizer",
          "partial": "Int",
          "signature": "t'-\u003ey'-\u003eT t t' y y' yv-\u003eIO ExitCode",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Physical-Play.html#v:toInt16"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Physical.Signal",
          "name": "T",
          "package": "synthesizer",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Physical-Signal.html#T",
          "type": "data"
        },
        "index": {
          "hierarchy": "Synthesizer Physical Signal",
          "module": "Synthesizer.Physical.Signal",
          "name": "T",
          "package": "synthesizer",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Physical-Signal.html#t:T"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Physical.Signal",
          "name": "addPlainSampleRate",
          "package": "synthesizer",
          "signature": "t' -\u003e T y y' yv -\u003e T t t' y y' yv",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Physical-Signal.html#addPlainSampleRate",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Physical Signal",
          "module": "Synthesizer.Physical.Signal",
          "name": "addPlainSampleRate",
          "normalized": "a-\u003eT b c d-\u003eT e a b c d",
          "package": "synthesizer",
          "partial": "Plain Sample Rate",
          "signature": "t'-\u003eT y y' yv-\u003eT t t' y y' yv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Physical-Signal.html#v:addPlainSampleRate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Physical.Signal",
          "name": "addSampleRate",
          "package": "synthesizer",
          "signature": "T t t' -\u003e T y y' yv -\u003e T t t' y y' yv",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Physical-Signal.html#addSampleRate",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Physical Signal",
          "module": "Synthesizer.Physical.Signal",
          "name": "addSampleRate",
          "normalized": "T a b-\u003eT c d e-\u003eT a b c d e",
          "package": "synthesizer",
          "partial": "Sample Rate",
          "signature": "T t t'-\u003eT y y' yv-\u003eT t t' y y' yv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Physical-Signal.html#v:addSampleRate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Physical.Signal",
          "name": "amplitude",
          "package": "synthesizer",
          "signature": "T t t' y y' yv -\u003e y'",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Physical-Signal.html#amplitude",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Physical Signal",
          "module": "Synthesizer.Physical.Signal",
          "name": "amplitude",
          "normalized": "T a b c d e-\u003ed",
          "package": "synthesizer",
          "signature": "T t t' y y' yv-\u003ey'",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Physical-Signal.html#v:amplitude"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Physical.Signal",
          "name": "apply",
          "package": "synthesizer",
          "signature": "(T t t' -\u003e T y0 y'0 y0v -\u003e T y1 y'1 y1v) -\u003e T t t' y0 y'0 y0v -\u003e T t t' y1 y'1 y1v",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Physical-Signal.html#apply",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Physical Signal",
          "module": "Synthesizer.Physical.Signal",
          "name": "apply",
          "normalized": "(T a b-\u003eT c d c e-\u003eT c d c e)-\u003eT a b c d c e-\u003eT a b c d c e",
          "package": "synthesizer",
          "signature": "(T t t'-\u003eT y y' y v-\u003eT y y' y v)-\u003eT t t' y y' y v-\u003eT t t' y y' y v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Physical-Signal.html#v:apply"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Fix the type of a value to the scalar amplitude type of a signal. \n",
          "module": "Synthesizer.Physical.Signal",
          "name": "asTypeOfAmplitude",
          "package": "synthesizer",
          "signature": "y -\u003e T t t' y y' yv -\u003e y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Physical-Signal.html#asTypeOfAmplitude",
          "type": "function"
        },
        "index": {
          "description": "Fix the type of value to the scalar amplitude type of signal",
          "hierarchy": "Synthesizer Physical Signal",
          "module": "Synthesizer.Physical.Signal",
          "name": "asTypeOfAmplitude",
          "normalized": "a-\u003eT b c a d e-\u003ea",
          "package": "synthesizer",
          "partial": "Type Of Amplitude",
          "signature": "y-\u003eT t t' y y' yv-\u003ey",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Physical-Signal.html#v:asTypeOfAmplitude"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "time value, of with a type to be fixed \nsignal, whose time type shall be matched \nthe time value, again \n",
          "module": "Synthesizer.Physical.Signal",
          "name": "asTypeOfTime",
          "package": "synthesizer",
          "signature": "t-\u003e T t t' y y' yv-\u003e t",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Physical-Signal.html#asTypeOfTime",
          "type": "function"
        },
        "index": {
          "description": "time value of with type to be fixed signal whose time type shall be matched the time value again",
          "hierarchy": "Synthesizer Physical Signal",
          "module": "Synthesizer.Physical.Signal",
          "name": "asTypeOfTime",
          "normalized": "a-\u003eT a b c d e-\u003ea",
          "package": "synthesizer",
          "partial": "Type Of Time",
          "signature": "t-\u003eT t t' y y' yv-\u003et",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Physical-Signal.html#v:asTypeOfTime"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Assert a condition before shipping the first sample.\n",
          "module": "Synthesizer.Physical.Signal",
          "name": "assert",
          "package": "synthesizer",
          "signature": "String -\u003e Bool -\u003e T t t' y y' yv -\u003e T t t' y y' yv",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Physical-Signal.html#assert",
          "type": "function"
        },
        "index": {
          "description": "Assert condition before shipping the first sample",
          "hierarchy": "Synthesizer Physical Signal",
          "module": "Synthesizer.Physical.Signal",
          "name": "assert",
          "normalized": "String-\u003eBool-\u003eT a b c d e-\u003eT a b c d e",
          "package": "synthesizer",
          "signature": "String-\u003eBool-\u003eT t t' y y' yv-\u003eT t t' y y' yv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Physical-Signal.html#v:assert"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Assert that the amplitude of the signal matches the given one.\nOtherwise give an error when the first sample is fetched.\n",
          "module": "Synthesizer.Physical.Signal",
          "name": "assertAmplitude",
          "package": "synthesizer",
          "signature": "y' -\u003e T t t' y y' yv -\u003e T t t' y y' yv",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Physical-Signal.html#assertAmplitude",
          "type": "function"
        },
        "index": {
          "description": "Assert that the amplitude of the signal matches the given one Otherwise give an error when the first sample is fetched",
          "hierarchy": "Synthesizer Physical Signal",
          "module": "Synthesizer.Physical.Signal",
          "name": "assertAmplitude",
          "normalized": "a-\u003eT b c d a e-\u003eT b c d a e",
          "package": "synthesizer",
          "partial": "Amplitude",
          "signature": "y'-\u003eT t t' y y' yv-\u003eT t t' y y' yv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Physical-Signal.html#v:assertAmplitude"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Assert that the sample rate of the signal matches the given one.\n",
          "module": "Synthesizer.Physical.Signal",
          "name": "assertSampleRate",
          "package": "synthesizer",
          "signature": "t' -\u003e T t t' y y' yv -\u003e T t t' y y' yv",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Physical-Signal.html#assertSampleRate",
          "type": "function"
        },
        "index": {
          "description": "Assert that the sample rate of the signal matches the given one",
          "hierarchy": "Synthesizer Physical Signal",
          "module": "Synthesizer.Physical.Signal",
          "name": "assertSampleRate",
          "normalized": "a-\u003eT b a c d e-\u003eT b a c d e",
          "package": "synthesizer",
          "partial": "Sample Rate",
          "signature": "t'-\u003eT t t' y y' yv-\u003eT t t' y y' yv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Physical-Signal.html#v:assertSampleRate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "If the given sample rate matches the one of the signal,\nthen return the core signal, otherwise \u003ctt\u003e\u003ca\u003eundefined\u003c/a\u003e\u003c/tt\u003e.\n",
          "module": "Synthesizer.Physical.Signal",
          "name": "checkSampleRate",
          "package": "synthesizer",
          "signature": "String -\u003e T t t' -\u003e T t t' y y' yv -\u003e T y y' yv",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Physical-Signal.html#checkSampleRate",
          "type": "function"
        },
        "index": {
          "description": "If the given sample rate matches the one of the signal then return the core signal otherwise undefined",
          "hierarchy": "Synthesizer Physical Signal",
          "module": "Synthesizer.Physical.Signal",
          "name": "checkSampleRate",
          "normalized": "String-\u003eT a b-\u003eT a b c d e-\u003eT c d e",
          "package": "synthesizer",
          "partial": "Sample Rate",
          "signature": "String-\u003eT t t'-\u003eT t t' y y' yv-\u003eT y y' yv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Physical-Signal.html#v:checkSampleRate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "If all signals share the same sampleRate, then return it,\n    otherwise raise an error. \n",
          "module": "Synthesizer.Physical.Signal",
          "name": "commonSampleRate",
          "package": "synthesizer",
          "signature": "T t t' y0 y'0 yv0 -\u003e T t t' y1 y'1 yv1 -\u003e t'",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Physical-Signal.html#commonSampleRate",
          "type": "function"
        },
        "index": {
          "description": "If all signals share the same sampleRate then return it otherwise raise an error",
          "hierarchy": "Synthesizer Physical Signal",
          "module": "Synthesizer.Physical.Signal",
          "name": "commonSampleRate",
          "normalized": "T a b c d e-\u003eT a b c d e-\u003eb",
          "package": "synthesizer",
          "partial": "Sample Rate",
          "signature": "T t t' y y' yv-\u003eT t t' y y' yv-\u003et'",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Physical-Signal.html#v:commonSampleRate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Physical.Signal",
          "name": "commonSampleRate'",
          "package": "synthesizer",
          "signature": "a -\u003e a -\u003e a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Physical-Signal.html#commonSampleRate%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Physical Signal",
          "module": "Synthesizer.Physical.Signal",
          "name": "commonSampleRate'",
          "normalized": "a-\u003ea-\u003ea",
          "package": "synthesizer",
          "partial": "Sample Rate'",
          "signature": "a-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Physical-Signal.html#v:commonSampleRate'"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "sampling rate, must be positive (unchecked) \namplitude, must be positive (unchecked) \nsamples, values should be between -1 and 1 (unchecked) \n",
          "module": "Synthesizer.Physical.Signal",
          "name": "cons",
          "package": "synthesizer",
          "signature": "t'-\u003e y'-\u003e [yv]-\u003e T t t' y y' yv",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Physical-Signal.html#cons",
          "type": "function"
        },
        "index": {
          "description": "sampling rate must be positive unchecked amplitude must be positive unchecked samples values should be between and unchecked",
          "hierarchy": "Synthesizer Physical Signal",
          "module": "Synthesizer.Physical.Signal",
          "name": "cons",
          "normalized": "a-\u003eb-\u003e[c]-\u003eT d a e b c",
          "package": "synthesizer",
          "signature": "t'-\u003ey'-\u003e[yv]-\u003eT t t' y y' yv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Physical-Signal.html#v:cons"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Physical.Signal",
          "name": "lift0",
          "package": "synthesizer",
          "signature": "(T t t' -\u003e T y y' yv) -\u003e t' -\u003e T t t' y y' yv",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Physical-Signal.html#lift0",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Physical Signal",
          "module": "Synthesizer.Physical.Signal",
          "name": "lift0",
          "normalized": "(T a b-\u003eT c d e)-\u003eb-\u003eT a b c d e",
          "package": "synthesizer",
          "signature": "(T t t'-\u003eT y y' yv)-\u003et'-\u003eT t t' y y' yv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Physical-Signal.html#v:lift0"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Physical.Signal",
          "name": "lift1",
          "package": "synthesizer",
          "signature": "(T t t' -\u003e T y0 y0' yv0 -\u003e T y1 y1' yv1) -\u003e T t t' y0 y0' yv0 -\u003e T t t' y1 y1' yv1",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Physical-Signal.html#lift1",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Physical Signal",
          "module": "Synthesizer.Physical.Signal",
          "name": "lift1",
          "normalized": "(T a b-\u003eT c c d-\u003eT c c d)-\u003eT a b c c d-\u003eT a b c c d",
          "package": "synthesizer",
          "signature": "(T t t'-\u003eT y y yv-\u003eT y y yv)-\u003eT t t' y y yv-\u003eT t t' y y yv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Physical-Signal.html#v:lift1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Physical.Signal",
          "name": "lift2",
          "package": "synthesizer",
          "signature": "(T t t' -\u003e T y0 y'0 yv0 -\u003e T y1 y'1 yv1 -\u003e T y2 y'2 yv2) -\u003e T t t' y0 y'0 yv0 -\u003e T t t' y1 y'1 yv1 -\u003e T t t' y2 y'2 yv2",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Physical-Signal.html#lift2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Physical Signal",
          "module": "Synthesizer.Physical.Signal",
          "name": "lift2",
          "normalized": "(T a b-\u003eT c d e-\u003eT c d e-\u003eT c d e)-\u003eT a b c d e-\u003eT a b c d e-\u003eT a b c d e",
          "package": "synthesizer",
          "signature": "(T t t'-\u003eT y y' yv-\u003eT y y' yv-\u003eT y y' yv)-\u003eT t t' y y' yv-\u003eT t t' y y' yv-\u003eT t t' y y' yv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Physical-Signal.html#v:lift2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Physical.Signal",
          "name": "lift3",
          "package": "synthesizer",
          "signature": "(T t t' -\u003e T y0 y'0 yv0 -\u003e T y1 y'1 yv1 -\u003e T y2 y'2 yv2 -\u003e T y3 y'3 yv3) -\u003e T t t' y0 y'0 yv0 -\u003e T t t' y1 y'1 yv1 -\u003e T t t' y2 y'2 yv2 -\u003e T t t' y3 y'3 yv3",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Physical-Signal.html#lift3",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Physical Signal",
          "module": "Synthesizer.Physical.Signal",
          "name": "lift3",
          "normalized": "(T a b-\u003eT c d e-\u003eT c d e-\u003eT c d e-\u003eT c d e)-\u003eT a b c d e-\u003eT a b c d e-\u003eT a b c d e-\u003eT a b c d e",
          "package": "synthesizer",
          "signature": "(T t t'-\u003eT y y' yv-\u003eT y y' yv-\u003eT y y' yv-\u003eT y y' yv)-\u003eT t t' y y' yv-\u003eT t t' y y' yv-\u003eT t t' y y' yv-\u003eT t t' y y' yv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Physical-Signal.html#v:lift3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Physical.Signal",
          "name": "liftList",
          "package": "synthesizer",
          "signature": "(T t t' -\u003e [T y1 y'1 yv1] -\u003e T y y' yv) -\u003e [T t t' y1 y'1 yv1] -\u003e T t t' y y' yv",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Physical-Signal.html#liftList",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Physical Signal",
          "module": "Synthesizer.Physical.Signal",
          "name": "liftList",
          "normalized": "(T a b-\u003e[T c d e]-\u003eT c d e)-\u003e[T a b c d e]-\u003eT a b c d e",
          "package": "synthesizer",
          "partial": "List",
          "signature": "(T t t'-\u003e[T y y' yv]-\u003eT y y' yv)-\u003e[T t t' y y' yv]-\u003eT t t' y y' yv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Physical-Signal.html#v:liftList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Physical.Signal",
          "name": "liftR2",
          "package": "synthesizer",
          "signature": "(T t t' -\u003e T y y' yv -\u003e (T y0 y'0 yv0, T y1 y'1 yv1)) -\u003e T t t' y y' yv -\u003e (T t t' y0 y'0 yv0, T t t' y1 y'1 yv1)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Physical-Signal.html#liftR2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Physical Signal",
          "module": "Synthesizer.Physical.Signal",
          "name": "liftR2",
          "normalized": "(T a b-\u003eT c d e-\u003e(T c d e,T c d e))-\u003eT a b c d e-\u003e(T a b c d e,T a b c d e)",
          "package": "synthesizer",
          "signature": "(T t t'-\u003eT y y' yv-\u003e(T y y' yv,T y y' yv))-\u003eT t t' y y' yv-\u003e(T t t' y y' yv,T t t' y y' yv)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Physical-Signal.html#v:liftR2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Physical.Signal",
          "name": "liftR3",
          "package": "synthesizer",
          "signature": "(T t t' -\u003e T y y' yv -\u003e (T y0 y'0 yv0, T y1 y'1 yv1, T y2 y'2 yv2)) -\u003e T t t' y y' yv -\u003e (T t t' y0 y'0 yv0, T t t' y1 y'1 yv1, T t t' y2 y'2 yv2)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Physical-Signal.html#liftR3",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Physical Signal",
          "module": "Synthesizer.Physical.Signal",
          "name": "liftR3",
          "normalized": "(T a b-\u003eT c d e-\u003e(T c d e,T c d e,T c d e))-\u003eT a b c d e-\u003e(T a b c d e,T a b c d e,T a b c d e)",
          "package": "synthesizer",
          "signature": "(T t t'-\u003eT y y' yv-\u003e(T y y' yv,T y y' yv,T y y' yv))-\u003eT t t' y y' yv-\u003e(T t t' y y' yv,T t t' y y' yv,T t t' y y' yv)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Physical-Signal.html#v:liftR3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "The unit of the sampling frequency, say Number.SI.hertz \nThe maximum expected value.\n               The data is normalized to this value,\n               in order to preserve that all output samples\n               are at most 1 in magnitude. \nThe input signal. \nThe sampling frequency without unit and\n               the list of normalized samples.\n               This information should suffice for playback\n               or writing the signal to a file. \n",
          "module": "Synthesizer.Physical.Signal",
          "name": "pureData",
          "package": "synthesizer",
          "signature": "t'-\u003e y'-\u003e T t t' y y' yv-\u003e (t, [yv])",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Physical-Signal.html#pureData",
          "type": "function"
        },
        "index": {
          "description": "The unit of the sampling frequency say Number.SI.hertz The maximum expected value The data is normalized to this value in order to preserve that all output samples are at most in magnitude The input signal The sampling frequency without unit and the list of normalized samples This information should suffice for playback or writing the signal to file",
          "hierarchy": "Synthesizer Physical Signal",
          "module": "Synthesizer.Physical.Signal",
          "name": "pureData",
          "normalized": "a-\u003eb-\u003eT c a d b e-\u003e(c,[e])",
          "package": "synthesizer",
          "partial": "Data",
          "signature": "t'-\u003ey'-\u003eT t t' y y' yv-\u003e(t,[yv])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Physical-Signal.html#v:pureData"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Physical.Signal",
          "name": "replaceAmplitude",
          "package": "synthesizer",
          "signature": "y1' -\u003e T t t' y y0' yv -\u003e T t t' y y1' yv",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Physical-Signal.html#replaceAmplitude",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Physical Signal",
          "module": "Synthesizer.Physical.Signal",
          "name": "replaceAmplitude",
          "normalized": "a-\u003eT b c a a d-\u003eT b c a a d",
          "package": "synthesizer",
          "partial": "Amplitude",
          "signature": "y-\u003eT t t' y y yv-\u003eT t t' y y yv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Physical-Signal.html#v:replaceAmplitude"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Replace sample rate and amplitude\nwith different representations of their values.\nThis is needed for internal purposes,\nespecially for preserving the phantom types.\nDo not use it for arbitrary changes of sample rate or amplitude!\n",
          "module": "Synthesizer.Physical.Signal",
          "name": "replaceParameters",
          "package": "synthesizer",
          "signature": "t1' -\u003e y1' -\u003e T t t0' y y0' yv -\u003e T t t1' y y1' yv",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Physical-Signal.html#replaceParameters",
          "type": "function"
        },
        "index": {
          "description": "Replace sample rate and amplitude with different representations of their values This is needed for internal purposes especially for preserving the phantom types Do not use it for arbitrary changes of sample rate or amplitude",
          "hierarchy": "Synthesizer Physical Signal",
          "module": "Synthesizer.Physical.Signal",
          "name": "replaceParameters",
          "normalized": "a-\u003eb-\u003eT a a b b c-\u003eT a a b b c",
          "package": "synthesizer",
          "partial": "Parameters",
          "signature": "t-\u003ey-\u003eT t t y y yv-\u003eT t t y y yv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Physical-Signal.html#v:replaceParameters"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Physical.Signal",
          "name": "replaceSampleRate",
          "package": "synthesizer",
          "signature": "t1' -\u003e T t t0' y y' yv -\u003e T t t1' y y' yv",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Physical-Signal.html#replaceSampleRate",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Physical Signal",
          "module": "Synthesizer.Physical.Signal",
          "name": "replaceSampleRate",
          "normalized": "a-\u003eT a a b c d-\u003eT a a b c d",
          "package": "synthesizer",
          "partial": "Sample Rate",
          "signature": "t-\u003eT t t y y' yv-\u003eT t t y y' yv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Physical-Signal.html#v:replaceSampleRate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Physical.Signal",
          "name": "replaceSamples",
          "package": "synthesizer",
          "signature": "[yv1] -\u003e T t t' y y' yv0 -\u003e T t t' y y' yv1",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Physical-Signal.html#replaceSamples",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Physical Signal",
          "module": "Synthesizer.Physical.Signal",
          "name": "replaceSamples",
          "normalized": "[a]-\u003eT b c d e a-\u003eT b c d e a",
          "package": "synthesizer",
          "partial": "Samples",
          "signature": "[yv]-\u003eT t t' y y' yv-\u003eT t t' y y' yv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Physical-Signal.html#v:replaceSamples"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Physical.Signal",
          "name": "run",
          "package": "synthesizer",
          "signature": "T t t' -\u003e (T t t' -\u003e T y y' yv) -\u003e T t t' y y' yv",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Physical-Signal.html#run",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Physical Signal",
          "module": "Synthesizer.Physical.Signal",
          "name": "run",
          "normalized": "T a b-\u003e(T a b-\u003eT c d e)-\u003eT a b c d e",
          "package": "synthesizer",
          "signature": "T t t'-\u003e(T t t'-\u003eT y y' yv)-\u003eT t t' y y' yv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Physical-Signal.html#v:run"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Physical.Signal",
          "name": "runPlain",
          "package": "synthesizer",
          "signature": "t' -\u003e (T t t' -\u003e T y y' yv) -\u003e T t t' y y' yv",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Physical-Signal.html#runPlain",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Physical Signal",
          "module": "Synthesizer.Physical.Signal",
          "name": "runPlain",
          "normalized": "a-\u003e(T b a-\u003eT c d e)-\u003eT b a c d e",
          "package": "synthesizer",
          "partial": "Plain",
          "signature": "t'-\u003e(T t t'-\u003eT y y' yv)-\u003eT t t' y y' yv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Physical-Signal.html#v:runPlain"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Physical.Signal",
          "name": "sampleRate",
          "package": "synthesizer",
          "signature": "T t t' y y' yv -\u003e t'",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Physical-Signal.html#sampleRate",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Physical Signal",
          "module": "Synthesizer.Physical.Signal",
          "name": "sampleRate",
          "normalized": "T a b c d e-\u003eb",
          "package": "synthesizer",
          "partial": "Rate",
          "signature": "T t t' y y' yv-\u003et'",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Physical-Signal.html#v:sampleRate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Physical.Signal",
          "name": "samples",
          "package": "synthesizer",
          "signature": "T t t' y y' yv -\u003e [yv]",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Physical-Signal.html#samples",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Physical Signal",
          "module": "Synthesizer.Physical.Signal",
          "name": "samples",
          "normalized": "T a b c d e-\u003e[e]",
          "package": "synthesizer",
          "signature": "T t t' y y' yv-\u003e[yv]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Physical-Signal.html#v:samples"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Physical.Signal",
          "name": "splitSampleRate",
          "package": "synthesizer",
          "signature": "T t t' y y' yv -\u003e (T t t', T y y' yv)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Physical-Signal.html#splitSampleRate",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Physical Signal",
          "module": "Synthesizer.Physical.Signal",
          "name": "splitSampleRate",
          "normalized": "T a b c d e-\u003e(T a b,T c d e)",
          "package": "synthesizer",
          "partial": "Sample Rate",
          "signature": "T t t' y y' yv-\u003e(T t t',T y y' yv)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Physical-Signal.html#v:splitSampleRate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Physical.Signal",
          "name": "splitSampleRateList",
          "package": "synthesizer",
          "signature": "[T t t' y y' yv] -\u003e (T t t', [T y y' yv])",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Physical-Signal.html#splitSampleRateList",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Physical Signal",
          "module": "Synthesizer.Physical.Signal",
          "name": "splitSampleRateList",
          "normalized": "[T a b c d e]-\u003e(T a b,[T c d e])",
          "package": "synthesizer",
          "partial": "Sample Rate List",
          "signature": "[T t t' y y' yv]-\u003e(T t t',[T y y' yv])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Physical-Signal.html#v:splitSampleRateList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Express an amplitude value as a multiple of the signal amplitude.\n     The multiplicity is returned.\n     It is a checked error,\n     if the units of amplitude value and signal amplitude mismatch. \n",
          "module": "Synthesizer.Physical.Signal",
          "name": "toAmplitudeScalar",
          "package": "synthesizer",
          "signature": "T t t' y y' yv -\u003e y' -\u003e y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Physical-Signal.html#toAmplitudeScalar",
          "type": "function"
        },
        "index": {
          "description": "Express an amplitude value as multiple of the signal amplitude The multiplicity is returned It is checked error if the units of amplitude value and signal amplitude mismatch",
          "hierarchy": "Synthesizer Physical Signal",
          "module": "Synthesizer.Physical.Signal",
          "name": "toAmplitudeScalar",
          "normalized": "T a b c d e-\u003ed-\u003ec",
          "package": "synthesizer",
          "partial": "Amplitude Scalar",
          "signature": "T t t' y y' yv-\u003ey'-\u003ey",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Physical-Signal.html#v:toAmplitudeScalar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Express a frequency value as a multiple of the sampling frequency.\n     The multiplicity is returned.\n     In many applications the multiplicity is below 1.\n     It is a checked error,\n     if the units of frequency value and sampling frequency mismatch. \n",
          "module": "Synthesizer.Physical.Signal",
          "name": "toFrequencyScalar",
          "package": "synthesizer",
          "signature": "T t t' y y' yv -\u003e t' -\u003e t",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Physical-Signal.html#toFrequencyScalar",
          "type": "function"
        },
        "index": {
          "description": "Express frequency value as multiple of the sampling frequency The multiplicity is returned In many applications the multiplicity is below It is checked error if the units of frequency value and sampling frequency mismatch",
          "hierarchy": "Synthesizer Physical Signal",
          "module": "Synthesizer.Physical.Signal",
          "name": "toFrequencyScalar",
          "normalized": "T a b c d e-\u003eb-\u003ea",
          "package": "synthesizer",
          "partial": "Frequency Scalar",
          "signature": "T t t' y y' yv-\u003et'-\u003et",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Physical-Signal.html#v:toFrequencyScalar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Express a time value as a multiple of the sampling period.\n     The multiplicity is returned.\n     It is a checked error,\n     if the units of time value and sampling period mismatch. \n",
          "module": "Synthesizer.Physical.Signal",
          "name": "toTimeScalar",
          "package": "synthesizer",
          "signature": "T t t' y y' yv -\u003e t' -\u003e t",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Physical-Signal.html#toTimeScalar",
          "type": "function"
        },
        "index": {
          "description": "Express time value as multiple of the sampling period The multiplicity is returned It is checked error if the units of time value and sampling period mismatch",
          "hierarchy": "Synthesizer Physical Signal",
          "module": "Synthesizer.Physical.Signal",
          "name": "toTimeScalar",
          "normalized": "T a b c d e-\u003eb-\u003ea",
          "package": "synthesizer",
          "partial": "Time Scalar",
          "signature": "T t t' y y' yv-\u003et'-\u003et",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Physical-Signal.html#v:toTimeScalar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "This module is for documentation purposes.\nBut the modules below are exported\nin order to let you easily navigate to them.\n",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Physical.html",
          "type": "unknown"
        },
        "index": {
          "description": "This module is for documentation purposes But the modules below are exported in order to let you easily navigate to them",
          "type": "unknown"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Physical.html"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Piecewise",
          "name": "Piece",
          "package": "synthesizer",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Piecewise.html#Piece",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "Synthesizer Piecewise",
          "module": "Synthesizer.Piecewise",
          "name": "Piece",
          "package": "synthesizer",
          "partial": "Piece",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Piecewise.html#t:Piece"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Piecewise",
          "name": "PieceData",
          "package": "synthesizer",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Piecewise.html#PieceData",
          "type": "data"
        },
        "index": {
          "hierarchy": "Synthesizer Piecewise",
          "module": "Synthesizer.Piecewise",
          "name": "PieceData",
          "package": "synthesizer",
          "partial": "Piece Data",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Piecewise.html#t:PieceData"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Piecewise",
          "name": "PieceDist",
          "package": "synthesizer",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Piecewise.html#PieceDist",
          "type": "data"
        },
        "index": {
          "hierarchy": "Synthesizer Piecewise",
          "module": "Synthesizer.Piecewise",
          "name": "PieceDist",
          "package": "synthesizer",
          "partial": "Piece Dist",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Piecewise.html#t:PieceDist"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Piecewise",
          "name": "PieceRightDouble",
          "package": "synthesizer",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Piecewise.html#PieceRightDouble",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "Synthesizer Piecewise",
          "module": "Synthesizer.Piecewise",
          "name": "PieceRightDouble",
          "package": "synthesizer",
          "partial": "Piece Right Double",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Piecewise.html#t:PieceRightDouble"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Piecewise",
          "name": "PieceRightSingle",
          "package": "synthesizer",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Piecewise.html#PieceRightSingle",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "Synthesizer Piecewise",
          "module": "Synthesizer.Piecewise",
          "name": "PieceRightSingle",
          "package": "synthesizer",
          "partial": "Piece Right Single",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Piecewise.html#t:PieceRightSingle"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Piecewise",
          "name": "T",
          "package": "synthesizer",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Piecewise.html#T",
          "type": "type"
        },
        "index": {
          "hierarchy": "Synthesizer Piecewise",
          "module": "Synthesizer.Piecewise",
          "name": "T",
          "package": "synthesizer",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Piecewise.html#t:T"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Piecewise",
          "name": "pieceFromFunction",
          "package": "synthesizer",
          "signature": "(y -\u003e y -\u003e t -\u003e sig) -\u003e Piece t y sig",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Piecewise.html#pieceFromFunction",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Piecewise",
          "module": "Synthesizer.Piecewise",
          "name": "pieceFromFunction",
          "normalized": "(a-\u003ea-\u003eb-\u003ec)-\u003ePiece b a c",
          "package": "synthesizer",
          "partial": "From Function",
          "signature": "(y-\u003ey-\u003et-\u003esig)-\u003ePiece t y sig",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Piecewise.html#v:pieceFromFunction"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Analysis",
          "name": "BinaryLevel",
          "package": "synthesizer",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Analysis.html#BinaryLevel",
          "type": "data"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Analysis",
          "module": "Synthesizer.Plain.Analysis",
          "name": "BinaryLevel",
          "package": "synthesizer",
          "partial": "Binary Level",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Analysis.html#t:BinaryLevel"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Analysis",
          "name": "attachOne",
          "package": "synthesizer",
          "signature": "T i -\u003e T (i, Int)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Analysis.html#attachOne",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Analysis",
          "module": "Synthesizer.Plain.Analysis",
          "name": "attachOne",
          "normalized": "T a-\u003eT(a,Int)",
          "package": "synthesizer",
          "partial": "One",
          "signature": "T i-\u003eT(i,Int)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Analysis.html#v:attachOne"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Analysis",
          "name": "average",
          "package": "synthesizer",
          "signature": "T y -\u003e y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Analysis.html#average",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Analysis",
          "module": "Synthesizer.Plain.Analysis",
          "name": "average",
          "normalized": "T a-\u003ea",
          "package": "synthesizer",
          "signature": "T y-\u003ey",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Analysis.html#v:average"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Analysis",
          "name": "binaryLevelFromBool",
          "package": "synthesizer",
          "signature": "Bool -\u003e BinaryLevel",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Analysis.html#binaryLevelFromBool",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Analysis",
          "module": "Synthesizer.Plain.Analysis",
          "name": "binaryLevelFromBool",
          "normalized": "Bool-\u003eBinaryLevel",
          "package": "synthesizer",
          "partial": "Level From Bool",
          "signature": "Bool-\u003eBinaryLevel",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Analysis.html#v:binaryLevelFromBool"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Analysis",
          "name": "binaryLevelToNumber",
          "package": "synthesizer",
          "signature": "BinaryLevel -\u003e a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Analysis.html#binaryLevelToNumber",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Analysis",
          "module": "Synthesizer.Plain.Analysis",
          "name": "binaryLevelToNumber",
          "normalized": "BinaryLevel-\u003ea",
          "package": "synthesizer",
          "partial": "Level To Number",
          "signature": "BinaryLevel-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Analysis.html#v:binaryLevelToNumber"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Analysis",
          "name": "binarySign",
          "package": "synthesizer",
          "signature": "T y -\u003e T BinaryLevel",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Analysis.html#binarySign",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Analysis",
          "module": "Synthesizer.Plain.Analysis",
          "name": "binarySign",
          "normalized": "T a-\u003eT BinaryLevel",
          "package": "synthesizer",
          "partial": "Sign",
          "signature": "T y-\u003eT BinaryLevel",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Analysis.html#v:binarySign"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Compute minimum and maximum value of the stream the efficient way.\nInput list must be non-empty and finite.\n",
          "module": "Synthesizer.Plain.Analysis",
          "name": "bounds",
          "package": "synthesizer",
          "signature": "T y -\u003e (y, y)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Analysis.html#bounds",
          "type": "function"
        },
        "index": {
          "description": "Compute minimum and maximum value of the stream the efficient way Input list must be non-empty and finite",
          "hierarchy": "Synthesizer Plain Analysis",
          "module": "Synthesizer.Plain.Analysis",
          "name": "bounds",
          "normalized": "T a-\u003e(a,a)",
          "package": "synthesizer",
          "signature": "T y-\u003e(y,y)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Analysis.html#v:bounds"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003ctt\u003e\u003ca\u003edirectCurrentOffset\u003c/a\u003e\u003c/tt\u003e must be non-zero.\n",
          "module": "Synthesizer.Plain.Analysis",
          "name": "centroid",
          "package": "synthesizer",
          "signature": "T y -\u003e y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Analysis.html#centroid",
          "type": "function"
        },
        "index": {
          "description": "directCurrentOffset must be non-zero",
          "hierarchy": "Synthesizer Plain Analysis",
          "module": "Synthesizer.Plain.Analysis",
          "name": "centroid",
          "normalized": "T a-\u003ea",
          "package": "synthesizer",
          "signature": "T y-\u003ey",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Analysis.html#v:centroid"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Analysis",
          "name": "centroidAlt",
          "package": "synthesizer",
          "signature": "T y -\u003e y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Analysis.html#centroidAlt",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Analysis",
          "module": "Synthesizer.Plain.Analysis",
          "name": "centroidAlt",
          "normalized": "T a-\u003ea",
          "package": "synthesizer",
          "partial": "Alt",
          "signature": "T y-\u003ey",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Analysis.html#v:centroidAlt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAlmost naive implementation of the chirp transform,\na generalization of the Fourier transform.\n\u003c/p\u003e\u003cp\u003eMore sophisticated algorithms like Rader, Cooley-Tukey, Winograd, Prime-Factor may follow.\n\u003c/p\u003e",
          "module": "Synthesizer.Plain.Analysis",
          "name": "chirpTransform",
          "package": "synthesizer",
          "signature": "y -\u003e T y -\u003e T y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Analysis.html#chirpTransform",
          "type": "function"
        },
        "index": {
          "description": "Almost naive implementation of the chirp transform generalization of the Fourier transform More sophisticated algorithms like Rader Cooley-Tukey Winograd Prime-Factor may follow",
          "hierarchy": "Synthesizer Plain Analysis",
          "module": "Synthesizer.Plain.Analysis",
          "name": "chirpTransform",
          "normalized": "a-\u003eT a-\u003eT a",
          "package": "synthesizer",
          "partial": "Transform",
          "signature": "y-\u003eT y-\u003eT y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Analysis.html#v:chirpTransform"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "The output type could be different from the input type\nbut then we would need a conversion from output to input for feedback.\n",
          "module": "Synthesizer.Plain.Analysis",
          "name": "deltaSigmaModulation",
          "package": "synthesizer",
          "signature": "T y -\u003e T BinaryLevel",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Analysis.html#deltaSigmaModulation",
          "type": "function"
        },
        "index": {
          "description": "The output type could be different from the input type but then we would need conversion from output to input for feedback",
          "hierarchy": "Synthesizer Plain Analysis",
          "module": "Synthesizer.Plain.Analysis",
          "name": "deltaSigmaModulation",
          "normalized": "T a-\u003eT BinaryLevel",
          "package": "synthesizer",
          "partial": "Sigma Modulation",
          "signature": "T y-\u003eT BinaryLevel",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Analysis.html#v:deltaSigmaModulation"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Requires finite length.\nThis is identical to the arithmetic mean.\n",
          "module": "Synthesizer.Plain.Analysis",
          "name": "directCurrentOffset",
          "package": "synthesizer",
          "signature": "T y -\u003e y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Analysis.html#directCurrentOffset",
          "type": "function"
        },
        "index": {
          "description": "Requires finite length This is identical to the arithmetic mean",
          "hierarchy": "Synthesizer Plain Analysis",
          "module": "Synthesizer.Plain.Analysis",
          "name": "directCurrentOffset",
          "normalized": "T a-\u003ea",
          "package": "synthesizer",
          "partial": "Current Offset",
          "signature": "T y-\u003ey",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Analysis.html#v:directCurrentOffset"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Analysis",
          "name": "firstMoment",
          "package": "synthesizer",
          "signature": "T y -\u003e y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Analysis.html#firstMoment",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Analysis",
          "module": "Synthesizer.Plain.Analysis",
          "name": "firstMoment",
          "normalized": "T a-\u003ea",
          "package": "synthesizer",
          "partial": "Moment",
          "signature": "T y-\u003ey",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Analysis.html#v:firstMoment"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Detect thresholds with a hysteresis.\n",
          "module": "Synthesizer.Plain.Analysis",
          "name": "flipFlopHysteresis",
          "package": "synthesizer",
          "signature": "(y, y) -\u003e BinaryLevel -\u003e T y -\u003e T BinaryLevel",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Analysis.html#flipFlopHysteresis",
          "type": "function"
        },
        "index": {
          "description": "Detect thresholds with hysteresis",
          "hierarchy": "Synthesizer Plain Analysis",
          "module": "Synthesizer.Plain.Analysis",
          "name": "flipFlopHysteresis",
          "normalized": "(a,a)-\u003eBinaryLevel-\u003eT a-\u003eT BinaryLevel",
          "package": "synthesizer",
          "partial": "Flop Hysteresis",
          "signature": "(y,y)-\u003eBinaryLevel-\u003eT y-\u003eT BinaryLevel",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Analysis.html#v:flipFlopHysteresis"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Input list must be finite.\nList is scanned twice, but counting may be faster.\n",
          "module": "Synthesizer.Plain.Analysis",
          "name": "histogramDiscreteArray",
          "package": "synthesizer",
          "signature": "T Int -\u003e (Int, T Int)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Analysis.html#histogramDiscreteArray",
          "type": "function"
        },
        "index": {
          "description": "Input list must be finite List is scanned twice but counting may be faster",
          "hierarchy": "Synthesizer Plain Analysis",
          "module": "Synthesizer.Plain.Analysis",
          "name": "histogramDiscreteArray",
          "normalized": "T Int-\u003e(Int,T Int)",
          "package": "synthesizer",
          "partial": "Discrete Array",
          "signature": "T Int-\u003e(Int,T Int)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Analysis.html#v:histogramDiscreteArray"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Input list must be finite.\nIf the input signal is empty, the offset is \u003ctt\u003eundefined\u003c/tt\u003e.\nList is scanned once, counting may be slower.\n",
          "module": "Synthesizer.Plain.Analysis",
          "name": "histogramDiscreteIntMap",
          "package": "synthesizer",
          "signature": "T Int -\u003e (Int, T Int)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Analysis.html#histogramDiscreteIntMap",
          "type": "function"
        },
        "index": {
          "description": "Input list must be finite If the input signal is empty the offset is undefined List is scanned once counting may be slower",
          "hierarchy": "Synthesizer Plain Analysis",
          "module": "Synthesizer.Plain.Analysis",
          "name": "histogramDiscreteIntMap",
          "normalized": "T Int-\u003e(Int,T Int)",
          "package": "synthesizer",
          "partial": "Discrete Int Map",
          "signature": "T Int-\u003e(Int,T Int)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Analysis.html#v:histogramDiscreteIntMap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Analysis",
          "name": "histogramIntMap",
          "package": "synthesizer",
          "signature": "y -\u003e T y -\u003e (Int, T Int)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Analysis.html#histogramIntMap",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Analysis",
          "module": "Synthesizer.Plain.Analysis",
          "name": "histogramIntMap",
          "normalized": "a-\u003eT a-\u003e(Int,T Int)",
          "package": "synthesizer",
          "partial": "Int Map",
          "signature": "y-\u003eT y-\u003e(Int,T Int)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Analysis.html#v:histogramIntMap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Input list must be finite.\nIf the input signal is empty, the offset is \u003ctt\u003eundefined\u003c/tt\u003e.\nList is scanned twice, but counting may be faster.\nThe sum of all histogram values is one less than the length of the signal.\n",
          "module": "Synthesizer.Plain.Analysis",
          "name": "histogramLinearArray",
          "package": "synthesizer",
          "signature": "T y -\u003e (Int, T y)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Analysis.html#histogramLinearArray",
          "type": "function"
        },
        "index": {
          "description": "Input list must be finite If the input signal is empty the offset is undefined List is scanned twice but counting may be faster The sum of all histogram values is one less than the length of the signal",
          "hierarchy": "Synthesizer Plain Analysis",
          "module": "Synthesizer.Plain.Analysis",
          "name": "histogramLinearArray",
          "normalized": "T a-\u003e(Int,T a)",
          "package": "synthesizer",
          "partial": "Linear Array",
          "signature": "T y-\u003e(Int,T y)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Analysis.html#v:histogramLinearArray"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Analysis",
          "name": "histogramLinearIntMap",
          "package": "synthesizer",
          "signature": "T y -\u003e (Int, T y)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Analysis.html#histogramLinearIntMap",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Analysis",
          "module": "Synthesizer.Plain.Analysis",
          "name": "histogramLinearIntMap",
          "normalized": "T a-\u003e(Int,T a)",
          "package": "synthesizer",
          "partial": "Linear Int Map",
          "signature": "T y-\u003e(Int,T y)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Analysis.html#v:histogramLinearIntMap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Analysis",
          "name": "meanValues",
          "package": "synthesizer",
          "signature": "T y -\u003e [(Int, y)]",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Analysis.html#meanValues",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Analysis",
          "module": "Synthesizer.Plain.Analysis",
          "name": "meanValues",
          "normalized": "T a-\u003e[(Int,a)]",
          "package": "synthesizer",
          "partial": "Values",
          "signature": "T y-\u003e[(Int,y)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Analysis.html#v:meanValues"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Analysis",
          "name": "quantize",
          "package": "synthesizer",
          "signature": "y -\u003e T y -\u003e T Int",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Analysis.html#quantize",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Analysis",
          "module": "Synthesizer.Plain.Analysis",
          "name": "quantize",
          "normalized": "a-\u003eT a-\u003eT Int",
          "package": "synthesizer",
          "signature": "y-\u003eT y-\u003eT Int",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Analysis.html#v:quantize"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Analysis",
          "name": "rectify",
          "package": "synthesizer",
          "signature": "T y -\u003e T y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Analysis.html#rectify",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Analysis",
          "module": "Synthesizer.Plain.Analysis",
          "name": "rectify",
          "normalized": "T a-\u003eT a",
          "package": "synthesizer",
          "signature": "T y-\u003eT y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Analysis.html#v:rectify"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Analysis",
          "name": "scalarProduct",
          "package": "synthesizer",
          "signature": "T y -\u003e T y -\u003e y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Analysis.html#scalarProduct",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Analysis",
          "module": "Synthesizer.Plain.Analysis",
          "name": "scalarProduct",
          "normalized": "T a-\u003eT a-\u003ea",
          "package": "synthesizer",
          "partial": "Product",
          "signature": "T y-\u003eT y-\u003ey",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Analysis.html#v:scalarProduct"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Analysis",
          "name": "spread",
          "package": "synthesizer",
          "signature": "(y, y) -\u003e [(Int, y)]",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Analysis.html#spread",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Analysis",
          "module": "Synthesizer.Plain.Analysis",
          "name": "spread",
          "normalized": "(a,a)-\u003e[(Int,a)]",
          "package": "synthesizer",
          "signature": "(y,y)-\u003e[(Int,y)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Analysis.html#v:spread"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Volume based on Energy norm.\n",
          "module": "Synthesizer.Plain.Analysis",
          "name": "volumeEuclidean",
          "package": "synthesizer",
          "signature": "T y -\u003e y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Analysis.html#volumeEuclidean",
          "type": "function"
        },
        "index": {
          "description": "Volume based on Energy norm",
          "hierarchy": "Synthesizer Plain Analysis",
          "module": "Synthesizer.Plain.Analysis",
          "name": "volumeEuclidean",
          "normalized": "T a-\u003ea",
          "package": "synthesizer",
          "partial": "Euclidean",
          "signature": "T y-\u003ey",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Analysis.html#v:volumeEuclidean"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Analysis",
          "name": "volumeEuclideanSqr",
          "package": "synthesizer",
          "signature": "T y -\u003e y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Analysis.html#volumeEuclideanSqr",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Analysis",
          "module": "Synthesizer.Plain.Analysis",
          "name": "volumeEuclideanSqr",
          "normalized": "T a-\u003ea",
          "package": "synthesizer",
          "partial": "Euclidean Sqr",
          "signature": "T y-\u003ey",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Analysis.html#v:volumeEuclideanSqr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Volume based on Manhattan norm.\n",
          "module": "Synthesizer.Plain.Analysis",
          "name": "volumeMaximum",
          "package": "synthesizer",
          "signature": "T y -\u003e y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Analysis.html#volumeMaximum",
          "type": "function"
        },
        "index": {
          "description": "Volume based on Manhattan norm",
          "hierarchy": "Synthesizer Plain Analysis",
          "module": "Synthesizer.Plain.Analysis",
          "name": "volumeMaximum",
          "normalized": "T a-\u003ea",
          "package": "synthesizer",
          "partial": "Maximum",
          "signature": "T y-\u003ey",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Analysis.html#v:volumeMaximum"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Volume based on Sum norm.\n",
          "module": "Synthesizer.Plain.Analysis",
          "name": "volumeSum",
          "package": "synthesizer",
          "signature": "T y -\u003e y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Analysis.html#volumeSum",
          "type": "function"
        },
        "index": {
          "description": "Volume based on Sum norm",
          "hierarchy": "Synthesizer Plain Analysis",
          "module": "Synthesizer.Plain.Analysis",
          "name": "volumeSum",
          "normalized": "T a-\u003ea",
          "package": "synthesizer",
          "partial": "Sum",
          "signature": "T y-\u003ey",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Analysis.html#v:volumeSum"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Volume based on Energy norm.\n",
          "module": "Synthesizer.Plain.Analysis",
          "name": "volumeVectorEuclidean",
          "package": "synthesizer",
          "signature": "T yv -\u003e y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Analysis.html#volumeVectorEuclidean",
          "type": "function"
        },
        "index": {
          "description": "Volume based on Energy norm",
          "hierarchy": "Synthesizer Plain Analysis",
          "module": "Synthesizer.Plain.Analysis",
          "name": "volumeVectorEuclidean",
          "normalized": "T a-\u003eb",
          "package": "synthesizer",
          "partial": "Vector Euclidean",
          "signature": "T yv-\u003ey",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Analysis.html#v:volumeVectorEuclidean"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Analysis",
          "name": "volumeVectorEuclideanSqr",
          "package": "synthesizer",
          "signature": "T yv -\u003e y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Analysis.html#volumeVectorEuclideanSqr",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Analysis",
          "module": "Synthesizer.Plain.Analysis",
          "name": "volumeVectorEuclideanSqr",
          "normalized": "T a-\u003eb",
          "package": "synthesizer",
          "partial": "Vector Euclidean Sqr",
          "signature": "T yv-\u003ey",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Analysis.html#v:volumeVectorEuclideanSqr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Volume based on Manhattan norm.\n",
          "module": "Synthesizer.Plain.Analysis",
          "name": "volumeVectorMaximum",
          "package": "synthesizer",
          "signature": "T yv -\u003e y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Analysis.html#volumeVectorMaximum",
          "type": "function"
        },
        "index": {
          "description": "Volume based on Manhattan norm",
          "hierarchy": "Synthesizer Plain Analysis",
          "module": "Synthesizer.Plain.Analysis",
          "name": "volumeVectorMaximum",
          "normalized": "T a-\u003eb",
          "package": "synthesizer",
          "partial": "Vector Maximum",
          "signature": "T yv-\u003ey",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Analysis.html#v:volumeVectorMaximum"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Volume based on Sum norm.\n",
          "module": "Synthesizer.Plain.Analysis",
          "name": "volumeVectorSum",
          "package": "synthesizer",
          "signature": "T yv -\u003e y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Analysis.html#volumeVectorSum",
          "type": "function"
        },
        "index": {
          "description": "Volume based on Sum norm",
          "hierarchy": "Synthesizer Plain Analysis",
          "module": "Synthesizer.Plain.Analysis",
          "name": "volumeVectorSum",
          "normalized": "T a-\u003eb",
          "package": "synthesizer",
          "partial": "Vector Sum",
          "signature": "T yv-\u003ey",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Analysis.html#v:volumeVectorSum"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDetects zeros (sign changes) in a signal.\nThis can be used as a simple measure of the portion\nof high frequencies or noise in the signal.\nIt ca be used as voiced/unvoiced detector in a vocoder.\n\u003c/p\u003e\u003cp\u003e\u003ctt\u003ezeros x !! n\u003c/tt\u003e is \u003ctt\u003eTrue\u003c/tt\u003e if and only if\n\u003ctt\u003e(x !! n \u003e= 0) /= (x !! (n+1) \u003e= 0)\u003c/tt\u003e.\nThe result will be one value shorter than the input.\n\u003c/p\u003e",
          "module": "Synthesizer.Plain.Analysis",
          "name": "zeros",
          "package": "synthesizer",
          "signature": "T y -\u003e T Bool",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Analysis.html#zeros",
          "type": "function"
        },
        "index": {
          "description": "Detects zeros sign changes in signal This can be used as simple measure of the portion of high frequencies or noise in the signal It ca be used as voiced unvoiced detector in vocoder zeros is True if and only if The result will be one value shorter than the input",
          "hierarchy": "Synthesizer Plain Analysis",
          "module": "Synthesizer.Plain.Analysis",
          "name": "zeros",
          "normalized": "T a-\u003eT Bool",
          "package": "synthesizer",
          "signature": "T y-\u003eT Bool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Analysis.html#v:zeros"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Builder",
          "name": "Put",
          "package": "synthesizer",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Builder.html#Put",
          "type": "type"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Builder",
          "module": "Synthesizer.Plain.Builder",
          "name": "Put",
          "package": "synthesizer",
          "partial": "Put",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Builder.html#t:Put"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Builder",
          "name": "T",
          "package": "synthesizer",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Builder.html#T",
          "type": "data"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Builder",
          "module": "Synthesizer.Plain.Builder",
          "name": "T",
          "package": "synthesizer",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Builder.html#t:T"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Builder",
          "name": "put",
          "package": "synthesizer",
          "signature": "Put a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Builder.html#put",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Builder",
          "module": "Synthesizer.Plain.Builder",
          "name": "put",
          "package": "synthesizer",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Builder.html#v:put"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Builder",
          "name": "run",
          "package": "synthesizer",
          "signature": "T a -\u003e [a]",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Builder.html#run",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Builder",
          "module": "Synthesizer.Plain.Builder",
          "name": "run",
          "normalized": "T a-\u003e[a]",
          "package": "synthesizer",
          "signature": "T a-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Builder.html#v:run"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Builder",
          "name": "signalToBinary",
          "package": "synthesizer",
          "signature": "[v] -\u003e [int]",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Builder.html#signalToBinary",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Builder",
          "module": "Synthesizer.Plain.Builder",
          "name": "signalToBinary",
          "normalized": "[a]-\u003e[b]",
          "package": "synthesizer",
          "partial": "To Binary",
          "signature": "[v]-\u003e[int]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Builder.html#v:signalToBinary"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Builder",
          "name": "signalToBinaryMono",
          "package": "synthesizer",
          "signature": "[a] -\u003e [int]",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Builder.html#signalToBinaryMono",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Builder",
          "module": "Synthesizer.Plain.Builder",
          "name": "signalToBinaryMono",
          "normalized": "[a]-\u003e[b]",
          "package": "synthesizer",
          "partial": "To Binary Mono",
          "signature": "[a]-\u003e[int]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Builder.html#v:signalToBinaryMono"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Builder",
          "name": "signalToBinaryStereo",
          "package": "synthesizer",
          "signature": "[(a, a)] -\u003e [int]",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Builder.html#signalToBinaryStereo",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Builder",
          "module": "Synthesizer.Plain.Builder",
          "name": "signalToBinaryStereo",
          "normalized": "[(a,a)]-\u003e[b]",
          "package": "synthesizer",
          "partial": "To Binary Stereo",
          "signature": "[(a,a)]-\u003e[int]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Builder.html#v:signalToBinaryStereo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Control",
          "name": "Control",
          "package": "synthesizer",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Control.html#Control",
          "type": "data"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Control",
          "module": "Synthesizer.Plain.Control",
          "name": "Control",
          "package": "synthesizer",
          "partial": "Control",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Control.html#t:Control"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Control",
          "name": "ControlDist",
          "package": "synthesizer",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Control.html#ControlDist",
          "type": "type"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Control",
          "module": "Synthesizer.Plain.Control",
          "name": "ControlDist",
          "package": "synthesizer",
          "partial": "Control Dist",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Control.html#t:ControlDist"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Control",
          "name": "ControlPiece",
          "package": "synthesizer",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Control.html#ControlPiece",
          "type": "data"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Control",
          "module": "Synthesizer.Plain.Control",
          "name": "ControlPiece",
          "package": "synthesizer",
          "partial": "Control Piece",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Control.html#t:ControlPiece"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Control",
          "name": "PieceRightDouble",
          "package": "synthesizer",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Control.html#PieceRightDouble",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Control",
          "module": "Synthesizer.Plain.Control",
          "name": "PieceRightDouble",
          "package": "synthesizer",
          "partial": "Piece Right Double",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Control.html#t:PieceRightDouble"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Control",
          "name": "PieceRightSingle",
          "package": "synthesizer",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Control.html#PieceRightSingle",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Control",
          "module": "Synthesizer.Plain.Control",
          "name": "PieceRightSingle",
          "package": "synthesizer",
          "partial": "Piece Right Single",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Control.html#t:PieceRightSingle"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Synthesizer.Plain.Control\",\"Synthesizer.SampleRateContext.Control\"]",
          "name": "#|",
          "package": "synthesizer",
          "signature": "(y, Control y) -\u003e y -\u003e (ControlDist y, [ControlPiece y])",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Control.html#%23%7C",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Control.html#v:#|\",\"http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-SampleRateContext-Control.html#v:#|\"]"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Control",
          "module": "Synthesizer.Plain.Control",
          "name": "#|",
          "normalized": "(a,Control a)-\u003ea-\u003e(ControlDist a,[ControlPiece a])",
          "package": "synthesizer",
          "signature": "(y,Control y)-\u003ey-\u003e(ControlDist y,[ControlPiece y])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Control.html#v:#|"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe 6 operators simplify constructing a list of \u003ctt\u003eControlPiece a\u003c/tt\u003e.\nThe description consists of nodes (namely the curve values at nodes)\nand the connecting curve types.\nThe naming scheme is as follows:\nIn the middle there is a bar \u003ctt\u003e|\u003c/tt\u003e.\nWith respect to the bar,\nthe pad symbol \u003ctt\u003e#\u003c/tt\u003e is at the side of the curve type,\nat the other side there is nothing, a minus sign \u003ctt\u003e-\u003c/tt\u003e, or an equality sign \u003ctt\u003e=\u003c/tt\u003e.\n\u003c/p\u003e\u003col\u003e\u003cli\u003e Nothing means that here is the start or the end node of a curve.\n\u003c/li\u003e\u003cli\u003e Minus means that here is a node where left and right curve meet at the same value.\n     The node description is thus one value.\n\u003c/li\u003e\u003cli\u003e Equality sign means that here is a split node,\n     where left and right curve might have different ending and beginning values, respectively.\n     The node description consists of a pair of values.\n\u003c/li\u003e\u003c/ol\u003e",
          "module": "[\"Synthesizer.Plain.Control\",\"Synthesizer.SampleRateContext.Control\"]",
          "name": "#|-",
          "package": "synthesizer",
          "signature": "(y, Control y) -\u003e (PieceRightSingle y, [ControlPiece y]) -\u003e (ControlDist y, [ControlPiece y])",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Control.html#%23%7C-",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Control.html#v:#|-\",\"http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-SampleRateContext-Control.html#v:#|-\"]"
        },
        "index": {
          "description": "The operators simplify constructing list of ControlPiece The description consists of nodes namely the curve values at nodes and the connecting curve types The naming scheme is as follows In the middle there is bar With respect to the bar the pad symbol is at the side of the curve type at the other side there is nothing minus sign or an equality sign Nothing means that here is the start or the end node of curve Minus means that here is node where left and right curve meet at the same value The node description is thus one value Equality sign means that here is split node where left and right curve might have different ending and beginning values respectively The node description consists of pair of values",
          "hierarchy": "Synthesizer Plain Control",
          "module": "Synthesizer.Plain.Control",
          "name": "#|-",
          "normalized": "(a,Control a)-\u003e(PieceRightSingle a,[ControlPiece a])-\u003e(ControlDist a,[ControlPiece a])",
          "package": "synthesizer",
          "signature": "(y,Control y)-\u003e(PieceRightSingle y,[ControlPiece y])-\u003e(ControlDist y,[ControlPiece y])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Control.html#v:#|-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Synthesizer.Plain.Control\",\"Synthesizer.SampleRateContext.Control\"]",
          "name": "#|=",
          "package": "synthesizer",
          "signature": "(y, Control y) -\u003e (PieceRightDouble y, [ControlPiece y]) -\u003e (ControlDist y, [ControlPiece y])",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Control.html#%23%7C%3D",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Control.html#v:#|=\",\"http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-SampleRateContext-Control.html#v:#|=\"]"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Control",
          "module": "Synthesizer.Plain.Control",
          "name": "#|=",
          "normalized": "(a,Control a)-\u003e(PieceRightDouble a,[ControlPiece a])-\u003e(ControlDist a,[ControlPiece a])",
          "package": "synthesizer",
          "signature": "(y,Control y)-\u003e(PieceRightDouble y,[ControlPiece y])-\u003e(ControlDist y,[ControlPiece y])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Control.html#v:#|="
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Synthesizer.Plain.Control\",\"Synthesizer.SampleRateContext.Control\"]",
          "name": "-|#",
          "package": "synthesizer",
          "signature": "y -\u003e (ControlDist y, [ControlPiece y]) -\u003e (PieceRightSingle y, [ControlPiece y])",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Control.html#-%7C%23",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Control.html#v:-|#\",\"http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-SampleRateContext-Control.html#v:-|#\"]"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Control",
          "module": "Synthesizer.Plain.Control",
          "name": "-|#",
          "normalized": "a-\u003e(ControlDist a,[ControlPiece a])-\u003e(PieceRightSingle a,[ControlPiece a])",
          "package": "synthesizer",
          "signature": "y-\u003e(ControlDist y,[ControlPiece y])-\u003e(PieceRightSingle y,[ControlPiece y])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Control.html#v:-|#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Synthesizer.Plain.Control\",\"Synthesizer.SampleRateContext.Control\"]",
          "name": "=|#",
          "package": "synthesizer",
          "signature": "(y, y) -\u003e (ControlDist y, [ControlPiece y]) -\u003e (PieceRightDouble y, [ControlPiece y])",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Control.html#%3D%7C%23",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Control.html#v:=|#\",\"http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-SampleRateContext-Control.html#v:=|#\"]"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Control",
          "module": "Synthesizer.Plain.Control",
          "name": "=|#",
          "normalized": "(a,a)-\u003e(ControlDist a,[ControlPiece a])-\u003e(PieceRightDouble a,[ControlPiece a])",
          "package": "synthesizer",
          "signature": "(y,y)-\u003e(ControlDist y,[ControlPiece y])-\u003e(PieceRightDouble y,[ControlPiece y])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Control.html#v:=|#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Control",
          "name": "concatMapPair",
          "package": "synthesizer",
          "signature": "(a -\u003e (b, b)) -\u003e T a -\u003e T b",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Control.html#concatMapPair",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Control",
          "module": "Synthesizer.Plain.Control",
          "name": "concatMapPair",
          "normalized": "(a-\u003e(b,b))-\u003eT a-\u003eT b",
          "package": "synthesizer",
          "partial": "Map Pair",
          "signature": "(a-\u003e(b,b))-\u003eT a-\u003eT b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Control.html#v:concatMapPair"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Control",
          "name": "concatMapPair'",
          "package": "synthesizer",
          "signature": "(a -\u003e (b, b)) -\u003e T a -\u003e T b",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Control.html#concatMapPair%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Control",
          "module": "Synthesizer.Plain.Control",
          "name": "concatMapPair'",
          "normalized": "(a-\u003e(b,b))-\u003eT a-\u003eT b",
          "package": "synthesizer",
          "partial": "Map Pair'",
          "signature": "(a-\u003e(b,b))-\u003eT a-\u003eT b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Control.html#v:concatMapPair'"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Control",
          "name": "constant",
          "package": "synthesizer",
          "signature": "y -\u003e T y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Control.html#constant",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Control",
          "module": "Synthesizer.Plain.Control",
          "name": "constant",
          "normalized": "a-\u003eT a",
          "package": "synthesizer",
          "signature": "y-\u003eT y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Control.html#v:constant"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "time t0 where  1 is approached \ntime t1 where -1 is approached \na cosine wave where one half wave is between t0 and t1 \n",
          "module": "Synthesizer.Plain.Control",
          "name": "cosine",
          "package": "synthesizer",
          "signature": "y-\u003e y-\u003e T y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Control.html#cosine",
          "type": "function"
        },
        "index": {
          "description": "time t0 where is approached time t1 where is approached cosine wave where one half wave is between t0 and t1",
          "hierarchy": "Synthesizer Plain Control",
          "module": "Synthesizer.Plain.Control",
          "name": "cosine",
          "normalized": "a-\u003ea-\u003eT a",
          "package": "synthesizer",
          "signature": "y-\u003ey-\u003eT y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Control.html#v:cosine"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "time t0 where  1 is approached \ntime t1 where -1 is approached \na cosine wave where one half wave is between t0 and t1 \n",
          "module": "Synthesizer.Plain.Control",
          "name": "cosineMultiscale",
          "package": "synthesizer",
          "signature": "y-\u003e y-\u003e T y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Control.html#cosineMultiscale",
          "type": "function"
        },
        "index": {
          "description": "time t0 where is approached time t1 where is approached cosine wave where one half wave is between t0 and t1",
          "hierarchy": "Synthesizer Plain Control",
          "module": "Synthesizer.Plain.Control",
          "name": "cosineMultiscale",
          "normalized": "a-\u003ea-\u003eT a",
          "package": "synthesizer",
          "partial": "Multiscale",
          "signature": "y-\u003ey-\u003eT y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Control.html#v:cosineMultiscale"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "time t0 where  1 is approached \ntime t1 where -1 is approached \na cosine wave where one half wave is between t0 and t1 \n",
          "module": "Synthesizer.Plain.Control",
          "name": "cosineStable",
          "package": "synthesizer",
          "signature": "y-\u003e y-\u003e T y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Control.html#cosineStable",
          "type": "function"
        },
        "index": {
          "description": "time t0 where is approached time t1 where is approached cosine wave where one half wave is between t0 and t1",
          "hierarchy": "Synthesizer Plain Control",
          "module": "Synthesizer.Plain.Control",
          "name": "cosineStable",
          "normalized": "a-\u003ea-\u003eT a",
          "package": "synthesizer",
          "partial": "Stable",
          "signature": "y-\u003ey-\u003eT y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Control.html#v:cosineStable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "time t0 where  1 is approached \ntime t1 where -1 is approached \na cosine wave where one half wave is between t0 and t1 \n",
          "module": "Synthesizer.Plain.Control",
          "name": "cosineSubdiv",
          "package": "synthesizer",
          "signature": "y-\u003e y-\u003e T y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Control.html#cosineSubdiv",
          "type": "function"
        },
        "index": {
          "description": "time t0 where is approached time t1 where is approached cosine wave where one half wave is between t0 and t1",
          "hierarchy": "Synthesizer Plain Control",
          "module": "Synthesizer.Plain.Control",
          "name": "cosineSubdiv",
          "normalized": "a-\u003ea-\u003eT a",
          "package": "synthesizer",
          "partial": "Subdiv",
          "signature": "y-\u003ey-\u003eT y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Control.html#v:cosineSubdiv"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Control",
          "name": "cosineSubdivision",
          "package": "synthesizer",
          "signature": "y -\u003e T y -\u003e T y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Control.html#cosineSubdivision",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Control",
          "module": "Synthesizer.Plain.Control",
          "name": "cosineSubdivision",
          "normalized": "a-\u003eT a-\u003eT a",
          "package": "synthesizer",
          "partial": "Subdivision",
          "signature": "y-\u003eT y-\u003eT y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Control.html#v:cosineSubdivision"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Control",
          "name": "cosineWithSlope",
          "package": "synthesizer",
          "signature": "(y -\u003e y -\u003e signal) -\u003e y -\u003e y -\u003e signal",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Control.html#cosineWithSlope",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Control",
          "module": "Synthesizer.Plain.Control",
          "name": "cosineWithSlope",
          "normalized": "(a-\u003ea-\u003eb)-\u003ea-\u003ea-\u003eb",
          "package": "synthesizer",
          "partial": "With Slope",
          "signature": "(y-\u003ey-\u003esignal)-\u003ey-\u003ey-\u003esignal",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Control.html#v:cosineWithSlope"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "0                                     16\n0               8                     16\n0       4       8         12          16\n0   2   4   6   8   10    12    14    16\n0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16\n",
          "module": "Synthesizer.Plain.Control",
          "name": "cubicFunc",
          "package": "synthesizer",
          "signature": "(y, (y, y)) -\u003e (y, (y, y)) -\u003e y -\u003e y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Control.html#cubicFunc",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Control",
          "module": "Synthesizer.Plain.Control",
          "name": "cubicFunc",
          "normalized": "(a,(a,a))-\u003e(a,(a,a))-\u003ea-\u003ea",
          "package": "synthesizer",
          "partial": "Func",
          "signature": "(y,(y,y))-\u003e(y,(y,y))-\u003ey-\u003ey",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Control.html#v:cubicFunc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Control",
          "name": "cubicHermite",
          "package": "synthesizer",
          "signature": "(y, (y, y)) -\u003e (y, (y, y)) -\u003e T y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Control.html#cubicHermite",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Control",
          "module": "Synthesizer.Plain.Control",
          "name": "cubicHermite",
          "normalized": "(a,(a,a))-\u003e(a,(a,a))-\u003eT a",
          "package": "synthesizer",
          "partial": "Hermite",
          "signature": "(y,(y,y))-\u003e(y,(y,y))-\u003eT y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Control.html#v:cubicHermite"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Control",
          "name": "cubicHermiteStable",
          "package": "synthesizer",
          "signature": "(y, (y, y)) -\u003e (y, (y, y)) -\u003e T y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Control.html#cubicHermiteStable",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Control",
          "module": "Synthesizer.Plain.Control",
          "name": "cubicHermiteStable",
          "normalized": "(a,(a,a))-\u003e(a,(a,a))-\u003eT a",
          "package": "synthesizer",
          "partial": "Hermite Stable",
          "signature": "(y,(y,y))-\u003e(y,(y,y))-\u003eT y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Control.html#v:cubicHermiteStable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Control",
          "name": "cubicSubdivision",
          "package": "synthesizer",
          "signature": "T y -\u003e T y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Control.html#cubicSubdivision",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Control",
          "module": "Synthesizer.Plain.Control",
          "name": "cubicSubdivision",
          "normalized": "T a-\u003eT a",
          "package": "synthesizer",
          "partial": "Subdivision",
          "signature": "T y-\u003eT y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Control.html#v:cubicSubdivision"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Control",
          "name": "curveMultiscale",
          "package": "synthesizer",
          "signature": "(y -\u003e y -\u003e y) -\u003e y -\u003e y -\u003e T y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Control.html#curveMultiscale",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Control",
          "module": "Synthesizer.Plain.Control",
          "name": "curveMultiscale",
          "normalized": "(a-\u003ea-\u003ea)-\u003ea-\u003ea-\u003eT a",
          "package": "synthesizer",
          "partial": "Multiscale",
          "signature": "(y-\u003ey-\u003ey)-\u003ey-\u003ey-\u003eT y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Control.html#v:curveMultiscale"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Control",
          "name": "curveMultiscaleNeutral",
          "package": "synthesizer",
          "signature": "(y -\u003e y -\u003e y) -\u003e y -\u003e y -\u003e T y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Control.html#curveMultiscaleNeutral",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Control",
          "module": "Synthesizer.Plain.Control",
          "name": "curveMultiscaleNeutral",
          "normalized": "(a-\u003ea-\u003ea)-\u003ea-\u003ea-\u003eT a",
          "package": "synthesizer",
          "partial": "Multiscale Neutral",
          "signature": "(y-\u003ey-\u003ey)-\u003ey-\u003ey-\u003eT y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Control.html#v:curveMultiscaleNeutral"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Control",
          "name": "curveStable",
          "package": "synthesizer",
          "signature": "(t -\u003e y) -\u003e (y -\u003e y -\u003e y) -\u003e t -\u003e y -\u003e T y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Control.html#curveStable",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Control",
          "module": "Synthesizer.Plain.Control",
          "name": "curveStable",
          "normalized": "(a-\u003eb)-\u003e(b-\u003eb-\u003eb)-\u003ea-\u003eb-\u003eT b",
          "package": "synthesizer",
          "partial": "Stable",
          "signature": "(t-\u003ey)-\u003e(y-\u003ey-\u003ey)-\u003et-\u003ey-\u003eT y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Control.html#v:curveStable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Control",
          "name": "double",
          "package": "synthesizer",
          "signature": "t -\u003e t",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Control.html#double",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Control",
          "module": "Synthesizer.Plain.Control",
          "name": "double",
          "normalized": "a-\u003ea",
          "package": "synthesizer",
          "signature": "t-\u003et",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Control.html#v:double"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "time where the function reaches 1/e of the initial value \ninitial value \nexponential decay \n",
          "module": "Synthesizer.Plain.Control",
          "name": "exponential",
          "package": "synthesizer",
          "signature": "y-\u003e y-\u003e T y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Control.html#exponential",
          "type": "function"
        },
        "index": {
          "description": "time where the function reaches of the initial value initial value exponential decay",
          "hierarchy": "Synthesizer Plain Control",
          "module": "Synthesizer.Plain.Control",
          "name": "exponential",
          "normalized": "a-\u003ea-\u003eT a",
          "package": "synthesizer",
          "signature": "y-\u003ey-\u003eT y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Control.html#v:exponential"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "half life \ninitial value \nexponential decay \n",
          "module": "Synthesizer.Plain.Control",
          "name": "exponential2",
          "package": "synthesizer",
          "signature": "y-\u003e y-\u003e T y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Control.html#exponential2",
          "type": "function"
        },
        "index": {
          "description": "half life initial value exponential decay",
          "hierarchy": "Synthesizer Plain Control",
          "module": "Synthesizer.Plain.Control",
          "name": "exponential2",
          "normalized": "a-\u003ea-\u003eT a",
          "package": "synthesizer",
          "signature": "y-\u003ey-\u003eT y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Control.html#v:exponential2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "half life \ninitial value \nexponential decay \n",
          "module": "Synthesizer.Plain.Control",
          "name": "exponential2Multiscale",
          "package": "synthesizer",
          "signature": "y-\u003e y-\u003e T y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Control.html#exponential2Multiscale",
          "type": "function"
        },
        "index": {
          "description": "half life initial value exponential decay",
          "hierarchy": "Synthesizer Plain Control",
          "module": "Synthesizer.Plain.Control",
          "name": "exponential2Multiscale",
          "normalized": "a-\u003ea-\u003eT a",
          "package": "synthesizer",
          "partial": "Multiscale",
          "signature": "y-\u003ey-\u003eT y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Control.html#v:exponential2Multiscale"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "half life \nexponential decay \n",
          "module": "Synthesizer.Plain.Control",
          "name": "exponential2MultiscaleNeutral",
          "package": "synthesizer",
          "signature": "y-\u003e T y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Control.html#exponential2MultiscaleNeutral",
          "type": "function"
        },
        "index": {
          "description": "half life exponential decay",
          "hierarchy": "Synthesizer Plain Control",
          "module": "Synthesizer.Plain.Control",
          "name": "exponential2MultiscaleNeutral",
          "normalized": "a-\u003eT a",
          "package": "synthesizer",
          "partial": "Multiscale Neutral",
          "signature": "y-\u003eT y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Control.html#v:exponential2MultiscaleNeutral"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "half life \ninitial value \nexponential decay \n",
          "module": "Synthesizer.Plain.Control",
          "name": "exponential2Stable",
          "package": "synthesizer",
          "signature": "y-\u003e y-\u003e T y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Control.html#exponential2Stable",
          "type": "function"
        },
        "index": {
          "description": "half life initial value exponential decay",
          "hierarchy": "Synthesizer Plain Control",
          "module": "Synthesizer.Plain.Control",
          "name": "exponential2Stable",
          "normalized": "a-\u003ea-\u003eT a",
          "package": "synthesizer",
          "partial": "Stable",
          "signature": "y-\u003ey-\u003eT y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Control.html#v:exponential2Stable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "time where the function reaches 1/e of the initial value \ninitial value \nvalue after given time \nexponential decay \n",
          "module": "Synthesizer.Plain.Control",
          "name": "exponentialFromTo",
          "package": "synthesizer",
          "signature": "y-\u003e y-\u003e y-\u003e T y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Control.html#exponentialFromTo",
          "type": "function"
        },
        "index": {
          "description": "time where the function reaches of the initial value initial value value after given time exponential decay",
          "hierarchy": "Synthesizer Plain Control",
          "module": "Synthesizer.Plain.Control",
          "name": "exponentialFromTo",
          "normalized": "a-\u003ea-\u003ea-\u003eT a",
          "package": "synthesizer",
          "partial": "From To",
          "signature": "y-\u003ey-\u003ey-\u003eT y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Control.html#v:exponentialFromTo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "time where the function reaches 1/e of the initial value \ninitial value \nvalue after given time \nexponential decay \n",
          "module": "Synthesizer.Plain.Control",
          "name": "exponentialFromToMultiscale",
          "package": "synthesizer",
          "signature": "y-\u003e y-\u003e y-\u003e T y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Control.html#exponentialFromToMultiscale",
          "type": "function"
        },
        "index": {
          "description": "time where the function reaches of the initial value initial value value after given time exponential decay",
          "hierarchy": "Synthesizer Plain Control",
          "module": "Synthesizer.Plain.Control",
          "name": "exponentialFromToMultiscale",
          "normalized": "a-\u003ea-\u003ea-\u003eT a",
          "package": "synthesizer",
          "partial": "From To Multiscale",
          "signature": "y-\u003ey-\u003ey-\u003eT y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Control.html#v:exponentialFromToMultiscale"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "time where the function reaches 1/e of the initial value \ninitial value \nexponential decay \n",
          "module": "Synthesizer.Plain.Control",
          "name": "exponentialMultiscale",
          "package": "synthesizer",
          "signature": "y-\u003e y-\u003e T y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Control.html#exponentialMultiscale",
          "type": "function"
        },
        "index": {
          "description": "time where the function reaches of the initial value initial value exponential decay",
          "hierarchy": "Synthesizer Plain Control",
          "module": "Synthesizer.Plain.Control",
          "name": "exponentialMultiscale",
          "normalized": "a-\u003ea-\u003eT a",
          "package": "synthesizer",
          "partial": "Multiscale",
          "signature": "y-\u003ey-\u003eT y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Control.html#v:exponentialMultiscale"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "time where the function reaches 1/e of the initial value \nexponential decay \n",
          "module": "Synthesizer.Plain.Control",
          "name": "exponentialMultiscaleNeutral",
          "package": "synthesizer",
          "signature": "y-\u003e T y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Control.html#exponentialMultiscaleNeutral",
          "type": "function"
        },
        "index": {
          "description": "time where the function reaches of the initial value exponential decay",
          "hierarchy": "Synthesizer Plain Control",
          "module": "Synthesizer.Plain.Control",
          "name": "exponentialMultiscaleNeutral",
          "normalized": "a-\u003eT a",
          "package": "synthesizer",
          "partial": "Multiscale Neutral",
          "signature": "y-\u003eT y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Control.html#v:exponentialMultiscaleNeutral"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "time where the function reaches 1/e of the initial value \ninitial value \nexponential decay \n",
          "module": "Synthesizer.Plain.Control",
          "name": "exponentialStable",
          "package": "synthesizer",
          "signature": "y-\u003e y-\u003e T y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Control.html#exponentialStable",
          "type": "function"
        },
        "index": {
          "description": "time where the function reaches of the initial value initial value exponential decay",
          "hierarchy": "Synthesizer Plain Control",
          "module": "Synthesizer.Plain.Control",
          "name": "exponentialStable",
          "normalized": "a-\u003ea-\u003eT a",
          "package": "synthesizer",
          "partial": "Stable",
          "signature": "y-\u003ey-\u003eT y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Control.html#v:exponentialStable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Control",
          "name": "exponentialStableGen",
          "package": "synthesizer",
          "signature": "(t -\u003e y) -\u003e t -\u003e y -\u003e T y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Control.html#exponentialStableGen",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Control",
          "module": "Synthesizer.Plain.Control",
          "name": "exponentialStableGen",
          "normalized": "(a-\u003eb)-\u003ea-\u003eb-\u003eT b",
          "package": "synthesizer",
          "partial": "Stable Gen",
          "signature": "(t-\u003ey)-\u003et-\u003ey-\u003eT y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Control.html#v:exponentialStableGen"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Control",
          "name": "flattenPairs",
          "package": "synthesizer",
          "signature": "T (a, a) -\u003e T a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Control.html#flattenPairs",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Control",
          "module": "Synthesizer.Plain.Control",
          "name": "flattenPairs",
          "normalized": "T(a,a)-\u003eT a",
          "package": "synthesizer",
          "partial": "Pairs",
          "signature": "T(a,a)-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Control.html#v:flattenPairs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "length \ninitial and final value \nlinear progression \n",
          "module": "Synthesizer.Plain.Control",
          "name": "line",
          "package": "synthesizer",
          "signature": "Int-\u003e (y, y)-\u003e T y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Control.html#line",
          "type": "function"
        },
        "index": {
          "description": "length initial and final value linear progression",
          "hierarchy": "Synthesizer Plain Control",
          "module": "Synthesizer.Plain.Control",
          "name": "line",
          "normalized": "Int-\u003e(a,a)-\u003eT a",
          "package": "synthesizer",
          "signature": "Int-\u003e(y,y)-\u003eT y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Control.html#v:line"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "steepness \ninitial value \nlinear progression \n",
          "module": "Synthesizer.Plain.Control",
          "name": "linear",
          "package": "synthesizer",
          "signature": "y-\u003e y-\u003e T y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Control.html#linear",
          "type": "function"
        },
        "index": {
          "description": "steepness initial value linear progression",
          "hierarchy": "Synthesizer Plain Control",
          "module": "Synthesizer.Plain.Control",
          "name": "linear",
          "normalized": "a-\u003ea-\u003eT a",
          "package": "synthesizer",
          "signature": "y-\u003ey-\u003eT y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Control.html#v:linear"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIt computes the same like \u003ctt\u003e\u003ca\u003elinear\u003c/a\u003e\u003c/tt\u003e but in a numerically more stable manner,\nnamely using a subdivision scheme.\nThe division needed is a division by two.\n\u003c/p\u003e\u003cp\u003e0       4       8\n0   2   4   6   8\n0 1 2 3 4 5 6 7 8\n\u003c/p\u003e",
          "module": "Synthesizer.Plain.Control",
          "name": "linearMean",
          "package": "synthesizer",
          "signature": "y -\u003e y -\u003e T y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Control.html#linearMean",
          "type": "function"
        },
        "index": {
          "description": "It computes the same like linear but in numerically more stable manner namely using subdivision scheme The division needed is division by two",
          "hierarchy": "Synthesizer Plain Control",
          "module": "Synthesizer.Plain.Control",
          "name": "linearMean",
          "normalized": "a-\u003ea-\u003eT a",
          "package": "synthesizer",
          "partial": "Mean",
          "signature": "y-\u003ey-\u003eT y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Control.html#v:linearMean"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Minimize rounding errors by reducing number of operations per element\nto a logarithmuc number.\n",
          "module": "Synthesizer.Plain.Control",
          "name": "linearMultiscale",
          "package": "synthesizer",
          "signature": "y -\u003e y -\u003e T y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Control.html#linearMultiscale",
          "type": "function"
        },
        "index": {
          "description": "Minimize rounding errors by reducing number of operations per element to logarithmuc number",
          "hierarchy": "Synthesizer Plain Control",
          "module": "Synthesizer.Plain.Control",
          "name": "linearMultiscale",
          "normalized": "a-\u003ea-\u003eT a",
          "package": "synthesizer",
          "partial": "Multiscale",
          "signature": "y-\u003ey-\u003eT y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Control.html#v:linearMultiscale"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Linear curve starting at zero.\n",
          "module": "Synthesizer.Plain.Control",
          "name": "linearMultiscaleNeutral",
          "package": "synthesizer",
          "signature": "y -\u003e T y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Control.html#linearMultiscaleNeutral",
          "type": "function"
        },
        "index": {
          "description": "Linear curve starting at zero",
          "hierarchy": "Synthesizer Plain Control",
          "module": "Synthesizer.Plain.Control",
          "name": "linearMultiscaleNeutral",
          "normalized": "a-\u003eT a",
          "package": "synthesizer",
          "partial": "Multiscale Neutral",
          "signature": "y-\u003eT y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Control.html#v:linearMultiscaleNeutral"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "As stable as the addition of time values.\n",
          "module": "Synthesizer.Plain.Control",
          "name": "linearStable",
          "package": "synthesizer",
          "signature": "y -\u003e y -\u003e T y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Control.html#linearStable",
          "type": "function"
        },
        "index": {
          "description": "As stable as the addition of time values",
          "hierarchy": "Synthesizer Plain Control",
          "module": "Synthesizer.Plain.Control",
          "name": "linearStable",
          "normalized": "a-\u003ea-\u003eT a",
          "package": "synthesizer",
          "partial": "Stable",
          "signature": "y-\u003ey-\u003eT y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Control.html#v:linearStable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Intersperse linearly interpolated values. \n",
          "module": "Synthesizer.Plain.Control",
          "name": "linearSubdivision",
          "package": "synthesizer",
          "signature": "T y -\u003e T y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Control.html#linearSubdivision",
          "type": "function"
        },
        "index": {
          "description": "Intersperse linearly interpolated values",
          "hierarchy": "Synthesizer Plain Control",
          "module": "Synthesizer.Plain.Control",
          "name": "linearSubdivision",
          "normalized": "T a-\u003eT a",
          "package": "synthesizer",
          "partial": "Subdivision",
          "signature": "T y-\u003eT y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Control.html#v:linearSubdivision"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Control",
          "name": "piecewise",
          "package": "synthesizer",
          "signature": "[ControlPiece y] -\u003e T y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Control.html#piecewise",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Control",
          "module": "Synthesizer.Plain.Control",
          "name": "piecewise",
          "normalized": "[ControlPiece a]-\u003eT a",
          "package": "synthesizer",
          "signature": "[ControlPiece y]-\u003eT y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Control.html#v:piecewise"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Control",
          "name": "piecewisePart",
          "package": "synthesizer",
          "signature": "y -\u003e y -\u003e y -\u003e y -\u003e Int -\u003e Control y -\u003e T y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Control.html#piecewisePart",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Control",
          "module": "Synthesizer.Plain.Control",
          "name": "piecewisePart",
          "normalized": "a-\u003ea-\u003ea-\u003ea-\u003eInt-\u003eControl a-\u003eT a",
          "package": "synthesizer",
          "partial": "Part",
          "signature": "y-\u003ey-\u003ey-\u003ey-\u003eInt-\u003eControl y-\u003eT y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Control.html#v:piecewisePart"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Control",
          "name": "subdivide",
          "package": "synthesizer",
          "signature": "(y -\u003e y -\u003e y) -\u003e T y -\u003e T y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Control.html#subdivide",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Control",
          "module": "Synthesizer.Plain.Control",
          "name": "subdivide",
          "normalized": "(a-\u003ea-\u003ea)-\u003eT a-\u003eT a",
          "package": "synthesizer",
          "signature": "(y-\u003ey-\u003ey)-\u003eT y-\u003eT y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Control.html#v:subdivide"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Control",
          "name": "unreachable",
          "package": "synthesizer",
          "signature": "a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Control.html#unreachable",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Control",
          "module": "Synthesizer.Plain.Control",
          "name": "unreachable",
          "package": "synthesizer",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Control.html#v:unreachable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "time where the function reaches 1/e of the initial value \ninitial value \nexponential decay \n",
          "module": "Synthesizer.Plain.Control",
          "name": "vectorExponential",
          "package": "synthesizer",
          "signature": "y-\u003e v-\u003e T v",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Control.html#vectorExponential",
          "type": "function"
        },
        "index": {
          "description": "time where the function reaches of the initial value initial value exponential decay",
          "hierarchy": "Synthesizer Plain Control",
          "module": "Synthesizer.Plain.Control",
          "name": "vectorExponential",
          "normalized": "a-\u003eb-\u003eT b",
          "package": "synthesizer",
          "partial": "Exponential",
          "signature": "y-\u003ev-\u003eT v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Control.html#v:vectorExponential"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "half life \ninitial value \nexponential decay \n",
          "module": "Synthesizer.Plain.Control",
          "name": "vectorExponential2",
          "package": "synthesizer",
          "signature": "y-\u003e v-\u003e T v",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Control.html#vectorExponential2",
          "type": "function"
        },
        "index": {
          "description": "half life initial value exponential decay",
          "hierarchy": "Synthesizer Plain Control",
          "module": "Synthesizer.Plain.Control",
          "name": "vectorExponential2",
          "normalized": "a-\u003eb-\u003eT b",
          "package": "synthesizer",
          "partial": "Exponential",
          "signature": "y-\u003ev-\u003eT v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Control.html#v:vectorExponential2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Synthesizer.Plain.Control\",\"Synthesizer.SampleRateContext.Control\"]",
          "name": "|#",
          "package": "synthesizer",
          "signature": "y -\u003e (ControlDist y, [ControlPiece y]) -\u003e [ControlPiece y]",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Control.html#%7C%23",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Control.html#v:|#\",\"http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-SampleRateContext-Control.html#v:|#\"]"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Control",
          "module": "Synthesizer.Plain.Control",
          "name": "|#",
          "normalized": "a-\u003e(ControlDist a,[ControlPiece a])-\u003e[ControlPiece a]",
          "package": "synthesizer",
          "signature": "y-\u003e(ControlDist y,[ControlPiece y])-\u003e[ControlPiece y]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Control.html#v:|#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "A list of pairs: (relative start time, signal part),\n                The start time is relative to the start time\n                of the previous event. \nThe mixed signal. \n",
          "module": "Synthesizer.Plain.Cut",
          "name": "arrange",
          "package": "synthesizer",
          "signature": "T Int (T v)-\u003e T v",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Cut.html#arrange",
          "type": "function"
        },
        "index": {
          "description": "list of pairs relative start time signal part The start time is relative to the start time of the previous event The mixed signal",
          "hierarchy": "Synthesizer Plain Cut",
          "module": "Synthesizer.Plain.Cut",
          "name": "arrange",
          "normalized": "T Int(T a)-\u003eT a",
          "package": "synthesizer",
          "signature": "T Int(T v)-\u003eT v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Cut.html#v:arrange"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Cut",
          "name": "select",
          "package": "synthesizer",
          "signature": "Array i (T a) -\u003e T i -\u003e T a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Cut.html#select",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Cut",
          "module": "Synthesizer.Plain.Cut",
          "name": "select",
          "normalized": "Array a(T b)-\u003eT a-\u003eT b",
          "package": "synthesizer",
          "signature": "Array i(T a)-\u003eT i-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Cut.html#v:select"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Cut",
          "name": "selectBool",
          "package": "synthesizer",
          "signature": "(T a, T a) -\u003e T Bool -\u003e T a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Cut.html#selectBool",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Cut",
          "module": "Synthesizer.Plain.Cut",
          "name": "selectBool",
          "normalized": "(T a,T a)-\u003eT Bool-\u003eT a",
          "package": "synthesizer",
          "partial": "Bool",
          "signature": "(T a,T a)-\u003eT Bool-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Cut.html#v:selectBool"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Take values until the predicate p holds for n successive values.\nThe list is truncated at the beginning of the interval of matching values.\n",
          "module": "Synthesizer.Plain.Cut",
          "name": "takeUntilInterval",
          "package": "synthesizer",
          "signature": "(a -\u003e Bool) -\u003e Int -\u003e T a -\u003e T a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Cut.html#takeUntilInterval",
          "type": "function"
        },
        "index": {
          "description": "Take values until the predicate holds for successive values The list is truncated at the beginning of the interval of matching values",
          "hierarchy": "Synthesizer Plain Cut",
          "module": "Synthesizer.Plain.Cut",
          "name": "takeUntilInterval",
          "normalized": "(a-\u003eBool)-\u003eInt-\u003eT a-\u003eT a",
          "package": "synthesizer",
          "partial": "Until Interval",
          "signature": "(a-\u003eBool)-\u003eInt-\u003eT a-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Cut.html#v:takeUntilInterval"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Take signal until it falls short of a certain amplitude for a given time.\n",
          "module": "Synthesizer.Plain.Cut",
          "name": "takeUntilPause",
          "package": "synthesizer",
          "signature": "a -\u003e Int -\u003e T a -\u003e T a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Cut.html#takeUntilPause",
          "type": "function"
        },
        "index": {
          "description": "Take signal until it falls short of certain amplitude for given time",
          "hierarchy": "Synthesizer Plain Cut",
          "module": "Synthesizer.Plain.Cut",
          "name": "takeUntilPause",
          "normalized": "a-\u003eInt-\u003eT a-\u003eT a",
          "package": "synthesizer",
          "partial": "Until Pause",
          "signature": "a-\u003eInt-\u003eT a-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Cut.html#v:takeUntilPause"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "In \u003ca\u003eSynthesizer.Basic.Distortion\u003c/a\u003e you find a collection\nof appropriate distortion functions.\n",
          "module": "Synthesizer.Plain.Displacement",
          "name": "distort",
          "package": "synthesizer",
          "signature": "(c -\u003e a -\u003e a) -\u003e T c -\u003e T a -\u003e T a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Displacement.html#distort",
          "type": "function"
        },
        "index": {
          "description": "In Synthesizer.Basic.Distortion you find collection of appropriate distortion functions",
          "hierarchy": "Synthesizer Plain Displacement",
          "module": "Synthesizer.Plain.Displacement",
          "name": "distort",
          "normalized": "(a-\u003eb-\u003eb)-\u003eT a-\u003eT b-\u003eT b",
          "package": "synthesizer",
          "signature": "(c-\u003ea-\u003ea)-\u003eT c-\u003eT a-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Displacement.html#v:distort"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Mix two signals.\n    In opposition to \u003ctt\u003e\u003ca\u003ezipWith\u003c/a\u003e\u003c/tt\u003e the result has the length of the longer signal. \n",
          "module": "Synthesizer.Plain.Displacement",
          "name": "mix",
          "package": "synthesizer",
          "signature": "T v -\u003e T v -\u003e T v",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Displacement.html#mix",
          "type": "function"
        },
        "index": {
          "description": "Mix two signals In opposition to zipWith the result has the length of the longer signal",
          "hierarchy": "Synthesizer Plain Displacement",
          "module": "Synthesizer.Plain.Displacement",
          "name": "mix",
          "normalized": "T a-\u003eT a-\u003eT a",
          "package": "synthesizer",
          "signature": "T v-\u003eT v-\u003eT v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Displacement.html#v:mix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Mix an arbitrary number of signals. \n",
          "module": "Synthesizer.Plain.Displacement",
          "name": "mixMulti",
          "package": "synthesizer",
          "signature": "[T v] -\u003e T v",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Displacement.html#mixMulti",
          "type": "function"
        },
        "index": {
          "description": "Mix an arbitrary number of signals",
          "hierarchy": "Synthesizer Plain Displacement",
          "module": "Synthesizer.Plain.Displacement",
          "name": "mixMulti",
          "normalized": "[T a]-\u003eT a",
          "package": "synthesizer",
          "partial": "Multi",
          "signature": "[T v]-\u003eT v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Displacement.html#v:mixMulti"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Add a number to all of the signal values.\n    This is useful for adjusting the center of a modulation. \n",
          "module": "Synthesizer.Plain.Displacement",
          "name": "raise",
          "package": "synthesizer",
          "signature": "v -\u003e T v -\u003e T v",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Displacement.html#raise",
          "type": "function"
        },
        "index": {
          "description": "Add number to all of the signal values This is useful for adjusting the center of modulation",
          "hierarchy": "Synthesizer Plain Displacement",
          "module": "Synthesizer.Plain.Displacement",
          "name": "raise",
          "normalized": "a-\u003eT a-\u003eT a",
          "package": "synthesizer",
          "signature": "v-\u003eT v-\u003eT v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Displacement.html#v:raise"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "stereo sound of a humming fly \n",
          "module": "Synthesizer.Plain.Effect.Fly",
          "name": "fly",
          "package": "synthesizer",
          "signature": "[(Double, Double)]",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Effect-Fly.html#fly",
          "type": "function"
        },
        "index": {
          "description": "stereo sound of humming fly",
          "hierarchy": "Synthesizer Plain Effect Fly",
          "module": "Synthesizer.Plain.Effect.Fly",
          "name": "fly",
          "normalized": "[(Double,Double)]",
          "package": "synthesizer",
          "signature": "[(Double,Double)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Effect-Fly.html#v:fly"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Effect.Fly",
          "name": "main",
          "package": "synthesizer",
          "signature": "IO ExitCode",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Effect-Fly.html#main",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Effect Fly",
          "module": "Synthesizer.Plain.Effect.Fly",
          "name": "main",
          "package": "synthesizer",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Effect-Fly.html#v:main"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Effect.Fly",
          "name": "sampleRate",
          "package": "synthesizer",
          "signature": "Double",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Effect-Fly.html#sampleRate",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Effect Fly",
          "module": "Synthesizer.Plain.Effect.Fly",
          "name": "sampleRate",
          "package": "synthesizer",
          "partial": "Rate",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Effect-Fly.html#v:sampleRate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Effect.Glass",
          "name": "densityHeavy",
          "package": "synthesizer",
          "signature": "a -\u003e a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Effect-Glass.html#densityHeavy",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Effect Glass",
          "module": "Synthesizer.Plain.Effect.Glass",
          "name": "densityHeavy",
          "normalized": "a-\u003ea",
          "package": "synthesizer",
          "partial": "Heavy",
          "signature": "a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Effect-Glass.html#v:densityHeavy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Effect.Glass",
          "name": "densitySmooth",
          "package": "synthesizer",
          "signature": "a -\u003e a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Effect-Glass.html#densitySmooth",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Effect Glass",
          "module": "Synthesizer.Plain.Effect.Glass",
          "name": "densitySmooth",
          "normalized": "a-\u003ea",
          "package": "synthesizer",
          "partial": "Smooth",
          "signature": "a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Effect-Glass.html#v:densitySmooth"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "We try to simulate the sound of broken glass\n     as a mixture of short percussive sounds with random pitch \n",
          "module": "Synthesizer.Plain.Effect.Glass",
          "name": "glass",
          "package": "synthesizer",
          "signature": "Double -\u003e [Double]",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Effect-Glass.html#glass",
          "type": "function"
        },
        "index": {
          "description": "We try to simulate the sound of broken glass as mixture of short percussive sounds with random pitch",
          "hierarchy": "Synthesizer Plain Effect Glass",
          "module": "Synthesizer.Plain.Effect.Glass",
          "name": "glass",
          "normalized": "Double-\u003e[Double]",
          "package": "synthesizer",
          "signature": "Double-\u003e[Double]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Effect-Glass.html#v:glass"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Effect.Glass",
          "name": "particle",
          "package": "synthesizer",
          "signature": "a -\u003e a -\u003e a -\u003e [a]",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Effect-Glass.html#particle",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Effect Glass",
          "module": "Synthesizer.Plain.Effect.Glass",
          "name": "particle",
          "normalized": "a-\u003ea-\u003ea-\u003e[a]",
          "package": "synthesizer",
          "signature": "a-\u003ea-\u003ea-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Effect-Glass.html#v:particle"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Effect.Glass",
          "name": "particles",
          "package": "synthesizer",
          "signature": "Double -\u003e Double -\u003e T Int [Double]",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Effect-Glass.html#particles",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Effect Glass",
          "module": "Synthesizer.Plain.Effect.Glass",
          "name": "particles",
          "normalized": "Double-\u003eDouble-\u003eT Int[Double]",
          "package": "synthesizer",
          "signature": "Double-\u003eDouble-\u003eT Int[Double]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Effect-Glass.html#v:particles"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Effect.Glass",
          "name": "segmentBefore",
          "package": "synthesizer",
          "signature": "(a -\u003e Bool) -\u003e [a] -\u003e [[a]]",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Effect-Glass.html#segmentBefore",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Effect Glass",
          "module": "Synthesizer.Plain.Effect.Glass",
          "name": "segmentBefore",
          "normalized": "(a-\u003eBool)-\u003e[a]-\u003e[[a]]",
          "package": "synthesizer",
          "partial": "Before",
          "signature": "(a-\u003eBool)-\u003e[a]-\u003e[[a]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Effect-Glass.html#v:segmentBefore"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Effect.Glass",
          "name": "timeDiffs",
          "package": "synthesizer",
          "signature": "[Bool] -\u003e [Int]",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Effect-Glass.html#timeDiffs",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Effect Glass",
          "module": "Synthesizer.Plain.Effect.Glass",
          "name": "timeDiffs",
          "normalized": "[Bool]-\u003e[Int]",
          "package": "synthesizer",
          "partial": "Diffs",
          "signature": "[Bool]-\u003e[Int]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Effect-Glass.html#v:timeDiffs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Effect.Glass",
          "name": "timeDiffsAlt",
          "package": "synthesizer",
          "signature": "[Bool] -\u003e [Int]",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Effect-Glass.html#timeDiffsAlt",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Effect Glass",
          "module": "Synthesizer.Plain.Effect.Glass",
          "name": "timeDiffsAlt",
          "normalized": "[Bool]-\u003e[Int]",
          "package": "synthesizer",
          "partial": "Diffs Alt",
          "signature": "[Bool]-\u003e[Int]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Effect-Glass.html#v:timeDiffsAlt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Effect",
          "name": "cFreq",
          "package": "synthesizer",
          "signature": "Double",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Effect.html#cFreq",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Effect",
          "module": "Synthesizer.Plain.Effect",
          "name": "cFreq",
          "package": "synthesizer",
          "partial": "Freq",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Effect.html#v:cFreq"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Effect",
          "name": "main",
          "package": "synthesizer",
          "signature": "IO ExitCode",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Effect.html#main",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Effect",
          "module": "Synthesizer.Plain.Effect",
          "name": "main",
          "package": "synthesizer",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Effect.html#v:main"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Effect",
          "name": "sound0",
          "package": "synthesizer",
          "signature": "Double -\u003e [Double]",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Effect.html#sound0",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Effect",
          "module": "Synthesizer.Plain.Effect",
          "name": "sound0",
          "normalized": "Double-\u003e[Double]",
          "package": "synthesizer",
          "signature": "Double-\u003e[Double]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Effect.html#v:sound0"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Effect",
          "name": "sound1",
          "package": "synthesizer",
          "signature": "Double -\u003e [Double]",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Effect.html#sound1",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Effect",
          "module": "Synthesizer.Plain.Effect",
          "name": "sound1",
          "normalized": "Double-\u003e[Double]",
          "package": "synthesizer",
          "signature": "Double-\u003e[Double]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Effect.html#v:sound1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Effect",
          "name": "sound2",
          "package": "synthesizer",
          "signature": "Double -\u003e [Double]",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Effect.html#sound2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Effect",
          "module": "Synthesizer.Plain.Effect",
          "name": "sound2",
          "normalized": "Double-\u003e[Double]",
          "package": "synthesizer",
          "signature": "Double-\u003e[Double]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Effect.html#v:sound2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Effect",
          "name": "sound3",
          "package": "synthesizer",
          "signature": "Double -\u003e [Double]",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Effect.html#sound3",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Effect",
          "module": "Synthesizer.Plain.Effect",
          "name": "sound3",
          "normalized": "Double-\u003e[Double]",
          "package": "synthesizer",
          "signature": "Double-\u003e[Double]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Effect.html#v:sound3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Effect",
          "name": "sound4",
          "package": "synthesizer",
          "signature": "Double -\u003e [Double]",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Effect.html#sound4",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Effect",
          "module": "Synthesizer.Plain.Effect",
          "name": "sound4",
          "normalized": "Double-\u003e[Double]",
          "package": "synthesizer",
          "signature": "Double-\u003e[Double]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Effect.html#v:sound4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Effect",
          "name": "sound5",
          "package": "synthesizer",
          "signature": "Double -\u003e [Double]",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Effect.html#sound5",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Effect",
          "module": "Synthesizer.Plain.Effect",
          "name": "sound5",
          "normalized": "Double-\u003e[Double]",
          "package": "synthesizer",
          "signature": "Double-\u003e[Double]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Effect.html#v:sound5"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Effect",
          "name": "sound6",
          "package": "synthesizer",
          "signature": "Double -\u003e [Double]",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Effect.html#sound6",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Effect",
          "module": "Synthesizer.Plain.Effect",
          "name": "sound6",
          "normalized": "Double-\u003e[Double]",
          "package": "synthesizer",
          "signature": "Double-\u003e[Double]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Effect.html#v:sound6"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Effect",
          "name": "sound7",
          "package": "synthesizer",
          "signature": "Double -\u003e [Double]",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Effect.html#sound7",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Effect",
          "module": "Synthesizer.Plain.Effect",
          "name": "sound7",
          "normalized": "Double-\u003e[Double]",
          "package": "synthesizer",
          "signature": "Double-\u003e[Double]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Effect.html#v:sound7"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Effect",
          "name": "sound8",
          "package": "synthesizer",
          "signature": "Double -\u003e [Double]",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Effect.html#sound8",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Effect",
          "module": "Synthesizer.Plain.Effect",
          "name": "sound8",
          "normalized": "Double-\u003e[Double]",
          "package": "synthesizer",
          "signature": "Double-\u003e[Double]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Effect.html#v:sound8"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Effect",
          "name": "sound9",
          "package": "synthesizer",
          "signature": "Double -\u003e [Double]",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Effect.html#sound9",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Effect",
          "module": "Synthesizer.Plain.Effect",
          "name": "sound9",
          "normalized": "Double-\u003e[Double]",
          "package": "synthesizer",
          "signature": "Double-\u003e[Double]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Effect.html#v:sound9"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Effect",
          "name": "soundA",
          "package": "synthesizer",
          "signature": "Double -\u003e [Double]",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Effect.html#soundA",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Effect",
          "module": "Synthesizer.Plain.Effect",
          "name": "soundA",
          "normalized": "Double-\u003e[Double]",
          "package": "synthesizer",
          "signature": "Double-\u003e[Double]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Effect.html#v:soundA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Effect",
          "name": "soundB",
          "package": "synthesizer",
          "signature": "Double -\u003e [Double]",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Effect.html#soundB",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Effect",
          "module": "Synthesizer.Plain.Effect",
          "name": "soundB",
          "normalized": "Double-\u003e[Double]",
          "package": "synthesizer",
          "signature": "Double-\u003e[Double]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Effect.html#v:soundB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Effect",
          "name": "soundC",
          "package": "synthesizer",
          "signature": "Double -\u003e [Double]",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Effect.html#soundC",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Effect",
          "module": "Synthesizer.Plain.Effect",
          "name": "soundC",
          "normalized": "Double-\u003e[Double]",
          "package": "synthesizer",
          "signature": "Double-\u003e[Double]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Effect.html#v:soundC"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Effect",
          "name": "soundD",
          "package": "synthesizer",
          "signature": "Double -\u003e [Double]",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Effect.html#soundD",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Effect",
          "module": "Synthesizer.Plain.Effect",
          "name": "soundD",
          "normalized": "Double-\u003e[Double]",
          "package": "synthesizer",
          "signature": "Double-\u003e[Double]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Effect.html#v:soundD"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Effect",
          "name": "soundE",
          "package": "synthesizer",
          "signature": "Double -\u003e [Double]",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Effect.html#soundE",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Effect",
          "module": "Synthesizer.Plain.Effect",
          "name": "soundE",
          "normalized": "Double-\u003e[Double]",
          "package": "synthesizer",
          "signature": "Double-\u003e[Double]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Effect.html#v:soundE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Effect",
          "name": "soundm0",
          "package": "synthesizer",
          "signature": "Double -\u003e [Double]",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Effect.html#soundm0",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Effect",
          "module": "Synthesizer.Plain.Effect",
          "name": "soundm0",
          "normalized": "Double-\u003e[Double]",
          "package": "synthesizer",
          "signature": "Double-\u003e[Double]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Effect.html#v:soundm0"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.File",
          "name": "compress",
          "package": "synthesizer",
          "signature": "FilePath -\u003e IO ExitCode",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-File.html#compress",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain File",
          "module": "Synthesizer.Plain.File",
          "name": "compress",
          "normalized": "FilePath-\u003eIO ExitCode",
          "package": "synthesizer",
          "signature": "FilePath-\u003eIO ExitCode",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-File.html#v:compress"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.File",
          "name": "getInt16List",
          "package": "synthesizer",
          "signature": "Get [Int16]",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-File.html#getInt16List",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain File",
          "module": "Synthesizer.Plain.File",
          "name": "getInt16List",
          "normalized": "Get[Int]",
          "package": "synthesizer",
          "partial": "Int List",
          "signature": "Get[Int]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-File.html#v:getInt16List"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.File",
          "name": "rawToAIFF",
          "package": "synthesizer",
          "signature": "FilePath -\u003e T -\u003e a -\u003e Int -\u003e IO ExitCode",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-File.html#rawToAIFF",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain File",
          "module": "Synthesizer.Plain.File",
          "name": "rawToAIFF",
          "normalized": "FilePath-\u003eT-\u003ea-\u003eInt-\u003eIO ExitCode",
          "package": "synthesizer",
          "partial": "To AIFF",
          "signature": "FilePath-\u003eT-\u003ea-\u003eInt-\u003eIO ExitCode",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-File.html#v:rawToAIFF"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.File",
          "name": "readAIFFMono",
          "package": "synthesizer",
          "signature": "FilePath -\u003e IO [a]",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-File.html#readAIFFMono",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain File",
          "module": "Synthesizer.Plain.File",
          "name": "readAIFFMono",
          "normalized": "FilePath-\u003eIO[a]",
          "package": "synthesizer",
          "partial": "AIFFMono",
          "signature": "FilePath-\u003eIO[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-File.html#v:readAIFFMono"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "I suspect we cannot handle file closing properly.\n",
          "module": "Synthesizer.Plain.File",
          "name": "readMonoFromInt16",
          "package": "synthesizer",
          "signature": "FilePath -\u003e IO [a]",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-File.html#readMonoFromInt16",
          "type": "function"
        },
        "index": {
          "description": "suspect we cannot handle file closing properly",
          "hierarchy": "Synthesizer Plain File",
          "module": "Synthesizer.Plain.File",
          "name": "readMonoFromInt16",
          "normalized": "FilePath-\u003eIO[a]",
          "package": "synthesizer",
          "partial": "Mono From Int",
          "signature": "FilePath-\u003eIO[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-File.html#v:readMonoFromInt16"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "See \u003ctt\u003e\u003ca\u003ewrite\u003c/a\u003e\u003c/tt\u003e.\n",
          "module": "Synthesizer.Plain.File",
          "name": "render",
          "package": "synthesizer",
          "signature": "Put int -\u003e FilePath -\u003e a -\u003e (a -\u003e [v]) -\u003e IO ExitCode",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-File.html#render",
          "type": "function"
        },
        "index": {
          "description": "See write",
          "hierarchy": "Synthesizer Plain File",
          "module": "Synthesizer.Plain.File",
          "name": "render",
          "normalized": "Put a-\u003eFilePath-\u003eb-\u003e(b-\u003e[c])-\u003eIO ExitCode",
          "package": "synthesizer",
          "signature": "Put int-\u003eFilePath-\u003ea-\u003e(a-\u003e[v])-\u003eIO ExitCode",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-File.html#v:render"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.File",
          "name": "renderMonoToInt16",
          "package": "synthesizer",
          "signature": "FilePath -\u003e a -\u003e (a -\u003e [a]) -\u003e IO ExitCode",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-File.html#renderMonoToInt16",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain File",
          "module": "Synthesizer.Plain.File",
          "name": "renderMonoToInt16",
          "normalized": "FilePath-\u003ea-\u003e(a-\u003e[a])-\u003eIO ExitCode",
          "package": "synthesizer",
          "partial": "Mono To Int",
          "signature": "FilePath-\u003ea-\u003e(a-\u003e[a])-\u003eIO ExitCode",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-File.html#v:renderMonoToInt16"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.File",
          "name": "renderStereoToInt16",
          "package": "synthesizer",
          "signature": "FilePath -\u003e a -\u003e (a -\u003e [(a, a)]) -\u003e IO ExitCode",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-File.html#renderStereoToInt16",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain File",
          "module": "Synthesizer.Plain.File",
          "name": "renderStereoToInt16",
          "normalized": "FilePath-\u003ea-\u003e(a-\u003e[(a,a)])-\u003eIO ExitCode",
          "package": "synthesizer",
          "partial": "Stereo To Int",
          "signature": "FilePath-\u003ea-\u003e(a-\u003e[(a,a)])-\u003eIO ExitCode",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-File.html#v:renderStereoToInt16"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.File",
          "name": "renderToInt16",
          "package": "synthesizer",
          "signature": "FilePath -\u003e a -\u003e (a -\u003e [v]) -\u003e IO ExitCode",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-File.html#renderToInt16",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain File",
          "module": "Synthesizer.Plain.File",
          "name": "renderToInt16",
          "normalized": "FilePath-\u003ea-\u003e(a-\u003e[b])-\u003eIO ExitCode",
          "package": "synthesizer",
          "partial": "To Int",
          "signature": "FilePath-\u003ea-\u003e(a-\u003e[v])-\u003eIO ExitCode",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-File.html#v:renderToInt16"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe output format is determined by SoX by the file name extension.\nThe sample precision is determined by the provided \u003ctt\u003e\u003ca\u003ePut\u003c/a\u003e\u003c/tt\u003e function.\n\u003c/p\u003e\u003cp\u003eExample:\n\u003c/p\u003e\u003cpre\u003e import qualified Synthesizer.Plain.Builder as Builder\n\n write (Builder.put :: Builder.Put Int16) \"test.aiff\" 44100 sound\n\u003c/pre\u003e",
          "module": "Synthesizer.Plain.File",
          "name": "write",
          "package": "synthesizer",
          "signature": "Put int -\u003e FilePath -\u003e a -\u003e [v] -\u003e IO ExitCode",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-File.html#write",
          "type": "function"
        },
        "index": {
          "description": "The output format is determined by SoX by the file name extension The sample precision is determined by the provided Put function Example import qualified Synthesizer.Plain.Builder as Builder write Builder.put Builder.Put Int16 test.aiff sound",
          "hierarchy": "Synthesizer Plain File",
          "module": "Synthesizer.Plain.File",
          "name": "write",
          "normalized": "Put a-\u003eFilePath-\u003eb-\u003e[c]-\u003eIO ExitCode",
          "package": "synthesizer",
          "signature": "Put int-\u003eFilePath-\u003ea-\u003e[v]-\u003eIO ExitCode",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-File.html#v:write"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.File",
          "name": "writeMonoToInt16",
          "package": "synthesizer",
          "signature": "FilePath -\u003e a -\u003e [a] -\u003e IO ExitCode",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-File.html#writeMonoToInt16",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain File",
          "module": "Synthesizer.Plain.File",
          "name": "writeMonoToInt16",
          "normalized": "FilePath-\u003ea-\u003e[a]-\u003eIO ExitCode",
          "package": "synthesizer",
          "partial": "Mono To Int",
          "signature": "FilePath-\u003ea-\u003e[a]-\u003eIO ExitCode",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-File.html#v:writeMonoToInt16"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.File",
          "name": "writeRaw",
          "package": "synthesizer",
          "signature": "T -\u003e FilePath -\u003e a -\u003e [v] -\u003e IO ExitCode",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-File.html#writeRaw",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain File",
          "module": "Synthesizer.Plain.File",
          "name": "writeRaw",
          "normalized": "T-\u003eFilePath-\u003ea-\u003e[b]-\u003eIO ExitCode",
          "package": "synthesizer",
          "partial": "Raw",
          "signature": "T-\u003eFilePath-\u003ea-\u003e[v]-\u003eIO ExitCode",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-File.html#v:writeRaw"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "You hardly need this routine\nsince you can use a filename with \u003ctt\u003e.mp3\u003c/tt\u003e or \u003ctt\u003e.ogg\u003c/tt\u003e\nextension for \u003ctt\u003e\u003ca\u003ewriteRaw\u003c/a\u003e\u003c/tt\u003e\nand SoX will do the corresponding compression for you.\n",
          "module": "Synthesizer.Plain.File",
          "name": "writeRawCompressed",
          "package": "synthesizer",
          "signature": "T -\u003e FilePath -\u003e a -\u003e [v] -\u003e IO ExitCode",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-File.html#writeRawCompressed",
          "type": "function"
        },
        "index": {
          "description": "You hardly need this routine since you can use filename with mp3 or ogg extension for writeRaw and SoX will do the corresponding compression for you",
          "hierarchy": "Synthesizer Plain File",
          "module": "Synthesizer.Plain.File",
          "name": "writeRawCompressed",
          "normalized": "T-\u003eFilePath-\u003ea-\u003e[b]-\u003eIO ExitCode",
          "package": "synthesizer",
          "partial": "Raw Compressed",
          "signature": "T-\u003eFilePath-\u003ea-\u003e[v]-\u003eIO ExitCode",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-File.html#v:writeRawCompressed"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.File",
          "name": "writeStereoToInt16",
          "package": "synthesizer",
          "signature": "FilePath -\u003e a -\u003e [(a, a)] -\u003e IO ExitCode",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-File.html#writeStereoToInt16",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain File",
          "module": "Synthesizer.Plain.File",
          "name": "writeStereoToInt16",
          "normalized": "FilePath-\u003ea-\u003e[(a,a)]-\u003eIO ExitCode",
          "package": "synthesizer",
          "partial": "Stereo To Int",
          "signature": "FilePath-\u003ea-\u003e[(a,a)]-\u003eIO ExitCode",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-File.html#v:writeStereoToInt16"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.File",
          "name": "writeToInt16",
          "package": "synthesizer",
          "signature": "FilePath -\u003e a -\u003e [v] -\u003e IO ExitCode",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-File.html#writeToInt16",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain File",
          "module": "Synthesizer.Plain.File",
          "name": "writeToInt16",
          "normalized": "FilePath-\u003ea-\u003e[b]-\u003eIO ExitCode",
          "package": "synthesizer",
          "partial": "To Int",
          "signature": "FilePath-\u003ea-\u003e[v]-\u003eIO ExitCode",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-File.html#v:writeToInt16"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Filter.Delay.Block",
          "name": "BlockList",
          "package": "synthesizer",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Filter-Delay-Block.html#BlockList",
          "type": "type"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Filter Delay Block",
          "module": "Synthesizer.Plain.Filter.Delay.Block",
          "name": "BlockList",
          "package": "synthesizer",
          "partial": "Block List",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Filter-Delay-Block.html#t:BlockList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Filter.Delay.Block",
          "name": "dropBlocksToList",
          "package": "synthesizer",
          "signature": "Int -\u003e BlockList a -\u003e T a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Filter-Delay-Block.html#dropBlocksToList",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Filter Delay Block",
          "module": "Synthesizer.Plain.Filter.Delay.Block",
          "name": "dropBlocksToList",
          "normalized": "Int-\u003eBlockList a-\u003eT a",
          "package": "synthesizer",
          "partial": "Blocks To List",
          "signature": "Int-\u003eBlockList a-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Filter-Delay-Block.html#v:dropBlocksToList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Drop elements from a blocked list.\nThe offset must lie in the leading block.\n",
          "module": "Synthesizer.Plain.Filter.Delay.Block",
          "name": "dropSingleBlocksToList",
          "package": "synthesizer",
          "signature": "Int -\u003e BlockList a -\u003e T a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Filter-Delay-Block.html#dropSingleBlocksToList",
          "type": "function"
        },
        "index": {
          "description": "Drop elements from blocked list The offset must lie in the leading block",
          "hierarchy": "Synthesizer Plain Filter Delay Block",
          "module": "Synthesizer.Plain.Filter.Delay.Block",
          "name": "dropSingleBlocksToList",
          "normalized": "Int-\u003eBlockList a-\u003eT a",
          "package": "synthesizer",
          "partial": "Single Blocks To List",
          "signature": "Int-\u003eBlockList a-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Filter-Delay-Block.html#v:dropSingleBlocksToList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Filter.Delay.Block",
          "name": "listToBlocks",
          "package": "synthesizer",
          "signature": "Int -\u003e T a -\u003e BlockList a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Filter-Delay-Block.html#listToBlocks",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Filter Delay Block",
          "module": "Synthesizer.Plain.Filter.Delay.Block",
          "name": "listToBlocks",
          "normalized": "Int-\u003eT a-\u003eBlockList a",
          "package": "synthesizer",
          "partial": "To Blocks",
          "signature": "Int-\u003eT a-\u003eBlockList a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Filter-Delay-Block.html#v:listToBlocks"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Filter.Delay.Block",
          "name": "modulated",
          "package": "synthesizer",
          "signature": "T a v -\u003e Int -\u003e T a -\u003e T v -\u003e T v",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Filter-Delay-Block.html#modulated",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Filter Delay Block",
          "module": "Synthesizer.Plain.Filter.Delay.Block",
          "name": "modulated",
          "normalized": "T a b-\u003eInt-\u003eT a-\u003eT b-\u003eT b",
          "package": "synthesizer",
          "signature": "T a v-\u003eInt-\u003eT a-\u003eT v-\u003eT v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Filter-Delay-Block.html#v:modulated"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Filter.Delay.Block",
          "name": "modulatedCore",
          "package": "synthesizer",
          "signature": "T a v -\u003e Int -\u003e T a -\u003e T v -\u003e T v",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Filter-Delay-Block.html#modulatedCore",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Filter Delay Block",
          "module": "Synthesizer.Plain.Filter.Delay.Block",
          "name": "modulatedCore",
          "normalized": "T a b-\u003eInt-\u003eT a-\u003eT b-\u003eT b",
          "package": "synthesizer",
          "partial": "Core",
          "signature": "T a v-\u003eInt-\u003eT a-\u003eT v-\u003eT v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Filter-Delay-Block.html#v:modulatedCore"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Filter.Delay.Block",
          "name": "propDrop",
          "package": "synthesizer",
          "signature": "Int -\u003e Int -\u003e [Int] -\u003e Property",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Filter-Delay-Block.html#propDrop",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Filter Delay Block",
          "module": "Synthesizer.Plain.Filter.Delay.Block",
          "name": "propDrop",
          "normalized": "Int-\u003eInt-\u003e[Int]-\u003eProperty",
          "package": "synthesizer",
          "partial": "Drop",
          "signature": "Int-\u003eInt-\u003e[Int]-\u003eProperty",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Filter-Delay-Block.html#v:propDrop"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Filter.Delay.Block",
          "name": "suffixIndexes",
          "package": "synthesizer",
          "signature": "BlockList a -\u003e [(Int, BlockList a)]",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Filter-Delay-Block.html#suffixIndexes",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Filter Delay Block",
          "module": "Synthesizer.Plain.Filter.Delay.Block",
          "name": "suffixIndexes",
          "normalized": "BlockList a-\u003e[(Int,BlockList a)]",
          "package": "synthesizer",
          "partial": "Indexes",
          "signature": "BlockList a-\u003e[(Int,BlockList a)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Filter-Delay-Block.html#v:suffixIndexes"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "This is essentially different for constant interpolation,\nbecause this function \u003ca\u003elooks forward\u003c/a\u003e\nwhereas the other two variants \u003ca\u003elook backward\u003c/a\u003e.\nFor the symmetric interpolation functions\nof linear and cubic interpolation, this does not really matter.\n",
          "module": "Synthesizer.Plain.Filter.Delay.List",
          "name": "modulated",
          "package": "synthesizer",
          "signature": "T a v -\u003e Int -\u003e [a] -\u003e [v] -\u003e [v]",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Filter-Delay-List.html#modulated",
          "type": "function"
        },
        "index": {
          "description": "This is essentially different for constant interpolation because this function looks forward whereas the other two variants look backward For the symmetric interpolation functions of linear and cubic interpolation this does not really matter",
          "hierarchy": "Synthesizer Plain Filter Delay List",
          "module": "Synthesizer.Plain.Filter.Delay.List",
          "name": "modulated",
          "normalized": "T a b-\u003eInt-\u003e[a]-\u003e[b]-\u003e[b]",
          "package": "synthesizer",
          "signature": "T a v-\u003eInt-\u003e[a]-\u003e[v]-\u003e[v]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Filter-Delay-List.html#v:modulated"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Filter.Delay.List",
          "name": "modulatedCore",
          "package": "synthesizer",
          "signature": "T a v -\u003e Int -\u003e [a] -\u003e [v] -\u003e [v]",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Filter-Delay-List.html#modulatedCore",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Filter Delay List",
          "module": "Synthesizer.Plain.Filter.Delay.List",
          "name": "modulatedCore",
          "normalized": "T a b-\u003eInt-\u003e[a]-\u003e[b]-\u003e[b]",
          "package": "synthesizer",
          "partial": "Core",
          "signature": "T a v-\u003eInt-\u003e[a]-\u003e[v]-\u003e[v]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Filter-Delay-List.html#v:modulatedCore"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Filter.Delay.List",
          "name": "modulatedRev",
          "package": "synthesizer",
          "signature": "T a v -\u003e Int -\u003e [a] -\u003e [v] -\u003e [v]",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Filter-Delay-List.html#modulatedRev",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Filter Delay List",
          "module": "Synthesizer.Plain.Filter.Delay.List",
          "name": "modulatedRev",
          "normalized": "T a b-\u003eInt-\u003e[a]-\u003e[b]-\u003e[b]",
          "package": "synthesizer",
          "partial": "Rev",
          "signature": "T a v-\u003eInt-\u003e[a]-\u003e[v]-\u003e[v]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Filter-Delay-List.html#v:modulatedRev"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "This function uses suffixes of the reversed signal.\nThis way small delays perform well\nbut the big drawback is that the garbage collector\ncan not deallocate old samples.\n",
          "module": "Synthesizer.Plain.Filter.Delay.List",
          "name": "modulatedRevCore",
          "package": "synthesizer",
          "signature": "T a v -\u003e Int -\u003e [a] -\u003e [v] -\u003e [v]",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Filter-Delay-List.html#modulatedRevCore",
          "type": "function"
        },
        "index": {
          "description": "This function uses suffixes of the reversed signal This way small delays perform well but the big drawback is that the garbage collector can not deallocate old samples",
          "hierarchy": "Synthesizer Plain Filter Delay List",
          "module": "Synthesizer.Plain.Filter.Delay.List",
          "name": "modulatedRevCore",
          "normalized": "T a b-\u003eInt-\u003e[a]-\u003e[b]-\u003e[b]",
          "package": "synthesizer",
          "partial": "Rev Core",
          "signature": "T a v-\u003eInt-\u003e[a]-\u003e[v]-\u003e[v]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Filter-Delay-List.html#v:modulatedRevCore"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Filter.Delay.ST",
          "name": "modulated",
          "package": "synthesizer",
          "signature": "T a v -\u003e Int -\u003e [a] -\u003e [v] -\u003e [v]",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Filter-Delay-ST.html#modulated",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Filter Delay ST",
          "module": "Synthesizer.Plain.Filter.Delay.ST",
          "name": "modulated",
          "normalized": "T a b-\u003eInt-\u003e[a]-\u003e[b]-\u003e[b]",
          "package": "synthesizer",
          "signature": "T a v-\u003eInt-\u003e[a]-\u003e[v]-\u003e[v]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Filter-Delay-ST.html#v:modulated"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Filter.Delay.ST",
          "name": "modulatedAction",
          "package": "synthesizer",
          "signature": "T a v -\u003e Int -\u003e [a] -\u003e [v] -\u003e ST s [v]",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Filter-Delay-ST.html#modulatedAction",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Filter Delay ST",
          "module": "Synthesizer.Plain.Filter.Delay.ST",
          "name": "modulatedAction",
          "normalized": "T a b-\u003eInt-\u003e[a]-\u003e[b]-\u003eST c[b]",
          "package": "synthesizer",
          "partial": "Action",
          "signature": "T a v-\u003eInt-\u003e[a]-\u003e[v]-\u003eST s[v]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Filter-Delay-ST.html#v:modulatedAction"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Filter.Delay",
          "name": "phaser",
          "package": "synthesizer",
          "signature": "a -\u003e [a] -\u003e [v] -\u003e [v]",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Filter-Delay.html#phaser",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Filter Delay",
          "module": "Synthesizer.Plain.Filter.Delay",
          "name": "phaser",
          "normalized": "a-\u003e[a]-\u003e[b]-\u003e[b]",
          "package": "synthesizer",
          "signature": "a-\u003e[a]-\u003e[v]-\u003e[v]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Filter-Delay.html#v:phaser"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Filter.Delay",
          "name": "plane",
          "package": "synthesizer",
          "signature": "Double -\u003e [Double]",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Filter-Delay.html#plane",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Filter Delay",
          "module": "Synthesizer.Plain.Filter.Delay",
          "name": "plane",
          "normalized": "Double-\u003e[Double]",
          "package": "synthesizer",
          "signature": "Double-\u003e[Double]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Filter-Delay.html#v:plane"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "The test for constant interpolation will fail,\ndue to different point of views in forward and backward interpolation.\n",
          "module": "Synthesizer.Plain.Filter.Delay",
          "name": "propAll",
          "package": "synthesizer",
          "signature": "[[Bool]]",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Filter-Delay.html#propAll",
          "type": "function"
        },
        "index": {
          "description": "The test for constant interpolation will fail due to different point of views in forward and backward interpolation",
          "hierarchy": "Synthesizer Plain Filter Delay",
          "module": "Synthesizer.Plain.Filter.Delay",
          "name": "propAll",
          "normalized": "[[Bool]]",
          "package": "synthesizer",
          "partial": "All",
          "signature": "[[Bool]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Filter-Delay.html#v:propAll"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Filter.Delay",
          "name": "propSingle",
          "package": "synthesizer",
          "signature": "T Double Double -\u003e [Bool]",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Filter-Delay.html#propSingle",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Filter Delay",
          "module": "Synthesizer.Plain.Filter.Delay",
          "name": "propSingle",
          "normalized": "T Double Double-\u003e[Bool]",
          "package": "synthesizer",
          "partial": "Single",
          "signature": "T Double Double-\u003e[Bool]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Filter-Delay.html#v:propSingle"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Determine optimal filter coefficients and residue by adaptive approximation.\nThe number of initial filter coefficients is used as filter order.\n",
          "module": "Synthesizer.Plain.Filter.LinearPredictive",
          "name": "approxCoefficients",
          "package": "synthesizer",
          "signature": "a -\u003e [a] -\u003e [a] -\u003e [(a, [a])]",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Filter-LinearPredictive.html#approxCoefficients",
          "type": "function"
        },
        "index": {
          "description": "Determine optimal filter coefficients and residue by adaptive approximation The number of initial filter coefficients is used as filter order",
          "hierarchy": "Synthesizer Plain Filter LinearPredictive",
          "module": "Synthesizer.Plain.Filter.LinearPredictive",
          "name": "approxCoefficients",
          "normalized": "a-\u003e[a]-\u003e[a]-\u003e[(a,[a])]",
          "package": "synthesizer",
          "partial": "Coefficients",
          "signature": "a-\u003e[a]-\u003e[a]-\u003e[(a,[a])]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Filter-LinearPredictive.html#v:approxCoefficients"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Filter.NonRecursive",
          "name": "amplify",
          "package": "synthesizer",
          "signature": "a -\u003e T a -\u003e T a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Filter-NonRecursive.html#amplify",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Filter NonRecursive",
          "module": "Synthesizer.Plain.Filter.NonRecursive",
          "name": "amplify",
          "normalized": "a-\u003eT a-\u003eT a",
          "package": "synthesizer",
          "signature": "a-\u003eT a-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Filter-NonRecursive.html#v:amplify"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Filter.NonRecursive",
          "name": "amplifyVector",
          "package": "synthesizer",
          "signature": "a -\u003e T v -\u003e T v",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Filter-NonRecursive.html#amplifyVector",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Filter NonRecursive",
          "module": "Synthesizer.Plain.Filter.NonRecursive",
          "name": "amplifyVector",
          "normalized": "a-\u003eT b-\u003eT b",
          "package": "synthesizer",
          "partial": "Vector",
          "signature": "a-\u003eT v-\u003eT v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Filter-NonRecursive.html#v:amplifyVector"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Filter.NonRecursive",
          "name": "binomial",
          "package": "synthesizer",
          "signature": "a -\u003e a -\u003e T v -\u003e T v",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Filter-NonRecursive.html#binomial",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Filter NonRecursive",
          "module": "Synthesizer.Plain.Filter.NonRecursive",
          "name": "binomial",
          "normalized": "a-\u003ea-\u003eT b-\u003eT b",
          "package": "synthesizer",
          "signature": "a-\u003ea-\u003eT v-\u003eT v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Filter-NonRecursive.html#v:binomial"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Filter.NonRecursive",
          "name": "binomial1",
          "package": "synthesizer",
          "signature": "T v -\u003e T v",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Filter-NonRecursive.html#binomial1",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Filter NonRecursive",
          "module": "Synthesizer.Plain.Filter.NonRecursive",
          "name": "binomial1",
          "normalized": "T a-\u003eT a",
          "package": "synthesizer",
          "signature": "T v-\u003eT v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Filter-NonRecursive.html#v:binomial1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Filter.NonRecursive",
          "name": "delay",
          "package": "synthesizer",
          "signature": "Int -\u003e T y -\u003e T y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Filter-NonRecursive.html#delay",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Filter NonRecursive",
          "module": "Synthesizer.Plain.Filter.NonRecursive",
          "name": "delay",
          "normalized": "Int-\u003eT a-\u003eT a",
          "package": "synthesizer",
          "signature": "Int-\u003eT y-\u003eT y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Filter-NonRecursive.html#v:delay"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Filter.NonRecursive",
          "name": "delayPad",
          "package": "synthesizer",
          "signature": "y -\u003e Int -\u003e T y -\u003e T y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Filter-NonRecursive.html#delayPad",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Filter NonRecursive",
          "module": "Synthesizer.Plain.Filter.NonRecursive",
          "name": "delayPad",
          "normalized": "a-\u003eInt-\u003eT a-\u003eT a",
          "package": "synthesizer",
          "partial": "Pad",
          "signature": "y-\u003eInt-\u003eT y-\u003eT y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Filter-NonRecursive.html#v:delayPad"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Forward difference quotient.\nShortens the signal by one.\nInverts Synthesizer.Plain.Filter.Recursive.Integration.run in the sense that\n\u003ctt\u003edifferentiate (zero : integrate x) == x\u003c/tt\u003e.\nThe signal is shifted by a half time unit.\n",
          "module": "Synthesizer.Plain.Filter.NonRecursive",
          "name": "differentiate",
          "package": "synthesizer",
          "signature": "T v -\u003e T v",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Filter-NonRecursive.html#differentiate",
          "type": "function"
        },
        "index": {
          "description": "Forward difference quotient Shortens the signal by one Inverts Synthesizer.Plain.Filter.Recursive.Integration.run in the sense that differentiate zero integrate The signal is shifted by half time unit",
          "hierarchy": "Synthesizer Plain Filter NonRecursive",
          "module": "Synthesizer.Plain.Filter.NonRecursive",
          "name": "differentiate",
          "normalized": "T a-\u003eT a",
          "package": "synthesizer",
          "signature": "T v-\u003eT v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Filter-NonRecursive.html#v:differentiate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Second derivative.\nIt is \u003ctt\u003edifferentiate2 == differentiate . differentiate\u003c/tt\u003e\nbut \u003ctt\u003e\u003ca\u003edifferentiate2\u003c/a\u003e\u003c/tt\u003e should be faster.\n",
          "module": "Synthesizer.Plain.Filter.NonRecursive",
          "name": "differentiate2",
          "package": "synthesizer",
          "signature": "T v -\u003e T v",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Filter-NonRecursive.html#differentiate2",
          "type": "function"
        },
        "index": {
          "description": "Second derivative It is differentiate2 differentiate differentiate but differentiate2 should be faster",
          "hierarchy": "Synthesizer Plain Filter NonRecursive",
          "module": "Synthesizer.Plain.Filter.NonRecursive",
          "name": "differentiate2",
          "normalized": "T a-\u003eT a",
          "package": "synthesizer",
          "signature": "T v-\u003eT v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Filter-NonRecursive.html#v:differentiate2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCentral difference quotient.\nShortens the signal by two elements,\nand shifts the signal by one element.\n(Which can be fixed by prepending an appropriate value.)\nFor linear functions this will yield\nessentially the same result as \u003ctt\u003e\u003ca\u003edifferentiate\u003c/a\u003e\u003c/tt\u003e.\nYou obtain the result of \u003ctt\u003e\u003ca\u003edifferentiateCenter\u003c/a\u003e\u003c/tt\u003e\nif you smooth the one of \u003ctt\u003e\u003ca\u003edifferentiate\u003c/a\u003e\u003c/tt\u003e\nby averaging pairs of adjacent values.\n\u003c/p\u003e\u003cp\u003eToDo: Vector variant\n\u003c/p\u003e",
          "module": "Synthesizer.Plain.Filter.NonRecursive",
          "name": "differentiateCenter",
          "package": "synthesizer",
          "signature": "T v -\u003e T v",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Filter-NonRecursive.html#differentiateCenter",
          "type": "function"
        },
        "index": {
          "description": "Central difference quotient Shortens the signal by two elements and shifts the signal by one element Which can be fixed by prepending an appropriate value For linear functions this will yield essentially the same result as differentiate You obtain the result of differentiateCenter if you smooth the one of differentiate by averaging pairs of adjacent values ToDo Vector variant",
          "hierarchy": "Synthesizer Plain Filter NonRecursive",
          "module": "Synthesizer.Plain.Filter.NonRecursive",
          "name": "differentiateCenter",
          "normalized": "T a-\u003eT a",
          "package": "synthesizer",
          "partial": "Center",
          "signature": "T v-\u003eT v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Filter-NonRecursive.html#v:differentiateCenter"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Filter.NonRecursive",
          "name": "downsample2",
          "package": "synthesizer",
          "signature": "T a -\u003e T a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Filter-NonRecursive.html#downsample2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Filter NonRecursive",
          "module": "Synthesizer.Plain.Filter.NonRecursive",
          "name": "downsample2",
          "normalized": "T a-\u003eT a",
          "package": "synthesizer",
          "signature": "T a-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Filter-NonRecursive.html#v:downsample2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "the envelope \nthe signal to be enveloped \n",
          "module": "Synthesizer.Plain.Filter.NonRecursive",
          "name": "envelope",
          "package": "synthesizer",
          "signature": "T a-\u003e T a-\u003e T a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Filter-NonRecursive.html#envelope",
          "type": "function"
        },
        "index": {
          "description": "the envelope the signal to be enveloped",
          "hierarchy": "Synthesizer Plain Filter NonRecursive",
          "module": "Synthesizer.Plain.Filter.NonRecursive",
          "name": "envelope",
          "normalized": "T a-\u003eT a-\u003eT a",
          "package": "synthesizer",
          "signature": "T a-\u003eT a-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Filter-NonRecursive.html#v:envelope"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "the envelope \nthe signal to be enveloped \n",
          "module": "Synthesizer.Plain.Filter.NonRecursive",
          "name": "envelopeVector",
          "package": "synthesizer",
          "signature": "T a-\u003e T v-\u003e T v",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Filter-NonRecursive.html#envelopeVector",
          "type": "function"
        },
        "index": {
          "description": "the envelope the signal to be enveloped",
          "hierarchy": "Synthesizer Plain Filter NonRecursive",
          "module": "Synthesizer.Plain.Filter.NonRecursive",
          "name": "envelopeVector",
          "normalized": "T a-\u003eT b-\u003eT b",
          "package": "synthesizer",
          "partial": "Vector",
          "signature": "T a-\u003eT v-\u003eT v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Filter-NonRecursive.html#v:envelopeVector"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Filter.NonRecursive",
          "name": "fadeInOut",
          "package": "synthesizer",
          "signature": "Int -\u003e Int -\u003e Int -\u003e T a -\u003e T a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Filter-NonRecursive.html#fadeInOut",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Filter NonRecursive",
          "module": "Synthesizer.Plain.Filter.NonRecursive",
          "name": "fadeInOut",
          "normalized": "Int-\u003eInt-\u003eInt-\u003eT a-\u003eT a",
          "package": "synthesizer",
          "partial": "In Out",
          "signature": "Int-\u003eInt-\u003eInt-\u003eT a-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Filter-NonRecursive.html#v:fadeInOut"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Filter.NonRecursive",
          "name": "fadeInOutAlt",
          "package": "synthesizer",
          "signature": "Int -\u003e Int -\u003e Int -\u003e T a -\u003e T a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Filter-NonRecursive.html#fadeInOutAlt",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Filter NonRecursive",
          "module": "Synthesizer.Plain.Filter.NonRecursive",
          "name": "fadeInOutAlt",
          "normalized": "Int-\u003eInt-\u003eInt-\u003eT a-\u003eT a",
          "package": "synthesizer",
          "partial": "In Out Alt",
          "signature": "Int-\u003eInt-\u003eInt-\u003eT a-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Filter-NonRecursive.html#v:fadeInOutAlt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003ctt\u003eeps\u003c/tt\u003e is the threshold relatively to the maximum.\nThat is, if the gaussian falls below \u003ctt\u003eeps * gaussian 0\u003c/tt\u003e,\nthen the function truncated.\n",
          "module": "Synthesizer.Plain.Filter.NonRecursive",
          "name": "gaussian",
          "package": "synthesizer",
          "signature": "a -\u003e a -\u003e a -\u003e T v -\u003e T v",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Filter-NonRecursive.html#gaussian",
          "type": "function"
        },
        "index": {
          "description": "eps is the threshold relatively to the maximum That is if the gaussian falls below eps gaussian then the function truncated",
          "hierarchy": "Synthesizer Plain Filter NonRecursive",
          "module": "Synthesizer.Plain.Filter.NonRecursive",
          "name": "gaussian",
          "normalized": "a-\u003ea-\u003ea-\u003eT b-\u003eT b",
          "package": "synthesizer",
          "signature": "a-\u003ea-\u003ea-\u003eT v-\u003eT v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Filter-NonRecursive.html#v:gaussian"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Unmodulated non-recursive filter \n",
          "module": "Synthesizer.Plain.Filter.NonRecursive",
          "name": "generic",
          "package": "synthesizer",
          "signature": "T a -\u003e T v -\u003e T v",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Filter-NonRecursive.html#generic",
          "type": "function"
        },
        "index": {
          "description": "Unmodulated non-recursive filter",
          "hierarchy": "Synthesizer Plain Filter NonRecursive",
          "module": "Synthesizer.Plain.Filter.NonRecursive",
          "name": "generic",
          "normalized": "T a-\u003eT b-\u003eT b",
          "package": "synthesizer",
          "signature": "T a-\u003eT v-\u003eT v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Filter-NonRecursive.html#v:generic"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUnmodulated non-recursive filter\nOutput has same length as the input.\n\u003c/p\u003e\u003cp\u003eIt is elegant but leaks memory.\n\u003c/p\u003e",
          "module": "Synthesizer.Plain.Filter.NonRecursive",
          "name": "genericAlt",
          "package": "synthesizer",
          "signature": "T a -\u003e T v -\u003e T v",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Filter-NonRecursive.html#genericAlt",
          "type": "function"
        },
        "index": {
          "description": "Unmodulated non-recursive filter Output has same length as the input It is elegant but leaks memory",
          "hierarchy": "Synthesizer Plain Filter NonRecursive",
          "module": "Synthesizer.Plain.Filter.NonRecursive",
          "name": "genericAlt",
          "normalized": "T a-\u003eT b-\u003eT b",
          "package": "synthesizer",
          "partial": "Alt",
          "signature": "T a-\u003eT v-\u003eT v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Filter-NonRecursive.html#v:genericAlt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Filter.NonRecursive",
          "name": "propGeneric",
          "package": "synthesizer",
          "signature": "T a -\u003e T v -\u003e Bool",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Filter-NonRecursive.html#propGeneric",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Filter NonRecursive",
          "module": "Synthesizer.Plain.Filter.NonRecursive",
          "name": "propGeneric",
          "normalized": "T a-\u003eT b-\u003eBool",
          "package": "synthesizer",
          "partial": "Generic",
          "signature": "T a-\u003eT v-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Filter-NonRecursive.html#v:propGeneric"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Compute the variance of the Gaussian\n  such that its Fourier transform has value \u003ctt\u003eratio\u003c/tt\u003e at frequency \u003ctt\u003efreq\u003c/tt\u003e.\n",
          "module": "Synthesizer.Plain.Filter.NonRecursive",
          "name": "ratioFreqToVariance",
          "package": "synthesizer",
          "signature": "a -\u003e a -\u003e a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Filter-NonRecursive.html#ratioFreqToVariance",
          "type": "function"
        },
        "index": {
          "description": "Compute the variance of the Gaussian such that its Fourier transform has value ratio at frequency freq",
          "hierarchy": "Synthesizer Plain Filter NonRecursive",
          "module": "Synthesizer.Plain.Filter.NonRecursive",
          "name": "ratioFreqToVariance",
          "normalized": "a-\u003ea-\u003ea",
          "package": "synthesizer",
          "partial": "Freq To Variance",
          "signature": "a-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Filter-NonRecursive.html#v:ratioFreqToVariance"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Moving (uniformly weighted) average in the most trivial form.\nThis is very slow and needs about \u003ctt\u003en * length x\u003c/tt\u003e operations.\n",
          "module": "Synthesizer.Plain.Filter.NonRecursive",
          "name": "sums",
          "package": "synthesizer",
          "signature": "Int -\u003e T v -\u003e T v",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Filter-NonRecursive.html#sums",
          "type": "function"
        },
        "index": {
          "description": "Moving uniformly weighted average in the most trivial form This is very slow and needs about length operations",
          "hierarchy": "Synthesizer Plain Filter NonRecursive",
          "module": "Synthesizer.Plain.Filter.NonRecursive",
          "name": "sums",
          "normalized": "Int-\u003eT a-\u003eT a",
          "package": "synthesizer",
          "signature": "Int-\u003eT v-\u003eT v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Filter-NonRecursive.html#v:sums"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Filter.NonRecursive",
          "name": "sumsDownsample2",
          "package": "synthesizer",
          "signature": "T v -\u003e T v",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Filter-NonRecursive.html#sumsDownsample2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Filter NonRecursive",
          "module": "Synthesizer.Plain.Filter.NonRecursive",
          "name": "sumsDownsample2",
          "normalized": "T a-\u003eT a",
          "package": "synthesizer",
          "partial": "Downsample",
          "signature": "T v-\u003eT v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Filter-NonRecursive.html#v:sumsDownsample2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Filter.NonRecursive",
          "name": "sumsPyramid",
          "package": "synthesizer",
          "signature": "Int -\u003e T v -\u003e T v",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Filter-NonRecursive.html#sumsPyramid",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Filter NonRecursive",
          "module": "Synthesizer.Plain.Filter.NonRecursive",
          "name": "sumsPyramid",
          "normalized": "Int-\u003eT a-\u003eT a",
          "package": "synthesizer",
          "partial": "Pyramid",
          "signature": "Int-\u003eT v-\u003eT v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Filter-NonRecursive.html#v:sumsPyramid"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Filter.NonRecursive",
          "name": "sumsUpsampleEven",
          "package": "synthesizer",
          "signature": "Int -\u003e T v -\u003e T v -\u003e T v",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Filter-NonRecursive.html#sumsUpsampleEven",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Filter NonRecursive",
          "module": "Synthesizer.Plain.Filter.NonRecursive",
          "name": "sumsUpsampleEven",
          "normalized": "Int-\u003eT a-\u003eT a-\u003eT a",
          "package": "synthesizer",
          "partial": "Upsample Even",
          "signature": "Int-\u003eT v-\u003eT v-\u003eT v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Filter-NonRecursive.html#v:sumsUpsampleEven"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGiven a list of numbers\nand a list of sums of (2*k) of successive summands,\ncompute a list of the sums of (2*k+1) or (2*k+2) summands.\n\u003c/p\u003e\u003cp\u003eEample for 2*k+1\n\u003c/p\u003e\u003cpre\u003e\n [0+1+2+3, 2+3+4+5, 4+5+6+7, ...] -\u003e\n    [0+1+2+3+4, 1+2+3+4+5, 2+3+4+5+6, 3+4+5+6+7, 4+5+6+7+8, ...]\n\u003c/pre\u003e\u003cp\u003eExample for 2*k+2\n\u003c/p\u003e\u003cpre\u003e\n [0+1+2+3, 2+3+4+5, 4+5+6+7, ...] -\u003e\n    [0+1+2+3+4+5, 1+2+3+4+5+6, 2+3+4+5+6+7, 3+4+5+6+7+8, 4+5+6+7+8+9, ...]\n\u003c/pre\u003e",
          "module": "Synthesizer.Plain.Filter.NonRecursive",
          "name": "sumsUpsampleOdd",
          "package": "synthesizer",
          "signature": "Int -\u003e T v -\u003e T v -\u003e T v",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Filter-NonRecursive.html#sumsUpsampleOdd",
          "type": "function"
        },
        "index": {
          "description": "Given list of numbers and list of sums of of successive summands compute list of the sums of or summands Eample for Example for",
          "hierarchy": "Synthesizer Plain Filter NonRecursive",
          "module": "Synthesizer.Plain.Filter.NonRecursive",
          "name": "sumsUpsampleOdd",
          "normalized": "Int-\u003eT a-\u003eT a-\u003eT a",
          "package": "synthesizer",
          "partial": "Upsample Odd",
          "signature": "Int-\u003eT v-\u003eT v-\u003eT v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Filter-NonRecursive.html#v:sumsUpsampleOdd"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Filter.Recursive.Allpass",
          "name": "Parameter",
          "package": "synthesizer",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Filter-Recursive-Allpass.html#Parameter",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Filter Recursive Allpass",
          "module": "Synthesizer.Plain.Filter.Recursive.Allpass",
          "name": "Parameter",
          "package": "synthesizer",
          "partial": "Parameter",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Filter-Recursive-Allpass.html#t:Parameter"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Filter.Recursive.Allpass",
          "name": "cascade",
          "package": "synthesizer",
          "signature": "Int -\u003e T (Parameter a) -\u003e T v -\u003e T v",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Filter-Recursive-Allpass.html#cascade",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Filter Recursive Allpass",
          "module": "Synthesizer.Plain.Filter.Recursive.Allpass",
          "name": "cascade",
          "normalized": "Int-\u003eT(Parameter a)-\u003eT b-\u003eT b",
          "package": "synthesizer",
          "signature": "Int-\u003eT(Parameter a)-\u003eT v-\u003eT v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Filter-Recursive-Allpass.html#v:cascade"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Filter.Recursive.Allpass",
          "name": "cascadeCausal",
          "package": "synthesizer",
          "signature": "Int -\u003e T (Parameter a, v) v",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Filter-Recursive-Allpass.html#cascadeCausal",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Filter Recursive Allpass",
          "module": "Synthesizer.Plain.Filter.Recursive.Allpass",
          "name": "cascadeCausal",
          "normalized": "Int-\u003eT(Parameter a,b)b",
          "package": "synthesizer",
          "partial": "Causal",
          "signature": "Int-\u003eT(Parameter a,v)v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Filter-Recursive-Allpass.html#v:cascadeCausal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Filter.Recursive.Allpass",
          "name": "cascadeCausalModifier",
          "package": "synthesizer",
          "signature": "Int -\u003e T (Parameter a, v) v",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Filter-Recursive-Allpass.html#cascadeCausalModifier",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Filter Recursive Allpass",
          "module": "Synthesizer.Plain.Filter.Recursive.Allpass",
          "name": "cascadeCausalModifier",
          "normalized": "Int-\u003eT(Parameter a,b)b",
          "package": "synthesizer",
          "partial": "Causal Modifier",
          "signature": "Int-\u003eT(Parameter a,v)v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Filter-Recursive-Allpass.html#v:cascadeCausalModifier"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Filter.Recursive.Allpass",
          "name": "cascadeCausalStacked",
          "package": "synthesizer",
          "signature": "Int -\u003e T (Parameter a, v) v",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Filter-Recursive-Allpass.html#cascadeCausalStacked",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Filter Recursive Allpass",
          "module": "Synthesizer.Plain.Filter.Recursive.Allpass",
          "name": "cascadeCausalStacked",
          "normalized": "Int-\u003eT(Parameter a,b)b",
          "package": "synthesizer",
          "partial": "Causal Stacked",
          "signature": "Int-\u003eT(Parameter a,v)v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Filter-Recursive-Allpass.html#v:cascadeCausalStacked"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Filter.Recursive.Allpass",
          "name": "cascadeIterative",
          "package": "synthesizer",
          "signature": "Int -\u003e T (Parameter a) -\u003e T v -\u003e T v",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Filter-Recursive-Allpass.html#cascadeIterative",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Filter Recursive Allpass",
          "module": "Synthesizer.Plain.Filter.Recursive.Allpass",
          "name": "cascadeIterative",
          "normalized": "Int-\u003eT(Parameter a)-\u003eT b-\u003eT b",
          "package": "synthesizer",
          "partial": "Iterative",
          "signature": "Int-\u003eT(Parameter a)-\u003eT v-\u003eT v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Filter-Recursive-Allpass.html#v:cascadeIterative"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Filter.Recursive.Allpass",
          "name": "cascadeModifier",
          "package": "synthesizer",
          "signature": "Int -\u003e Simple [v] (Parameter a) v v",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Filter-Recursive-Allpass.html#cascadeModifier",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Filter Recursive Allpass",
          "module": "Synthesizer.Plain.Filter.Recursive.Allpass",
          "name": "cascadeModifier",
          "normalized": "Int-\u003eSimple[a](Parameter b)a a",
          "package": "synthesizer",
          "partial": "Modifier",
          "signature": "Int-\u003eSimple[v](Parameter a)v v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Filter-Recursive-Allpass.html#v:cascadeModifier"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Filter.Recursive.Allpass",
          "name": "cascadeState",
          "package": "synthesizer",
          "signature": "Int -\u003e T (Parameter a) -\u003e T v -\u003e T v",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Filter-Recursive-Allpass.html#cascadeState",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Filter Recursive Allpass",
          "module": "Synthesizer.Plain.Filter.Recursive.Allpass",
          "name": "cascadeState",
          "normalized": "Int-\u003eT(Parameter a)-\u003eT b-\u003eT b",
          "package": "synthesizer",
          "partial": "State",
          "signature": "Int-\u003eT(Parameter a)-\u003eT v-\u003eT v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Filter-Recursive-Allpass.html#v:cascadeState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Filter.Recursive.Allpass",
          "name": "cascadeStep",
          "package": "synthesizer",
          "signature": "Parameter a -\u003e v -\u003e State [v] v",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Filter-Recursive-Allpass.html#cascadeStep",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Filter Recursive Allpass",
          "module": "Synthesizer.Plain.Filter.Recursive.Allpass",
          "name": "cascadeStep",
          "normalized": "Parameter a-\u003eb-\u003eState[b]b",
          "package": "synthesizer",
          "partial": "Step",
          "signature": "Parameter a-\u003ev-\u003eState[v]v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Filter-Recursive-Allpass.html#v:cascadeStep"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Filter.Recursive.Allpass",
          "name": "cascadeStepRec",
          "package": "synthesizer",
          "signature": "Parameter a -\u003e v -\u003e State [v] v",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Filter-Recursive-Allpass.html#cascadeStepRec",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Filter Recursive Allpass",
          "module": "Synthesizer.Plain.Filter.Recursive.Allpass",
          "name": "cascadeStepRec",
          "normalized": "Parameter a-\u003eb-\u003eState[b]b",
          "package": "synthesizer",
          "partial": "Step Rec",
          "signature": "Parameter a-\u003ev-\u003eState[v]v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Filter-Recursive-Allpass.html#v:cascadeStepRec"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Filter.Recursive.Allpass",
          "name": "cascadeStepRecAlt",
          "package": "synthesizer",
          "signature": "Parameter a -\u003e v -\u003e State [v] v",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Filter-Recursive-Allpass.html#cascadeStepRecAlt",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Filter Recursive Allpass",
          "module": "Synthesizer.Plain.Filter.Recursive.Allpass",
          "name": "cascadeStepRecAlt",
          "normalized": "Parameter a-\u003eb-\u003eState[b]b",
          "package": "synthesizer",
          "partial": "Step Rec Alt",
          "signature": "Parameter a-\u003ev-\u003eState[v]v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Filter-Recursive-Allpass.html#v:cascadeStepRecAlt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Filter.Recursive.Allpass",
          "name": "cascadeStepStack",
          "package": "synthesizer",
          "signature": "Parameter a -\u003e v -\u003e State [v] v",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Filter-Recursive-Allpass.html#cascadeStepStack",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Filter Recursive Allpass",
          "module": "Synthesizer.Plain.Filter.Recursive.Allpass",
          "name": "cascadeStepStack",
          "normalized": "Parameter a-\u003eb-\u003eState[b]b",
          "package": "synthesizer",
          "partial": "Step Stack",
          "signature": "Parameter a-\u003ev-\u003eState[v]v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Filter-Recursive-Allpass.html#v:cascadeStepStack"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Filter.Recursive.Allpass",
          "name": "cascadeStepStackPairs",
          "package": "synthesizer",
          "signature": "Parameter a -\u003e v -\u003e State [(v, v)] v",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Filter-Recursive-Allpass.html#cascadeStepStackPairs",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Filter Recursive Allpass",
          "module": "Synthesizer.Plain.Filter.Recursive.Allpass",
          "name": "cascadeStepStackPairs",
          "normalized": "Parameter a-\u003eb-\u003eState[(b,b)]b",
          "package": "synthesizer",
          "partial": "Step Stack Pairs",
          "signature": "Parameter a-\u003ev-\u003eState[(v,v)]v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Filter-Recursive-Allpass.html#v:cascadeStepStackPairs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Filter.Recursive.Allpass",
          "name": "firstOrder",
          "package": "synthesizer",
          "signature": "T (Parameter a) -\u003e T v -\u003e T v",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Filter-Recursive-Allpass.html#firstOrder",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Filter Recursive Allpass",
          "module": "Synthesizer.Plain.Filter.Recursive.Allpass",
          "name": "firstOrder",
          "normalized": "T(Parameter a)-\u003eT b-\u003eT b",
          "package": "synthesizer",
          "partial": "Order",
          "signature": "T(Parameter a)-\u003eT v-\u003eT v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Filter-Recursive-Allpass.html#v:firstOrder"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Filter.Recursive.Allpass",
          "name": "firstOrderCausal",
          "package": "synthesizer",
          "signature": "T (Parameter a, v) v",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Filter-Recursive-Allpass.html#firstOrderCausal",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Filter Recursive Allpass",
          "module": "Synthesizer.Plain.Filter.Recursive.Allpass",
          "name": "firstOrderCausal",
          "normalized": "T(Parameter a,b)b",
          "package": "synthesizer",
          "partial": "Order Causal",
          "signature": "T(Parameter a,v)v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Filter-Recursive-Allpass.html#v:firstOrderCausal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Filter.Recursive.Allpass",
          "name": "firstOrderModifier",
          "package": "synthesizer",
          "signature": "Simple (v, v) (Parameter a) v v",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Filter-Recursive-Allpass.html#firstOrderModifier",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Filter Recursive Allpass",
          "module": "Synthesizer.Plain.Filter.Recursive.Allpass",
          "name": "firstOrderModifier",
          "normalized": "Simple(a,a)(Parameter b)a a",
          "package": "synthesizer",
          "partial": "Order Modifier",
          "signature": "Simple(v,v)(Parameter a)v v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Filter-Recursive-Allpass.html#v:firstOrderModifier"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Filter.Recursive.Allpass",
          "name": "firstOrderStep",
          "package": "synthesizer",
          "signature": "Parameter a -\u003e v -\u003e State (v, v) v",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Filter-Recursive-Allpass.html#firstOrderStep",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Filter Recursive Allpass",
          "module": "Synthesizer.Plain.Filter.Recursive.Allpass",
          "name": "firstOrderStep",
          "normalized": "Parameter a-\u003eb-\u003eState(b,b)b",
          "package": "synthesizer",
          "partial": "Order Step",
          "signature": "Parameter a-\u003ev-\u003eState(v,v)v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Filter-Recursive-Allpass.html#v:firstOrderStep"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Filter.Recursive.Allpass",
          "name": "flangerParameter",
          "package": "synthesizer",
          "signature": "Int -\u003e a -\u003e Parameter a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Filter-Recursive-Allpass.html#flangerParameter",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Filter Recursive Allpass",
          "module": "Synthesizer.Plain.Filter.Recursive.Allpass",
          "name": "flangerParameter",
          "normalized": "Int-\u003ea-\u003eParameter a",
          "package": "synthesizer",
          "partial": "Parameter",
          "signature": "Int-\u003ea-\u003eParameter a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Filter-Recursive-Allpass.html#v:flangerParameter"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Filter.Recursive.Allpass",
          "name": "flangerPhase",
          "package": "synthesizer",
          "signature": "a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Filter-Recursive-Allpass.html#flangerPhase",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Filter Recursive Allpass",
          "module": "Synthesizer.Plain.Filter.Recursive.Allpass",
          "name": "flangerPhase",
          "package": "synthesizer",
          "partial": "Phase",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Filter-Recursive-Allpass.html#v:flangerPhase"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Filter.Recursive.Allpass",
          "name": "fromPairs",
          "package": "synthesizer",
          "signature": "[(a, a)] -\u003e [a]",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Filter-Recursive-Allpass.html#fromPairs",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Filter Recursive Allpass",
          "module": "Synthesizer.Plain.Filter.Recursive.Allpass",
          "name": "fromPairs",
          "normalized": "[(a,a)]-\u003e[a]",
          "package": "synthesizer",
          "partial": "Pairs",
          "signature": "[(a,a)]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Filter-Recursive-Allpass.html#v:fromPairs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Filter.Recursive.Allpass",
          "name": "makePhase",
          "package": "synthesizer",
          "signature": "Parameter a -\u003e a -\u003e a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Filter-Recursive-Allpass.html#makePhase",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Filter Recursive Allpass",
          "module": "Synthesizer.Plain.Filter.Recursive.Allpass",
          "name": "makePhase",
          "normalized": "Parameter a-\u003ea-\u003ea",
          "package": "synthesizer",
          "partial": "Phase",
          "signature": "Parameter a-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Filter-Recursive-Allpass.html#v:makePhase"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "The number of equally designed 1st order allpasses. \nThe phase shift to be achieved for the given frequency. \nThe frequency we specified the phase shift for. \n",
          "module": "Synthesizer.Plain.Filter.Recursive.Allpass",
          "name": "parameter",
          "package": "synthesizer",
          "signature": "Int-\u003e a-\u003e a-\u003e Parameter a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Filter-Recursive-Allpass.html#parameter",
          "type": "function"
        },
        "index": {
          "description": "The number of equally designed st order allpasses The phase shift to be achieved for the given frequency The frequency we specified the phase shift for",
          "hierarchy": "Synthesizer Plain Filter Recursive Allpass",
          "module": "Synthesizer.Plain.Filter.Recursive.Allpass",
          "name": "parameter",
          "normalized": "Int-\u003ea-\u003ea-\u003eParameter a",
          "package": "synthesizer",
          "signature": "Int-\u003ea-\u003ea-\u003eParameter a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Filter-Recursive-Allpass.html#v:parameter"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Filter.Recursive.Allpass",
          "name": "toPairs",
          "package": "synthesizer",
          "signature": "[a] -\u003e [(a, a)]",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Filter-Recursive-Allpass.html#toPairs",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Filter Recursive Allpass",
          "module": "Synthesizer.Plain.Filter.Recursive.Allpass",
          "name": "toPairs",
          "normalized": "[a]-\u003e[(a,a)]",
          "package": "synthesizer",
          "partial": "Pairs",
          "signature": "[a]-\u003e[(a,a)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Filter-Recursive-Allpass.html#v:toPairs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Filter.Recursive.AllpassPoly",
          "name": "Parameter",
          "package": "synthesizer",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Filter-Recursive-AllpassPoly.html#Parameter",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Filter Recursive AllpassPoly",
          "module": "Synthesizer.Plain.Filter.Recursive.AllpassPoly",
          "name": "Parameter",
          "package": "synthesizer",
          "partial": "Parameter",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Filter-Recursive-AllpassPoly.html#t:Parameter"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Filter.Recursive.AllpassPoly",
          "name": "integrateNum",
          "package": "synthesizer",
          "signature": "Int -\u003e (a, a) -\u003e (a -\u003e v) -\u003e v",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Filter-Recursive-AllpassPoly.html#integrateNum",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Filter Recursive AllpassPoly",
          "module": "Synthesizer.Plain.Filter.Recursive.AllpassPoly",
          "name": "integrateNum",
          "normalized": "Int-\u003e(a,a)-\u003e(a-\u003eb)-\u003eb",
          "package": "synthesizer",
          "partial": "Num",
          "signature": "Int-\u003e(a,a)-\u003e(a-\u003ev)-\u003ev",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Filter-Recursive-AllpassPoly.html#v:integrateNum"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Filter.Recursive.AllpassPoly",
          "name": "integrateScrewExp",
          "package": "synthesizer",
          "signature": "a -\u003e Int -\u003e (a, a)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Filter-Recursive-AllpassPoly.html#integrateScrewExp",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Filter Recursive AllpassPoly",
          "module": "Synthesizer.Plain.Filter.Recursive.AllpassPoly",
          "name": "integrateScrewExp",
          "normalized": "a-\u003eInt-\u003e(a,a)",
          "package": "synthesizer",
          "partial": "Screw Exp",
          "signature": "a-\u003eInt-\u003e(a,a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Filter-Recursive-AllpassPoly.html#v:integrateScrewExp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Filter.Recursive.AllpassPoly",
          "name": "makePhase",
          "package": "synthesizer",
          "signature": "Parameter a -\u003e a -\u003e a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Filter-Recursive-AllpassPoly.html#makePhase",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Filter Recursive AllpassPoly",
          "module": "Synthesizer.Plain.Filter.Recursive.AllpassPoly",
          "name": "makePhase",
          "normalized": "Parameter a-\u003ea-\u003ea",
          "package": "synthesizer",
          "partial": "Phase",
          "signature": "Parameter a-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Filter-Recursive-AllpassPoly.html#v:makePhase"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Filter.Recursive.AllpassPoly",
          "name": "scalarProdScrewExp",
          "package": "synthesizer",
          "signature": "a -\u003e Int -\u003e a -\u003e Int -\u003e Int -\u003e a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Filter-Recursive-AllpassPoly.html#scalarProdScrewExp",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Filter Recursive AllpassPoly",
          "module": "Synthesizer.Plain.Filter.Recursive.AllpassPoly",
          "name": "scalarProdScrewExp",
          "normalized": "a-\u003eInt-\u003ea-\u003eInt-\u003eInt-\u003ea",
          "package": "synthesizer",
          "partial": "Prod Screw Exp",
          "signature": "a-\u003eInt-\u003ea-\u003eInt-\u003eInt-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Filter-Recursive-AllpassPoly.html#v:scalarProdScrewExp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Filter.Recursive.AllpassPoly",
          "name": "screwProd",
          "package": "synthesizer",
          "signature": "Int -\u003e a -\u003e Int -\u003e Int -\u003e a -\u003e a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Filter-Recursive-AllpassPoly.html#screwProd",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Filter Recursive AllpassPoly",
          "module": "Synthesizer.Plain.Filter.Recursive.AllpassPoly",
          "name": "screwProd",
          "normalized": "Int-\u003ea-\u003eInt-\u003eInt-\u003ea-\u003ea",
          "package": "synthesizer",
          "partial": "Prod",
          "signature": "Int-\u003ea-\u003eInt-\u003eInt-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Filter-Recursive-AllpassPoly.html#v:screwProd"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Compute coefficients for an allpass that shifts low frequencies\n     by approximately the shift you want.\n     To achieve this we solve a linear least squares problem,\n     where low frequencies are more weighted than high ones.\n     The output is a list of coefficients for an arbitrary order allpass. \n",
          "module": "Synthesizer.Plain.Filter.Recursive.AllpassPoly",
          "name": "shiftParam",
          "package": "synthesizer",
          "signature": "Int -\u003e a -\u003e a -\u003e Parameter a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Filter-Recursive-AllpassPoly.html#shiftParam",
          "type": "function"
        },
        "index": {
          "description": "Compute coefficients for an allpass that shifts low frequencies by approximately the shift you want To achieve this we solve linear least squares problem where low frequencies are more weighted than high ones The output is list of coefficients for an arbitrary order allpass",
          "hierarchy": "Synthesizer Plain Filter Recursive AllpassPoly",
          "module": "Synthesizer.Plain.Filter.Recursive.AllpassPoly",
          "name": "shiftParam",
          "normalized": "Int-\u003ea-\u003ea-\u003eParameter a",
          "package": "synthesizer",
          "partial": "Param",
          "signature": "Int-\u003ea-\u003ea-\u003eParameter a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Filter-Recursive-AllpassPoly.html#v:shiftParam"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Filter.Recursive.Butterworth",
          "name": "Parameter",
          "package": "synthesizer",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Filter-Recursive-Butterworth.html#Parameter",
          "type": "type"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Filter Recursive Butterworth",
          "module": "Synthesizer.Plain.Filter.Recursive.Butterworth",
          "name": "Parameter",
          "package": "synthesizer",
          "partial": "Parameter",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Filter-Recursive-Butterworth.html#t:Parameter"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Filter.Recursive.Butterworth",
          "name": "causal",
          "package": "synthesizer",
          "signature": "Int -\u003e T (Parameter a, v) v",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Filter-Recursive-Butterworth.html#causal",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Filter Recursive Butterworth",
          "module": "Synthesizer.Plain.Filter.Recursive.Butterworth",
          "name": "causal",
          "normalized": "Int-\u003eT(Parameter a,b)b",
          "package": "synthesizer",
          "signature": "Int-\u003eT(Parameter a,v)v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Filter-Recursive-Butterworth.html#v:causal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Filter.Recursive.Butterworth",
          "name": "causalPole",
          "package": "synthesizer",
          "signature": "Passband -\u003e Int -\u003e T (Pole a, v) v",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Filter-Recursive-Butterworth.html#causalPole",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Filter Recursive Butterworth",
          "module": "Synthesizer.Plain.Filter.Recursive.Butterworth",
          "name": "causalPole",
          "normalized": "Passband-\u003eInt-\u003eT(Pole a,b)b",
          "package": "synthesizer",
          "partial": "Pole",
          "signature": "Passband-\u003eInt-\u003eT(Pole a,v)v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Filter-Recursive-Butterworth.html#v:causalPole"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Filter.Recursive.Butterworth",
          "name": "checkedHalf",
          "package": "synthesizer",
          "signature": "String -\u003e Int -\u003e Int",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Filter-Recursive-Butterworth.html#checkedHalf",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Filter Recursive Butterworth",
          "module": "Synthesizer.Plain.Filter.Recursive.Butterworth",
          "name": "checkedHalf",
          "normalized": "String-\u003eInt-\u003eInt",
          "package": "synthesizer",
          "partial": "Half",
          "signature": "String-\u003eInt-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Filter-Recursive-Butterworth.html#v:checkedHalf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Filter.Recursive.Butterworth",
          "name": "highpassCausalPole",
          "package": "synthesizer",
          "signature": "Int -\u003e T (Pole a, v) v",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Filter-Recursive-Butterworth.html#highpassCausalPole",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Filter Recursive Butterworth",
          "module": "Synthesizer.Plain.Filter.Recursive.Butterworth",
          "name": "highpassCausalPole",
          "normalized": "Int-\u003eT(Pole a,b)b",
          "package": "synthesizer",
          "partial": "Causal Pole",
          "signature": "Int-\u003eT(Pole a,v)v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Filter-Recursive-Butterworth.html#v:highpassCausalPole"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Filter.Recursive.Butterworth",
          "name": "highpassPole",
          "package": "synthesizer",
          "signature": "Int -\u003e T a -\u003e T a -\u003e T v -\u003e T v",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Filter-Recursive-Butterworth.html#highpassPole",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Filter Recursive Butterworth",
          "module": "Synthesizer.Plain.Filter.Recursive.Butterworth",
          "name": "highpassPole",
          "normalized": "Int-\u003eT a-\u003eT a-\u003eT b-\u003eT b",
          "package": "synthesizer",
          "partial": "Pole",
          "signature": "Int-\u003eT a-\u003eT a-\u003eT v-\u003eT v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Filter-Recursive-Butterworth.html#v:highpassPole"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Filter.Recursive.Butterworth",
          "name": "lowpassCausalPole",
          "package": "synthesizer",
          "signature": "Int -\u003e T (Pole a, v) v",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Filter-Recursive-Butterworth.html#lowpassCausalPole",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Filter Recursive Butterworth",
          "module": "Synthesizer.Plain.Filter.Recursive.Butterworth",
          "name": "lowpassCausalPole",
          "normalized": "Int-\u003eT(Pole a,b)b",
          "package": "synthesizer",
          "partial": "Causal Pole",
          "signature": "Int-\u003eT(Pole a,v)v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Filter-Recursive-Butterworth.html#v:lowpassCausalPole"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Filter.Recursive.Butterworth",
          "name": "lowpassPole",
          "package": "synthesizer",
          "signature": "Int -\u003e T a -\u003e T a -\u003e T v -\u003e T v",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Filter-Recursive-Butterworth.html#lowpassPole",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Filter Recursive Butterworth",
          "module": "Synthesizer.Plain.Filter.Recursive.Butterworth",
          "name": "lowpassPole",
          "normalized": "Int-\u003eT a-\u003eT a-\u003eT b-\u003eT b",
          "package": "synthesizer",
          "partial": "Pole",
          "signature": "Int-\u003eT a-\u003eT a-\u003eT v-\u003eT v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Filter-Recursive-Butterworth.html#v:lowpassPole"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Filter.Recursive.Butterworth",
          "name": "makeSines",
          "package": "synthesizer",
          "signature": "Int -\u003e [a]",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Filter-Recursive-Butterworth.html#makeSines",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Filter Recursive Butterworth",
          "module": "Synthesizer.Plain.Filter.Recursive.Butterworth",
          "name": "makeSines",
          "normalized": "Int-\u003e[a]",
          "package": "synthesizer",
          "partial": "Sines",
          "signature": "Int-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Filter-Recursive-Butterworth.html#v:makeSines"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Filter.Recursive.Butterworth",
          "name": "modifier",
          "package": "synthesizer",
          "signature": "Int -\u003e Simple (Status v) (Parameter a) v v",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Filter-Recursive-Butterworth.html#modifier",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Filter Recursive Butterworth",
          "module": "Synthesizer.Plain.Filter.Recursive.Butterworth",
          "name": "modifier",
          "normalized": "Int-\u003eSimple(Status a)(Parameter b)a a",
          "package": "synthesizer",
          "signature": "Int-\u003eSimple(Status v)(Parameter a)v v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Filter-Recursive-Butterworth.html#v:modifier"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Filter.Recursive.Butterworth",
          "name": "parameter",
          "package": "synthesizer",
          "signature": "Passband -\u003e Int -\u003e Pole a -\u003e Parameter a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Filter-Recursive-Butterworth.html#parameter",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Filter Recursive Butterworth",
          "module": "Synthesizer.Plain.Filter.Recursive.Butterworth",
          "name": "parameter",
          "normalized": "Passband-\u003eInt-\u003ePole a-\u003eParameter a",
          "package": "synthesizer",
          "signature": "Passband-\u003eInt-\u003ePole a-\u003eParameter a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Filter-Recursive-Butterworth.html#v:parameter"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Filter.Recursive.Butterworth",
          "name": "partialParameter",
          "package": "synthesizer",
          "signature": "a -\u003e a -\u003e a -\u003e Parameter a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Filter-Recursive-Butterworth.html#partialParameter",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Filter Recursive Butterworth",
          "module": "Synthesizer.Plain.Filter.Recursive.Butterworth",
          "name": "partialParameter",
          "normalized": "a-\u003ea-\u003ea-\u003eParameter a",
          "package": "synthesizer",
          "partial": "Parameter",
          "signature": "a-\u003ea-\u003ea-\u003eParameter a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Filter-Recursive-Butterworth.html#v:partialParameter"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Filter.Recursive.Butterworth",
          "name": "partialParameterInstable",
          "package": "synthesizer",
          "signature": "a -\u003e a -\u003e a -\u003e Parameter a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Filter-Recursive-Butterworth.html#partialParameterInstable",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Filter Recursive Butterworth",
          "module": "Synthesizer.Plain.Filter.Recursive.Butterworth",
          "name": "partialParameterInstable",
          "normalized": "a-\u003ea-\u003ea-\u003eParameter a",
          "package": "synthesizer",
          "partial": "Parameter Instable",
          "signature": "a-\u003ea-\u003ea-\u003eParameter a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Filter-Recursive-Butterworth.html#v:partialParameterInstable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Filter.Recursive.Butterworth",
          "name": "partialRatio",
          "package": "synthesizer",
          "signature": "Int -\u003e a -\u003e a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Filter-Recursive-Butterworth.html#partialRatio",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Filter Recursive Butterworth",
          "module": "Synthesizer.Plain.Filter.Recursive.Butterworth",
          "name": "partialRatio",
          "normalized": "Int-\u003ea-\u003ea",
          "package": "synthesizer",
          "partial": "Ratio",
          "signature": "Int-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Filter-Recursive-Butterworth.html#v:partialRatio"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWhen called as \u003ctt\u003erunPole kind order ratio freqs\u003c/tt\u003e,\nthe filter amplifies frequency 0 with factor 1\nand frequency \u003ctt\u003efreq\u003c/tt\u003e with factor \u003ctt\u003eratio\u003c/tt\u003e.\n\u003c/p\u003e\u003cp\u003eIt uses the frequency and ratio information directly\nand thus cannot benefit from efficient parameter interpolation\n(asynchronous run of a ControlledProcess.\n\u003c/p\u003e",
          "module": "Synthesizer.Plain.Filter.Recursive.Butterworth",
          "name": "runPole",
          "package": "synthesizer",
          "signature": "Passband -\u003e Int -\u003e T a -\u003e T a -\u003e T v -\u003e T v",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Filter-Recursive-Butterworth.html#runPole",
          "type": "function"
        },
        "index": {
          "description": "When called as runPole kind order ratio freqs the filter amplifies frequency with factor and frequency freq with factor ratio It uses the frequency and ratio information directly and thus cannot benefit from efficient parameter interpolation asynchronous run of ControlledProcess",
          "hierarchy": "Synthesizer Plain Filter Recursive Butterworth",
          "module": "Synthesizer.Plain.Filter.Recursive.Butterworth",
          "name": "runPole",
          "normalized": "Passband-\u003eInt-\u003eT a-\u003eT a-\u003eT b-\u003eT b",
          "package": "synthesizer",
          "partial": "Pole",
          "signature": "Passband-\u003eInt-\u003eT a-\u003eT a-\u003eT v-\u003eT v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Filter-Recursive-Butterworth.html#v:runPole"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Filter.Recursive.Butterworth",
          "name": "sineList",
          "package": "synthesizer",
          "signature": "a -\u003e [a]",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Filter-Recursive-Butterworth.html#sineList",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Filter Recursive Butterworth",
          "module": "Synthesizer.Plain.Filter.Recursive.Butterworth",
          "name": "sineList",
          "normalized": "a-\u003e[a]",
          "package": "synthesizer",
          "partial": "List",
          "signature": "a-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Filter-Recursive-Butterworth.html#v:sineList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Filter.Recursive.Butterworth",
          "name": "sineListFast",
          "package": "synthesizer",
          "signature": "a -\u003e [a]",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Filter-Recursive-Butterworth.html#sineListFast",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Filter Recursive Butterworth",
          "module": "Synthesizer.Plain.Filter.Recursive.Butterworth",
          "name": "sineListFast",
          "normalized": "a-\u003e[a]",
          "package": "synthesizer",
          "partial": "List Fast",
          "signature": "a-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Filter-Recursive-Butterworth.html#v:sineListFast"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Filter.Recursive.Butterworth",
          "name": "sineListSlow",
          "package": "synthesizer",
          "signature": "a -\u003e [a]",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Filter-Recursive-Butterworth.html#sineListSlow",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Filter Recursive Butterworth",
          "module": "Synthesizer.Plain.Filter.Recursive.Butterworth",
          "name": "sineListSlow",
          "normalized": "a-\u003e[a]",
          "package": "synthesizer",
          "partial": "List Slow",
          "signature": "a-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Filter-Recursive-Butterworth.html#v:sineListSlow"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Filter.Recursive.Chebyshev",
          "name": "ParameterA",
          "package": "synthesizer",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Filter-Recursive-Chebyshev.html#ParameterA",
          "type": "type"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Filter Recursive Chebyshev",
          "module": "Synthesizer.Plain.Filter.Recursive.Chebyshev",
          "name": "ParameterA",
          "package": "synthesizer",
          "partial": "Parameter",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Filter-Recursive-Chebyshev.html#t:ParameterA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Filter.Recursive.Chebyshev",
          "name": "ParameterB",
          "package": "synthesizer",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Filter-Recursive-Chebyshev.html#ParameterB",
          "type": "type"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Filter Recursive Chebyshev",
          "module": "Synthesizer.Plain.Filter.Recursive.Chebyshev",
          "name": "ParameterB",
          "package": "synthesizer",
          "partial": "Parameter",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Filter-Recursive-Chebyshev.html#t:ParameterB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Filter.Recursive.Chebyshev",
          "name": "causalA",
          "package": "synthesizer",
          "signature": "Int -\u003e T (ParameterA a, v) v",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Filter-Recursive-Chebyshev.html#causalA",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Filter Recursive Chebyshev",
          "module": "Synthesizer.Plain.Filter.Recursive.Chebyshev",
          "name": "causalA",
          "normalized": "Int-\u003eT(ParameterA a,b)b",
          "package": "synthesizer",
          "signature": "Int-\u003eT(ParameterA a,v)v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Filter-Recursive-Chebyshev.html#v:causalA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Filter.Recursive.Chebyshev",
          "name": "causalAPole",
          "package": "synthesizer",
          "signature": "Passband -\u003e Int -\u003e T (Pole a, v) v",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Filter-Recursive-Chebyshev.html#causalAPole",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Filter Recursive Chebyshev",
          "module": "Synthesizer.Plain.Filter.Recursive.Chebyshev",
          "name": "causalAPole",
          "normalized": "Passband-\u003eInt-\u003eT(Pole a,b)b",
          "package": "synthesizer",
          "partial": "APole",
          "signature": "Passband-\u003eInt-\u003eT(Pole a,v)v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Filter-Recursive-Chebyshev.html#v:causalAPole"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Filter.Recursive.Chebyshev",
          "name": "causalB",
          "package": "synthesizer",
          "signature": "Int -\u003e T (ParameterB a, v) v",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Filter-Recursive-Chebyshev.html#causalB",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Filter Recursive Chebyshev",
          "module": "Synthesizer.Plain.Filter.Recursive.Chebyshev",
          "name": "causalB",
          "normalized": "Int-\u003eT(ParameterB a,b)b",
          "package": "synthesizer",
          "signature": "Int-\u003eT(ParameterB a,v)v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Filter-Recursive-Chebyshev.html#v:causalB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Filter.Recursive.Chebyshev",
          "name": "causalBPole",
          "package": "synthesizer",
          "signature": "Passband -\u003e Int -\u003e T (Pole a, v) v",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Filter-Recursive-Chebyshev.html#causalBPole",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Filter Recursive Chebyshev",
          "module": "Synthesizer.Plain.Filter.Recursive.Chebyshev",
          "name": "causalBPole",
          "normalized": "Passband-\u003eInt-\u003eT(Pole a,b)b",
          "package": "synthesizer",
          "partial": "BPole",
          "signature": "Passband-\u003eInt-\u003eT(Pole a,v)v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Filter-Recursive-Chebyshev.html#v:causalBPole"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Filter.Recursive.Chebyshev",
          "name": "circleList",
          "package": "synthesizer",
          "signature": "a -\u003e [T a]",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Filter-Recursive-Chebyshev.html#circleList",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Filter Recursive Chebyshev",
          "module": "Synthesizer.Plain.Filter.Recursive.Chebyshev",
          "name": "circleList",
          "normalized": "a-\u003e[T a]",
          "package": "synthesizer",
          "partial": "List",
          "signature": "a-\u003e[T a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Filter-Recursive-Chebyshev.html#v:circleList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Filter.Recursive.Chebyshev",
          "name": "circleListFast",
          "package": "synthesizer",
          "signature": "a -\u003e [T a]",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Filter-Recursive-Chebyshev.html#circleListFast",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Filter Recursive Chebyshev",
          "module": "Synthesizer.Plain.Filter.Recursive.Chebyshev",
          "name": "circleListFast",
          "normalized": "a-\u003e[T a]",
          "package": "synthesizer",
          "partial": "List Fast",
          "signature": "a-\u003e[T a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Filter-Recursive-Chebyshev.html#v:circleListFast"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Filter.Recursive.Chebyshev",
          "name": "circleListSlow",
          "package": "synthesizer",
          "signature": "a -\u003e [T a]",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Filter-Recursive-Chebyshev.html#circleListSlow",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Filter Recursive Chebyshev",
          "module": "Synthesizer.Plain.Filter.Recursive.Chebyshev",
          "name": "circleListSlow",
          "normalized": "a-\u003e[T a]",
          "package": "synthesizer",
          "partial": "List Slow",
          "signature": "a-\u003e[T a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Filter-Recursive-Chebyshev.html#v:circleListSlow"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Filter.Recursive.Chebyshev",
          "name": "highpassACausalPole",
          "package": "synthesizer",
          "signature": "Int -\u003e T (Pole a, v) v",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Filter-Recursive-Chebyshev.html#highpassACausalPole",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Filter Recursive Chebyshev",
          "module": "Synthesizer.Plain.Filter.Recursive.Chebyshev",
          "name": "highpassACausalPole",
          "normalized": "Int-\u003eT(Pole a,b)b",
          "package": "synthesizer",
          "partial": "ACausal Pole",
          "signature": "Int-\u003eT(Pole a,v)v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Filter-Recursive-Chebyshev.html#v:highpassACausalPole"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Filter.Recursive.Chebyshev",
          "name": "highpassAPole",
          "package": "synthesizer",
          "signature": "Int -\u003e T a -\u003e T a -\u003e T v -\u003e T v",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Filter-Recursive-Chebyshev.html#highpassAPole",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Filter Recursive Chebyshev",
          "module": "Synthesizer.Plain.Filter.Recursive.Chebyshev",
          "name": "highpassAPole",
          "normalized": "Int-\u003eT a-\u003eT a-\u003eT b-\u003eT b",
          "package": "synthesizer",
          "partial": "APole",
          "signature": "Int-\u003eT a-\u003eT a-\u003eT v-\u003eT v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Filter-Recursive-Chebyshev.html#v:highpassAPole"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Filter.Recursive.Chebyshev",
          "name": "highpassBCausalPole",
          "package": "synthesizer",
          "signature": "Int -\u003e T (Pole a, v) v",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Filter-Recursive-Chebyshev.html#highpassBCausalPole",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Filter Recursive Chebyshev",
          "module": "Synthesizer.Plain.Filter.Recursive.Chebyshev",
          "name": "highpassBCausalPole",
          "normalized": "Int-\u003eT(Pole a,b)b",
          "package": "synthesizer",
          "partial": "BCausal Pole",
          "signature": "Int-\u003eT(Pole a,v)v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Filter-Recursive-Chebyshev.html#v:highpassBCausalPole"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Filter.Recursive.Chebyshev",
          "name": "highpassBPole",
          "package": "synthesizer",
          "signature": "Int -\u003e T a -\u003e T a -\u003e T v -\u003e T v",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Filter-Recursive-Chebyshev.html#highpassBPole",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Filter Recursive Chebyshev",
          "module": "Synthesizer.Plain.Filter.Recursive.Chebyshev",
          "name": "highpassBPole",
          "normalized": "Int-\u003eT a-\u003eT a-\u003eT b-\u003eT b",
          "package": "synthesizer",
          "partial": "BPole",
          "signature": "Int-\u003eT a-\u003eT a-\u003eT v-\u003eT v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Filter-Recursive-Chebyshev.html#v:highpassBPole"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Filter.Recursive.Chebyshev",
          "name": "lowpassACausalPole",
          "package": "synthesizer",
          "signature": "Int -\u003e T (Pole a, v) v",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Filter-Recursive-Chebyshev.html#lowpassACausalPole",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Filter Recursive Chebyshev",
          "module": "Synthesizer.Plain.Filter.Recursive.Chebyshev",
          "name": "lowpassACausalPole",
          "normalized": "Int-\u003eT(Pole a,b)b",
          "package": "synthesizer",
          "partial": "ACausal Pole",
          "signature": "Int-\u003eT(Pole a,v)v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Filter-Recursive-Chebyshev.html#v:lowpassACausalPole"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Filter.Recursive.Chebyshev",
          "name": "lowpassAPole",
          "package": "synthesizer",
          "signature": "Int -\u003e T a -\u003e T a -\u003e T v -\u003e T v",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Filter-Recursive-Chebyshev.html#lowpassAPole",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Filter Recursive Chebyshev",
          "module": "Synthesizer.Plain.Filter.Recursive.Chebyshev",
          "name": "lowpassAPole",
          "normalized": "Int-\u003eT a-\u003eT a-\u003eT b-\u003eT b",
          "package": "synthesizer",
          "partial": "APole",
          "signature": "Int-\u003eT a-\u003eT a-\u003eT v-\u003eT v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Filter-Recursive-Chebyshev.html#v:lowpassAPole"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Filter.Recursive.Chebyshev",
          "name": "lowpassBCausalPole",
          "package": "synthesizer",
          "signature": "Int -\u003e T (Pole a, v) v",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Filter-Recursive-Chebyshev.html#lowpassBCausalPole",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Filter Recursive Chebyshev",
          "module": "Synthesizer.Plain.Filter.Recursive.Chebyshev",
          "name": "lowpassBCausalPole",
          "normalized": "Int-\u003eT(Pole a,b)b",
          "package": "synthesizer",
          "partial": "BCausal Pole",
          "signature": "Int-\u003eT(Pole a,v)v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Filter-Recursive-Chebyshev.html#v:lowpassBCausalPole"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Filter.Recursive.Chebyshev",
          "name": "lowpassBPole",
          "package": "synthesizer",
          "signature": "Int -\u003e T a -\u003e T a -\u003e T v -\u003e T v",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Filter-Recursive-Chebyshev.html#lowpassBPole",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Filter Recursive Chebyshev",
          "module": "Synthesizer.Plain.Filter.Recursive.Chebyshev",
          "name": "lowpassBPole",
          "normalized": "Int-\u003eT a-\u003eT a-\u003eT b-\u003eT b",
          "package": "synthesizer",
          "partial": "BPole",
          "signature": "Int-\u003eT a-\u003eT a-\u003eT v-\u003eT v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Filter-Recursive-Chebyshev.html#v:lowpassBPole"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Filter.Recursive.Chebyshev",
          "name": "makeCirclePoints",
          "package": "synthesizer",
          "signature": "Int -\u003e [T a]",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Filter-Recursive-Chebyshev.html#makeCirclePoints",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Filter Recursive Chebyshev",
          "module": "Synthesizer.Plain.Filter.Recursive.Chebyshev",
          "name": "makeCirclePoints",
          "normalized": "Int-\u003e[T a]",
          "package": "synthesizer",
          "partial": "Circle Points",
          "signature": "Int-\u003e[T a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Filter-Recursive-Chebyshev.html#v:makeCirclePoints"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Filter.Recursive.Chebyshev",
          "name": "parameterA",
          "package": "synthesizer",
          "signature": "Passband -\u003e Int -\u003e Pole a -\u003e ParameterA a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Filter-Recursive-Chebyshev.html#parameterA",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Filter Recursive Chebyshev",
          "module": "Synthesizer.Plain.Filter.Recursive.Chebyshev",
          "name": "parameterA",
          "normalized": "Passband-\u003eInt-\u003ePole a-\u003eParameterA a",
          "package": "synthesizer",
          "signature": "Passband-\u003eInt-\u003ePole a-\u003eParameterA a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Filter-Recursive-Chebyshev.html#v:parameterA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Filter.Recursive.Chebyshev",
          "name": "parameterB",
          "package": "synthesizer",
          "signature": "Passband -\u003e Int -\u003e Pole a -\u003e ParameterB a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Filter-Recursive-Chebyshev.html#parameterB",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Filter Recursive Chebyshev",
          "module": "Synthesizer.Plain.Filter.Recursive.Chebyshev",
          "name": "parameterB",
          "normalized": "Passband-\u003eInt-\u003ePole a-\u003eParameterB a",
          "package": "synthesizer",
          "signature": "Passband-\u003eInt-\u003ePole a-\u003eParameterB a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Filter-Recursive-Chebyshev.html#v:parameterB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Filter.Recursive.Chebyshev",
          "name": "partialParameterA",
          "package": "synthesizer",
          "signature": "Int -\u003e a -\u003e a -\u003e T a -\u003e Parameter a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Filter-Recursive-Chebyshev.html#partialParameterA",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Filter Recursive Chebyshev",
          "module": "Synthesizer.Plain.Filter.Recursive.Chebyshev",
          "name": "partialParameterA",
          "normalized": "Int-\u003ea-\u003ea-\u003eT a-\u003eParameter a",
          "package": "synthesizer",
          "partial": "Parameter",
          "signature": "Int-\u003ea-\u003ea-\u003eT a-\u003eParameter a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Filter-Recursive-Chebyshev.html#v:partialParameterA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "compute the partial filter of the second order from the pole information\n",
          "module": "Synthesizer.Plain.Filter.Recursive.Chebyshev",
          "name": "partialParameterB",
          "package": "synthesizer",
          "signature": "Int -\u003e a -\u003e a -\u003e T a -\u003e Parameter a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Filter-Recursive-Chebyshev.html#partialParameterB",
          "type": "function"
        },
        "index": {
          "description": "compute the partial filter of the second order from the pole information",
          "hierarchy": "Synthesizer Plain Filter Recursive Chebyshev",
          "module": "Synthesizer.Plain.Filter.Recursive.Chebyshev",
          "name": "partialParameterB",
          "normalized": "Int-\u003ea-\u003ea-\u003eT a-\u003eParameter a",
          "package": "synthesizer",
          "partial": "Parameter",
          "signature": "Int-\u003ea-\u003ea-\u003eT a-\u003eParameter a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Filter-Recursive-Chebyshev.html#v:partialParameterB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Filter.Recursive.Chebyshev",
          "name": "runAPole",
          "package": "synthesizer",
          "signature": "Passband -\u003e Int -\u003e T a -\u003e T a -\u003e T v -\u003e T v",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Filter-Recursive-Chebyshev.html#runAPole",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Filter Recursive Chebyshev",
          "module": "Synthesizer.Plain.Filter.Recursive.Chebyshev",
          "name": "runAPole",
          "normalized": "Passband-\u003eInt-\u003eT a-\u003eT a-\u003eT b-\u003eT b",
          "package": "synthesizer",
          "partial": "APole",
          "signature": "Passband-\u003eInt-\u003eT a-\u003eT a-\u003eT v-\u003eT v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Filter-Recursive-Chebyshev.html#v:runAPole"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Filter.Recursive.Chebyshev",
          "name": "runBPole",
          "package": "synthesizer",
          "signature": "Passband -\u003e Int -\u003e T a -\u003e T a -\u003e T v -\u003e T v",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Filter-Recursive-Chebyshev.html#runBPole",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Filter Recursive Chebyshev",
          "module": "Synthesizer.Plain.Filter.Recursive.Chebyshev",
          "name": "runBPole",
          "normalized": "Passband-\u003eInt-\u003eT a-\u003eT a-\u003eT b-\u003eT b",
          "package": "synthesizer",
          "partial": "BPole",
          "signature": "Passband-\u003eInt-\u003eT a-\u003eT a-\u003eT v-\u003eT v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Filter-Recursive-Chebyshev.html#v:runBPole"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "The most simple version of the Karplus-Strong algorithm\nwhich is suitable to simulate a plucked string.\nIt is similar to the \u003ctt\u003e\u003ca\u003erunProc\u003c/a\u003e\u003c/tt\u003e function.\n",
          "module": "Synthesizer.Plain.Filter.Recursive.Comb",
          "name": "karplusStrong",
          "package": "synthesizer",
          "signature": "Parameter a -\u003e T v -\u003e T v",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Filter-Recursive-Comb.html#karplusStrong",
          "type": "function"
        },
        "index": {
          "description": "The most simple version of the Karplus-Strong algorithm which is suitable to simulate plucked string It is similar to the runProc function",
          "hierarchy": "Synthesizer Plain Filter Recursive Comb",
          "module": "Synthesizer.Plain.Filter.Recursive.Comb",
          "name": "karplusStrong",
          "normalized": "Parameter a-\u003eT b-\u003eT b",
          "package": "synthesizer",
          "partial": "Strong",
          "signature": "Parameter a-\u003eT v-\u003eT v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Filter-Recursive-Comb.html#v:karplusStrong"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Infinitely many equi-delayed exponentially decaying echos.\nThe echos are clipped to the input length.\nWe think it is easier (and simpler to do efficiently)\nto pad the input with zeros or whatever\ninstead of cutting the result according to the input length.\n",
          "module": "Synthesizer.Plain.Filter.Recursive.Comb",
          "name": "run",
          "package": "synthesizer",
          "signature": "Int -\u003e a -\u003e T v -\u003e T v",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Filter-Recursive-Comb.html#run",
          "type": "function"
        },
        "index": {
          "description": "Infinitely many equi-delayed exponentially decaying echos The echos are clipped to the input length We think it is easier and simpler to do efficiently to pad the input with zeros or whatever instead of cutting the result according to the input length",
          "hierarchy": "Synthesizer Plain Filter Recursive Comb",
          "module": "Synthesizer.Plain.Filter.Recursive.Comb",
          "name": "run",
          "normalized": "Int-\u003ea-\u003eT b-\u003eT b",
          "package": "synthesizer",
          "signature": "Int-\u003ea-\u003eT v-\u003eT v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Filter-Recursive-Comb.html#v:run"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Echos of different delays. \n",
          "module": "Synthesizer.Plain.Filter.Recursive.Comb",
          "name": "runMulti",
          "package": "synthesizer",
          "signature": "[Int] -\u003e a -\u003e T v -\u003e T v",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Filter-Recursive-Comb.html#runMulti",
          "type": "function"
        },
        "index": {
          "description": "Echos of different delays",
          "hierarchy": "Synthesizer Plain Filter Recursive Comb",
          "module": "Synthesizer.Plain.Filter.Recursive.Comb",
          "name": "runMulti",
          "normalized": "[Int]-\u003ea-\u003eT b-\u003eT b",
          "package": "synthesizer",
          "partial": "Multi",
          "signature": "[Int]-\u003ea-\u003eT v-\u003eT v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Filter-Recursive-Comb.html#v:runMulti"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Echos can be piped through an arbitrary signal processor. \n",
          "module": "Synthesizer.Plain.Filter.Recursive.Comb",
          "name": "runProc",
          "package": "synthesizer",
          "signature": "Int -\u003e (T v -\u003e T v) -\u003e T v -\u003e T v",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Filter-Recursive-Comb.html#runProc",
          "type": "function"
        },
        "index": {
          "description": "Echos can be piped through an arbitrary signal processor",
          "hierarchy": "Synthesizer Plain Filter Recursive Comb",
          "module": "Synthesizer.Plain.Filter.Recursive.Comb",
          "name": "runProc",
          "normalized": "Int-\u003e(T a-\u003eT a)-\u003eT a-\u003eT a",
          "package": "synthesizer",
          "partial": "Proc",
          "signature": "Int-\u003e(T v-\u003eT v)-\u003eT v-\u003eT v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Filter-Recursive-Comb.html#v:runProc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Filter.Recursive.FirstOrder",
          "name": "Parameter",
          "package": "synthesizer",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Filter-Recursive-FirstOrder.html#Parameter",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Filter Recursive FirstOrder",
          "module": "Synthesizer.Plain.Filter.Recursive.FirstOrder",
          "name": "Parameter",
          "package": "synthesizer",
          "partial": "Parameter",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Filter-Recursive-FirstOrder.html#t:Parameter"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Filter.Recursive.FirstOrder",
          "name": "Result",
          "package": "synthesizer",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Filter-Recursive-FirstOrder.html#Result",
          "type": "data"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Filter Recursive FirstOrder",
          "module": "Synthesizer.Plain.Filter.Recursive.FirstOrder",
          "name": "Result",
          "package": "synthesizer",
          "partial": "Result",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Filter-Recursive-FirstOrder.html#t:Result"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Filter.Recursive.FirstOrder",
          "name": "highpass",
          "package": "synthesizer",
          "signature": "T (Parameter a) -\u003e T v -\u003e T v",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Filter-Recursive-FirstOrder.html#highpass",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Filter Recursive FirstOrder",
          "module": "Synthesizer.Plain.Filter.Recursive.FirstOrder",
          "name": "highpass",
          "normalized": "T(Parameter a)-\u003eT b-\u003eT b",
          "package": "synthesizer",
          "signature": "T(Parameter a)-\u003eT v-\u003eT v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Filter-Recursive-FirstOrder.html#v:highpass"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Filter.Recursive.FirstOrder",
          "name": "highpassInit",
          "package": "synthesizer",
          "signature": "v -\u003e T (Parameter a) -\u003e T v -\u003e T v",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Filter-Recursive-FirstOrder.html#highpassInit",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Filter Recursive FirstOrder",
          "module": "Synthesizer.Plain.Filter.Recursive.FirstOrder",
          "name": "highpassInit",
          "normalized": "a-\u003eT(Parameter b)-\u003eT a-\u003eT a",
          "package": "synthesizer",
          "partial": "Init",
          "signature": "v-\u003eT(Parameter a)-\u003eT v-\u003eT v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Filter-Recursive-FirstOrder.html#v:highpassInit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Filter.Recursive.FirstOrder",
          "name": "highpassInitAlt",
          "package": "synthesizer",
          "signature": "v -\u003e T (Parameter a) -\u003e T v -\u003e T v",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Filter-Recursive-FirstOrder.html#highpassInitAlt",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Filter Recursive FirstOrder",
          "module": "Synthesizer.Plain.Filter.Recursive.FirstOrder",
          "name": "highpassInitAlt",
          "normalized": "a-\u003eT(Parameter b)-\u003eT a-\u003eT a",
          "package": "synthesizer",
          "partial": "Init Alt",
          "signature": "v-\u003eT(Parameter a)-\u003eT v-\u003eT v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Filter-Recursive-FirstOrder.html#v:highpassInitAlt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Filter.Recursive.FirstOrder",
          "name": "highpassModifier",
          "package": "synthesizer",
          "signature": "Simple v (Parameter a) v v",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Filter-Recursive-FirstOrder.html#highpassModifier",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Filter Recursive FirstOrder",
          "module": "Synthesizer.Plain.Filter.Recursive.FirstOrder",
          "name": "highpassModifier",
          "package": "synthesizer",
          "partial": "Modifier",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Filter-Recursive-FirstOrder.html#v:highpassModifier"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Filter.Recursive.FirstOrder",
          "name": "highpassModifierInit",
          "package": "synthesizer",
          "signature": "Initialized v v (Parameter a) v v",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Filter-Recursive-FirstOrder.html#highpassModifierInit",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Filter Recursive FirstOrder",
          "module": "Synthesizer.Plain.Filter.Recursive.FirstOrder",
          "name": "highpassModifierInit",
          "package": "synthesizer",
          "partial": "Modifier Init",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Filter-Recursive-FirstOrder.html#v:highpassModifierInit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Filter.Recursive.FirstOrder",
          "name": "highpassStep",
          "package": "synthesizer",
          "signature": "Parameter a -\u003e v -\u003e State v v",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Filter-Recursive-FirstOrder.html#highpassStep",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Filter Recursive FirstOrder",
          "module": "Synthesizer.Plain.Filter.Recursive.FirstOrder",
          "name": "highpassStep",
          "normalized": "Parameter a-\u003eb-\u003eState b b",
          "package": "synthesizer",
          "partial": "Step",
          "signature": "Parameter a-\u003ev-\u003eState v v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Filter-Recursive-FirstOrder.html#v:highpassStep"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Filter.Recursive.FirstOrder",
          "name": "lowpass",
          "package": "synthesizer",
          "signature": "T (Parameter a) -\u003e T v -\u003e T v",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Filter-Recursive-FirstOrder.html#lowpass",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Filter Recursive FirstOrder",
          "module": "Synthesizer.Plain.Filter.Recursive.FirstOrder",
          "name": "lowpass",
          "normalized": "T(Parameter a)-\u003eT b-\u003eT b",
          "package": "synthesizer",
          "signature": "T(Parameter a)-\u003eT v-\u003eT v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Filter-Recursive-FirstOrder.html#v:lowpass"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Filter.Recursive.FirstOrder",
          "name": "lowpassCausal",
          "package": "synthesizer",
          "signature": "T (Parameter a, v) v",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Filter-Recursive-FirstOrder.html#lowpassCausal",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Filter Recursive FirstOrder",
          "module": "Synthesizer.Plain.Filter.Recursive.FirstOrder",
          "name": "lowpassCausal",
          "normalized": "T(Parameter a,b)b",
          "package": "synthesizer",
          "partial": "Causal",
          "signature": "T(Parameter a,v)v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Filter-Recursive-FirstOrder.html#v:lowpassCausal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Filter.Recursive.FirstOrder",
          "name": "lowpassInit",
          "package": "synthesizer",
          "signature": "v -\u003e T (Parameter a) -\u003e T v -\u003e T v",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Filter-Recursive-FirstOrder.html#lowpassInit",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Filter Recursive FirstOrder",
          "module": "Synthesizer.Plain.Filter.Recursive.FirstOrder",
          "name": "lowpassInit",
          "normalized": "a-\u003eT(Parameter b)-\u003eT a-\u003eT a",
          "package": "synthesizer",
          "partial": "Init",
          "signature": "v-\u003eT(Parameter a)-\u003eT v-\u003eT v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Filter-Recursive-FirstOrder.html#v:lowpassInit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Filter.Recursive.FirstOrder",
          "name": "lowpassModifier",
          "package": "synthesizer",
          "signature": "Simple v (Parameter a) v v",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Filter-Recursive-FirstOrder.html#lowpassModifier",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Filter Recursive FirstOrder",
          "module": "Synthesizer.Plain.Filter.Recursive.FirstOrder",
          "name": "lowpassModifier",
          "package": "synthesizer",
          "partial": "Modifier",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Filter-Recursive-FirstOrder.html#v:lowpassModifier"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Filter.Recursive.FirstOrder",
          "name": "lowpassModifierInit",
          "package": "synthesizer",
          "signature": "Initialized v v (Parameter a) v v",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Filter-Recursive-FirstOrder.html#lowpassModifierInit",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Filter Recursive FirstOrder",
          "module": "Synthesizer.Plain.Filter.Recursive.FirstOrder",
          "name": "lowpassModifierInit",
          "package": "synthesizer",
          "partial": "Modifier Init",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Filter-Recursive-FirstOrder.html#v:lowpassModifierInit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Filter.Recursive.FirstOrder",
          "name": "lowpassStep",
          "package": "synthesizer",
          "signature": "Parameter a -\u003e v -\u003e State v v",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Filter-Recursive-FirstOrder.html#lowpassStep",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Filter Recursive FirstOrder",
          "module": "Synthesizer.Plain.Filter.Recursive.FirstOrder",
          "name": "lowpassStep",
          "normalized": "Parameter a-\u003eb-\u003eState b b",
          "package": "synthesizer",
          "partial": "Step",
          "signature": "Parameter a-\u003ev-\u003eState v v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Filter-Recursive-FirstOrder.html#v:lowpassStep"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Convert cut-off frequency to feedback factor. \n",
          "module": "Synthesizer.Plain.Filter.Recursive.FirstOrder",
          "name": "parameter",
          "package": "synthesizer",
          "signature": "a -\u003e Parameter a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Filter-Recursive-FirstOrder.html#parameter",
          "type": "function"
        },
        "index": {
          "description": "Convert cut-off frequency to feedback factor",
          "hierarchy": "Synthesizer Plain Filter Recursive FirstOrder",
          "module": "Synthesizer.Plain.Filter.Recursive.FirstOrder",
          "name": "parameter",
          "normalized": "a-\u003eParameter a",
          "package": "synthesizer",
          "signature": "a-\u003eParameter a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Filter-Recursive-FirstOrder.html#v:parameter"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Filter.Recursive.FirstOrder",
          "name": "step",
          "package": "synthesizer",
          "signature": "Parameter a -\u003e v -\u003e State v (Result v)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Filter-Recursive-FirstOrder.html#step",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Filter Recursive FirstOrder",
          "module": "Synthesizer.Plain.Filter.Recursive.FirstOrder",
          "name": "step",
          "normalized": "Parameter a-\u003eb-\u003eState b(Result b)",
          "package": "synthesizer",
          "signature": "Parameter a-\u003ev-\u003eState v(Result v)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Filter-Recursive-FirstOrder.html#v:step"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Filter.Recursive.FirstOrderComplex",
          "name": "Parameter",
          "package": "synthesizer",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Filter-Recursive-FirstOrderComplex.html#Parameter",
          "type": "data"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Filter Recursive FirstOrderComplex",
          "module": "Synthesizer.Plain.Filter.Recursive.FirstOrderComplex",
          "name": "Parameter",
          "package": "synthesizer",
          "partial": "Parameter",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Filter-Recursive-FirstOrderComplex.html#t:Parameter"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Filter.Recursive.FirstOrderComplex",
          "name": "causal",
          "package": "synthesizer",
          "signature": "T (Parameter a, v) (Result v)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Filter-Recursive-FirstOrderComplex.html#causal",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Filter Recursive FirstOrderComplex",
          "module": "Synthesizer.Plain.Filter.Recursive.FirstOrderComplex",
          "name": "causal",
          "normalized": "T(Parameter a,b)(Result b)",
          "package": "synthesizer",
          "signature": "T(Parameter a,v)(Result v)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Filter-Recursive-FirstOrderComplex.html#v:causal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Filter.Recursive.FirstOrderComplex",
          "name": "modifier",
          "package": "synthesizer",
          "signature": "Simple (T v) (Parameter a) v (Result v)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Filter-Recursive-FirstOrderComplex.html#modifier",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Filter Recursive FirstOrderComplex",
          "module": "Synthesizer.Plain.Filter.Recursive.FirstOrderComplex",
          "name": "modifier",
          "package": "synthesizer",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Filter-Recursive-FirstOrderComplex.html#v:modifier"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Filter.Recursive.FirstOrderComplex",
          "name": "modifierInit",
          "package": "synthesizer",
          "signature": "Initialized (T v) (T v) (Parameter a) v (Result v)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Filter-Recursive-FirstOrderComplex.html#modifierInit",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Filter Recursive FirstOrderComplex",
          "module": "Synthesizer.Plain.Filter.Recursive.FirstOrderComplex",
          "name": "modifierInit",
          "package": "synthesizer",
          "partial": "Init",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Filter-Recursive-FirstOrderComplex.html#v:modifierInit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe internal parameters are computed such that:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e At the resonance frequency\n  the filter amplifies by the factor \u003ctt\u003eresonance\u003c/tt\u003e\n  with no phase shift.\n\u003c/li\u003e\u003cli\u003e At resonance frequency plus half sample rate\n  the filter amplifies by facter \u003ctt\u003erecip $ 2 - recip resonance\u003c/tt\u003e\n  with no phase shift,\n  but you cannot observe this immediately,\n  because it is outside the Nyquist band.\n\u003c/li\u003e\u003c/ul\u003e",
          "module": "Synthesizer.Plain.Filter.Recursive.FirstOrderComplex",
          "name": "parameter",
          "package": "synthesizer",
          "signature": "Pole a -\u003e Parameter a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Filter-Recursive-FirstOrderComplex.html#parameter",
          "type": "function"
        },
        "index": {
          "description": "The internal parameters are computed such that At the resonance frequency the filter amplifies by the factor resonance with no phase shift At resonance frequency plus half sample rate the filter amplifies by facter recip recip resonance with no phase shift but you cannot observe this immediately because it is outside the Nyquist band",
          "hierarchy": "Synthesizer Plain Filter Recursive FirstOrderComplex",
          "module": "Synthesizer.Plain.Filter.Recursive.FirstOrderComplex",
          "name": "parameter",
          "normalized": "Pole a-\u003eParameter a",
          "package": "synthesizer",
          "signature": "Pole a-\u003eParameter a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Filter-Recursive-FirstOrderComplex.html#v:parameter"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe internal parameters are computed such that:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e At the resonance frequency\n  the filter amplifies by the factor \u003ctt\u003eresonance\u003c/tt\u003e\n  with a non-zero phase shift.\n\u003c/li\u003e\u003cli\u003e The filter amplifies the direct current (frequency zero) by factor 1\n  with no phase shift.\n\u003c/li\u003e\u003cli\u003e The real component is a lowpass,\n  the imaginary component is a highpass.\n  You can interpolate between them using other complex projections.\n\u003c/li\u003e\u003c/ul\u003e",
          "module": "Synthesizer.Plain.Filter.Recursive.FirstOrderComplex",
          "name": "parameterFromPeakToDCRatio",
          "package": "synthesizer",
          "signature": "Pole a -\u003e Parameter a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Filter-Recursive-FirstOrderComplex.html#parameterFromPeakToDCRatio",
          "type": "function"
        },
        "index": {
          "description": "The internal parameters are computed such that At the resonance frequency the filter amplifies by the factor resonance with non-zero phase shift The filter amplifies the direct current frequency zero by factor with no phase shift The real component is lowpass the imaginary component is highpass You can interpolate between them using other complex projections",
          "hierarchy": "Synthesizer Plain Filter Recursive FirstOrderComplex",
          "module": "Synthesizer.Plain.Filter.Recursive.FirstOrderComplex",
          "name": "parameterFromPeakToDCRatio",
          "normalized": "Pole a-\u003eParameter a",
          "package": "synthesizer",
          "partial": "From Peak To DCRatio",
          "signature": "Pole a-\u003eParameter a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Filter-Recursive-FirstOrderComplex.html#v:parameterFromPeakToDCRatio"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe internal parameters are computed such that:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e At the resonance frequency\n  the filter amplifies by the factor \u003ctt\u003eresonance\u003c/tt\u003e\n  with no phase shift.\n\u003c/li\u003e\u003cli\u003e At resonance frequency plus and minus band width\n  the filter amplifies by facter 1 with a non-zero phase shift.\n\u003c/li\u003e\u003c/ul\u003e",
          "module": "Synthesizer.Plain.Filter.Recursive.FirstOrderComplex",
          "name": "parameterFromPeakWidth",
          "package": "synthesizer",
          "signature": "a -\u003e Pole a -\u003e Parameter a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Filter-Recursive-FirstOrderComplex.html#parameterFromPeakWidth",
          "type": "function"
        },
        "index": {
          "description": "The internal parameters are computed such that At the resonance frequency the filter amplifies by the factor resonance with no phase shift At resonance frequency plus and minus band width the filter amplifies by facter with non-zero phase shift",
          "hierarchy": "Synthesizer Plain Filter Recursive FirstOrderComplex",
          "module": "Synthesizer.Plain.Filter.Recursive.FirstOrderComplex",
          "name": "parameterFromPeakWidth",
          "normalized": "a-\u003ePole a-\u003eParameter a",
          "package": "synthesizer",
          "partial": "From Peak Width",
          "signature": "a-\u003ePole a-\u003eParameter a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Filter-Recursive-FirstOrderComplex.html#v:parameterFromPeakWidth"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Filter.Recursive.FirstOrderComplex",
          "name": "run",
          "package": "synthesizer",
          "signature": "T (Parameter a) -\u003e T v -\u003e T (Result v)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Filter-Recursive-FirstOrderComplex.html#run",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Filter Recursive FirstOrderComplex",
          "module": "Synthesizer.Plain.Filter.Recursive.FirstOrderComplex",
          "name": "run",
          "normalized": "T(Parameter a)-\u003eT b-\u003eT(Result b)",
          "package": "synthesizer",
          "signature": "T(Parameter a)-\u003eT v-\u003eT(Result v)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Filter-Recursive-FirstOrderComplex.html#v:run"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Filter.Recursive.FirstOrderComplex",
          "name": "runInit",
          "package": "synthesizer",
          "signature": "T v -\u003e T (Parameter a) -\u003e T v -\u003e T (Result v)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Filter-Recursive-FirstOrderComplex.html#runInit",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Filter Recursive FirstOrderComplex",
          "module": "Synthesizer.Plain.Filter.Recursive.FirstOrderComplex",
          "name": "runInit",
          "normalized": "T a-\u003eT(Parameter b)-\u003eT a-\u003eT(Result a)",
          "package": "synthesizer",
          "partial": "Init",
          "signature": "T v-\u003eT(Parameter a)-\u003eT v-\u003eT(Result v)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Filter-Recursive-FirstOrderComplex.html#v:runInit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Universal filter: Computes high pass, band pass, low pass in one go \n",
          "module": "Synthesizer.Plain.Filter.Recursive.FirstOrderComplex",
          "name": "step",
          "package": "synthesizer",
          "signature": "Parameter a -\u003e v -\u003e State (T v) (Result v)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Filter-Recursive-FirstOrderComplex.html#step",
          "type": "function"
        },
        "index": {
          "description": "Universal filter Computes high pass band pass low pass in one go",
          "hierarchy": "Synthesizer Plain Filter Recursive FirstOrderComplex",
          "module": "Synthesizer.Plain.Filter.Recursive.FirstOrderComplex",
          "name": "step",
          "normalized": "Parameter a-\u003eb-\u003eState(T b)(Result b)",
          "package": "synthesizer",
          "signature": "Parameter a-\u003ev-\u003eState(T v)(Result v)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Filter-Recursive-FirstOrderComplex.html#v:step"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Integrate with initial value zero.\nHowever the first emitted value is the value of the input signal.\nIt maintains the length of the signal.\n",
          "module": "Synthesizer.Plain.Filter.Recursive.Integration",
          "name": "run",
          "package": "synthesizer",
          "signature": "T v -\u003e T v",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Filter-Recursive-Integration.html#run",
          "type": "function"
        },
        "index": {
          "description": "Integrate with initial value zero However the first emitted value is the value of the input signal It maintains the length of the signal",
          "hierarchy": "Synthesizer Plain Filter Recursive Integration",
          "module": "Synthesizer.Plain.Filter.Recursive.Integration",
          "name": "run",
          "normalized": "T a-\u003eT a",
          "package": "synthesizer",
          "signature": "T v-\u003eT v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Filter-Recursive-Integration.html#v:run"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Integrate with initial condition.\nFirst emitted value is the initial condition.\nThe signal become one element longer.\n",
          "module": "Synthesizer.Plain.Filter.Recursive.Integration",
          "name": "runInit",
          "package": "synthesizer",
          "signature": "v -\u003e T v -\u003e T v",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Filter-Recursive-Integration.html#runInit",
          "type": "function"
        },
        "index": {
          "description": "Integrate with initial condition First emitted value is the initial condition The signal become one element longer",
          "hierarchy": "Synthesizer Plain Filter Recursive Integration",
          "module": "Synthesizer.Plain.Filter.Recursive.Integration",
          "name": "runInit",
          "normalized": "a-\u003eT a-\u003eT a",
          "package": "synthesizer",
          "partial": "Init",
          "signature": "v-\u003eT v-\u003eT v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Filter-Recursive-Integration.html#v:runInit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Filter.Recursive.Moog",
          "name": "Parameter",
          "package": "synthesizer",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Filter-Recursive-Moog.html#Parameter",
          "type": "data"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Filter Recursive Moog",
          "module": "Synthesizer.Plain.Filter.Recursive.Moog",
          "name": "Parameter",
          "package": "synthesizer",
          "partial": "Parameter",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Filter-Recursive-Moog.html#t:Parameter"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Filter.Recursive.Moog",
          "name": "lowpass",
          "package": "synthesizer",
          "signature": "Int -\u003e T (Parameter a) -\u003e T v -\u003e T v",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Filter-Recursive-Moog.html#lowpass",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Filter Recursive Moog",
          "module": "Synthesizer.Plain.Filter.Recursive.Moog",
          "name": "lowpass",
          "normalized": "Int-\u003eT(Parameter a)-\u003eT b-\u003eT b",
          "package": "synthesizer",
          "signature": "Int-\u003eT(Parameter a)-\u003eT v-\u003eT v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Filter-Recursive-Moog.html#v:lowpass"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Filter.Recursive.Moog",
          "name": "lowpassCausal",
          "package": "synthesizer",
          "signature": "Int -\u003e T (Parameter a, v) v",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Filter-Recursive-Moog.html#lowpassCausal",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Filter Recursive Moog",
          "module": "Synthesizer.Plain.Filter.Recursive.Moog",
          "name": "lowpassCausal",
          "normalized": "Int-\u003eT(Parameter a,b)b",
          "package": "synthesizer",
          "partial": "Causal",
          "signature": "Int-\u003eT(Parameter a,v)v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Filter-Recursive-Moog.html#v:lowpassCausal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Filter.Recursive.Moog",
          "name": "lowpassCausalModifier",
          "package": "synthesizer",
          "signature": "Int -\u003e T (Parameter a, v) v",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Filter-Recursive-Moog.html#lowpassCausalModifier",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Filter Recursive Moog",
          "module": "Synthesizer.Plain.Filter.Recursive.Moog",
          "name": "lowpassCausalModifier",
          "normalized": "Int-\u003eT(Parameter a,b)b",
          "package": "synthesizer",
          "partial": "Causal Modifier",
          "signature": "Int-\u003eT(Parameter a,v)v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Filter-Recursive-Moog.html#v:lowpassCausalModifier"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Filter.Recursive.Moog",
          "name": "lowpassCausalStacked",
          "package": "synthesizer",
          "signature": "Int -\u003e T (Parameter a, v) v",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Filter-Recursive-Moog.html#lowpassCausalStacked",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Filter Recursive Moog",
          "module": "Synthesizer.Plain.Filter.Recursive.Moog",
          "name": "lowpassCausalStacked",
          "normalized": "Int-\u003eT(Parameter a,b)b",
          "package": "synthesizer",
          "partial": "Causal Stacked",
          "signature": "Int-\u003eT(Parameter a,v)v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Filter-Recursive-Moog.html#v:lowpassCausalStacked"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Filter.Recursive.Moog",
          "name": "lowpassModifier",
          "package": "synthesizer",
          "signature": "Int -\u003e Simple [v] (Parameter a) v v",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Filter-Recursive-Moog.html#lowpassModifier",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Filter Recursive Moog",
          "module": "Synthesizer.Plain.Filter.Recursive.Moog",
          "name": "lowpassModifier",
          "normalized": "Int-\u003eSimple[a](Parameter b)a a",
          "package": "synthesizer",
          "partial": "Modifier",
          "signature": "Int-\u003eSimple[v](Parameter a)v v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Filter-Recursive-Moog.html#v:lowpassModifier"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Filter.Recursive.Moog",
          "name": "lowpassRecursive",
          "package": "synthesizer",
          "signature": "Int -\u003e T (Parameter a) -\u003e T v -\u003e T v",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Filter-Recursive-Moog.html#lowpassRecursive",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Filter Recursive Moog",
          "module": "Synthesizer.Plain.Filter.Recursive.Moog",
          "name": "lowpassRecursive",
          "normalized": "Int-\u003eT(Parameter a)-\u003eT b-\u003eT b",
          "package": "synthesizer",
          "partial": "Recursive",
          "signature": "Int-\u003eT(Parameter a)-\u003eT v-\u003eT v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Filter-Recursive-Moog.html#v:lowpassRecursive"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Filter.Recursive.Moog",
          "name": "lowpassState",
          "package": "synthesizer",
          "signature": "Int -\u003e T (Parameter a) -\u003e T v -\u003e T v",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Filter-Recursive-Moog.html#lowpassState",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Filter Recursive Moog",
          "module": "Synthesizer.Plain.Filter.Recursive.Moog",
          "name": "lowpassState",
          "normalized": "Int-\u003eT(Parameter a)-\u003eT b-\u003eT b",
          "package": "synthesizer",
          "partial": "State",
          "signature": "Int-\u003eT(Parameter a)-\u003eT v-\u003eT v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Filter-Recursive-Moog.html#v:lowpassState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Filter.Recursive.Moog",
          "name": "lowpassStepRev",
          "package": "synthesizer",
          "signature": "Parameter a -\u003e v -\u003e State [v] v",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Filter-Recursive-Moog.html#lowpassStepRev",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Filter Recursive Moog",
          "module": "Synthesizer.Plain.Filter.Recursive.Moog",
          "name": "lowpassStepRev",
          "normalized": "Parameter a-\u003eb-\u003eState[b]b",
          "package": "synthesizer",
          "partial": "Step Rev",
          "signature": "Parameter a-\u003ev-\u003eState[v]v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Filter-Recursive-Moog.html#v:lowpassStepRev"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Filter.Recursive.Moog",
          "name": "lowpassStepStack",
          "package": "synthesizer",
          "signature": "Parameter a -\u003e v -\u003e State [v] v",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Filter-Recursive-Moog.html#lowpassStepStack",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Filter Recursive Moog",
          "module": "Synthesizer.Plain.Filter.Recursive.Moog",
          "name": "lowpassStepStack",
          "normalized": "Parameter a-\u003eb-\u003eState[b]b",
          "package": "synthesizer",
          "partial": "Step Stack",
          "signature": "Parameter a-\u003ev-\u003eState[v]v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Filter-Recursive-Moog.html#v:lowpassStepStack"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Filter.Recursive.Moog",
          "name": "parameter",
          "package": "synthesizer",
          "signature": "Int -\u003e Pole a -\u003e Parameter a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Filter-Recursive-Moog.html#parameter",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Filter Recursive Moog",
          "module": "Synthesizer.Plain.Filter.Recursive.Moog",
          "name": "parameter",
          "normalized": "Int-\u003ePole a-\u003eParameter a",
          "package": "synthesizer",
          "signature": "Int-\u003ePole a-\u003eParameter a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Filter-Recursive-Moog.html#v:parameter"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Filter.Recursive.MovingAverage",
          "name": "modulatedFrac",
          "package": "synthesizer",
          "signature": "Int -\u003e T a -\u003e T v -\u003e T v",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Filter-Recursive-MovingAverage.html#modulatedFrac",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Filter Recursive MovingAverage",
          "module": "Synthesizer.Plain.Filter.Recursive.MovingAverage",
          "name": "modulatedFrac",
          "normalized": "Int-\u003eT a-\u003eT b-\u003eT b",
          "package": "synthesizer",
          "partial": "Frac",
          "signature": "Int-\u003eT a-\u003eT v-\u003eT v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Filter-Recursive-MovingAverage.html#v:modulatedFrac"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLike Synthesizer.Plain.Filter.NonRecursive.sums but in a recursive form.\nThis needs only linear time (independent of the window size)\nbut may accumulate rounding errors.\n\u003c/p\u003e\u003cpre\u003e\nys = xs * (1,0,0,0,-1) / (1,-1)\nys * (1,-1) = xs * (1,0,0,0,-1)\nys = xs * (1,0,0,0,-1) + ys * (0,1)\n\u003c/pre\u003e",
          "module": "Synthesizer.Plain.Filter.Recursive.MovingAverage",
          "name": "sumsStaticInt",
          "package": "synthesizer",
          "signature": "Int -\u003e T v -\u003e T v",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Filter-Recursive-MovingAverage.html#sumsStaticInt",
          "type": "function"
        },
        "index": {
          "description": "Like Synthesizer.Plain.Filter.NonRecursive.sums but in recursive form This needs only linear time independent of the window size but may accumulate rounding errors ys xs ys xs ys xs ys",
          "hierarchy": "Synthesizer Plain Filter Recursive MovingAverage",
          "module": "Synthesizer.Plain.Filter.Recursive.MovingAverage",
          "name": "sumsStaticInt",
          "normalized": "Int-\u003eT a-\u003eT a",
          "package": "synthesizer",
          "partial": "Static Int",
          "signature": "Int-\u003eT v-\u003eT v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Filter-Recursive-MovingAverage.html#v:sumsStaticInt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Filter.Recursive.SecondOrder",
          "name": "Parameter",
          "package": "synthesizer",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Filter-Recursive-SecondOrder.html#Parameter",
          "type": "data"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Filter Recursive SecondOrder",
          "module": "Synthesizer.Plain.Filter.Recursive.SecondOrder",
          "name": "Parameter",
          "package": "synthesizer",
          "partial": "Parameter",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Filter-Recursive-SecondOrder.html#t:Parameter"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Filter.Recursive.SecondOrder",
          "name": "Status",
          "package": "synthesizer",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Filter-Recursive-SecondOrder.html#Status",
          "type": "data"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Filter Recursive SecondOrder",
          "module": "Synthesizer.Plain.Filter.Recursive.SecondOrder",
          "name": "Status",
          "package": "synthesizer",
          "partial": "Status",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Filter-Recursive-SecondOrder.html#t:Status"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Given a function which computes the filter parameters of a lowpass filter\nfor a given frequency,\nturn that into a function which generates highpass parameters,\nif requested filter type is Highpass.\n",
          "module": "Synthesizer.Plain.Filter.Recursive.SecondOrder",
          "name": "adjustPassband",
          "package": "synthesizer",
          "signature": "Passband -\u003e (a -\u003e Parameter a) -\u003e a -\u003e Parameter a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Filter-Recursive-SecondOrder.html#adjustPassband",
          "type": "function"
        },
        "index": {
          "description": "Given function which computes the filter parameters of lowpass filter for given frequency turn that into function which generates highpass parameters if requested filter type is Highpass",
          "hierarchy": "Synthesizer Plain Filter Recursive SecondOrder",
          "module": "Synthesizer.Plain.Filter.Recursive.SecondOrder",
          "name": "adjustPassband",
          "normalized": "Passband-\u003e(a-\u003eParameter a)-\u003ea-\u003eParameter a",
          "package": "synthesizer",
          "partial": "Passband",
          "signature": "Passband-\u003e(a-\u003eParameter a)-\u003ea-\u003eParameter a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Filter-Recursive-SecondOrder.html#v:adjustPassband"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Filter.Recursive.SecondOrder",
          "name": "causal",
          "package": "synthesizer",
          "signature": "T (Parameter a, v) v",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Filter-Recursive-SecondOrder.html#causal",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Filter Recursive SecondOrder",
          "module": "Synthesizer.Plain.Filter.Recursive.SecondOrder",
          "name": "causal",
          "normalized": "T(Parameter a,b)b",
          "package": "synthesizer",
          "signature": "T(Parameter a,v)v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Filter-Recursive-SecondOrder.html#v:causal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Filter.Recursive.SecondOrder",
          "name": "modifier",
          "package": "synthesizer",
          "signature": "Simple (Status v) (Parameter a) v v",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Filter-Recursive-SecondOrder.html#modifier",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Filter Recursive SecondOrder",
          "module": "Synthesizer.Plain.Filter.Recursive.SecondOrder",
          "name": "modifier",
          "package": "synthesizer",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Filter-Recursive-SecondOrder.html#v:modifier"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Filter.Recursive.SecondOrder",
          "name": "modifierInit",
          "package": "synthesizer",
          "signature": "Initialized (Status v) (Status v) (Parameter a) v v",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Filter-Recursive-SecondOrder.html#modifierInit",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Filter Recursive SecondOrder",
          "module": "Synthesizer.Plain.Filter.Recursive.SecondOrder",
          "name": "modifierInit",
          "package": "synthesizer",
          "partial": "Init",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Filter-Recursive-SecondOrder.html#v:modifierInit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Filter.Recursive.SecondOrder",
          "name": "run",
          "package": "synthesizer",
          "signature": "T (Parameter a) -\u003e T v -\u003e T v",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Filter-Recursive-SecondOrder.html#run",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Filter Recursive SecondOrder",
          "module": "Synthesizer.Plain.Filter.Recursive.SecondOrder",
          "name": "run",
          "normalized": "T(Parameter a)-\u003eT b-\u003eT b",
          "package": "synthesizer",
          "signature": "T(Parameter a)-\u003eT v-\u003eT v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Filter-Recursive-SecondOrder.html#v:run"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Filter.Recursive.SecondOrder",
          "name": "runInit",
          "package": "synthesizer",
          "signature": "Status v -\u003e T (Parameter a) -\u003e T v -\u003e T v",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Filter-Recursive-SecondOrder.html#runInit",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Filter Recursive SecondOrder",
          "module": "Synthesizer.Plain.Filter.Recursive.SecondOrder",
          "name": "runInit",
          "normalized": "Status a-\u003eT(Parameter b)-\u003eT a-\u003eT a",
          "package": "synthesizer",
          "partial": "Init",
          "signature": "Status v-\u003eT(Parameter a)-\u003eT v-\u003eT v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Filter-Recursive-SecondOrder.html#v:runInit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Filter.Recursive.SecondOrder",
          "name": "step",
          "package": "synthesizer",
          "signature": "Parameter a -\u003e v -\u003e State (Status v) v",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Filter-Recursive-SecondOrder.html#step",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Filter Recursive SecondOrder",
          "module": "Synthesizer.Plain.Filter.Recursive.SecondOrder",
          "name": "step",
          "normalized": "Parameter a-\u003eb-\u003eState(Status b)b",
          "package": "synthesizer",
          "signature": "Parameter a-\u003ev-\u003eState(Status v)v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Filter-Recursive-SecondOrder.html#v:step"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Filter.Recursive.SecondOrder",
          "name": "storeParameter",
          "package": "synthesizer",
          "signature": "Dictionary (Parameter a)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Filter-Recursive-SecondOrder.html#storeParameter",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Filter Recursive SecondOrder",
          "module": "Synthesizer.Plain.Filter.Recursive.SecondOrder",
          "name": "storeParameter",
          "package": "synthesizer",
          "partial": "Parameter",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Filter-Recursive-SecondOrder.html#v:storeParameter"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Filter.Recursive.SecondOrder",
          "name": "storeStatus",
          "package": "synthesizer",
          "signature": "Dictionary (Status a)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Filter-Recursive-SecondOrder.html#storeStatus",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Filter Recursive SecondOrder",
          "module": "Synthesizer.Plain.Filter.Recursive.SecondOrder",
          "name": "storeStatus",
          "package": "synthesizer",
          "partial": "Status",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Filter-Recursive-SecondOrder.html#v:storeStatus"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Filter.Recursive.SecondOrder",
          "name": "zeroStatus",
          "package": "synthesizer",
          "signature": "Status a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Filter-Recursive-SecondOrder.html#zeroStatus",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Filter Recursive SecondOrder",
          "module": "Synthesizer.Plain.Filter.Recursive.SecondOrder",
          "name": "zeroStatus",
          "package": "synthesizer",
          "partial": "Status",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Filter-Recursive-SecondOrder.html#v:zeroStatus"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Filter.Recursive.SecondOrderCascade",
          "name": "Parameter",
          "package": "synthesizer",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Filter-Recursive-SecondOrderCascade.html#Parameter",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Filter Recursive SecondOrderCascade",
          "module": "Synthesizer.Plain.Filter.Recursive.SecondOrderCascade",
          "name": "Parameter",
          "package": "synthesizer",
          "partial": "Parameter",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Filter-Recursive-SecondOrderCascade.html#t:Parameter"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Filter.Recursive.SecondOrderCascade",
          "name": "Status",
          "package": "synthesizer",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Filter-Recursive-SecondOrderCascade.html#Status",
          "type": "type"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Filter Recursive SecondOrderCascade",
          "module": "Synthesizer.Plain.Filter.Recursive.SecondOrderCascade",
          "name": "Status",
          "package": "synthesizer",
          "partial": "Status",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Filter-Recursive-SecondOrderCascade.html#t:Status"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Filter.Recursive.SecondOrderCascade",
          "name": "causal",
          "package": "synthesizer",
          "signature": "Int -\u003e T (Parameter a, v) v",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Filter-Recursive-SecondOrderCascade.html#causal",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Filter Recursive SecondOrderCascade",
          "module": "Synthesizer.Plain.Filter.Recursive.SecondOrderCascade",
          "name": "causal",
          "normalized": "Int-\u003eT(Parameter a,b)b",
          "package": "synthesizer",
          "signature": "Int-\u003eT(Parameter a,v)v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Filter-Recursive-SecondOrderCascade.html#v:causal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Filter.Recursive.SecondOrderCascade",
          "name": "checkSizes",
          "package": "synthesizer",
          "signature": "String -\u003e Vector a -\u003e Vector b -\u003e c -\u003e c",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Filter-Recursive-SecondOrderCascade.html#checkSizes",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Filter Recursive SecondOrderCascade",
          "module": "Synthesizer.Plain.Filter.Recursive.SecondOrderCascade",
          "name": "checkSizes",
          "normalized": "String-\u003eVector a-\u003eVector b-\u003ec-\u003ec",
          "package": "synthesizer",
          "partial": "Sizes",
          "signature": "String-\u003eVector a-\u003eVector b-\u003ec-\u003ec",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Filter-Recursive-SecondOrderCascade.html#v:checkSizes"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Filter.Recursive.SecondOrderCascade",
          "name": "modifier",
          "package": "synthesizer",
          "signature": "Int -\u003e Simple (Status v) (Parameter a) v v",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Filter-Recursive-SecondOrderCascade.html#modifier",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Filter Recursive SecondOrderCascade",
          "module": "Synthesizer.Plain.Filter.Recursive.SecondOrderCascade",
          "name": "modifier",
          "normalized": "Int-\u003eSimple(Status a)(Parameter b)a a",
          "package": "synthesizer",
          "signature": "Int-\u003eSimple(Status v)(Parameter a)v v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Filter-Recursive-SecondOrderCascade.html#v:modifier"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Filter.Recursive.SecondOrderCascade",
          "name": "modifierInit",
          "package": "synthesizer",
          "signature": "Initialized (Status v) (Status v) (Parameter a) v v",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Filter-Recursive-SecondOrderCascade.html#modifierInit",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Filter Recursive SecondOrderCascade",
          "module": "Synthesizer.Plain.Filter.Recursive.SecondOrderCascade",
          "name": "modifierInit",
          "package": "synthesizer",
          "partial": "Init",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Filter-Recursive-SecondOrderCascade.html#v:modifierInit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Filter.Recursive.SecondOrderCascade",
          "name": "step",
          "package": "synthesizer",
          "signature": "Parameter a -\u003e v -\u003e State (Status v) v",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Filter-Recursive-SecondOrderCascade.html#step",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Filter Recursive SecondOrderCascade",
          "module": "Synthesizer.Plain.Filter.Recursive.SecondOrderCascade",
          "name": "step",
          "normalized": "Parameter a-\u003eb-\u003eState(Status b)b",
          "package": "synthesizer",
          "signature": "Parameter a-\u003ev-\u003eState(Status v)v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Filter-Recursive-SecondOrderCascade.html#v:step"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Filter.Recursive.SecondOrderCascade",
          "name": "withSizeCheck",
          "package": "synthesizer",
          "signature": "String -\u003e (Vector a -\u003e Vector b -\u003e c) -\u003e Vector a -\u003e Vector b -\u003e c",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Filter-Recursive-SecondOrderCascade.html#withSizeCheck",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Filter Recursive SecondOrderCascade",
          "module": "Synthesizer.Plain.Filter.Recursive.SecondOrderCascade",
          "name": "withSizeCheck",
          "normalized": "String-\u003e(Vector a-\u003eVector b-\u003ec)-\u003eVector a-\u003eVector b-\u003ec",
          "package": "synthesizer",
          "partial": "Size Check",
          "signature": "String-\u003e(Vector a-\u003eVector b-\u003ec)-\u003eVector a-\u003eVector b-\u003ec",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Filter-Recursive-SecondOrderCascade.html#v:withSizeCheck"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Filter.Recursive.Test",
          "name": "butterworthLowpassTest0",
          "package": "synthesizer",
          "signature": "[Double]",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Filter-Recursive-Test.html#butterworthLowpassTest0",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Filter Recursive Test",
          "module": "Synthesizer.Plain.Filter.Recursive.Test",
          "name": "butterworthLowpassTest0",
          "normalized": "[Double]",
          "package": "synthesizer",
          "partial": "Lowpass Test",
          "signature": "[Double]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Filter-Recursive-Test.html#v:butterworthLowpassTest0"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Filter.Recursive.Test",
          "name": "butterworthLowpassTest1",
          "package": "synthesizer",
          "signature": "Double",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Filter-Recursive-Test.html#butterworthLowpassTest1",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Filter Recursive Test",
          "module": "Synthesizer.Plain.Filter.Recursive.Test",
          "name": "butterworthLowpassTest1",
          "package": "synthesizer",
          "partial": "Lowpass Test",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Filter-Recursive-Test.html#v:butterworthLowpassTest1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Filter.Recursive.Test",
          "name": "butterworthLowpassTest2",
          "package": "synthesizer",
          "signature": "[Double]",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Filter-Recursive-Test.html#butterworthLowpassTest2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Filter Recursive Test",
          "module": "Synthesizer.Plain.Filter.Recursive.Test",
          "name": "butterworthLowpassTest2",
          "normalized": "[Double]",
          "package": "synthesizer",
          "partial": "Lowpass Test",
          "signature": "[Double]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Filter-Recursive-Test.html#v:butterworthLowpassTest2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Filter.Recursive.Test",
          "name": "chebyParameterA",
          "package": "synthesizer",
          "signature": "a -\u003e T a -\u003e a -\u003e Parameter a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Filter-Recursive-Test.html#chebyParameterA",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Filter Recursive Test",
          "module": "Synthesizer.Plain.Filter.Recursive.Test",
          "name": "chebyParameterA",
          "normalized": "a-\u003eT a-\u003ea-\u003eParameter a",
          "package": "synthesizer",
          "partial": "Parameter",
          "signature": "a-\u003eT a-\u003ea-\u003eParameter a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Filter-Recursive-Test.html#v:chebyParameterA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Filter.Recursive.Test",
          "name": "chebyParameterB",
          "package": "synthesizer",
          "signature": "a -\u003e T a -\u003e a -\u003e Parameter a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Filter-Recursive-Test.html#chebyParameterB",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Filter Recursive Test",
          "module": "Synthesizer.Plain.Filter.Recursive.Test",
          "name": "chebyParameterB",
          "normalized": "a-\u003eT a-\u003ea-\u003eParameter a",
          "package": "synthesizer",
          "partial": "Parameter",
          "signature": "a-\u003eT a-\u003ea-\u003eParameter a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Filter-Recursive-Test.html#v:chebyParameterB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Filter.Recursive.Test",
          "name": "chebyshevALowpassTest0",
          "package": "synthesizer",
          "signature": "Parameter Double",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Filter-Recursive-Test.html#chebyshevALowpassTest0",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Filter Recursive Test",
          "module": "Synthesizer.Plain.Filter.Recursive.Test",
          "name": "chebyshevALowpassTest0",
          "package": "synthesizer",
          "partial": "ALowpass Test",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Filter-Recursive-Test.html#v:chebyshevALowpassTest0"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Filter.Recursive.Test",
          "name": "chebyshevALowpassTest2",
          "package": "synthesizer",
          "signature": "[Double]",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Filter-Recursive-Test.html#chebyshevALowpassTest2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Filter Recursive Test",
          "module": "Synthesizer.Plain.Filter.Recursive.Test",
          "name": "chebyshevALowpassTest2",
          "normalized": "[Double]",
          "package": "synthesizer",
          "partial": "ALowpass Test",
          "signature": "[Double]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Filter-Recursive-Test.html#v:chebyshevALowpassTest2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Filter.Recursive.Test",
          "name": "chebyshevBLowpassTest0",
          "package": "synthesizer",
          "signature": "Parameter Double",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Filter-Recursive-Test.html#chebyshevBLowpassTest0",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Filter Recursive Test",
          "module": "Synthesizer.Plain.Filter.Recursive.Test",
          "name": "chebyshevBLowpassTest0",
          "package": "synthesizer",
          "partial": "BLowpass Test",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Filter-Recursive-Test.html#v:chebyshevBLowpassTest0"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Filter.Recursive.Test",
          "name": "chebyshevBLowpassTest2",
          "package": "synthesizer",
          "signature": "[Double]",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Filter-Recursive-Test.html#chebyshevBLowpassTest2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Filter Recursive Test",
          "module": "Synthesizer.Plain.Filter.Recursive.Test",
          "name": "chebyshevBLowpassTest2",
          "normalized": "[Double]",
          "package": "synthesizer",
          "partial": "BLowpass Test",
          "signature": "[Double]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Filter-Recursive-Test.html#v:chebyshevBLowpassTest2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Filter.Recursive.Test",
          "name": "chebyshevLowpassTest1",
          "package": "synthesizer",
          "signature": "[Double]",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Filter-Recursive-Test.html#chebyshevLowpassTest1",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Filter Recursive Test",
          "module": "Synthesizer.Plain.Filter.Recursive.Test",
          "name": "chebyshevLowpassTest1",
          "normalized": "[Double]",
          "package": "synthesizer",
          "partial": "Lowpass Test",
          "signature": "[Double]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Filter-Recursive-Test.html#v:chebyshevLowpassTest1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Filter.Recursive.Test",
          "name": "chirp",
          "package": "synthesizer",
          "signature": "Double -\u003e [Double]",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Filter-Recursive-Test.html#chirp",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Filter Recursive Test",
          "module": "Synthesizer.Plain.Filter.Recursive.Test",
          "name": "chirp",
          "normalized": "Double-\u003e[Double]",
          "package": "synthesizer",
          "signature": "Double-\u003e[Double]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Filter-Recursive-Test.html#v:chirp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Filter.Recursive.Test",
          "name": "chirpComplex",
          "package": "synthesizer",
          "signature": "Double -\u003e [T Double]",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Filter-Recursive-Test.html#chirpComplex",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Filter Recursive Test",
          "module": "Synthesizer.Plain.Filter.Recursive.Test",
          "name": "chirpComplex",
          "normalized": "Double-\u003e[T Double]",
          "package": "synthesizer",
          "partial": "Complex",
          "signature": "Double-\u003e[T Double]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Filter-Recursive-Test.html#v:chirpComplex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Filter.Recursive.Test",
          "name": "complexRealTest",
          "package": "synthesizer",
          "signature": "[T Double]",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Filter-Recursive-Test.html#complexRealTest",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Filter Recursive Test",
          "module": "Synthesizer.Plain.Filter.Recursive.Test",
          "name": "complexRealTest",
          "normalized": "[T Double]",
          "package": "synthesizer",
          "partial": "Real Test",
          "signature": "[T Double]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Filter-Recursive-Test.html#v:complexRealTest"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Filter.Recursive.Test",
          "name": "complexTest",
          "package": "synthesizer",
          "signature": "[T Double]",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Filter-Recursive-Test.html#complexTest",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Filter Recursive Test",
          "module": "Synthesizer.Plain.Filter.Recursive.Test",
          "name": "complexTest",
          "normalized": "[T Double]",
          "package": "synthesizer",
          "partial": "Test",
          "signature": "[T Double]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Filter-Recursive-Test.html#v:complexTest"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Filter.Recursive.Test",
          "name": "filter2ndOrderTest",
          "package": "synthesizer",
          "signature": "[Double]",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Filter-Recursive-Test.html#filter2ndOrderTest",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Filter Recursive Test",
          "module": "Synthesizer.Plain.Filter.Recursive.Test",
          "name": "filter2ndOrderTest",
          "normalized": "[Double]",
          "package": "synthesizer",
          "partial": "Order Test",
          "signature": "[Double]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Filter-Recursive-Test.html#v:filter2ndOrderTest"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Filter.Recursive.Test",
          "name": "moogLowpassTest",
          "package": "synthesizer",
          "signature": "[Double]",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Filter-Recursive-Test.html#moogLowpassTest",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Filter Recursive Test",
          "module": "Synthesizer.Plain.Filter.Recursive.Test",
          "name": "moogLowpassTest",
          "normalized": "[Double]",
          "package": "synthesizer",
          "partial": "Lowpass Test",
          "signature": "[Double]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Filter-Recursive-Test.html#v:moogLowpassTest"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Filter.Recursive.Test",
          "name": "sampleRate",
          "package": "synthesizer",
          "signature": "a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Filter-Recursive-Test.html#sampleRate",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Filter Recursive Test",
          "module": "Synthesizer.Plain.Filter.Recursive.Test",
          "name": "sampleRate",
          "package": "synthesizer",
          "partial": "Rate",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Filter-Recursive-Test.html#v:sampleRate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Filter.Recursive.Test",
          "name": "universalTest",
          "package": "synthesizer",
          "signature": "[Result Double]",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Filter-Recursive-Test.html#universalTest",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Filter Recursive Test",
          "module": "Synthesizer.Plain.Filter.Recursive.Test",
          "name": "universalTest",
          "normalized": "[Result Double]",
          "package": "synthesizer",
          "partial": "Test",
          "signature": "[Result Double]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Filter-Recursive-Test.html#v:universalTest"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Filter.Recursive.Universal",
          "name": "Parameter",
          "package": "synthesizer",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Filter-Recursive-Universal.html#Parameter",
          "type": "data"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Filter Recursive Universal",
          "module": "Synthesizer.Plain.Filter.Recursive.Universal",
          "name": "Parameter",
          "package": "synthesizer",
          "partial": "Parameter",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Filter-Recursive-Universal.html#t:Parameter"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Filter.Recursive.Universal",
          "name": "Result",
          "package": "synthesizer",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Filter-Recursive-Universal.html#Result",
          "type": "data"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Filter Recursive Universal",
          "module": "Synthesizer.Plain.Filter.Recursive.Universal",
          "name": "Result",
          "package": "synthesizer",
          "partial": "Result",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Filter-Recursive-Universal.html#t:Result"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Filter.Recursive.Universal",
          "name": "causal",
          "package": "synthesizer",
          "signature": "T (Parameter a, v) (Result v)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Filter-Recursive-Universal.html#causal",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Filter Recursive Universal",
          "module": "Synthesizer.Plain.Filter.Recursive.Universal",
          "name": "causal",
          "normalized": "T(Parameter a,b)(Result b)",
          "package": "synthesizer",
          "signature": "T(Parameter a,v)(Result v)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Filter-Recursive-Universal.html#v:causal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Filter.Recursive.Universal",
          "name": "modifier",
          "package": "synthesizer",
          "signature": "Simple (v, v) (Parameter a) v (Result v)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Filter-Recursive-Universal.html#modifier",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Filter Recursive Universal",
          "module": "Synthesizer.Plain.Filter.Recursive.Universal",
          "name": "modifier",
          "normalized": "Simple(a,a)(Parameter b)a(Result a)",
          "package": "synthesizer",
          "signature": "Simple(v,v)(Parameter a)v(Result v)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Filter-Recursive-Universal.html#v:modifier"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Filter.Recursive.Universal",
          "name": "modifierInit",
          "package": "synthesizer",
          "signature": "Initialized (v, v) (v, v) (Parameter a) v (Result v)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Filter-Recursive-Universal.html#modifierInit",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Filter Recursive Universal",
          "module": "Synthesizer.Plain.Filter.Recursive.Universal",
          "name": "modifierInit",
          "normalized": "Initialized(a,a)(a,a)(Parameter b)a(Result a)",
          "package": "synthesizer",
          "partial": "Init",
          "signature": "Initialized(v,v)(v,v)(Parameter a)v(Result v)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Filter-Recursive-Universal.html#v:modifierInit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe computation of the internal parameters is a bit complicated,\nbut it fulfills the following properties:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e At the resonance frequency the band pass has 180 degree phase shift.\n  This is also approximately the frequency\n  where the filter has maximum output.\n  Even more important, this is the frequency where the band limit filter works.\n\u003c/li\u003e\u003cli\u003e At the resonance frequency highpass, lowpass, and bandpass\n  amplify by the factor \u003ctt\u003eresonance\u003c/tt\u003e.\n\u003c/li\u003e\u003cli\u003e The lowpass amplifies the frequency zero by factor 1.\n\u003c/li\u003e\u003cli\u003e The highpass amplifies the highest representable (Nyquist) frequency by the factor 1.\n\u003c/li\u003e\u003cli\u003e The bandlimit amplifies both frequency zero and Nyquist frequency\n  by factor one and cancels the resonance frequency.\n\u003c/li\u003e\u003c/ul\u003e",
          "module": "Synthesizer.Plain.Filter.Recursive.Universal",
          "name": "parameter",
          "package": "synthesizer",
          "signature": "Pole a -\u003e Parameter a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Filter-Recursive-Universal.html#parameter",
          "type": "function"
        },
        "index": {
          "description": "The computation of the internal parameters is bit complicated but it fulfills the following properties At the resonance frequency the band pass has degree phase shift This is also approximately the frequency where the filter has maximum output Even more important this is the frequency where the band limit filter works At the resonance frequency highpass lowpass and bandpass amplify by the factor resonance The lowpass amplifies the frequency zero by factor The highpass amplifies the highest representable Nyquist frequency by the factor The bandlimit amplifies both frequency zero and Nyquist frequency by factor one and cancels the resonance frequency",
          "hierarchy": "Synthesizer Plain Filter Recursive Universal",
          "module": "Synthesizer.Plain.Filter.Recursive.Universal",
          "name": "parameter",
          "normalized": "Pole a-\u003eParameter a",
          "package": "synthesizer",
          "signature": "Pole a-\u003eParameter a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Filter-Recursive-Universal.html#v:parameter"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Filter.Recursive.Universal",
          "name": "run",
          "package": "synthesizer",
          "signature": "T (Parameter a) -\u003e T v -\u003e T (Result v)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Filter-Recursive-Universal.html#run",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Filter Recursive Universal",
          "module": "Synthesizer.Plain.Filter.Recursive.Universal",
          "name": "run",
          "normalized": "T(Parameter a)-\u003eT b-\u003eT(Result b)",
          "package": "synthesizer",
          "signature": "T(Parameter a)-\u003eT v-\u003eT(Result v)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Filter-Recursive-Universal.html#v:run"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Filter.Recursive.Universal",
          "name": "runInit",
          "package": "synthesizer",
          "signature": "(v, v) -\u003e T (Parameter a) -\u003e T v -\u003e T (Result v)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Filter-Recursive-Universal.html#runInit",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Filter Recursive Universal",
          "module": "Synthesizer.Plain.Filter.Recursive.Universal",
          "name": "runInit",
          "normalized": "(a,a)-\u003eT(Parameter b)-\u003eT a-\u003eT(Result a)",
          "package": "synthesizer",
          "partial": "Init",
          "signature": "(v,v)-\u003eT(Parameter a)-\u003eT v-\u003eT(Result v)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Filter-Recursive-Universal.html#v:runInit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Universal filter: Computes high pass, band pass, low pass in one go \n",
          "module": "Synthesizer.Plain.Filter.Recursive.Universal",
          "name": "step",
          "package": "synthesizer",
          "signature": "Parameter a -\u003e v -\u003e State (v, v) (Result v)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Filter-Recursive-Universal.html#step",
          "type": "function"
        },
        "index": {
          "description": "Universal filter Computes high pass band pass low pass in one go",
          "hierarchy": "Synthesizer Plain Filter Recursive Universal",
          "module": "Synthesizer.Plain.Filter.Recursive.Universal",
          "name": "step",
          "normalized": "Parameter a-\u003eb-\u003eState(b,b)(Result b)",
          "package": "synthesizer",
          "signature": "Parameter a-\u003ev-\u003eState(v,v)(Result v)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Filter-Recursive-Universal.html#v:step"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Filter.Recursive.Universal",
          "name": "storeParameter",
          "package": "synthesizer",
          "signature": "Dictionary (Parameter a)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Filter-Recursive-Universal.html#storeParameter",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Filter Recursive Universal",
          "module": "Synthesizer.Plain.Filter.Recursive.Universal",
          "name": "storeParameter",
          "package": "synthesizer",
          "partial": "Parameter",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Filter-Recursive-Universal.html#v:storeParameter"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Filter.Recursive.Universal",
          "name": "storeResult",
          "package": "synthesizer",
          "signature": "Dictionary (Result a)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Filter-Recursive-Universal.html#storeResult",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Filter Recursive Universal",
          "module": "Synthesizer.Plain.Filter.Recursive.Universal",
          "name": "storeResult",
          "package": "synthesizer",
          "partial": "Result",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Filter-Recursive-Universal.html#v:storeResult"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Filter.Recursive",
          "name": "Passband",
          "package": "synthesizer",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Filter-Recursive.html#Passband",
          "type": "data"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Filter Recursive",
          "module": "Synthesizer.Plain.Filter.Recursive",
          "name": "Passband",
          "package": "synthesizer",
          "partial": "Passband",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Filter-Recursive.html#t:Passband"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Filter.Recursive",
          "name": "Pole",
          "package": "synthesizer",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Filter-Recursive.html#Pole",
          "type": "data"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Filter Recursive",
          "module": "Synthesizer.Plain.Filter.Recursive",
          "name": "Pole",
          "package": "synthesizer",
          "partial": "Pole",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Filter-Recursive.html#t:Pole"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.IO",
          "name": "intToTwoLEChars",
          "package": "synthesizer",
          "signature": "Int -\u003e [Char]",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-IO.html#intToTwoLEChars",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain IO",
          "module": "Synthesizer.Plain.IO",
          "name": "intToTwoLEChars",
          "normalized": "Int-\u003e[Char]",
          "package": "synthesizer",
          "partial": "To Two LEChars",
          "signature": "Int-\u003e[Char]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-IO.html#v:intToTwoLEChars"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.IO",
          "name": "putInt16Stream",
          "package": "synthesizer",
          "signature": "Handle -\u003e [Int16] -\u003e IO ()",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-IO.html#putInt16Stream",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain IO",
          "module": "Synthesizer.Plain.IO",
          "name": "putInt16Stream",
          "normalized": "Handle-\u003e[Int]-\u003eIO()",
          "package": "synthesizer",
          "partial": "Int Stream",
          "signature": "Handle-\u003e[Int]-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-IO.html#v:putInt16Stream"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.IO",
          "name": "putInt16StreamChunky",
          "package": "synthesizer",
          "signature": "Handle -\u003e [Int16] -\u003e IO ()",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-IO.html#putInt16StreamChunky",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain IO",
          "module": "Synthesizer.Plain.IO",
          "name": "putInt16StreamChunky",
          "normalized": "Handle-\u003e[Int]-\u003eIO()",
          "package": "synthesizer",
          "partial": "Int Stream Chunky",
          "signature": "Handle-\u003e[Int]-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-IO.html#v:putInt16StreamChunky"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "The end of the list is undefined,\nif the file has odd length.\nIt would be better if it throws an exception.\n",
          "module": "Synthesizer.Plain.IO",
          "name": "readInt16StreamStrict",
          "package": "synthesizer",
          "signature": "FilePath -\u003e IO [Int16]",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-IO.html#readInt16StreamStrict",
          "type": "function"
        },
        "index": {
          "description": "The end of the list is undefined if the file has odd length It would be better if it throws an exception",
          "hierarchy": "Synthesizer Plain IO",
          "module": "Synthesizer.Plain.IO",
          "name": "readInt16StreamStrict",
          "normalized": "FilePath-\u003eIO[Int]",
          "package": "synthesizer",
          "partial": "Int Stream Strict",
          "signature": "FilePath-\u003eIO[Int]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-IO.html#v:readInt16StreamStrict"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "The end of the list is undefined,\nif the file has odd length.\nIt would be better if it throws an exception.\n",
          "module": "Synthesizer.Plain.IO",
          "name": "readLEInt16Stream",
          "package": "synthesizer",
          "signature": "FilePath -\u003e IO [Int16]",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-IO.html#readLEInt16Stream",
          "type": "function"
        },
        "index": {
          "description": "The end of the list is undefined if the file has odd length It would be better if it throws an exception",
          "hierarchy": "Synthesizer Plain IO",
          "module": "Synthesizer.Plain.IO",
          "name": "readLEInt16Stream",
          "normalized": "FilePath-\u003eIO[Int]",
          "package": "synthesizer",
          "partial": "LEInt Stream",
          "signature": "FilePath-\u003eIO[Int]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-IO.html#v:readLEInt16Stream"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.IO",
          "name": "twoLECharsToInt",
          "package": "synthesizer",
          "signature": "Char -\u003e Char -\u003e Int",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-IO.html#twoLECharsToInt",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain IO",
          "module": "Synthesizer.Plain.IO",
          "name": "twoLECharsToInt",
          "normalized": "Char-\u003eChar-\u003eInt",
          "package": "synthesizer",
          "partial": "LEChars To Int",
          "signature": "Char-\u003eChar-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-IO.html#v:twoLECharsToInt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Uses endianess of the machine, like Sox does.\n",
          "module": "Synthesizer.Plain.IO",
          "name": "writeInt16Stream",
          "package": "synthesizer",
          "signature": "FilePath -\u003e [Int16] -\u003e IO ()",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-IO.html#writeInt16Stream",
          "type": "function"
        },
        "index": {
          "description": "Uses endianess of the machine like Sox does",
          "hierarchy": "Synthesizer Plain IO",
          "module": "Synthesizer.Plain.IO",
          "name": "writeInt16Stream",
          "normalized": "FilePath-\u003e[Int]-\u003eIO()",
          "package": "synthesizer",
          "partial": "Int Stream",
          "signature": "FilePath-\u003e[Int]-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-IO.html#v:writeInt16Stream"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Write a little endian 16 bit integer stream\nvia String data and \u003ctt\u003e\u003ca\u003ewriteFile\u003c/a\u003e\u003c/tt\u003e.\n",
          "module": "Synthesizer.Plain.IO",
          "name": "writeLEInt16Stream",
          "package": "synthesizer",
          "signature": "FilePath -\u003e [Int16] -\u003e IO ()",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-IO.html#writeLEInt16Stream",
          "type": "function"
        },
        "index": {
          "description": "Write little endian bit integer stream via String data and writeFile",
          "hierarchy": "Synthesizer Plain IO",
          "module": "Synthesizer.Plain.IO",
          "name": "writeLEInt16Stream",
          "normalized": "FilePath-\u003e[Int]-\u003eIO()",
          "package": "synthesizer",
          "partial": "LEInt Stream",
          "signature": "FilePath-\u003e[Int]-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-IO.html#v:writeLEInt16Stream"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Instrument",
          "name": "accumulatedSaws",
          "package": "synthesizer",
          "signature": "a -\u003e a -\u003e [[a]]",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Instrument.html#accumulatedSaws",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Instrument",
          "module": "Synthesizer.Plain.Instrument",
          "name": "accumulatedSaws",
          "normalized": "a-\u003ea-\u003e[[a]]",
          "package": "synthesizer",
          "partial": "Saws",
          "signature": "a-\u003ea-\u003e[[a]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Instrument.html#v:accumulatedSaws"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Instrument",
          "name": "allpassDown",
          "package": "synthesizer",
          "signature": "a -\u003e Int -\u003e a -\u003e a -\u003e a -\u003e [a]",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Instrument.html#allpassDown",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Instrument",
          "module": "Synthesizer.Plain.Instrument",
          "name": "allpassDown",
          "normalized": "a-\u003eInt-\u003ea-\u003ea-\u003ea-\u003e[a]",
          "package": "synthesizer",
          "partial": "Down",
          "signature": "a-\u003eInt-\u003ea-\u003ea-\u003ea-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Instrument.html#v:allpassDown"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Instrument",
          "name": "allpassPlain",
          "package": "synthesizer",
          "signature": "a -\u003e a -\u003e a -\u003e a -\u003e [a]",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Instrument.html#allpassPlain",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Instrument",
          "module": "Synthesizer.Plain.Instrument",
          "name": "allpassPlain",
          "normalized": "a-\u003ea-\u003ea-\u003ea-\u003e[a]",
          "package": "synthesizer",
          "partial": "Plain",
          "signature": "a-\u003ea-\u003ea-\u003ea-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Instrument.html#v:allpassPlain"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Instrument",
          "name": "bell",
          "package": "synthesizer",
          "signature": "a -\u003e a -\u003e [a]",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Instrument.html#bell",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Instrument",
          "module": "Synthesizer.Plain.Instrument",
          "name": "bell",
          "normalized": "a-\u003ea-\u003e[a]",
          "package": "synthesizer",
          "signature": "a-\u003ea-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Instrument.html#v:bell"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Instrument",
          "name": "bellHarmonic",
          "package": "synthesizer",
          "signature": "a -\u003e a -\u003e a -\u003e a -\u003e [a]",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Instrument.html#bellHarmonic",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Instrument",
          "module": "Synthesizer.Plain.Instrument",
          "name": "bellHarmonic",
          "normalized": "a-\u003ea-\u003ea-\u003ea-\u003e[a]",
          "package": "synthesizer",
          "partial": "Harmonic",
          "signature": "a-\u003ea-\u003ea-\u003ea-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Instrument.html#v:bellHarmonic"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Instrument",
          "name": "choir",
          "package": "synthesizer",
          "signature": "a -\u003e a -\u003e [a]",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Instrument.html#choir",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Instrument",
          "module": "Synthesizer.Plain.Instrument",
          "name": "choir",
          "normalized": "a-\u003ea-\u003e[a]",
          "package": "synthesizer",
          "signature": "a-\u003ea-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Instrument.html#v:choir"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Instrument",
          "name": "choirWave",
          "package": "synthesizer",
          "signature": "[a]",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Instrument.html#choirWave",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Instrument",
          "module": "Synthesizer.Plain.Instrument",
          "name": "choirWave",
          "normalized": "[a]",
          "package": "synthesizer",
          "partial": "Wave",
          "signature": "[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Instrument.html#v:choirWave"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Drum sound using the Karplus-Strong-Algorithm\n    This is a Noise.white enveloped by an exponential2\n    which is piped through the Karplus-Strong machine\n    for generating some frequency.\n    The whole thing is then frequency modulated\n    to give a falling frequency. \n",
          "module": "Synthesizer.Plain.Instrument",
          "name": "electroTom",
          "package": "synthesizer",
          "signature": "a -\u003e [a]",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Instrument.html#electroTom",
          "type": "function"
        },
        "index": {
          "description": "Drum sound using the Karplus-Strong-Algorithm This is Noise.white enveloped by an exponential2 which is piped through the Karplus-Strong machine for generating some frequency The whole thing is then frequency modulated to give falling frequency",
          "hierarchy": "Synthesizer Plain Instrument",
          "module": "Synthesizer.Plain.Instrument",
          "name": "electroTom",
          "normalized": "a-\u003e[a]",
          "package": "synthesizer",
          "partial": "Tom",
          "signature": "a-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Instrument.html#v:electroTom"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Instrument",
          "name": "fastBell",
          "package": "synthesizer",
          "signature": "a -\u003e a -\u003e [a]",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Instrument.html#fastBell",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Instrument",
          "module": "Synthesizer.Plain.Instrument",
          "name": "fastBell",
          "normalized": "a-\u003ea-\u003e[a]",
          "package": "synthesizer",
          "partial": "Bell",
          "signature": "a-\u003ea-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Instrument.html#v:fastBell"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Instrument",
          "name": "fatSaw",
          "package": "synthesizer",
          "signature": "a -\u003e a -\u003e [a]",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Instrument.html#fatSaw",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Instrument",
          "module": "Synthesizer.Plain.Instrument",
          "name": "fatSaw",
          "normalized": "a-\u003ea-\u003e[a]",
          "package": "synthesizer",
          "partial": "Saw",
          "signature": "a-\u003ea-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Instrument.html#v:fatSaw"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Instrument",
          "name": "fatSawChord",
          "package": "synthesizer",
          "signature": "a -\u003e a -\u003e [a]",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Instrument.html#fatSawChord",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Instrument",
          "module": "Synthesizer.Plain.Instrument",
          "name": "fatSawChord",
          "normalized": "a-\u003ea-\u003e[a]",
          "package": "synthesizer",
          "partial": "Saw Chord",
          "signature": "a-\u003ea-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Instrument.html#v:fatSawChord"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Instrument",
          "name": "fatSawChordFilter",
          "package": "synthesizer",
          "signature": "a -\u003e a -\u003e [a]",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Instrument.html#fatSawChordFilter",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Instrument",
          "module": "Synthesizer.Plain.Instrument",
          "name": "fatSawChordFilter",
          "normalized": "a-\u003ea-\u003e[a]",
          "package": "synthesizer",
          "partial": "Saw Chord Filter",
          "signature": "a-\u003ea-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Instrument.html#v:fatSawChordFilter"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Instrument",
          "name": "filterDown",
          "package": "synthesizer",
          "signature": "a -\u003e [Parameter a]",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Instrument.html#filterDown",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Instrument",
          "module": "Synthesizer.Plain.Instrument",
          "name": "filterDown",
          "normalized": "a-\u003e[Parameter a]",
          "package": "synthesizer",
          "partial": "Down",
          "signature": "a-\u003e[Parameter a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Instrument.html#v:filterDown"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Instrument",
          "name": "filterSaw",
          "package": "synthesizer",
          "signature": "a -\u003e a -\u003e a -\u003e [a]",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Instrument.html#filterSaw",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Instrument",
          "module": "Synthesizer.Plain.Instrument",
          "name": "filterSaw",
          "normalized": "a-\u003ea-\u003ea-\u003e[a]",
          "package": "synthesizer",
          "partial": "Saw",
          "signature": "a-\u003ea-\u003ea-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Instrument.html#v:filterSaw"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "low pass with resonance \n",
          "module": "Synthesizer.Plain.Instrument",
          "name": "filterSweep",
          "package": "synthesizer",
          "signature": "a -\u003e a -\u003e [v] -\u003e [v]",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Instrument.html#filterSweep",
          "type": "function"
        },
        "index": {
          "description": "low pass with resonance",
          "hierarchy": "Synthesizer Plain Instrument",
          "module": "Synthesizer.Plain.Instrument",
          "name": "filterSweep",
          "normalized": "a-\u003ea-\u003e[b]-\u003e[b]",
          "package": "synthesizer",
          "partial": "Sweep",
          "signature": "a-\u003ea-\u003e[v]-\u003e[v]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Instrument.html#v:filterSweep"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Instrument",
          "name": "fmBell",
          "package": "synthesizer",
          "signature": "a -\u003e a -\u003e a -\u003e a -\u003e [a]",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Instrument.html#fmBell",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Instrument",
          "module": "Synthesizer.Plain.Instrument",
          "name": "fmBell",
          "normalized": "a-\u003ea-\u003ea-\u003ea-\u003e[a]",
          "package": "synthesizer",
          "partial": "Bell",
          "signature": "a-\u003ea-\u003ea-\u003ea-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Instrument.html#v:fmBell"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "accumulate multiple similar saw sounds and observe the increase of volume\n    The oscillator \u003ctt\u003eosc\u003c/tt\u003e must accept relative frequencies. \n",
          "module": "Synthesizer.Plain.Instrument",
          "name": "modulatedWave",
          "package": "synthesizer",
          "signature": "a -\u003e (a -\u003e [a] -\u003e [a]) -\u003e a -\u003e a -\u003e a -\u003e a -\u003e a -\u003e [a]",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Instrument.html#modulatedWave",
          "type": "function"
        },
        "index": {
          "description": "accumulate multiple similar saw sounds and observe the increase of volume The oscillator osc must accept relative frequencies",
          "hierarchy": "Synthesizer Plain Instrument",
          "module": "Synthesizer.Plain.Instrument",
          "name": "modulatedWave",
          "normalized": "a-\u003e(a-\u003e[a]-\u003e[a])-\u003ea-\u003ea-\u003ea-\u003ea-\u003ea-\u003e[a]",
          "package": "synthesizer",
          "partial": "Wave",
          "signature": "a-\u003e(a-\u003e[a]-\u003e[a])-\u003ea-\u003ea-\u003ea-\u003ea-\u003ea-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Instrument.html#v:modulatedWave"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Instrument",
          "name": "moogDown",
          "package": "synthesizer",
          "signature": "a -\u003e Int -\u003e a -\u003e a -\u003e a -\u003e [a]",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Instrument.html#moogDown",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Instrument",
          "module": "Synthesizer.Plain.Instrument",
          "name": "moogDown",
          "normalized": "a-\u003eInt-\u003ea-\u003ea-\u003ea-\u003e[a]",
          "package": "synthesizer",
          "partial": "Down",
          "signature": "a-\u003eInt-\u003ea-\u003ea-\u003ea-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Instrument.html#v:moogDown"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Instrument",
          "name": "moogGuitar",
          "package": "synthesizer",
          "signature": "a -\u003e a -\u003e [a]",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Instrument.html#moogGuitar",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Instrument",
          "module": "Synthesizer.Plain.Instrument",
          "name": "moogGuitar",
          "normalized": "a-\u003ea-\u003e[a]",
          "package": "synthesizer",
          "partial": "Guitar",
          "signature": "a-\u003ea-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Instrument.html#v:moogGuitar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Instrument",
          "name": "moogGuitarSoft",
          "package": "synthesizer",
          "signature": "a -\u003e a -\u003e [a]",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Instrument.html#moogGuitarSoft",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Instrument",
          "module": "Synthesizer.Plain.Instrument",
          "name": "moogGuitarSoft",
          "normalized": "a-\u003ea-\u003e[a]",
          "package": "synthesizer",
          "partial": "Guitar Soft",
          "signature": "a-\u003ea-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Instrument.html#v:moogGuitarSoft"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Instrument",
          "name": "moogReso",
          "package": "synthesizer",
          "signature": "a -\u003e Int -\u003e a -\u003e a -\u003e a -\u003e [a]",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Instrument.html#moogReso",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Instrument",
          "module": "Synthesizer.Plain.Instrument",
          "name": "moogReso",
          "normalized": "a-\u003eInt-\u003ea-\u003ea-\u003ea-\u003e[a]",
          "package": "synthesizer",
          "partial": "Reso",
          "signature": "a-\u003eInt-\u003ea-\u003ea-\u003ea-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Instrument.html#v:moogReso"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Instrument",
          "name": "noiseBass",
          "package": "synthesizer",
          "signature": "a -\u003e a -\u003e [a]",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Instrument.html#noiseBass",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Instrument",
          "module": "Synthesizer.Plain.Instrument",
          "name": "noiseBass",
          "normalized": "a-\u003ea-\u003e[a]",
          "package": "synthesizer",
          "partial": "Bass",
          "signature": "a-\u003ea-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Instrument.html#v:noiseBass"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Build a saw sound from its harmonics and modulate it.\n    Different to normal modulation\n    I modulate each harmonic with the same depth rather than a proportional one. \n",
          "module": "Synthesizer.Plain.Instrument",
          "name": "osciAbsModSaw",
          "package": "synthesizer",
          "signature": "a -\u003e a -\u003e [a]",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Instrument.html#osciAbsModSaw",
          "type": "function"
        },
        "index": {
          "description": "Build saw sound from its harmonics and modulate it Different to normal modulation modulate each harmonic with the same depth rather than proportional one",
          "hierarchy": "Synthesizer Plain Instrument",
          "module": "Synthesizer.Plain.Instrument",
          "name": "osciAbsModSaw",
          "normalized": "a-\u003ea-\u003e[a]",
          "package": "synthesizer",
          "partial": "Abs Mod Saw",
          "signature": "a-\u003ea-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Instrument.html#v:osciAbsModSaw"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Instrument",
          "name": "osciDoubleSaw",
          "package": "synthesizer",
          "signature": "a -\u003e [a] -\u003e [a]",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Instrument.html#osciDoubleSaw",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Instrument",
          "module": "Synthesizer.Plain.Instrument",
          "name": "osciDoubleSaw",
          "normalized": "a-\u003e[a]-\u003e[a]",
          "package": "synthesizer",
          "partial": "Double Saw",
          "signature": "a-\u003e[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Instrument.html#v:osciDoubleSaw"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "A tone with a waveform with roughly the dependency x -\u003e x**p,\n    where the waveform is normalized to constant quadratic norm \n",
          "module": "Synthesizer.Plain.Instrument",
          "name": "osciSharp",
          "package": "synthesizer",
          "signature": "a -\u003e a -\u003e [a]",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Instrument.html#osciSharp",
          "type": "function"
        },
        "index": {
          "description": "tone with waveform with roughly the dependency where the waveform is normalized to constant quadratic norm",
          "hierarchy": "Synthesizer Plain Instrument",
          "module": "Synthesizer.Plain.Instrument",
          "name": "osciSharp",
          "normalized": "a-\u003ea-\u003e[a]",
          "package": "synthesizer",
          "partial": "Sharp",
          "signature": "a-\u003ea-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Instrument.html#v:osciSharp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "frequency of the pulses, interesting ones are around 100 Hz and below \n",
          "module": "Synthesizer.Plain.Instrument",
          "name": "pulsedNoise",
          "package": "synthesizer",
          "signature": "a-\u003e a-\u003e [a]",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Instrument.html#pulsedNoise",
          "type": "function"
        },
        "index": {
          "description": "frequency of the pulses interesting ones are around Hz and below",
          "hierarchy": "Synthesizer Plain Instrument",
          "module": "Synthesizer.Plain.Instrument",
          "name": "pulsedNoise",
          "normalized": "a-\u003ea-\u003e[a]",
          "package": "synthesizer",
          "partial": "Noise",
          "signature": "a-\u003ea-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Instrument.html#v:pulsedNoise"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Instrument",
          "name": "simpleSaw",
          "package": "synthesizer",
          "signature": "a -\u003e a -\u003e [a]",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Instrument.html#simpleSaw",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Instrument",
          "module": "Synthesizer.Plain.Instrument",
          "name": "simpleSaw",
          "normalized": "a-\u003ea-\u003e[a]",
          "package": "synthesizer",
          "partial": "Saw",
          "signature": "a-\u003ea-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Instrument.html#v:simpleSaw"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Instrument",
          "name": "squareBell",
          "package": "synthesizer",
          "signature": "a -\u003e a -\u003e [a]",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Instrument.html#squareBell",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Instrument",
          "module": "Synthesizer.Plain.Instrument",
          "name": "squareBell",
          "normalized": "a-\u003ea-\u003e[a]",
          "package": "synthesizer",
          "partial": "Bell",
          "signature": "a-\u003ea-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Instrument.html#v:squareBell"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "A function mapping a frequency to a signal. \nThe factor to the frequency, should be close to 1. \nThe base (undeviated) frequency of the sound. \n",
          "module": "Synthesizer.Plain.Instrument",
          "name": "stereoPhaser",
          "package": "synthesizer",
          "signature": "a -\u003e [b]-\u003e a-\u003e a-\u003e [b]",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Instrument.html#stereoPhaser",
          "type": "function"
        },
        "index": {
          "description": "function mapping frequency to signal The factor to the frequency should be close to The base undeviated frequency of the sound",
          "hierarchy": "Synthesizer Plain Instrument",
          "module": "Synthesizer.Plain.Instrument",
          "name": "stereoPhaser",
          "normalized": "a-\u003e[b]-\u003ea-\u003ea-\u003e[b]",
          "package": "synthesizer",
          "partial": "Phaser",
          "signature": "a-\u003e[b]-\u003ea-\u003ea-\u003e[b]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Instrument.html#v:stereoPhaser"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Interpolation",
          "name": "Margin",
          "package": "synthesizer",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Interpolation.html#Margin",
          "type": "data"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Interpolation",
          "module": "Synthesizer.Plain.Interpolation",
          "name": "Margin",
          "package": "synthesizer",
          "partial": "Margin",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Interpolation.html#t:Margin"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Interpolation",
          "name": "T",
          "package": "synthesizer",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Interpolation.html#T",
          "type": "data"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Interpolation",
          "module": "Synthesizer.Plain.Interpolation",
          "name": "T",
          "package": "synthesizer",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Interpolation.html#t:T"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Interpolation",
          "name": "constantPad",
          "package": "synthesizer",
          "signature": "(T t y -\u003e t -\u003e T y -\u003e a) -\u003e T t y -\u003e t -\u003e T y -\u003e a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Interpolation.html#constantPad",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Interpolation",
          "module": "Synthesizer.Plain.Interpolation",
          "name": "constantPad",
          "normalized": "(T a b-\u003ea-\u003eT b-\u003ec)-\u003eT a b-\u003ea-\u003eT b-\u003ec",
          "package": "synthesizer",
          "partial": "Pad",
          "signature": "(T t y-\u003et-\u003eT y-\u003ea)-\u003eT t y-\u003et-\u003eT y-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Interpolation.html#v:constantPad"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Only for finite input signals.\n",
          "module": "Synthesizer.Plain.Interpolation",
          "name": "cyclicPad",
          "package": "synthesizer",
          "signature": "(T t y -\u003e t -\u003e T y -\u003e a) -\u003e T t y -\u003e t -\u003e T y -\u003e a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Interpolation.html#cyclicPad",
          "type": "function"
        },
        "index": {
          "description": "Only for finite input signals",
          "hierarchy": "Synthesizer Plain Interpolation",
          "module": "Synthesizer.Plain.Interpolation",
          "name": "cyclicPad",
          "normalized": "(T a b-\u003ea-\u003eT b-\u003ec)-\u003eT a b-\u003ea-\u003eT b-\u003ec",
          "package": "synthesizer",
          "partial": "Pad",
          "signature": "(T t y-\u003et-\u003eT y-\u003ea)-\u003eT t y-\u003et-\u003eT y-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Interpolation.html#v:cyclicPad"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "The extrapolation may miss some of the first and some of the last points\n",
          "module": "Synthesizer.Plain.Interpolation",
          "name": "extrapolationPad",
          "package": "synthesizer",
          "signature": "(T t y -\u003e t -\u003e T y -\u003e a) -\u003e T t y -\u003e t -\u003e T y -\u003e a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Interpolation.html#extrapolationPad",
          "type": "function"
        },
        "index": {
          "description": "The extrapolation may miss some of the first and some of the last points",
          "hierarchy": "Synthesizer Plain Interpolation",
          "module": "Synthesizer.Plain.Interpolation",
          "name": "extrapolationPad",
          "normalized": "(T a b-\u003ea-\u003eT b-\u003ec)-\u003eT a b-\u003ea-\u003eT b-\u003ec",
          "package": "synthesizer",
          "partial": "Pad",
          "signature": "(T t y-\u003et-\u003eT y-\u003ea)-\u003eT t y-\u003et-\u003eT y-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Interpolation.html#v:extrapolationPad"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Interpolation",
          "name": "func",
          "package": "synthesizer",
          "signature": "T t y -\u003e t -\u003e T y -\u003e y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Interpolation.html#func",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Interpolation",
          "module": "Synthesizer.Plain.Interpolation",
          "name": "func",
          "normalized": "T a b-\u003ea-\u003eT b-\u003eb",
          "package": "synthesizer",
          "signature": "T t y-\u003et-\u003eT y-\u003ey",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Interpolation.html#v:func"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Interpolation",
          "name": "margin",
          "package": "synthesizer",
          "signature": "T t y -\u003e Margin",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Interpolation.html#margin",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Interpolation",
          "module": "Synthesizer.Plain.Interpolation",
          "name": "margin",
          "normalized": "T a b-\u003eMargin",
          "package": "synthesizer",
          "signature": "T t y-\u003eMargin",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Interpolation.html#v:margin"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "All values of frequency control must be non-negative. \n",
          "module": "Synthesizer.Plain.Interpolation",
          "name": "multiRelative",
          "package": "synthesizer",
          "signature": "T t y -\u003e t -\u003e T y -\u003e T t -\u003e T y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Interpolation.html#multiRelative",
          "type": "function"
        },
        "index": {
          "description": "All values of frequency control must be non-negative",
          "hierarchy": "Synthesizer Plain Interpolation",
          "module": "Synthesizer.Plain.Interpolation",
          "name": "multiRelative",
          "normalized": "T a b-\u003ea-\u003eT b-\u003eT a-\u003eT b",
          "package": "synthesizer",
          "partial": "Relative",
          "signature": "T t y-\u003et-\u003eT y-\u003eT t-\u003eT y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Interpolation.html#v:multiRelative"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Interpolation",
          "name": "multiRelativeConstantPad",
          "package": "synthesizer",
          "signature": "T t y -\u003e t -\u003e T t -\u003e T y -\u003e T y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Interpolation.html#multiRelativeConstantPad",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Interpolation",
          "module": "Synthesizer.Plain.Interpolation",
          "name": "multiRelativeConstantPad",
          "normalized": "T a b-\u003ea-\u003eT a-\u003eT b-\u003eT b",
          "package": "synthesizer",
          "partial": "Relative Constant Pad",
          "signature": "T t y-\u003et-\u003eT t-\u003eT y-\u003eT y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Interpolation.html#v:multiRelativeConstantPad"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Interpolation",
          "name": "multiRelativeCyclicPad",
          "package": "synthesizer",
          "signature": "T t y -\u003e t -\u003e T t -\u003e T y -\u003e T y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Interpolation.html#multiRelativeCyclicPad",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Interpolation",
          "module": "Synthesizer.Plain.Interpolation",
          "name": "multiRelativeCyclicPad",
          "normalized": "T a b-\u003ea-\u003eT a-\u003eT b-\u003eT b",
          "package": "synthesizer",
          "partial": "Relative Cyclic Pad",
          "signature": "T t y-\u003et-\u003eT t-\u003eT y-\u003eT y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Interpolation.html#v:multiRelativeCyclicPad"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "The extrapolation may miss some of the first and some of the last points\n",
          "module": "Synthesizer.Plain.Interpolation",
          "name": "multiRelativeExtrapolationPad",
          "package": "synthesizer",
          "signature": "T t y -\u003e t -\u003e T t -\u003e T y -\u003e T y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Interpolation.html#multiRelativeExtrapolationPad",
          "type": "function"
        },
        "index": {
          "description": "The extrapolation may miss some of the first and some of the last points",
          "hierarchy": "Synthesizer Plain Interpolation",
          "module": "Synthesizer.Plain.Interpolation",
          "name": "multiRelativeExtrapolationPad",
          "normalized": "T a b-\u003ea-\u003eT a-\u003eT b-\u003eT b",
          "package": "synthesizer",
          "partial": "Relative Extrapolation Pad",
          "signature": "T t y-\u003et-\u003eT t-\u003eT y-\u003eT y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Interpolation.html#v:multiRelativeExtrapolationPad"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Interpolation",
          "name": "multiRelativeZeroPad",
          "package": "synthesizer",
          "signature": "y -\u003e T t y -\u003e t -\u003e T t -\u003e T y -\u003e T y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Interpolation.html#multiRelativeZeroPad",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Interpolation",
          "module": "Synthesizer.Plain.Interpolation",
          "name": "multiRelativeZeroPad",
          "normalized": "a-\u003eT b a-\u003eb-\u003eT b-\u003eT a-\u003eT a",
          "package": "synthesizer",
          "partial": "Relative Zero Pad",
          "signature": "y-\u003eT t y-\u003et-\u003eT t-\u003eT y-\u003eT y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Interpolation.html#v:multiRelativeZeroPad"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Interpolation",
          "name": "multiRelativeZeroPadConstant",
          "package": "synthesizer",
          "signature": "t -\u003e T t -\u003e T y -\u003e T y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Interpolation.html#multiRelativeZeroPadConstant",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Interpolation",
          "module": "Synthesizer.Plain.Interpolation",
          "name": "multiRelativeZeroPadConstant",
          "normalized": "a-\u003eT a-\u003eT b-\u003eT b",
          "package": "synthesizer",
          "partial": "Relative Zero Pad Constant",
          "signature": "t-\u003eT t-\u003eT y-\u003eT y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Interpolation.html#v:multiRelativeZeroPadConstant"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Interpolation",
          "name": "multiRelativeZeroPadCubic",
          "package": "synthesizer",
          "signature": "t -\u003e T t -\u003e T y -\u003e T y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Interpolation.html#multiRelativeZeroPadCubic",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Interpolation",
          "module": "Synthesizer.Plain.Interpolation",
          "name": "multiRelativeZeroPadCubic",
          "normalized": "a-\u003eT a-\u003eT b-\u003eT b",
          "package": "synthesizer",
          "partial": "Relative Zero Pad Cubic",
          "signature": "t-\u003eT t-\u003eT y-\u003eT y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Interpolation.html#v:multiRelativeZeroPadCubic"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Interpolation",
          "name": "multiRelativeZeroPadLinear",
          "package": "synthesizer",
          "signature": "t -\u003e T t -\u003e T y -\u003e T y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Interpolation.html#multiRelativeZeroPadLinear",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Interpolation",
          "module": "Synthesizer.Plain.Interpolation",
          "name": "multiRelativeZeroPadLinear",
          "normalized": "a-\u003eT a-\u003eT b-\u003eT b",
          "package": "synthesizer",
          "partial": "Relative Zero Pad Linear",
          "signature": "t-\u003eT t-\u003eT y-\u003eT y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Interpolation.html#v:multiRelativeZeroPadLinear"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Interpolation",
          "name": "single",
          "package": "synthesizer",
          "signature": "T t y -\u003e t -\u003e T y -\u003e y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Interpolation.html#single",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Interpolation",
          "module": "Synthesizer.Plain.Interpolation",
          "name": "single",
          "normalized": "T a b-\u003ea-\u003eT b-\u003eb",
          "package": "synthesizer",
          "signature": "T t y-\u003et-\u003eT y-\u003ey",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Interpolation.html#v:single"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "alternative implementation of \u003ctt\u003e\u003ca\u003esingle\u003c/a\u003e\u003c/tt\u003e\n",
          "module": "Synthesizer.Plain.Interpolation",
          "name": "singleRec",
          "package": "synthesizer",
          "signature": "T t y -\u003e t -\u003e T y -\u003e y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Interpolation.html#singleRec",
          "type": "function"
        },
        "index": {
          "description": "alternative implementation of single",
          "hierarchy": "Synthesizer Plain Interpolation",
          "module": "Synthesizer.Plain.Interpolation",
          "name": "singleRec",
          "normalized": "T a b-\u003ea-\u003eT b-\u003eb",
          "package": "synthesizer",
          "partial": "Rec",
          "signature": "T t y-\u003et-\u003eT y-\u003ey",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Interpolation.html#v:singleRec"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Interpolation",
          "name": "zeroPad",
          "package": "synthesizer",
          "signature": "(T t y -\u003e t -\u003e T y -\u003e a) -\u003e y -\u003e T t y -\u003e t -\u003e T y -\u003e a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Interpolation.html#zeroPad",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Interpolation",
          "module": "Synthesizer.Plain.Interpolation",
          "name": "zeroPad",
          "normalized": "(T a b-\u003ea-\u003eT b-\u003ec)-\u003eb-\u003eT a b-\u003ea-\u003eT b-\u003ec",
          "package": "synthesizer",
          "partial": "Pad",
          "signature": "(T t y-\u003et-\u003eT y-\u003ea)-\u003ey-\u003eT t y-\u003et-\u003eT y-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Interpolation.html#v:zeroPad"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.LorenzAttractor",
          "name": "computeDerivatives",
          "package": "synthesizer",
          "signature": "(y, y, y) -\u003e (y, y, y) -\u003e (y, y, y)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-LorenzAttractor.html#computeDerivatives",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain LorenzAttractor",
          "module": "Synthesizer.Plain.LorenzAttractor",
          "name": "computeDerivatives",
          "normalized": "(a,a,a)-\u003e(a,a,a)-\u003e(a,a,a)",
          "package": "synthesizer",
          "partial": "Derivatives",
          "signature": "(y,y,y)-\u003e(y,y,y)-\u003e(y,y,y)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-LorenzAttractor.html#v:computeDerivatives"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.LorenzAttractor",
          "name": "equilibrium",
          "package": "synthesizer",
          "signature": "(Double, Double, Double)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-LorenzAttractor.html#equilibrium",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain LorenzAttractor",
          "module": "Synthesizer.Plain.LorenzAttractor",
          "name": "equilibrium",
          "normalized": "(Double,Double,Double)",
          "package": "synthesizer",
          "signature": "(Double,Double,Double)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-LorenzAttractor.html#v:equilibrium"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.LorenzAttractor",
          "name": "example",
          "package": "synthesizer",
          "signature": "[(Double, Double, Double)]",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-LorenzAttractor.html#example",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain LorenzAttractor",
          "module": "Synthesizer.Plain.LorenzAttractor",
          "name": "example",
          "normalized": "[(Double,Double,Double)]",
          "package": "synthesizer",
          "signature": "[(Double,Double,Double)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-LorenzAttractor.html#v:example"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.LorenzAttractor",
          "name": "example0",
          "package": "synthesizer",
          "signature": "[(Double, Double, Double)]",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-LorenzAttractor.html#example0",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain LorenzAttractor",
          "module": "Synthesizer.Plain.LorenzAttractor",
          "name": "example0",
          "normalized": "[(Double,Double,Double)]",
          "package": "synthesizer",
          "signature": "[(Double,Double,Double)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-LorenzAttractor.html#v:example0"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.LorenzAttractor",
          "name": "explicitEuler",
          "package": "synthesizer",
          "signature": "a -\u003e (v -\u003e v) -\u003e v -\u003e [v]",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-LorenzAttractor.html#explicitEuler",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain LorenzAttractor",
          "module": "Synthesizer.Plain.LorenzAttractor",
          "name": "explicitEuler",
          "normalized": "a-\u003e(b-\u003eb)-\u003eb-\u003e[b]",
          "package": "synthesizer",
          "partial": "Euler",
          "signature": "a-\u003e(v-\u003ev)-\u003ev-\u003e[v]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-LorenzAttractor.html#v:explicitEuler"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "simulate an moving sounding object\n   convert the way of the object through 3D space\n   into a delay and attenuation information,\n   sonicDelay is the reciprocal of the sonic velocity \n",
          "module": "Synthesizer.Plain.Miscellaneous",
          "name": "receive3Dsound",
          "package": "synthesizer",
          "signature": "a -\u003e a -\u003e v -\u003e [v] -\u003e ([a], [a])",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Miscellaneous.html#receive3Dsound",
          "type": "function"
        },
        "index": {
          "description": "simulate an moving sounding object convert the way of the object through space into delay and attenuation information sonicDelay is the reciprocal of the sonic velocity",
          "hierarchy": "Synthesizer Plain Miscellaneous",
          "module": "Synthesizer.Plain.Miscellaneous",
          "name": "receive3Dsound",
          "normalized": "a-\u003ea-\u003eb-\u003e[b]-\u003e([a],[a])",
          "package": "synthesizer",
          "partial": "Dsound",
          "signature": "a-\u003ea-\u003ev-\u003e[v]-\u003e([a],[a])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Miscellaneous.html#v:receive3Dsound"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Modifier",
          "name": "Initialized",
          "package": "synthesizer",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Modifier.html#Initialized",
          "type": "data"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Modifier",
          "module": "Synthesizer.Plain.Modifier",
          "name": "Initialized",
          "package": "synthesizer",
          "partial": "Initialized",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Modifier.html#t:Initialized"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Modifier",
          "name": "Simple",
          "package": "synthesizer",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Modifier.html#Simple",
          "type": "data"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Modifier",
          "module": "Synthesizer.Plain.Modifier",
          "name": "Simple",
          "package": "synthesizer",
          "partial": "Simple",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Modifier.html#t:Simple"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Modifier",
          "name": "T",
          "package": "synthesizer",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Modifier.html#T",
          "type": "type"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Modifier",
          "module": "Synthesizer.Plain.Modifier",
          "name": "T",
          "package": "synthesizer",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Modifier.html#t:T"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Modifier",
          "name": "initialize",
          "package": "synthesizer",
          "signature": "Initialized s init ctrl a b -\u003e init -\u003e Simple s ctrl a b",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Modifier.html#initialize",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Modifier",
          "module": "Synthesizer.Plain.Modifier",
          "name": "initialize",
          "normalized": "Initialized a b c d e-\u003eb-\u003eSimple a c d e",
          "package": "synthesizer",
          "signature": "Initialized s init ctrl a b-\u003einit-\u003eSimple s ctrl a b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Modifier.html#v:initialize"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Here the control may vary over the time. \n",
          "module": "Synthesizer.Plain.Modifier",
          "name": "modulated",
          "package": "synthesizer",
          "signature": "Simple s ctrl a b -\u003e T ctrl -\u003e T a -\u003e T b",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Modifier.html#modulated",
          "type": "function"
        },
        "index": {
          "description": "Here the control may vary over the time",
          "hierarchy": "Synthesizer Plain Modifier",
          "module": "Synthesizer.Plain.Modifier",
          "name": "modulated",
          "normalized": "Simple a b c d-\u003eT b-\u003eT c-\u003eT d",
          "package": "synthesizer",
          "signature": "Simple s ctrl a b-\u003eT ctrl-\u003eT a-\u003eT b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Modifier.html#v:modulated"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Here the control may vary over the time. \n",
          "module": "Synthesizer.Plain.Modifier",
          "name": "modulatedInit",
          "package": "synthesizer",
          "signature": "Initialized s init ctrl a b -\u003e init -\u003e T ctrl -\u003e T a -\u003e T b",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Modifier.html#modulatedInit",
          "type": "function"
        },
        "index": {
          "description": "Here the control may vary over the time",
          "hierarchy": "Synthesizer Plain Modifier",
          "module": "Synthesizer.Plain.Modifier",
          "name": "modulatedInit",
          "normalized": "Initialized a b c d e-\u003eb-\u003eT c-\u003eT d-\u003eT e",
          "package": "synthesizer",
          "partial": "Init",
          "signature": "Initialized s init ctrl a b-\u003einit-\u003eT ctrl-\u003eT a-\u003eT b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Modifier.html#v:modulatedInit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Modifier",
          "name": "stackStatesL",
          "package": "synthesizer",
          "signature": "(a -\u003e State s a) -\u003e a -\u003e State [s] a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Modifier.html#stackStatesL",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Modifier",
          "module": "Synthesizer.Plain.Modifier",
          "name": "stackStatesL",
          "normalized": "(a-\u003eState b a)-\u003ea-\u003eState[b]a",
          "package": "synthesizer",
          "partial": "States",
          "signature": "(a-\u003eState s a)-\u003ea-\u003eState[s]a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Modifier.html#v:stackStatesL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "The number of stacked state monads\ndepends on the size of the list of state values.\nThis is like a dynamically nested StateT.\n",
          "module": "Synthesizer.Plain.Modifier",
          "name": "stackStatesR",
          "package": "synthesizer",
          "signature": "(a -\u003e State s a) -\u003e a -\u003e State [s] a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Modifier.html#stackStatesR",
          "type": "function"
        },
        "index": {
          "description": "The number of stacked state monads depends on the size of the list of state values This is like dynamically nested StateT",
          "hierarchy": "Synthesizer Plain Modifier",
          "module": "Synthesizer.Plain.Modifier",
          "name": "stackStatesR",
          "normalized": "(a-\u003eState b a)-\u003ea-\u003eState[b]a",
          "package": "synthesizer",
          "partial": "States",
          "signature": "(a-\u003eState s a)-\u003ea-\u003eState[s]a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Modifier.html#v:stackStatesR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Modifier",
          "name": "stackStatesStorableL",
          "package": "synthesizer",
          "signature": "(a -\u003e State s a) -\u003e a -\u003e State (Vector s) a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Modifier.html#stackStatesStorableL",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Modifier",
          "module": "Synthesizer.Plain.Modifier",
          "name": "stackStatesStorableL",
          "normalized": "(a-\u003eState b a)-\u003ea-\u003eState(Vector b)a",
          "package": "synthesizer",
          "partial": "States Storable",
          "signature": "(a-\u003eState s a)-\u003ea-\u003eState(Vector s)a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Modifier.html#v:stackStatesStorableL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Modifier",
          "name": "stackStatesStorableR",
          "package": "synthesizer",
          "signature": "(a -\u003e State s a) -\u003e a -\u003e State (Vector s) a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Modifier.html#stackStatesStorableR",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Modifier",
          "module": "Synthesizer.Plain.Modifier",
          "name": "stackStatesStorableR",
          "normalized": "(a-\u003eState b a)-\u003ea-\u003eState(Vector b)a",
          "package": "synthesizer",
          "partial": "States Storable",
          "signature": "(a-\u003eState s a)-\u003ea-\u003eState(Vector s)a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Modifier.html#v:stackStatesStorableR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Modifier",
          "name": "stackStatesStorableVaryL",
          "package": "synthesizer",
          "signature": "(c -\u003e a -\u003e State s a) -\u003e Vector c -\u003e a -\u003e State (Vector s) a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Modifier.html#stackStatesStorableVaryL",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Modifier",
          "module": "Synthesizer.Plain.Modifier",
          "name": "stackStatesStorableVaryL",
          "normalized": "(a-\u003eb-\u003eState c b)-\u003eVector a-\u003eb-\u003eState(Vector c)b",
          "package": "synthesizer",
          "partial": "States Storable Vary",
          "signature": "(c-\u003ea-\u003eState s a)-\u003eVector c-\u003ea-\u003eState(Vector s)a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Modifier.html#v:stackStatesStorableVaryL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003emodif is a process controlled by values of type c\nwith an internal state of type s,\nit converts an input value of type a into an output value of type b\nwhile turning into a new state\n\u003c/p\u003e\u003cp\u003eToDo:\nShall finite signals be padded with zeros?\n\u003c/p\u003e",
          "module": "Synthesizer.Plain.Modifier",
          "name": "static",
          "package": "synthesizer",
          "signature": "Simple s ctrl a b -\u003e ctrl -\u003e T a -\u003e T b",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Modifier.html#static",
          "type": "function"
        },
        "index": {
          "description": "modif is process controlled by values of type with an internal state of type it converts an input value of type into an output value of type while turning into new state ToDo Shall finite signals be padded with zeros",
          "hierarchy": "Synthesizer Plain Modifier",
          "module": "Synthesizer.Plain.Modifier",
          "name": "static",
          "normalized": "Simple a b c d-\u003eb-\u003eT c-\u003eT d",
          "package": "synthesizer",
          "signature": "Simple s ctrl a b-\u003ectrl-\u003eT a-\u003eT b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Modifier.html#v:static"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Modifier",
          "name": "staticInit",
          "package": "synthesizer",
          "signature": "Initialized s init ctrl a b -\u003e init -\u003e ctrl -\u003e T a -\u003e T b",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Modifier.html#staticInit",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Modifier",
          "module": "Synthesizer.Plain.Modifier",
          "name": "staticInit",
          "normalized": "Initialized a b c d e-\u003eb-\u003ec-\u003eT d-\u003eT e",
          "package": "synthesizer",
          "partial": "Init",
          "signature": "Initialized s init ctrl a b-\u003einit-\u003ectrl-\u003eT a-\u003eT b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Modifier.html#v:staticInit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "momentary densities, \u003ctt\u003ep\u003c/tt\u003e means that there is about one peak\n                      in the time range of \u003ctt\u003e1/p\u003c/tt\u003e samples \nEvery occurence of \u003ctt\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/tt\u003e represents a peak. \n",
          "module": "Synthesizer.Plain.Noise",
          "name": "randomPeeks",
          "package": "synthesizer",
          "signature": "T y-\u003e T Bool",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Noise.html#randomPeeks",
          "type": "function"
        },
        "index": {
          "description": "momentary densities means that there is about one peak in the time range of samples Every occurence of True represents peak",
          "hierarchy": "Synthesizer Plain Noise",
          "module": "Synthesizer.Plain.Noise",
          "name": "randomPeeks",
          "normalized": "T a-\u003eT Bool",
          "package": "synthesizer",
          "partial": "Peeks",
          "signature": "T y-\u003eT Bool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Noise.html#v:randomPeeks"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Noise",
          "name": "randomPeeksGen",
          "package": "synthesizer",
          "signature": "g -\u003e T y -\u003e T Bool",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Noise.html#randomPeeksGen",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Noise",
          "module": "Synthesizer.Plain.Noise",
          "name": "randomPeeksGen",
          "normalized": "a-\u003eT b-\u003eT Bool",
          "package": "synthesizer",
          "partial": "Peeks Gen",
          "signature": "g-\u003eT y-\u003eT Bool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Noise.html#v:randomPeeksGen"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Deterministic white noise, uniformly distributed between -1 and 1.\nThat is, variance is 1/3.\n",
          "module": "Synthesizer.Plain.Noise",
          "name": "white",
          "package": "synthesizer",
          "signature": "T y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Noise.html#white",
          "type": "function"
        },
        "index": {
          "description": "Deterministic white noise uniformly distributed between and That is variance is",
          "hierarchy": "Synthesizer Plain Noise",
          "module": "Synthesizer.Plain.Noise",
          "name": "white",
          "package": "synthesizer",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Noise.html#v:white"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Noise",
          "name": "whiteGen",
          "package": "synthesizer",
          "signature": "g -\u003e T y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Noise.html#whiteGen",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Noise",
          "module": "Synthesizer.Plain.Noise",
          "name": "whiteGen",
          "normalized": "a-\u003eT b",
          "package": "synthesizer",
          "partial": "Gen",
          "signature": "g-\u003eT y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Noise.html#v:whiteGen"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Approximates normal distribution with variance 1\nby a quadratic B-spline distribution.\n",
          "module": "Synthesizer.Plain.Noise",
          "name": "whiteQuadraticBSplineGen",
          "package": "synthesizer",
          "signature": "g -\u003e T y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Noise.html#whiteQuadraticBSplineGen",
          "type": "function"
        },
        "index": {
          "description": "Approximates normal distribution with variance by quadratic B-spline distribution",
          "hierarchy": "Synthesizer Plain Noise",
          "module": "Synthesizer.Plain.Noise",
          "name": "whiteQuadraticBSplineGen",
          "normalized": "a-\u003eT b",
          "package": "synthesizer",
          "partial": "Quadratic BSpline Gen",
          "signature": "g-\u003eT y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Noise.html#v:whiteQuadraticBSplineGen"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Oscillator",
          "name": "Phase",
          "package": "synthesizer",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Oscillator.html#Phase",
          "type": "type"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Oscillator",
          "module": "Synthesizer.Plain.Oscillator",
          "name": "Phase",
          "package": "synthesizer",
          "partial": "Phase",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Oscillator.html#t:Phase"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "oscillator with modulated frequency \n",
          "module": "Synthesizer.Plain.Oscillator",
          "name": "freqMod",
          "package": "synthesizer",
          "signature": "T a b -\u003e Phase a -\u003e T a -\u003e T b",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Oscillator.html#freqMod",
          "type": "function"
        },
        "index": {
          "description": "oscillator with modulated frequency",
          "hierarchy": "Synthesizer Plain Oscillator",
          "module": "Synthesizer.Plain.Oscillator",
          "name": "freqMod",
          "normalized": "T a b-\u003ePhase a-\u003eT a-\u003eT b",
          "package": "synthesizer",
          "partial": "Mod",
          "signature": "T a b-\u003ePhase a-\u003eT a-\u003eT b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Oscillator.html#v:freqMod"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "oscillator with a sampled waveform with modulated frequency\n     Should behave homogenously for different types of interpolation. \n",
          "module": "Synthesizer.Plain.Oscillator",
          "name": "freqModSample",
          "package": "synthesizer",
          "signature": "T a b -\u003e [b] -\u003e Phase a -\u003e T a -\u003e T b",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Oscillator.html#freqModSample",
          "type": "function"
        },
        "index": {
          "description": "oscillator with sampled waveform with modulated frequency Should behave homogenously for different types of interpolation",
          "hierarchy": "Synthesizer Plain Oscillator",
          "module": "Synthesizer.Plain.Oscillator",
          "name": "freqModSample",
          "normalized": "T a b-\u003e[b]-\u003ePhase a-\u003eT a-\u003eT b",
          "package": "synthesizer",
          "partial": "Mod Sample",
          "signature": "T a b-\u003e[b]-\u003ePhase a-\u003eT a-\u003eT b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Oscillator.html#v:freqModSample"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "saw tooth oscillator with modulated frequency \n",
          "module": "Synthesizer.Plain.Oscillator",
          "name": "freqModSaw",
          "package": "synthesizer",
          "signature": "a -\u003e T a -\u003e T a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Oscillator.html#freqModSaw",
          "type": "function"
        },
        "index": {
          "description": "saw tooth oscillator with modulated frequency",
          "hierarchy": "Synthesizer Plain Oscillator",
          "module": "Synthesizer.Plain.Oscillator",
          "name": "freqModSaw",
          "normalized": "a-\u003eT a-\u003eT a",
          "package": "synthesizer",
          "partial": "Mod Saw",
          "signature": "a-\u003eT a-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Oscillator.html#v:freqModSaw"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "sine oscillator with modulated frequency \n",
          "module": "Synthesizer.Plain.Oscillator",
          "name": "freqModSine",
          "package": "synthesizer",
          "signature": "a -\u003e T a -\u003e T a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Oscillator.html#freqModSine",
          "type": "function"
        },
        "index": {
          "description": "sine oscillator with modulated frequency",
          "hierarchy": "Synthesizer Plain Oscillator",
          "module": "Synthesizer.Plain.Oscillator",
          "name": "freqModSine",
          "normalized": "a-\u003eT a-\u003eT a",
          "package": "synthesizer",
          "partial": "Mod Sine",
          "signature": "a-\u003eT a-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Oscillator.html#v:freqModSine"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "oscillator with both phase and frequency modulation \n",
          "module": "Synthesizer.Plain.Oscillator",
          "name": "phaseFreqMod",
          "package": "synthesizer",
          "signature": "T a b -\u003e T (Phase a) -\u003e T a -\u003e T b",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Oscillator.html#phaseFreqMod",
          "type": "function"
        },
        "index": {
          "description": "oscillator with both phase and frequency modulation",
          "hierarchy": "Synthesizer Plain Oscillator",
          "module": "Synthesizer.Plain.Oscillator",
          "name": "phaseFreqMod",
          "normalized": "T a b-\u003eT(Phase a)-\u003eT a-\u003eT b",
          "package": "synthesizer",
          "partial": "Freq Mod",
          "signature": "T a b-\u003eT(Phase a)-\u003eT a-\u003eT b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Oscillator.html#v:phaseFreqMod"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "oscillator with modulated phase \n",
          "module": "Synthesizer.Plain.Oscillator",
          "name": "phaseMod",
          "package": "synthesizer",
          "signature": "T a b -\u003e a -\u003e T (Phase a) -\u003e T b",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Oscillator.html#phaseMod",
          "type": "function"
        },
        "index": {
          "description": "oscillator with modulated phase",
          "hierarchy": "Synthesizer Plain Oscillator",
          "module": "Synthesizer.Plain.Oscillator",
          "name": "phaseMod",
          "normalized": "T a b-\u003ea-\u003eT(Phase a)-\u003eT b",
          "package": "synthesizer",
          "partial": "Mod",
          "signature": "T a b-\u003ea-\u003eT(Phase a)-\u003eT b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Oscillator.html#v:phaseMod"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "sine oscillator with modulated phase, useful for FM synthesis \n",
          "module": "Synthesizer.Plain.Oscillator",
          "name": "phaseModSine",
          "package": "synthesizer",
          "signature": "a -\u003e T a -\u003e T a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Oscillator.html#phaseModSine",
          "type": "function"
        },
        "index": {
          "description": "sine oscillator with modulated phase useful for FM synthesis",
          "hierarchy": "Synthesizer Plain Oscillator",
          "module": "Synthesizer.Plain.Oscillator",
          "name": "phaseModSine",
          "normalized": "a-\u003eT a-\u003eT a",
          "package": "synthesizer",
          "partial": "Mod Sine",
          "signature": "a-\u003eT a-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Oscillator.html#v:phaseModSine"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "oscillator with both shape and frequency modulation \n",
          "module": "Synthesizer.Plain.Oscillator",
          "name": "shapeFreqMod",
          "package": "synthesizer",
          "signature": "(c -\u003e T a b) -\u003e Phase a -\u003e T c -\u003e T a -\u003e T b",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Oscillator.html#shapeFreqMod",
          "type": "function"
        },
        "index": {
          "description": "oscillator with both shape and frequency modulation",
          "hierarchy": "Synthesizer Plain Oscillator",
          "module": "Synthesizer.Plain.Oscillator",
          "name": "shapeFreqMod",
          "normalized": "(a-\u003eT b c)-\u003ePhase b-\u003eT a-\u003eT b-\u003eT c",
          "package": "synthesizer",
          "partial": "Freq Mod",
          "signature": "(c-\u003eT a b)-\u003ePhase a-\u003eT c-\u003eT a-\u003eT b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Oscillator.html#v:shapeFreqMod"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTime stretching and frequency modulation of a pure tone.\n\u003c/p\u003e\u003cp\u003eWe consider a tone as the result of a shape modulated oscillator,\nand virtually reconstruct the waveform function\n(a function of time and phase) by interpolation and resample it.\nThis way we can alter frequency and time progress of the tone independently.\n\u003c/p\u003e\u003cp\u003eThis function is identical to using \u003ctt\u003e\u003ca\u003eshapeFreqMod\u003c/a\u003e\u003c/tt\u003e\nwith a wave function constructed by Wave.sampledTone\nbut it consumes the sampled source tone lazily\nand thus allows only relative shape control with non-negative control steps.\n\u003c/p\u003e\u003cp\u003eThe function is similar to \u003ctt\u003e\u003ca\u003eshapeFreqModSample\u003c/a\u003e\u003c/tt\u003e but respects\nthat in a sampled tone, phase and shape control advance synchronously.\nActually we could re-use \u003ctt\u003e\u003ca\u003eshapeFreqModSample\u003c/a\u003e\u003c/tt\u003e with modified phase values.\nBut we would have to cope with negative shape control jumps,\nand waves would be padded locally cyclically.\nThe latter one is not wanted\nsince we want padding according to the adjacencies in the source tone.\nNote that differently from \u003ctt\u003e\u003ca\u003eshapeFreqModSample\u003c/a\u003e\u003c/tt\u003e\nthe shape control difference \u003ctt\u003e1\u003c/tt\u003e does not mean to skip to the next wave,\nsince this oscillator has no discrete waveforms.\nInstead \u003ctt\u003e1\u003c/tt\u003e means that the shape alters as fast as in the prototype signal.\n\u003c/p\u003e\u003cp\u003eAlthough the shape difference values must be non-negative\nI hesitate to give them the type \u003ctt\u003eNumber.NonNegative.T t\u003c/tt\u003e\nbecause then you cannot call this function with other types\nof non-negative numbers like Number.NonNegativeChunky.T.\n\u003c/p\u003e\u003cp\u003eThe prototype tone signal is reproduced if\n\u003ctt\u003efreqs == repeat (1/period)\u003c/tt\u003e and \u003ctt\u003eshapes == repeat 1\u003c/tt\u003e.\n\u003c/p\u003e",
          "module": "Synthesizer.Plain.Oscillator",
          "name": "shapeFreqModFromSampledTone",
          "package": "synthesizer",
          "signature": "T t y -\u003e T t y -\u003e t -\u003e T y -\u003e t -\u003e t -\u003e T t -\u003e T t -\u003e T y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Oscillator.html#shapeFreqModFromSampledTone",
          "type": "function"
        },
        "index": {
          "description": "Time stretching and frequency modulation of pure tone We consider tone as the result of shape modulated oscillator and virtually reconstruct the waveform function function of time and phase by interpolation and resample it This way we can alter frequency and time progress of the tone independently This function is identical to using shapeFreqMod with wave function constructed by Wave.sampledTone but it consumes the sampled source tone lazily and thus allows only relative shape control with non-negative control steps The function is similar to shapeFreqModSample but respects that in sampled tone phase and shape control advance synchronously Actually we could re-use shapeFreqModSample with modified phase values But we would have to cope with negative shape control jumps and waves would be padded locally cyclically The latter one is not wanted since we want padding according to the adjacencies in the source tone Note that differently from shapeFreqModSample the shape control difference does not mean to skip to the next wave since this oscillator has no discrete waveforms Instead means that the shape alters as fast as in the prototype signal Although the shape difference values must be non-negative hesitate to give them the type Number.NonNegative.T because then you cannot call this function with other types of non-negative numbers like Number.NonNegativeChunky.T The prototype tone signal is reproduced if freqs repeat period and shapes repeat",
          "hierarchy": "Synthesizer Plain Oscillator",
          "module": "Synthesizer.Plain.Oscillator",
          "name": "shapeFreqModFromSampledTone",
          "normalized": "T a b-\u003eT a b-\u003ea-\u003eT b-\u003ea-\u003ea-\u003eT a-\u003eT a-\u003eT b",
          "package": "synthesizer",
          "partial": "Freq Mod From Sampled Tone",
          "signature": "T t y-\u003eT t y-\u003et-\u003eT y-\u003et-\u003et-\u003eT t-\u003eT t-\u003eT y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Oscillator.html#v:shapeFreqModFromSampledTone"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eShape control is a list of relative changes,\neach of which must be non-negative in order to allow lazy processing.\n'1' advances by one wave.\nFrequency control can be negative.\nIf you want to use sampled waveforms as well\nthen use Wave.sample in the list of waveforms.\nWith sampled waves this function is identical to HunkTranspose in Assampler.\n\u003c/p\u003e\u003cp\u003eExample: interpolate different versions\nof Wave.oddCosine and Wave.oddTriangle.\n\u003c/p\u003e\u003cp\u003eYou could also chop a tone into single waves\nand use the waves as input for this function\nbut you certainly want to use\nWave.sampledTone or \u003ctt\u003e\u003ca\u003eshapeFreqModFromSampledTone\u003c/a\u003e\u003c/tt\u003e instead,\nbecause in the wave information for \u003ctt\u003e\u003ca\u003eshapeFreqModSample\u003c/a\u003e\u003c/tt\u003e\nshape and phase are strictly separated.\n\u003c/p\u003e",
          "module": "Synthesizer.Plain.Oscillator",
          "name": "shapeFreqModSample",
          "package": "synthesizer",
          "signature": "T c (T b a) -\u003e [T b a] -\u003e c -\u003e Phase b -\u003e T c -\u003e T b -\u003e T a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Oscillator.html#shapeFreqModSample",
          "type": "function"
        },
        "index": {
          "description": "Shape control is list of relative changes each of which must be non-negative in order to allow lazy processing advances by one wave Frequency control can be negative If you want to use sampled waveforms as well then use Wave.sample in the list of waveforms With sampled waves this function is identical to HunkTranspose in Assampler Example interpolate different versions of Wave.oddCosine and Wave.oddTriangle You could also chop tone into single waves and use the waves as input for this function but you certainly want to use Wave.sampledTone or shapeFreqModFromSampledTone instead because in the wave information for shapeFreqModSample shape and phase are strictly separated",
          "hierarchy": "Synthesizer Plain Oscillator",
          "module": "Synthesizer.Plain.Oscillator",
          "name": "shapeFreqModSample",
          "normalized": "T a(T b c)-\u003e[T b c]-\u003ea-\u003ePhase b-\u003eT a-\u003eT b-\u003eT c",
          "package": "synthesizer",
          "partial": "Freq Mod Sample",
          "signature": "T c(T b a)-\u003e[T b a]-\u003ec-\u003ePhase b-\u003eT c-\u003eT b-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Oscillator.html#v:shapeFreqModSample"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "oscillator with modulated shape \n",
          "module": "Synthesizer.Plain.Oscillator",
          "name": "shapeMod",
          "package": "synthesizer",
          "signature": "(c -\u003e T a b) -\u003e Phase a -\u003e a -\u003e T c -\u003e T b",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Oscillator.html#shapeMod",
          "type": "function"
        },
        "index": {
          "description": "oscillator with modulated shape",
          "hierarchy": "Synthesizer Plain Oscillator",
          "module": "Synthesizer.Plain.Oscillator",
          "name": "shapeMod",
          "normalized": "(a-\u003eT b c)-\u003ePhase b-\u003eb-\u003eT a-\u003eT c",
          "package": "synthesizer",
          "partial": "Mod",
          "signature": "(c-\u003eT a b)-\u003ePhase a-\u003ea-\u003eT c-\u003eT b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Oscillator.html#v:shapeMod"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Oscillator",
          "name": "shapePhaseFreqModFromSampledTone",
          "package": "synthesizer",
          "signature": "T t y -\u003e T t y -\u003e t -\u003e T y -\u003e t -\u003e t -\u003e T t -\u003e T t -\u003e T t -\u003e T y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Oscillator.html#shapePhaseFreqModFromSampledTone",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Oscillator",
          "module": "Synthesizer.Plain.Oscillator",
          "name": "shapePhaseFreqModFromSampledTone",
          "normalized": "T a b-\u003eT a b-\u003ea-\u003eT b-\u003ea-\u003ea-\u003eT a-\u003eT a-\u003eT a-\u003eT b",
          "package": "synthesizer",
          "partial": "Phase Freq Mod From Sampled Tone",
          "signature": "T t y-\u003eT t y-\u003et-\u003eT y-\u003et-\u003et-\u003eT t-\u003eT t-\u003eT t-\u003eT y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Oscillator.html#v:shapePhaseFreqModFromSampledTone"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Oscillator",
          "name": "shapePhaseFreqModSample",
          "package": "synthesizer",
          "signature": "T c (T b a) -\u003e [T b a] -\u003e c -\u003e T c -\u003e T (Phase b) -\u003e T b -\u003e T a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Oscillator.html#shapePhaseFreqModSample",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Oscillator",
          "module": "Synthesizer.Plain.Oscillator",
          "name": "shapePhaseFreqModSample",
          "normalized": "T a(T b c)-\u003e[T b c]-\u003ea-\u003eT a-\u003eT(Phase b)-\u003eT b-\u003eT c",
          "package": "synthesizer",
          "partial": "Phase Freq Mod Sample",
          "signature": "T c(T b a)-\u003e[T b a]-\u003ec-\u003eT c-\u003eT(Phase b)-\u003eT b-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Oscillator.html#v:shapePhaseFreqModSample"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "oscillator with constant frequency \n",
          "module": "Synthesizer.Plain.Oscillator",
          "name": "static",
          "package": "synthesizer",
          "signature": "T a b -\u003e Phase a -\u003e a -\u003e T b",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Oscillator.html#static",
          "type": "function"
        },
        "index": {
          "description": "oscillator with constant frequency",
          "hierarchy": "Synthesizer Plain Oscillator",
          "module": "Synthesizer.Plain.Oscillator",
          "name": "static",
          "normalized": "T a b-\u003ePhase a-\u003ea-\u003eT b",
          "package": "synthesizer",
          "signature": "T a b-\u003ePhase a-\u003ea-\u003eT b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Oscillator.html#v:static"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "oscillator with a sampled waveform with constant frequency\n     This is essentially an interpolation with cyclic padding. \n",
          "module": "Synthesizer.Plain.Oscillator",
          "name": "staticSample",
          "package": "synthesizer",
          "signature": "T a b -\u003e [b] -\u003e Phase a -\u003e a -\u003e T b",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Oscillator.html#staticSample",
          "type": "function"
        },
        "index": {
          "description": "oscillator with sampled waveform with constant frequency This is essentially an interpolation with cyclic padding",
          "hierarchy": "Synthesizer Plain Oscillator",
          "module": "Synthesizer.Plain.Oscillator",
          "name": "staticSample",
          "normalized": "T a b-\u003e[b]-\u003ePhase a-\u003ea-\u003eT b",
          "package": "synthesizer",
          "partial": "Sample",
          "signature": "T a b-\u003e[b]-\u003ePhase a-\u003ea-\u003eT b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Oscillator.html#v:staticSample"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "saw tooth oscillator with modulated frequency \n",
          "module": "Synthesizer.Plain.Oscillator",
          "name": "staticSaw",
          "package": "synthesizer",
          "signature": "a -\u003e a -\u003e T a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Oscillator.html#staticSaw",
          "type": "function"
        },
        "index": {
          "description": "saw tooth oscillator with modulated frequency",
          "hierarchy": "Synthesizer Plain Oscillator",
          "module": "Synthesizer.Plain.Oscillator",
          "name": "staticSaw",
          "normalized": "a-\u003ea-\u003eT a",
          "package": "synthesizer",
          "partial": "Saw",
          "signature": "a-\u003ea-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Oscillator.html#v:staticSaw"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "sine oscillator with static frequency \n",
          "module": "Synthesizer.Plain.Oscillator",
          "name": "staticSine",
          "package": "synthesizer",
          "signature": "a -\u003e a -\u003e T a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Oscillator.html#staticSine",
          "type": "function"
        },
        "index": {
          "description": "sine oscillator with static frequency",
          "hierarchy": "Synthesizer Plain Oscillator",
          "module": "Synthesizer.Plain.Oscillator",
          "name": "staticSine",
          "normalized": "a-\u003ea-\u003eT a",
          "package": "synthesizer",
          "partial": "Sine",
          "signature": "a-\u003ea-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Oscillator.html#v:staticSine"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "See Synthesizer.Plain.File.write.\n",
          "module": "Synthesizer.Plain.Play",
          "name": "auto",
          "package": "synthesizer",
          "signature": "Put int -\u003e a -\u003e [v] -\u003e IO ExitCode",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Play.html#auto",
          "type": "function"
        },
        "index": {
          "description": "See Synthesizer.Plain.File.write",
          "hierarchy": "Synthesizer Plain Play",
          "module": "Synthesizer.Plain.Play",
          "name": "auto",
          "normalized": "Put a-\u003eb-\u003e[c]-\u003eIO ExitCode",
          "package": "synthesizer",
          "signature": "Put int-\u003ea-\u003e[v]-\u003eIO ExitCode",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Play.html#v:auto"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Play",
          "name": "exampleMono",
          "package": "synthesizer",
          "signature": "IO ExitCode",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Play.html#exampleMono",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Play",
          "module": "Synthesizer.Plain.Play",
          "name": "exampleMono",
          "package": "synthesizer",
          "partial": "Mono",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Play.html#v:exampleMono"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Play",
          "name": "exampleStereo",
          "package": "synthesizer",
          "signature": "IO ExitCode",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Play.html#exampleStereo",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Play",
          "module": "Synthesizer.Plain.Play",
          "name": "exampleStereo",
          "package": "synthesizer",
          "partial": "Stereo",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Play.html#v:exampleStereo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Play",
          "name": "monoToInt16",
          "package": "synthesizer",
          "signature": "a -\u003e [a] -\u003e IO ExitCode",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Play.html#monoToInt16",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Play",
          "module": "Synthesizer.Plain.Play",
          "name": "monoToInt16",
          "normalized": "a-\u003e[a]-\u003eIO ExitCode",
          "package": "synthesizer",
          "partial": "To Int",
          "signature": "a-\u003e[a]-\u003eIO ExitCode",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Play.html#v:monoToInt16"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Play",
          "name": "raw",
          "package": "synthesizer",
          "signature": "T -\u003e a -\u003e [v] -\u003e IO ExitCode",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Play.html#raw",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Play",
          "module": "Synthesizer.Plain.Play",
          "name": "raw",
          "normalized": "T-\u003ea-\u003e[b]-\u003eIO ExitCode",
          "package": "synthesizer",
          "signature": "T-\u003ea-\u003e[v]-\u003eIO ExitCode",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Play.html#v:raw"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "See Synthesizer.Plain.File.write.\n",
          "module": "Synthesizer.Plain.Play",
          "name": "render",
          "package": "synthesizer",
          "signature": "Put int -\u003e a -\u003e (a -\u003e [v]) -\u003e IO ExitCode",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Play.html#render",
          "type": "function"
        },
        "index": {
          "description": "See Synthesizer.Plain.File.write",
          "hierarchy": "Synthesizer Plain Play",
          "module": "Synthesizer.Plain.Play",
          "name": "render",
          "normalized": "Put a-\u003eb-\u003e(b-\u003e[c])-\u003eIO ExitCode",
          "package": "synthesizer",
          "signature": "Put int-\u003ea-\u003e(a-\u003e[v])-\u003eIO ExitCode",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Play.html#v:render"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Play",
          "name": "renderMonoToInt16",
          "package": "synthesizer",
          "signature": "a -\u003e (a -\u003e [a]) -\u003e IO ExitCode",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Play.html#renderMonoToInt16",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Play",
          "module": "Synthesizer.Plain.Play",
          "name": "renderMonoToInt16",
          "normalized": "a-\u003e(a-\u003e[a])-\u003eIO ExitCode",
          "package": "synthesizer",
          "partial": "Mono To Int",
          "signature": "a-\u003e(a-\u003e[a])-\u003eIO ExitCode",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Play.html#v:renderMonoToInt16"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Play",
          "name": "renderStereoToInt16",
          "package": "synthesizer",
          "signature": "a -\u003e (a -\u003e [(a, a)]) -\u003e IO ExitCode",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Play.html#renderStereoToInt16",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Play",
          "module": "Synthesizer.Plain.Play",
          "name": "renderStereoToInt16",
          "normalized": "a-\u003e(a-\u003e[(a,a)])-\u003eIO ExitCode",
          "package": "synthesizer",
          "partial": "Stereo To Int",
          "signature": "a-\u003e(a-\u003e[(a,a)])-\u003eIO ExitCode",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Play.html#v:renderStereoToInt16"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Play",
          "name": "renderToInt16",
          "package": "synthesizer",
          "signature": "a -\u003e (a -\u003e [v]) -\u003e IO ExitCode",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Play.html#renderToInt16",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Play",
          "module": "Synthesizer.Plain.Play",
          "name": "renderToInt16",
          "normalized": "a-\u003e(a-\u003e[b])-\u003eIO ExitCode",
          "package": "synthesizer",
          "partial": "To Int",
          "signature": "a-\u003e(a-\u003e[v])-\u003eIO ExitCode",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Play.html#v:renderToInt16"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Play",
          "name": "stereoToInt16",
          "package": "synthesizer",
          "signature": "a -\u003e [(a, a)] -\u003e IO ExitCode",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Play.html#stereoToInt16",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Play",
          "module": "Synthesizer.Plain.Play",
          "name": "stereoToInt16",
          "normalized": "a-\u003e[(a,a)]-\u003eIO ExitCode",
          "package": "synthesizer",
          "partial": "To Int",
          "signature": "a-\u003e[(a,a)]-\u003eIO ExitCode",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Play.html#v:stereoToInt16"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Play",
          "name": "toInt16",
          "package": "synthesizer",
          "signature": "a -\u003e [v] -\u003e IO ExitCode",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Play.html#toInt16",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Play",
          "module": "Synthesizer.Plain.Play",
          "name": "toInt16",
          "normalized": "a-\u003e[b]-\u003eIO ExitCode",
          "package": "synthesizer",
          "partial": "Int",
          "signature": "a-\u003e[v]-\u003eIO ExitCode",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Play.html#v:toInt16"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Signal",
          "name": "Modifier",
          "package": "synthesizer",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Signal.html#Modifier",
          "type": "type"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Signal",
          "module": "Synthesizer.Plain.Signal",
          "name": "Modifier",
          "package": "synthesizer",
          "partial": "Modifier",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Signal.html#t:Modifier"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Signal",
          "name": "ModifierInit",
          "package": "synthesizer",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Signal.html#ModifierInit",
          "type": "type"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Signal",
          "module": "Synthesizer.Plain.Signal",
          "name": "ModifierInit",
          "package": "synthesizer",
          "partial": "Modifier Init",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Signal.html#t:ModifierInit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Signal",
          "name": "T",
          "package": "synthesizer",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Signal.html#T",
          "type": "type"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Signal",
          "module": "Synthesizer.Plain.Signal",
          "name": "T",
          "package": "synthesizer",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Signal.html#t:T"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Signal",
          "name": "crochetL",
          "package": "synthesizer",
          "signature": "(x -\u003e acc -\u003e Maybe (y, acc)) -\u003e acc -\u003e T x -\u003e T y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Signal.html#crochetL",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Signal",
          "module": "Synthesizer.Plain.Signal",
          "name": "crochetL",
          "normalized": "(a-\u003eb-\u003eMaybe(c,b))-\u003eb-\u003eT a-\u003eT c",
          "package": "synthesizer",
          "signature": "(x-\u003eacc-\u003eMaybe(y,acc))-\u003eacc-\u003eT x-\u003eT y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Signal.html#v:crochetL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Signal",
          "name": "dropMargin",
          "package": "synthesizer",
          "signature": "Int -\u003e Int -\u003e T a -\u003e T a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Signal.html#dropMargin",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Signal",
          "module": "Synthesizer.Plain.Signal",
          "name": "dropMargin",
          "normalized": "Int-\u003eInt-\u003eT a-\u003eT a",
          "package": "synthesizer",
          "partial": "Margin",
          "signature": "Int-\u003eInt-\u003eT a-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Signal.html#v:dropMargin"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003ctt\u003edropMarginRem n m xs\u003c/tt\u003e\ndrops at most the first \u003ctt\u003em\u003c/tt\u003e elements of \u003ctt\u003exs\u003c/tt\u003e\nand ensures that \u003ctt\u003exs\u003c/tt\u003e still contains \u003ctt\u003en\u003c/tt\u003e elements.\nAdditionally returns the number of elements that could not be dropped\ndue to the margin constraint.\nThat is \u003ctt\u003edropMarginRem n m xs == (k,ys)\u003c/tt\u003e implies \u003ctt\u003elength xs - m == length ys - k\u003c/tt\u003e.\nRequires \u003ctt\u003elength xs \u003e= n\u003c/tt\u003e.\n",
          "module": "Synthesizer.Plain.Signal",
          "name": "dropMarginRem",
          "package": "synthesizer",
          "signature": "Int -\u003e Int -\u003e T a -\u003e (Int, T a)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Signal.html#dropMarginRem",
          "type": "function"
        },
        "index": {
          "description": "dropMarginRem xs drops at most the first elements of xs and ensures that xs still contains elements Additionally returns the number of elements that could not be dropped due to the margin constraint That is dropMarginRem xs ys implies length xs length ys Requires length xs",
          "hierarchy": "Synthesizer Plain Signal",
          "module": "Synthesizer.Plain.Signal",
          "name": "dropMarginRem",
          "normalized": "Int-\u003eInt-\u003eT a-\u003e(Int,T a)",
          "package": "synthesizer",
          "partial": "Margin Rem",
          "signature": "Int-\u003eInt-\u003eT a-\u003e(Int,T a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Signal.html#v:dropMarginRem"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Feed back signal into signal processor,\nand apply a delay by one value.\n\u003ctt\u003e\u003ca\u003efix1\u003c/a\u003e\u003c/tt\u003e is a kind of Signal.generate.\n",
          "module": "Synthesizer.Plain.Signal",
          "name": "fix1",
          "package": "synthesizer",
          "signature": "y -\u003e (T y -\u003e T y) -\u003e T y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Signal.html#fix1",
          "type": "function"
        },
        "index": {
          "description": "Feed back signal into signal processor and apply delay by one value fix1 is kind of Signal.generate",
          "hierarchy": "Synthesizer Plain Signal",
          "module": "Synthesizer.Plain.Signal",
          "name": "fix1",
          "normalized": "a-\u003e(T a-\u003eT a)-\u003eT a",
          "package": "synthesizer",
          "signature": "y-\u003e(T y-\u003eT y)-\u003eT y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Signal.html#v:fix1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Test whether a list has at least \u003ctt\u003en\u003c/tt\u003e elements.\n",
          "module": "Synthesizer.Plain.Signal",
          "name": "lengthAtLeast",
          "package": "synthesizer",
          "signature": "Int -\u003e T a -\u003e Bool",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Signal.html#lengthAtLeast",
          "type": "function"
        },
        "index": {
          "description": "Test whether list has at least elements",
          "hierarchy": "Synthesizer Plain Signal",
          "module": "Synthesizer.Plain.Signal",
          "name": "lengthAtLeast",
          "normalized": "Int-\u003eT a-\u003eBool",
          "package": "synthesizer",
          "partial": "At Least",
          "signature": "Int-\u003eT a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Signal.html#v:lengthAtLeast"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Signal",
          "name": "mapAccumL",
          "package": "synthesizer",
          "signature": "(x -\u003e acc -\u003e Maybe (y, acc)) -\u003e acc -\u003e T x -\u003e (acc, T y)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Signal.html#mapAccumL",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Signal",
          "module": "Synthesizer.Plain.Signal",
          "name": "mapAccumL",
          "normalized": "(a-\u003eb-\u003eMaybe(c,b))-\u003eb-\u003eT a-\u003e(b,T c)",
          "package": "synthesizer",
          "partial": "Accum",
          "signature": "(x-\u003eacc-\u003eMaybe(y,acc))-\u003eacc-\u003eT x-\u003e(acc,T y)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Signal.html#v:mapAccumL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Signal",
          "name": "modifierInitialize",
          "package": "synthesizer",
          "signature": "ModifierInit s init ctrl a b -\u003e init -\u003e Modifier s ctrl a b",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Signal.html#modifierInitialize",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Signal",
          "module": "Synthesizer.Plain.Signal",
          "name": "modifierInitialize",
          "normalized": "ModifierInit a b c d e-\u003eb-\u003eModifier a c d e",
          "package": "synthesizer",
          "partial": "Initialize",
          "signature": "ModifierInit s init ctrl a b-\u003einit-\u003eModifier s ctrl a b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Signal.html#v:modifierInitialize"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Here the control may vary over the time. \n",
          "module": "Synthesizer.Plain.Signal",
          "name": "modifyModulated",
          "package": "synthesizer",
          "signature": "Modifier s ctrl a b -\u003e T ctrl -\u003e T a -\u003e T b",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Signal.html#modifyModulated",
          "type": "function"
        },
        "index": {
          "description": "Here the control may vary over the time",
          "hierarchy": "Synthesizer Plain Signal",
          "module": "Synthesizer.Plain.Signal",
          "name": "modifyModulated",
          "normalized": "Modifier a b c d-\u003eT b-\u003eT c-\u003eT d",
          "package": "synthesizer",
          "partial": "Modulated",
          "signature": "Modifier s ctrl a b-\u003eT ctrl-\u003eT a-\u003eT b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Signal.html#v:modifyModulated"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Here the control may vary over the time. \n",
          "module": "Synthesizer.Plain.Signal",
          "name": "modifyModulatedInit",
          "package": "synthesizer",
          "signature": "ModifierInit s init ctrl a b -\u003e init -\u003e T ctrl -\u003e T a -\u003e T b",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Signal.html#modifyModulatedInit",
          "type": "function"
        },
        "index": {
          "description": "Here the control may vary over the time",
          "hierarchy": "Synthesizer Plain Signal",
          "module": "Synthesizer.Plain.Signal",
          "name": "modifyModulatedInit",
          "normalized": "ModifierInit a b c d e-\u003eb-\u003eT c-\u003eT d-\u003eT e",
          "package": "synthesizer",
          "partial": "Modulated Init",
          "signature": "ModifierInit s init ctrl a b-\u003einit-\u003eT ctrl-\u003eT a-\u003eT b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Signal.html#v:modifyModulatedInit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003emodif is a process controlled by values of type c\nwith an internal state of type s,\nit converts an input value of type a into an output value of type b\nwhile turning into a new state\n\u003c/p\u003e\u003cp\u003eToDo:\nShall finite signals be padded with zeros?\n\u003c/p\u003e",
          "module": "Synthesizer.Plain.Signal",
          "name": "modifyStatic",
          "package": "synthesizer",
          "signature": "Modifier s ctrl a b -\u003e ctrl -\u003e T a -\u003e T b",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Signal.html#modifyStatic",
          "type": "function"
        },
        "index": {
          "description": "modif is process controlled by values of type with an internal state of type it converts an input value of type into an output value of type while turning into new state ToDo Shall finite signals be padded with zeros",
          "hierarchy": "Synthesizer Plain Signal",
          "module": "Synthesizer.Plain.Signal",
          "name": "modifyStatic",
          "normalized": "Modifier a b c d-\u003eb-\u003eT c-\u003eT d",
          "package": "synthesizer",
          "partial": "Static",
          "signature": "Modifier s ctrl a b-\u003ectrl-\u003eT a-\u003eT b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Signal.html#v:modifyStatic"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Signal",
          "name": "modifyStaticInit",
          "package": "synthesizer",
          "signature": "ModifierInit s init ctrl a b -\u003e init -\u003e ctrl -\u003e T a -\u003e T b",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Signal.html#modifyStaticInit",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Signal",
          "module": "Synthesizer.Plain.Signal",
          "name": "modifyStaticInit",
          "normalized": "ModifierInit a b c d e-\u003eb-\u003ec-\u003eT d-\u003eT e",
          "package": "synthesizer",
          "partial": "Static Init",
          "signature": "ModifierInit s init ctrl a b-\u003einit-\u003ectrl-\u003eT a-\u003eT b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Signal.html#v:modifyStaticInit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Signal",
          "name": "reduceL",
          "package": "synthesizer",
          "signature": "(x -\u003e acc -\u003e Maybe acc) -\u003e acc -\u003e T x -\u003e acc",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Signal.html#reduceL",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Signal",
          "module": "Synthesizer.Plain.Signal",
          "name": "reduceL",
          "normalized": "(a-\u003eb-\u003eMaybe b)-\u003eb-\u003eT a-\u003eb",
          "package": "synthesizer",
          "signature": "(x-\u003eacc-\u003eMaybe acc)-\u003eacc-\u003eT x-\u003eacc",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Signal.html#v:reduceL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Signal",
          "name": "unfoldR",
          "package": "synthesizer",
          "signature": "(acc -\u003e Maybe (y, acc)) -\u003e acc -\u003e (acc, T y)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Signal.html#unfoldR",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Signal",
          "module": "Synthesizer.Plain.Signal",
          "name": "unfoldR",
          "normalized": "(a-\u003eMaybe(b,a))-\u003ea-\u003e(a,T b)",
          "package": "synthesizer",
          "signature": "(acc-\u003eMaybe(y,acc))-\u003eacc-\u003e(acc,T y)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Signal.html#v:unfoldR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Signal",
          "name": "zipWithAppend",
          "package": "synthesizer",
          "signature": "(y -\u003e y -\u003e y) -\u003e T y -\u003e T y -\u003e T y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Signal.html#zipWithAppend",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Signal",
          "module": "Synthesizer.Plain.Signal",
          "name": "zipWithAppend",
          "normalized": "(a-\u003ea-\u003ea)-\u003eT a-\u003eT a-\u003eT a",
          "package": "synthesizer",
          "partial": "With Append",
          "signature": "(y-\u003ey-\u003ey)-\u003eT y-\u003eT y-\u003eT y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Signal.html#v:zipWithAppend"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Signal",
          "name": "zipWithRest",
          "package": "synthesizer",
          "signature": "(y0 -\u003e y0 -\u003e y1) -\u003e T y0 -\u003e T y0 -\u003e (T y1, (Bool, T y0))",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Signal.html#zipWithRest",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Signal",
          "module": "Synthesizer.Plain.Signal",
          "name": "zipWithRest",
          "normalized": "(a-\u003ea-\u003ea)-\u003eT a-\u003eT a-\u003e(T a,(Bool,T a))",
          "package": "synthesizer",
          "partial": "With Rest",
          "signature": "(y-\u003ey-\u003ey)-\u003eT y-\u003eT y-\u003e(T y,(Bool,T y))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Signal.html#v:zipWithRest"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Signal",
          "name": "zipWithRest'",
          "package": "synthesizer",
          "signature": "(y0 -\u003e y0 -\u003e y1) -\u003e T y0 -\u003e T y0 -\u003e (T y1, (Bool, T y0))",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Signal.html#zipWithRest%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Signal",
          "module": "Synthesizer.Plain.Signal",
          "name": "zipWithRest'",
          "normalized": "(a-\u003ea-\u003ea)-\u003eT a-\u003eT a-\u003e(T a,(Bool,T a))",
          "package": "synthesizer",
          "partial": "With Rest'",
          "signature": "(y-\u003ey-\u003ey)-\u003eT y-\u003eT y-\u003e(T y,(Bool,T y))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Signal.html#v:zipWithRest'"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Can be implemented more efficiently\nthan just by \u003ctt\u003e\u003ca\u003ezipWith\u003c/a\u003e\u003c/tt\u003e and \u003ctt\u003e\u003ca\u003etails\u003c/a\u003e\u003c/tt\u003e\nfor other data structures.\n",
          "module": "Synthesizer.Plain.Signal",
          "name": "zipWithTails",
          "package": "synthesizer",
          "signature": "(y0 -\u003e T y1 -\u003e y2) -\u003e T y0 -\u003e T y1 -\u003e T y2",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Signal.html#zipWithTails",
          "type": "function"
        },
        "index": {
          "description": "Can be implemented more efficiently than just by zipWith and tails for other data structures",
          "hierarchy": "Synthesizer Plain Signal",
          "module": "Synthesizer.Plain.Signal",
          "name": "zipWithTails",
          "normalized": "(a-\u003eT a-\u003ea)-\u003eT a-\u003eT a-\u003eT a",
          "package": "synthesizer",
          "partial": "With Tails",
          "signature": "(y-\u003eT y-\u003ey)-\u003eT y-\u003eT y-\u003eT y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Signal.html#v:zipWithTails"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.ToneModulation",
          "name": "Cell",
          "package": "synthesizer",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-ToneModulation.html#Cell",
          "type": "type"
        },
        "index": {
          "hierarchy": "Synthesizer Plain ToneModulation",
          "module": "Synthesizer.Plain.ToneModulation",
          "name": "Cell",
          "package": "synthesizer",
          "partial": "Cell",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-ToneModulation.html#t:Cell"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.ToneModulation",
          "name": "Prototype",
          "package": "synthesizer",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-ToneModulation.html#Prototype",
          "type": "data"
        },
        "index": {
          "hierarchy": "Synthesizer Plain ToneModulation",
          "module": "Synthesizer.Plain.ToneModulation",
          "name": "Prototype",
          "package": "synthesizer",
          "partial": "Prototype",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-ToneModulation.html#t:Prototype"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.ToneModulation",
          "name": "dropFrac",
          "package": "synthesizer",
          "signature": "i -\u003e T a -\u003e (Int, i, T a)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-ToneModulation.html#dropFrac",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain ToneModulation",
          "module": "Synthesizer.Plain.ToneModulation",
          "name": "dropFrac",
          "normalized": "a-\u003eT b-\u003e(Int,a,T b)",
          "package": "synthesizer",
          "partial": "Frac",
          "signature": "i-\u003eT a-\u003e(Int,i,T a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-ToneModulation.html#v:dropFrac"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.ToneModulation",
          "name": "dropFrac'",
          "package": "synthesizer",
          "signature": "i -\u003e T a -\u003e (Int, i, T a)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-ToneModulation.html#dropFrac%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain ToneModulation",
          "module": "Synthesizer.Plain.ToneModulation",
          "name": "dropFrac'",
          "normalized": "a-\u003eT b-\u003e(Int,a,T b)",
          "package": "synthesizer",
          "partial": "Frac'",
          "signature": "i-\u003eT a-\u003e(Int,i,T a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-ToneModulation.html#v:dropFrac'"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.ToneModulation",
          "name": "dropRem",
          "package": "synthesizer",
          "signature": "Int -\u003e T a -\u003e (Int, T a)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-ToneModulation.html#dropRem",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain ToneModulation",
          "module": "Synthesizer.Plain.ToneModulation",
          "name": "dropRem",
          "normalized": "Int-\u003eT a-\u003e(Int,T a)",
          "package": "synthesizer",
          "partial": "Rem",
          "signature": "Int-\u003eT a-\u003e(Int,T a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-ToneModulation.html#v:dropRem"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.ToneModulation",
          "name": "dropRem'",
          "package": "synthesizer",
          "signature": "Int -\u003e T a -\u003e (Int, T a)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-ToneModulation.html#dropRem%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain ToneModulation",
          "module": "Synthesizer.Plain.ToneModulation",
          "name": "dropRem'",
          "normalized": "Int-\u003eT a-\u003e(Int,T a)",
          "package": "synthesizer",
          "partial": "Rem'",
          "signature": "Int-\u003eT a-\u003e(Int,T a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-ToneModulation.html#v:dropRem'"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Convert a list of phase steps into a list of momentum phases\nphase is a number in the interval [0,1)\nfreq contains the phase steps\n",
          "module": "Synthesizer.Plain.ToneModulation",
          "name": "freqsToPhases",
          "package": "synthesizer",
          "signature": "T a -\u003e T a -\u003e T (T a)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-ToneModulation.html#freqsToPhases",
          "type": "function"
        },
        "index": {
          "description": "Convert list of phase steps into list of momentum phases phase is number in the interval freq contains the phase steps",
          "hierarchy": "Synthesizer Plain ToneModulation",
          "module": "Synthesizer.Plain.ToneModulation",
          "name": "freqsToPhases",
          "normalized": "T a-\u003eT a-\u003eT(T a)",
          "package": "synthesizer",
          "partial": "To Phases",
          "signature": "T a-\u003eT a-\u003eT(T a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-ToneModulation.html#v:freqsToPhases"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.ToneModulation",
          "name": "integrateFractional",
          "package": "synthesizer",
          "signature": "t -\u003e (t, T t) -\u003e (T t, T t) -\u003e T (Skip t)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-ToneModulation.html#integrateFractional",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain ToneModulation",
          "module": "Synthesizer.Plain.ToneModulation",
          "name": "integrateFractional",
          "normalized": "a-\u003e(a,T a)-\u003e(T a,T a)-\u003eT(Skip a)",
          "package": "synthesizer",
          "partial": "Fractional",
          "signature": "t-\u003e(t,T t)-\u003e(T t,T t)-\u003eT(Skip t)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-ToneModulation.html#v:integrateFractional"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.ToneModulation",
          "name": "interpolateCell",
          "package": "synthesizer",
          "signature": "T a y -\u003e T b y -\u003e (a, b) -\u003e Cell y -\u003e y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-ToneModulation.html#interpolateCell",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain ToneModulation",
          "module": "Synthesizer.Plain.ToneModulation",
          "name": "interpolateCell",
          "normalized": "T a b-\u003eT c b-\u003e(a,c)-\u003eCell b-\u003eb",
          "package": "synthesizer",
          "partial": "Cell",
          "signature": "T a y-\u003eT b y-\u003e(a,b)-\u003eCell y-\u003ey",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-ToneModulation.html#v:interpolateCell"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.ToneModulation",
          "name": "limitMaxRelativeValues",
          "package": "synthesizer",
          "signature": "a -\u003e a -\u003e T a -\u003e (a, T a)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-ToneModulation.html#limitMaxRelativeValues",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain ToneModulation",
          "module": "Synthesizer.Plain.ToneModulation",
          "name": "limitMaxRelativeValues",
          "normalized": "a-\u003ea-\u003eT a-\u003e(a,T a)",
          "package": "synthesizer",
          "partial": "Max Relative Values",
          "signature": "a-\u003ea-\u003eT a-\u003e(a,T a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-ToneModulation.html#v:limitMaxRelativeValues"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Avoids negative numbers and thus can be used with Chunky numbers.\n",
          "module": "Synthesizer.Plain.ToneModulation",
          "name": "limitMaxRelativeValuesNonNeg",
          "package": "synthesizer",
          "signature": "a -\u003e a -\u003e T a -\u003e (a, T a)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-ToneModulation.html#limitMaxRelativeValuesNonNeg",
          "type": "function"
        },
        "index": {
          "description": "Avoids negative numbers and thus can be used with Chunky numbers",
          "hierarchy": "Synthesizer Plain ToneModulation",
          "module": "Synthesizer.Plain.ToneModulation",
          "name": "limitMaxRelativeValuesNonNeg",
          "normalized": "a-\u003ea-\u003eT a-\u003e(a,T a)",
          "package": "synthesizer",
          "partial": "Max Relative Values Non Neg",
          "signature": "a-\u003ea-\u003eT a-\u003e(a,T a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-ToneModulation.html#v:limitMaxRelativeValuesNonNeg"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.ToneModulation",
          "name": "limitMinRelativeValues",
          "package": "synthesizer",
          "signature": "a -\u003e a -\u003e T a -\u003e (a, T a)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-ToneModulation.html#limitMinRelativeValues",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain ToneModulation",
          "module": "Synthesizer.Plain.ToneModulation",
          "name": "limitMinRelativeValues",
          "normalized": "a-\u003ea-\u003eT a-\u003e(a,T a)",
          "package": "synthesizer",
          "partial": "Min Relative Values",
          "signature": "a-\u003ea-\u003eT a-\u003e(a,T a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-ToneModulation.html#v:limitMinRelativeValues"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.ToneModulation",
          "name": "limitRelativeShapes",
          "package": "synthesizer",
          "signature": "Margin -\u003e Margin -\u003e Int -\u003e T y -\u003e (t, T t) -\u003e (t, T t)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-ToneModulation.html#limitRelativeShapes",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain ToneModulation",
          "module": "Synthesizer.Plain.ToneModulation",
          "name": "limitRelativeShapes",
          "normalized": "Margin-\u003eMargin-\u003eInt-\u003eT a-\u003e(b,T b)-\u003e(b,T b)",
          "package": "synthesizer",
          "partial": "Relative Shapes",
          "signature": "Margin-\u003eMargin-\u003eInt-\u003eT y-\u003e(t,T t)-\u003e(t,T t)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-ToneModulation.html#v:limitRelativeShapes"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.ToneModulation",
          "name": "makePrototype",
          "package": "synthesizer",
          "signature": "Margin -\u003e Margin -\u003e Int -\u003e t -\u003e T y -\u003e Prototype t y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-ToneModulation.html#makePrototype",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain ToneModulation",
          "module": "Synthesizer.Plain.ToneModulation",
          "name": "makePrototype",
          "normalized": "Margin-\u003eMargin-\u003eInt-\u003ea-\u003eT b-\u003ePrototype a b",
          "package": "synthesizer",
          "partial": "Prototype",
          "signature": "Margin-\u003eMargin-\u003eInt-\u003et-\u003eT y-\u003ePrototype t y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-ToneModulation.html#v:makePrototype"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.ToneModulation",
          "name": "oscillatorCells",
          "package": "synthesizer",
          "signature": "Margin -\u003e Margin -\u003e Int -\u003e t -\u003e T y -\u003e (t, T t) -\u003e (T t, T t) -\u003e T ((t, t), Cell y)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-ToneModulation.html#oscillatorCells",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain ToneModulation",
          "module": "Synthesizer.Plain.ToneModulation",
          "name": "oscillatorCells",
          "normalized": "Margin-\u003eMargin-\u003eInt-\u003ea-\u003eT b-\u003e(a,T a)-\u003e(T a,T a)-\u003eT((a,a),Cell b)",
          "package": "synthesizer",
          "partial": "Cells",
          "signature": "Margin-\u003eMargin-\u003eInt-\u003et-\u003eT y-\u003e(t,T t)-\u003e(T t,T t)-\u003eT((t,t),Cell y)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-ToneModulation.html#v:oscillatorCells"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.ToneModulation",
          "name": "oscillatorCoords",
          "package": "synthesizer",
          "signature": "Int -\u003e t -\u003e (t, T t) -\u003e (T t, T t) -\u003e T (Coords t)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-ToneModulation.html#oscillatorCoords",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain ToneModulation",
          "module": "Synthesizer.Plain.ToneModulation",
          "name": "oscillatorCoords",
          "normalized": "Int-\u003ea-\u003e(a,T a)-\u003e(T a,T a)-\u003eT(Coords a)",
          "package": "synthesizer",
          "partial": "Coords",
          "signature": "Int-\u003et-\u003e(t,T t)-\u003e(T t,T t)-\u003eT(Coords t)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-ToneModulation.html#v:oscillatorCoords"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.ToneModulation",
          "name": "oscillatorSuffixes",
          "package": "synthesizer",
          "signature": "Margin -\u003e Margin -\u003e Int -\u003e t -\u003e T y -\u003e (t, T t) -\u003e (T t, T t) -\u003e T ((t, T t), Cell y)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-ToneModulation.html#oscillatorSuffixes",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain ToneModulation",
          "module": "Synthesizer.Plain.ToneModulation",
          "name": "oscillatorSuffixes",
          "normalized": "Margin-\u003eMargin-\u003eInt-\u003ea-\u003eT b-\u003e(a,T a)-\u003e(T a,T a)-\u003eT((a,T a),Cell b)",
          "package": "synthesizer",
          "partial": "Suffixes",
          "signature": "Margin-\u003eMargin-\u003eInt-\u003et-\u003eT y-\u003e(t,T t)-\u003e(T t,T t)-\u003eT((t,T t),Cell y)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-ToneModulation.html#v:oscillatorSuffixes"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.ToneModulation",
          "name": "propDropFrac",
          "package": "synthesizer",
          "signature": "i -\u003e T a -\u003e Bool",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-ToneModulation.html#propDropFrac",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain ToneModulation",
          "module": "Synthesizer.Plain.ToneModulation",
          "name": "propDropFrac",
          "normalized": "a-\u003eT b-\u003eBool",
          "package": "synthesizer",
          "partial": "Drop Frac",
          "signature": "i-\u003eT a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-ToneModulation.html#v:propDropFrac"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.ToneModulation",
          "name": "propDropRem",
          "package": "synthesizer",
          "signature": "Int -\u003e T a -\u003e Bool",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-ToneModulation.html#propDropRem",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain ToneModulation",
          "module": "Synthesizer.Plain.ToneModulation",
          "name": "propDropRem",
          "normalized": "Int-\u003eT a-\u003eBool",
          "package": "synthesizer",
          "partial": "Drop Rem",
          "signature": "Int-\u003eT a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-ToneModulation.html#v:propDropRem"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.ToneModulation",
          "name": "safeSub",
          "package": "synthesizer",
          "signature": "a -\u003e a -\u003e (Bool, a)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-ToneModulation.html#safeSub",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain ToneModulation",
          "module": "Synthesizer.Plain.ToneModulation",
          "name": "safeSub",
          "normalized": "a-\u003ea-\u003e(Bool,a)",
          "package": "synthesizer",
          "partial": "Sub",
          "signature": "a-\u003ea-\u003e(Bool,a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-ToneModulation.html#v:safeSub"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.ToneModulation",
          "name": "sampledToneCell",
          "package": "synthesizer",
          "signature": "Prototype t y -\u003e t -\u003e T t -\u003e ((t, t), Cell y)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-ToneModulation.html#sampledToneCell",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain ToneModulation",
          "module": "Synthesizer.Plain.ToneModulation",
          "name": "sampledToneCell",
          "normalized": "Prototype a b-\u003ea-\u003eT a-\u003e((a,a),Cell b)",
          "package": "synthesizer",
          "partial": "Tone Cell",
          "signature": "Prototype t y-\u003et-\u003eT t-\u003e((t,t),Cell y)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-ToneModulation.html#v:sampledToneCell"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.ToneModulation",
          "name": "seekCell",
          "package": "synthesizer",
          "signature": "Int -\u003e t -\u003e ((t, T t), Cell y) -\u003e ((t, t), Cell y)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-ToneModulation.html#seekCell",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain ToneModulation",
          "module": "Synthesizer.Plain.ToneModulation",
          "name": "seekCell",
          "normalized": "Int-\u003ea-\u003e((a,T a),Cell b)-\u003e((a,a),Cell b)",
          "package": "synthesizer",
          "partial": "Cell",
          "signature": "Int-\u003et-\u003e((t,T t),Cell y)-\u003e((t,t),Cell y)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-ToneModulation.html#v:seekCell"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "When we apply a third power to each value of the saw tooths\nwe get an oscillator with cubic polynomial functions as waveform.\nThe distortion function applied to a saw wave can be used\nto turn every function on the interval [-1,1] into a waveform.\n",
          "module": "Synthesizer.Plain.Tutorial",
          "name": "cubic",
          "package": "synthesizer",
          "signature": "IO ExitCode",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Tutorial.html#cubic",
          "type": "function"
        },
        "index": {
          "description": "When we apply third power to each value of the saw tooths we get an oscillator with cubic polynomial functions as waveform The distortion function applied to saw wave can be used to turn every function on the interval into waveform",
          "hierarchy": "Synthesizer Plain Tutorial",
          "module": "Synthesizer.Plain.Tutorial",
          "name": "cubic",
          "package": "synthesizer",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Tutorial.html#v:cubic"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eOne of the most impressive sounds effects is certainly frequency filtering,\nespecially when the filter parameters are modulated.\nIn this example we use a resonant lowpass\nwhose resonance frequency is controlled by a slow sine wave.\nThe frequency filters usually use internal filter parameters\nthat are not very intuitive to use directly.\nThus we apply a function (here \u003ctt\u003e\u003ca\u003eparameter\u003c/a\u003e\u003c/tt\u003e)\nin order to turn the intuitive parameters \"resonance frequency\" and \"resonance\"\n(resonance frequency amplification while frequency zero is left unchanged)\ninto internal filter parameters.\nWe have not merged these two steps\nsince the computation of internal filter parameters\nis more expensive then the filtering itself\nand you may want to reduce the computation\nby computing the internal filter parameters at a low sample rate\nand interpolate them.\nHowever, in the list implementation\nthis will not save you much time, if at all,\nsince the list operations are too expensive.\n\u003c/p\u003e\u003cp\u003eNow this is the example where my machine is no longer able to produce\na constant audio stream in real-time.\nFor tackling this problem, please continue with \u003ca\u003eSynthesizer.Generic.Tutorial\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Synthesizer.Plain.Tutorial",
          "name": "filterSaw",
          "package": "synthesizer",
          "signature": "IO ExitCode",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Tutorial.html#filterSaw",
          "type": "function"
        },
        "index": {
          "description": "One of the most impressive sounds effects is certainly frequency filtering especially when the filter parameters are modulated In this example we use resonant lowpass whose resonance frequency is controlled by slow sine wave The frequency filters usually use internal filter parameters that are not very intuitive to use directly Thus we apply function here parameter in order to turn the intuitive parameters resonance frequency and resonance resonance frequency amplification while frequency zero is left unchanged into internal filter parameters We have not merged these two steps since the computation of internal filter parameters is more expensive then the filtering itself and you may want to reduce the computation by computing the internal filter parameters at low sample rate and interpolate them However in the list implementation this will not save you much time if at all since the list operations are too expensive Now this is the example where my machine is no longer able to produce constant audio stream in real-time For tackling this problem please continue with Synthesizer.Generic.Tutorial",
          "hierarchy": "Synthesizer Plain Tutorial",
          "module": "Synthesizer.Plain.Tutorial",
          "name": "filterSaw",
          "package": "synthesizer",
          "partial": "Saw",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Tutorial.html#v:filterSaw"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "The \u003ctt\u003e\u003ca\u003eping\u003c/a\u003e\u003c/tt\u003e sound can also be used\nto modulate the phase another oscillator.\nThis is a well-known effect used excessively in FM synthesis,\nthat was introduced by the Yamaha DX-7 synthesizer.\n",
          "module": "Synthesizer.Plain.Tutorial",
          "name": "fmPing",
          "package": "synthesizer",
          "signature": "IO ExitCode",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Tutorial.html#fmPing",
          "type": "function"
        },
        "index": {
          "description": "The ping sound can also be used to modulate the phase another oscillator This is well-known effect used excessively in FM synthesis that was introduced by the Yamaha DX-7 synthesizer",
          "hierarchy": "Synthesizer Plain Tutorial",
          "module": "Synthesizer.Plain.Tutorial",
          "name": "fmPing",
          "package": "synthesizer",
          "partial": "Ping",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Tutorial.html#v:fmPing"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "It's also very common to modulate the frequency of a tone.\n",
          "module": "Synthesizer.Plain.Tutorial",
          "name": "laser",
          "package": "synthesizer",
          "signature": "IO ExitCode",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Tutorial.html#laser",
          "type": "function"
        },
        "index": {
          "description": "It also very common to modulate the frequency of tone",
          "hierarchy": "Synthesizer Plain Tutorial",
          "module": "Synthesizer.Plain.Tutorial",
          "name": "laser",
          "package": "synthesizer",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Tutorial.html#v:laser"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eNow, let's repeat the \u003ctt\u003e\u003ca\u003esine\u003c/a\u003e\u003c/tt\u003e example in a higher level style.\nWe use the oscillator \u003ctt\u003e\u003ca\u003estatic\u003c/a\u003e\u003c/tt\u003e that does not allow any modulation.\nWe can however use any waveform.\nThe waveform is essentially a function\nwhich maps from the phase to the displacement.\nFunctional programming proves to be very useful here,\nsince anonymous functions as waveforms are optimally supported by the language.\nWe can also expect, that in compiled form\nthe oscillator does not have to call back the waveform function\nby an expensive explicit function call,\nbut that the compiler will inline both oscillator and waveform\nsuch that the oscillator is turned into a simple loop\nwhich handles both oscillation and waveform computation.\n\u003c/p\u003e\u003cp\u003eUsing the oscillator with \u003ctt\u003e\u003ca\u003esine\u003c/a\u003e\u003c/tt\u003e also has the advantage\nthat we do not have to cope with \u003ctt\u003e\u003ca\u003epi\u003c/a\u003e\u003c/tt\u003es any longer.\nThe frequency is given as ratio of the sample rate.\nThat is, \u003ctt\u003e0.01\u003c/tt\u003e at \u003ctt\u003e44100 Hz\u003c/tt\u003e sample rate means \u003ctt\u003e441 Hz\u003c/tt\u003e.\nThis way all frequencies are given in the low-level signal processing.\n\u003c/p\u003e\u003cp\u003eIt is not optimal to handle frequencies this way,\nsince all frequency values are bound to the sample rate.\nFor overcoming this problem, see the high level routines using physical dimensions.\nFor examples see \u003ca\u003eSynthesizer.Dimensional.RateAmplitude.Demonstration\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Synthesizer.Plain.Tutorial",
          "name": "oscillator",
          "package": "synthesizer",
          "signature": "IO ExitCode",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Tutorial.html#oscillator",
          "type": "function"
        },
        "index": {
          "description": "Now let repeat the sine example in higher level style We use the oscillator static that does not allow any modulation We can however use any waveform The waveform is essentially function which maps from the phase to the displacement Functional programming proves to be very useful here since anonymous functions as waveforms are optimally supported by the language We can also expect that in compiled form the oscillator does not have to call back the waveform function by an expensive explicit function call but that the compiler will inline both oscillator and waveform such that the oscillator is turned into simple loop which handles both oscillation and waveform computation Using the oscillator with sine also has the advantage that we do not have to cope with pi any longer The frequency is given as ratio of the sample rate That is at Hz sample rate means Hz This way all frequencies are given in the low-level signal processing It is not optimal to handle frequencies this way since all frequency values are bound to the sample rate For overcoming this problem see the high level routines using physical dimensions For examples see Synthesizer.Dimensional.RateAmplitude.Demonstration",
          "hierarchy": "Synthesizer Plain Tutorial",
          "module": "Synthesizer.Plain.Tutorial",
          "name": "oscillator",
          "package": "synthesizer",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Tutorial.html#v:oscillator"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "A simple sine wave with exponentially decaying amplitude.\n",
          "module": "Synthesizer.Plain.Tutorial",
          "name": "ping",
          "package": "synthesizer",
          "signature": "IO ExitCode",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Tutorial.html#ping",
          "type": "function"
        },
        "index": {
          "description": "simple sine wave with exponentially decaying amplitude",
          "hierarchy": "Synthesizer Plain Tutorial",
          "module": "Synthesizer.Plain.Tutorial",
          "name": "ping",
          "package": "synthesizer",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Tutorial.html#v:ping"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Tutorial",
          "name": "pingSig",
          "package": "synthesizer",
          "signature": "T Double",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Tutorial.html#pingSig",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Tutorial",
          "module": "Synthesizer.Plain.Tutorial",
          "name": "pingSig",
          "package": "synthesizer",
          "partial": "Sig",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Tutorial.html#v:pingSig"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "For the following examples we will stick to monophonic sounds played at 44100 Hz.\nThus we define a function for convenience.\n",
          "module": "Synthesizer.Plain.Tutorial",
          "name": "play",
          "package": "synthesizer",
          "signature": "T Double -\u003e IO ExitCode",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Tutorial.html#play",
          "type": "function"
        },
        "index": {
          "description": "For the following examples we will stick to monophonic sounds played at Hz Thus we define function for convenience",
          "hierarchy": "Synthesizer Plain Tutorial",
          "module": "Synthesizer.Plain.Tutorial",
          "name": "play",
          "normalized": "T Double-\u003eIO ExitCode",
          "package": "synthesizer",
          "signature": "T Double-\u003eIO ExitCode",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Tutorial.html#v:play"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "It is very simple to switch to another waveform like a saw tooth wave.\nInstead of a sharp saw tooth,\nwe use an extreme asymmetric triangle.\nThis is a poor man's band-limiting approach\nthat shall reduce aliasing at high oscillation frequencies.\nWe should really work on band-limited oscillators,\nbut this is hard in the general case.\n",
          "module": "Synthesizer.Plain.Tutorial",
          "name": "saw",
          "package": "synthesizer",
          "signature": "IO ExitCode",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Tutorial.html#saw",
          "type": "function"
        },
        "index": {
          "description": "It is very simple to switch to another waveform like saw tooth wave Instead of sharp saw tooth we use an extreme asymmetric triangle This is poor man band-limiting approach that shall reduce aliasing at high oscillation frequencies We should really work on band-limited oscillators but this is hard in the general case",
          "hierarchy": "Synthesizer Plain Tutorial",
          "module": "Synthesizer.Plain.Tutorial",
          "name": "saw",
          "package": "synthesizer",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Tutorial.html#v:saw"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Now let's start with modulated tones.\nThe first simple example is changing the degree of asymmetry\naccording to a slow oscillator (LFO = low frequency oscillator).\n",
          "module": "Synthesizer.Plain.Tutorial",
          "name": "sawMorph",
          "package": "synthesizer",
          "signature": "IO ExitCode",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Tutorial.html#sawMorph",
          "type": "function"
        },
        "index": {
          "description": "Now let start with modulated tones The first simple example is changing the degree of asymmetry according to slow oscillator LFO low frequency oscillator",
          "hierarchy": "Synthesizer Plain Tutorial",
          "module": "Synthesizer.Plain.Tutorial",
          "name": "sawMorph",
          "package": "synthesizer",
          "partial": "Morph",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Tutorial.html#v:sawMorph"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Play a simple sine tone at 44100 sample rate and 16 bit.\nThese are the parameters used for compact disks.\nThe period of the tone is \u003ctt\u003e2*pi*10\u003c/tt\u003e.\nPlaying at sample rate 44100 Hz results in a tone of \u003ctt\u003e44100 / (20*pi) Hz\u003c/tt\u003e,\nthat is about \u003ctt\u003e702 Hz\u003c/tt\u003e.\nThis is simple enough to be performed in real-time,\nat least on my machine.\nFor playback we use \u003ctt\u003eSoX\u003c/tt\u003e.\n",
          "module": "Synthesizer.Plain.Tutorial",
          "name": "sine",
          "package": "synthesizer",
          "signature": "IO ExitCode",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Tutorial.html#sine",
          "type": "function"
        },
        "index": {
          "description": "Play simple sine tone at sample rate and bit These are the parameters used for compact disks The period of the tone is pi Playing at sample rate Hz results in tone of pi Hz that is about Hz This is simple enough to be performed in real-time at least on my machine For playback we use SoX",
          "hierarchy": "Synthesizer Plain Tutorial",
          "module": "Synthesizer.Plain.Tutorial",
          "name": "sine",
          "package": "synthesizer",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Tutorial.html#v:sine"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Now the same for a stereo signal.\nBoth stereo channels are slightly detuned\nin order to achieve a stereophonic phasing effect.\nIn principle there is no limit of the number of channels,\nbut with more channels playback becomes difficult.\nMany signal processes in our package\nsupport any tuple and even nested tuples\nusing the notion of an algebraic \u003ctt\u003emodule\u003c/tt\u003e (see \u003ctt\u003e\u003ca\u003eC\u003c/a\u003e\u003c/tt\u003e).\nA module is a vector space where the scalar numbers\ndo not need to support division.\nA vector space is often also called a linear space,\nbecause all we require of vectors is that they can be added and scaled\nand these two operations fulfill some natural laws.\n",
          "module": "Synthesizer.Plain.Tutorial",
          "name": "sineStereo",
          "package": "synthesizer",
          "signature": "IO ExitCode",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Tutorial.html#sineStereo",
          "type": "function"
        },
        "index": {
          "description": "Now the same for stereo signal Both stereo channels are slightly detuned in order to achieve stereophonic phasing effect In principle there is no limit of the number of channels but with more channels playback becomes difficult Many signal processes in our package support any tuple and even nested tuples using the notion of an algebraic module see module is vector space where the scalar numbers do not need to support division vector space is often also called linear space because all we require of vectors is that they can be added and scaled and these two operations fulfill some natural laws",
          "hierarchy": "Synthesizer Plain Tutorial",
          "module": "Synthesizer.Plain.Tutorial",
          "name": "sineStereo",
          "package": "synthesizer",
          "partial": "Stereo",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Tutorial.html#v:sineStereo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Of course we can also write a tone to disk using \u003ctt\u003esox\u003c/tt\u003e.\n",
          "module": "Synthesizer.Plain.Tutorial",
          "name": "writeSine",
          "package": "synthesizer",
          "signature": "IO ExitCode",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Tutorial.html#writeSine",
          "type": "function"
        },
        "index": {
          "description": "Of course we can also write tone to disk using sox",
          "hierarchy": "Synthesizer Plain Tutorial",
          "module": "Synthesizer.Plain.Tutorial",
          "name": "writeSine",
          "package": "synthesizer",
          "partial": "Sine",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Tutorial.html#v:writeSine"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Plain.Wave",
          "name": "sample",
          "package": "synthesizer",
          "signature": "T a v -\u003e T v -\u003e T a v",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Wave.html#sample",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Plain Wave",
          "module": "Synthesizer.Plain.Wave",
          "name": "sample",
          "normalized": "T a b-\u003eT b-\u003eT a b",
          "package": "synthesizer",
          "signature": "T a v-\u003eT v-\u003eT a v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Wave.html#v:sample"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWe assume that a tone was generated by a shape modulated oscillator.\nWe try to reconstruct the wave function\n(with parameters shape control and phase)\nfrom a tone by interpolation.\n\u003c/p\u003e\u003cp\u003eThe unit for the shape control parameter is the sampling period.\nThat is the shape parameter is a time parameter\npointing to a momentary shape of the prototype signal.\nOf course this momentary shape does not exist\nand we can only guess it using interpolation.\n\u003c/p\u003e\u003cp\u003eAt the boundaries we repeat the outermost shapes\nthat can be reconstructed entirely from interpolated data\n(that is, no extrapolation is needed).\nThis way we cannot reproduce the shape at the boundaries\nbecause we have no data for cyclically extending it.\nOn the other hand this method guarantees a nice wave shape\nwith the required fractional period.\n\u003c/p\u003e\u003cp\u003eIt must be\n   \u003ctt\u003elength tone \u003e=\n       Interpolation.number ipStep +\n       Interpolation.number ipLeap * ceiling period\u003c/tt\u003e.\n\u003c/p\u003e",
          "module": "Synthesizer.Plain.Wave",
          "name": "sampledTone",
          "package": "synthesizer",
          "signature": "T a v -\u003e T a v -\u003e a -\u003e T v -\u003e a -\u003e T a v",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Wave.html#sampledTone",
          "type": "function"
        },
        "index": {
          "description": "We assume that tone was generated by shape modulated oscillator We try to reconstruct the wave function with parameters shape control and phase from tone by interpolation The unit for the shape control parameter is the sampling period That is the shape parameter is time parameter pointing to momentary shape of the prototype signal Of course this momentary shape does not exist and we can only guess it using interpolation At the boundaries we repeat the outermost shapes that can be reconstructed entirely from interpolated data that is no extrapolation is needed This way we cannot reproduce the shape at the boundaries because we have no data for cyclically extending it On the other hand this method guarantees nice wave shape with the required fractional period It must be length tone Interpolation.number ipStep Interpolation.number ipLeap ceiling period",
          "hierarchy": "Synthesizer Plain Wave",
          "module": "Synthesizer.Plain.Wave",
          "name": "sampledTone",
          "normalized": "T a b-\u003eT a b-\u003ea-\u003eT b-\u003ea-\u003eT a b",
          "package": "synthesizer",
          "partial": "Tone",
          "signature": "T a v-\u003eT a v-\u003ea-\u003eT v-\u003ea-\u003eT a v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Plain-Wave.html#v:sampledTone"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.RandomKnuth",
          "name": "T",
          "package": "synthesizer",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-RandomKnuth.html#T",
          "type": "data"
        },
        "index": {
          "hierarchy": "Synthesizer RandomKnuth",
          "module": "Synthesizer.RandomKnuth",
          "name": "T",
          "package": "synthesizer",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-RandomKnuth.html#t:T"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.RandomKnuth",
          "name": "cons",
          "package": "synthesizer",
          "signature": "Int -\u003e T",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-RandomKnuth.html#cons",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer RandomKnuth",
          "module": "Synthesizer.RandomKnuth",
          "name": "cons",
          "normalized": "Int-\u003eT",
          "package": "synthesizer",
          "signature": "Int-\u003eT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-RandomKnuth.html#v:cons"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.SampleRateContext.Control",
          "name": "Control",
          "package": "synthesizer",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Control.html#Control",
          "type": "data"
        },
        "index": {
          "hierarchy": "Synthesizer SampleRateContext Control",
          "module": "Synthesizer.SampleRateContext.Control",
          "name": "Control",
          "package": "synthesizer",
          "partial": "Control",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-SampleRateContext-Control.html#t:Control"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.SampleRateContext.Control",
          "name": "ControlPiece",
          "package": "synthesizer",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Plain-Control.html#ControlPiece",
          "type": "data"
        },
        "index": {
          "hierarchy": "Synthesizer SampleRateContext Control",
          "module": "Synthesizer.SampleRateContext.Control",
          "name": "ControlPiece",
          "package": "synthesizer",
          "partial": "Control Piece",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-SampleRateContext-Control.html#t:ControlPiece"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "value \n",
          "module": "Synthesizer.SampleRateContext.Control",
          "name": "constant",
          "package": "synthesizer",
          "signature": "y'-\u003e T t t'-\u003e T y y' y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-SampleRateContext-Control.html#constant",
          "type": "function"
        },
        "index": {
          "description": "value",
          "hierarchy": "Synthesizer SampleRateContext Control",
          "module": "Synthesizer.SampleRateContext.Control",
          "name": "constant",
          "normalized": "a-\u003eT b c-\u003eT d a d",
          "package": "synthesizer",
          "signature": "y'-\u003eT t t'-\u003eT y y' y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-SampleRateContext-Control.html#v:constant"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "amplitude \nvalue \n",
          "module": "Synthesizer.SampleRateContext.Control",
          "name": "constantVector",
          "package": "synthesizer",
          "signature": "y'-\u003e yv-\u003e T t t'-\u003e T y y' yv",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-SampleRateContext-Control.html#constantVector",
          "type": "function"
        },
        "index": {
          "description": "amplitude value",
          "hierarchy": "Synthesizer SampleRateContext Control",
          "module": "Synthesizer.SampleRateContext.Control",
          "name": "constantVector",
          "normalized": "a-\u003eb-\u003eT c d-\u003eT e a b",
          "package": "synthesizer",
          "partial": "Vector",
          "signature": "y'-\u003eyv-\u003eT t t'-\u003eT y y' yv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-SampleRateContext-Control.html#v:constantVector"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "time where the function reaches 1/e of the initial value \ninitial value \n",
          "module": "Synthesizer.SampleRateContext.Control",
          "name": "exponential",
          "package": "synthesizer",
          "signature": "q'-\u003e q'-\u003e T q q'-\u003e T q q' q",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-SampleRateContext-Control.html#exponential",
          "type": "function"
        },
        "index": {
          "description": "time where the function reaches of the initial value initial value",
          "hierarchy": "Synthesizer SampleRateContext Control",
          "module": "Synthesizer.SampleRateContext.Control",
          "name": "exponential",
          "normalized": "a-\u003ea-\u003eT b a-\u003eT b a b",
          "package": "synthesizer",
          "signature": "q'-\u003eq'-\u003eT q q'-\u003eT q q' q",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-SampleRateContext-Control.html#v:exponential"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "half life, time where the function reaches 1/2 of the initial value \ninitial value \n",
          "module": "Synthesizer.SampleRateContext.Control",
          "name": "exponential2",
          "package": "synthesizer",
          "signature": "q'-\u003e q'-\u003e T q q'-\u003e T q q' q",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-SampleRateContext-Control.html#exponential2",
          "type": "function"
        },
        "index": {
          "description": "half life time where the function reaches of the initial value initial value",
          "hierarchy": "Synthesizer SampleRateContext Control",
          "module": "Synthesizer.SampleRateContext.Control",
          "name": "exponential2",
          "normalized": "a-\u003ea-\u003eT b a-\u003eT b a b",
          "package": "synthesizer",
          "signature": "q'-\u003eq'-\u003eT q q'-\u003eT q q' q",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-SampleRateContext-Control.html#v:exponential2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "duration of the ramp \ninitial and final value \n",
          "module": "Synthesizer.SampleRateContext.Control",
          "name": "line",
          "package": "synthesizer",
          "signature": "q'-\u003e (q', q')-\u003e T q q'-\u003e T q q' q",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-SampleRateContext-Control.html#line",
          "type": "function"
        },
        "index": {
          "description": "duration of the ramp initial and final value",
          "hierarchy": "Synthesizer SampleRateContext Control",
          "module": "Synthesizer.SampleRateContext.Control",
          "name": "line",
          "normalized": "a-\u003e(a,a)-\u003eT b a-\u003eT b a b",
          "package": "synthesizer",
          "signature": "q'-\u003e(q',q')-\u003eT q q'-\u003eT q q' q",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-SampleRateContext-Control.html#v:line"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "slope of the curve \ninitial value \n",
          "module": "Synthesizer.SampleRateContext.Control",
          "name": "linear",
          "package": "synthesizer",
          "signature": "q'-\u003e q'-\u003e T q q'-\u003e T q q' q",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-SampleRateContext-Control.html#linear",
          "type": "function"
        },
        "index": {
          "description": "slope of the curve initial value",
          "hierarchy": "Synthesizer SampleRateContext Control",
          "module": "Synthesizer.SampleRateContext.Control",
          "name": "linear",
          "normalized": "a-\u003ea-\u003eT b a-\u003eT b a b",
          "package": "synthesizer",
          "signature": "q'-\u003eq'-\u003eT q q'-\u003eT q q' q",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-SampleRateContext-Control.html#v:linear"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "range: one is mapped to \u003ctt\u003ecenter*range\u003c/tt\u003e, must be positive \ncenter: zero is mapped to \u003ctt\u003ecenter\u003c/tt\u003e \n",
          "module": "Synthesizer.SampleRateContext.Control",
          "name": "mapExponential",
          "package": "synthesizer",
          "signature": "y-\u003e y'-\u003e T t t'-\u003e T y y y-\u003e T y y' y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-SampleRateContext-Control.html#mapExponential",
          "type": "function"
        },
        "index": {
          "description": "range one is mapped to center range must be positive center zero is mapped to center",
          "hierarchy": "Synthesizer SampleRateContext Control",
          "module": "Synthesizer.SampleRateContext.Control",
          "name": "mapExponential",
          "normalized": "a-\u003eb-\u003eT c d-\u003eT a a a-\u003eT a b a",
          "package": "synthesizer",
          "partial": "Exponential",
          "signature": "y-\u003ey'-\u003eT t t'-\u003eT y y y-\u003eT y y' y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-SampleRateContext-Control.html#v:mapExponential"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "range: one is mapped to \u003ctt\u003ecenter+range\u003c/tt\u003e \ncenter: zero is mapped to \u003ctt\u003ecenter\u003c/tt\u003e \n",
          "module": "Synthesizer.SampleRateContext.Control",
          "name": "mapLinear",
          "package": "synthesizer",
          "signature": "y'-\u003e y'-\u003e T t t'-\u003e T y y' y-\u003e T y y' y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-SampleRateContext-Control.html#mapLinear",
          "type": "function"
        },
        "index": {
          "description": "range one is mapped to center range center zero is mapped to center",
          "hierarchy": "Synthesizer SampleRateContext Control",
          "module": "Synthesizer.SampleRateContext.Control",
          "name": "mapLinear",
          "normalized": "a-\u003ea-\u003eT b c-\u003eT d a d-\u003eT d a d",
          "package": "synthesizer",
          "partial": "Linear",
          "signature": "y'-\u003ey'-\u003eT t t'-\u003eT y y' y-\u003eT y y' y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-SampleRateContext-Control.html#v:mapLinear"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Since this function looks for the maximum node value,\nand since the signal parameter inference phase must be completed before signal processing,\ninfinite descriptions cannot be used here.\n",
          "module": "Synthesizer.SampleRateContext.Control",
          "name": "piecewise",
          "package": "synthesizer",
          "signature": "[ControlPiece q'] -\u003e T q q' -\u003e T q q' q",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-SampleRateContext-Control.html#piecewise",
          "type": "function"
        },
        "index": {
          "description": "Since this function looks for the maximum node value and since the signal parameter inference phase must be completed before signal processing infinite descriptions cannot be used here",
          "hierarchy": "Synthesizer SampleRateContext Control",
          "module": "Synthesizer.SampleRateContext.Control",
          "name": "piecewise",
          "normalized": "[ControlPiece a]-\u003eT b a-\u003eT b a b",
          "package": "synthesizer",
          "signature": "[ControlPiece q']-\u003eT q q'-\u003eT q q' q",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-SampleRateContext-Control.html#v:piecewise"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.SampleRateContext.Control",
          "name": "piecewiseVolume",
          "package": "synthesizer",
          "signature": "[ControlPiece q'] -\u003e q' -\u003e T q q' -\u003e T q q' q",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-SampleRateContext-Control.html#piecewiseVolume",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer SampleRateContext Control",
          "module": "Synthesizer.SampleRateContext.Control",
          "name": "piecewiseVolume",
          "normalized": "[ControlPiece a]-\u003ea-\u003eT b a-\u003eT b a b",
          "package": "synthesizer",
          "partial": "Volume",
          "signature": "[ControlPiece q']-\u003eq'-\u003eT q q'-\u003eT q q' q",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-SampleRateContext-Control.html#v:piecewiseVolume"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.SampleRateContext.Cut",
          "name": "append",
          "package": "synthesizer",
          "signature": "T t t' -\u003e T y y' yv -\u003e T y y' yv -\u003e T y y' yv",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-SampleRateContext-Cut.html#append",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer SampleRateContext Cut",
          "module": "Synthesizer.SampleRateContext.Cut",
          "name": "append",
          "normalized": "T a b-\u003eT c d e-\u003eT c d e-\u003eT c d e",
          "package": "synthesizer",
          "signature": "T t t'-\u003eT y y' yv-\u003eT y y' yv-\u003eT y y' yv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-SampleRateContext-Cut.html#v:append"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.SampleRateContext.Cut",
          "name": "appendVolume",
          "package": "synthesizer",
          "signature": "y' -\u003e T t t' -\u003e T y y' yv -\u003e T y y' yv -\u003e T y y' yv",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-SampleRateContext-Cut.html#appendVolume",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer SampleRateContext Cut",
          "module": "Synthesizer.SampleRateContext.Cut",
          "name": "appendVolume",
          "normalized": "a-\u003eT b c-\u003eT d a e-\u003eT d a e-\u003eT d a e",
          "package": "synthesizer",
          "partial": "Volume",
          "signature": "y'-\u003eT t t'-\u003eT y y' yv-\u003eT y y' yv-\u003eT y y' yv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-SampleRateContext-Cut.html#v:appendVolume"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Unit of the time values in the time ordered list. \nA list of pairs: (relative start time, signal part),\n                 The start time is relative\n                 to the start time of the previous event. \nThe mixed signal. \n",
          "module": "Synthesizer.SampleRateContext.Cut",
          "name": "arrange",
          "package": "synthesizer",
          "signature": "t'-\u003e T t t'-\u003e T t (T y y' yv)-\u003e T y y' yv",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-SampleRateContext-Cut.html#arrange",
          "type": "function"
        },
        "index": {
          "description": "Unit of the time values in the time ordered list list of pairs relative start time signal part The start time is relative to the start time of the previous event The mixed signal",
          "hierarchy": "Synthesizer SampleRateContext Cut",
          "module": "Synthesizer.SampleRateContext.Cut",
          "name": "arrange",
          "normalized": "a-\u003eT b a-\u003eT b(T c d e)-\u003eT c d e",
          "package": "synthesizer",
          "signature": "t'-\u003eT t t'-\u003eT t(T y y' yv)-\u003eT y y' yv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-SampleRateContext-Cut.html#v:arrange"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Output volume. \nUnit of the time values in the time ordered list. \nA list of pairs: (relative start time, signal part),\n                 The start time is relative\n                 to the start time of the previous event. \nThe mixed signal. \n",
          "module": "Synthesizer.SampleRateContext.Cut",
          "name": "arrangeVolume",
          "package": "synthesizer",
          "signature": "y'-\u003e t'-\u003e T t t'-\u003e T t (T y y' yv)-\u003e T y y' yv",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-SampleRateContext-Cut.html#arrangeVolume",
          "type": "function"
        },
        "index": {
          "description": "Output volume Unit of the time values in the time ordered list list of pairs relative start time signal part The start time is relative to the start time of the previous event The mixed signal",
          "hierarchy": "Synthesizer SampleRateContext Cut",
          "module": "Synthesizer.SampleRateContext.Cut",
          "name": "arrangeVolume",
          "normalized": "a-\u003eb-\u003eT c b-\u003eT c(T d a e)-\u003eT d a e",
          "package": "synthesizer",
          "partial": "Volume",
          "signature": "y'-\u003et'-\u003eT t t'-\u003eT t(T y y' yv)-\u003eT y y' yv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-SampleRateContext-Cut.html#v:arrangeVolume"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Similar to \u003ctt\u003efoldr1 append\u003c/tt\u003e but more efficient and accurate,\nbecause it reduces the number of amplifications.\nDoes not work for infinite lists,\nbecause no maximum amplitude can be computed.\n",
          "module": "Synthesizer.SampleRateContext.Cut",
          "name": "concat",
          "package": "synthesizer",
          "signature": "T t t' -\u003e [T y y' yv] -\u003e T y y' yv",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-SampleRateContext-Cut.html#concat",
          "type": "function"
        },
        "index": {
          "description": "Similar to foldr1 append but more efficient and accurate because it reduces the number of amplifications Does not work for infinite lists because no maximum amplitude can be computed",
          "hierarchy": "Synthesizer SampleRateContext Cut",
          "module": "Synthesizer.SampleRateContext.Cut",
          "name": "concat",
          "normalized": "T a b-\u003e[T c d e]-\u003eT c d e",
          "package": "synthesizer",
          "signature": "T t t'-\u003e[T y y' yv]-\u003eT y y' yv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-SampleRateContext-Cut.html#v:concat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Give the output volume explicitly.\nDoes also work for infinite lists.\n",
          "module": "Synthesizer.SampleRateContext.Cut",
          "name": "concatVolume",
          "package": "synthesizer",
          "signature": "y' -\u003e T t t' -\u003e [T y y' yv] -\u003e T y y' yv",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-SampleRateContext-Cut.html#concatVolume",
          "type": "function"
        },
        "index": {
          "description": "Give the output volume explicitly Does also work for infinite lists",
          "hierarchy": "Synthesizer SampleRateContext Cut",
          "module": "Synthesizer.SampleRateContext.Cut",
          "name": "concatVolume",
          "normalized": "a-\u003eT b c-\u003e[T d a e]-\u003eT d a e",
          "package": "synthesizer",
          "partial": "Volume",
          "signature": "y'-\u003eT t t'-\u003e[T y y' yv]-\u003eT y y' yv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-SampleRateContext-Cut.html#v:concatVolume"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.SampleRateContext.Cut",
          "name": "drop",
          "package": "synthesizer",
          "signature": "t' -\u003e T t t' -\u003e T y y' yv -\u003e T y y' yv",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-SampleRateContext-Cut.html#drop",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer SampleRateContext Cut",
          "module": "Synthesizer.SampleRateContext.Cut",
          "name": "drop",
          "normalized": "a-\u003eT b a-\u003eT c d e-\u003eT c d e",
          "package": "synthesizer",
          "signature": "t'-\u003eT t t'-\u003eT y y' yv-\u003eT y y' yv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-SampleRateContext-Cut.html#v:drop"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.SampleRateContext.Cut",
          "name": "splitAt",
          "package": "synthesizer",
          "signature": "t' -\u003e T t t' -\u003e T y y' yv -\u003e (T y y' yv, T y y' yv)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-SampleRateContext-Cut.html#splitAt",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer SampleRateContext Cut",
          "module": "Synthesizer.SampleRateContext.Cut",
          "name": "splitAt",
          "normalized": "a-\u003eT b a-\u003eT c d e-\u003e(T c d e,T c d e)",
          "package": "synthesizer",
          "partial": "At",
          "signature": "t'-\u003eT t t'-\u003eT y y' yv-\u003e(T y y' yv,T y y' yv)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-SampleRateContext-Cut.html#v:splitAt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.SampleRateContext.Cut",
          "name": "take",
          "package": "synthesizer",
          "signature": "t' -\u003e T t t' -\u003e T y y' yv -\u003e T y y' yv",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-SampleRateContext-Cut.html#take",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer SampleRateContext Cut",
          "module": "Synthesizer.SampleRateContext.Cut",
          "name": "take",
          "normalized": "a-\u003eT b a-\u003eT c d e-\u003eT c d e",
          "package": "synthesizer",
          "signature": "t'-\u003eT t t'-\u003eT y y' yv-\u003eT y y' yv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-SampleRateContext-Cut.html#v:take"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.SampleRateContext.Cut",
          "name": "takeUntilPause",
          "package": "synthesizer",
          "signature": "y' -\u003e t' -\u003e T t t' -\u003e T y y' yv -\u003e T y y' yv",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-SampleRateContext-Cut.html#takeUntilPause",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer SampleRateContext Cut",
          "module": "Synthesizer.SampleRateContext.Cut",
          "name": "takeUntilPause",
          "normalized": "a-\u003eb-\u003eT c b-\u003eT d a e-\u003eT d a e",
          "package": "synthesizer",
          "partial": "Until Pause",
          "signature": "y'-\u003et'-\u003eT t t'-\u003eT y y' yv-\u003eT y y' yv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-SampleRateContext-Cut.html#v:takeUntilPause"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.SampleRateContext.Cut",
          "name": "unzip",
          "package": "synthesizer",
          "signature": "T t t' -\u003e T y y' (yv0, yv1) -\u003e (T y y' yv0, T y y' yv1)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-SampleRateContext-Cut.html#unzip",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer SampleRateContext Cut",
          "module": "Synthesizer.SampleRateContext.Cut",
          "name": "unzip",
          "normalized": "T a b-\u003eT c d(e,e)-\u003e(T c d e,T c d e)",
          "package": "synthesizer",
          "signature": "T t t'-\u003eT y y'(yv,yv)-\u003e(T y y' yv,T y y' yv)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-SampleRateContext-Cut.html#v:unzip"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.SampleRateContext.Cut",
          "name": "unzip3",
          "package": "synthesizer",
          "signature": "T t t' -\u003e T y y' (yv0, yv1, yv2) -\u003e (T y y' yv0, T y y' yv1, T y y' yv2)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-SampleRateContext-Cut.html#unzip3",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer SampleRateContext Cut",
          "module": "Synthesizer.SampleRateContext.Cut",
          "name": "unzip3",
          "normalized": "T a b-\u003eT c d(e,e,e)-\u003e(T c d e,T c d e,T c d e)",
          "package": "synthesizer",
          "signature": "T t t'-\u003eT y y'(yv,yv,yv)-\u003e(T y y' yv,T y y' yv,T y y' yv)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-SampleRateContext-Cut.html#v:unzip3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.SampleRateContext.Cut",
          "name": "zip",
          "package": "synthesizer",
          "signature": "T t t' -\u003e T y y' yv0 -\u003e T y y' yv1 -\u003e T y y' (yv0, yv1)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-SampleRateContext-Cut.html#zip",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer SampleRateContext Cut",
          "module": "Synthesizer.SampleRateContext.Cut",
          "name": "zip",
          "normalized": "T a b-\u003eT c d e-\u003eT c d e-\u003eT c d(e,e)",
          "package": "synthesizer",
          "signature": "T t t'-\u003eT y y' yv-\u003eT y y' yv-\u003eT y y'(yv,yv)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-SampleRateContext-Cut.html#v:zip"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.SampleRateContext.Cut",
          "name": "zip3",
          "package": "synthesizer",
          "signature": "T t t' -\u003e T y y' yv0 -\u003e T y y' yv1 -\u003e T y y' yv2 -\u003e T y y' (yv0, yv1, yv2)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-SampleRateContext-Cut.html#zip3",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer SampleRateContext Cut",
          "module": "Synthesizer.SampleRateContext.Cut",
          "name": "zip3",
          "normalized": "T a b-\u003eT c d e-\u003eT c d e-\u003eT c d e-\u003eT c d(e,e,e)",
          "package": "synthesizer",
          "signature": "T t t'-\u003eT y y' yv-\u003eT y y' yv-\u003eT y y' yv-\u003eT y y'(yv,yv,yv)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-SampleRateContext-Cut.html#v:zip3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.SampleRateContext.Cut",
          "name": "zip3Volume",
          "package": "synthesizer",
          "signature": "y' -\u003e T t t' -\u003e T y y' yv0 -\u003e T y y' yv1 -\u003e T y y' yv2 -\u003e T y y' (yv0, yv1, yv2)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-SampleRateContext-Cut.html#zip3Volume",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer SampleRateContext Cut",
          "module": "Synthesizer.SampleRateContext.Cut",
          "name": "zip3Volume",
          "normalized": "a-\u003eT b c-\u003eT d a e-\u003eT d a e-\u003eT d a e-\u003eT d a(e,e,e)",
          "package": "synthesizer",
          "partial": "Volume",
          "signature": "y'-\u003eT t t'-\u003eT y y' yv-\u003eT y y' yv-\u003eT y y' yv-\u003eT y y'(yv,yv,yv)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-SampleRateContext-Cut.html#v:zip3Volume"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.SampleRateContext.Cut",
          "name": "zipVolume",
          "package": "synthesizer",
          "signature": "y' -\u003e T t t' -\u003e T y y' yv0 -\u003e T y y' yv1 -\u003e T y y' (yv0, yv1)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-SampleRateContext-Cut.html#zipVolume",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer SampleRateContext Cut",
          "module": "Synthesizer.SampleRateContext.Cut",
          "name": "zipVolume",
          "normalized": "a-\u003eT b c-\u003eT d a e-\u003eT d a e-\u003eT d a(e,e)",
          "package": "synthesizer",
          "partial": "Volume",
          "signature": "y'-\u003eT t t'-\u003eT y y' yv-\u003eT y y' yv-\u003eT y y'(yv,yv)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-SampleRateContext-Cut.html#v:zipVolume"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Mix two signals.\n    In opposition to \u003ctt\u003e\u003ca\u003ezipWith\u003c/a\u003e\u003c/tt\u003e the result has the length of the longer signal. \n",
          "module": "Synthesizer.SampleRateContext.Displacement",
          "name": "mix",
          "package": "synthesizer",
          "signature": "T t t' -\u003e T y y' yv -\u003e T y y' yv -\u003e T y y' yv",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-SampleRateContext-Displacement.html#mix",
          "type": "function"
        },
        "index": {
          "description": "Mix two signals In opposition to zipWith the result has the length of the longer signal",
          "hierarchy": "Synthesizer SampleRateContext Displacement",
          "module": "Synthesizer.SampleRateContext.Displacement",
          "name": "mix",
          "normalized": "T a b-\u003eT c d e-\u003eT c d e-\u003eT c d e",
          "package": "synthesizer",
          "signature": "T t t'-\u003eT y y' yv-\u003eT y y' yv-\u003eT y y' yv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-SampleRateContext-Displacement.html#v:mix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Mix one or more signals. \n",
          "module": "Synthesizer.SampleRateContext.Displacement",
          "name": "mixMulti",
          "package": "synthesizer",
          "signature": "T t t' -\u003e [T y y' yv] -\u003e T y y' yv",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-SampleRateContext-Displacement.html#mixMulti",
          "type": "function"
        },
        "index": {
          "description": "Mix one or more signals",
          "hierarchy": "Synthesizer SampleRateContext Displacement",
          "module": "Synthesizer.SampleRateContext.Displacement",
          "name": "mixMulti",
          "normalized": "T a b-\u003e[T c d e]-\u003eT c d e",
          "package": "synthesizer",
          "partial": "Multi",
          "signature": "T t t'-\u003e[T y y' yv]-\u003eT y y' yv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-SampleRateContext-Displacement.html#v:mixMulti"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.SampleRateContext.Displacement",
          "name": "mixMultiVolume",
          "package": "synthesizer",
          "signature": "y' -\u003e T t t' -\u003e [T y y' yv] -\u003e T y y' yv",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-SampleRateContext-Displacement.html#mixMultiVolume",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer SampleRateContext Displacement",
          "module": "Synthesizer.SampleRateContext.Displacement",
          "name": "mixMultiVolume",
          "normalized": "a-\u003eT b c-\u003e[T d a e]-\u003eT d a e",
          "package": "synthesizer",
          "partial": "Multi Volume",
          "signature": "y'-\u003eT t t'-\u003e[T y y' yv]-\u003eT y y' yv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-SampleRateContext-Displacement.html#v:mixMultiVolume"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.SampleRateContext.Displacement",
          "name": "mixVolume",
          "package": "synthesizer",
          "signature": "y' -\u003e T t t' -\u003e T y y' yv -\u003e T y y' yv -\u003e T y y' yv",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-SampleRateContext-Displacement.html#mixVolume",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer SampleRateContext Displacement",
          "module": "Synthesizer.SampleRateContext.Displacement",
          "name": "mixVolume",
          "normalized": "a-\u003eT b c-\u003eT d a e-\u003eT d a e-\u003eT d a e",
          "package": "synthesizer",
          "partial": "Volume",
          "signature": "y'-\u003eT t t'-\u003eT y y' yv-\u003eT y y' yv-\u003eT y y' yv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-SampleRateContext-Displacement.html#v:mixVolume"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Add a number to all of the signal values.\n    This is useful for adjusting the center of a modulation. \n",
          "module": "Synthesizer.SampleRateContext.Displacement",
          "name": "raise",
          "package": "synthesizer",
          "signature": "y' -\u003e yv -\u003e T t t' -\u003e T y y' yv -\u003e T y y' yv",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-SampleRateContext-Displacement.html#raise",
          "type": "function"
        },
        "index": {
          "description": "Add number to all of the signal values This is useful for adjusting the center of modulation",
          "hierarchy": "Synthesizer SampleRateContext Displacement",
          "module": "Synthesizer.SampleRateContext.Displacement",
          "name": "raise",
          "normalized": "a-\u003eb-\u003eT c d-\u003eT e a b-\u003eT e a b",
          "package": "synthesizer",
          "signature": "y'-\u003eyv-\u003eT t t'-\u003eT y y' yv-\u003eT y y' yv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-SampleRateContext-Displacement.html#v:raise"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "The amplification factor must be positive. \n",
          "module": "Synthesizer.SampleRateContext.Filter",
          "name": "amplify",
          "package": "synthesizer",
          "signature": "y' -\u003e T t t' -\u003e T y y' yv -\u003e T y y' yv",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-SampleRateContext-Filter.html#amplify",
          "type": "function"
        },
        "index": {
          "description": "The amplification factor must be positive",
          "hierarchy": "Synthesizer SampleRateContext Filter",
          "module": "Synthesizer.SampleRateContext.Filter",
          "name": "amplify",
          "normalized": "a-\u003eT b c-\u003eT d a e-\u003eT d a e",
          "package": "synthesizer",
          "signature": "y'-\u003eT t t'-\u003eT y y' yv-\u003eT y y' yv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-SampleRateContext-Filter.html#v:amplify"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Infinitely many equi-delayed exponentially decaying echos. \n",
          "module": "Synthesizer.SampleRateContext.Filter",
          "name": "comb",
          "package": "synthesizer",
          "signature": "t' -\u003e y -\u003e T t t' -\u003e T y y' yv -\u003e T y y' yv",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-SampleRateContext-Filter.html#comb",
          "type": "function"
        },
        "index": {
          "description": "Infinitely many equi-delayed exponentially decaying echos",
          "hierarchy": "Synthesizer SampleRateContext Filter",
          "module": "Synthesizer.SampleRateContext.Filter",
          "name": "comb",
          "normalized": "a-\u003eb-\u003eT c a-\u003eT b d e-\u003eT b d e",
          "package": "synthesizer",
          "signature": "t'-\u003ey-\u003eT t t'-\u003eT y y' yv-\u003eT y y' yv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-SampleRateContext-Filter.html#v:comb"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.SampleRateContext.Filter",
          "name": "differentiate",
          "package": "synthesizer",
          "signature": "T t q' -\u003e T y q' v -\u003e T y q' v",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-SampleRateContext-Filter.html#differentiate",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer SampleRateContext Filter",
          "module": "Synthesizer.SampleRateContext.Filter",
          "name": "differentiate",
          "normalized": "T a b-\u003eT c b d-\u003eT c b d",
          "package": "synthesizer",
          "signature": "T t q'-\u003eT y q' v-\u003eT y q' v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-SampleRateContext-Filter.html#v:differentiate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.SampleRateContext.Filter",
          "name": "envelope",
          "package": "synthesizer",
          "signature": "T t t' -\u003e T y y' y0 -\u003e T y y' yv -\u003e T y y' yv",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-SampleRateContext-Filter.html#envelope",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer SampleRateContext Filter",
          "module": "Synthesizer.SampleRateContext.Filter",
          "name": "envelope",
          "normalized": "T a b-\u003eT c d c-\u003eT c d e-\u003eT c d e",
          "package": "synthesizer",
          "signature": "T t t'-\u003eT y y' y-\u003eT y y' yv-\u003eT y y' yv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-SampleRateContext-Filter.html#v:envelope"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.SampleRateContext.Filter",
          "name": "integrate",
          "package": "synthesizer",
          "signature": "T t q' -\u003e T y q' v -\u003e T y q' v",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-SampleRateContext-Filter.html#integrate",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer SampleRateContext Filter",
          "module": "Synthesizer.SampleRateContext.Filter",
          "name": "integrate",
          "normalized": "T a b-\u003eT c b d-\u003eT c b d",
          "package": "synthesizer",
          "signature": "T t q'-\u003eT y q' v-\u003eT y q' v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-SampleRateContext-Filter.html#v:integrate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.SampleRateContext.Filter",
          "name": "negate",
          "package": "synthesizer",
          "signature": "T t t' -\u003e T y y' yv -\u003e T y y' yv",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-SampleRateContext-Filter.html#negate",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer SampleRateContext Filter",
          "module": "Synthesizer.SampleRateContext.Filter",
          "name": "negate",
          "normalized": "T a b-\u003eT c d e-\u003eT c d e",
          "package": "synthesizer",
          "signature": "T t t'-\u003eT y y' yv-\u003eT y y' yv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-SampleRateContext-Filter.html#v:negate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "momentary densities (frequency),\n                           \u003ctt\u003ep\u003c/tt\u003e means that there is about one peak\n                           in the time range of \u003ctt\u003e1/p\u003c/tt\u003e. \nEvery occurence of \u003ctt\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/tt\u003e represents a peak. \n",
          "module": "Synthesizer.SampleRateContext.Noise",
          "name": "randomPeeks",
          "package": "synthesizer",
          "signature": "T q q'-\u003e T q q' q-\u003e [Bool]",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-SampleRateContext-Noise.html#randomPeeks",
          "type": "function"
        },
        "index": {
          "description": "momentary densities frequency means that there is about one peak in the time range of Every occurence of True represents peak",
          "hierarchy": "Synthesizer SampleRateContext Noise",
          "module": "Synthesizer.SampleRateContext.Noise",
          "name": "randomPeeks",
          "normalized": "T a b-\u003eT a b a-\u003e[Bool]",
          "package": "synthesizer",
          "partial": "Peeks",
          "signature": "T q q'-\u003eT q q' q-\u003e[Bool]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-SampleRateContext-Noise.html#v:randomPeeks"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "random generator, can be used to choose a seed \nmomentary densities (frequency),\n                           \u003ctt\u003ep\u003c/tt\u003e means that there is about one peak\n                           in the time range of \u003ctt\u003e1/p\u003c/tt\u003e. \nEvery occurence of \u003ctt\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/tt\u003e represents a peak. \n",
          "module": "Synthesizer.SampleRateContext.Noise",
          "name": "randomPeeksGen",
          "package": "synthesizer",
          "signature": "g-\u003e T q q'-\u003e T q q' q-\u003e [Bool]",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-SampleRateContext-Noise.html#randomPeeksGen",
          "type": "function"
        },
        "index": {
          "description": "random generator can be used to choose seed momentary densities frequency means that there is about one peak in the time range of Every occurence of True represents peak",
          "hierarchy": "Synthesizer SampleRateContext Noise",
          "module": "Synthesizer.SampleRateContext.Noise",
          "name": "randomPeeksGen",
          "normalized": "a-\u003eT b c-\u003eT b c b-\u003e[Bool]",
          "package": "synthesizer",
          "partial": "Peeks Gen",
          "signature": "g-\u003eT q q'-\u003eT q q' q-\u003e[Bool]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-SampleRateContext-Noise.html#v:randomPeeksGen"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "width of the frequency band \nvolume caused by the given frequency band \nnoise \n",
          "module": "Synthesizer.SampleRateContext.Noise",
          "name": "white",
          "package": "synthesizer",
          "signature": "q'-\u003e q'-\u003e T t q'-\u003e T y q' yv",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-SampleRateContext-Noise.html#white",
          "type": "function"
        },
        "index": {
          "description": "width of the frequency band volume caused by the given frequency band noise",
          "hierarchy": "Synthesizer SampleRateContext Noise",
          "module": "Synthesizer.SampleRateContext.Noise",
          "name": "white",
          "normalized": "a-\u003ea-\u003eT b a-\u003eT c a d",
          "package": "synthesizer",
          "signature": "q'-\u003eq'-\u003eT t q'-\u003eT y q' yv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-SampleRateContext-Noise.html#v:white"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "energy per frequency band \nnoise \n",
          "module": "Synthesizer.SampleRateContext.Noise",
          "name": "whiteBandEnergy",
          "package": "synthesizer",
          "signature": "q'-\u003e T t q'-\u003e T y q' yv",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-SampleRateContext-Noise.html#whiteBandEnergy",
          "type": "function"
        },
        "index": {
          "description": "energy per frequency band noise",
          "hierarchy": "Synthesizer SampleRateContext Noise",
          "module": "Synthesizer.SampleRateContext.Noise",
          "name": "whiteBandEnergy",
          "normalized": "a-\u003eT b a-\u003eT c a d",
          "package": "synthesizer",
          "partial": "Band Energy",
          "signature": "q'-\u003eT t q'-\u003eT y q' yv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-SampleRateContext-Noise.html#v:whiteBandEnergy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "random generator, can be used to choose a seed \nenergy per frequency band \nnoise \n",
          "module": "Synthesizer.SampleRateContext.Noise",
          "name": "whiteBandEnergyGen",
          "package": "synthesizer",
          "signature": "g-\u003e q'-\u003e T t q'-\u003e T y q' yv",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-SampleRateContext-Noise.html#whiteBandEnergyGen",
          "type": "function"
        },
        "index": {
          "description": "random generator can be used to choose seed energy per frequency band noise",
          "hierarchy": "Synthesizer SampleRateContext Noise",
          "module": "Synthesizer.SampleRateContext.Noise",
          "name": "whiteBandEnergyGen",
          "normalized": "a-\u003eb-\u003eT c b-\u003eT d b e",
          "package": "synthesizer",
          "partial": "Band Energy Gen",
          "signature": "g-\u003eq'-\u003eT t q'-\u003eT y q' yv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-SampleRateContext-Noise.html#v:whiteBandEnergyGen"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "random generator, can be used to choose a seed \nwidth of the frequency band \nvolume caused by the given frequency band \nnoise \n",
          "module": "Synthesizer.SampleRateContext.Noise",
          "name": "whiteGen",
          "package": "synthesizer",
          "signature": "g-\u003e q'-\u003e q'-\u003e T t q'-\u003e T y q' yv",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-SampleRateContext-Noise.html#whiteGen",
          "type": "function"
        },
        "index": {
          "description": "random generator can be used to choose seed width of the frequency band volume caused by the given frequency band noise",
          "hierarchy": "Synthesizer SampleRateContext Noise",
          "module": "Synthesizer.SampleRateContext.Noise",
          "name": "whiteGen",
          "normalized": "a-\u003eb-\u003eb-\u003eT c b-\u003eT d b e",
          "package": "synthesizer",
          "partial": "Gen",
          "signature": "g-\u003eq'-\u003eq'-\u003eT t q'-\u003eT y q' yv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-SampleRateContext-Noise.html#v:whiteGen"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "waveform \namplitude \nstart phase from the range [0,1] \nfrequency control \n",
          "module": "Synthesizer.SampleRateContext.Oscillator",
          "name": "freqMod",
          "package": "synthesizer",
          "signature": "T t yv-\u003e y'-\u003e t-\u003e T t t'-\u003e T t t' t-\u003e T y y' yv",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-SampleRateContext-Oscillator.html#freqMod",
          "type": "function"
        },
        "index": {
          "description": "waveform amplitude start phase from the range frequency control",
          "hierarchy": "Synthesizer SampleRateContext Oscillator",
          "module": "Synthesizer.SampleRateContext.Oscillator",
          "name": "freqMod",
          "normalized": "T a b-\u003ec-\u003ea-\u003eT a d-\u003eT a d a-\u003eT e c b",
          "package": "synthesizer",
          "partial": "Mod",
          "signature": "T t yv-\u003ey'-\u003et-\u003eT t t'-\u003eT t t' t-\u003eT y y' yv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-SampleRateContext-Oscillator.html#v:freqMod"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "waveform \namplitude \nphase control \nfrequency control \n",
          "module": "Synthesizer.SampleRateContext.Oscillator",
          "name": "phaseFreqMod",
          "package": "synthesizer",
          "signature": "T t yv-\u003e y'-\u003e T t t'-\u003e T t t t-\u003e T t t' t-\u003e T y y' yv",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-SampleRateContext-Oscillator.html#phaseFreqMod",
          "type": "function"
        },
        "index": {
          "description": "waveform amplitude phase control frequency control",
          "hierarchy": "Synthesizer SampleRateContext Oscillator",
          "module": "Synthesizer.SampleRateContext.Oscillator",
          "name": "phaseFreqMod",
          "normalized": "T a b-\u003ec-\u003eT a d-\u003eT a a a-\u003eT a d a-\u003eT e c b",
          "package": "synthesizer",
          "partial": "Freq Mod",
          "signature": "T t yv-\u003ey'-\u003eT t t'-\u003eT t t t-\u003eT t t' t-\u003eT y y' yv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-SampleRateContext-Oscillator.html#v:phaseFreqMod"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "waveform \namplitude \nfrequency control \nphase modulation, phases must have no unit and\n                          are from range [0,1] \n",
          "module": "Synthesizer.SampleRateContext.Oscillator",
          "name": "phaseMod",
          "package": "synthesizer",
          "signature": "T t yv-\u003e y'-\u003e t'-\u003e T t t'-\u003e T t t t-\u003e T y y' yv",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-SampleRateContext-Oscillator.html#phaseMod",
          "type": "function"
        },
        "index": {
          "description": "waveform amplitude frequency control phase modulation phases must have no unit and are from range",
          "hierarchy": "Synthesizer SampleRateContext Oscillator",
          "module": "Synthesizer.SampleRateContext.Oscillator",
          "name": "phaseMod",
          "normalized": "T a b-\u003ec-\u003ed-\u003eT a d-\u003eT a a a-\u003eT e c b",
          "package": "synthesizer",
          "partial": "Mod",
          "signature": "T t yv-\u003ey'-\u003et'-\u003eT t t'-\u003eT t t t-\u003eT y y' yv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-SampleRateContext-Oscillator.html#v:phaseMod"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "waveform \namplitude \nstart phase from the range [0,1] \nfrequency \n",
          "module": "Synthesizer.SampleRateContext.Oscillator",
          "name": "static",
          "package": "synthesizer",
          "signature": "T t yv-\u003e y'-\u003e t-\u003e t'-\u003e T t t'-\u003e T y y' yv",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-SampleRateContext-Oscillator.html#static",
          "type": "function"
        },
        "index": {
          "description": "waveform amplitude start phase from the range frequency",
          "hierarchy": "Synthesizer SampleRateContext Oscillator",
          "module": "Synthesizer.SampleRateContext.Oscillator",
          "name": "static",
          "normalized": "T a b-\u003ec-\u003ea-\u003ed-\u003eT a d-\u003eT e c b",
          "package": "synthesizer",
          "signature": "T t yv-\u003ey'-\u003et-\u003et'-\u003eT t t'-\u003eT y y' yv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-SampleRateContext-Oscillator.html#v:static"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.SampleRateContext.Play",
          "name": "toInt16",
          "package": "synthesizer",
          "signature": "t' -\u003e y' -\u003e t' -\u003e (T t t' -\u003e T y y' yv) -\u003e IO ExitCode",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-SampleRateContext-Play.html#toInt16",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer SampleRateContext Play",
          "module": "Synthesizer.SampleRateContext.Play",
          "name": "toInt16",
          "normalized": "a-\u003eb-\u003ea-\u003e(T c a-\u003eT d b e)-\u003eIO ExitCode",
          "package": "synthesizer",
          "partial": "Int",
          "signature": "t'-\u003ey'-\u003et'-\u003e(T t t'-\u003eT y y' yv)-\u003eIO ExitCode",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-SampleRateContext-Play.html#v:toInt16"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.SampleRateContext.Rate",
          "name": "T",
          "package": "synthesizer",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-SampleRateContext-Rate.html#T",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "Synthesizer SampleRateContext Rate",
          "module": "Synthesizer.SampleRateContext.Rate",
          "name": "T",
          "package": "synthesizer",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-SampleRateContext-Rate.html#t:T"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.SampleRateContext.Rate",
          "name": "fromNumber",
          "package": "synthesizer",
          "signature": "t' -\u003e T t t'",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-SampleRateContext-Rate.html#fromNumber",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer SampleRateContext Rate",
          "module": "Synthesizer.SampleRateContext.Rate",
          "name": "fromNumber",
          "normalized": "a-\u003eT b a",
          "package": "synthesizer",
          "partial": "Number",
          "signature": "t'-\u003eT t t'",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-SampleRateContext-Rate.html#v:fromNumber"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.SampleRateContext.Rate",
          "name": "pure",
          "package": "synthesizer",
          "signature": "a -\u003e T t t' -\u003e a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-SampleRateContext-Rate.html#pure",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer SampleRateContext Rate",
          "module": "Synthesizer.SampleRateContext.Rate",
          "name": "pure",
          "normalized": "a-\u003eT b c-\u003ea",
          "package": "synthesizer",
          "signature": "a-\u003eT t t'-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-SampleRateContext-Rate.html#v:pure"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.SampleRateContext.Rate",
          "name": "toNumber",
          "package": "synthesizer",
          "signature": "T t t' -\u003e t'",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-SampleRateContext-Rate.html#toNumber",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer SampleRateContext Rate",
          "module": "Synthesizer.SampleRateContext.Rate",
          "name": "toNumber",
          "normalized": "T a b-\u003eb",
          "package": "synthesizer",
          "partial": "Number",
          "signature": "T t t'-\u003et'",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-SampleRateContext-Rate.html#v:toNumber"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.SampleRateContext.Signal",
          "name": "T",
          "package": "synthesizer",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Amplitude-Signal.html#T",
          "type": "data"
        },
        "index": {
          "hierarchy": "Synthesizer SampleRateContext Signal",
          "module": "Synthesizer.SampleRateContext.Signal",
          "name": "T",
          "package": "synthesizer",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-SampleRateContext-Signal.html#t:T"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Take a scalar argument where a process expects a signal.\nOnly possible for non-negative values so far.\n",
          "module": "Synthesizer.SampleRateContext.Signal",
          "name": "$-",
          "package": "synthesizer",
          "signature": "(T t t' -\u003e T y y' y -\u003e a) -\u003e y' -\u003e T t t' -\u003e a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-SampleRateContext-Signal.html#%24-",
          "type": "function"
        },
        "index": {
          "description": "Take scalar argument where process expects signal Only possible for non-negative values so far",
          "hierarchy": "Synthesizer SampleRateContext Signal",
          "module": "Synthesizer.SampleRateContext.Signal",
          "name": "$-",
          "normalized": "(T a b-\u003eT c d c-\u003ee)-\u003ed-\u003eT a b-\u003ee",
          "package": "synthesizer",
          "signature": "(T t t'-\u003eT y y' y-\u003ea)-\u003ey'-\u003eT t t'-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-SampleRateContext-Signal.html#v:$-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.SampleRateContext.Signal",
          "name": "toFrequencyScalar",
          "package": "synthesizer",
          "signature": "T t t' -\u003e t' -\u003e t",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-SampleRateContext-Signal.html#toFrequencyScalar",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer SampleRateContext Signal",
          "module": "Synthesizer.SampleRateContext.Signal",
          "name": "toFrequencyScalar",
          "normalized": "T a b-\u003eb-\u003ea",
          "package": "synthesizer",
          "partial": "Frequency Scalar",
          "signature": "T t t'-\u003et'-\u003et",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-SampleRateContext-Signal.html#v:toFrequencyScalar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.SampleRateContext.Signal",
          "name": "toGradientScalar",
          "package": "synthesizer",
          "signature": "q' -\u003e T q q' -\u003e q' -\u003e q",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-SampleRateContext-Signal.html#toGradientScalar",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer SampleRateContext Signal",
          "module": "Synthesizer.SampleRateContext.Signal",
          "name": "toGradientScalar",
          "normalized": "a-\u003eT b a-\u003ea-\u003eb",
          "package": "synthesizer",
          "partial": "Gradient Scalar",
          "signature": "q'-\u003eT q q'-\u003eq'-\u003eq",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-SampleRateContext-Signal.html#v:toGradientScalar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.SampleRateContext.Signal",
          "name": "toTimeScalar",
          "package": "synthesizer",
          "signature": "T t t' -\u003e t' -\u003e t",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-SampleRateContext-Signal.html#toTimeScalar",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer SampleRateContext Signal",
          "module": "Synthesizer.SampleRateContext.Signal",
          "name": "toTimeScalar",
          "normalized": "T a b-\u003eb-\u003ea",
          "package": "synthesizer",
          "partial": "Time Scalar",
          "signature": "T t t'-\u003et'-\u003et",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-SampleRateContext-Signal.html#v:toTimeScalar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.State.Analysis",
          "name": "attachOne",
          "package": "synthesizer",
          "signature": "T i -\u003e [(i, Int)]",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Analysis.html#attachOne",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer State Analysis",
          "module": "Synthesizer.State.Analysis",
          "name": "attachOne",
          "normalized": "T a-\u003e[(a,Int)]",
          "package": "synthesizer",
          "partial": "One",
          "signature": "T i-\u003e[(i,Int)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Analysis.html#v:attachOne"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.State.Analysis",
          "name": "average",
          "package": "synthesizer",
          "signature": "T y -\u003e y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Analysis.html#average",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer State Analysis",
          "module": "Synthesizer.State.Analysis",
          "name": "average",
          "normalized": "T a-\u003ea",
          "package": "synthesizer",
          "signature": "T y-\u003ey",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Analysis.html#v:average"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.State.Analysis",
          "name": "averageRecompute",
          "package": "synthesizer",
          "signature": "T y -\u003e y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Analysis.html#averageRecompute",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer State Analysis",
          "module": "Synthesizer.State.Analysis",
          "name": "averageRecompute",
          "normalized": "T a-\u003ea",
          "package": "synthesizer",
          "partial": "Recompute",
          "signature": "T y-\u003ey",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Analysis.html#v:averageRecompute"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Compute minimum and maximum value of the stream the efficient way.\nInput list must be non-empty and finite.\n",
          "module": "Synthesizer.State.Analysis",
          "name": "bounds",
          "package": "synthesizer",
          "signature": "T y -\u003e (y, y)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Analysis.html#bounds",
          "type": "function"
        },
        "index": {
          "description": "Compute minimum and maximum value of the stream the efficient way Input list must be non-empty and finite",
          "hierarchy": "Synthesizer State Analysis",
          "module": "Synthesizer.State.Analysis",
          "name": "bounds",
          "normalized": "T a-\u003e(a,a)",
          "package": "synthesizer",
          "signature": "T y-\u003e(y,y)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Analysis.html#v:bounds"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003ctt\u003e\u003ca\u003edirectCurrentOffset\u003c/a\u003e\u003c/tt\u003e must be non-zero.\n",
          "module": "Synthesizer.State.Analysis",
          "name": "centroid",
          "package": "synthesizer",
          "signature": "T y -\u003e y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Analysis.html#centroid",
          "type": "function"
        },
        "index": {
          "description": "directCurrentOffset must be non-zero",
          "hierarchy": "Synthesizer State Analysis",
          "module": "Synthesizer.State.Analysis",
          "name": "centroid",
          "normalized": "T a-\u003ea",
          "package": "synthesizer",
          "signature": "T y-\u003ey",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Analysis.html#v:centroid"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.State.Analysis",
          "name": "centroidRecompute",
          "package": "synthesizer",
          "signature": "T y -\u003e y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Analysis.html#centroidRecompute",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer State Analysis",
          "module": "Synthesizer.State.Analysis",
          "name": "centroidRecompute",
          "normalized": "T a-\u003ea",
          "package": "synthesizer",
          "partial": "Recompute",
          "signature": "T y-\u003ey",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Analysis.html#v:centroidRecompute"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAlmost naive implementation of the chirp transform,\na generalization of the Fourier transform.\n\u003c/p\u003e\u003cp\u003eMore sophisticated algorithms like Rader, Cooley-Tukey, Winograd, Prime-Factor may follow.\n\u003c/p\u003e",
          "module": "Synthesizer.State.Analysis",
          "name": "chirpTransform",
          "package": "synthesizer",
          "signature": "y -\u003e T y -\u003e T y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Analysis.html#chirpTransform",
          "type": "function"
        },
        "index": {
          "description": "Almost naive implementation of the chirp transform generalization of the Fourier transform More sophisticated algorithms like Rader Cooley-Tukey Winograd Prime-Factor may follow",
          "hierarchy": "Synthesizer State Analysis",
          "module": "Synthesizer.State.Analysis",
          "name": "chirpTransform",
          "normalized": "a-\u003eT a-\u003eT a",
          "package": "synthesizer",
          "partial": "Transform",
          "signature": "y-\u003eT y-\u003eT y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Analysis.html#v:chirpTransform"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Requires finite length.\nThis is identical to the arithmetic mean.\n",
          "module": "Synthesizer.State.Analysis",
          "name": "directCurrentOffset",
          "package": "synthesizer",
          "signature": "T y -\u003e y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Analysis.html#directCurrentOffset",
          "type": "function"
        },
        "index": {
          "description": "Requires finite length This is identical to the arithmetic mean",
          "hierarchy": "Synthesizer State Analysis",
          "module": "Synthesizer.State.Analysis",
          "name": "directCurrentOffset",
          "normalized": "T a-\u003ea",
          "package": "synthesizer",
          "partial": "Current Offset",
          "signature": "T y-\u003ey",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Analysis.html#v:directCurrentOffset"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.State.Analysis",
          "name": "firstMoment",
          "package": "synthesizer",
          "signature": "T y -\u003e y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Analysis.html#firstMoment",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer State Analysis",
          "module": "Synthesizer.State.Analysis",
          "name": "firstMoment",
          "normalized": "T a-\u003ea",
          "package": "synthesizer",
          "partial": "Moment",
          "signature": "T y-\u003ey",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Analysis.html#v:firstMoment"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Detect thresholds with a hysteresis.\n",
          "module": "Synthesizer.State.Analysis",
          "name": "flipFlopHysteresis",
          "package": "synthesizer",
          "signature": "(y, y) -\u003e Bool -\u003e T y -\u003e T Bool",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Analysis.html#flipFlopHysteresis",
          "type": "function"
        },
        "index": {
          "description": "Detect thresholds with hysteresis",
          "hierarchy": "Synthesizer State Analysis",
          "module": "Synthesizer.State.Analysis",
          "name": "flipFlopHysteresis",
          "normalized": "(a,a)-\u003eBool-\u003eT a-\u003eT Bool",
          "package": "synthesizer",
          "partial": "Flop Hysteresis",
          "signature": "(y,y)-\u003eBool-\u003eT y-\u003eT Bool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Analysis.html#v:flipFlopHysteresis"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Input list must be finite.\nList is scanned twice, but counting may be faster.\n",
          "module": "Synthesizer.State.Analysis",
          "name": "histogramDiscreteArray",
          "package": "synthesizer",
          "signature": "T Int -\u003e (Int, T Int)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Analysis.html#histogramDiscreteArray",
          "type": "function"
        },
        "index": {
          "description": "Input list must be finite List is scanned twice but counting may be faster",
          "hierarchy": "Synthesizer State Analysis",
          "module": "Synthesizer.State.Analysis",
          "name": "histogramDiscreteArray",
          "normalized": "T Int-\u003e(Int,T Int)",
          "package": "synthesizer",
          "partial": "Discrete Array",
          "signature": "T Int-\u003e(Int,T Int)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Analysis.html#v:histogramDiscreteArray"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Input list must be finite.\nIf the input signal is empty, the offset is \u003ctt\u003eundefined\u003c/tt\u003e.\nList is scanned once, counting may be slower.\n",
          "module": "Synthesizer.State.Analysis",
          "name": "histogramDiscreteIntMap",
          "package": "synthesizer",
          "signature": "T Int -\u003e (Int, T Int)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Analysis.html#histogramDiscreteIntMap",
          "type": "function"
        },
        "index": {
          "description": "Input list must be finite If the input signal is empty the offset is undefined List is scanned once counting may be slower",
          "hierarchy": "Synthesizer State Analysis",
          "module": "Synthesizer.State.Analysis",
          "name": "histogramDiscreteIntMap",
          "normalized": "T Int-\u003e(Int,T Int)",
          "package": "synthesizer",
          "partial": "Discrete Int Map",
          "signature": "T Int-\u003e(Int,T Int)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Analysis.html#v:histogramDiscreteIntMap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.State.Analysis",
          "name": "histogramIntMap",
          "package": "synthesizer",
          "signature": "y -\u003e T y -\u003e (Int, T Int)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Analysis.html#histogramIntMap",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer State Analysis",
          "module": "Synthesizer.State.Analysis",
          "name": "histogramIntMap",
          "normalized": "a-\u003eT a-\u003e(Int,T Int)",
          "package": "synthesizer",
          "partial": "Int Map",
          "signature": "y-\u003eT y-\u003e(Int,T Int)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Analysis.html#v:histogramIntMap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Input list must be finite.\nIf the input signal is empty, the offset is \u003ctt\u003eundefined\u003c/tt\u003e.\nList is scanned twice, but counting may be faster.\nThe sum of all histogram values is one less than the length of the signal.\n",
          "module": "Synthesizer.State.Analysis",
          "name": "histogramLinearArray",
          "package": "synthesizer",
          "signature": "T y -\u003e (Int, T y)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Analysis.html#histogramLinearArray",
          "type": "function"
        },
        "index": {
          "description": "Input list must be finite If the input signal is empty the offset is undefined List is scanned twice but counting may be faster The sum of all histogram values is one less than the length of the signal",
          "hierarchy": "Synthesizer State Analysis",
          "module": "Synthesizer.State.Analysis",
          "name": "histogramLinearArray",
          "normalized": "T a-\u003e(Int,T a)",
          "package": "synthesizer",
          "partial": "Linear Array",
          "signature": "T y-\u003e(Int,T y)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Analysis.html#v:histogramLinearArray"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.State.Analysis",
          "name": "histogramLinearIntMap",
          "package": "synthesizer",
          "signature": "T y -\u003e (Int, T y)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Analysis.html#histogramLinearIntMap",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer State Analysis",
          "module": "Synthesizer.State.Analysis",
          "name": "histogramLinearIntMap",
          "normalized": "T a-\u003e(Int,T a)",
          "package": "synthesizer",
          "partial": "Linear Int Map",
          "signature": "T y-\u003e(Int,T y)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Analysis.html#v:histogramLinearIntMap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.State.Analysis",
          "name": "meanValues",
          "package": "synthesizer",
          "signature": "T y -\u003e [(Int, y)]",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Analysis.html#meanValues",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer State Analysis",
          "module": "Synthesizer.State.Analysis",
          "name": "meanValues",
          "normalized": "T a-\u003e[(Int,a)]",
          "package": "synthesizer",
          "partial": "Values",
          "signature": "T y-\u003e[(Int,y)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Analysis.html#v:meanValues"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.State.Analysis",
          "name": "quantize",
          "package": "synthesizer",
          "signature": "y -\u003e T y -\u003e T Int",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Analysis.html#quantize",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer State Analysis",
          "module": "Synthesizer.State.Analysis",
          "name": "quantize",
          "normalized": "a-\u003eT a-\u003eT Int",
          "package": "synthesizer",
          "signature": "y-\u003eT y-\u003eT Int",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Analysis.html#v:quantize"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.State.Analysis",
          "name": "rectify",
          "package": "synthesizer",
          "signature": "T y -\u003e T y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Analysis.html#rectify",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer State Analysis",
          "module": "Synthesizer.State.Analysis",
          "name": "rectify",
          "normalized": "T a-\u003eT a",
          "package": "synthesizer",
          "signature": "T y-\u003eT y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Analysis.html#v:rectify"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.State.Analysis",
          "name": "scalarProduct",
          "package": "synthesizer",
          "signature": "T y -\u003e T y -\u003e y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Analysis.html#scalarProduct",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer State Analysis",
          "module": "Synthesizer.State.Analysis",
          "name": "scalarProduct",
          "normalized": "T a-\u003eT a-\u003ea",
          "package": "synthesizer",
          "partial": "Product",
          "signature": "T y-\u003eT y-\u003ey",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Analysis.html#v:scalarProduct"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.State.Analysis",
          "name": "spread",
          "package": "synthesizer",
          "signature": "(y, y) -\u003e [(Int, y)]",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Analysis.html#spread",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer State Analysis",
          "module": "Synthesizer.State.Analysis",
          "name": "spread",
          "normalized": "(a,a)-\u003e[(Int,a)]",
          "package": "synthesizer",
          "signature": "(y,y)-\u003e[(Int,y)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Analysis.html#v:spread"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Volume based on Energy norm.\n",
          "module": "Synthesizer.State.Analysis",
          "name": "volumeEuclidean",
          "package": "synthesizer",
          "signature": "T y -\u003e y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Analysis.html#volumeEuclidean",
          "type": "function"
        },
        "index": {
          "description": "Volume based on Energy norm",
          "hierarchy": "Synthesizer State Analysis",
          "module": "Synthesizer.State.Analysis",
          "name": "volumeEuclidean",
          "normalized": "T a-\u003ea",
          "package": "synthesizer",
          "partial": "Euclidean",
          "signature": "T y-\u003ey",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Analysis.html#v:volumeEuclidean"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.State.Analysis",
          "name": "volumeEuclideanSqr",
          "package": "synthesizer",
          "signature": "T y -\u003e y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Analysis.html#volumeEuclideanSqr",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer State Analysis",
          "module": "Synthesizer.State.Analysis",
          "name": "volumeEuclideanSqr",
          "normalized": "T a-\u003ea",
          "package": "synthesizer",
          "partial": "Euclidean Sqr",
          "signature": "T y-\u003ey",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Analysis.html#v:volumeEuclideanSqr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Volume based on Manhattan norm.\n",
          "module": "Synthesizer.State.Analysis",
          "name": "volumeMaximum",
          "package": "synthesizer",
          "signature": "T y -\u003e y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Analysis.html#volumeMaximum",
          "type": "function"
        },
        "index": {
          "description": "Volume based on Manhattan norm",
          "hierarchy": "Synthesizer State Analysis",
          "module": "Synthesizer.State.Analysis",
          "name": "volumeMaximum",
          "normalized": "T a-\u003ea",
          "package": "synthesizer",
          "partial": "Maximum",
          "signature": "T y-\u003ey",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Analysis.html#v:volumeMaximum"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Volume based on Sum norm.\n",
          "module": "Synthesizer.State.Analysis",
          "name": "volumeSum",
          "package": "synthesizer",
          "signature": "T y -\u003e y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Analysis.html#volumeSum",
          "type": "function"
        },
        "index": {
          "description": "Volume based on Sum norm",
          "hierarchy": "Synthesizer State Analysis",
          "module": "Synthesizer.State.Analysis",
          "name": "volumeSum",
          "normalized": "T a-\u003ea",
          "package": "synthesizer",
          "partial": "Sum",
          "signature": "T y-\u003ey",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Analysis.html#v:volumeSum"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Volume based on Energy norm.\n",
          "module": "Synthesizer.State.Analysis",
          "name": "volumeVectorEuclidean",
          "package": "synthesizer",
          "signature": "T yv -\u003e y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Analysis.html#volumeVectorEuclidean",
          "type": "function"
        },
        "index": {
          "description": "Volume based on Energy norm",
          "hierarchy": "Synthesizer State Analysis",
          "module": "Synthesizer.State.Analysis",
          "name": "volumeVectorEuclidean",
          "normalized": "T a-\u003eb",
          "package": "synthesizer",
          "partial": "Vector Euclidean",
          "signature": "T yv-\u003ey",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Analysis.html#v:volumeVectorEuclidean"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.State.Analysis",
          "name": "volumeVectorEuclideanSqr",
          "package": "synthesizer",
          "signature": "T yv -\u003e y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Analysis.html#volumeVectorEuclideanSqr",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer State Analysis",
          "module": "Synthesizer.State.Analysis",
          "name": "volumeVectorEuclideanSqr",
          "normalized": "T a-\u003eb",
          "package": "synthesizer",
          "partial": "Vector Euclidean Sqr",
          "signature": "T yv-\u003ey",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Analysis.html#v:volumeVectorEuclideanSqr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Volume based on Manhattan norm.\n",
          "module": "Synthesizer.State.Analysis",
          "name": "volumeVectorMaximum",
          "package": "synthesizer",
          "signature": "T yv -\u003e y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Analysis.html#volumeVectorMaximum",
          "type": "function"
        },
        "index": {
          "description": "Volume based on Manhattan norm",
          "hierarchy": "Synthesizer State Analysis",
          "module": "Synthesizer.State.Analysis",
          "name": "volumeVectorMaximum",
          "normalized": "T a-\u003eb",
          "package": "synthesizer",
          "partial": "Vector Maximum",
          "signature": "T yv-\u003ey",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Analysis.html#v:volumeVectorMaximum"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Volume based on Sum norm.\n",
          "module": "Synthesizer.State.Analysis",
          "name": "volumeVectorSum",
          "package": "synthesizer",
          "signature": "T yv -\u003e y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Analysis.html#volumeVectorSum",
          "type": "function"
        },
        "index": {
          "description": "Volume based on Sum norm",
          "hierarchy": "Synthesizer State Analysis",
          "module": "Synthesizer.State.Analysis",
          "name": "volumeVectorSum",
          "normalized": "T a-\u003eb",
          "package": "synthesizer",
          "partial": "Vector Sum",
          "signature": "T yv-\u003ey",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Analysis.html#v:volumeVectorSum"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.State.Analysis",
          "name": "withAtLeast1",
          "package": "synthesizer",
          "signature": "String -\u003e (T y -\u003e (Int, T y)) -\u003e T y -\u003e (Int, T y)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Analysis.html#withAtLeast1",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer State Analysis",
          "module": "Synthesizer.State.Analysis",
          "name": "withAtLeast1",
          "normalized": "String-\u003e(T a-\u003e(Int,T a))-\u003eT a-\u003e(Int,T a)",
          "package": "synthesizer",
          "partial": "At Least",
          "signature": "String-\u003e(T y-\u003e(Int,T y))-\u003eT y-\u003e(Int,T y)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Analysis.html#v:withAtLeast1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.State.Analysis",
          "name": "withAtLeast2",
          "package": "synthesizer",
          "signature": "String -\u003e (T y -\u003e (Int, T y)) -\u003e T y -\u003e (Int, T y)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Analysis.html#withAtLeast2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer State Analysis",
          "module": "Synthesizer.State.Analysis",
          "name": "withAtLeast2",
          "normalized": "String-\u003e(T a-\u003e(Int,T a))-\u003eT a-\u003e(Int,T a)",
          "package": "synthesizer",
          "partial": "At Least",
          "signature": "String-\u003e(T y-\u003e(Int,T y))-\u003eT y-\u003e(Int,T y)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Analysis.html#v:withAtLeast2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDetects zeros (sign changes) in a signal.\nThis can be used as a simple measure of the portion\nof high frequencies or noise in the signal.\nIt ca be used as voiced/unvoiced detector in a vocoder.\n\u003c/p\u003e\u003cp\u003e\u003ctt\u003ezeros x !! n\u003c/tt\u003e is \u003ctt\u003eTrue\u003c/tt\u003e if and only if\n\u003ctt\u003e(x !! n \u003e= 0) /= (x !! (n+1) \u003e= 0)\u003c/tt\u003e.\nThe result will be one value shorter than the input.\n\u003c/p\u003e",
          "module": "Synthesizer.State.Analysis",
          "name": "zeros",
          "package": "synthesizer",
          "signature": "T y -\u003e T Bool",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Analysis.html#zeros",
          "type": "function"
        },
        "index": {
          "description": "Detects zeros sign changes in signal This can be used as simple measure of the portion of high frequencies or noise in the signal It ca be used as voiced unvoiced detector in vocoder zeros is True if and only if The result will be one value shorter than the input",
          "hierarchy": "Synthesizer State Analysis",
          "module": "Synthesizer.State.Analysis",
          "name": "zeros",
          "normalized": "T a-\u003eT Bool",
          "package": "synthesizer",
          "signature": "T y-\u003eT Bool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Analysis.html#v:zeros"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.State.Control",
          "name": "Piece",
          "package": "synthesizer",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Control.html#Piece",
          "type": "type"
        },
        "index": {
          "hierarchy": "Synthesizer State Control",
          "module": "Synthesizer.State.Control",
          "name": "Piece",
          "package": "synthesizer",
          "partial": "Piece",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Control.html#t:Piece"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.State.Control",
          "name": "constant",
          "package": "synthesizer",
          "signature": "a -\u003e T a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Control.html#constant",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer State Control",
          "module": "Synthesizer.State.Control",
          "name": "constant",
          "normalized": "a-\u003eT a",
          "package": "synthesizer",
          "signature": "a-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Control.html#v:constant"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "time t0 where  1 is approached \ntime t1 where -1 is approached \na cosine wave where one half wave is between t0 and t1 \n",
          "module": "Synthesizer.State.Control",
          "name": "cosine",
          "package": "synthesizer",
          "signature": "a-\u003e a-\u003e T a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Control.html#cosine",
          "type": "function"
        },
        "index": {
          "description": "time t0 where is approached time t1 where is approached cosine wave where one half wave is between t0 and t1",
          "hierarchy": "Synthesizer State Control",
          "module": "Synthesizer.State.Control",
          "name": "cosine",
          "normalized": "a-\u003ea-\u003eT a",
          "package": "synthesizer",
          "signature": "a-\u003ea-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Control.html#v:cosine"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.State.Control",
          "name": "cosinePiece",
          "package": "synthesizer",
          "signature": "Piece a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Control.html#cosinePiece",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer State Control",
          "module": "Synthesizer.State.Control",
          "name": "cosinePiece",
          "package": "synthesizer",
          "partial": "Piece",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Control.html#v:cosinePiece"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.State.Control",
          "name": "cubicHermite",
          "package": "synthesizer",
          "signature": "(a, (a, a)) -\u003e (a, (a, a)) -\u003e T a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Control.html#cubicHermite",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer State Control",
          "module": "Synthesizer.State.Control",
          "name": "cubicHermite",
          "normalized": "(a,(a,a))-\u003e(a,(a,a))-\u003eT a",
          "package": "synthesizer",
          "partial": "Hermite",
          "signature": "(a,(a,a))-\u003e(a,(a,a))-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Control.html#v:cubicHermite"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.State.Control",
          "name": "cubicPiece",
          "package": "synthesizer",
          "signature": "a -\u003e a -\u003e Piece a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Control.html#cubicPiece",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer State Control",
          "module": "Synthesizer.State.Control",
          "name": "cubicPiece",
          "normalized": "a-\u003ea-\u003ePiece a",
          "package": "synthesizer",
          "partial": "Piece",
          "signature": "a-\u003ea-\u003ePiece a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Control.html#v:cubicPiece"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.State.Control",
          "name": "curveMultiscale",
          "package": "synthesizer",
          "signature": "(y -\u003e y -\u003e y) -\u003e y -\u003e y -\u003e T y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Control.html#curveMultiscale",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer State Control",
          "module": "Synthesizer.State.Control",
          "name": "curveMultiscale",
          "normalized": "(a-\u003ea-\u003ea)-\u003ea-\u003ea-\u003eT a",
          "package": "synthesizer",
          "partial": "Multiscale",
          "signature": "(y-\u003ey-\u003ey)-\u003ey-\u003ey-\u003eT y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Control.html#v:curveMultiscale"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.State.Control",
          "name": "curveMultiscaleNeutral",
          "package": "synthesizer",
          "signature": "(y -\u003e y -\u003e y) -\u003e y -\u003e y -\u003e T y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Control.html#curveMultiscaleNeutral",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer State Control",
          "module": "Synthesizer.State.Control",
          "name": "curveMultiscaleNeutral",
          "normalized": "(a-\u003ea-\u003ea)-\u003ea-\u003ea-\u003eT a",
          "package": "synthesizer",
          "partial": "Multiscale Neutral",
          "signature": "(y-\u003ey-\u003ey)-\u003ey-\u003ey-\u003eT y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Control.html#v:curveMultiscaleNeutral"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "time where the function reaches 1/e of the initial value \ninitial value \nexponential decay \n",
          "module": "Synthesizer.State.Control",
          "name": "exponential",
          "package": "synthesizer",
          "signature": "a-\u003e a-\u003e T a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Control.html#exponential",
          "type": "function"
        },
        "index": {
          "description": "time where the function reaches of the initial value initial value exponential decay",
          "hierarchy": "Synthesizer State Control",
          "module": "Synthesizer.State.Control",
          "name": "exponential",
          "normalized": "a-\u003ea-\u003eT a",
          "package": "synthesizer",
          "signature": "a-\u003ea-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Control.html#v:exponential"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "half life \ninitial value \nexponential decay \n",
          "module": "Synthesizer.State.Control",
          "name": "exponential2",
          "package": "synthesizer",
          "signature": "a-\u003e a-\u003e T a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Control.html#exponential2",
          "type": "function"
        },
        "index": {
          "description": "half life initial value exponential decay",
          "hierarchy": "Synthesizer State Control",
          "module": "Synthesizer.State.Control",
          "name": "exponential2",
          "normalized": "a-\u003ea-\u003eT a",
          "package": "synthesizer",
          "signature": "a-\u003ea-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Control.html#v:exponential2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "half life \ninitial value \nexponential decay \n",
          "module": "Synthesizer.State.Control",
          "name": "exponential2Multiscale",
          "package": "synthesizer",
          "signature": "a-\u003e a-\u003e T a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Control.html#exponential2Multiscale",
          "type": "function"
        },
        "index": {
          "description": "half life initial value exponential decay",
          "hierarchy": "Synthesizer State Control",
          "module": "Synthesizer.State.Control",
          "name": "exponential2Multiscale",
          "normalized": "a-\u003ea-\u003eT a",
          "package": "synthesizer",
          "partial": "Multiscale",
          "signature": "a-\u003ea-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Control.html#v:exponential2Multiscale"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "half life \nexponential decay \n",
          "module": "Synthesizer.State.Control",
          "name": "exponential2MultiscaleNeutral",
          "package": "synthesizer",
          "signature": "y-\u003e T y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Control.html#exponential2MultiscaleNeutral",
          "type": "function"
        },
        "index": {
          "description": "half life exponential decay",
          "hierarchy": "Synthesizer State Control",
          "module": "Synthesizer.State.Control",
          "name": "exponential2MultiscaleNeutral",
          "normalized": "a-\u003eT a",
          "package": "synthesizer",
          "partial": "Multiscale Neutral",
          "signature": "y-\u003eT y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Control.html#v:exponential2MultiscaleNeutral"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "time where the function reaches 1/e of the initial value \ninitial value \nvalue after given time \nexponential decay \n",
          "module": "Synthesizer.State.Control",
          "name": "exponentialFromTo",
          "package": "synthesizer",
          "signature": "y-\u003e y-\u003e y-\u003e T y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Control.html#exponentialFromTo",
          "type": "function"
        },
        "index": {
          "description": "time where the function reaches of the initial value initial value value after given time exponential decay",
          "hierarchy": "Synthesizer State Control",
          "module": "Synthesizer.State.Control",
          "name": "exponentialFromTo",
          "normalized": "a-\u003ea-\u003ea-\u003eT a",
          "package": "synthesizer",
          "partial": "From To",
          "signature": "y-\u003ey-\u003ey-\u003eT y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Control.html#v:exponentialFromTo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "time where the function reaches 1/e of the initial value \ninitial value \nvalue after given time \nexponential decay \n",
          "module": "Synthesizer.State.Control",
          "name": "exponentialFromToMultiscale",
          "package": "synthesizer",
          "signature": "y-\u003e y-\u003e y-\u003e T y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Control.html#exponentialFromToMultiscale",
          "type": "function"
        },
        "index": {
          "description": "time where the function reaches of the initial value initial value value after given time exponential decay",
          "hierarchy": "Synthesizer State Control",
          "module": "Synthesizer.State.Control",
          "name": "exponentialFromToMultiscale",
          "normalized": "a-\u003ea-\u003ea-\u003eT a",
          "package": "synthesizer",
          "partial": "From To Multiscale",
          "signature": "y-\u003ey-\u003ey-\u003eT y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Control.html#v:exponentialFromToMultiscale"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "time where the function reaches 1/e of the initial value \ninitial value \nexponential decay \n",
          "module": "Synthesizer.State.Control",
          "name": "exponentialMultiscale",
          "package": "synthesizer",
          "signature": "a-\u003e a-\u003e T a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Control.html#exponentialMultiscale",
          "type": "function"
        },
        "index": {
          "description": "time where the function reaches of the initial value initial value exponential decay",
          "hierarchy": "Synthesizer State Control",
          "module": "Synthesizer.State.Control",
          "name": "exponentialMultiscale",
          "normalized": "a-\u003ea-\u003eT a",
          "package": "synthesizer",
          "partial": "Multiscale",
          "signature": "a-\u003ea-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Control.html#v:exponentialMultiscale"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "time where the function reaches 1/e of the initial value \nexponential decay \n",
          "module": "Synthesizer.State.Control",
          "name": "exponentialMultiscaleNeutral",
          "package": "synthesizer",
          "signature": "y-\u003e T y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Control.html#exponentialMultiscaleNeutral",
          "type": "function"
        },
        "index": {
          "description": "time where the function reaches of the initial value exponential decay",
          "hierarchy": "Synthesizer State Control",
          "module": "Synthesizer.State.Control",
          "name": "exponentialMultiscaleNeutral",
          "normalized": "a-\u003eT a",
          "package": "synthesizer",
          "partial": "Multiscale Neutral",
          "signature": "y-\u003eT y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Control.html#v:exponentialMultiscaleNeutral"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.State.Control",
          "name": "exponentialPiece",
          "package": "synthesizer",
          "signature": "a -\u003e Piece a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Control.html#exponentialPiece",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer State Control",
          "module": "Synthesizer.State.Control",
          "name": "exponentialPiece",
          "normalized": "a-\u003ePiece a",
          "package": "synthesizer",
          "partial": "Piece",
          "signature": "a-\u003ePiece a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Control.html#v:exponentialPiece"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "length \ninitial and final value \nlinear progression \n",
          "module": "Synthesizer.State.Control",
          "name": "line",
          "package": "synthesizer",
          "signature": "Int-\u003e (y, y)-\u003e T y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Control.html#line",
          "type": "function"
        },
        "index": {
          "description": "length initial and final value linear progression",
          "hierarchy": "Synthesizer State Control",
          "module": "Synthesizer.State.Control",
          "name": "line",
          "normalized": "Int-\u003e(a,a)-\u003eT a",
          "package": "synthesizer",
          "signature": "Int-\u003e(y,y)-\u003eT y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Control.html#v:line"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "steepness \ninitial value \nlinear progression \n",
          "module": "Synthesizer.State.Control",
          "name": "linear",
          "package": "synthesizer",
          "signature": "a-\u003e a-\u003e T a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Control.html#linear",
          "type": "function"
        },
        "index": {
          "description": "steepness initial value linear progression",
          "hierarchy": "Synthesizer State Control",
          "module": "Synthesizer.State.Control",
          "name": "linear",
          "normalized": "a-\u003ea-\u003eT a",
          "package": "synthesizer",
          "signature": "a-\u003ea-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Control.html#v:linear"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "As stable as the addition of time values.\n",
          "module": "Synthesizer.State.Control",
          "name": "linearMultiscale",
          "package": "synthesizer",
          "signature": "y -\u003e y -\u003e T y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Control.html#linearMultiscale",
          "type": "function"
        },
        "index": {
          "description": "As stable as the addition of time values",
          "hierarchy": "Synthesizer State Control",
          "module": "Synthesizer.State.Control",
          "name": "linearMultiscale",
          "normalized": "a-\u003ea-\u003eT a",
          "package": "synthesizer",
          "partial": "Multiscale",
          "signature": "y-\u003ey-\u003eT y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Control.html#v:linearMultiscale"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Linear curve starting at zero.\n",
          "module": "Synthesizer.State.Control",
          "name": "linearMultiscaleNeutral",
          "package": "synthesizer",
          "signature": "y -\u003e T y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Control.html#linearMultiscaleNeutral",
          "type": "function"
        },
        "index": {
          "description": "Linear curve starting at zero",
          "hierarchy": "Synthesizer State Control",
          "module": "Synthesizer.State.Control",
          "name": "linearMultiscaleNeutral",
          "normalized": "a-\u003eT a",
          "package": "synthesizer",
          "partial": "Multiscale Neutral",
          "signature": "y-\u003eT y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Control.html#v:linearMultiscaleNeutral"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.State.Control",
          "name": "linearPiece",
          "package": "synthesizer",
          "signature": "Piece a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Control.html#linearPiece",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer State Control",
          "module": "Synthesizer.State.Control",
          "name": "linearPiece",
          "package": "synthesizer",
          "partial": "Piece",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Control.html#v:linearPiece"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.State.Control",
          "name": "piecewise",
          "package": "synthesizer",
          "signature": "T a a (a -\u003e T a) -\u003e T a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Control.html#piecewise",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer State Control",
          "module": "Synthesizer.State.Control",
          "name": "piecewise",
          "normalized": "T a a(a-\u003eT a)-\u003eT a",
          "package": "synthesizer",
          "signature": "T a a(a-\u003eT a)-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Control.html#v:piecewise"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.State.Control",
          "name": "splitDurations",
          "package": "synthesizer",
          "signature": "[t] -\u003e [(Int, t)]",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Control.html#splitDurations",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer State Control",
          "module": "Synthesizer.State.Control",
          "name": "splitDurations",
          "normalized": "[a]-\u003e[(Int,a)]",
          "package": "synthesizer",
          "partial": "Durations",
          "signature": "[t]-\u003e[(Int,t)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Control.html#v:splitDurations"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.State.Control",
          "name": "stepPiece",
          "package": "synthesizer",
          "signature": "Piece a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Control.html#stepPiece",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer State Control",
          "module": "Synthesizer.State.Control",
          "name": "stepPiece",
          "package": "synthesizer",
          "partial": "Piece",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Control.html#v:stepPiece"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "time where the function reaches 1/e of the initial value \ninitial value \nexponential decay \n",
          "module": "Synthesizer.State.Control",
          "name": "vectorExponential",
          "package": "synthesizer",
          "signature": "a-\u003e v-\u003e T v",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Control.html#vectorExponential",
          "type": "function"
        },
        "index": {
          "description": "time where the function reaches of the initial value initial value exponential decay",
          "hierarchy": "Synthesizer State Control",
          "module": "Synthesizer.State.Control",
          "name": "vectorExponential",
          "normalized": "a-\u003eb-\u003eT b",
          "package": "synthesizer",
          "partial": "Exponential",
          "signature": "a-\u003ev-\u003eT v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Control.html#v:vectorExponential"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "half life \ninitial value \nexponential decay \n",
          "module": "Synthesizer.State.Control",
          "name": "vectorExponential2",
          "package": "synthesizer",
          "signature": "a-\u003e v-\u003e T v",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Control.html#vectorExponential2",
          "type": "function"
        },
        "index": {
          "description": "half life initial value exponential decay",
          "hierarchy": "Synthesizer State Control",
          "module": "Synthesizer.State.Control",
          "name": "vectorExponential2",
          "normalized": "a-\u003eb-\u003eT b",
          "package": "synthesizer",
          "partial": "Exponential",
          "signature": "a-\u003ev-\u003eT v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Control.html#v:vectorExponential2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "A list of pairs: (relative start time, signal part),\n                The start time is relative to the start time\n                of the previous event. \nThe mixed signal. \n",
          "module": "Synthesizer.State.Cut",
          "name": "arrange",
          "package": "synthesizer",
          "signature": "T Int (T v)-\u003e T v",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Cut.html#arrange",
          "type": "function"
        },
        "index": {
          "description": "list of pairs relative start time signal part The start time is relative to the start time of the previous event The mixed signal",
          "hierarchy": "Synthesizer State Cut",
          "module": "Synthesizer.State.Cut",
          "name": "arrange",
          "normalized": "T Int(T a)-\u003eT a",
          "package": "synthesizer",
          "signature": "T Int(T v)-\u003eT v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Cut.html#v:arrange"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "A list of pairs: (relative start time, signal part),\n                The start time is relative to the start time\n                of the previous event. \nThe mixed signal. \n",
          "module": "Synthesizer.State.Cut",
          "name": "arrangeList",
          "package": "synthesizer",
          "signature": "T Int (T v)-\u003e T v",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Cut.html#arrangeList",
          "type": "function"
        },
        "index": {
          "description": "list of pairs relative start time signal part The start time is relative to the start time of the previous event The mixed signal",
          "hierarchy": "Synthesizer State Cut",
          "module": "Synthesizer.State.Cut",
          "name": "arrangeList",
          "normalized": "T Int(T a)-\u003eT a",
          "package": "synthesizer",
          "partial": "List",
          "signature": "T Int(T v)-\u003eT v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Cut.html#v:arrangeList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.State.Cut",
          "name": "select",
          "package": "synthesizer",
          "signature": "Array i (T a) -\u003e T i -\u003e T a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Cut.html#select",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer State Cut",
          "module": "Synthesizer.State.Cut",
          "name": "select",
          "normalized": "Array a(T b)-\u003eT a-\u003eT b",
          "package": "synthesizer",
          "signature": "Array i(T a)-\u003eT i-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Cut.html#v:select"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.State.Cut",
          "name": "selectBool",
          "package": "synthesizer",
          "signature": "(T a, T a) -\u003e T Bool -\u003e T a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Cut.html#selectBool",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer State Cut",
          "module": "Synthesizer.State.Cut",
          "name": "selectBool",
          "normalized": "(T a,T a)-\u003eT Bool-\u003eT a",
          "package": "synthesizer",
          "partial": "Bool",
          "signature": "(T a,T a)-\u003eT Bool-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Cut.html#v:selectBool"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Take values until the predicate p holds for n successive values.\nThe list is truncated at the beginning of the interval of matching values.\n",
          "module": "Synthesizer.State.Cut",
          "name": "takeUntilInterval",
          "package": "synthesizer",
          "signature": "(a -\u003e Bool) -\u003e Int -\u003e T a -\u003e T a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Cut.html#takeUntilInterval",
          "type": "function"
        },
        "index": {
          "description": "Take values until the predicate holds for successive values The list is truncated at the beginning of the interval of matching values",
          "hierarchy": "Synthesizer State Cut",
          "module": "Synthesizer.State.Cut",
          "name": "takeUntilInterval",
          "normalized": "(a-\u003eBool)-\u003eInt-\u003eT a-\u003eT a",
          "package": "synthesizer",
          "partial": "Until Interval",
          "signature": "(a-\u003eBool)-\u003eInt-\u003eT a-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Cut.html#v:takeUntilInterval"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Take signal until it falls short of a certain amplitude for a given time.\n",
          "module": "Synthesizer.State.Cut",
          "name": "takeUntilPause",
          "package": "synthesizer",
          "signature": "a -\u003e Int -\u003e T a -\u003e T a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Cut.html#takeUntilPause",
          "type": "function"
        },
        "index": {
          "description": "Take signal until it falls short of certain amplitude for given time",
          "hierarchy": "Synthesizer State Cut",
          "module": "Synthesizer.State.Cut",
          "name": "takeUntilPause",
          "normalized": "a-\u003eInt-\u003eT a-\u003eT a",
          "package": "synthesizer",
          "partial": "Until Pause",
          "signature": "a-\u003eInt-\u003eT a-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Cut.html#v:takeUntilPause"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "In \u003ca\u003eSynthesizer.Basic.Distortion\u003c/a\u003e you find a collection\nof appropriate distortion functions.\n",
          "module": "Synthesizer.State.Displacement",
          "name": "distort",
          "package": "synthesizer",
          "signature": "(c -\u003e a -\u003e a) -\u003e T c -\u003e T a -\u003e T a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Displacement.html#distort",
          "type": "function"
        },
        "index": {
          "description": "In Synthesizer.Basic.Distortion you find collection of appropriate distortion functions",
          "hierarchy": "Synthesizer State Displacement",
          "module": "Synthesizer.State.Displacement",
          "name": "distort",
          "normalized": "(a-\u003eb-\u003eb)-\u003eT a-\u003eT b-\u003eT b",
          "package": "synthesizer",
          "signature": "(c-\u003ea-\u003ea)-\u003eT c-\u003eT a-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Displacement.html#v:distort"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Mix two signals.\nIn opposition to \u003ctt\u003e\u003ca\u003ezipWith\u003c/a\u003e\u003c/tt\u003e the result has the length of the longer signal.\n",
          "module": "Synthesizer.State.Displacement",
          "name": "mix",
          "package": "synthesizer",
          "signature": "T v -\u003e T v -\u003e T v",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Displacement.html#mix",
          "type": "function"
        },
        "index": {
          "description": "Mix two signals In opposition to zipWith the result has the length of the longer signal",
          "hierarchy": "Synthesizer State Displacement",
          "module": "Synthesizer.State.Displacement",
          "name": "mix",
          "normalized": "T a-\u003eT a-\u003eT a",
          "package": "synthesizer",
          "signature": "T v-\u003eT v-\u003eT v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Displacement.html#v:mix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Mix an arbitrary number of signals. \n",
          "module": "Synthesizer.State.Displacement",
          "name": "mixMulti",
          "package": "synthesizer",
          "signature": "[T v] -\u003e T v",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Displacement.html#mixMulti",
          "type": "function"
        },
        "index": {
          "description": "Mix an arbitrary number of signals",
          "hierarchy": "Synthesizer State Displacement",
          "module": "Synthesizer.State.Displacement",
          "name": "mixMulti",
          "normalized": "[T a]-\u003eT a",
          "package": "synthesizer",
          "partial": "Multi",
          "signature": "[T v]-\u003eT v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Displacement.html#v:mixMulti"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Add a number to all of the signal values.\nThis is useful for adjusting the center of a modulation.\n",
          "module": "Synthesizer.State.Displacement",
          "name": "raise",
          "package": "synthesizer",
          "signature": "v -\u003e T v -\u003e T v",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Displacement.html#raise",
          "type": "function"
        },
        "index": {
          "description": "Add number to all of the signal values This is useful for adjusting the center of modulation",
          "hierarchy": "Synthesizer State Displacement",
          "module": "Synthesizer.State.Displacement",
          "name": "raise",
          "normalized": "a-\u003eT a-\u003eT a",
          "package": "synthesizer",
          "signature": "v-\u003eT v-\u003eT v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Displacement.html#v:raise"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "This is essentially different for constant interpolation,\nbecause this function \u003ca\u003elooks forward\u003c/a\u003e\nwhereas the other two variants \u003ca\u003elook backward\u003c/a\u003e.\nFor the symmetric interpolation functions\nof linear and cubic interpolation, this does not really matter.\n",
          "module": "Synthesizer.State.Filter.Delay",
          "name": "modulated",
          "package": "synthesizer",
          "signature": "T a v -\u003e Int -\u003e T a -\u003e T v -\u003e T v",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Filter-Delay.html#modulated",
          "type": "function"
        },
        "index": {
          "description": "This is essentially different for constant interpolation because this function looks forward whereas the other two variants look backward For the symmetric interpolation functions of linear and cubic interpolation this does not really matter",
          "hierarchy": "Synthesizer State Filter Delay",
          "module": "Synthesizer.State.Filter.Delay",
          "name": "modulated",
          "normalized": "T a b-\u003eInt-\u003eT a-\u003eT b-\u003eT b",
          "package": "synthesizer",
          "signature": "T a v-\u003eInt-\u003eT a-\u003eT v-\u003eT v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Filter-Delay.html#v:modulated"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.State.Filter.Delay",
          "name": "modulatedCore",
          "package": "synthesizer",
          "signature": "T a v -\u003e Int -\u003e T a -\u003e T v -\u003e T v",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Filter-Delay.html#modulatedCore",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer State Filter Delay",
          "module": "Synthesizer.State.Filter.Delay",
          "name": "modulatedCore",
          "normalized": "T a b-\u003eInt-\u003eT a-\u003eT b-\u003eT b",
          "package": "synthesizer",
          "partial": "Core",
          "signature": "T a v-\u003eInt-\u003eT a-\u003eT v-\u003eT v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Filter-Delay.html#v:modulatedCore"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.State.Filter.Delay",
          "name": "static",
          "package": "synthesizer",
          "signature": "Int -\u003e T y -\u003e T y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Filter-Delay.html#static",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer State Filter Delay",
          "module": "Synthesizer.State.Filter.Delay",
          "name": "static",
          "normalized": "Int-\u003eT a-\u003eT a",
          "package": "synthesizer",
          "signature": "Int-\u003eT y-\u003eT y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Filter-Delay.html#v:static"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.State.Filter.Delay",
          "name": "staticNeg",
          "package": "synthesizer",
          "signature": "Int -\u003e T y -\u003e T y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Filter-Delay.html#staticNeg",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer State Filter Delay",
          "module": "Synthesizer.State.Filter.Delay",
          "name": "staticNeg",
          "normalized": "Int-\u003eT a-\u003eT a",
          "package": "synthesizer",
          "partial": "Neg",
          "signature": "Int-\u003eT y-\u003eT y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Filter-Delay.html#v:staticNeg"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.State.Filter.Delay",
          "name": "staticPad",
          "package": "synthesizer",
          "signature": "y -\u003e Int -\u003e T y -\u003e T y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Filter-Delay.html#staticPad",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer State Filter Delay",
          "module": "Synthesizer.State.Filter.Delay",
          "name": "staticPad",
          "normalized": "a-\u003eInt-\u003eT a-\u003eT a",
          "package": "synthesizer",
          "partial": "Pad",
          "signature": "y-\u003eInt-\u003eT y-\u003eT y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Filter-Delay.html#v:staticPad"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.State.Filter.Delay",
          "name": "staticPos",
          "package": "synthesizer",
          "signature": "Int -\u003e T y -\u003e T y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Filter-Delay.html#staticPos",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer State Filter Delay",
          "module": "Synthesizer.State.Filter.Delay",
          "name": "staticPos",
          "normalized": "Int-\u003eT a-\u003eT a",
          "package": "synthesizer",
          "partial": "Pos",
          "signature": "Int-\u003eT y-\u003eT y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Filter-Delay.html#v:staticPos"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.State.Filter.NonRecursive",
          "name": "amplify",
          "package": "synthesizer",
          "signature": "a -\u003e T a -\u003e T a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Filter-NonRecursive.html#amplify",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer State Filter NonRecursive",
          "module": "Synthesizer.State.Filter.NonRecursive",
          "name": "amplify",
          "normalized": "a-\u003eT a-\u003eT a",
          "package": "synthesizer",
          "signature": "a-\u003eT a-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Filter-NonRecursive.html#v:amplify"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.State.Filter.NonRecursive",
          "name": "amplifyVector",
          "package": "synthesizer",
          "signature": "a -\u003e T v -\u003e T v",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Filter-NonRecursive.html#amplifyVector",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer State Filter NonRecursive",
          "module": "Synthesizer.State.Filter.NonRecursive",
          "name": "amplifyVector",
          "normalized": "a-\u003eT b-\u003eT b",
          "package": "synthesizer",
          "partial": "Vector",
          "signature": "a-\u003eT v-\u003eT v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Filter-NonRecursive.html#v:amplifyVector"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.State.Filter.NonRecursive",
          "name": "binomial",
          "package": "synthesizer",
          "signature": "a -\u003e a -\u003e T v -\u003e T v",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Filter-NonRecursive.html#binomial",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer State Filter NonRecursive",
          "module": "Synthesizer.State.Filter.NonRecursive",
          "name": "binomial",
          "normalized": "a-\u003ea-\u003eT b-\u003eT b",
          "package": "synthesizer",
          "signature": "a-\u003ea-\u003eT v-\u003eT v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Filter-NonRecursive.html#v:binomial"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.State.Filter.NonRecursive",
          "name": "binomial1",
          "package": "synthesizer",
          "signature": "T v -\u003e T v",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Filter-NonRecursive.html#binomial1",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer State Filter NonRecursive",
          "module": "Synthesizer.State.Filter.NonRecursive",
          "name": "binomial1",
          "normalized": "T a-\u003eT a",
          "package": "synthesizer",
          "signature": "T v-\u003eT v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Filter-NonRecursive.html#v:binomial1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Forward difference quotient.\nShortens the signal by one.\nInverts Synthesizer.State.Filter.Recursive.Integration.run in the sense that\n\u003ctt\u003edifferentiate (zero : integrate x) == x\u003c/tt\u003e.\nThe signal is shifted by a half time unit.\n",
          "module": "Synthesizer.State.Filter.NonRecursive",
          "name": "differentiate",
          "package": "synthesizer",
          "signature": "T v -\u003e T v",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Filter-NonRecursive.html#differentiate",
          "type": "function"
        },
        "index": {
          "description": "Forward difference quotient Shortens the signal by one Inverts Synthesizer.State.Filter.Recursive.Integration.run in the sense that differentiate zero integrate The signal is shifted by half time unit",
          "hierarchy": "Synthesizer State Filter NonRecursive",
          "module": "Synthesizer.State.Filter.NonRecursive",
          "name": "differentiate",
          "normalized": "T a-\u003eT a",
          "package": "synthesizer",
          "signature": "T v-\u003eT v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Filter-NonRecursive.html#v:differentiate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Second derivative.\nIt is \u003ctt\u003edifferentiate2 == differentiate . differentiate\u003c/tt\u003e\nbut \u003ctt\u003e\u003ca\u003edifferentiate2\u003c/a\u003e\u003c/tt\u003e should be faster.\n",
          "module": "Synthesizer.State.Filter.NonRecursive",
          "name": "differentiate2",
          "package": "synthesizer",
          "signature": "T v -\u003e T v",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Filter-NonRecursive.html#differentiate2",
          "type": "function"
        },
        "index": {
          "description": "Second derivative It is differentiate2 differentiate differentiate but differentiate2 should be faster",
          "hierarchy": "Synthesizer State Filter NonRecursive",
          "module": "Synthesizer.State.Filter.NonRecursive",
          "name": "differentiate2",
          "normalized": "T a-\u003eT a",
          "package": "synthesizer",
          "signature": "T v-\u003eT v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Filter-NonRecursive.html#v:differentiate2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCentral difference quotient.\nShortens the signal by two elements,\nand shifts the signal by one element.\n(Which can be fixed by prepending an appropriate value.)\nFor linear functions this will yield\nessentially the same result as \u003ctt\u003e\u003ca\u003edifferentiate\u003c/a\u003e\u003c/tt\u003e.\nYou obtain the result of \u003ctt\u003e\u003ca\u003edifferentiateCenter\u003c/a\u003e\u003c/tt\u003e\nif you smooth the one of \u003ctt\u003e\u003ca\u003edifferentiate\u003c/a\u003e\u003c/tt\u003e\nby averaging pairs of adjacent values.\n\u003c/p\u003e\u003cp\u003eToDo: Vector variant\n\u003c/p\u003e",
          "module": "Synthesizer.State.Filter.NonRecursive",
          "name": "differentiateCenter",
          "package": "synthesizer",
          "signature": "T v -\u003e T v",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Filter-NonRecursive.html#differentiateCenter",
          "type": "function"
        },
        "index": {
          "description": "Central difference quotient Shortens the signal by two elements and shifts the signal by one element Which can be fixed by prepending an appropriate value For linear functions this will yield essentially the same result as differentiate You obtain the result of differentiateCenter if you smooth the one of differentiate by averaging pairs of adjacent values ToDo Vector variant",
          "hierarchy": "Synthesizer State Filter NonRecursive",
          "module": "Synthesizer.State.Filter.NonRecursive",
          "name": "differentiateCenter",
          "normalized": "T a-\u003eT a",
          "package": "synthesizer",
          "partial": "Center",
          "signature": "T v-\u003eT v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Filter-NonRecursive.html#v:differentiateCenter"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "the envelope \nthe signal to be enveloped \n",
          "module": "Synthesizer.State.Filter.NonRecursive",
          "name": "envelope",
          "package": "synthesizer",
          "signature": "T a-\u003e T a-\u003e T a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Filter-NonRecursive.html#envelope",
          "type": "function"
        },
        "index": {
          "description": "the envelope the signal to be enveloped",
          "hierarchy": "Synthesizer State Filter NonRecursive",
          "module": "Synthesizer.State.Filter.NonRecursive",
          "name": "envelope",
          "normalized": "T a-\u003eT a-\u003eT a",
          "package": "synthesizer",
          "signature": "T a-\u003eT a-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Filter-NonRecursive.html#v:envelope"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "the envelope \nthe signal to be enveloped \n",
          "module": "Synthesizer.State.Filter.NonRecursive",
          "name": "envelopeVector",
          "package": "synthesizer",
          "signature": "T a-\u003e T v-\u003e T v",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Filter-NonRecursive.html#envelopeVector",
          "type": "function"
        },
        "index": {
          "description": "the envelope the signal to be enveloped",
          "hierarchy": "Synthesizer State Filter NonRecursive",
          "module": "Synthesizer.State.Filter.NonRecursive",
          "name": "envelopeVector",
          "normalized": "T a-\u003eT b-\u003eT b",
          "package": "synthesizer",
          "partial": "Vector",
          "signature": "T a-\u003eT v-\u003eT v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Filter-NonRecursive.html#v:envelopeVector"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.State.Filter.NonRecursive",
          "name": "fadeInOut",
          "package": "synthesizer",
          "signature": "Int -\u003e Int -\u003e Int -\u003e T a -\u003e T a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Filter-NonRecursive.html#fadeInOut",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer State Filter NonRecursive",
          "module": "Synthesizer.State.Filter.NonRecursive",
          "name": "fadeInOut",
          "normalized": "Int-\u003eInt-\u003eInt-\u003eT a-\u003eT a",
          "package": "synthesizer",
          "partial": "In Out",
          "signature": "Int-\u003eInt-\u003eInt-\u003eT a-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Filter-NonRecursive.html#v:fadeInOut"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Unmodulated non-recursive filter \n",
          "module": "Synthesizer.State.Filter.NonRecursive",
          "name": "generic",
          "package": "synthesizer",
          "signature": "T a -\u003e T v -\u003e T v",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Filter-NonRecursive.html#generic",
          "type": "function"
        },
        "index": {
          "description": "Unmodulated non-recursive filter",
          "hierarchy": "Synthesizer State Filter NonRecursive",
          "module": "Synthesizer.State.Filter.NonRecursive",
          "name": "generic",
          "normalized": "T a-\u003eT b-\u003eT b",
          "package": "synthesizer",
          "signature": "T a-\u003eT v-\u003eT v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Filter-NonRecursive.html#v:generic"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Compute the variance of the Gaussian\n  such that its Fourier transform has value \u003ctt\u003eratio\u003c/tt\u003e at frequency \u003ctt\u003efreq\u003c/tt\u003e.\n",
          "module": "Synthesizer.State.Filter.NonRecursive",
          "name": "ratioFreqToVariance",
          "package": "synthesizer",
          "signature": "a -\u003e a -\u003e a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Filter-NonRecursive.html#ratioFreqToVariance",
          "type": "function"
        },
        "index": {
          "description": "Compute the variance of the Gaussian such that its Fourier transform has value ratio at frequency freq",
          "hierarchy": "Synthesizer State Filter NonRecursive",
          "module": "Synthesizer.State.Filter.NonRecursive",
          "name": "ratioFreqToVariance",
          "normalized": "a-\u003ea-\u003ea",
          "package": "synthesizer",
          "partial": "Freq To Variance",
          "signature": "a-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Filter-NonRecursive.html#v:ratioFreqToVariance"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Moving (uniformly weighted) average in the most trivial form.\nThis is very slow and needs about \u003ctt\u003en * length x\u003c/tt\u003e operations.\n",
          "module": "Synthesizer.State.Filter.NonRecursive",
          "name": "sums",
          "package": "synthesizer",
          "signature": "Int -\u003e T v -\u003e T v",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Filter-NonRecursive.html#sums",
          "type": "function"
        },
        "index": {
          "description": "Moving uniformly weighted average in the most trivial form This is very slow and needs about length operations",
          "hierarchy": "Synthesizer State Filter NonRecursive",
          "module": "Synthesizer.State.Filter.NonRecursive",
          "name": "sums",
          "normalized": "Int-\u003eT a-\u003eT a",
          "package": "synthesizer",
          "signature": "Int-\u003eT v-\u003eT v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Filter-NonRecursive.html#v:sums"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "The most simple version of the Karplus-Strong algorithm\nwhich is suitable to simulate a plucked string.\nIt is similar to the \u003ctt\u003e\u003ca\u003erunProc\u003c/a\u003e\u003c/tt\u003e function.\n",
          "module": "Synthesizer.State.Filter.Recursive.Comb",
          "name": "karplusStrong",
          "package": "synthesizer",
          "signature": "Parameter a -\u003e T v -\u003e T v",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Filter-Recursive-Comb.html#karplusStrong",
          "type": "function"
        },
        "index": {
          "description": "The most simple version of the Karplus-Strong algorithm which is suitable to simulate plucked string It is similar to the runProc function",
          "hierarchy": "Synthesizer State Filter Recursive Comb",
          "module": "Synthesizer.State.Filter.Recursive.Comb",
          "name": "karplusStrong",
          "normalized": "Parameter a-\u003eT b-\u003eT b",
          "package": "synthesizer",
          "partial": "Strong",
          "signature": "Parameter a-\u003eT v-\u003eT v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Filter-Recursive-Comb.html#v:karplusStrong"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Infinitely many equi-delayed exponentially decaying echos.\nThe echos are clipped to the input length.\nWe think it is easier (and simpler to do efficiently)\nto pad the input with zeros or whatever\ninstead of cutting the result according to the input length.\n",
          "module": "Synthesizer.State.Filter.Recursive.Comb",
          "name": "run",
          "package": "synthesizer",
          "signature": "Int -\u003e a -\u003e T v -\u003e T v",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Filter-Recursive-Comb.html#run",
          "type": "function"
        },
        "index": {
          "description": "Infinitely many equi-delayed exponentially decaying echos The echos are clipped to the input length We think it is easier and simpler to do efficiently to pad the input with zeros or whatever instead of cutting the result according to the input length",
          "hierarchy": "Synthesizer State Filter Recursive Comb",
          "module": "Synthesizer.State.Filter.Recursive.Comb",
          "name": "run",
          "normalized": "Int-\u003ea-\u003eT b-\u003eT b",
          "package": "synthesizer",
          "signature": "Int-\u003ea-\u003eT v-\u003eT v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Filter-Recursive-Comb.html#v:run"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Echos of different delays. \n",
          "module": "Synthesizer.State.Filter.Recursive.Comb",
          "name": "runMulti",
          "package": "synthesizer",
          "signature": "[Int] -\u003e a -\u003e T v -\u003e T v",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Filter-Recursive-Comb.html#runMulti",
          "type": "function"
        },
        "index": {
          "description": "Echos of different delays",
          "hierarchy": "Synthesizer State Filter Recursive Comb",
          "module": "Synthesizer.State.Filter.Recursive.Comb",
          "name": "runMulti",
          "normalized": "[Int]-\u003ea-\u003eT b-\u003eT b",
          "package": "synthesizer",
          "partial": "Multi",
          "signature": "[Int]-\u003ea-\u003eT v-\u003eT v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Filter-Recursive-Comb.html#v:runMulti"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Echos can be piped through an arbitrary signal processor. \n",
          "module": "Synthesizer.State.Filter.Recursive.Comb",
          "name": "runProc",
          "package": "synthesizer",
          "signature": "Int -\u003e (T v -\u003e T v) -\u003e T v -\u003e T v",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Filter-Recursive-Comb.html#runProc",
          "type": "function"
        },
        "index": {
          "description": "Echos can be piped through an arbitrary signal processor",
          "hierarchy": "Synthesizer State Filter Recursive Comb",
          "module": "Synthesizer.State.Filter.Recursive.Comb",
          "name": "runProc",
          "normalized": "Int-\u003e(T a-\u003eT a)-\u003eT a-\u003eT a",
          "package": "synthesizer",
          "partial": "Proc",
          "signature": "Int-\u003e(T v-\u003eT v)-\u003eT v-\u003eT v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Filter-Recursive-Comb.html#v:runProc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.State.Filter.Recursive.Integration",
          "name": "causal",
          "package": "synthesizer",
          "signature": "T v v",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Filter-Recursive-Integration.html#causal",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer State Filter Recursive Integration",
          "module": "Synthesizer.State.Filter.Recursive.Integration",
          "name": "causal",
          "package": "synthesizer",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Filter-Recursive-Integration.html#v:causal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Integrate with initial condition.\nFirst emitted value is the initial condition.\nThe signal become one element longer.\n",
          "module": "Synthesizer.State.Filter.Recursive.Integration",
          "name": "causalInit",
          "package": "synthesizer",
          "signature": "v -\u003e T v v",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Filter-Recursive-Integration.html#causalInit",
          "type": "function"
        },
        "index": {
          "description": "Integrate with initial condition First emitted value is the initial condition The signal become one element longer",
          "hierarchy": "Synthesizer State Filter Recursive Integration",
          "module": "Synthesizer.State.Filter.Recursive.Integration",
          "name": "causalInit",
          "normalized": "a-\u003eT a a",
          "package": "synthesizer",
          "partial": "Init",
          "signature": "v-\u003eT v v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Filter-Recursive-Integration.html#v:causalInit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Integrate with initial value zero.\nHowever the first emitted value is the value of the input signal.\nIt maintains the length of the signal.\n",
          "module": "Synthesizer.State.Filter.Recursive.Integration",
          "name": "run",
          "package": "synthesizer",
          "signature": "T v -\u003e T v",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Filter-Recursive-Integration.html#run",
          "type": "function"
        },
        "index": {
          "description": "Integrate with initial value zero However the first emitted value is the value of the input signal It maintains the length of the signal",
          "hierarchy": "Synthesizer State Filter Recursive Integration",
          "module": "Synthesizer.State.Filter.Recursive.Integration",
          "name": "run",
          "normalized": "T a-\u003eT a",
          "package": "synthesizer",
          "signature": "T v-\u003eT v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Filter-Recursive-Integration.html#v:run"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Integrate with initial condition.\nFirst emitted value is the initial condition.\nThe signal become one element longer.\n",
          "module": "Synthesizer.State.Filter.Recursive.Integration",
          "name": "runInit",
          "package": "synthesizer",
          "signature": "v -\u003e T v -\u003e T v",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Filter-Recursive-Integration.html#runInit",
          "type": "function"
        },
        "index": {
          "description": "Integrate with initial condition First emitted value is the initial condition The signal become one element longer",
          "hierarchy": "Synthesizer State Filter Recursive Integration",
          "module": "Synthesizer.State.Filter.Recursive.Integration",
          "name": "runInit",
          "normalized": "a-\u003eT a-\u003eT a",
          "package": "synthesizer",
          "partial": "Init",
          "signature": "v-\u003eT v-\u003eT v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Filter-Recursive-Integration.html#v:runInit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.State.Filter.Recursive.MovingAverage",
          "name": "modulatedFrac",
          "package": "synthesizer",
          "signature": "Int -\u003e T a -\u003e T v -\u003e T v",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Filter-Recursive-MovingAverage.html#modulatedFrac",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer State Filter Recursive MovingAverage",
          "module": "Synthesizer.State.Filter.Recursive.MovingAverage",
          "name": "modulatedFrac",
          "normalized": "Int-\u003eT a-\u003eT b-\u003eT b",
          "package": "synthesizer",
          "partial": "Frac",
          "signature": "Int-\u003eT a-\u003eT v-\u003eT v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Filter-Recursive-MovingAverage.html#v:modulatedFrac"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLike Synthesizer.State.Filter.NonRecursive.sums but in a recursive form.\nThis needs only linear time (independent of the window size)\nbut may accumulate rounding errors.\n\u003c/p\u003e\u003cpre\u003e\nys = xs * (1,0,0,0,-1) / (1,-1)\nys * (1,-1) = xs * (1,0,0,0,-1)\nys = xs * (1,0,0,0,-1) + ys * (0,1)\n\u003c/pre\u003e",
          "module": "Synthesizer.State.Filter.Recursive.MovingAverage",
          "name": "sumsStaticInt",
          "package": "synthesizer",
          "signature": "Int -\u003e T v -\u003e T v",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Filter-Recursive-MovingAverage.html#sumsStaticInt",
          "type": "function"
        },
        "index": {
          "description": "Like Synthesizer.State.Filter.NonRecursive.sums but in recursive form This needs only linear time independent of the window size but may accumulate rounding errors ys xs ys xs ys xs ys",
          "hierarchy": "Synthesizer State Filter Recursive MovingAverage",
          "module": "Synthesizer.State.Filter.Recursive.MovingAverage",
          "name": "sumsStaticInt",
          "normalized": "Int-\u003eT a-\u003eT a",
          "package": "synthesizer",
          "partial": "Static Int",
          "signature": "Int-\u003eT v-\u003eT v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Filter-Recursive-MovingAverage.html#v:sumsStaticInt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.State.Interpolation",
          "name": "constantPad",
          "package": "synthesizer",
          "signature": "(T t y -\u003e t -\u003e T y -\u003e a) -\u003e T t y -\u003e t -\u003e T y -\u003e a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Interpolation.html#constantPad",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer State Interpolation",
          "module": "Synthesizer.State.Interpolation",
          "name": "constantPad",
          "normalized": "(T a b-\u003ea-\u003eT b-\u003ec)-\u003eT a b-\u003ea-\u003eT b-\u003ec",
          "package": "synthesizer",
          "partial": "Pad",
          "signature": "(T t y-\u003et-\u003eT y-\u003ea)-\u003eT t y-\u003et-\u003eT y-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Interpolation.html#v:constantPad"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Only for finite input signals.\n",
          "module": "Synthesizer.State.Interpolation",
          "name": "cyclicPad",
          "package": "synthesizer",
          "signature": "(T t y -\u003e t -\u003e T y -\u003e a) -\u003e T t y -\u003e t -\u003e T y -\u003e a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Interpolation.html#cyclicPad",
          "type": "function"
        },
        "index": {
          "description": "Only for finite input signals",
          "hierarchy": "Synthesizer State Interpolation",
          "module": "Synthesizer.State.Interpolation",
          "name": "cyclicPad",
          "normalized": "(T a b-\u003ea-\u003eT b-\u003ec)-\u003eT a b-\u003ea-\u003eT b-\u003ec",
          "package": "synthesizer",
          "partial": "Pad",
          "signature": "(T t y-\u003et-\u003eT y-\u003ea)-\u003eT t y-\u003et-\u003eT y-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Interpolation.html#v:cyclicPad"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.State.Interpolation",
          "name": "delayPad",
          "package": "synthesizer",
          "signature": "y -\u003e Int -\u003e T y -\u003e T y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Interpolation.html#delayPad",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer State Interpolation",
          "module": "Synthesizer.State.Interpolation",
          "name": "delayPad",
          "normalized": "a-\u003eInt-\u003eT a-\u003eT a",
          "package": "synthesizer",
          "partial": "Pad",
          "signature": "y-\u003eInt-\u003eT y-\u003eT y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Interpolation.html#v:delayPad"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "The extrapolation may miss some of the first and some of the last points\n",
          "module": "Synthesizer.State.Interpolation",
          "name": "extrapolationPad",
          "package": "synthesizer",
          "signature": "(T t y -\u003e t -\u003e T y -\u003e a) -\u003e T t y -\u003e t -\u003e T y -\u003e a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Interpolation.html#extrapolationPad",
          "type": "function"
        },
        "index": {
          "description": "The extrapolation may miss some of the first and some of the last points",
          "hierarchy": "Synthesizer State Interpolation",
          "module": "Synthesizer.State.Interpolation",
          "name": "extrapolationPad",
          "normalized": "(T a b-\u003ea-\u003eT b-\u003ec)-\u003eT a b-\u003ea-\u003eT b-\u003ec",
          "package": "synthesizer",
          "partial": "Pad",
          "signature": "(T t y-\u003et-\u003eT y-\u003ea)-\u003eT t y-\u003et-\u003eT y-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Interpolation.html#v:extrapolationPad"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.State.Interpolation",
          "name": "single",
          "package": "synthesizer",
          "signature": "T t y -\u003e t -\u003e T y -\u003e y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Interpolation.html#single",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer State Interpolation",
          "module": "Synthesizer.State.Interpolation",
          "name": "single",
          "normalized": "T a b-\u003ea-\u003eT b-\u003eb",
          "package": "synthesizer",
          "signature": "T t y-\u003et-\u003eT y-\u003ey",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Interpolation.html#v:single"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.State.Interpolation",
          "name": "skip",
          "package": "synthesizer",
          "signature": "T t y -\u003e (t, T y) -\u003e (t, T y)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Interpolation.html#skip",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer State Interpolation",
          "module": "Synthesizer.State.Interpolation",
          "name": "skip",
          "normalized": "T a b-\u003e(a,T b)-\u003e(a,T b)",
          "package": "synthesizer",
          "signature": "T t y-\u003e(t,T y)-\u003e(t,T y)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Interpolation.html#v:skip"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.State.Interpolation",
          "name": "zeroPad",
          "package": "synthesizer",
          "signature": "(T t y -\u003e t -\u003e T y -\u003e a) -\u003e y -\u003e T t y -\u003e t -\u003e T y -\u003e a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Interpolation.html#zeroPad",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer State Interpolation",
          "module": "Synthesizer.State.Interpolation",
          "name": "zeroPad",
          "normalized": "(T a b-\u003ea-\u003eT b-\u003ec)-\u003eb-\u003eT a b-\u003ea-\u003eT b-\u003ec",
          "package": "synthesizer",
          "partial": "Pad",
          "signature": "(T t y-\u003et-\u003eT y-\u003ea)-\u003ey-\u003eT t y-\u003et-\u003eT y-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Interpolation.html#v:zeroPad"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "simulate an moving sounding object\n   convert the way of the object through 3D space\n   into a delay and attenuation information,\n   sonicDelay is the reciprocal of the sonic velocity \n",
          "module": "Synthesizer.State.Miscellaneous",
          "name": "receive3Dsound",
          "package": "synthesizer",
          "signature": "a -\u003e a -\u003e v -\u003e T v -\u003e (T a, T a)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Miscellaneous.html#receive3Dsound",
          "type": "function"
        },
        "index": {
          "description": "simulate an moving sounding object convert the way of the object through space into delay and attenuation information sonicDelay is the reciprocal of the sonic velocity",
          "hierarchy": "Synthesizer State Miscellaneous",
          "module": "Synthesizer.State.Miscellaneous",
          "name": "receive3Dsound",
          "normalized": "a-\u003ea-\u003eb-\u003eT b-\u003e(T a,T a)",
          "package": "synthesizer",
          "partial": "Dsound",
          "signature": "a-\u003ea-\u003ev-\u003eT v-\u003e(T a,T a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Miscellaneous.html#v:receive3Dsound"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "momentary densities, \u003ctt\u003ep\u003c/tt\u003e means that there is about one peak\n                      in the time range of \u003ctt\u003e1/p\u003c/tt\u003e samples \nEvery occurence of \u003ctt\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/tt\u003e represents a peak. \n",
          "module": "Synthesizer.State.Noise",
          "name": "randomPeeks",
          "package": "synthesizer",
          "signature": "T y-\u003e T Bool",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Noise.html#randomPeeks",
          "type": "function"
        },
        "index": {
          "description": "momentary densities means that there is about one peak in the time range of samples Every occurence of True represents peak",
          "hierarchy": "Synthesizer State Noise",
          "module": "Synthesizer.State.Noise",
          "name": "randomPeeks",
          "normalized": "T a-\u003eT Bool",
          "package": "synthesizer",
          "partial": "Peeks",
          "signature": "T y-\u003eT Bool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Noise.html#v:randomPeeks"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.State.Noise",
          "name": "randomPeeksGen",
          "package": "synthesizer",
          "signature": "g -\u003e T y -\u003e T Bool",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Noise.html#randomPeeksGen",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer State Noise",
          "module": "Synthesizer.State.Noise",
          "name": "randomPeeksGen",
          "normalized": "a-\u003eT b-\u003eT Bool",
          "package": "synthesizer",
          "partial": "Peeks Gen",
          "signature": "g-\u003eT y-\u003eT Bool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Noise.html#v:randomPeeksGen"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.State.Noise",
          "name": "randomRs",
          "package": "synthesizer",
          "signature": "(y, y) -\u003e g -\u003e T y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Noise.html#randomRs",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer State Noise",
          "module": "Synthesizer.State.Noise",
          "name": "randomRs",
          "normalized": "(a,a)-\u003eb-\u003eT a",
          "package": "synthesizer",
          "partial": "Rs",
          "signature": "(y,y)-\u003eg-\u003eT y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Noise.html#v:randomRs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Deterministic white noise, uniformly distributed between -1 and 1.\nThat is, variance is 1/3.\n",
          "module": "Synthesizer.State.Noise",
          "name": "white",
          "package": "synthesizer",
          "signature": "T y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Noise.html#white",
          "type": "function"
        },
        "index": {
          "description": "Deterministic white noise uniformly distributed between and That is variance is",
          "hierarchy": "Synthesizer State Noise",
          "module": "Synthesizer.State.Noise",
          "name": "white",
          "package": "synthesizer",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Noise.html#v:white"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.State.Noise",
          "name": "whiteGen",
          "package": "synthesizer",
          "signature": "g -\u003e T y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Noise.html#whiteGen",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer State Noise",
          "module": "Synthesizer.State.Noise",
          "name": "whiteGen",
          "normalized": "a-\u003eT b",
          "package": "synthesizer",
          "partial": "Gen",
          "signature": "g-\u003eT y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Noise.html#v:whiteGen"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Approximates normal distribution with variance 1\nby a quadratic B-spline distribution.\n",
          "module": "Synthesizer.State.Noise",
          "name": "whiteQuadraticBSplineGen",
          "package": "synthesizer",
          "signature": "g -\u003e T y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Noise.html#whiteQuadraticBSplineGen",
          "type": "function"
        },
        "index": {
          "description": "Approximates normal distribution with variance by quadratic B-spline distribution",
          "hierarchy": "Synthesizer State Noise",
          "module": "Synthesizer.State.Noise",
          "name": "whiteQuadraticBSplineGen",
          "normalized": "a-\u003eT b",
          "package": "synthesizer",
          "partial": "Quadratic BSpline Gen",
          "signature": "g-\u003eT y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Noise.html#v:whiteQuadraticBSplineGen"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "momentary densities, \u003ctt\u003ep\u003c/tt\u003e means that there is about one peak\n                      in the time range of \u003ctt\u003e1/p\u003c/tt\u003e samples \nEvery occurence of \u003ctt\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/tt\u003e represents a peak. \n",
          "module": "Synthesizer.State.NoiseCustom",
          "name": "randomPeeks",
          "package": "synthesizer",
          "signature": "T y-\u003e T Bool",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-NoiseCustom.html#randomPeeks",
          "type": "function"
        },
        "index": {
          "description": "momentary densities means that there is about one peak in the time range of samples Every occurence of True represents peak",
          "hierarchy": "Synthesizer State NoiseCustom",
          "module": "Synthesizer.State.NoiseCustom",
          "name": "randomPeeks",
          "normalized": "T a-\u003eT Bool",
          "package": "synthesizer",
          "partial": "Peeks",
          "signature": "T y-\u003eT Bool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-NoiseCustom.html#v:randomPeeks"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.State.NoiseCustom",
          "name": "randomPeeksGen",
          "package": "synthesizer",
          "signature": "g -\u003e T y -\u003e T Bool",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-NoiseCustom.html#randomPeeksGen",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer State NoiseCustom",
          "module": "Synthesizer.State.NoiseCustom",
          "name": "randomPeeksGen",
          "normalized": "a-\u003eT b-\u003eT Bool",
          "package": "synthesizer",
          "partial": "Peeks Gen",
          "signature": "g-\u003eT y-\u003eT Bool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-NoiseCustom.html#v:randomPeeksGen"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.State.NoiseCustom",
          "name": "randomR",
          "package": "synthesizer",
          "signature": "(y, y) -\u003e g -\u003e (y, g)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-NoiseCustom.html#randomR",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer State NoiseCustom",
          "module": "Synthesizer.State.NoiseCustom",
          "name": "randomR",
          "normalized": "(a,a)-\u003eb-\u003e(a,b)",
          "package": "synthesizer",
          "signature": "(y,y)-\u003eg-\u003e(y,g)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-NoiseCustom.html#v:randomR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.State.NoiseCustom",
          "name": "randomRs",
          "package": "synthesizer",
          "signature": "(y, y) -\u003e g -\u003e T y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-NoiseCustom.html#randomRs",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer State NoiseCustom",
          "module": "Synthesizer.State.NoiseCustom",
          "name": "randomRs",
          "normalized": "(a,a)-\u003eb-\u003eT a",
          "package": "synthesizer",
          "partial": "Rs",
          "signature": "(y,y)-\u003eg-\u003eT y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-NoiseCustom.html#v:randomRs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Deterministic white noise, uniformly distributed between -1 and 1.\nThat is, variance is 1/3.\n",
          "module": "Synthesizer.State.NoiseCustom",
          "name": "white",
          "package": "synthesizer",
          "signature": "T y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-NoiseCustom.html#white",
          "type": "function"
        },
        "index": {
          "description": "Deterministic white noise uniformly distributed between and That is variance is",
          "hierarchy": "Synthesizer State NoiseCustom",
          "module": "Synthesizer.State.NoiseCustom",
          "name": "white",
          "package": "synthesizer",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-NoiseCustom.html#v:white"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.State.NoiseCustom",
          "name": "whiteGen",
          "package": "synthesizer",
          "signature": "g -\u003e T y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-NoiseCustom.html#whiteGen",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer State NoiseCustom",
          "module": "Synthesizer.State.NoiseCustom",
          "name": "whiteGen",
          "normalized": "a-\u003eT b",
          "package": "synthesizer",
          "partial": "Gen",
          "signature": "g-\u003eT y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-NoiseCustom.html#v:whiteGen"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Approximates normal distribution with variance 1\nby a quadratic B-spline distribution.\n",
          "module": "Synthesizer.State.NoiseCustom",
          "name": "whiteQuadraticBSplineGen",
          "package": "synthesizer",
          "signature": "g -\u003e T y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-NoiseCustom.html#whiteQuadraticBSplineGen",
          "type": "function"
        },
        "index": {
          "description": "Approximates normal distribution with variance by quadratic B-spline distribution",
          "hierarchy": "Synthesizer State NoiseCustom",
          "module": "Synthesizer.State.NoiseCustom",
          "name": "whiteQuadraticBSplineGen",
          "normalized": "a-\u003eT b",
          "package": "synthesizer",
          "partial": "Quadratic BSpline Gen",
          "signature": "g-\u003eT y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-NoiseCustom.html#v:whiteQuadraticBSplineGen"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "oscillator with modulated frequency \n",
          "module": "Synthesizer.State.Oscillator",
          "name": "freqMod",
          "package": "synthesizer",
          "signature": "T a b -\u003e T a -\u003e T a -\u003e T b",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Oscillator.html#freqMod",
          "type": "function"
        },
        "index": {
          "description": "oscillator with modulated frequency",
          "hierarchy": "Synthesizer State Oscillator",
          "module": "Synthesizer.State.Oscillator",
          "name": "freqMod",
          "normalized": "T a b-\u003eT a-\u003eT a-\u003eT b",
          "package": "synthesizer",
          "partial": "Mod",
          "signature": "T a b-\u003eT a-\u003eT a-\u003eT b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Oscillator.html#v:freqMod"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "oscillator with modulated frequency \n",
          "module": "Synthesizer.State.Oscillator",
          "name": "freqModAntiAlias",
          "package": "synthesizer",
          "signature": "T a b -\u003e T a -\u003e T a -\u003e T b",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Oscillator.html#freqModAntiAlias",
          "type": "function"
        },
        "index": {
          "description": "oscillator with modulated frequency",
          "hierarchy": "Synthesizer State Oscillator",
          "module": "Synthesizer.State.Oscillator",
          "name": "freqModAntiAlias",
          "normalized": "T a b-\u003eT a-\u003eT a-\u003eT b",
          "package": "synthesizer",
          "partial": "Mod Anti Alias",
          "signature": "T a b-\u003eT a-\u003eT a-\u003eT b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Oscillator.html#v:freqModAntiAlias"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "oscillator with a sampled waveform with modulated frequency\n     Should behave homogenously for different types of interpolation. \n",
          "module": "Synthesizer.State.Oscillator",
          "name": "freqModSample",
          "package": "synthesizer",
          "signature": "T a b -\u003e T b -\u003e T a -\u003e T a -\u003e T b",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Oscillator.html#freqModSample",
          "type": "function"
        },
        "index": {
          "description": "oscillator with sampled waveform with modulated frequency Should behave homogenously for different types of interpolation",
          "hierarchy": "Synthesizer State Oscillator",
          "module": "Synthesizer.State.Oscillator",
          "name": "freqModSample",
          "normalized": "T a b-\u003eT b-\u003eT a-\u003eT a-\u003eT b",
          "package": "synthesizer",
          "partial": "Mod Sample",
          "signature": "T a b-\u003eT b-\u003eT a-\u003eT a-\u003eT b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Oscillator.html#v:freqModSample"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "saw tooth oscillator with modulated frequency \n",
          "module": "Synthesizer.State.Oscillator",
          "name": "freqModSaw",
          "package": "synthesizer",
          "signature": "T a -\u003e T a -\u003e T a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Oscillator.html#freqModSaw",
          "type": "function"
        },
        "index": {
          "description": "saw tooth oscillator with modulated frequency",
          "hierarchy": "Synthesizer State Oscillator",
          "module": "Synthesizer.State.Oscillator",
          "name": "freqModSaw",
          "normalized": "T a-\u003eT a-\u003eT a",
          "package": "synthesizer",
          "partial": "Mod Saw",
          "signature": "T a-\u003eT a-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Oscillator.html#v:freqModSaw"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "sine oscillator with modulated frequency \n",
          "module": "Synthesizer.State.Oscillator",
          "name": "freqModSine",
          "package": "synthesizer",
          "signature": "T a -\u003e T a -\u003e T a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Oscillator.html#freqModSine",
          "type": "function"
        },
        "index": {
          "description": "sine oscillator with modulated frequency",
          "hierarchy": "Synthesizer State Oscillator",
          "module": "Synthesizer.State.Oscillator",
          "name": "freqModSine",
          "normalized": "T a-\u003eT a-\u003eT a",
          "package": "synthesizer",
          "partial": "Mod Sine",
          "signature": "T a-\u003eT a-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Oscillator.html#v:freqModSine"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "oscillator with both phase and frequency modulation \n",
          "module": "Synthesizer.State.Oscillator",
          "name": "phaseFreqMod",
          "package": "synthesizer",
          "signature": "T a b -\u003e T a -\u003e T a -\u003e T b",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Oscillator.html#phaseFreqMod",
          "type": "function"
        },
        "index": {
          "description": "oscillator with both phase and frequency modulation",
          "hierarchy": "Synthesizer State Oscillator",
          "module": "Synthesizer.State.Oscillator",
          "name": "phaseFreqMod",
          "normalized": "T a b-\u003eT a-\u003eT a-\u003eT b",
          "package": "synthesizer",
          "partial": "Freq Mod",
          "signature": "T a b-\u003eT a-\u003eT a-\u003eT b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Oscillator.html#v:phaseFreqMod"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "oscillator with modulated phase \n",
          "module": "Synthesizer.State.Oscillator",
          "name": "phaseMod",
          "package": "synthesizer",
          "signature": "T a b -\u003e a -\u003e T a -\u003e T b",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Oscillator.html#phaseMod",
          "type": "function"
        },
        "index": {
          "description": "oscillator with modulated phase",
          "hierarchy": "Synthesizer State Oscillator",
          "module": "Synthesizer.State.Oscillator",
          "name": "phaseMod",
          "normalized": "T a b-\u003ea-\u003eT a-\u003eT b",
          "package": "synthesizer",
          "partial": "Mod",
          "signature": "T a b-\u003ea-\u003eT a-\u003eT b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Oscillator.html#v:phaseMod"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "sine oscillator with modulated phase, useful for FM synthesis \n",
          "module": "Synthesizer.State.Oscillator",
          "name": "phaseModSine",
          "package": "synthesizer",
          "signature": "a -\u003e T a -\u003e T a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Oscillator.html#phaseModSine",
          "type": "function"
        },
        "index": {
          "description": "sine oscillator with modulated phase useful for FM synthesis",
          "hierarchy": "Synthesizer State Oscillator",
          "module": "Synthesizer.State.Oscillator",
          "name": "phaseModSine",
          "normalized": "a-\u003eT a-\u003eT a",
          "package": "synthesizer",
          "partial": "Mod Sine",
          "signature": "a-\u003eT a-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Oscillator.html#v:phaseModSine"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "oscillator with both shape and frequency modulation \n",
          "module": "Synthesizer.State.Oscillator",
          "name": "shapeFreqMod",
          "package": "synthesizer",
          "signature": "(c -\u003e T a b) -\u003e T a -\u003e T c -\u003e T a -\u003e T b",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Oscillator.html#shapeFreqMod",
          "type": "function"
        },
        "index": {
          "description": "oscillator with both shape and frequency modulation",
          "hierarchy": "Synthesizer State Oscillator",
          "module": "Synthesizer.State.Oscillator",
          "name": "shapeFreqMod",
          "normalized": "(a-\u003eT b c)-\u003eT b-\u003eT a-\u003eT b-\u003eT c",
          "package": "synthesizer",
          "partial": "Freq Mod",
          "signature": "(c-\u003eT a b)-\u003eT a-\u003eT c-\u003eT a-\u003eT b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Oscillator.html#v:shapeFreqMod"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.State.Oscillator",
          "name": "shapeFreqModFromSampledTone",
          "package": "synthesizer",
          "signature": "T a b -\u003e T a b -\u003e a -\u003e sig b -\u003e a -\u003e T a -\u003e T a -\u003e T a -\u003e T b",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Oscillator.html#shapeFreqModFromSampledTone",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer State Oscillator",
          "module": "Synthesizer.State.Oscillator",
          "name": "shapeFreqModFromSampledTone",
          "normalized": "T a b-\u003eT a b-\u003ea-\u003ec b-\u003ea-\u003eT a-\u003eT a-\u003eT a-\u003eT b",
          "package": "synthesizer",
          "partial": "Freq Mod From Sampled Tone",
          "signature": "T a b-\u003eT a b-\u003ea-\u003esig b-\u003ea-\u003eT a-\u003eT a-\u003eT a-\u003eT b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Oscillator.html#v:shapeFreqModFromSampledTone"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.State.Oscillator",
          "name": "shapeFreqModSample",
          "package": "synthesizer",
          "signature": "T c (T a b) -\u003e T (T a b) -\u003e c -\u003e T a -\u003e T c -\u003e T a -\u003e T b",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Oscillator.html#shapeFreqModSample",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer State Oscillator",
          "module": "Synthesizer.State.Oscillator",
          "name": "shapeFreqModSample",
          "normalized": "T a(T b c)-\u003eT(T b c)-\u003ea-\u003eT b-\u003eT a-\u003eT b-\u003eT c",
          "package": "synthesizer",
          "partial": "Freq Mod Sample",
          "signature": "T c(T a b)-\u003eT(T a b)-\u003ec-\u003eT a-\u003eT c-\u003eT a-\u003eT b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Oscillator.html#v:shapeFreqModSample"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "oscillator with modulated shape \n",
          "module": "Synthesizer.State.Oscillator",
          "name": "shapeMod",
          "package": "synthesizer",
          "signature": "(c -\u003e T a b) -\u003e T a -\u003e a -\u003e T c -\u003e T b",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Oscillator.html#shapeMod",
          "type": "function"
        },
        "index": {
          "description": "oscillator with modulated shape",
          "hierarchy": "Synthesizer State Oscillator",
          "module": "Synthesizer.State.Oscillator",
          "name": "shapeMod",
          "normalized": "(a-\u003eT b c)-\u003eT b-\u003eb-\u003eT a-\u003eT c",
          "package": "synthesizer",
          "partial": "Mod",
          "signature": "(c-\u003eT a b)-\u003eT a-\u003ea-\u003eT c-\u003eT b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Oscillator.html#v:shapeMod"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.State.Oscillator",
          "name": "shapePhaseFreqModFromSampledTone",
          "package": "synthesizer",
          "signature": "T a b -\u003e T a b -\u003e a -\u003e sig b -\u003e a -\u003e T a -\u003e T a -\u003e T a -\u003e T a -\u003e T b",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Oscillator.html#shapePhaseFreqModFromSampledTone",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer State Oscillator",
          "module": "Synthesizer.State.Oscillator",
          "name": "shapePhaseFreqModFromSampledTone",
          "normalized": "T a b-\u003eT a b-\u003ea-\u003ec b-\u003ea-\u003eT a-\u003eT a-\u003eT a-\u003eT a-\u003eT b",
          "package": "synthesizer",
          "partial": "Phase Freq Mod From Sampled Tone",
          "signature": "T a b-\u003eT a b-\u003ea-\u003esig b-\u003ea-\u003eT a-\u003eT a-\u003eT a-\u003eT a-\u003eT b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Oscillator.html#v:shapePhaseFreqModFromSampledTone"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Oscillator with constant frequency.\nIt causes aliasing effects for sharp waveforms and high frequencies.\n",
          "module": "Synthesizer.State.Oscillator",
          "name": "static",
          "package": "synthesizer",
          "signature": "T a b -\u003e T a -\u003e a -\u003e T b",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Oscillator.html#static",
          "type": "function"
        },
        "index": {
          "description": "Oscillator with constant frequency It causes aliasing effects for sharp waveforms and high frequencies",
          "hierarchy": "Synthesizer State Oscillator",
          "module": "Synthesizer.State.Oscillator",
          "name": "static",
          "normalized": "T a b-\u003eT a-\u003ea-\u003eT b",
          "package": "synthesizer",
          "signature": "T a b-\u003eT a-\u003ea-\u003eT b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Oscillator.html#v:static"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Oscillator with constant frequency\nthat suppresses aliasing effects using waveforms with controllable smoothness.\n",
          "module": "Synthesizer.State.Oscillator",
          "name": "staticAntiAlias",
          "package": "synthesizer",
          "signature": "T a b -\u003e T a -\u003e a -\u003e T b",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Oscillator.html#staticAntiAlias",
          "type": "function"
        },
        "index": {
          "description": "Oscillator with constant frequency that suppresses aliasing effects using waveforms with controllable smoothness",
          "hierarchy": "Synthesizer State Oscillator",
          "module": "Synthesizer.State.Oscillator",
          "name": "staticAntiAlias",
          "normalized": "T a b-\u003eT a-\u003ea-\u003eT b",
          "package": "synthesizer",
          "partial": "Anti Alias",
          "signature": "T a b-\u003eT a-\u003ea-\u003eT b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Oscillator.html#v:staticAntiAlias"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "oscillator with a sampled waveform with constant frequency\n     This essentially an interpolation with cyclic padding. \n",
          "module": "Synthesizer.State.Oscillator",
          "name": "staticSample",
          "package": "synthesizer",
          "signature": "T a b -\u003e T b -\u003e T a -\u003e a -\u003e T b",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Oscillator.html#staticSample",
          "type": "function"
        },
        "index": {
          "description": "oscillator with sampled waveform with constant frequency This essentially an interpolation with cyclic padding",
          "hierarchy": "Synthesizer State Oscillator",
          "module": "Synthesizer.State.Oscillator",
          "name": "staticSample",
          "normalized": "T a b-\u003eT b-\u003eT a-\u003ea-\u003eT b",
          "package": "synthesizer",
          "partial": "Sample",
          "signature": "T a b-\u003eT b-\u003eT a-\u003ea-\u003eT b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Oscillator.html#v:staticSample"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "saw tooth oscillator with modulated frequency \n",
          "module": "Synthesizer.State.Oscillator",
          "name": "staticSaw",
          "package": "synthesizer",
          "signature": "T a -\u003e a -\u003e T a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Oscillator.html#staticSaw",
          "type": "function"
        },
        "index": {
          "description": "saw tooth oscillator with modulated frequency",
          "hierarchy": "Synthesizer State Oscillator",
          "module": "Synthesizer.State.Oscillator",
          "name": "staticSaw",
          "normalized": "T a-\u003ea-\u003eT a",
          "package": "synthesizer",
          "partial": "Saw",
          "signature": "T a-\u003ea-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Oscillator.html#v:staticSaw"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "sine oscillator with static frequency \n",
          "module": "Synthesizer.State.Oscillator",
          "name": "staticSine",
          "package": "synthesizer",
          "signature": "T a -\u003e a -\u003e T a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Oscillator.html#staticSine",
          "type": "function"
        },
        "index": {
          "description": "sine oscillator with static frequency",
          "hierarchy": "Synthesizer State Oscillator",
          "module": "Synthesizer.State.Oscillator",
          "name": "staticSine",
          "normalized": "T a-\u003ea-\u003eT a",
          "package": "synthesizer",
          "partial": "Sine",
          "signature": "T a-\u003ea-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Oscillator.html#v:staticSine"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.State.Signal",
          "name": "T",
          "package": "synthesizer",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Signal.html#T",
          "type": "data"
        },
        "index": {
          "hierarchy": "Synthesizer State Signal",
          "module": "Synthesizer.State.Signal",
          "name": "T",
          "package": "synthesizer",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Signal.html#t:T"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.State.Signal",
          "name": "append",
          "package": "synthesizer",
          "signature": "T a -\u003e T a -\u003e T a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Signal.html#append",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer State Signal",
          "module": "Synthesizer.State.Signal",
          "name": "append",
          "normalized": "T a-\u003eT a-\u003eT a",
          "package": "synthesizer",
          "signature": "T a-\u003eT a-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Signal.html#v:append"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.State.Signal",
          "name": "appendStored",
          "package": "synthesizer",
          "signature": "T a -\u003e T a -\u003e T a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Signal.html#appendStored",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer State Signal",
          "module": "Synthesizer.State.Signal",
          "name": "appendStored",
          "normalized": "T a-\u003eT a-\u003eT a",
          "package": "synthesizer",
          "partial": "Stored",
          "signature": "T a-\u003eT a-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Signal.html#v:appendStored"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.State.Signal",
          "name": "appendStoredSize",
          "package": "synthesizer",
          "signature": "ChunkSize -\u003e T a -\u003e T a -\u003e T a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Signal.html#appendStoredSize",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer State Signal",
          "module": "Synthesizer.State.Signal",
          "name": "appendStoredSize",
          "normalized": "ChunkSize-\u003eT a-\u003eT a-\u003eT a",
          "package": "synthesizer",
          "partial": "Stored Size",
          "signature": "ChunkSize-\u003eT a-\u003eT a-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Signal.html#v:appendStoredSize"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "certainly inefficient because of frequent list deconstruction\n",
          "module": "Synthesizer.State.Signal",
          "name": "concat",
          "package": "synthesizer",
          "signature": "[T a] -\u003e T a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Signal.html#concat",
          "type": "function"
        },
        "index": {
          "description": "certainly inefficient because of frequent list deconstruction",
          "hierarchy": "Synthesizer State Signal",
          "module": "Synthesizer.State.Signal",
          "name": "concat",
          "normalized": "[T a]-\u003eT a",
          "package": "synthesizer",
          "signature": "[T a]-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Signal.html#v:concat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.State.Signal",
          "name": "concatStored",
          "package": "synthesizer",
          "signature": "[T a] -\u003e T a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Signal.html#concatStored",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer State Signal",
          "module": "Synthesizer.State.Signal",
          "name": "concatStored",
          "normalized": "[T a]-\u003eT a",
          "package": "synthesizer",
          "partial": "Stored",
          "signature": "[T a]-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Signal.html#v:concatStored"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.State.Signal",
          "name": "concatStoredSize",
          "package": "synthesizer",
          "signature": "ChunkSize -\u003e [T a] -\u003e T a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Signal.html#concatStoredSize",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer State Signal",
          "module": "Synthesizer.State.Signal",
          "name": "concatStoredSize",
          "normalized": "ChunkSize-\u003e[T a]-\u003eT a",
          "package": "synthesizer",
          "partial": "Stored Size",
          "signature": "ChunkSize-\u003e[T a]-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Signal.html#v:concatStoredSize"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "This is expensive and should not be used to construct lists iteratively!\n",
          "module": "Synthesizer.State.Signal",
          "name": "cons",
          "package": "synthesizer",
          "signature": "a -\u003e T a -\u003e T a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Signal.html#cons",
          "type": "function"
        },
        "index": {
          "description": "This is expensive and should not be used to construct lists iteratively",
          "hierarchy": "Synthesizer State Signal",
          "module": "Synthesizer.State.Signal",
          "name": "cons",
          "normalized": "a-\u003eT a-\u003eT a",
          "package": "synthesizer",
          "signature": "a-\u003eT a-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Signal.html#v:cons"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.State.Signal",
          "name": "crochetL",
          "package": "synthesizer",
          "signature": "(x -\u003e acc -\u003e Maybe (y, acc)) -\u003e acc -\u003e T x -\u003e T y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Signal.html#crochetL",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer State Signal",
          "module": "Synthesizer.State.Signal",
          "name": "crochetL",
          "normalized": "(a-\u003eb-\u003eMaybe(c,b))-\u003eb-\u003eT a-\u003eT c",
          "package": "synthesizer",
          "signature": "(x-\u003eacc-\u003eMaybe(y,acc))-\u003eacc-\u003eT x-\u003eT y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Signal.html#v:crochetL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.State.Signal",
          "name": "cycle",
          "package": "synthesizer",
          "signature": "T a -\u003e T a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Signal.html#cycle",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer State Signal",
          "module": "Synthesizer.State.Signal",
          "name": "cycle",
          "normalized": "T a-\u003eT a",
          "package": "synthesizer",
          "signature": "T a-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Signal.html#v:cycle"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.State.Signal",
          "name": "delay",
          "package": "synthesizer",
          "signature": "y -\u003e Int -\u003e T y -\u003e T y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Signal.html#delay",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer State Signal",
          "module": "Synthesizer.State.Signal",
          "name": "delay",
          "normalized": "a-\u003eInt-\u003eT a-\u003eT a",
          "package": "synthesizer",
          "signature": "y-\u003eInt-\u003eT y-\u003eT y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Signal.html#v:delay"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "This is a fusion friendly implementation of delay.\nHowever, in order to be a \u003ctt\u003e\u003ca\u003ecrochetL\u003c/a\u003e\u003c/tt\u003e\nthe output has the same length as the input,\nthat is, the last element is removed - at least for finite input.\n",
          "module": "Synthesizer.State.Signal",
          "name": "delay1",
          "package": "synthesizer",
          "signature": "a -\u003e T a -\u003e T a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Signal.html#delay1",
          "type": "function"
        },
        "index": {
          "description": "This is fusion friendly implementation of delay However in order to be crochetL the output has the same length as the input that is the last element is removed at least for finite input",
          "hierarchy": "Synthesizer State Signal",
          "module": "Synthesizer.State.Signal",
          "name": "delay1",
          "normalized": "a-\u003eT a-\u003eT a",
          "package": "synthesizer",
          "signature": "a-\u003eT a-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Signal.html#v:delay1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "processor that shall be run in a feedback loop\nprefix of the output, its length determines the delay\n",
          "module": "Synthesizer.State.Signal",
          "name": "delayLoop",
          "package": "synthesizer",
          "signature": "T y -\u003e T y-\u003e T y-\u003e T y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Signal.html#delayLoop",
          "type": "function"
        },
        "index": {
          "description": "processor that shall be run in feedback loop prefix of the output its length determines the delay",
          "hierarchy": "Synthesizer State Signal",
          "module": "Synthesizer.State.Signal",
          "name": "delayLoop",
          "normalized": "T a-\u003eT a-\u003eT a-\u003eT a",
          "package": "synthesizer",
          "partial": "Loop",
          "signature": "T y-\u003eT y-\u003eT y-\u003eT y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Signal.html#v:delayLoop"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "processor that shall be run in a feedback loop\ninput\noutput has the same length as the input\n",
          "module": "Synthesizer.State.Signal",
          "name": "delayLoopOverlap",
          "package": "synthesizer",
          "signature": "Int-\u003e T y -\u003e T y-\u003e T y-\u003e T y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Signal.html#delayLoopOverlap",
          "type": "function"
        },
        "index": {
          "description": "processor that shall be run in feedback loop input output has the same length as the input",
          "hierarchy": "Synthesizer State Signal",
          "module": "Synthesizer.State.Signal",
          "name": "delayLoopOverlap",
          "normalized": "Int-\u003eT a-\u003eT a-\u003eT a-\u003eT a",
          "package": "synthesizer",
          "partial": "Loop Overlap",
          "signature": "Int-\u003eT y-\u003eT y-\u003eT y-\u003eT y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Signal.html#v:delayLoopOverlap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.State.Signal",
          "name": "drop",
          "package": "synthesizer",
          "signature": "Int -\u003e T a -\u003e T a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Signal.html#drop",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer State Signal",
          "module": "Synthesizer.State.Signal",
          "name": "drop",
          "normalized": "Int-\u003eT a-\u003eT a",
          "package": "synthesizer",
          "signature": "Int-\u003eT a-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Signal.html#v:drop"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.State.Signal",
          "name": "dropMargin",
          "package": "synthesizer",
          "signature": "Int -\u003e Int -\u003e T a -\u003e T a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Signal.html#dropMargin",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer State Signal",
          "module": "Synthesizer.State.Signal",
          "name": "dropMargin",
          "normalized": "Int-\u003eInt-\u003eT a-\u003eT a",
          "package": "synthesizer",
          "partial": "Margin",
          "signature": "Int-\u003eInt-\u003eT a-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Signal.html#v:dropMargin"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "This implementation expects that looking ahead is cheap.\n",
          "module": "Synthesizer.State.Signal",
          "name": "dropMarginRem",
          "package": "synthesizer",
          "signature": "Int -\u003e Int -\u003e T a -\u003e (Int, T a)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Signal.html#dropMarginRem",
          "type": "function"
        },
        "index": {
          "description": "This implementation expects that looking ahead is cheap",
          "hierarchy": "Synthesizer State Signal",
          "module": "Synthesizer.State.Signal",
          "name": "dropMarginRem",
          "normalized": "Int-\u003eInt-\u003eT a-\u003e(Int,T a)",
          "package": "synthesizer",
          "partial": "Margin Rem",
          "signature": "Int-\u003eInt-\u003eT a-\u003e(Int,T a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Signal.html#v:dropMarginRem"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.State.Signal",
          "name": "dropMatch",
          "package": "synthesizer",
          "signature": "T b -\u003e T a -\u003e T a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Signal.html#dropMatch",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer State Signal",
          "module": "Synthesizer.State.Signal",
          "name": "dropMatch",
          "normalized": "T a-\u003eT b-\u003eT b",
          "package": "synthesizer",
          "partial": "Match",
          "signature": "T b-\u003eT a-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Signal.html#v:dropMatch"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.State.Signal",
          "name": "dropWhile",
          "package": "synthesizer",
          "signature": "(a -\u003e Bool) -\u003e T a -\u003e T a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Signal.html#dropWhile",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer State Signal",
          "module": "Synthesizer.State.Signal",
          "name": "dropWhile",
          "normalized": "(a-\u003eBool)-\u003eT a-\u003eT a",
          "package": "synthesizer",
          "partial": "While",
          "signature": "(a-\u003eBool)-\u003eT a-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Signal.html#v:dropWhile"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.State.Signal",
          "name": "empty",
          "package": "synthesizer",
          "signature": "T a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Signal.html#empty",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer State Signal",
          "module": "Synthesizer.State.Signal",
          "name": "empty",
          "package": "synthesizer",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Signal.html#v:empty"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "This implementation requires\nthat the input generator has to check repeatedly whether it is finished.\n",
          "module": "Synthesizer.State.Signal",
          "name": "extendConstant",
          "package": "synthesizer",
          "signature": "T a -\u003e T a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Signal.html#extendConstant",
          "type": "function"
        },
        "index": {
          "description": "This implementation requires that the input generator has to check repeatedly whether it is finished",
          "hierarchy": "Synthesizer State Signal",
          "module": "Synthesizer.State.Signal",
          "name": "extendConstant",
          "normalized": "T a-\u003eT a",
          "package": "synthesizer",
          "partial": "Constant",
          "signature": "T a-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Signal.html#v:extendConstant"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.State.Signal",
          "name": "foldL",
          "package": "synthesizer",
          "signature": "(acc -\u003e x -\u003e acc) -\u003e acc -\u003e T x -\u003e acc",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Signal.html#foldL",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer State Signal",
          "module": "Synthesizer.State.Signal",
          "name": "foldL",
          "normalized": "(a-\u003eb-\u003ea)-\u003ea-\u003eT b-\u003ea",
          "package": "synthesizer",
          "signature": "(acc-\u003ex-\u003eacc)-\u003eacc-\u003eT x-\u003eacc",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Signal.html#v:foldL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.State.Signal",
          "name": "foldL'",
          "package": "synthesizer",
          "signature": "(x -\u003e acc -\u003e acc) -\u003e acc -\u003e T x -\u003e acc",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Signal.html#foldL%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer State Signal",
          "module": "Synthesizer.State.Signal",
          "name": "foldL'",
          "normalized": "(a-\u003eb-\u003eb)-\u003eb-\u003eT a-\u003eb",
          "package": "synthesizer",
          "partial": "L'",
          "signature": "(x-\u003eacc-\u003eacc)-\u003eacc-\u003eT x-\u003eacc",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Signal.html#v:foldL'"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.State.Signal",
          "name": "foldR",
          "package": "synthesizer",
          "signature": "(x -\u003e acc -\u003e acc) -\u003e acc -\u003e T x -\u003e acc",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Signal.html#foldR",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer State Signal",
          "module": "Synthesizer.State.Signal",
          "name": "foldR",
          "normalized": "(a-\u003eb-\u003eb)-\u003eb-\u003eT a-\u003eb",
          "package": "synthesizer",
          "signature": "(x-\u003eacc-\u003eacc)-\u003eacc-\u003eT x-\u003eacc",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Signal.html#v:foldR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.State.Signal",
          "name": "fromList",
          "package": "synthesizer",
          "signature": "[y] -\u003e T y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Signal.html#fromList",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer State Signal",
          "module": "Synthesizer.State.Signal",
          "name": "fromList",
          "normalized": "[a]-\u003eT a",
          "package": "synthesizer",
          "partial": "List",
          "signature": "[y]-\u003eT y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Signal.html#v:fromList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.State.Signal",
          "name": "fromStorableSignal",
          "package": "synthesizer",
          "signature": "T a -\u003e T a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Signal.html#fromStorableSignal",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer State Signal",
          "module": "Synthesizer.State.Signal",
          "name": "fromStorableSignal",
          "normalized": "T a-\u003eT a",
          "package": "synthesizer",
          "partial": "Storable Signal",
          "signature": "T a-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Signal.html#v:fromStorableSignal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.State.Signal",
          "name": "generate",
          "package": "synthesizer",
          "signature": "(acc -\u003e Maybe (y, acc)) -\u003e acc -\u003e T y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Signal.html#generate",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer State Signal",
          "module": "Synthesizer.State.Signal",
          "name": "generate",
          "normalized": "(a-\u003eMaybe(b,a))-\u003ea-\u003eT b",
          "package": "synthesizer",
          "signature": "(acc-\u003eMaybe(y,acc))-\u003eacc-\u003eT y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Signal.html#v:generate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.State.Signal",
          "name": "generateInfinite",
          "package": "synthesizer",
          "signature": "(acc -\u003e (y, acc)) -\u003e acc -\u003e T y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Signal.html#generateInfinite",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer State Signal",
          "module": "Synthesizer.State.Signal",
          "name": "generateInfinite",
          "normalized": "(a-\u003e(b,a))-\u003ea-\u003eT b",
          "package": "synthesizer",
          "partial": "Infinite",
          "signature": "(acc-\u003e(y,acc))-\u003eacc-\u003eT y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Signal.html#v:generateInfinite"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.State.Signal",
          "name": "index",
          "package": "synthesizer",
          "signature": "Int -\u003e T a -\u003e a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Signal.html#index",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer State Signal",
          "module": "Synthesizer.State.Signal",
          "name": "index",
          "normalized": "Int-\u003eT a-\u003ea",
          "package": "synthesizer",
          "signature": "Int-\u003eT a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Signal.html#v:index"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.State.Signal",
          "name": "init",
          "package": "synthesizer",
          "signature": "T y -\u003e T y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Signal.html#init",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer State Signal",
          "module": "Synthesizer.State.Signal",
          "name": "init",
          "normalized": "T a-\u003eT a",
          "package": "synthesizer",
          "signature": "T y-\u003eT y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Signal.html#v:init"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.State.Signal",
          "name": "iterate",
          "package": "synthesizer",
          "signature": "(a -\u003e a) -\u003e a -\u003e T a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Signal.html#iterate",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer State Signal",
          "module": "Synthesizer.State.Signal",
          "name": "iterate",
          "normalized": "(a-\u003ea)-\u003ea-\u003eT a",
          "package": "synthesizer",
          "signature": "(a-\u003ea)-\u003ea-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Signal.html#v:iterate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.State.Signal",
          "name": "iterateAssociative",
          "package": "synthesizer",
          "signature": "(a -\u003e a -\u003e a) -\u003e a -\u003e T a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Signal.html#iterateAssociative",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer State Signal",
          "module": "Synthesizer.State.Signal",
          "name": "iterateAssociative",
          "normalized": "(a-\u003ea-\u003ea)-\u003ea-\u003eT a",
          "package": "synthesizer",
          "partial": "Associative",
          "signature": "(a-\u003ea-\u003ea)-\u003ea-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Signal.html#v:iterateAssociative"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.State.Signal",
          "name": "length",
          "package": "synthesizer",
          "signature": "T a -\u003e Int",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Signal.html#length",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer State Signal",
          "module": "Synthesizer.State.Signal",
          "name": "length",
          "normalized": "T a-\u003eInt",
          "package": "synthesizer",
          "signature": "T a-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Signal.html#v:length"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.State.Signal",
          "name": "linearComb",
          "package": "synthesizer",
          "signature": "T t -\u003e T y -\u003e y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Signal.html#linearComb",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer State Signal",
          "module": "Synthesizer.State.Signal",
          "name": "linearComb",
          "normalized": "T a-\u003eT b-\u003eb",
          "package": "synthesizer",
          "partial": "Comb",
          "signature": "T t-\u003eT y-\u003ey",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Signal.html#v:linearComb"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.State.Signal",
          "name": "map",
          "package": "synthesizer",
          "signature": "(a -\u003e b) -\u003e T a -\u003e T b",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Signal.html#map",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer State Signal",
          "module": "Synthesizer.State.Signal",
          "name": "map",
          "normalized": "(a-\u003eb)-\u003eT a-\u003eT b",
          "package": "synthesizer",
          "signature": "(a-\u003eb)-\u003eT a-\u003eT b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Signal.html#v:map"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.State.Signal",
          "name": "mapM_",
          "package": "synthesizer",
          "signature": "(a -\u003e m ()) -\u003e T a -\u003e m ()",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Signal.html#mapM_",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer State Signal",
          "module": "Synthesizer.State.Signal",
          "name": "mapM_",
          "normalized": "(a-\u003eb())-\u003eT a-\u003eb()",
          "package": "synthesizer",
          "signature": "(a-\u003em())-\u003eT a-\u003em()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Signal.html#v:mapM_"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.State.Signal",
          "name": "mapTails",
          "package": "synthesizer",
          "signature": "(T y0 -\u003e y1) -\u003e T y0 -\u003e T y1",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Signal.html#mapTails",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer State Signal",
          "module": "Synthesizer.State.Signal",
          "name": "mapTails",
          "normalized": "(T a-\u003ea)-\u003eT a-\u003eT a",
          "package": "synthesizer",
          "partial": "Tails",
          "signature": "(T y-\u003ey)-\u003eT y-\u003eT y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Signal.html#v:mapTails"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.State.Signal",
          "name": "maximum",
          "package": "synthesizer",
          "signature": "T a -\u003e a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Signal.html#maximum",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer State Signal",
          "module": "Synthesizer.State.Signal",
          "name": "maximum",
          "normalized": "T a-\u003ea",
          "package": "synthesizer",
          "signature": "T a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Signal.html#v:maximum"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.State.Signal",
          "name": "mix",
          "package": "synthesizer",
          "signature": "T a -\u003e T a -\u003e T a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Signal.html#mix",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer State Signal",
          "module": "Synthesizer.State.Signal",
          "name": "mix",
          "normalized": "T a-\u003eT a-\u003eT a",
          "package": "synthesizer",
          "signature": "T a-\u003eT a-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Signal.html#v:mix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Here the control may vary over the time. \n",
          "module": "Synthesizer.State.Signal",
          "name": "modifyModulated",
          "package": "synthesizer",
          "signature": "Simple s ctrl a b -\u003e T ctrl -\u003e T a -\u003e T b",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Signal.html#modifyModulated",
          "type": "function"
        },
        "index": {
          "description": "Here the control may vary over the time",
          "hierarchy": "Synthesizer State Signal",
          "module": "Synthesizer.State.Signal",
          "name": "modifyModulated",
          "normalized": "Simple a b c d-\u003eT b-\u003eT c-\u003eT d",
          "package": "synthesizer",
          "partial": "Modulated",
          "signature": "Simple s ctrl a b-\u003eT ctrl-\u003eT a-\u003eT b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Signal.html#v:modifyModulated"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.State.Signal",
          "name": "modifyStatic",
          "package": "synthesizer",
          "signature": "Simple s ctrl a b -\u003e ctrl -\u003e T a -\u003e T b",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Signal.html#modifyStatic",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer State Signal",
          "module": "Synthesizer.State.Signal",
          "name": "modifyStatic",
          "normalized": "Simple a b c d-\u003eb-\u003eT c-\u003eT d",
          "package": "synthesizer",
          "partial": "Static",
          "signature": "Simple s ctrl a b-\u003ectrl-\u003eT a-\u003eT b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Signal.html#v:modifyStatic"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Counterpart to Data.Monoid.mconcat.\n",
          "module": "Synthesizer.State.Signal",
          "name": "monoidConcat",
          "package": "synthesizer",
          "signature": "T m -\u003e m",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Signal.html#monoidConcat",
          "type": "function"
        },
        "index": {
          "description": "Counterpart to Data.Monoid.mconcat",
          "hierarchy": "Synthesizer State Signal",
          "module": "Synthesizer.State.Signal",
          "name": "monoidConcat",
          "normalized": "T a-\u003ea",
          "package": "synthesizer",
          "partial": "Concat",
          "signature": "T m-\u003em",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Signal.html#v:monoidConcat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.State.Signal",
          "name": "monoidConcatMap",
          "package": "synthesizer",
          "signature": "(a -\u003e m) -\u003e T a -\u003e m",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Signal.html#monoidConcatMap",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer State Signal",
          "module": "Synthesizer.State.Signal",
          "name": "monoidConcatMap",
          "normalized": "(a-\u003eb)-\u003eT a-\u003eb",
          "package": "synthesizer",
          "partial": "Concat Map",
          "signature": "(a-\u003em)-\u003eT a-\u003em",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Signal.html#v:monoidConcatMap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.State.Signal",
          "name": "neg",
          "package": "synthesizer",
          "signature": "T a -\u003e T a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Signal.html#neg",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer State Signal",
          "module": "Synthesizer.State.Signal",
          "name": "neg",
          "normalized": "T a-\u003eT a",
          "package": "synthesizer",
          "signature": "T a-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Signal.html#v:neg"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.State.Signal",
          "name": "null",
          "package": "synthesizer",
          "signature": "T a -\u003e Bool",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Signal.html#null",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer State Signal",
          "module": "Synthesizer.State.Signal",
          "name": "null",
          "normalized": "T a-\u003eBool",
          "package": "synthesizer",
          "signature": "T a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Signal.html#v:null"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.State.Signal",
          "name": "repeat",
          "package": "synthesizer",
          "signature": "a -\u003e T a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Signal.html#repeat",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer State Signal",
          "module": "Synthesizer.State.Signal",
          "name": "repeat",
          "normalized": "a-\u003eT a",
          "package": "synthesizer",
          "signature": "a-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Signal.html#v:repeat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.State.Signal",
          "name": "replicate",
          "package": "synthesizer",
          "signature": "Int -\u003e a -\u003e T a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Signal.html#replicate",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer State Signal",
          "module": "Synthesizer.State.Signal",
          "name": "replicate",
          "normalized": "Int-\u003ea-\u003eT a",
          "package": "synthesizer",
          "signature": "Int-\u003ea-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Signal.html#v:replicate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.State.Signal",
          "name": "reverse",
          "package": "synthesizer",
          "signature": "T a -\u003e T a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Signal.html#reverse",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer State Signal",
          "module": "Synthesizer.State.Signal",
          "name": "reverse",
          "normalized": "T a-\u003eT a",
          "package": "synthesizer",
          "signature": "T a-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Signal.html#v:reverse"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.State.Signal",
          "name": "reverseStored",
          "package": "synthesizer",
          "signature": "T a -\u003e T a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Signal.html#reverseStored",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer State Signal",
          "module": "Synthesizer.State.Signal",
          "name": "reverseStored",
          "normalized": "T a-\u003eT a",
          "package": "synthesizer",
          "partial": "Stored",
          "signature": "T a-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Signal.html#v:reverseStored"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.State.Signal",
          "name": "reverseStoredSize",
          "package": "synthesizer",
          "signature": "ChunkSize -\u003e T a -\u003e T a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Signal.html#reverseStoredSize",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer State Signal",
          "module": "Synthesizer.State.Signal",
          "name": "reverseStoredSize",
          "normalized": "ChunkSize-\u003eT a-\u003eT a",
          "package": "synthesizer",
          "partial": "Stored Size",
          "signature": "ChunkSize-\u003eT a-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Signal.html#v:reverseStoredSize"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.State.Signal",
          "name": "scanL",
          "package": "synthesizer",
          "signature": "(acc -\u003e x -\u003e acc) -\u003e acc -\u003e T x -\u003e T acc",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Signal.html#scanL",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer State Signal",
          "module": "Synthesizer.State.Signal",
          "name": "scanL",
          "normalized": "(a-\u003eb-\u003ea)-\u003ea-\u003eT b-\u003eT a",
          "package": "synthesizer",
          "signature": "(acc-\u003ex-\u003eacc)-\u003eacc-\u003eT x-\u003eT acc",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Signal.html#v:scanL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "input and output have equal length, that's better for fusion\n",
          "module": "Synthesizer.State.Signal",
          "name": "scanLClip",
          "package": "synthesizer",
          "signature": "(acc -\u003e x -\u003e acc) -\u003e acc -\u003e T x -\u003e T acc",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Signal.html#scanLClip",
          "type": "function"
        },
        "index": {
          "description": "input and output have equal length that better for fusion",
          "hierarchy": "Synthesizer State Signal",
          "module": "Synthesizer.State.Signal",
          "name": "scanLClip",
          "normalized": "(a-\u003eb-\u003ea)-\u003ea-\u003eT b-\u003eT a",
          "package": "synthesizer",
          "partial": "LClip",
          "signature": "(acc-\u003ex-\u003eacc)-\u003eacc-\u003eT x-\u003eT acc",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Signal.html#v:scanLClip"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.State.Signal",
          "name": "sequence_",
          "package": "synthesizer",
          "signature": "T (m a) -\u003e m ()",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Signal.html#sequence_",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer State Signal",
          "module": "Synthesizer.State.Signal",
          "name": "sequence_",
          "normalized": "T(a b)-\u003ea()",
          "package": "synthesizer",
          "signature": "T(m a)-\u003em()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Signal.html#v:sequence_"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.State.Signal",
          "name": "singleton",
          "package": "synthesizer",
          "signature": "a -\u003e T a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Signal.html#singleton",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer State Signal",
          "module": "Synthesizer.State.Signal",
          "name": "singleton",
          "normalized": "a-\u003eT a",
          "package": "synthesizer",
          "signature": "a-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Signal.html#v:singleton"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.State.Signal",
          "name": "sliceVert",
          "package": "synthesizer",
          "signature": "Int -\u003e T y -\u003e [T y]",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Signal.html#sliceVert",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer State Signal",
          "module": "Synthesizer.State.Signal",
          "name": "sliceVert",
          "normalized": "Int-\u003eT a-\u003e[T a]",
          "package": "synthesizer",
          "partial": "Vert",
          "signature": "Int-\u003eT y-\u003e[T y]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Signal.html#v:sliceVert"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.State.Signal",
          "name": "span",
          "package": "synthesizer",
          "signature": "(a -\u003e Bool) -\u003e T a -\u003e (T a, T a)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Signal.html#span",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer State Signal",
          "module": "Synthesizer.State.Signal",
          "name": "span",
          "normalized": "(a-\u003eBool)-\u003eT a-\u003e(T a,T a)",
          "package": "synthesizer",
          "signature": "(a-\u003eBool)-\u003eT a-\u003e(T a,T a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Signal.html#v:span"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.State.Signal",
          "name": "spanSize",
          "package": "synthesizer",
          "signature": "ChunkSize -\u003e (a -\u003e Bool) -\u003e T a -\u003e (T a, T a)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Signal.html#spanSize",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer State Signal",
          "module": "Synthesizer.State.Signal",
          "name": "spanSize",
          "normalized": "ChunkSize-\u003e(a-\u003eBool)-\u003eT a-\u003e(T a,T a)",
          "package": "synthesizer",
          "partial": "Size",
          "signature": "ChunkSize-\u003e(a-\u003eBool)-\u003eT a-\u003e(T a,T a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Signal.html#v:spanSize"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.State.Signal",
          "name": "splitAt",
          "package": "synthesizer",
          "signature": "Int -\u003e T a -\u003e (T a, T a)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Signal.html#splitAt",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer State Signal",
          "module": "Synthesizer.State.Signal",
          "name": "splitAt",
          "normalized": "Int-\u003eT a-\u003e(T a,T a)",
          "package": "synthesizer",
          "partial": "At",
          "signature": "Int-\u003eT a-\u003e(T a,T a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Signal.html#v:splitAt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.State.Signal",
          "name": "splitAtSize",
          "package": "synthesizer",
          "signature": "ChunkSize -\u003e Int -\u003e T a -\u003e (T a, T a)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Signal.html#splitAtSize",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer State Signal",
          "module": "Synthesizer.State.Signal",
          "name": "splitAtSize",
          "normalized": "ChunkSize-\u003eInt-\u003eT a-\u003e(T a,T a)",
          "package": "synthesizer",
          "partial": "At Size",
          "signature": "ChunkSize-\u003eInt-\u003eT a-\u003e(T a,T a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Signal.html#v:splitAtSize"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.State.Signal",
          "name": "sub",
          "package": "synthesizer",
          "signature": "T a -\u003e T a -\u003e T a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Signal.html#sub",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer State Signal",
          "module": "Synthesizer.State.Signal",
          "name": "sub",
          "normalized": "T a-\u003eT a-\u003eT a",
          "package": "synthesizer",
          "signature": "T a-\u003eT a-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Signal.html#v:sub"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.State.Signal",
          "name": "sum",
          "package": "synthesizer",
          "signature": "T a -\u003e a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Signal.html#sum",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer State Signal",
          "module": "Synthesizer.State.Signal",
          "name": "sum",
          "normalized": "T a-\u003ea",
          "package": "synthesizer",
          "signature": "T a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Signal.html#v:sum"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.State.Signal",
          "name": "switchL",
          "package": "synthesizer",
          "signature": "b -\u003e (a -\u003e T a -\u003e b) -\u003e T a -\u003e b",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Signal.html#switchL",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer State Signal",
          "module": "Synthesizer.State.Signal",
          "name": "switchL",
          "normalized": "a-\u003e(b-\u003eT b-\u003ea)-\u003eT b-\u003ea",
          "package": "synthesizer",
          "signature": "b-\u003e(a-\u003eT a-\u003eb)-\u003eT a-\u003eb",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Signal.html#v:switchL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.State.Signal",
          "name": "switchR",
          "package": "synthesizer",
          "signature": "b -\u003e (T a -\u003e a -\u003e b) -\u003e T a -\u003e b",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Signal.html#switchR",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer State Signal",
          "module": "Synthesizer.State.Signal",
          "name": "switchR",
          "normalized": "a-\u003e(T b-\u003eb-\u003ea)-\u003eT b-\u003ea",
          "package": "synthesizer",
          "signature": "b-\u003e(T a-\u003ea-\u003eb)-\u003eT a-\u003eb",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Signal.html#v:switchR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.State.Signal",
          "name": "take",
          "package": "synthesizer",
          "signature": "Int -\u003e T a -\u003e T a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Signal.html#take",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer State Signal",
          "module": "Synthesizer.State.Signal",
          "name": "take",
          "normalized": "Int-\u003eT a-\u003eT a",
          "package": "synthesizer",
          "signature": "Int-\u003eT a-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Signal.html#v:take"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.State.Signal",
          "name": "takeWhile",
          "package": "synthesizer",
          "signature": "(a -\u003e Bool) -\u003e T a -\u003e T a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Signal.html#takeWhile",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer State Signal",
          "module": "Synthesizer.State.Signal",
          "name": "takeWhile",
          "normalized": "(a-\u003eBool)-\u003eT a-\u003eT a",
          "package": "synthesizer",
          "partial": "While",
          "signature": "(a-\u003eBool)-\u003eT a-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Signal.html#v:takeWhile"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.State.Signal",
          "name": "toList",
          "package": "synthesizer",
          "signature": "T y -\u003e [y]",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Signal.html#toList",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer State Signal",
          "module": "Synthesizer.State.Signal",
          "name": "toList",
          "normalized": "T a-\u003e[a]",
          "package": "synthesizer",
          "partial": "List",
          "signature": "T y-\u003e[y]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Signal.html#v:toList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.State.Signal",
          "name": "toStorableSignal",
          "package": "synthesizer",
          "signature": "ChunkSize -\u003e T a -\u003e T a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Signal.html#toStorableSignal",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer State Signal",
          "module": "Synthesizer.State.Signal",
          "name": "toStorableSignal",
          "normalized": "ChunkSize-\u003eT a-\u003eT a",
          "package": "synthesizer",
          "partial": "Storable Signal",
          "signature": "ChunkSize-\u003eT a-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Signal.html#v:toStorableSignal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.State.Signal",
          "name": "toStorableSignalVary",
          "package": "synthesizer",
          "signature": "LazySize -\u003e T a -\u003e T a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Signal.html#toStorableSignalVary",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer State Signal",
          "module": "Synthesizer.State.Signal",
          "name": "toStorableSignalVary",
          "normalized": "LazySize-\u003eT a-\u003eT a",
          "package": "synthesizer",
          "partial": "Storable Signal Vary",
          "signature": "LazySize-\u003eT a-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Signal.html#v:toStorableSignalVary"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.State.Signal",
          "name": "unfoldR",
          "package": "synthesizer",
          "signature": "(acc -\u003e Maybe (y, acc)) -\u003e acc -\u003e T y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Signal.html#unfoldR",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer State Signal",
          "module": "Synthesizer.State.Signal",
          "name": "unfoldR",
          "normalized": "(a-\u003eMaybe(b,a))-\u003ea-\u003eT b",
          "package": "synthesizer",
          "signature": "(acc-\u003eMaybe(y,acc))-\u003eacc-\u003eT y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Signal.html#v:unfoldR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "This function will recompute the input lists\nand is thus probably not what you want.\nIf you want to avoid recomputation please consider Causal.Process.\n",
          "module": "Synthesizer.State.Signal",
          "name": "unzip",
          "package": "synthesizer",
          "signature": "T (a, b) -\u003e (T a, T b)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Signal.html#unzip",
          "type": "function"
        },
        "index": {
          "description": "This function will recompute the input lists and is thus probably not what you want If you want to avoid recomputation please consider Causal.Process",
          "hierarchy": "Synthesizer State Signal",
          "module": "Synthesizer.State.Signal",
          "name": "unzip",
          "normalized": "T(a,b)-\u003e(T a,T b)",
          "package": "synthesizer",
          "signature": "T(a,b)-\u003e(T a,T b)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Signal.html#v:unzip"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.State.Signal",
          "name": "unzip3",
          "package": "synthesizer",
          "signature": "T (a, b, c) -\u003e (T a, T b, T c)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Signal.html#unzip3",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer State Signal",
          "module": "Synthesizer.State.Signal",
          "name": "unzip3",
          "normalized": "T(a,b,c)-\u003e(T a,T b,T c)",
          "package": "synthesizer",
          "signature": "T(a,b,c)-\u003e(T a,T b,T c)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Signal.html#v:unzip3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.State.Signal",
          "name": "viewL",
          "package": "synthesizer",
          "signature": "T a -\u003e Maybe (a, T a)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Signal.html#viewL",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer State Signal",
          "module": "Synthesizer.State.Signal",
          "name": "viewL",
          "normalized": "T a-\u003eMaybe(a,T a)",
          "package": "synthesizer",
          "signature": "T a-\u003eMaybe(a,T a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Signal.html#v:viewL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.State.Signal",
          "name": "viewR",
          "package": "synthesizer",
          "signature": "T a -\u003e Maybe (T a, a)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Signal.html#viewR",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer State Signal",
          "module": "Synthesizer.State.Signal",
          "name": "viewR",
          "normalized": "T a-\u003eMaybe(T a,a)",
          "package": "synthesizer",
          "signature": "T a-\u003eMaybe(T a,a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Signal.html#v:viewR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.State.Signal",
          "name": "viewRSize",
          "package": "synthesizer",
          "signature": "ChunkSize -\u003e T a -\u003e Maybe (T a, a)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Signal.html#viewRSize",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer State Signal",
          "module": "Synthesizer.State.Signal",
          "name": "viewRSize",
          "normalized": "ChunkSize-\u003eT a-\u003eMaybe(T a,a)",
          "package": "synthesizer",
          "partial": "RSize",
          "signature": "ChunkSize-\u003eT a-\u003eMaybe(T a,a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Signal.html#v:viewRSize"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.State.Signal",
          "name": "zapWith",
          "package": "synthesizer",
          "signature": "(a -\u003e a -\u003e b) -\u003e T a -\u003e T b",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Signal.html#zapWith",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer State Signal",
          "module": "Synthesizer.State.Signal",
          "name": "zapWith",
          "normalized": "(a-\u003ea-\u003eb)-\u003eT a-\u003eT b",
          "package": "synthesizer",
          "partial": "With",
          "signature": "(a-\u003ea-\u003eb)-\u003eT a-\u003eT b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Signal.html#v:zapWith"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.State.Signal",
          "name": "zapWithAlt",
          "package": "synthesizer",
          "signature": "(a -\u003e a -\u003e b) -\u003e T a -\u003e T b",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Signal.html#zapWithAlt",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer State Signal",
          "module": "Synthesizer.State.Signal",
          "name": "zapWithAlt",
          "normalized": "(a-\u003ea-\u003eb)-\u003eT a-\u003eT b",
          "package": "synthesizer",
          "partial": "With Alt",
          "signature": "(a-\u003ea-\u003eb)-\u003eT a-\u003eT b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Signal.html#v:zapWithAlt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.State.Signal",
          "name": "zip",
          "package": "synthesizer",
          "signature": "T a -\u003e T b -\u003e T (a, b)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Signal.html#zip",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer State Signal",
          "module": "Synthesizer.State.Signal",
          "name": "zip",
          "normalized": "T a-\u003eT b-\u003eT(a,b)",
          "package": "synthesizer",
          "signature": "T a-\u003eT b-\u003eT(a,b)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Signal.html#v:zip"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.State.Signal",
          "name": "zip3",
          "package": "synthesizer",
          "signature": "T a -\u003e T b -\u003e T c -\u003e T (a, b, c)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Signal.html#zip3",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer State Signal",
          "module": "Synthesizer.State.Signal",
          "name": "zip3",
          "normalized": "T a-\u003eT b-\u003eT c-\u003eT(a,b,c)",
          "package": "synthesizer",
          "signature": "T a-\u003eT b-\u003eT c-\u003eT(a,b,c)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Signal.html#v:zip3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.State.Signal",
          "name": "zip4",
          "package": "synthesizer",
          "signature": "T a -\u003e T b -\u003e T c -\u003e T d -\u003e T (a, b, c, d)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Signal.html#zip4",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer State Signal",
          "module": "Synthesizer.State.Signal",
          "name": "zip4",
          "normalized": "T a-\u003eT b-\u003eT c-\u003eT d-\u003eT(a,b,c,d)",
          "package": "synthesizer",
          "signature": "T a-\u003eT b-\u003eT c-\u003eT d-\u003eT(a,b,c,d)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Signal.html#v:zip4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.State.Signal",
          "name": "zipStep",
          "package": "synthesizer",
          "signature": "(a -\u003e a -\u003e a) -\u003e (T a, T a) -\u003e Maybe (a, (T a, T a))",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Signal.html#zipStep",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer State Signal",
          "module": "Synthesizer.State.Signal",
          "name": "zipStep",
          "normalized": "(a-\u003ea-\u003ea)-\u003e(T a,T a)-\u003eMaybe(a,(T a,T a))",
          "package": "synthesizer",
          "partial": "Step",
          "signature": "(a-\u003ea-\u003ea)-\u003e(T a,T a)-\u003eMaybe(a,(T a,T a))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Signal.html#v:zipStep"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.State.Signal",
          "name": "zipWith",
          "package": "synthesizer",
          "signature": "(a -\u003e b -\u003e c) -\u003e T a -\u003e T b -\u003e T c",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Signal.html#zipWith",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer State Signal",
          "module": "Synthesizer.State.Signal",
          "name": "zipWith",
          "normalized": "(a-\u003eb-\u003ec)-\u003eT a-\u003eT b-\u003eT c",
          "package": "synthesizer",
          "partial": "With",
          "signature": "(a-\u003eb-\u003ec)-\u003eT a-\u003eT b-\u003eT c",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Signal.html#v:zipWith"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.State.Signal",
          "name": "zipWith3",
          "package": "synthesizer",
          "signature": "(a -\u003e b -\u003e c -\u003e d) -\u003e T a -\u003e T b -\u003e T c -\u003e T d",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Signal.html#zipWith3",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer State Signal",
          "module": "Synthesizer.State.Signal",
          "name": "zipWith3",
          "normalized": "(a-\u003eb-\u003ec-\u003ed)-\u003eT a-\u003eT b-\u003eT c-\u003eT d",
          "package": "synthesizer",
          "partial": "With",
          "signature": "(a-\u003eb-\u003ec-\u003ed)-\u003eT a-\u003eT b-\u003eT c-\u003eT d",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Signal.html#v:zipWith3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.State.Signal",
          "name": "zipWith4",
          "package": "synthesizer",
          "signature": "(a -\u003e b -\u003e c -\u003e d -\u003e e) -\u003e T a -\u003e T b -\u003e T c -\u003e T d -\u003e T e",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Signal.html#zipWith4",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer State Signal",
          "module": "Synthesizer.State.Signal",
          "name": "zipWith4",
          "normalized": "(a-\u003eb-\u003ec-\u003ed-\u003ee)-\u003eT a-\u003eT b-\u003eT c-\u003eT d-\u003eT e",
          "package": "synthesizer",
          "partial": "With",
          "signature": "(a-\u003eb-\u003ec-\u003ed-\u003ee)-\u003eT a-\u003eT b-\u003eT c-\u003eT d-\u003eT e",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Signal.html#v:zipWith4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.State.Signal",
          "name": "zipWithAppend",
          "package": "synthesizer",
          "signature": "(y -\u003e y -\u003e y) -\u003e T y -\u003e T y -\u003e T y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Signal.html#zipWithAppend",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer State Signal",
          "module": "Synthesizer.State.Signal",
          "name": "zipWithAppend",
          "normalized": "(a-\u003ea-\u003ea)-\u003eT a-\u003eT a-\u003eT a",
          "package": "synthesizer",
          "partial": "With Append",
          "signature": "(y-\u003ey-\u003ey)-\u003eT y-\u003eT y-\u003eT y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Signal.html#v:zipWithAppend"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.State.Signal",
          "name": "zipWithStorable",
          "package": "synthesizer",
          "signature": "(a -\u003e b -\u003e c) -\u003e T a -\u003e T b -\u003e T c",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Signal.html#zipWithStorable",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer State Signal",
          "module": "Synthesizer.State.Signal",
          "name": "zipWithStorable",
          "normalized": "(a-\u003eb-\u003ec)-\u003eT a-\u003eT b-\u003eT c",
          "package": "synthesizer",
          "partial": "With Storable",
          "signature": "(a-\u003eb-\u003ec)-\u003eT a-\u003eT b-\u003eT c",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Signal.html#v:zipWithStorable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.State.Signal",
          "name": "zipWithTails",
          "package": "synthesizer",
          "signature": "(y0 -\u003e T y1 -\u003e y2) -\u003e T y0 -\u003e T y1 -\u003e T y2",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-Signal.html#zipWithTails",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer State Signal",
          "module": "Synthesizer.State.Signal",
          "name": "zipWithTails",
          "normalized": "(a-\u003eT a-\u003ea)-\u003eT a-\u003eT a-\u003eT a",
          "package": "synthesizer",
          "partial": "With Tails",
          "signature": "(y-\u003eT y-\u003ey)-\u003eT y-\u003eT y-\u003eT y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-Signal.html#v:zipWithTails"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.State.ToneModulation",
          "name": "Cell",
          "package": "synthesizer",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-ToneModulation.html#Cell",
          "type": "type"
        },
        "index": {
          "hierarchy": "Synthesizer State ToneModulation",
          "module": "Synthesizer.State.ToneModulation",
          "name": "Cell",
          "package": "synthesizer",
          "partial": "Cell",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-ToneModulation.html#t:Cell"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.State.ToneModulation",
          "name": "Prototype",
          "package": "synthesizer",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-ToneModulation.html#Prototype",
          "type": "data"
        },
        "index": {
          "hierarchy": "Synthesizer State ToneModulation",
          "module": "Synthesizer.State.ToneModulation",
          "name": "Prototype",
          "package": "synthesizer",
          "partial": "Prototype",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-ToneModulation.html#t:Prototype"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.State.ToneModulation",
          "name": "checkNonNeg",
          "package": "synthesizer",
          "signature": "a -\u003e a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-ToneModulation.html#checkNonNeg",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer State ToneModulation",
          "module": "Synthesizer.State.ToneModulation",
          "name": "checkNonNeg",
          "normalized": "a-\u003ea",
          "package": "synthesizer",
          "partial": "Non Neg",
          "signature": "a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-ToneModulation.html#v:checkNonNeg"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Convert a list of phase steps into a list of momentum phases.\nphase is a number in the interval [0,1).\nfreq contains the phase steps.\nThe last element is omitted.\n",
          "module": "Synthesizer.State.ToneModulation",
          "name": "freqsToPhases",
          "package": "synthesizer",
          "signature": "T a -\u003e T a (T a)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-ToneModulation.html#freqsToPhases",
          "type": "function"
        },
        "index": {
          "description": "Convert list of phase steps into list of momentum phases phase is number in the interval freq contains the phase steps The last element is omitted",
          "hierarchy": "Synthesizer State ToneModulation",
          "module": "Synthesizer.State.ToneModulation",
          "name": "freqsToPhases",
          "normalized": "T a-\u003eT a(T a)",
          "package": "synthesizer",
          "partial": "To Phases",
          "signature": "T a-\u003eT a(T a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-ToneModulation.html#v:freqsToPhases"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Like \u003ctt\u003e\u003ca\u003efreqsToPhases\u003c/a\u003e\u003c/tt\u003e but the first element is omitted.\n",
          "module": "Synthesizer.State.ToneModulation",
          "name": "freqsToPhasesSync",
          "package": "synthesizer",
          "signature": "T a -\u003e T a (T a)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-ToneModulation.html#freqsToPhasesSync",
          "type": "function"
        },
        "index": {
          "description": "Like freqsToPhases but the first element is omitted",
          "hierarchy": "Synthesizer State ToneModulation",
          "module": "Synthesizer.State.ToneModulation",
          "name": "freqsToPhasesSync",
          "normalized": "T a-\u003eT a(T a)",
          "package": "synthesizer",
          "partial": "To Phases Sync",
          "signature": "T a-\u003eT a(T a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-ToneModulation.html#v:freqsToPhasesSync"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.State.ToneModulation",
          "name": "limitMinRelativeValues",
          "package": "synthesizer",
          "signature": "t -\u003e (t, T t) -\u003e (t, T t)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-ToneModulation.html#limitMinRelativeValues",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer State ToneModulation",
          "module": "Synthesizer.State.ToneModulation",
          "name": "limitMinRelativeValues",
          "normalized": "a-\u003e(a,T a)-\u003e(a,T a)",
          "package": "synthesizer",
          "partial": "Min Relative Values",
          "signature": "t-\u003e(t,T t)-\u003e(t,T t)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-ToneModulation.html#v:limitMinRelativeValues"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.State.ToneModulation",
          "name": "limitRelativeShapes",
          "package": "synthesizer",
          "signature": "Margin -\u003e Margin -\u003e Int -\u003e (t, T t) -\u003e (t, T t)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-ToneModulation.html#limitRelativeShapes",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer State ToneModulation",
          "module": "Synthesizer.State.ToneModulation",
          "name": "limitRelativeShapes",
          "normalized": "Margin-\u003eMargin-\u003eInt-\u003e(a,T a)-\u003e(a,T a)",
          "package": "synthesizer",
          "partial": "Relative Shapes",
          "signature": "Margin-\u003eMargin-\u003eInt-\u003e(t,T t)-\u003e(t,T t)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-ToneModulation.html#v:limitRelativeShapes"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.State.ToneModulation",
          "name": "makeCell",
          "package": "synthesizer",
          "signature": "Int -\u003e sig y -\u003e Cell sig y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-ToneModulation.html#makeCell",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer State ToneModulation",
          "module": "Synthesizer.State.ToneModulation",
          "name": "makeCell",
          "normalized": "Int-\u003ea b-\u003eCell a b",
          "package": "synthesizer",
          "partial": "Cell",
          "signature": "Int-\u003esig y-\u003eCell sig y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-ToneModulation.html#v:makeCell"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.State.ToneModulation",
          "name": "makePrototype",
          "package": "synthesizer",
          "signature": "Margin -\u003e Margin -\u003e a -\u003e sig v -\u003e Prototype sig a v",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-ToneModulation.html#makePrototype",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer State ToneModulation",
          "module": "Synthesizer.State.ToneModulation",
          "name": "makePrototype",
          "normalized": "Margin-\u003eMargin-\u003ea-\u003eb c-\u003ePrototype b a c",
          "package": "synthesizer",
          "partial": "Prototype",
          "signature": "Margin-\u003eMargin-\u003ea-\u003esig v-\u003ePrototype sig a v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-ToneModulation.html#v:makePrototype"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "This function should not be used,\nsince it requires recomputation of \u003ctt\u003eshapes\u003c/tt\u003e and \u003ctt\u003efreqs\u003c/tt\u003e lists.\n",
          "module": "Synthesizer.State.ToneModulation",
          "name": "oscillatorCells",
          "package": "synthesizer",
          "signature": "Margin -\u003e Margin -\u003e t -\u003e sig y -\u003e (t, T t) -\u003e (T t, T t) -\u003e T ((t, t), Cell sig y)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-ToneModulation.html#oscillatorCells",
          "type": "function"
        },
        "index": {
          "description": "This function should not be used since it requires recomputation of shapes and freqs lists",
          "hierarchy": "Synthesizer State ToneModulation",
          "module": "Synthesizer.State.ToneModulation",
          "name": "oscillatorCells",
          "normalized": "Margin-\u003eMargin-\u003ea-\u003eb c-\u003e(a,T a)-\u003e(T a,T a)-\u003eT((a,a),Cell b c)",
          "package": "synthesizer",
          "partial": "Cells",
          "signature": "Margin-\u003eMargin-\u003et-\u003esig y-\u003e(t,T t)-\u003e(T t,T t)-\u003eT((t,t),Cell sig y)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-ToneModulation.html#v:oscillatorCells"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.State.ToneModulation",
          "name": "oscillatorCoords",
          "package": "synthesizer",
          "signature": "Int -\u003e t -\u003e (t, T t) -\u003e (T t, T t) -\u003e T (Coords t)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-ToneModulation.html#oscillatorCoords",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer State ToneModulation",
          "module": "Synthesizer.State.ToneModulation",
          "name": "oscillatorCoords",
          "normalized": "Int-\u003ea-\u003e(a,T a)-\u003e(T a,T a)-\u003eT(Coords a)",
          "package": "synthesizer",
          "partial": "Coords",
          "signature": "Int-\u003et-\u003e(t,T t)-\u003e(T t,T t)-\u003eT(Coords t)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-ToneModulation.html#v:oscillatorCoords"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.State.ToneModulation",
          "name": "sampledToneCell",
          "package": "synthesizer",
          "signature": "Prototype sig a v -\u003e a -\u003e T a -\u003e ((a, a), Cell sig v)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-State-ToneModulation.html#sampledToneCell",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer State ToneModulation",
          "module": "Synthesizer.State.ToneModulation",
          "name": "sampledToneCell",
          "normalized": "Prototype a b c-\u003eb-\u003eT b-\u003e((b,b),Cell a c)",
          "package": "synthesizer",
          "partial": "Tone Cell",
          "signature": "Prototype sig a v-\u003ea-\u003eT a-\u003e((a,a),Cell sig v)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-State-ToneModulation.html#v:sampledToneCell"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Storable.Cut",
          "name": "addShifted",
          "package": "synthesizer",
          "signature": "ChunkSize -\u003e Int -\u003e T a -\u003e T a -\u003e T a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Storable-Cut.html#addShifted",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Storable Cut",
          "module": "Synthesizer.Storable.Cut",
          "name": "addShifted",
          "normalized": "ChunkSize-\u003eInt-\u003eT a-\u003eT a-\u003eT a",
          "package": "synthesizer",
          "partial": "Shifted",
          "signature": "ChunkSize-\u003eInt-\u003eT a-\u003eT a-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Storable-Cut.html#v:addShifted"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Storable.Cut",
          "name": "addShiftedMany",
          "package": "synthesizer",
          "signature": "ChunkSize -\u003e [Int] -\u003e [T a] -\u003e T a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Storable-Cut.html#addShiftedMany",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Storable Cut",
          "module": "Synthesizer.Storable.Cut",
          "name": "addShiftedMany",
          "normalized": "ChunkSize-\u003e[Int]-\u003e[T a]-\u003eT a",
          "package": "synthesizer",
          "partial": "Shifted Many",
          "signature": "ChunkSize-\u003e[Int]-\u003e[T a]-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Storable-Cut.html#v:addShiftedMany"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Storable.Cut",
          "name": "addToBuffer",
          "package": "synthesizer",
          "signature": "Vector s a -\u003e Int -\u003e T a -\u003e ST s (T a)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Storable-Cut.html#addToBuffer",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Storable Cut",
          "module": "Synthesizer.Storable.Cut",
          "name": "addToBuffer",
          "normalized": "Vector a b-\u003eInt-\u003eT b-\u003eST a(T b)",
          "package": "synthesizer",
          "partial": "To Buffer",
          "signature": "Vector s a-\u003eInt-\u003eT a-\u003eST s(T a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Storable-Cut.html#v:addToBuffer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "A list of pairs: (relative start time, signal part),\n                The start time is relative to the start time\n                of the previous event. \nThe mixed signal. \n",
          "module": "Synthesizer.Storable.Cut",
          "name": "arrange",
          "package": "synthesizer",
          "signature": "ChunkSize-\u003e T Int (T v)-\u003e T v",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Storable-Cut.html#arrange",
          "type": "function"
        },
        "index": {
          "description": "list of pairs relative start time signal part The start time is relative to the start time of the previous event The mixed signal",
          "hierarchy": "Synthesizer Storable Cut",
          "module": "Synthesizer.Storable.Cut",
          "name": "arrange",
          "normalized": "ChunkSize-\u003eT Int(T a)-\u003eT a",
          "package": "synthesizer",
          "signature": "ChunkSize-\u003eT Int(T v)-\u003eT v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Storable-Cut.html#v:arrange"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "A list of pairs: (relative start time, signal part),\n                The start time is relative to the start time\n                of the previous event. \nThe mixed signal. \n",
          "module": "Synthesizer.Storable.Cut",
          "name": "arrangeEquidist",
          "package": "synthesizer",
          "signature": "ChunkSize-\u003e T Int (T v)-\u003e T v",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Storable-Cut.html#arrangeEquidist",
          "type": "function"
        },
        "index": {
          "description": "list of pairs relative start time signal part The start time is relative to the start time of the previous event The mixed signal",
          "hierarchy": "Synthesizer Storable Cut",
          "module": "Synthesizer.Storable.Cut",
          "name": "arrangeEquidist",
          "normalized": "ChunkSize-\u003eT Int(T a)-\u003eT a",
          "package": "synthesizer",
          "partial": "Equidist",
          "signature": "ChunkSize-\u003eT Int(T v)-\u003eT v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Storable-Cut.html#v:arrangeEquidist"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "A list of pairs: (relative start time, signal part),\n                The start time is relative to the start time\n                of the previous event. \nThe mixed signal. \n",
          "module": "Synthesizer.Storable.Cut",
          "name": "arrangeList",
          "package": "synthesizer",
          "signature": "ChunkSize-\u003e T Int (T v)-\u003e T v",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Storable-Cut.html#arrangeList",
          "type": "function"
        },
        "index": {
          "description": "list of pairs relative start time signal part The start time is relative to the start time of the previous event The mixed signal",
          "hierarchy": "Synthesizer Storable Cut",
          "module": "Synthesizer.Storable.Cut",
          "name": "arrangeList",
          "normalized": "ChunkSize-\u003eT Int(T a)-\u003eT a",
          "package": "synthesizer",
          "partial": "List",
          "signature": "ChunkSize-\u003eT Int(T v)-\u003eT v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Storable-Cut.html#v:arrangeList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Storable.Instance",
          "name": "storePair",
          "package": "synthesizer",
          "signature": "Dictionary (a, b)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Storable-Instance.html#storePair",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Storable Instance",
          "module": "Synthesizer.Storable.Instance",
          "name": "storePair",
          "normalized": "Dictionary(a,b)",
          "package": "synthesizer",
          "partial": "Pair",
          "signature": "Dictionary(a,b)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Storable-Instance.html#v:storePair"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Storable.Instance",
          "name": "storeTriple",
          "package": "synthesizer",
          "signature": "Dictionary (a, b, c)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Storable-Instance.html#storeTriple",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Storable Instance",
          "module": "Synthesizer.Storable.Instance",
          "name": "storeTriple",
          "normalized": "Dictionary(a,b,c)",
          "package": "synthesizer",
          "partial": "Triple",
          "signature": "Dictionary(a,b,c)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Storable-Instance.html#v:storeTriple"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "oscillator with modulated frequency \n",
          "module": "Synthesizer.Storable.Oscillator",
          "name": "freqMod",
          "package": "synthesizer",
          "signature": "ChunkSize -\u003e T a b -\u003e T a -\u003e T a -\u003e T b",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Storable-Oscillator.html#freqMod",
          "type": "function"
        },
        "index": {
          "description": "oscillator with modulated frequency",
          "hierarchy": "Synthesizer Storable Oscillator",
          "module": "Synthesizer.Storable.Oscillator",
          "name": "freqMod",
          "normalized": "ChunkSize-\u003eT a b-\u003eT a-\u003eT a-\u003eT b",
          "package": "synthesizer",
          "partial": "Mod",
          "signature": "ChunkSize-\u003eT a b-\u003eT a-\u003eT a-\u003eT b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Storable-Oscillator.html#v:freqMod"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "saw tooth oscillator with modulated frequency \n",
          "module": "Synthesizer.Storable.Oscillator",
          "name": "freqModSaw",
          "package": "synthesizer",
          "signature": "ChunkSize -\u003e T a -\u003e T a -\u003e T a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Storable-Oscillator.html#freqModSaw",
          "type": "function"
        },
        "index": {
          "description": "saw tooth oscillator with modulated frequency",
          "hierarchy": "Synthesizer Storable Oscillator",
          "module": "Synthesizer.Storable.Oscillator",
          "name": "freqModSaw",
          "normalized": "ChunkSize-\u003eT a-\u003eT a-\u003eT a",
          "package": "synthesizer",
          "partial": "Mod Saw",
          "signature": "ChunkSize-\u003eT a-\u003eT a-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Storable-Oscillator.html#v:freqModSaw"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "sine oscillator with modulated frequency \n",
          "module": "Synthesizer.Storable.Oscillator",
          "name": "freqModSine",
          "package": "synthesizer",
          "signature": "ChunkSize -\u003e T a -\u003e T a -\u003e T a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Storable-Oscillator.html#freqModSine",
          "type": "function"
        },
        "index": {
          "description": "sine oscillator with modulated frequency",
          "hierarchy": "Synthesizer Storable Oscillator",
          "module": "Synthesizer.Storable.Oscillator",
          "name": "freqModSine",
          "normalized": "ChunkSize-\u003eT a-\u003eT a-\u003eT a",
          "package": "synthesizer",
          "partial": "Mod Sine",
          "signature": "ChunkSize-\u003eT a-\u003eT a-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Storable-Oscillator.html#v:freqModSine"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Convert a list of phase steps into a list of momentum phases\n     phase is a number in the interval [0,1)\n     freq contains the phase steps \n",
          "module": "Synthesizer.Storable.Oscillator",
          "name": "freqToPhase",
          "package": "synthesizer",
          "signature": "T a -\u003e T a -\u003e T (T a)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Storable-Oscillator.html#freqToPhase",
          "type": "function"
        },
        "index": {
          "description": "Convert list of phase steps into list of momentum phases phase is number in the interval freq contains the phase steps",
          "hierarchy": "Synthesizer Storable Oscillator",
          "module": "Synthesizer.Storable.Oscillator",
          "name": "freqToPhase",
          "normalized": "T a-\u003eT a-\u003eT(T a)",
          "package": "synthesizer",
          "partial": "To Phase",
          "signature": "T a-\u003eT a-\u003eT(T a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Storable-Oscillator.html#v:freqToPhase"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "oscillator with both phase and frequency modulation \n",
          "module": "Synthesizer.Storable.Oscillator",
          "name": "phaseFreqMod",
          "package": "synthesizer",
          "signature": "ChunkSize -\u003e T a b -\u003e T a -\u003e T a -\u003e T b",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Storable-Oscillator.html#phaseFreqMod",
          "type": "function"
        },
        "index": {
          "description": "oscillator with both phase and frequency modulation",
          "hierarchy": "Synthesizer Storable Oscillator",
          "module": "Synthesizer.Storable.Oscillator",
          "name": "phaseFreqMod",
          "normalized": "ChunkSize-\u003eT a b-\u003eT a-\u003eT a-\u003eT b",
          "package": "synthesizer",
          "partial": "Freq Mod",
          "signature": "ChunkSize-\u003eT a b-\u003eT a-\u003eT a-\u003eT b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Storable-Oscillator.html#v:phaseFreqMod"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "oscillator with modulated phase \n",
          "module": "Synthesizer.Storable.Oscillator",
          "name": "phaseMod",
          "package": "synthesizer",
          "signature": "ChunkSize -\u003e T a b -\u003e a -\u003e T a -\u003e T b",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Storable-Oscillator.html#phaseMod",
          "type": "function"
        },
        "index": {
          "description": "oscillator with modulated phase",
          "hierarchy": "Synthesizer Storable Oscillator",
          "module": "Synthesizer.Storable.Oscillator",
          "name": "phaseMod",
          "normalized": "ChunkSize-\u003eT a b-\u003ea-\u003eT a-\u003eT b",
          "package": "synthesizer",
          "partial": "Mod",
          "signature": "ChunkSize-\u003eT a b-\u003ea-\u003eT a-\u003eT b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Storable-Oscillator.html#v:phaseMod"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "sine oscillator with modulated phase, useful for FM synthesis \n",
          "module": "Synthesizer.Storable.Oscillator",
          "name": "phaseModSine",
          "package": "synthesizer",
          "signature": "ChunkSize -\u003e a -\u003e T a -\u003e T a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Storable-Oscillator.html#phaseModSine",
          "type": "function"
        },
        "index": {
          "description": "sine oscillator with modulated phase useful for FM synthesis",
          "hierarchy": "Synthesizer Storable Oscillator",
          "module": "Synthesizer.Storable.Oscillator",
          "name": "phaseModSine",
          "normalized": "ChunkSize-\u003ea-\u003eT a-\u003eT a",
          "package": "synthesizer",
          "partial": "Mod Sine",
          "signature": "ChunkSize-\u003ea-\u003eT a-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Storable-Oscillator.html#v:phaseModSine"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "oscillator with both shape and frequency modulation \n",
          "module": "Synthesizer.Storable.Oscillator",
          "name": "shapeFreqMod",
          "package": "synthesizer",
          "signature": "ChunkSize -\u003e (c -\u003e T a b) -\u003e T a -\u003e T c -\u003e T a -\u003e T b",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Storable-Oscillator.html#shapeFreqMod",
          "type": "function"
        },
        "index": {
          "description": "oscillator with both shape and frequency modulation",
          "hierarchy": "Synthesizer Storable Oscillator",
          "module": "Synthesizer.Storable.Oscillator",
          "name": "shapeFreqMod",
          "normalized": "ChunkSize-\u003e(a-\u003eT b c)-\u003eT b-\u003eT a-\u003eT b-\u003eT c",
          "package": "synthesizer",
          "partial": "Freq Mod",
          "signature": "ChunkSize-\u003e(c-\u003eT a b)-\u003eT a-\u003eT c-\u003eT a-\u003eT b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Storable-Oscillator.html#v:shapeFreqMod"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "oscillator with modulated shape \n",
          "module": "Synthesizer.Storable.Oscillator",
          "name": "shapeMod",
          "package": "synthesizer",
          "signature": "ChunkSize -\u003e (c -\u003e T a b) -\u003e T a -\u003e a -\u003e T c -\u003e T b",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Storable-Oscillator.html#shapeMod",
          "type": "function"
        },
        "index": {
          "description": "oscillator with modulated shape",
          "hierarchy": "Synthesizer Storable Oscillator",
          "module": "Synthesizer.Storable.Oscillator",
          "name": "shapeMod",
          "normalized": "ChunkSize-\u003e(a-\u003eT b c)-\u003eT b-\u003eb-\u003eT a-\u003eT c",
          "package": "synthesizer",
          "partial": "Mod",
          "signature": "ChunkSize-\u003e(c-\u003eT a b)-\u003eT a-\u003ea-\u003eT c-\u003eT b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Storable-Oscillator.html#v:shapeMod"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "oscillator with constant frequency \n",
          "module": "Synthesizer.Storable.Oscillator",
          "name": "static",
          "package": "synthesizer",
          "signature": "ChunkSize -\u003e T a b -\u003e T a -\u003e a -\u003e T b",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Storable-Oscillator.html#static",
          "type": "function"
        },
        "index": {
          "description": "oscillator with constant frequency",
          "hierarchy": "Synthesizer Storable Oscillator",
          "module": "Synthesizer.Storable.Oscillator",
          "name": "static",
          "normalized": "ChunkSize-\u003eT a b-\u003eT a-\u003ea-\u003eT b",
          "package": "synthesizer",
          "signature": "ChunkSize-\u003eT a b-\u003eT a-\u003ea-\u003eT b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Storable-Oscillator.html#v:static"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "saw tooth oscillator with modulated frequency \n",
          "module": "Synthesizer.Storable.Oscillator",
          "name": "staticSaw",
          "package": "synthesizer",
          "signature": "ChunkSize -\u003e T a -\u003e a -\u003e T a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Storable-Oscillator.html#staticSaw",
          "type": "function"
        },
        "index": {
          "description": "saw tooth oscillator with modulated frequency",
          "hierarchy": "Synthesizer Storable Oscillator",
          "module": "Synthesizer.Storable.Oscillator",
          "name": "staticSaw",
          "normalized": "ChunkSize-\u003eT a-\u003ea-\u003eT a",
          "package": "synthesizer",
          "partial": "Saw",
          "signature": "ChunkSize-\u003eT a-\u003ea-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Storable-Oscillator.html#v:staticSaw"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "sine oscillator with static frequency \n",
          "module": "Synthesizer.Storable.Oscillator",
          "name": "staticSine",
          "package": "synthesizer",
          "signature": "ChunkSize -\u003e T a -\u003e a -\u003e T a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Storable-Oscillator.html#staticSine",
          "type": "function"
        },
        "index": {
          "description": "sine oscillator with static frequency",
          "hierarchy": "Synthesizer Storable Oscillator",
          "module": "Synthesizer.Storable.Oscillator",
          "name": "staticSine",
          "normalized": "ChunkSize-\u003eT a-\u003ea-\u003eT a",
          "package": "synthesizer",
          "partial": "Sine",
          "signature": "ChunkSize-\u003eT a-\u003ea-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Storable-Oscillator.html#v:staticSine"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Storable.Signal",
          "name": "T",
          "package": "synthesizer",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Storable-Signal.html#T",
          "type": "type"
        },
        "index": {
          "hierarchy": "Synthesizer Storable Signal",
          "module": "Synthesizer.Storable.Signal",
          "name": "T",
          "package": "synthesizer",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Storable-Signal.html#t:T"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Storable.Signal",
          "name": "appendFromFusionList",
          "package": "synthesizer",
          "signature": "ChunkSize -\u003e T a -\u003e T a -\u003e T a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Storable-Signal.html#appendFromFusionList",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Storable Signal",
          "module": "Synthesizer.Storable.Signal",
          "name": "appendFromFusionList",
          "normalized": "ChunkSize-\u003eT a-\u003eT a-\u003eT a",
          "package": "synthesizer",
          "partial": "From Fusion List",
          "signature": "ChunkSize-\u003eT a-\u003eT a-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Storable-Signal.html#v:appendFromFusionList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Like \u003ctt\u003e\u003ca\u003eappendFromFusionList\u003c/a\u003e\u003c/tt\u003e but returns a \u003ctt\u003e\u003ca\u003eT\u003c/a\u003e\u003c/tt\u003e\nfor more flexible following processing.\n",
          "module": "Synthesizer.Storable.Signal",
          "name": "appendFusionList",
          "package": "synthesizer",
          "signature": "ChunkSize -\u003e T a -\u003e T a -\u003e T a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Storable-Signal.html#appendFusionList",
          "type": "function"
        },
        "index": {
          "description": "Like appendFromFusionList but returns for more flexible following processing",
          "hierarchy": "Synthesizer Storable Signal",
          "module": "Synthesizer.Storable.Signal",
          "name": "appendFusionList",
          "normalized": "ChunkSize-\u003eT a-\u003eT a-\u003eT a",
          "package": "synthesizer",
          "partial": "Fusion List",
          "signature": "ChunkSize-\u003eT a-\u003eT a-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Storable-Signal.html#v:appendFusionList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Storable.Signal",
          "name": "defaultChunkSize",
          "package": "synthesizer",
          "signature": "ChunkSize",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Storable-Signal.html#defaultChunkSize",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Storable Signal",
          "module": "Synthesizer.Storable.Signal",
          "name": "defaultChunkSize",
          "package": "synthesizer",
          "partial": "Chunk Size",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Storable-Signal.html#v:defaultChunkSize"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Storable.Signal",
          "name": "delay",
          "package": "synthesizer",
          "signature": "ChunkSize -\u003e y -\u003e Int -\u003e T y -\u003e T y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Storable-Signal.html#delay",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Storable Signal",
          "module": "Synthesizer.Storable.Signal",
          "name": "delay",
          "normalized": "ChunkSize-\u003ea-\u003eInt-\u003eT a-\u003eT a",
          "package": "synthesizer",
          "signature": "ChunkSize-\u003ey-\u003eInt-\u003eT y-\u003eT y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Storable-Signal.html#v:delay"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "processor that shall be run in a feedback loop\nprefix of the output, its length determines the delay\n",
          "module": "Synthesizer.Storable.Signal",
          "name": "delayLoop",
          "package": "synthesizer",
          "signature": "T y -\u003e T y-\u003e T y-\u003e T y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Storable-Signal.html#delayLoop",
          "type": "function"
        },
        "index": {
          "description": "processor that shall be run in feedback loop prefix of the output its length determines the delay",
          "hierarchy": "Synthesizer Storable Signal",
          "module": "Synthesizer.Storable.Signal",
          "name": "delayLoop",
          "normalized": "T a-\u003eT a-\u003eT a-\u003eT a",
          "package": "synthesizer",
          "partial": "Loop",
          "signature": "T y-\u003eT y-\u003eT y-\u003eT y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Storable-Signal.html#v:delayLoop"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Processor that shall be run in a feedback loop.\n                 It's absolutely necessary that this function preserves the chunk structure\n                 and that it does not look a chunk ahead.\n                 That's guaranteed for processes that do not look ahead at all,\n                 like \u003ctt\u003e\u003ca\u003emap\u003c/a\u003e\u003c/tt\u003e, \u003ctt\u003e\u003ca\u003ecrochetL\u003c/a\u003e\u003c/tt\u003e and\n                 all of type \u003ctt\u003eCausal.Process\u003c/tt\u003e. \ninput\noutput has the same length as the input\n",
          "module": "Synthesizer.Storable.Signal",
          "name": "delayLoopOverlap",
          "package": "synthesizer",
          "signature": "Int-\u003e T y -\u003e T y-\u003e T y-\u003e T y",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Storable-Signal.html#delayLoopOverlap",
          "type": "function"
        },
        "index": {
          "description": "Processor that shall be run in feedback loop It absolutely necessary that this function preserves the chunk structure and that it does not look chunk ahead That guaranteed for processes that do not look ahead at all like map crochetL and all of type Causal.Process input output has the same length as the input",
          "hierarchy": "Synthesizer Storable Signal",
          "module": "Synthesizer.Storable.Signal",
          "name": "delayLoopOverlap",
          "normalized": "Int-\u003eT a-\u003eT a-\u003eT a-\u003eT a",
          "package": "synthesizer",
          "partial": "Loop Overlap",
          "signature": "Int-\u003eT y-\u003eT y-\u003eT y-\u003eT y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Storable-Signal.html#v:delayLoopOverlap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Storable.Signal",
          "name": "fromFusionList",
          "package": "synthesizer",
          "signature": "ChunkSize -\u003e T a -\u003e T a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Storable-Signal.html#fromFusionList",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Storable Signal",
          "module": "Synthesizer.Storable.Signal",
          "name": "fromFusionList",
          "normalized": "ChunkSize-\u003eT a-\u003eT a",
          "package": "synthesizer",
          "partial": "Fusion List",
          "signature": "ChunkSize-\u003eT a-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Storable-Signal.html#v:fromFusionList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Storable.Signal",
          "name": "fromList",
          "package": "synthesizer",
          "signature": "ChunkSize -\u003e [a] -\u003e T a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Storable-Signal.html#fromList",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Storable Signal",
          "module": "Synthesizer.Storable.Signal",
          "name": "fromList",
          "normalized": "ChunkSize-\u003e[a]-\u003eT a",
          "package": "synthesizer",
          "partial": "List",
          "signature": "ChunkSize-\u003e[a]-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Storable-Signal.html#v:fromList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Storable.Signal",
          "name": "genericLength",
          "package": "synthesizer",
          "signature": "T x -\u003e i",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Storable-Signal.html#genericLength",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Storable Signal",
          "module": "Synthesizer.Storable.Signal",
          "name": "genericLength",
          "normalized": "T a-\u003eb",
          "package": "synthesizer",
          "partial": "Length",
          "signature": "T x-\u003ei",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Storable-Signal.html#v:genericLength"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Storable.Signal",
          "name": "mix",
          "package": "synthesizer",
          "signature": "T x -\u003e T x -\u003e T x",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Storable-Signal.html#mix",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Storable Signal",
          "module": "Synthesizer.Storable.Signal",
          "name": "mix",
          "normalized": "T a-\u003eT a-\u003eT a",
          "package": "synthesizer",
          "signature": "T x-\u003eT x-\u003eT x",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Storable-Signal.html#v:mix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Storable.Signal",
          "name": "mixSize",
          "package": "synthesizer",
          "signature": "ChunkSize -\u003e T x -\u003e T x -\u003e T x",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Storable-Signal.html#mixSize",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Storable Signal",
          "module": "Synthesizer.Storable.Signal",
          "name": "mixSize",
          "normalized": "ChunkSize-\u003eT a-\u003eT a-\u003eT a",
          "package": "synthesizer",
          "partial": "Size",
          "signature": "ChunkSize-\u003eT x-\u003eT x-\u003eT x",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Storable-Signal.html#v:mixSize"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Storable.Signal",
          "name": "scanL",
          "package": "synthesizer",
          "signature": "(a -\u003e b -\u003e a) -\u003e a -\u003e T b -\u003e T a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Storable-Signal.html#scanL",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Storable Signal",
          "module": "Synthesizer.Storable.Signal",
          "name": "scanL",
          "normalized": "(a-\u003eb-\u003ea)-\u003ea-\u003eT b-\u003eT a",
          "package": "synthesizer",
          "signature": "(a-\u003eb-\u003ea)-\u003ea-\u003eT b-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Storable-Signal.html#v:scanL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Storable.Signal",
          "name": "splitAtPad",
          "package": "synthesizer",
          "signature": "ChunkSize -\u003e Int -\u003e T x -\u003e (T x, T x)",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Storable-Signal.html#splitAtPad",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Storable Signal",
          "module": "Synthesizer.Storable.Signal",
          "name": "splitAtPad",
          "normalized": "ChunkSize-\u003eInt-\u003eT a-\u003e(T a,T a)",
          "package": "synthesizer",
          "partial": "At Pad",
          "signature": "ChunkSize-\u003eInt-\u003eT x-\u003e(T x,T x)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Storable-Signal.html#v:splitAtPad"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Storable.Signal",
          "name": "takeCrochet",
          "package": "synthesizer",
          "signature": "Int -\u003e T a -\u003e T a",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Storable-Signal.html#takeCrochet",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Storable Signal",
          "module": "Synthesizer.Storable.Signal",
          "name": "takeCrochet",
          "normalized": "Int-\u003eT a-\u003eT a",
          "package": "synthesizer",
          "partial": "Crochet",
          "signature": "Int-\u003eT a-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Storable-Signal.html#v:takeCrochet"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Storable.Signal",
          "name": "zipWithAppend",
          "package": "synthesizer",
          "signature": "(x -\u003e x -\u003e x) -\u003e T x -\u003e T x -\u003e T x",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Storable-Signal.html#zipWithAppend",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Storable Signal",
          "module": "Synthesizer.Storable.Signal",
          "name": "zipWithAppend",
          "normalized": "(a-\u003ea-\u003ea)-\u003eT a-\u003eT a-\u003eT a",
          "package": "synthesizer",
          "partial": "With Append",
          "signature": "(x-\u003ex-\u003ex)-\u003eT x-\u003eT x-\u003eT x",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Storable-Signal.html#v:zipWithAppend"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Synthesizer.Storable.Signal",
          "name": "zipWithRest",
          "package": "synthesizer",
          "signature": "(x -\u003e x -\u003e c) -\u003e T x -\u003e T x -\u003e (Vector c, (Bool, T x))",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/src/Synthesizer-Storable-Signal.html#zipWithRest",
          "type": "function"
        },
        "index": {
          "hierarchy": "Synthesizer Storable Signal",
          "module": "Synthesizer.Storable.Signal",
          "name": "zipWithRest",
          "normalized": "(a-\u003ea-\u003eb)-\u003eT a-\u003eT a-\u003e(Vector b,(Bool,T a))",
          "package": "synthesizer",
          "partial": "With Rest",
          "signature": "(x-\u003ex-\u003ec)-\u003eT x-\u003eT x-\u003e(Vector c,(Bool,T x))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Storable-Signal.html#v:zipWithRest"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRendering sound effects off-line has its virtue,\nbut really cool is real-time signal generation.\nFor a long time I thought that it is the compiler's responsibility\nto make list based signal processing fast enough.\nHowever, the compiler has to respect correctness first.\nThat is, it cannot do too fancy optimization,\nsince the optimized program must still do the same as the unoptimized program.\nSo, when we write functions that rely on the maximal flexibility,\nthe compiler cannot turn it to something less flexible.\nActually, a list as in \u003ca\u003eSynthesizer.Plain.Signal\u003c/a\u003e\nis the best representation of a signal\nin terms of flexibility:\nIt allows free choice of the element type, even functions,\nit is element-wise lazy, allowing for short feedback,\nit allows sharing of computed data.\nThe drawback is, that it is slow and memory inefficient.\nIn most cases we don't need this full flexibility,\nbut the compiler has no chance to find this out automatically.\nIt can merge several operations on a list\nto a single operation by the fusion technique,\nhowever even a single list operation is hard to get in real-time.\n\u003c/p\u003e\u003cp\u003eHow do real-time software synthesizer achieve real-time performance?\nThey get the popular fast inner loops\nby processing signals in chunks of raw data.\nThis way, they lose flexibility, because they cannot do quick feedback.\nWe can do the same in Haskell, getting the same restrictions.\nAdditionally, in order to store raw data\nwe must restrict the element types\ne.g. to the \u003ctt\u003eStorable\u003c/tt\u003e class,\nsince we use \u003ctt\u003eStorableVector\u003c/tt\u003e in \u003ca\u003eSynthesizer.Storable.Signal\u003c/a\u003e.\nWith this technique single signal operations are fast,\nbut their combination cannot be optimized in many cases.\nThis is so, again, because top priority in optimization is correctness.\nConsider \u003ctt\u003emix x (cons 0 x)\u003c/tt\u003e\nwhere \u003ctt\u003econs 0 x\u003c/tt\u003e means \u003ctt\u003e0:x\u003c/tt\u003e for our chunky signal data.\nThis expression is a perfect candidate for optimization.\nBut in this case it must not be applied since the chunk structures of\n\u003ctt\u003ex\u003c/tt\u003e and \u003ctt\u003econs 0 x\u003c/tt\u003e do not match.\nIn such cases we would not gain anything over SuperCollider and CSound.\n\u003c/p\u003e\u003cp\u003eRemember that we introduced the chunky signal representation\nentirely because of efficiency concerns.\nActually we are not interested in a special chunk structure,\nso this should not be a reason for disabling optimization.\nOf course, we could ignore the correctness\nand write incorrect optimizer rules\nthat are based on correct ideas.\nHowever, experience shows that wrong optimization\nleads to surprise and infelicities sooner or later.\nThe later the worse,\nbecause the later the more code you have written\nrelying on invalid optimization.\n\u003c/p\u003e\u003cp\u003eWhat we can try is to use list representation,\nenjoy the optimization that GHC already provides for it,\nand then let fusion rules jump in\nthat make lists disappear when they are used in connection with chunky sequences.\nE.g. \u003ctt\u003eChunky.fromList (List.oscillator freq)\u003c/tt\u003e\ncould be turned into \u003ctt\u003eChunky.oscillator freq\u003c/tt\u003e.\nThis approach would be really cool, but works only in theory.\nIn practice it is hard to predict how GHC transforms various operations.\nAdditionally to optimizer rule application\nit also expands functions to their definitions (known as inlining/unfolding)\nor specializes functions to fixed types.\nWe cannot rely on our optimizer rules being actually applied.\nThis means however, that in unpredictable cases\nthe optimization fails and the efficiency drops from real-time to non-real-time.\nThis is unacceptable.\n\u003c/p\u003e\u003cp\u003eThe solution is a third signal representation,\nsee \u003ca\u003eSynthesizer.State.Signal\u003c/a\u003e.\n(Already got tired?)\nIt consists of no actual data\nbut it is a function that generates elements.\nIts type is \u003ctt\u003es -\u003e Maybe (a,s)\u003c/tt\u003e or short \u003ctt\u003eStateT s Maybe a\u003c/tt\u003e.\nGiven a state of type \u003ctt\u003es\u003c/tt\u003e it produces \u003ctt\u003eNothing\u003c/tt\u003e when the list terminates\nor \u003ctt\u003eJust\u003c/tt\u003e the next element and the updated state.\nThis can be easily converted from and to lists\nwhile preserving laziness.\nWe convert to lists by \u003ctt\u003eList.unfoldr\u003c/tt\u003e and from lists using \u003ctt\u003eviewL\u003c/tt\u003e.\nActually this signal representation is very close\nto the list representation used in the streams package.\nThe main differences are:\nFirstly, we do not use a list storage that is fused away when only used temporarily.\nThus we do not need a fusion rule (that could be skipped by the compiler).\nSecondly, we have no notion of Skip,\nsince operations like \u003ctt\u003e\u003ca\u003efilter\u003c/a\u003e\u003c/tt\u003e are uncommon in signal processing.\nIf we write our signal processing in terms of these virtual signals\nand then convert the result to regular lists or chunky sequences,\nthen only one data structure will be built\nand GHC does it's best to generate efficient inner loops.\n\u003c/p\u003e\u003cp\u003eWe cannot use these virtual signals for sharing and feedback,\nbecause there is no data structure that stores the data.\nIf we try to do so anyway, data will be recomputed.\nThus we still need chunky sequences or lists\nfor sharing of interim results and for feedback.\nActually, an expression like \u003ctt\u003emix x (reverse x)\u003c/tt\u003e\nwould definitely benefit from interim conversion to a chunky sequence,\nbut for \u003ctt\u003emix x (cons 0 x)\u003c/tt\u003e this is overkill.\n\u003c/p\u003e\u003cp\u003eIn order to get processes like the last one efficient\nwe have a new data type (no, not another one!)\nbut this time it is not a signal data type\nbut a signal processor type.\nIt is the result of thinking about\nwhich processes allow sharing on a per-sample basis at all.\nWe come to the conclusion that these can be only causal processes,\ni.e. processes that depend only on current and past data,\nnot on data from the future.\nSo, we already have a good name: \u003ca\u003eSynthesizer.Causal.Process\u003c/a\u003e.\nCausal processes are \u003ca\u003eControl.Arrow\u003c/a\u003es,\nhowever the higher level variant does no longer fit into the Arrow type class.\nThis means that there are various combinations\nthat turn causal processes into larger causal processes.\nIt needs a bit experience in pointfree coding style\nin order to use the arrow combinators,\nbut there is no way around it,\nwhen you want to use physical dimensions.\nGHC's arrow notation does only support types of the Arrow class.\nE.g. the expression \u003ctt\u003emix x (cons 0 x)\u003c/tt\u003e\nbecomes \u003ctt\u003eCausal.mix \u003c\u003c\u003c (Causal.id &&& Causal.cons 0)\u003c/tt\u003e.\nWhen you manage this burden\nyou get processes that are warranted to be causal.\nThey can not only be used to make something efficient,\nbut they also allow to process data from the outside world\nin a streaming way without unsafeInterleaveIO\nas required e.g. in JACK plugins.\n\u003c/p\u003e\u003cp\u003eFor historical reasons there is also \u003ca\u003eSynthesizer.FusionList.Signal\u003c/a\u003e\nwhich is a wrapper around lists.\nI used this data type to disable GHC's default list optimizer rules\nand use my own ones.\nThe fusion is based on \u003ctt\u003eunfoldr\u003c/tt\u003e and \u003ctt\u003ecrochetL\u003c/tt\u003e\nwhich is quite similar to the \u003ctt\u003estream-fusion\u003c/tt\u003e package.\nThe \u003ctt\u003estream-fusion\u003c/tt\u003e uses internally a \u003ctt\u003eSkip\u003c/tt\u003e constructor,\nwhich, as far as I understand,\nis better for the \u003ctt\u003efilter\u003c/tt\u003e function.\nWe do not need it,\nbecause the \u003ctt\u003efilter\u003c/tt\u003e function is very uncommon in signal processing.\nI think, \u003ctt\u003eFusionList\u003c/tt\u003e can be replaced by \u003ctt\u003estream-fusion\u003c/tt\u003e functions.\n\u003c/p\u003e\u003cp\u003eWe have now a pretty big set of signal storage types\nthat differ considerably in performance\nbut not in the set of operations.\nThis calls for a type class!\nYou find it in \u003ca\u003eSynthesizer.Generic.Signal\u003c/a\u003e\nand \u003ca\u003eSynthesizer.Generic.Signal2\u003c/a\u003e.\n\u003c/p\u003e",
          "source": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Storage.html",
          "type": "unknown"
        },
        "index": {
          "description": "Rendering sound effects off-line has its virtue but really cool is real-time signal generation For long time thought that it is the compiler responsibility to make list based signal processing fast enough However the compiler has to respect correctness first That is it cannot do too fancy optimization since the optimized program must still do the same as the unoptimized program So when we write functions that rely on the maximal flexibility the compiler cannot turn it to something less flexible Actually list as in Synthesizer.Plain.Signal is the best representation of signal in terms of flexibility It allows free choice of the element type even functions it is element-wise lazy allowing for short feedback it allows sharing of computed data The drawback is that it is slow and memory inefficient In most cases we don need this full flexibility but the compiler has no chance to find this out automatically It can merge several operations on list to single operation by the fusion technique however even single list operation is hard to get in real-time How do real-time software synthesizer achieve real-time performance They get the popular fast inner loops by processing signals in chunks of raw data This way they lose flexibility because they cannot do quick feedback We can do the same in Haskell getting the same restrictions Additionally in order to store raw data we must restrict the element types e.g to the Storable class since we use StorableVector in Synthesizer.Storable.Signal With this technique single signal operations are fast but their combination cannot be optimized in many cases This is so again because top priority in optimization is correctness Consider mix cons where cons means for our chunky signal data This expression is perfect candidate for optimization But in this case it must not be applied since the chunk structures of and cons do not match In such cases we would not gain anything over SuperCollider and CSound Remember that we introduced the chunky signal representation entirely because of efficiency concerns Actually we are not interested in special chunk structure so this should not be reason for disabling optimization Of course we could ignore the correctness and write incorrect optimizer rules that are based on correct ideas However experience shows that wrong optimization leads to surprise and infelicities sooner or later The later the worse because the later the more code you have written relying on invalid optimization What we can try is to use list representation enjoy the optimization that GHC already provides for it and then let fusion rules jump in that make lists disappear when they are used in connection with chunky sequences E.g Chunky.fromList List.oscillator freq could be turned into Chunky.oscillator freq This approach would be really cool but works only in theory In practice it is hard to predict how GHC transforms various operations Additionally to optimizer rule application it also expands functions to their definitions known as inlining unfolding or specializes functions to fixed types We cannot rely on our optimizer rules being actually applied This means however that in unpredictable cases the optimization fails and the efficiency drops from real-time to non-real-time This is unacceptable The solution is third signal representation see Synthesizer.State.Signal Already got tired It consists of no actual data but it is function that generates elements Its type is Maybe or short StateT Maybe Given state of type it produces Nothing when the list terminates or Just the next element and the updated state This can be easily converted from and to lists while preserving laziness We convert to lists by List.unfoldr and from lists using viewL Actually this signal representation is very close to the list representation used in the streams package The main differences are Firstly we do not use list storage that is fused away when only used temporarily Thus we do not need fusion rule that could be skipped by the compiler Secondly we have no notion of Skip since operations like filter are uncommon in signal processing If we write our signal processing in terms of these virtual signals and then convert the result to regular lists or chunky sequences then only one data structure will be built and GHC does it best to generate efficient inner loops We cannot use these virtual signals for sharing and feedback because there is no data structure that stores the data If we try to do so anyway data will be recomputed Thus we still need chunky sequences or lists for sharing of interim results and for feedback Actually an expression like mix reverse would definitely benefit from interim conversion to chunky sequence but for mix cons this is overkill In order to get processes like the last one efficient we have new data type no not another one but this time it is not signal data type but signal processor type It is the result of thinking about which processes allow sharing on per-sample basis at all We come to the conclusion that these can be only causal processes i.e processes that depend only on current and past data not on data from the future So we already have good name Synthesizer.Causal.Process Causal processes are Control.Arrow however the higher level variant does no longer fit into the Arrow type class This means that there are various combinations that turn causal processes into larger causal processes It needs bit experience in pointfree coding style in order to use the arrow combinators but there is no way around it when you want to use physical dimensions GHC arrow notation does only support types of the Arrow class E.g the expression mix cons becomes Causal.mix Causal.id Causal.cons When you manage this burden you get processes that are warranted to be causal They can not only be used to make something efficient but they also allow to process data from the outside world in streaming way without unsafeInterleaveIO as required e.g in JACK plugins For historical reasons there is also Synthesizer.FusionList.Signal which is wrapper around lists used this data type to disable GHC default list optimizer rules and use my own ones The fusion is based on unfoldr and crochetL which is quite similar to the stream-fusion package The stream-fusion uses internally Skip constructor which as far as understand is better for the filter function We do not need it because the filter function is very uncommon in signal processing think FusionList can be replaced by stream-fusion functions We have now pretty big set of signal storage types that differ considerably in performance but not in the set of operations This calls for type class You find it in Synthesizer.Generic.Signal and Synthesizer.Generic.Signal2",
          "type": "unknown"
        },
        "uri": "http://hackage.haskell.org/package/synthesizer/docs/Synthesizer-Storage.html"
      }
    }
  ]
]