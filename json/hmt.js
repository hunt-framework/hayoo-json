[
  {
    "cmd": "delete-by-query",
    "query": {
      "contexts": [
        "package"
      ],
      "query": {
        "op": "case",
        "type": "word",
        "word": "hmt"
      },
      "type": "context"
    }
  },
  [
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eGodfried T. Toussaint et. al.\n \"The distance geometry of music\"\n \u003cem\u003eJournal of Computational Geometry: Theory and Applications\u003c/em\u003e\n Volume 42, Issue 5, July, 2009\n (\u003ca\u003ehttp://dx.doi.org/10.1016/j.comgeo.2008.04.005\u003c/a\u003e)\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Music.Theory.Bjorklund",
          "name": "Bjorklund",
          "package": "hmt",
          "source": "src/Music-Theory-Bjorklund.html",
          "type": "module"
        },
        "index": {
          "description": "Godfried Toussaint et al The distance geometry of music Journal of Computational Geometry Theory and Applications Volume Issue July http dx.doi.org j.comgeo.2008.04.005",
          "hierarchy": "Music Theory Bjorklund",
          "module": "Music.Theory.Bjorklund",
          "name": "Bjorklund",
          "package": "hmt",
          "partial": "Bjorklund",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Bjorklund.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eBjorklund's algorithm to construct a binary sequence of \u003cem\u003en\u003c/em\u003e bits\n with \u003cem\u003ek\u003c/em\u003e ones such that the \u003cem\u003ek\u003c/em\u003e ones are distributed as evenly as\n possible among the (\u003cem\u003en\u003c/em\u003e - \u003cem\u003ek\u003c/em\u003e) zeroes.\n\u003c/p\u003e\u003cpre\u003e bjorklund (5,9) == [True,False,True,False,True,False,True,False,True]\n xdot (bjorklund (5,9)) == \"x.x.x.x.x\"\n\u003c/pre\u003e\u003cpre\u003e let es = [(2,3),(2,5)\n          ,(3,4),(3,5),(3,8)\n          ,(4,7),(4,9),(4,12),(4,15)\n          ,(5,6),(5,7),(5,8),(5,9),(5,11),(5,12),(5,13),(5,16)\n          ,(6,7),(6,13)\n          ,(7,8),(7,9),(7,10),(7,12),(7,15),(7,16),(7,17),(7,18)\n          ,(8,17),(8,19)\n          ,(9,14),(9,16),(9,22),(9,23)\n          ,(11,12),(11,24)\n          ,(13,24)\n          ,(15,34)]\n in map (\\e -\u003e let e' = bjorklund e in (e,xdot e',iseq_str e')) es\n\u003c/pre\u003e\u003cpre\u003e [((2,3),\"xx.\",\"(12)\")\n ,((2,5),\"x.x..\",\"(23)\")\n ,((3,4),\"xxx.\",\"(112)\")\n ,((3,5),\"x.x.x\",\"(221)\")\n ,((3,8),\"x..x..x.\",\"(332)\")\n ,((4,7),\"x.x.x.x\",\"(2221)\")\n ,((4,9),\"x.x.x.x..\",\"(2223)\")\n ,((4,12),\"x..x..x..x..\",\"(3333)\")\n ,((4,15),\"x...x...x...x..\",\"(4443)\")\n ,((5,6),\"xxxxx.\",\"(11112)\")\n ,((5,7),\"x.xx.xx\",\"(21211)\")\n ,((5,8),\"x.xx.xx.\",\"(21212)\")\n ,((5,9),\"x.x.x.x.x\",\"(22221)\")\n ,((5,11),\"x.x.x.x.x..\",\"(22223)\")\n ,((5,12),\"x..x.x..x.x.\",\"(32322)\")\n ,((5,13),\"x..x.x..x.x..\",\"(32323)\")\n ,((5,16),\"x..x..x..x..x...\",\"(33334)\")\n ,((6,7),\"xxxxxx.\",\"(111112)\")\n ,((6,13),\"x.x.x.x.x.x..\",\"(222223)\")\n ,((7,8),\"xxxxxxx.\",\"(1111112)\")\n ,((7,9),\"x.xxx.xxx\",\"(2112111)\")\n ,((7,10),\"x.xx.xx.xx\",\"(2121211)\")\n ,((7,12),\"x.xx.x.xx.x.\",\"(2122122)\")\n ,((7,15),\"x.x.x.x.x.x.x..\",\"(2222223)\")\n ,((7,16),\"x..x.x.x..x.x.x.\",\"(3223222)\")\n ,((7,17),\"x..x.x..x.x..x.x.\",\"(3232322)\")\n ,((7,18),\"x..x.x..x.x..x.x..\",\"(3232323)\")\n ,((8,17),\"x.x.x.x.x.x.x.x..\",\"(22222223)\")\n ,((8,19),\"x..x.x.x..x.x.x..x.\",\"(32232232)\")\n ,((9,14),\"x.xx.xx.xx.xx.\",\"(212121212)\")\n ,((9,16),\"x.xx.x.x.xx.x.x.\",\"(212221222)\")\n ,((9,22),\"x..x.x..x.x..x.x..x.x.\",\"(323232322)\")\n ,((9,23),\"x..x.x..x.x..x.x..x.x..\",\"(323232323)\")\n ,((11,12),\"xxxxxxxxxxx.\",\"(11111111112)\")\n ,((11,24),\"x..x.x.x.x.x..x.x.x.x.x.\",\"(32222322222)\")\n ,((13,24),\"x.xx.x.x.x.x.xx.x.x.x.x.\",\"(2122222122222)\")\n ,((15,34),\"x..x.x.x.x..x.x.x.x..x.x.x.x..x.x.\",\"(322232223222322)\")]\n\u003c/pre\u003e",
          "module": "Music.Theory.Bjorklund",
          "name": "bjorklund",
          "package": "hmt",
          "signature": "(Int, Int) -\u003e [Bool]",
          "source": "src/Music-Theory-Bjorklund.html#bjorklund",
          "type": "function"
        },
        "index": {
          "description": "Bjorklund algorithm to construct binary sequence of bits with ones such that the ones are distributed as evenly as possible among the zeroes bjorklund True False True False True False True False True xdot bjorklund x.x.x.x.x let es in map let bjorklund in xdot iseq str es xx x.x xxx x.x.x x..x..x x.x.x.x x.x.x.x x..x..x..x x...x...x...x xxxxx x.xx.xx x.xx.xx x.x.x.x.x x.x.x.x.x x..x.x..x.x x..x.x..x.x x..x..x..x..x xxxxxx x.x.x.x.x.x xxxxxxx x.xxx.xxx x.xx.xx.xx x.xx.x.xx.x x.x.x.x.x.x.x x..x.x.x..x.x.x x..x.x..x.x..x.x x..x.x..x.x..x.x x.x.x.x.x.x.x.x x..x.x.x..x.x.x..x x.xx.xx.xx.xx x.xx.x.x.xx.x.x x..x.x..x.x..x.x..x.x x..x.x..x.x..x.x..x.x xxxxxxxxxxx x..x.x.x.x.x..x.x.x.x.x x.xx.x.x.x.x.xx.x.x.x.x x..x.x.x.x..x.x.x.x..x.x.x.x..x.x",
          "hierarchy": "Music Theory Bjorklund",
          "module": "Music.Theory.Bjorklund",
          "name": "bjorklund",
          "normalized": "(Int,Int)-\u003e[Bool]",
          "package": "hmt",
          "signature": "(Int,Int)-\u003e[Bool]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Bjorklund.html#v:bjorklund"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003eiseq\u003c/a\u003e\u003c/code\u003e of a pattern is the distance between \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e values.\n\u003c/p\u003e\u003cpre\u003e iseq (bjorklund (5,9)) == [2,2,2,2,1]\n\u003c/pre\u003e",
          "module": "Music.Theory.Bjorklund",
          "name": "iseq",
          "package": "hmt",
          "signature": "[Bool] -\u003e [Int]",
          "source": "src/Music-Theory-Bjorklund.html#iseq",
          "type": "function"
        },
        "index": {
          "description": "The iseq of pattern is the distance between True values iseq bjorklund",
          "hierarchy": "Music Theory Bjorklund",
          "module": "Music.Theory.Bjorklund",
          "name": "iseq",
          "normalized": "[Bool]-\u003e[Int]",
          "package": "hmt",
          "signature": "[Bool]-\u003e[Int]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Bjorklund.html#v:iseq"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eiseq\u003c/a\u003e\u003c/code\u003e of pattern as compact string.\n\u003c/p\u003e\u003cpre\u003e iseq_str (bjorklund (5,9)) == \"(22221)\"\n\u003c/pre\u003e",
          "module": "Music.Theory.Bjorklund",
          "name": "iseq_str",
          "package": "hmt",
          "signature": "[Bool] -\u003e String",
          "source": "src/Music-Theory-Bjorklund.html#iseq_str",
          "type": "function"
        },
        "index": {
          "description": "iseq of pattern as compact string iseq str bjorklund",
          "hierarchy": "Music Theory Bjorklund",
          "module": "Music.Theory.Bjorklund",
          "name": "iseq_str",
          "normalized": "[Bool]-\u003eString",
          "package": "hmt",
          "signature": "[Bool]-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Bjorklund.html#v:iseq_str"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003exdot\u003c/em\u003e notation for pattern.\n\u003c/p\u003e\u003cpre\u003e xdot (bjorklund (5,9)) == \"x.x.x.x.x\"\n\u003c/pre\u003e",
          "module": "Music.Theory.Bjorklund",
          "name": "xdot",
          "package": "hmt",
          "signature": "[Bool] -\u003e String",
          "source": "src/Music-Theory-Bjorklund.html#xdot",
          "type": "function"
        },
        "index": {
          "description": "xdot notation for pattern xdot bjorklund x.x.x.x.x",
          "hierarchy": "Music Theory Bjorklund",
          "module": "Music.Theory.Bjorklund",
          "name": "xdot",
          "normalized": "[Bool]-\u003eString",
          "package": "hmt",
          "signature": "[Bool]-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Bjorklund.html#v:xdot"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eTom Johnson. \"Networks\". In Conference on Mathematics and\n Computation in Music, Berlin, May 2007.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Music.Theory.Block_Design.Johnson_2007",
          "name": "Johnson_2007",
          "package": "hmt",
          "source": "src/Music-Theory-Block_Design-Johnson_2007.html",
          "type": "module"
        },
        "index": {
          "description": "Tom Johnson Networks In Conference on Mathematics and Computation in Music Berlin May",
          "hierarchy": "Music Theory Block_Design Johnson_2007",
          "module": "Music.Theory.Block_Design.Johnson_2007",
          "name": "Johnson_2007",
          "package": "hmt",
          "partial": "Johnson",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Block_Design-Johnson_2007.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Block_Design.Johnson_2007",
          "name": "Design",
          "package": "hmt",
          "source": "src/Music-Theory-Block_Design-Johnson_2007.html#Design",
          "type": "data"
        },
        "index": {
          "hierarchy": "Music Theory Block_Design Johnson_2007",
          "module": "Music.Theory.Block_Design.Johnson_2007",
          "name": "Design",
          "package": "hmt",
          "partial": "Design",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Block_Design-Johnson_2007.html#t:Design"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Block_Design.Johnson_2007",
          "name": "Design",
          "package": "hmt",
          "signature": "Design [i] [[i]]",
          "source": "src/Music-Theory-Block_Design-Johnson_2007.html#Design",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Block_Design Johnson_2007",
          "module": "Music.Theory.Block_Design.Johnson_2007",
          "name": "Design",
          "normalized": "Design[a][[a]]",
          "package": "hmt",
          "partial": "Design",
          "signature": "Design[i][[i]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Block_Design-Johnson_2007.html#v:Design"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Block_Design.Johnson_2007",
          "name": "b_12_4_3",
          "package": "hmt",
          "signature": "[[i]]",
          "source": "src/Music-Theory-Block_Design-Johnson_2007.html#b_12_4_3",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Block_Design Johnson_2007",
          "module": "Music.Theory.Block_Design.Johnson_2007",
          "name": "b_12_4_3",
          "normalized": "[[a]]",
          "package": "hmt",
          "signature": "[[i]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Block_Design-Johnson_2007.html#v:b_12_4_3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Block_Design.Johnson_2007",
          "name": "b_13_4_1",
          "package": "hmt",
          "signature": "([[i]], [[i]])",
          "source": "src/Music-Theory-Block_Design-Johnson_2007.html#b_13_4_1",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Block_Design Johnson_2007",
          "module": "Music.Theory.Block_Design.Johnson_2007",
          "name": "b_13_4_1",
          "normalized": "([[a]],[[a]])",
          "package": "hmt",
          "signature": "([[i]],[[i]])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Block_Design-Johnson_2007.html#v:b_13_4_1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Block_Design.Johnson_2007",
          "name": "b_7_3_1",
          "package": "hmt",
          "signature": "([[i]], [[i]])",
          "source": "src/Music-Theory-Block_Design-Johnson_2007.html#b_7_3_1",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Block_Design Johnson_2007",
          "module": "Music.Theory.Block_Design.Johnson_2007",
          "name": "b_7_3_1",
          "normalized": "([[a]],[[a]])",
          "package": "hmt",
          "signature": "([[i]],[[i]])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Block_Design-Johnson_2007.html#v:b_7_3_1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Block_Design.Johnson_2007",
          "name": "c_7_3_1",
          "package": "hmt",
          "signature": "[i]",
          "source": "src/Music-Theory-Block_Design-Johnson_2007.html#c_7_3_1",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Block_Design Johnson_2007",
          "module": "Music.Theory.Block_Design.Johnson_2007",
          "name": "c_7_3_1",
          "normalized": "[a]",
          "package": "hmt",
          "signature": "[i]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Block_Design-Johnson_2007.html#v:c_7_3_1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Block_Design.Johnson_2007",
          "name": "d_13_4_1",
          "package": "hmt",
          "signature": "(Design n, Design n)",
          "source": "src/Music-Theory-Block_Design-Johnson_2007.html#d_13_4_1",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Block_Design Johnson_2007",
          "module": "Music.Theory.Block_Design.Johnson_2007",
          "name": "d_13_4_1",
          "normalized": "(Design a,Design a)",
          "package": "hmt",
          "signature": "(Design n,Design n)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Block_Design-Johnson_2007.html#v:d_13_4_1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Block_Design.Johnson_2007",
          "name": "d_7_3_1",
          "package": "hmt",
          "signature": "(Design n, Design n)",
          "source": "src/Music-Theory-Block_Design-Johnson_2007.html#d_7_3_1",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Block_Design Johnson_2007",
          "module": "Music.Theory.Block_Design.Johnson_2007",
          "name": "d_7_3_1",
          "normalized": "(Design a,Design a)",
          "package": "hmt",
          "signature": "(Design n,Design n)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Block_Design-Johnson_2007.html#v:d_7_3_1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Block_Design.Johnson_2007",
          "name": "n_12_4_3",
          "package": "hmt",
          "signature": "[(i, i)]",
          "source": "src/Music-Theory-Block_Design-Johnson_2007.html#n_12_4_3",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Block_Design Johnson_2007",
          "module": "Music.Theory.Block_Design.Johnson_2007",
          "name": "n_12_4_3",
          "normalized": "[(a,a)]",
          "package": "hmt",
          "signature": "[(i,i)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Block_Design-Johnson_2007.html#v:n_12_4_3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Block_Design.Johnson_2007",
          "name": "n_13_4_1",
          "package": "hmt",
          "signature": "[(i, i)]",
          "source": "src/Music-Theory-Block_Design-Johnson_2007.html#n_13_4_1",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Block_Design Johnson_2007",
          "module": "Music.Theory.Block_Design.Johnson_2007",
          "name": "n_13_4_1",
          "normalized": "[(a,a)]",
          "package": "hmt",
          "signature": "[(i,i)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Block_Design-Johnson_2007.html#v:n_13_4_1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Block_Design.Johnson_2007",
          "name": "n_7_3_1",
          "package": "hmt",
          "signature": "[(i, i)]",
          "source": "src/Music-Theory-Block_Design-Johnson_2007.html#n_7_3_1",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Block_Design Johnson_2007",
          "module": "Music.Theory.Block_Design.Johnson_2007",
          "name": "n_7_3_1",
          "normalized": "[(a,a)]",
          "package": "hmt",
          "signature": "[(i,i)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Block_Design-Johnson_2007.html#v:n_7_3_1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Block_Design.Johnson_2007",
          "name": "p_9_3_1",
          "package": "hmt",
          "signature": "[[i]]",
          "source": "src/Music-Theory-Block_Design-Johnson_2007.html#p_9_3_1",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Block_Design Johnson_2007",
          "module": "Music.Theory.Block_Design.Johnson_2007",
          "name": "p_9_3_1",
          "normalized": "[[a]]",
          "package": "hmt",
          "signature": "[[i]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Block_Design-Johnson_2007.html#v:p_9_3_1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eCommon music notation clefs.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Music.Theory.Clef",
          "name": "Clef",
          "package": "hmt",
          "source": "src/Music-Theory-Clef.html",
          "type": "module"
        },
        "index": {
          "description": "Common music notation clefs",
          "hierarchy": "Music Theory Clef",
          "module": "Music.Theory.Clef",
          "name": "Clef",
          "package": "hmt",
          "partial": "Clef",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Clef.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eClef with octave offset.\n\u003c/p\u003e",
          "module": "Music.Theory.Clef",
          "name": "Clef",
          "package": "hmt",
          "source": "src/Music-Theory-Clef.html#Clef",
          "type": "data"
        },
        "index": {
          "description": "Clef with octave offset",
          "hierarchy": "Music Theory Clef",
          "module": "Music.Theory.Clef",
          "name": "Clef",
          "package": "hmt",
          "partial": "Clef",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Clef.html#t:Clef"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eClef enumeration type.\n\u003c/p\u003e",
          "module": "Music.Theory.Clef",
          "name": "Clef_T",
          "package": "hmt",
          "source": "src/Music-Theory-Clef.html#Clef_T",
          "type": "data"
        },
        "index": {
          "description": "Clef enumeration type",
          "hierarchy": "Music Theory Clef",
          "module": "Music.Theory.Clef",
          "name": "Clef_T",
          "package": "hmt",
          "partial": "Clef",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Clef.html#t:Clef_T"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Clef",
          "name": "Alto",
          "package": "hmt",
          "signature": "Alto",
          "source": "src/Music-Theory-Clef.html#Clef_T",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Clef",
          "module": "Music.Theory.Clef",
          "name": "Alto",
          "package": "hmt",
          "partial": "Alto",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Clef.html#v:Alto"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Clef",
          "name": "Bass",
          "package": "hmt",
          "signature": "Bass",
          "source": "src/Music-Theory-Clef.html#Clef_T",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Clef",
          "module": "Music.Theory.Clef",
          "name": "Bass",
          "package": "hmt",
          "partial": "Bass",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Clef.html#v:Bass"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Clef",
          "name": "Clef",
          "package": "hmt",
          "signature": "Clef",
          "source": "src/Music-Theory-Clef.html#Clef",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Clef",
          "module": "Music.Theory.Clef",
          "name": "Clef",
          "package": "hmt",
          "partial": "Clef",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Clef.html#v:Clef"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Clef",
          "name": "Percussion",
          "package": "hmt",
          "signature": "Percussion",
          "source": "src/Music-Theory-Clef.html#Clef_T",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Clef",
          "module": "Music.Theory.Clef",
          "name": "Percussion",
          "package": "hmt",
          "partial": "Percussion",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Clef.html#v:Percussion"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Clef",
          "name": "Tenor",
          "package": "hmt",
          "signature": "Tenor",
          "source": "src/Music-Theory-Clef.html#Clef_T",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Clef",
          "module": "Music.Theory.Clef",
          "name": "Tenor",
          "package": "hmt",
          "partial": "Tenor",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Clef.html#v:Tenor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Clef",
          "name": "Treble",
          "package": "hmt",
          "signature": "Treble",
          "source": "src/Music-Theory-Clef.html#Clef_T",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Clef",
          "module": "Music.Theory.Clef",
          "name": "Treble",
          "package": "hmt",
          "partial": "Treble",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Clef.html#v:Treble"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Clef",
          "name": "clef_octave",
          "package": "hmt",
          "signature": "i",
          "source": "src/Music-Theory-Clef.html#Clef",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Clef",
          "module": "Music.Theory.Clef",
          "name": "clef_octave",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Clef.html#v:clef_octave"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGive clef range as a \u003ccode\u003e\u003ca\u003ePitch\u003c/a\u003e\u003c/code\u003e pair indicating the notes below and\n above the staff.\n\u003c/p\u003e\u003cpre\u003e map clef_range [Treble,Bass] == [Just (d4,g5),Just (f2,b3)]\n clef_range Percussion == Nothing\n\u003c/pre\u003e",
          "module": "Music.Theory.Clef",
          "name": "clef_range",
          "package": "hmt",
          "signature": "Clef_T -\u003e Maybe (Pitch, Pitch)",
          "source": "src/Music-Theory-Clef.html#clef_range",
          "type": "function"
        },
        "index": {
          "description": "Give clef range as Pitch pair indicating the notes below and above the staff map clef range Treble Bass Just d4 g5 Just f2 b3 clef range Percussion Nothing",
          "hierarchy": "Music Theory Clef",
          "module": "Music.Theory.Clef",
          "name": "clef_range",
          "normalized": "Clef_T-\u003eMaybe(Pitch,Pitch)",
          "package": "hmt",
          "signature": "Clef_T-\u003eMaybe(Pitch,Pitch)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Clef.html#v:clef_range"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSuggest a \u003ccode\u003e\u003ca\u003eClef\u003c/a\u003e\u003c/code\u003e given a \u003ccode\u003e\u003ca\u003ePitch\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e map clef_suggest [c2,c4] == [Clef Bass (-1),Clef Treble 0]\n\u003c/pre\u003e",
          "module": "Music.Theory.Clef",
          "name": "clef_suggest",
          "package": "hmt",
          "signature": "Pitch -\u003e Clef i",
          "source": "src/Music-Theory-Clef.html#clef_suggest",
          "type": "function"
        },
        "index": {
          "description": "Suggest Clef given Pitch map clef suggest c2 c4 Clef Bass Clef Treble",
          "hierarchy": "Music Theory Clef",
          "module": "Music.Theory.Clef",
          "name": "clef_suggest",
          "normalized": "Pitch-\u003eClef a",
          "package": "hmt",
          "signature": "Pitch-\u003eClef i",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Clef.html#v:clef_suggest"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Clef",
          "name": "clef_t",
          "package": "hmt",
          "signature": "Clef_T",
          "source": "src/Music-Theory-Clef.html#Clef",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Clef",
          "module": "Music.Theory.Clef",
          "name": "clef_t",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Clef.html#v:clef_t"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSet \u003ccode\u003e\u003ca\u003eclef_octave\u003c/a\u003e\u003c/code\u003e to \u003ccode\u003e0\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Music.Theory.Clef",
          "name": "clef_zero",
          "package": "hmt",
          "signature": "Clef i -\u003e Clef i",
          "source": "src/Music-Theory-Clef.html#clef_zero",
          "type": "function"
        },
        "index": {
          "description": "Set clef octave to",
          "hierarchy": "Music Theory Clef",
          "module": "Music.Theory.Clef",
          "name": "clef_zero",
          "normalized": "Clef a-\u003eClef a",
          "package": "hmt",
          "signature": "Clef i-\u003eClef i",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Clef.html#v:clef_zero"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eCombination functions.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Music.Theory.Combinations",
          "name": "Combinations",
          "package": "hmt",
          "source": "src/Music-Theory-Combinations.html",
          "type": "module"
        },
        "index": {
          "description": "Combination functions",
          "hierarchy": "Music Theory Combinations",
          "module": "Music.Theory.Combinations",
          "name": "Combinations",
          "package": "hmt",
          "partial": "Combinations",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Combinations.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003ek\u003c/em\u003e element subsets of \u003cem\u003es\u003c/em\u003e.\n\u003c/p\u003e\u003cpre\u003e combinations 3 [1..4] == [[1,2,3],[1,2,4],[1,3,4],[2,3,4]]\n length (combinations 3 [1..5]) == nk_combinations 5 3\n\u003c/pre\u003e",
          "module": "Music.Theory.Combinations",
          "name": "combinations",
          "package": "hmt",
          "signature": "t -\u003e [a] -\u003e [[a]]",
          "source": "src/Music-Theory-Combinations.html#combinations",
          "type": "function"
        },
        "index": {
          "description": "element subsets of combinations length combinations nk combinations",
          "hierarchy": "Music Theory Combinations",
          "module": "Music.Theory.Combinations",
          "name": "combinations",
          "normalized": "a-\u003e[b]-\u003e[[b]]",
          "package": "hmt",
          "signature": "t-\u003e[a]-\u003e[[a]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Combinations.html#v:combinations"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eNumber of \u003cem\u003ek\u003c/em\u003e element combinations of a set of \u003cem\u003en\u003c/em\u003e elements.\n\u003c/p\u003e\u003cpre\u003e (nk_combinations 6 3,nk_combinations 13 3) == (20,286)\n\u003c/pre\u003e",
          "module": "Music.Theory.Combinations",
          "name": "nk_combinations",
          "package": "hmt",
          "signature": "a -\u003e a -\u003e a",
          "source": "src/Music-Theory-Combinations.html#nk_combinations",
          "type": "function"
        },
        "index": {
          "description": "Number of element combinations of set of elements nk combinations nk combinations",
          "hierarchy": "Music Theory Combinations",
          "module": "Music.Theory.Combinations",
          "name": "nk_combinations",
          "normalized": "a-\u003ea-\u003ea",
          "package": "hmt",
          "signature": "a-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Combinations.html#v:nk_combinations"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003ePolansky, Larry and Bassein, Richard\n \"Possible and Impossible Melody: Some Formal Aspects of Contour\"\n \u003cem\u003eJournal of Music Theory\u003c/em\u003e 36/2, 1992 (pp.259-284)\n (\u003ca\u003ehttp://www.jstor.org/pss/843933\u003c/a\u003e)\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Music.Theory.Contour.Polansky_1992",
          "name": "Polansky_1992",
          "package": "hmt",
          "source": "src/Music-Theory-Contour-Polansky_1992.html",
          "type": "module"
        },
        "index": {
          "description": "Polansky Larry and Bassein Richard Possible and Impossible Melody Some Formal Aspects of Contour Journal of Music Theory pp.259-284 http www.jstor.org pss",
          "hierarchy": "Music Theory Contour Polansky_1992",
          "module": "Music.Theory.Contour.Polansky_1992",
          "name": "Polansky_1992",
          "package": "hmt",
          "partial": "Polansky",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Contour-Polansky_1992.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFunction to perhaps generate an element and a new state from an\n initial state.  This is the function provided to \u003ccode\u003e\u003ca\u003eunfoldr\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Music.Theory.Contour.Polansky_1992",
          "name": "Build_f",
          "package": "hmt",
          "source": "src/Music-Theory-Contour-Polansky_1992.html#Build_f",
          "type": "type"
        },
        "index": {
          "description": "Function to perhaps generate an element and new state from an initial state This is the function provided to unfoldr",
          "hierarchy": "Music Theory Contour Polansky_1992",
          "module": "Music.Theory.Contour.Polansky_1992",
          "name": "Build_f",
          "package": "hmt",
          "partial": "Build",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Contour-Polansky_1992.html#t:Build_f"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFunction to test is a partial sequence conforms to the target\n sequence.\n\u003c/p\u003e",
          "module": "Music.Theory.Contour.Polansky_1992",
          "name": "Conforms_f",
          "package": "hmt",
          "source": "src/Music-Theory-Contour-Polansky_1992.html#Conforms_f",
          "type": "type"
        },
        "index": {
          "description": "Function to test is partial sequence conforms to the target sequence",
          "hierarchy": "Music Theory Contour Polansky_1992",
          "module": "Music.Theory.Contour.Polansky_1992",
          "name": "Conforms_f",
          "package": "hmt",
          "partial": "Conforms",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Contour-Polansky_1992.html#t:Conforms_f"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eDescription\u003c/em\u003e notation of contour.\n\u003c/p\u003e",
          "module": "Music.Theory.Contour.Polansky_1992",
          "name": "Contour_Description",
          "package": "hmt",
          "source": "src/Music-Theory-Contour-Polansky_1992.html#Contour_Description",
          "type": "data"
        },
        "index": {
          "description": "Description notation of contour",
          "hierarchy": "Music Theory Contour Polansky_1992",
          "module": "Music.Theory.Contour.Polansky_1992",
          "name": "Contour_Description",
          "package": "hmt",
          "partial": "Contour Description",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Contour-Polansky_1992.html#t:Contour_Description"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eHalf matrix notation for contour.\n\u003c/p\u003e",
          "module": "Music.Theory.Contour.Polansky_1992",
          "name": "Contour_Half_Matrix",
          "package": "hmt",
          "source": "src/Music-Theory-Contour-Polansky_1992.html#Contour_Half_Matrix",
          "type": "data"
        },
        "index": {
          "description": "Half matrix notation for contour",
          "hierarchy": "Music Theory Contour Polansky_1992",
          "module": "Music.Theory.Contour.Polansky_1992",
          "name": "Contour_Half_Matrix",
          "package": "hmt",
          "partial": "Contour Half Matrix",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Contour-Polansky_1992.html#t:Contour_Half_Matrix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA list notation for matrices.\n\u003c/p\u003e",
          "module": "Music.Theory.Contour.Polansky_1992",
          "name": "Matrix",
          "package": "hmt",
          "source": "src/Music-Theory-Contour-Polansky_1992.html#Matrix",
          "type": "type"
        },
        "index": {
          "description": "list notation for matrices",
          "hierarchy": "Music Theory Contour Polansky_1992",
          "module": "Music.Theory.Contour.Polansky_1992",
          "name": "Matrix",
          "package": "hmt",
          "partial": "Matrix",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Contour-Polansky_1992.html#t:Matrix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Contour.Polansky_1992",
          "name": "Contour_Description",
          "package": "hmt",
          "signature": "Contour_Description",
          "source": "src/Music-Theory-Contour-Polansky_1992.html#Contour_Description",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Contour Polansky_1992",
          "module": "Music.Theory.Contour.Polansky_1992",
          "name": "Contour_Description",
          "package": "hmt",
          "partial": "Contour Description",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Contour-Polansky_1992.html#v:Contour_Description"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Contour.Polansky_1992",
          "name": "Contour_Half_Matrix",
          "package": "hmt",
          "signature": "Contour_Half_Matrix",
          "source": "src/Music-Theory-Contour-Polansky_1992.html#Contour_Half_Matrix",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Contour Polansky_1992",
          "module": "Music.Theory.Contour.Polansky_1992",
          "name": "Contour_Half_Matrix",
          "package": "hmt",
          "partial": "Contour Half Matrix",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Contour-Polansky_1992.html#v:Contour_Half_Matrix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstruct set of \u003cem\u003en\u003c/em\u003e \u003ccode\u003e\u003ca\u003e-\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e1\u003c/code\u003e adjacent indices, left right order.\n\u003c/p\u003e\u003cpre\u003e adjacent_indices 5 == [(0,1),(1,2),(2,3),(3,4)]\n\u003c/pre\u003e",
          "module": "Music.Theory.Contour.Polansky_1992",
          "name": "adjacent_indices",
          "package": "hmt",
          "signature": "i -\u003e [(i, i)]",
          "source": "src/Music-Theory-Contour-Polansky_1992.html#adjacent_indices",
          "type": "function"
        },
        "index": {
          "description": "Construct set of adjacent indices left right order adjacent indices",
          "hierarchy": "Music Theory Contour Polansky_1992",
          "module": "Music.Theory.Contour.Polansky_1992",
          "name": "adjacent_indices",
          "normalized": "a-\u003e[(a,a)]",
          "package": "hmt",
          "signature": "i-\u003e[(i,i)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Contour-Polansky_1992.html#v:adjacent_indices"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSet of all contour descriptions.\n\u003c/p\u003e\u003cpre\u003e map (length.all_contours) [3,4,5] == [27,729,59049]\n\u003c/pre\u003e",
          "module": "Music.Theory.Contour.Polansky_1992",
          "name": "all_contours",
          "package": "hmt",
          "signature": "Int -\u003e [Contour_Description]",
          "source": "src/Music-Theory-Contour-Polansky_1992.html#all_contours",
          "type": "function"
        },
        "index": {
          "description": "Set of all contour descriptions map length.all contours",
          "hierarchy": "Music Theory Contour Polansky_1992",
          "module": "Music.Theory.Contour.Polansky_1992",
          "name": "all_contours",
          "normalized": "Int-\u003e[Contour_Description]",
          "package": "hmt",
          "signature": "Int-\u003e[Contour_Description]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Contour-Polansky_1992.html#v:all_contours"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAre all elements equal.\n\u003c/p\u003e\u003cpre\u003e all_equal \"aaa\" == True\n\u003c/pre\u003e",
          "module": "Music.Theory.Contour.Polansky_1992",
          "name": "all_equal",
          "package": "hmt",
          "signature": "[a] -\u003e Bool",
          "source": "src/Music-Theory-Contour-Polansky_1992.html#all_equal",
          "type": "function"
        },
        "index": {
          "description": "Are all elements equal all equal aaa True",
          "hierarchy": "Music Theory Contour Polansky_1992",
          "module": "Music.Theory.Contour.Polansky_1992",
          "name": "all_equal",
          "normalized": "[a]-\u003eBool",
          "package": "hmt",
          "signature": "[a]-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Contour-Polansky_1992.html#v:all_equal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAll \u003cem\u003e(i,j)\u003c/em\u003e indices, in half matrix order.\n\u003c/p\u003e\u003cpre\u003e all_indices 4 == [(0,1),(0,2),(0,3),(1,2),(1,3),(2,3)]\n\u003c/pre\u003e",
          "module": "Music.Theory.Contour.Polansky_1992",
          "name": "all_indices",
          "package": "hmt",
          "signature": "i -\u003e [(i, i)]",
          "source": "src/Music-Theory-Contour-Polansky_1992.html#all_indices",
          "type": "function"
        },
        "index": {
          "description": "All indices in half matrix order all indices",
          "hierarchy": "Music Theory Contour Polansky_1992",
          "module": "Music.Theory.Contour.Polansky_1992",
          "name": "all_indices",
          "normalized": "a-\u003e[(a,a)]",
          "package": "hmt",
          "signature": "i-\u003e[(i,i)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Contour-Polansky_1992.html#v:all_indices"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAttempt to construct a sequence that has a specified contour.\n The arguments are a \u003ccode\u003e\u003ca\u003eBuild_f\u003c/a\u003e\u003c/code\u003e to generate possible elements, a\n \u003ccode\u003e\u003ca\u003eContour_Description\u003c/a\u003e\u003c/code\u003e that the result sequence must conform to, an\n \u003ccode\u003e\u003ca\u003eInt\u003c/a\u003e\u003c/code\u003e to specify the maximum number of elements to generate when\n searching for a solution, and an initial state.\n\u003c/p\u003e\u003cpre\u003e import System.Random\n\u003c/pre\u003e\u003cpre\u003e let {f = Just . randomR ('a','z')\n     ;c = contour_description \"atdez\"\n     ;st = mkStdGen 2347}\n in fst (build_contour f c 1024 st) == Just \"nvruy\"\n\u003c/pre\u003e",
          "module": "Music.Theory.Contour.Polansky_1992",
          "name": "build_contour",
          "package": "hmt",
          "signature": "Build_f st e -\u003e Contour_Description -\u003e Int -\u003e st -\u003e (Maybe [e], st)",
          "source": "src/Music-Theory-Contour-Polansky_1992.html#build_contour",
          "type": "function"
        },
        "index": {
          "description": "Attempt to construct sequence that has specified contour The arguments are Build to generate possible elements Contour Description that the result sequence must conform to an Int to specify the maximum number of elements to generate when searching for solution and an initial state import System.Random let Just randomR contour description atdez st mkStdGen in fst build contour st Just nvruy",
          "hierarchy": "Music Theory Contour Polansky_1992",
          "module": "Music.Theory.Contour.Polansky_1992",
          "name": "build_contour",
          "normalized": "Build_f a b-\u003eContour_Description-\u003eInt-\u003ea-\u003e(Maybe[b],a)",
          "package": "hmt",
          "signature": "Build_f st e-\u003eContour_Description-\u003eInt-\u003est-\u003e(Maybe[e],st)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Contour-Polansky_1992.html#v:build_contour"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA variant on \u003ccode\u003e\u003ca\u003ebuild_contour\u003c/a\u003e\u003c/code\u003e that retries a specified number of\n times using the final state of the failed attempt as the state for\n the next try.\n\u003c/p\u003e\u003cpre\u003e let {f = Just . randomR ('a','z')\n     ;c = contour_description \"atdezjh\"\n     ;st = mkStdGen 2347}\n in fst (build_contour_retry f c 64 8 st) == Just \"nystzvu\"\n\u003c/pre\u003e",
          "module": "Music.Theory.Contour.Polansky_1992",
          "name": "build_contour_retry",
          "package": "hmt",
          "signature": "Build_f st e -\u003e Contour_Description -\u003e Int -\u003e Int -\u003e st -\u003e (Maybe [e], st)",
          "source": "src/Music-Theory-Contour-Polansky_1992.html#build_contour_retry",
          "type": "function"
        },
        "index": {
          "description": "variant on build contour that retries specified number of times using the final state of the failed attempt as the state for the next try let Just randomR contour description atdezjh st mkStdGen in fst build contour retry st Just nystzvu",
          "hierarchy": "Music Theory Contour Polansky_1992",
          "module": "Music.Theory.Contour.Polansky_1992",
          "name": "build_contour_retry",
          "normalized": "Build_f a b-\u003eContour_Description-\u003eInt-\u003eInt-\u003ea-\u003e(Maybe[b],a)",
          "package": "hmt",
          "signature": "Build_f st e-\u003eContour_Description-\u003eInt-\u003eInt-\u003est-\u003e(Maybe[e],st)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Contour-Polansky_1992.html#v:build_contour_retry"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA variant on \u003ccode\u003e\u003ca\u003ebuild_contour_retry\u003c/a\u003e\u003c/code\u003e that returns the set of all\n sequences constructed.\n\u003c/p\u003e\u003cpre\u003e let {f = Just . randomR ('a','z')\n     ;c = contour_description \"atdezjh\"\n     ;st = mkStdGen 2347}\n in length (build_contour_set f c 64 64 st) == 60\n\u003c/pre\u003e",
          "module": "Music.Theory.Contour.Polansky_1992",
          "name": "build_contour_set",
          "package": "hmt",
          "signature": "Build_f st e -\u003e Contour_Description -\u003e Int -\u003e Int -\u003e st -\u003e [[e]]",
          "source": "src/Music-Theory-Contour-Polansky_1992.html#build_contour_set",
          "type": "function"
        },
        "index": {
          "description": "variant on build contour retry that returns the set of all sequences constructed let Just randomR contour description atdezjh st mkStdGen in length build contour set st",
          "hierarchy": "Music Theory Contour Polansky_1992",
          "module": "Music.Theory.Contour.Polansky_1992",
          "name": "build_contour_set",
          "normalized": "Build_f a b-\u003eContour_Description-\u003eInt-\u003eInt-\u003ea-\u003e[[b]]",
          "package": "hmt",
          "signature": "Build_f st e-\u003eContour_Description-\u003eInt-\u003eInt-\u003est-\u003e[[e]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Contour-Polansky_1992.html#v:build_contour_set"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eVariant of \u003ccode\u003e\u003ca\u003ebuild_contour_set\u003c/a\u003e\u003c/code\u003e that halts when an generated\n sequence is a duplicate of an already generated sequence.\n\u003c/p\u003e\u003cpre\u003e let {f = randomR ('a','f')\n     ;c = contour_description \"cafe\"\n     ;st = mkStdGen 2346836\n     ;r = build_contour_set_nodup f c 64 64 st}\n in filter (\"c\" `isPrefixOf`) r == [\"cafe\",\"cbed\",\"caed\"]\n\u003c/pre\u003e",
          "module": "Music.Theory.Contour.Polansky_1992",
          "name": "build_contour_set_nodup",
          "package": "hmt",
          "signature": "Build_f st e -\u003e Contour_Description -\u003e Int -\u003e Int -\u003e st -\u003e [[e]]",
          "source": "src/Music-Theory-Contour-Polansky_1992.html#build_contour_set_nodup",
          "type": "function"
        },
        "index": {
          "description": "Variant of build contour set that halts when an generated sequence is duplicate of an already generated sequence let randomR contour description cafe st mkStdGen build contour set nodup st in filter isPrefixOf cafe cbed caed",
          "hierarchy": "Music Theory Contour Polansky_1992",
          "module": "Music.Theory.Contour.Polansky_1992",
          "name": "build_contour_set_nodup",
          "normalized": "Build_f a b-\u003eContour_Description-\u003eInt-\u003eInt-\u003ea-\u003e[[b]]",
          "package": "hmt",
          "signature": "Build_f st e-\u003eContour_Description-\u003eInt-\u003eInt-\u003est-\u003e[[e]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Contour-Polansky_1992.html#v:build_contour_set_nodup"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTransform a \u003ccode\u003e\u003ca\u003eBuild_f\u003c/a\u003e\u003c/code\u003e to produce at most \u003cem\u003en\u003c/em\u003e elements.\n\u003c/p\u003e\u003cpre\u003e let f i = Just (i,succ i)\n in unfoldr (build_f_n f) (5,'a') == \"abcde\"\n\u003c/pre\u003e",
          "module": "Music.Theory.Contour.Polansky_1992",
          "name": "build_f_n",
          "package": "hmt",
          "signature": "Build_f st e -\u003e Build_f (Int, st) e",
          "source": "src/Music-Theory-Contour-Polansky_1992.html#build_f_n",
          "type": "function"
        },
        "index": {
          "description": "Transform Build to produce at most elements let Just succ in unfoldr build abcde",
          "hierarchy": "Music Theory Contour Polansky_1992",
          "module": "Music.Theory.Contour.Polansky_1992",
          "name": "build_f_n",
          "normalized": "Build_f a b-\u003eBuild_f(Int,a)b",
          "package": "hmt",
          "signature": "Build_f st e-\u003eBuild_f(Int,st)e",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Contour-Polansky_1992.html#v:build_f_n"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAttempt to construct a sequence of \u003cem\u003en\u003c/em\u003e elements given a \u003ccode\u003e\u003ca\u003eBuild_f\u003c/a\u003e\u003c/code\u003e\n to generate possible elements, a \u003ccode\u003e\u003ca\u003eConforms_f\u003c/a\u003e\u003c/code\u003e that the result\n sequence must conform to at each step, an \u003ccode\u003e\u003ca\u003eInt\u003c/a\u003e\u003c/code\u003e to specify the\n maximum number of elements to generate when searching for a\n solution, and an initial state.\n\u003c/p\u003e\u003cpre\u003e let {b_f i = Just (i,i+1)\n     ;c_f i x = odd (sum x `div` i)}\n in build_sequence 6 b_f c_f 20 0 == (Just [1,2,6,11,15,19],20)\n\u003c/pre\u003e",
          "module": "Music.Theory.Contour.Polansky_1992",
          "name": "build_sequence",
          "package": "hmt",
          "signature": "Int -\u003e Build_f st e -\u003e Conforms_f e -\u003e Int -\u003e st -\u003e (Maybe [e], st)",
          "source": "src/Music-Theory-Contour-Polansky_1992.html#build_sequence",
          "type": "function"
        },
        "index": {
          "description": "Attempt to construct sequence of elements given Build to generate possible elements Conforms that the result sequence must conform to at each step an Int to specify the maximum number of elements to generate when searching for solution and an initial state let Just odd sum div in build sequence Just",
          "hierarchy": "Music Theory Contour Polansky_1992",
          "module": "Music.Theory.Contour.Polansky_1992",
          "name": "build_sequence",
          "normalized": "Int-\u003eBuild_f a b-\u003eConforms_f b-\u003eInt-\u003ea-\u003e(Maybe[b],a)",
          "package": "hmt",
          "signature": "Int-\u003eBuild_f st e-\u003eConforms_f e-\u003eInt-\u003est-\u003e(Maybe[e],st)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Contour-Polansky_1992.html#v:build_sequence"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCompare adjacent elements (p.262) left to right.\n\u003c/p\u003e\u003cpre\u003e compare_adjacent [0,1,3,2] == [LT,LT,GT]\n\u003c/pre\u003e",
          "module": "Music.Theory.Contour.Polansky_1992",
          "name": "compare_adjacent",
          "package": "hmt",
          "signature": "[a] -\u003e [Ordering]",
          "source": "src/Music-Theory-Contour-Polansky_1992.html#compare_adjacent",
          "type": "function"
        },
        "index": {
          "description": "Compare adjacent elements p.262 left to right compare adjacent LT LT GT",
          "hierarchy": "Music Theory Contour Polansky_1992",
          "module": "Music.Theory.Contour.Polansky_1992",
          "name": "compare_adjacent",
          "normalized": "[a]-\u003e[Ordering]",
          "package": "hmt",
          "signature": "[a]-\u003e[Ordering]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Contour-Polansky_1992.html#v:compare_adjacent"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstruct \u003ccode\u003e\u003ca\u003eContour_Description\u003c/a\u003e\u003c/code\u003e of contour (p.264).\n\u003c/p\u003e\u003cpre\u003e let c = [[3,2,4,1],[3,2,1,4]]\n in map (show.contour_description) c == [\"202 02 2\",\"220 20 0\"]\n\u003c/pre\u003e",
          "module": "Music.Theory.Contour.Polansky_1992",
          "name": "contour_description",
          "package": "hmt",
          "signature": "[a] -\u003e Contour_Description",
          "source": "src/Music-Theory-Contour-Polansky_1992.html#contour_description",
          "type": "function"
        },
        "index": {
          "description": "Construct Contour Description of contour p.264 let in map show.contour description",
          "hierarchy": "Music Theory Contour Polansky_1992",
          "module": "Music.Theory.Contour.Polansky_1992",
          "name": "contour_description",
          "normalized": "[a]-\u003eContour_Description",
          "package": "hmt",
          "signature": "[a]-\u003eContour_Description",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Contour-Polansky_1992.html#v:contour_description"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInvert \u003ccode\u003e\u003ca\u003eContour_Description\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e let c = contour_description \"abdc\"\n in draw_contour (contour_description_invert c) == [3,2,0,1]\n\u003c/pre\u003e",
          "module": "Music.Theory.Contour.Polansky_1992",
          "name": "contour_description_invert",
          "package": "hmt",
          "signature": "Contour_Description -\u003e Contour_Description",
          "source": "src/Music-Theory-Contour-Polansky_1992.html#contour_description_invert",
          "type": "function"
        },
        "index": {
          "description": "Invert Contour Description let contour description abdc in draw contour contour description invert",
          "hierarchy": "Music Theory Contour Polansky_1992",
          "module": "Music.Theory.Contour.Polansky_1992",
          "name": "contour_description_invert",
          "normalized": "Contour_Description-\u003eContour_Description",
          "package": "hmt",
          "signature": "Contour_Description-\u003eContour_Description",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Contour-Polansky_1992.html#v:contour_description_invert"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eOrdering from \u003cem\u003ei\u003c/em\u003eth to \u003cem\u003ej\u003c/em\u003eth element of sequence described at \u003cem\u003ed\u003c/em\u003e.\n\u003c/p\u003e\u003cpre\u003e contour_description_ix (contour_description \"abdc\") (0,3) == LT\n\u003c/pre\u003e",
          "module": "Music.Theory.Contour.Polansky_1992",
          "name": "contour_description_ix",
          "package": "hmt",
          "signature": "Contour_Description -\u003e (Int, Int) -\u003e Ordering",
          "source": "src/Music-Theory-Contour-Polansky_1992.html#contour_description_ix",
          "type": "function"
        },
        "index": {
          "description": "Ordering from th to th element of sequence described at contour description ix contour description abdc LT",
          "hierarchy": "Music Theory Contour Polansky_1992",
          "module": "Music.Theory.Contour.Polansky_1992",
          "name": "contour_description_ix",
          "normalized": "Contour_Description-\u003e(Int,Int)-\u003eOrdering",
          "package": "hmt",
          "signature": "Contour_Description-\u003e(Int,Int)-\u003eOrdering",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Contour-Polansky_1992.html#v:contour_description_ix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCalculate number of contours of indicated degree (p.263).\n\u003c/p\u003e\u003cpre\u003e map contour_description_lm [2..7] == [1,3,6,10,15,21]\n\u003c/pre\u003e\u003cpre\u003e let r = [3,27,729,59049,14348907]\n in map (\\n -\u003e 3 ^ n) (map contour_description_lm [2..6]) == r\n\u003c/pre\u003e",
          "module": "Music.Theory.Contour.Polansky_1992",
          "name": "contour_description_lm",
          "package": "hmt",
          "signature": "a -\u003e a",
          "source": "src/Music-Theory-Contour-Polansky_1992.html#contour_description_lm",
          "type": "function"
        },
        "index": {
          "description": "Calculate number of contours of indicated degree p.263 map contour description lm let in map map contour description lm",
          "hierarchy": "Music Theory Contour Polansky_1992",
          "module": "Music.Theory.Contour.Polansky_1992",
          "name": "contour_description_lm",
          "normalized": "a-\u003ea",
          "package": "hmt",
          "signature": "a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Contour-Polansky_1992.html#v:contour_description_lm"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Contour.Polansky_1992",
          "name": "contour_description_m",
          "package": "hmt",
          "signature": "Map (Int, Int) Ordering",
          "source": "src/Music-Theory-Contour-Polansky_1992.html#Contour_Description",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Contour Polansky_1992",
          "module": "Music.Theory.Contour.Polansky_1992",
          "name": "contour_description_m",
          "normalized": "Map(Int,Int)Ordering",
          "package": "hmt",
          "signature": "Map(Int,Int)Ordering",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Contour-Polansky_1992.html#v:contour_description_m"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Contour.Polansky_1992",
          "name": "contour_description_n",
          "package": "hmt",
          "signature": "Int",
          "source": "src/Music-Theory-Contour-Polansky_1992.html#Contour_Description",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Contour Polansky_1992",
          "module": "Music.Theory.Contour.Polansky_1992",
          "name": "contour_description_n",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Contour-Polansky_1992.html#v:contour_description_n"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eShow\u003c/a\u003e\u003c/code\u003e function for \u003ccode\u003e\u003ca\u003eContour_Description\u003c/a\u003e\u003c/code\u003e (p.264).\n\u003c/p\u003e",
          "module": "Music.Theory.Contour.Polansky_1992",
          "name": "contour_description_str",
          "package": "hmt",
          "signature": "Contour_Description -\u003e String",
          "source": "src/Music-Theory-Contour-Polansky_1992.html#contour_description_str",
          "type": "function"
        },
        "index": {
          "description": "Show function for Contour Description p.264",
          "hierarchy": "Music Theory Contour Polansky_1992",
          "module": "Music.Theory.Contour.Polansky_1992",
          "name": "contour_description_str",
          "normalized": "Contour_Description-\u003eString",
          "package": "hmt",
          "signature": "Contour_Description-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Contour-Polansky_1992.html#v:contour_description_str"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAre \u003ccode\u003e\u003ca\u003eContour_Description\u003c/a\u003e\u003c/code\u003es \u003cem\u003ep\u003c/em\u003e and \u003cem\u003eq\u003c/em\u003e equal at column \u003cem\u003en\u003c/em\u003e.\n\u003c/p\u003e\u003cpre\u003e let {c = contour_description [3,2,4,1,5]\n     ;d = contour_description [3,2,4,1]}\n in map (contour_eq_at c d) [0..4] == [True,True,True,True,False]\n\u003c/pre\u003e",
          "module": "Music.Theory.Contour.Polansky_1992",
          "name": "contour_eq_at",
          "package": "hmt",
          "signature": "Contour_Description -\u003e Contour_Description -\u003e Int -\u003e Bool",
          "source": "src/Music-Theory-Contour-Polansky_1992.html#contour_eq_at",
          "type": "function"
        },
        "index": {
          "description": "Are Contour Description and equal at column let contour description contour description in map contour eq at True True True True False",
          "hierarchy": "Music Theory Contour Polansky_1992",
          "module": "Music.Theory.Contour.Polansky_1992",
          "name": "contour_eq_at",
          "normalized": "Contour_Description-\u003eContour_Description-\u003eInt-\u003eBool",
          "package": "hmt",
          "signature": "Contour_Description-\u003eContour_Description-\u003eInt-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Contour-Polansky_1992.html#v:contour_eq_at"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstruct \u003ccode\u003e\u003ca\u003eContour_Half_Matrix\u003c/a\u003e\u003c/code\u003e (p.264)\n\u003c/p\u003e",
          "module": "Music.Theory.Contour.Polansky_1992",
          "name": "contour_half_matrix",
          "package": "hmt",
          "signature": "[a] -\u003e Contour_Half_Matrix",
          "source": "src/Music-Theory-Contour-Polansky_1992.html#contour_half_matrix",
          "type": "function"
        },
        "index": {
          "description": "Construct Contour Half Matrix p.264",
          "hierarchy": "Music Theory Contour Polansky_1992",
          "module": "Music.Theory.Contour.Polansky_1992",
          "name": "contour_half_matrix",
          "normalized": "[a]-\u003eContour_Half_Matrix",
          "package": "hmt",
          "signature": "[a]-\u003eContour_Half_Matrix",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Contour-Polansky_1992.html#v:contour_half_matrix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Contour.Polansky_1992",
          "name": "contour_half_matrix_m",
          "package": "hmt",
          "signature": "Matrix Ordering",
          "source": "src/Music-Theory-Contour-Polansky_1992.html#Contour_Half_Matrix",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Contour Polansky_1992",
          "module": "Music.Theory.Contour.Polansky_1992",
          "name": "contour_half_matrix_m",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Contour-Polansky_1992.html#v:contour_half_matrix_m"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Contour.Polansky_1992",
          "name": "contour_half_matrix_n",
          "package": "hmt",
          "signature": "Int",
          "source": "src/Music-Theory-Contour-Polansky_1992.html#Contour_Half_Matrix",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Contour Polansky_1992",
          "module": "Music.Theory.Contour.Polansky_1992",
          "name": "contour_half_matrix_n",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Contour-Polansky_1992.html#v:contour_half_matrix_n"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eShow\u003c/a\u003e\u003c/code\u003e function for \u003ccode\u003e\u003ca\u003eContour_Half_Matrix\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Music.Theory.Contour.Polansky_1992",
          "name": "contour_half_matrix_str",
          "package": "hmt",
          "signature": "Contour_Half_Matrix -\u003e String",
          "source": "src/Music-Theory-Contour-Polansky_1992.html#contour_half_matrix_str",
          "type": "function"
        },
        "index": {
          "description": "Show function for Contour Half Matrix",
          "hierarchy": "Music Theory Contour Polansky_1992",
          "module": "Music.Theory.Contour.Polansky_1992",
          "name": "contour_half_matrix_str",
          "normalized": "Contour_Half_Matrix-\u003eString",
          "package": "hmt",
          "signature": "Contour_Half_Matrix-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Contour-Polansky_1992.html#v:contour_half_matrix_str"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIs \u003ccode\u003e\u003ca\u003eContour_Description\u003c/a\u003e\u003c/code\u003e \u003cem\u003ep\u003c/em\u003e a prefix of \u003cem\u003eq\u003c/em\u003e.\n\u003c/p\u003e\u003cpre\u003e let {c = contour_description [3,2,4,1]\n     ;d = contour_description [3,2,4]}\n in d `contour_is_prefix_of` c == True\n\u003c/pre\u003e",
          "module": "Music.Theory.Contour.Polansky_1992",
          "name": "contour_is_prefix_of",
          "package": "hmt",
          "signature": "Contour_Description -\u003e Contour_Description -\u003e Bool",
          "source": "src/Music-Theory-Contour-Polansky_1992.html#contour_is_prefix_of",
          "type": "function"
        },
        "index": {
          "description": "Is Contour Description prefix of let contour description contour description in contour is prefix of True",
          "hierarchy": "Music Theory Contour Polansky_1992",
          "module": "Music.Theory.Contour.Polansky_1992",
          "name": "contour_is_prefix_of",
          "normalized": "Contour_Description-\u003eContour_Description-\u003eBool",
          "package": "hmt",
          "signature": "Contour_Description-\u003eContour_Description-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Contour-Polansky_1992.html#v:contour_is_prefix_of"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstruct \u003ccode\u003e\u003ca\u003ematrix_f\u003c/a\u003e\u003c/code\u003e with \u003ccode\u003e\u003ca\u003ecompare\u003c/a\u003e\u003c/code\u003e (p.263).\n\u003c/p\u003e\u003cpre\u003e contour_matrix [1..3] == [[EQ,LT,LT],[GT,EQ,LT],[GT,GT,EQ]]\n\u003c/pre\u003e",
          "module": "Music.Theory.Contour.Polansky_1992",
          "name": "contour_matrix",
          "package": "hmt",
          "signature": "[a] -\u003e Matrix Ordering",
          "source": "src/Music-Theory-Contour-Polansky_1992.html#contour_matrix",
          "type": "function"
        },
        "index": {
          "description": "Construct matrix with compare p.263 contour matrix EQ LT LT GT EQ LT GT GT EQ",
          "hierarchy": "Music Theory Contour Polansky_1992",
          "module": "Music.Theory.Contour.Polansky_1992",
          "name": "contour_matrix",
          "normalized": "[a]-\u003eMatrix Ordering",
          "package": "hmt",
          "signature": "[a]-\u003eMatrix Ordering",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Contour-Polansky_1992.html#v:contour_matrix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTruncate a \u003ccode\u003e\u003ca\u003eContour_Description\u003c/a\u003e\u003c/code\u003e to have at most \u003cem\u003en\u003c/em\u003e elements.\n\u003c/p\u003e\u003cpre\u003e let c = contour_description [3,2,4,1]\n in contour_truncate c 3 == contour_description [3,2,4]\n\u003c/pre\u003e",
          "module": "Music.Theory.Contour.Polansky_1992",
          "name": "contour_truncate",
          "package": "hmt",
          "signature": "Contour_Description -\u003e Int -\u003e Contour_Description",
          "source": "src/Music-Theory-Contour-Polansky_1992.html#contour_truncate",
          "type": "function"
        },
        "index": {
          "description": "Truncate Contour Description to have at most elements let contour description in contour truncate contour description",
          "hierarchy": "Music Theory Contour Polansky_1992",
          "module": "Music.Theory.Contour.Polansky_1992",
          "name": "contour_truncate",
          "normalized": "Contour_Description-\u003eInt-\u003eContour_Description",
          "package": "hmt",
          "signature": "Contour_Description-\u003eInt-\u003eContour_Description",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Contour-Polansky_1992.html#v:contour_truncate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDerive an \u003ccode\u003e\u003ca\u003eIntegral\u003c/a\u003e\u003c/code\u003e contour that would be described by\n \u003ccode\u003e\u003ca\u003eContour_Description\u003c/a\u003e\u003c/code\u003e.  Diverges for impossible contours.\n\u003c/p\u003e\u003cpre\u003e draw_contour (contour_description \"abdc\") == [0,1,3,2]\n\u003c/pre\u003e",
          "module": "Music.Theory.Contour.Polansky_1992",
          "name": "draw_contour",
          "package": "hmt",
          "signature": "Contour_Description -\u003e [i]",
          "source": "src/Music-Theory-Contour-Polansky_1992.html#draw_contour",
          "type": "function"
        },
        "index": {
          "description": "Derive an Integral contour that would be described by Contour Description Diverges for impossible contours draw contour contour description abdc",
          "hierarchy": "Music Theory Contour Polansky_1992",
          "module": "Music.Theory.Contour.Polansky_1992",
          "name": "draw_contour",
          "normalized": "Contour_Description-\u003e[a]",
          "package": "hmt",
          "signature": "Contour_Description-\u003e[i]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Contour-Polansky_1992.html#v:draw_contour"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExample from p.262 (quarter-note durations)\n\u003c/p\u003e\u003cpre\u003e ex_1 == [2,3/2,1/2,1,2]\n compare_adjacent ex_1 == [GT,GT,LT,LT]\n show (contour_half_matrix ex_1) == \"2221 220 00 0\"\n draw_contour (contour_description ex_1) == [3,2,0,1,3]\n\u003c/pre\u003e\u003cpre\u003e let d = contour_description_invert (contour_description ex_1)\n in (show d,is_possible d) == (\"0001 002 22 2\",True)\n\u003c/pre\u003e",
          "module": "Music.Theory.Contour.Polansky_1992",
          "name": "ex_1",
          "package": "hmt",
          "signature": "[Rational]",
          "source": "src/Music-Theory-Contour-Polansky_1992.html#ex_1",
          "type": "function"
        },
        "index": {
          "description": "Example from p.262 quarter-note durations ex compare adjacent ex GT GT LT LT show contour half matrix ex draw contour contour description ex let contour description invert contour description ex in show is possible True",
          "hierarchy": "Music Theory Contour Polansky_1992",
          "module": "Music.Theory.Contour.Polansky_1992",
          "name": "ex_1",
          "normalized": "[Rational]",
          "package": "hmt",
          "signature": "[Rational]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Contour-Polansky_1992.html#v:ex_1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExample on p.265 (pitch)\n\u003c/p\u003e\u003cpre\u003e ex_2 == [0,5,3]\n show (contour_description ex_2) == \"00 2\"\n\u003c/pre\u003e",
          "module": "Music.Theory.Contour.Polansky_1992",
          "name": "ex_2",
          "package": "hmt",
          "signature": "[Integer]",
          "source": "src/Music-Theory-Contour-Polansky_1992.html#ex_2",
          "type": "function"
        },
        "index": {
          "description": "Example on p.265 pitch ex show contour description ex",
          "hierarchy": "Music Theory Contour Polansky_1992",
          "module": "Music.Theory.Contour.Polansky_1992",
          "name": "ex_2",
          "normalized": "[Integer]",
          "package": "hmt",
          "signature": "[Integer]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Contour-Polansky_1992.html#v:ex_2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExample on p.265 (pitch)\n\u003c/p\u003e\u003cpre\u003e ex_3 == [12,7,6,7,8,7]\n show (contour_description ex_3) == \"22222 2101 000 01 2\"\n contour_description_ix (contour_description ex_3) (0,5) == GT\n is_possible (contour_description ex_3) == True\n\u003c/pre\u003e",
          "module": "Music.Theory.Contour.Polansky_1992",
          "name": "ex_3",
          "package": "hmt",
          "signature": "[Integer]",
          "source": "src/Music-Theory-Contour-Polansky_1992.html#ex_3",
          "type": "function"
        },
        "index": {
          "description": "Example on p.265 pitch ex show contour description ex contour description ix contour description ex GT is possible contour description ex True",
          "hierarchy": "Music Theory Contour Polansky_1992",
          "module": "Music.Theory.Contour.Polansky_1992",
          "name": "ex_3",
          "normalized": "[Integer]",
          "package": "hmt",
          "signature": "[Integer]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Contour-Polansky_1992.html#v:ex_3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExample on p.266 (impossible)\n\u003c/p\u003e\u003cpre\u003e show ex_4 == \"2221 220 00 1\"\n is_possible ex_4 == False\n violations ex_4 == [(0,3,4,GT),(1,3,4,GT)]\n\u003c/pre\u003e",
          "module": "Music.Theory.Contour.Polansky_1992",
          "name": "ex_4",
          "package": "hmt",
          "signature": "Contour_Description",
          "source": "src/Music-Theory-Contour-Polansky_1992.html#ex_4",
          "type": "function"
        },
        "index": {
          "description": "Example on p.266 impossible show ex is possible ex False violations ex GT GT",
          "hierarchy": "Music Theory Contour Polansky_1992",
          "module": "Music.Theory.Contour.Polansky_1992",
          "name": "ex_4",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Contour-Polansky_1992.html#v:ex_4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGeneric variant of \u003ccode\u003e\u003ca\u003efromEnum\u003c/a\u003e\u003c/code\u003e (p.263).\n\u003c/p\u003e",
          "module": "Music.Theory.Contour.Polansky_1992",
          "name": "genericFromEnum",
          "package": "hmt",
          "signature": "e -\u003e i",
          "source": "src/Music-Theory-Contour-Polansky_1992.html#genericFromEnum",
          "type": "function"
        },
        "index": {
          "description": "Generic variant of fromEnum p.263",
          "hierarchy": "Music Theory Contour Polansky_1992",
          "module": "Music.Theory.Contour.Polansky_1992",
          "name": "genericFromEnum",
          "normalized": "a-\u003eb",
          "package": "hmt",
          "partial": "From Enum",
          "signature": "e-\u003ei",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Contour-Polansky_1992.html#v:genericFromEnum"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGeneric variant of \u003ccode\u003e\u003ca\u003etoEnum\u003c/a\u003e\u003c/code\u003e (p.263).\n\u003c/p\u003e",
          "module": "Music.Theory.Contour.Polansky_1992",
          "name": "genericToEnum",
          "package": "hmt",
          "signature": "i -\u003e e",
          "source": "src/Music-Theory-Contour-Polansky_1992.html#genericToEnum",
          "type": "function"
        },
        "index": {
          "description": "Generic variant of toEnum p.263",
          "hierarchy": "Music Theory Contour Polansky_1992",
          "module": "Music.Theory.Contour.Polansky_1992",
          "name": "genericToEnum",
          "normalized": "a-\u003eb",
          "package": "hmt",
          "partial": "To Enum",
          "signature": "i-\u003ee",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Contour-Polansky_1992.html#v:genericToEnum"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eHalf \u003ccode\u003e\u003ca\u003eMatrix\u003c/a\u003e\u003c/code\u003e of contour given comparison function \u003cem\u003ef\u003c/em\u003e.\n\u003c/p\u003e\u003cpre\u003e half_matrix_f (flip (-)) [2,10,6,7] == [[8,4,5],[-4,-3],[1]]\n half_matrix_f (flip (-)) [5,0,3,2] == [[-5,-2,-3],[3,2],[-1]]\n half_matrix_f compare [5,0,3,2] == [[GT,GT,GT],[LT,LT],[GT]]\n\u003c/pre\u003e",
          "module": "Music.Theory.Contour.Polansky_1992",
          "name": "half_matrix_f",
          "package": "hmt",
          "signature": "(a -\u003e a -\u003e b) -\u003e [a] -\u003e Matrix b",
          "source": "src/Music-Theory-Contour-Polansky_1992.html#half_matrix_f",
          "type": "function"
        },
        "index": {
          "description": "Half Matrix of contour given comparison function half matrix flip half matrix flip half matrix compare GT GT GT LT LT GT",
          "hierarchy": "Music Theory Contour Polansky_1992",
          "module": "Music.Theory.Contour.Polansky_1992",
          "name": "half_matrix_f",
          "normalized": "(a-\u003ea-\u003eb)-\u003e[a]-\u003eMatrix b",
          "package": "hmt",
          "signature": "(a-\u003ea-\u003eb)-\u003e[a]-\u003eMatrix b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Contour-Polansky_1992.html#v:half_matrix_f"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert from \u003ccode\u003e\u003ca\u003eContour_Half_Matrix\u003c/a\u003e\u003c/code\u003e notation to \u003ccode\u003e\u003ca\u003eContour_Description\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Music.Theory.Contour.Polansky_1992",
          "name": "half_matrix_to_description",
          "package": "hmt",
          "signature": "Contour_Half_Matrix -\u003e Contour_Description",
          "source": "src/Music-Theory-Contour-Polansky_1992.html#half_matrix_to_description",
          "type": "function"
        },
        "index": {
          "description": "Convert from Contour Half Matrix notation to Contour Description",
          "hierarchy": "Music Theory Contour Polansky_1992",
          "module": "Music.Theory.Contour.Polansky_1992",
          "name": "half_matrix_to_description",
          "normalized": "Contour_Half_Matrix-\u003eContour_Description",
          "package": "hmt",
          "signature": "Contour_Half_Matrix-\u003eContour_Description",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Contour-Polansky_1992.html#v:half_matrix_to_description"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA sequence of orderings \u003cem\u003e(i,j)\u003c/em\u003e and \u003cem\u003e(j,k)\u003c/em\u003e may imply ordering\n for \u003cem\u003e(i,k)\u003c/em\u003e.\n\u003c/p\u003e\u003cpre\u003e map implication [(LT,EQ),(EQ,EQ),(EQ,GT)] == [Just LT,Just EQ,Just GT]\n\u003c/pre\u003e",
          "module": "Music.Theory.Contour.Polansky_1992",
          "name": "implication",
          "package": "hmt",
          "signature": "(Ordering, Ordering) -\u003e Maybe Ordering",
          "source": "src/Music-Theory-Contour-Polansky_1992.html#implication",
          "type": "function"
        },
        "index": {
          "description": "sequence of orderings and may imply ordering for map implication LT EQ EQ EQ EQ GT Just LT Just EQ Just GT",
          "hierarchy": "Music Theory Contour Polansky_1992",
          "module": "Music.Theory.Contour.Polansky_1992",
          "name": "implication",
          "normalized": "(Ordering,Ordering)-\u003eMaybe Ordering",
          "package": "hmt",
          "signature": "(Ordering,Ordering)-\u003eMaybe Ordering",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Contour-Polansky_1992.html#v:implication"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAll impossible contour descriptions\n\u003c/p\u003e\u003cpre\u003e map (length.impossible_contours) [3,4,5] == [14,654,58508]\n\u003c/pre\u003e",
          "module": "Music.Theory.Contour.Polansky_1992",
          "name": "impossible_contours",
          "package": "hmt",
          "signature": "Int -\u003e [Contour_Description]",
          "source": "src/Music-Theory-Contour-Polansky_1992.html#impossible_contours",
          "type": "function"
        },
        "index": {
          "description": "All impossible contour descriptions map length.impossible contours",
          "hierarchy": "Music Theory Contour Polansky_1992",
          "module": "Music.Theory.Contour.Polansky_1992",
          "name": "impossible_contours",
          "normalized": "Int-\u003e[Contour_Description]",
          "package": "hmt",
          "signature": "Int-\u003e[Contour_Description]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Contour-Polansky_1992.html#v:impossible_contours"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSpecialised \u003ccode\u003e\u003ca\u003egenericToEnum\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Music.Theory.Contour.Polansky_1992",
          "name": "int_to_ord",
          "package": "hmt",
          "signature": "a -\u003e Ordering",
          "source": "src/Music-Theory-Contour-Polansky_1992.html#int_to_ord",
          "type": "function"
        },
        "index": {
          "description": "Specialised genericToEnum",
          "hierarchy": "Music Theory Contour Polansky_1992",
          "module": "Music.Theory.Contour.Polansky_1992",
          "name": "int_to_ord",
          "normalized": "a-\u003eOrdering",
          "package": "hmt",
          "signature": "a-\u003eOrdering",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Contour-Polansky_1992.html#v:int_to_ord"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIs the number of \u003ccode\u003e\u003ca\u003eviolations\u003c/a\u003e\u003c/code\u003e zero.\n\u003c/p\u003e",
          "module": "Music.Theory.Contour.Polansky_1992",
          "name": "is_possible",
          "package": "hmt",
          "signature": "Contour_Description -\u003e Bool",
          "source": "src/Music-Theory-Contour-Polansky_1992.html#is_possible",
          "type": "function"
        },
        "index": {
          "description": "Is the number of violations zero",
          "hierarchy": "Music Theory Contour Polansky_1992",
          "module": "Music.Theory.Contour.Polansky_1992",
          "name": "is_possible",
          "normalized": "Contour_Description-\u003eBool",
          "package": "hmt",
          "signature": "Contour_Description-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Contour-Polansky_1992.html#v:is_possible"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eApply \u003cem\u003ef\u003c/em\u003e to construct \u003ccode\u003e\u003ca\u003eMatrix\u003c/a\u003e\u003c/code\u003e from sequence.\n\u003c/p\u003e\u003cpre\u003e matrix_f (,) [1..3] == [[(1,1),(1,2),(1,3)]\n                        ,[(2,1),(2,2),(2,3)]\n                        ,[(3,1),(3,2),(3,3)]]\n\u003c/pre\u003e",
          "module": "Music.Theory.Contour.Polansky_1992",
          "name": "matrix_f",
          "package": "hmt",
          "signature": "(a -\u003e a -\u003e b) -\u003e [a] -\u003e Matrix b",
          "source": "src/Music-Theory-Contour-Polansky_1992.html#matrix_f",
          "type": "function"
        },
        "index": {
          "description": "Apply to construct Matrix from sequence matrix",
          "hierarchy": "Music Theory Contour Polansky_1992",
          "module": "Music.Theory.Contour.Polansky_1992",
          "name": "matrix_f",
          "normalized": "(a-\u003ea-\u003eb)-\u003e[a]-\u003eMatrix b",
          "package": "hmt",
          "signature": "(a-\u003ea-\u003eb)-\u003e[a]-\u003eMatrix b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Contour-Polansky_1992.html#v:matrix_f"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e if contour does not containt any \u003ccode\u003e\u003ca\u003eEQ\u003c/a\u003e\u003c/code\u003e elements.\n\u003c/p\u003e\u003cpre\u003e let c = [\"abc\",\"bbb\",\"cba\"]\n map (no_equalities.contour_description) c == [True,False,True]\n\u003c/pre\u003e",
          "module": "Music.Theory.Contour.Polansky_1992",
          "name": "no_equalities",
          "package": "hmt",
          "signature": "Contour_Description -\u003e Bool",
          "source": "src/Music-Theory-Contour-Polansky_1992.html#no_equalities",
          "type": "function"
        },
        "index": {
          "description": "True if contour does not containt any EQ elements let abc bbb cba map no equalities.contour description True False True",
          "hierarchy": "Music Theory Contour Polansky_1992",
          "module": "Music.Theory.Contour.Polansky_1992",
          "name": "no_equalities",
          "normalized": "Contour_Description-\u003eBool",
          "package": "hmt",
          "signature": "Contour_Description-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Contour-Polansky_1992.html#v:no_equalities"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInvert \u003ccode\u003e\u003ca\u003eOrdering\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e map ord_invert [LT,EQ,GT] == [GT,EQ,LT]\n\u003c/pre\u003e",
          "module": "Music.Theory.Contour.Polansky_1992",
          "name": "ord_invert",
          "package": "hmt",
          "signature": "Ordering -\u003e Ordering",
          "source": "src/Music-Theory-Contour-Polansky_1992.html#ord_invert",
          "type": "function"
        },
        "index": {
          "description": "Invert Ordering map ord invert LT EQ GT GT EQ LT",
          "hierarchy": "Music Theory Contour Polansky_1992",
          "module": "Music.Theory.Contour.Polansky_1992",
          "name": "ord_invert",
          "normalized": "Ordering-\u003eOrdering",
          "package": "hmt",
          "signature": "Ordering-\u003eOrdering",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Contour-Polansky_1992.html#v:ord_invert"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSpecialised \u003ccode\u003e\u003ca\u003egenericFromEnum\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Music.Theory.Contour.Polansky_1992",
          "name": "ord_to_int",
          "package": "hmt",
          "signature": "Ordering -\u003e a",
          "source": "src/Music-Theory-Contour-Polansky_1992.html#ord_to_int",
          "type": "function"
        },
        "index": {
          "description": "Specialised genericFromEnum",
          "hierarchy": "Music Theory Contour Polansky_1992",
          "module": "Music.Theory.Contour.Polansky_1992",
          "name": "ord_to_int",
          "normalized": "Ordering-\u003ea",
          "package": "hmt",
          "signature": "Ordering-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Contour-Polansky_1992.html#v:ord_to_int"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAll possible contour descriptions\n\u003c/p\u003e\u003cpre\u003e map (length.possible_contours) [3,4,5] == [13,75,541]\n\u003c/pre\u003e",
          "module": "Music.Theory.Contour.Polansky_1992",
          "name": "possible_contours",
          "package": "hmt",
          "signature": "Int -\u003e [Contour_Description]",
          "source": "src/Music-Theory-Contour-Polansky_1992.html#possible_contours",
          "type": "function"
        },
        "index": {
          "description": "All possible contour descriptions map length.possible contours",
          "hierarchy": "Music Theory Contour Polansky_1992",
          "module": "Music.Theory.Contour.Polansky_1992",
          "name": "possible_contours",
          "normalized": "Int-\u003e[Contour_Description]",
          "package": "hmt",
          "signature": "Int-\u003e[Contour_Description]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Contour-Polansky_1992.html#v:possible_contours"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReplace the \u003cem\u003ei\u003c/em\u003eth value at \u003cem\u003ens\u003c/em\u003e with \u003cem\u003ex\u003c/em\u003e.\n\u003c/p\u003e\u003cpre\u003e replace \"test\" 2 'n' == \"tent\"\n\u003c/pre\u003e",
          "module": "Music.Theory.Contour.Polansky_1992",
          "name": "replace",
          "package": "hmt",
          "signature": "[a] -\u003e i -\u003e a -\u003e [a]",
          "source": "src/Music-Theory-Contour-Polansky_1992.html#replace",
          "type": "function"
        },
        "index": {
          "description": "Replace the th value at ns with replace test tent",
          "hierarchy": "Music Theory Contour Polansky_1992",
          "module": "Music.Theory.Contour.Polansky_1992",
          "name": "replace",
          "normalized": "[a]-\u003eb-\u003ea-\u003e[a]",
          "package": "hmt",
          "signature": "[a]-\u003ei-\u003ea-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Contour-Polansky_1992.html#v:replace"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e if contour is all descending, equal or ascending.\n\u003c/p\u003e\u003cpre\u003e let c = [\"abc\",\"bbb\",\"cba\"]\n in map (uniform.contour_description) c == [True,True,True]\n\u003c/pre\u003e",
          "module": "Music.Theory.Contour.Polansky_1992",
          "name": "uniform",
          "package": "hmt",
          "signature": "Contour_Description -\u003e Bool",
          "source": "src/Music-Theory-Contour-Polansky_1992.html#uniform",
          "type": "function"
        },
        "index": {
          "description": "True if contour is all descending equal or ascending let abc bbb cba in map uniform.contour description True True True",
          "hierarchy": "Music Theory Contour Polansky_1992",
          "module": "Music.Theory.Contour.Polansky_1992",
          "name": "uniform",
          "normalized": "Contour_Description-\u003eBool",
          "package": "hmt",
          "signature": "Contour_Description-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Contour-Polansky_1992.html#v:uniform"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eList of all violations at a \u003ccode\u003e\u003ca\u003eContour_Description\u003c/a\u003e\u003c/code\u003e (p.266).\n\u003c/p\u003e",
          "module": "Music.Theory.Contour.Polansky_1992",
          "name": "violations",
          "package": "hmt",
          "signature": "Contour_Description -\u003e [(Int, Int, Int, Ordering)]",
          "source": "src/Music-Theory-Contour-Polansky_1992.html#violations",
          "type": "function"
        },
        "index": {
          "description": "List of all violations at Contour Description p.266",
          "hierarchy": "Music Theory Contour Polansky_1992",
          "module": "Music.Theory.Contour.Polansky_1992",
          "name": "violations",
          "normalized": "Contour_Description-\u003e[(Int,Int,Int,Ordering)]",
          "package": "hmt",
          "signature": "Contour_Description-\u003e[(Int,Int,Int,Ordering)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Contour-Polansky_1992.html#v:violations"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eDuration annotations.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Music.Theory.Duration.Annotation",
          "name": "Annotation",
          "package": "hmt",
          "source": "src/Music-Theory-Duration-Annotation.html",
          "type": "module"
        },
        "index": {
          "description": "Duration annotations",
          "hierarchy": "Music Theory Duration Annotation",
          "module": "Music.Theory.Duration.Annotation",
          "name": "Annotation",
          "package": "hmt",
          "partial": "Annotation",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Duration-Annotation.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eStandard music notation durational model annotations\n\u003c/p\u003e",
          "module": "Music.Theory.Duration.Annotation",
          "name": "D_Annotation",
          "package": "hmt",
          "source": "src/Music-Theory-Duration-Annotation.html#D_Annotation",
          "type": "data"
        },
        "index": {
          "description": "Standard music notation durational model annotations",
          "hierarchy": "Music Theory Duration Annotation",
          "module": "Music.Theory.Duration.Annotation",
          "name": "D_Annotation",
          "package": "hmt",
          "partial": "Annotation",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Duration-Annotation.html#t:D_Annotation"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAnnotated \u003ccode\u003e\u003ca\u003eDuration\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Music.Theory.Duration.Annotation",
          "name": "Duration_A",
          "package": "hmt",
          "source": "src/Music-Theory-Duration-Annotation.html#Duration_A",
          "type": "type"
        },
        "index": {
          "description": "Annotated Duration",
          "hierarchy": "Music Theory Duration Annotation",
          "module": "Music.Theory.Duration.Annotation",
          "name": "Duration_A",
          "package": "hmt",
          "partial": "Duration",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Duration-Annotation.html#t:Duration_A"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Duration.Annotation",
          "name": "Begin_Tuplet",
          "package": "hmt",
          "signature": "Begin_Tuplet (Integer, Integer, Duration)",
          "source": "src/Music-Theory-Duration-Annotation.html#D_Annotation",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Duration Annotation",
          "module": "Music.Theory.Duration.Annotation",
          "name": "Begin_Tuplet",
          "normalized": "Begin_Tuplet(Integer,Integer,Duration)",
          "package": "hmt",
          "partial": "Begin Tuplet",
          "signature": "Begin_Tuplet(Integer,Integer,Duration)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Duration-Annotation.html#v:Begin_Tuplet"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Duration.Annotation",
          "name": "End_Tuplet",
          "package": "hmt",
          "signature": "End_Tuplet",
          "source": "src/Music-Theory-Duration-Annotation.html#D_Annotation",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Duration Annotation",
          "module": "Music.Theory.Duration.Annotation",
          "name": "End_Tuplet",
          "package": "hmt",
          "partial": "End Tuplet",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Duration-Annotation.html#v:End_Tuplet"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Duration.Annotation",
          "name": "Tie_Left",
          "package": "hmt",
          "signature": "Tie_Left",
          "source": "src/Music-Theory-Duration-Annotation.html#D_Annotation",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Duration Annotation",
          "module": "Music.Theory.Duration.Annotation",
          "name": "Tie_Left",
          "package": "hmt",
          "partial": "Tie Left",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Duration-Annotation.html#v:Tie_Left"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Duration.Annotation",
          "name": "Tie_Right",
          "package": "hmt",
          "signature": "Tie_Right",
          "source": "src/Music-Theory-Duration-Annotation.html#D_Annotation",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Duration Annotation",
          "module": "Music.Theory.Duration.Annotation",
          "name": "Tie_Right",
          "package": "hmt",
          "partial": "Tie Right",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Duration-Annotation.html#v:Tie_Right"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReplace elements at \u003ccode\u003eTraversable\u003c/code\u003e with result of joining with\n elements from list.\n\u003c/p\u003e",
          "module": "Music.Theory.Duration.Annotation",
          "name": "adopt_shape",
          "package": "hmt",
          "signature": "(a -\u003e b -\u003e c) -\u003e [b] -\u003e t a -\u003e t c",
          "source": "src/Music-Theory-Duration-Annotation.html#adopt_shape",
          "type": "function"
        },
        "index": {
          "description": "Replace elements at Traversable with result of joining with elements from list",
          "hierarchy": "Music Theory Duration Annotation",
          "module": "Music.Theory.Duration.Annotation",
          "name": "adopt_shape",
          "normalized": "(a-\u003eb-\u003ec)-\u003e[b]-\u003ed a-\u003ed c",
          "package": "hmt",
          "signature": "(a-\u003eb-\u003ec)-\u003e[b]-\u003et a-\u003et c",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Duration-Annotation.html#v:adopt_shape"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eVariant of \u003ccode\u003e\u003ca\u003eadopt_shape\u003c/a\u003e\u003c/code\u003e that considers only \u003ccode\u003e\u003ca\u003eJust\u003c/a\u003e\u003c/code\u003e elements at\n \u003ccode\u003eTraversable\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e let {s = \"a(b(cd)ef)ghi\"\n     ;t = group_tree (begin_end_cmp_eq '(' ')') s}\n in adopt_shape_m (,) [1..13] t\n\u003c/pre\u003e",
          "module": "Music.Theory.Duration.Annotation",
          "name": "adopt_shape_m",
          "package": "hmt",
          "signature": "(a -\u003e b -\u003e c) -\u003e [b] -\u003e t (Maybe a) -\u003e t (Maybe c)",
          "source": "src/Music-Theory-Duration-Annotation.html#adopt_shape_m",
          "type": "function"
        },
        "index": {
          "description": "Variant of adopt shape that considers only Just elements at Traversable let cd ef ghi group tree begin end cmp eq in adopt shape",
          "hierarchy": "Music Theory Duration Annotation",
          "module": "Music.Theory.Duration.Annotation",
          "name": "adopt_shape_m",
          "normalized": "(a-\u003eb-\u003ec)-\u003e[b]-\u003ed(Maybe a)-\u003ed(Maybe c)",
          "package": "hmt",
          "signature": "(a-\u003eb-\u003ec)-\u003e[b]-\u003et(Maybe a)-\u003et(Maybe c)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Duration-Annotation.html#v:adopt_shape_m"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTransform predicates into \u003ccode\u003e\u003ca\u003eOrdering\u003c/a\u003e\u003c/code\u003e predicate such that if \u003cem\u003ef\u003c/em\u003e\n holds then \u003ccode\u003e\u003ca\u003eLT\u003c/a\u003e\u003c/code\u003e, if \u003cem\u003eg\u003c/em\u003e holds then \u003ccode\u003e\u003ca\u003eGT\u003c/a\u003e\u003c/code\u003e else \u003ccode\u003e\u003ca\u003eEQ\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e map (begin_end_cmp (== '{') (== '}')) \"{a}\" == [LT,EQ,GT]\n\u003c/pre\u003e",
          "module": "Music.Theory.Duration.Annotation",
          "name": "begin_end_cmp",
          "package": "hmt",
          "signature": "(t -\u003e Bool) -\u003e (t -\u003e Bool) -\u003e t -\u003e Ordering",
          "source": "src/Music-Theory-Duration-Annotation.html#begin_end_cmp",
          "type": "function"
        },
        "index": {
          "description": "Transform predicates into Ordering predicate such that if holds then LT if holds then GT else EQ map begin end cmp LT EQ GT",
          "hierarchy": "Music Theory Duration Annotation",
          "module": "Music.Theory.Duration.Annotation",
          "name": "begin_end_cmp",
          "normalized": "(a-\u003eBool)-\u003e(a-\u003eBool)-\u003ea-\u003eOrdering",
          "package": "hmt",
          "signature": "(t-\u003eBool)-\u003e(t-\u003eBool)-\u003et-\u003eOrdering",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Duration-Annotation.html#v:begin_end_cmp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eVariant of \u003ccode\u003e\u003ca\u003ebegin_end_cmp\u003c/a\u003e\u003c/code\u003e, predicates are constructed by \u003ccode\u003e\u003ca\u003e==\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e map (begin_end_cmp_eq '{' '}') \"{a}\" == [LT,EQ,GT]\n\u003c/pre\u003e",
          "module": "Music.Theory.Duration.Annotation",
          "name": "begin_end_cmp_eq",
          "package": "hmt",
          "signature": "t -\u003e t -\u003e t -\u003e Ordering",
          "source": "src/Music-Theory-Duration-Annotation.html#begin_end_cmp_eq",
          "type": "function"
        },
        "index": {
          "description": "Variant of begin end cmp predicates are constructed by map begin end cmp eq LT EQ GT",
          "hierarchy": "Music Theory Duration Annotation",
          "module": "Music.Theory.Duration.Annotation",
          "name": "begin_end_cmp_eq",
          "normalized": "a-\u003ea-\u003ea-\u003eOrdering",
          "package": "hmt",
          "signature": "t-\u003et-\u003et-\u003eOrdering",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Duration-Annotation.html#v:begin_end_cmp_eq"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Duration.Annotation",
          "name": "begin_tuplet",
          "package": "hmt",
          "signature": "D_Annotation -\u003e Maybe (Integer, Integer, Duration)",
          "source": "src/Music-Theory-Duration-Annotation.html#begin_tuplet",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Duration Annotation",
          "module": "Music.Theory.Duration.Annotation",
          "name": "begin_tuplet",
          "normalized": "D_Annotation-\u003eMaybe(Integer,Integer,Duration)",
          "package": "hmt",
          "signature": "D_Annotation-\u003eMaybe(Integer,Integer,Duration)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Duration-Annotation.html#v:begin_tuplet"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Duration.Annotation",
          "name": "begins_tuplet",
          "package": "hmt",
          "signature": "D_Annotation -\u003e Bool",
          "source": "src/Music-Theory-Duration-Annotation.html#begins_tuplet",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Duration Annotation",
          "module": "Music.Theory.Duration.Annotation",
          "name": "begins_tuplet",
          "normalized": "D_Annotation-\u003eBool",
          "package": "hmt",
          "signature": "D_Annotation-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Duration-Annotation.html#v:begins_tuplet"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eVariant of \u003ccode\u003e\u003ca\u003ebreak\u003c/a\u003e\u003c/code\u003e that places separator at left.\n\u003c/p\u003e\u003cpre\u003e break_left (== 3) [1..6] == ([1..3],[4..6])\n break_left (== 3) [1..3] == ([1..3],[])\n\u003c/pre\u003e",
          "module": "Music.Theory.Duration.Annotation",
          "name": "break_left",
          "package": "hmt",
          "signature": "(a -\u003e Bool) -\u003e [a] -\u003e ([a], [a])",
          "source": "src/Music-Theory-Duration-Annotation.html#break_left",
          "type": "function"
        },
        "index": {
          "description": "Variant of break that places separator at left break left break left",
          "hierarchy": "Music Theory Duration Annotation",
          "module": "Music.Theory.Duration.Annotation",
          "name": "break_left",
          "normalized": "(a-\u003eBool)-\u003e[a]-\u003e([a],[a])",
          "package": "hmt",
          "signature": "(a-\u003eBool)-\u003e[a]-\u003e([a],[a])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Duration-Annotation.html#v:break_left"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDoes \u003cem\u003ea\u003c/em\u003e have \u003ccode\u003e\u003ca\u003eTie_Left\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003eTie_Right\u003c/a\u003e\u003c/code\u003e?\n\u003c/p\u003e",
          "module": "Music.Theory.Duration.Annotation",
          "name": "d_annotated_tied_lr",
          "package": "hmt",
          "signature": "[D_Annotation] -\u003e (Bool, Bool)",
          "source": "src/Music-Theory-Duration-Annotation.html#d_annotated_tied_lr",
          "type": "function"
        },
        "index": {
          "description": "Does have Tie Left and Tie Right",
          "hierarchy": "Music Theory Duration Annotation",
          "module": "Music.Theory.Duration.Annotation",
          "name": "d_annotated_tied_lr",
          "normalized": "[D_Annotation]-\u003e(Bool,Bool)",
          "package": "hmt",
          "signature": "[D_Annotation]-\u003e(Bool,Bool)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Duration-Annotation.html#v:d_annotated_tied_lr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Duration.Annotation",
          "name": "da_begin_tuplet",
          "package": "hmt",
          "signature": "Duration_A -\u003e Maybe (Integer, Integer, Duration)",
          "source": "src/Music-Theory-Duration-Annotation.html#da_begin_tuplet",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Duration Annotation",
          "module": "Music.Theory.Duration.Annotation",
          "name": "da_begin_tuplet",
          "normalized": "Duration_A-\u003eMaybe(Integer,Integer,Duration)",
          "package": "hmt",
          "signature": "Duration_A-\u003eMaybe(Integer,Integer,Duration)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Duration-Annotation.html#v:da_begin_tuplet"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDoes \u003ccode\u003e\u003ca\u003eDuration_A\u003c/a\u003e\u003c/code\u003e being a tuplet?\n\u003c/p\u003e",
          "module": "Music.Theory.Duration.Annotation",
          "name": "da_begins_tuplet",
          "package": "hmt",
          "signature": "Duration_A -\u003e Bool",
          "source": "src/Music-Theory-Duration-Annotation.html#da_begins_tuplet",
          "type": "function"
        },
        "index": {
          "description": "Does Duration being tuplet",
          "hierarchy": "Music Theory Duration Annotation",
          "module": "Music.Theory.Duration.Annotation",
          "name": "da_begins_tuplet",
          "normalized": "Duration_A-\u003eBool",
          "package": "hmt",
          "signature": "Duration_A-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Duration-Annotation.html#v:da_begins_tuplet"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDoes \u003ccode\u003e\u003ca\u003eDuration_A\u003c/a\u003e\u003c/code\u003e end a tuplet?\n\u003c/p\u003e",
          "module": "Music.Theory.Duration.Annotation",
          "name": "da_ends_tuplet",
          "package": "hmt",
          "signature": "Duration_A -\u003e Bool",
          "source": "src/Music-Theory-Duration-Annotation.html#da_ends_tuplet",
          "type": "function"
        },
        "index": {
          "description": "Does Duration end tuplet",
          "hierarchy": "Music Theory Duration Annotation",
          "module": "Music.Theory.Duration.Annotation",
          "name": "da_ends_tuplet",
          "normalized": "Duration_A-\u003eBool",
          "package": "hmt",
          "signature": "Duration_A-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Duration-Annotation.html#v:da_ends_tuplet"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGroup tuplets into a \u003ccode\u003e\u003ca\u003eTree\u003c/a\u003e\u003c/code\u003e.  Branch nodes have label \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e,\n leaf nodes label \u003ccode\u003e\u003ca\u003eJust\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eDuration_A\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e import Music.Theory.Duration.Name.Abbreviation\n\u003c/pre\u003e\u003cpre\u003e let d = [(q,[])\n         ,(e,[Begin_Tuplet (3,2,e)])\n         ,(s,[Begin_Tuplet (3,2,s)]),(s,[]),(s,[End_Tuplet])\n         ,(e,[End_Tuplet])\n         ,(q,[])]\n in catMaybes (flatten (da_group_tuplets d)) == d\n\u003c/pre\u003e",
          "module": "Music.Theory.Duration.Annotation",
          "name": "da_group_tuplets",
          "package": "hmt",
          "signature": "[Duration_A] -\u003e Tree (Maybe Duration_A)",
          "source": "src/Music-Theory-Duration-Annotation.html#da_group_tuplets",
          "type": "function"
        },
        "index": {
          "description": "Group tuplets into Tree Branch nodes have label Nothing leaf nodes label Just Duration import Music.Theory.Duration.Name.Abbreviation let Begin Tuplet Begin Tuplet End Tuplet End Tuplet in catMaybes flatten da group tuplets",
          "hierarchy": "Music Theory Duration Annotation",
          "module": "Music.Theory.Duration.Annotation",
          "name": "da_group_tuplets",
          "normalized": "[Duration_A]-\u003eTree(Maybe Duration_A)",
          "package": "hmt",
          "signature": "[Duration_A]-\u003eTree(Maybe Duration_A)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Duration-Annotation.html#v:da_group_tuplets"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGroup non-nested tuplets, ie. groups nested tuplets at one level.\n\u003c/p\u003e",
          "module": "Music.Theory.Duration.Annotation",
          "name": "da_group_tuplets_nn",
          "package": "hmt",
          "signature": "[Duration_A] -\u003e [Either Duration_A [Duration_A]]",
          "source": "src/Music-Theory-Duration-Annotation.html#da_group_tuplets_nn",
          "type": "function"
        },
        "index": {
          "description": "Group non-nested tuplets ie groups nested tuplets at one level",
          "hierarchy": "Music Theory Duration Annotation",
          "module": "Music.Theory.Duration.Annotation",
          "name": "da_group_tuplets_nn",
          "normalized": "[Duration_A]-\u003e[Either Duration_A[Duration_A]]",
          "package": "hmt",
          "signature": "[Duration_A]-\u003e[Either Duration_A[Duration_A]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Duration-Annotation.html#v:da_group_tuplets_nn"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIs \u003ccode\u003e\u003ca\u003eDuration_A\u003c/a\u003e\u003c/code\u003e tied to the the right?\n\u003c/p\u003e",
          "module": "Music.Theory.Duration.Annotation",
          "name": "da_tied_right",
          "package": "hmt",
          "signature": "Duration_A -\u003e Bool",
          "source": "src/Music-Theory-Duration-Annotation.html#da_tied_right",
          "type": "function"
        },
        "index": {
          "description": "Is Duration tied to the the right",
          "hierarchy": "Music Theory Duration Annotation",
          "module": "Music.Theory.Duration.Annotation",
          "name": "da_tied_right",
          "normalized": "Duration_A-\u003eBool",
          "package": "hmt",
          "signature": "Duration_A-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Duration-Annotation.html#v:da_tied_right"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAnnotate a sequence of \u003ccode\u003e\u003ca\u003eDuration_A\u003c/a\u003e\u003c/code\u003e as a tuplet.\n\u003c/p\u003e\u003cpre\u003e import Music.Theory.Duration.Name\n da_tuplet (3,2) [(quarter_note,[Tie_Left]),(eighth_note,[Tie_Right])]\n\u003c/pre\u003e",
          "module": "Music.Theory.Duration.Annotation",
          "name": "da_tuplet",
          "package": "hmt",
          "signature": "(Integer, Integer) -\u003e [Duration_A] -\u003e [Duration_A]",
          "source": "src/Music-Theory-Duration-Annotation.html#da_tuplet",
          "type": "function"
        },
        "index": {
          "description": "Annotate sequence of Duration as tuplet import Music.Theory.Duration.Name da tuplet quarter note Tie Left eighth note Tie Right",
          "hierarchy": "Music Theory Duration Annotation",
          "module": "Music.Theory.Duration.Annotation",
          "name": "da_tuplet",
          "normalized": "(Integer,Integer)-\u003e[Duration_A]-\u003e[Duration_A]",
          "package": "hmt",
          "signature": "(Integer,Integer)-\u003e[Duration_A]-\u003e[Duration_A]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Duration-Annotation.html#v:da_tuplet"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDoes \u003cem\u003ed\u003c/em\u003e have \u003ccode\u003e\u003ca\u003eTie_Left\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003eTie_Right\u003c/a\u003e\u003c/code\u003e?\n\u003c/p\u003e",
          "module": "Music.Theory.Duration.Annotation",
          "name": "duration_a_tied_lr",
          "package": "hmt",
          "signature": "Duration_A -\u003e (Bool, Bool)",
          "source": "src/Music-Theory-Duration-Annotation.html#duration_a_tied_lr",
          "type": "function"
        },
        "index": {
          "description": "Does have Tie Left and Tie Right",
          "hierarchy": "Music Theory Duration Annotation",
          "module": "Music.Theory.Duration.Annotation",
          "name": "duration_a_tied_lr",
          "normalized": "Duration_A-\u003e(Bool,Bool)",
          "package": "hmt",
          "signature": "Duration_A-\u003e(Bool,Bool)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Duration-Annotation.html#v:duration_a_tied_lr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGiven an \u003ccode\u003e\u003ca\u003eOrdering\u003c/a\u003e\u003c/code\u003e predicate where \u003ccode\u003e\u003ca\u003eLT\u003c/a\u003e\u003c/code\u003e opens a group, \u003ccode\u003e\u003ca\u003eGT\u003c/a\u003e\u003c/code\u003e\n closes a group, and \u003ccode\u003e\u003ca\u003eEQ\u003c/a\u003e\u003c/code\u003e continues current group, construct tree\n from list.\n\u003c/p\u003e\u003cpre\u003e let {l = \"a {b {c d} e f} g h i\"\n     ;t = group_tree (begin_end_cmp_eq '{' '}') l}\n in catMaybes (flatten t) == l\n\u003c/pre\u003e\u003cpre\u003e let d = putStrLn . drawTree . fmap show\n in d (group_tree (begin_end_cmp_eq '(' ')') \"a(b(cd)ef)ghi\")\n\u003c/pre\u003e",
          "module": "Music.Theory.Duration.Annotation",
          "name": "group_tree",
          "package": "hmt",
          "signature": "(a -\u003e Ordering) -\u003e [a] -\u003e Tree (Maybe a)",
          "source": "src/Music-Theory-Duration-Annotation.html#group_tree",
          "type": "function"
        },
        "index": {
          "description": "Given an Ordering predicate where LT opens group GT closes group and EQ continues current group construct tree from list let group tree begin end cmp eq in catMaybes flatten let putStrLn drawTree fmap show in group tree begin end cmp eq cd ef ghi",
          "hierarchy": "Music Theory Duration Annotation",
          "module": "Music.Theory.Duration.Annotation",
          "name": "group_tree",
          "normalized": "(a-\u003eOrdering)-\u003e[a]-\u003eTree(Maybe a)",
          "package": "hmt",
          "signature": "(a-\u003eOrdering)-\u003e[a]-\u003eTree(Maybe a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Duration-Annotation.html#v:group_tree"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003ezipWith\u003c/a\u003e\u003c/code\u003e variant that adopts the shape of the lhs.\n\u003c/p\u003e\u003cpre\u003e let {p = [Left 1,Right [2,3],Left 4]\n     ;q = \"abcd\"}\n in nn_reshape (,) p q == [Left (1,'a'),Right [(2,'b'),(3,'c')],Left (4,'d')]\n\u003c/pre\u003e",
          "module": "Music.Theory.Duration.Annotation",
          "name": "nn_reshape",
          "package": "hmt",
          "signature": "(a -\u003e b -\u003e c) -\u003e [Either a [a]] -\u003e [b] -\u003e [Either c [c]]",
          "source": "src/Music-Theory-Duration-Annotation.html#nn_reshape",
          "type": "function"
        },
        "index": {
          "description": "zipWith variant that adopts the shape of the lhs let Left Right Left abcd in nn reshape Left Right Left",
          "hierarchy": "Music Theory Duration Annotation",
          "module": "Music.Theory.Duration.Annotation",
          "name": "nn_reshape",
          "normalized": "(a-\u003eb-\u003ec)-\u003e[Either a[a]]-\u003e[b]-\u003e[Either c[c]]",
          "package": "hmt",
          "signature": "(a-\u003eb-\u003ec)-\u003e[Either a[a]]-\u003e[b]-\u003e[Either c[c]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Duration-Annotation.html#v:nn_reshape"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eVariant of \u003ccode\u003e\u003ca\u003ebreak_left\u003c/a\u003e\u003c/code\u003e that balances begin & end predicates.\n\u003c/p\u003e\u003cpre\u003e break_left (== ')') \"test (sep) _) balanced\"\n sep_balanced True (== '(') (== ')') \"test (sep) _) balanced\"\n sep_balanced False (== '(') (== ')') \"(test (sep) _) balanced\"\n\u003c/pre\u003e",
          "module": "Music.Theory.Duration.Annotation",
          "name": "sep_balanced",
          "package": "hmt",
          "signature": "Bool -\u003e (a -\u003e Bool) -\u003e (a -\u003e Bool) -\u003e [a] -\u003e ([a], [a])",
          "source": "src/Music-Theory-Duration-Annotation.html#sep_balanced",
          "type": "function"
        },
        "index": {
          "description": "Variant of break left that balances begin end predicates break left test sep balanced sep balanced True test sep balanced sep balanced False test sep balanced",
          "hierarchy": "Music Theory Duration Annotation",
          "module": "Music.Theory.Duration.Annotation",
          "name": "sep_balanced",
          "normalized": "Bool-\u003e(a-\u003eBool)-\u003e(a-\u003eBool)-\u003e[a]-\u003e([a],[a])",
          "package": "hmt",
          "signature": "Bool-\u003e(a-\u003eBool)-\u003e(a-\u003eBool)-\u003e[a]-\u003e([a],[a])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Duration-Annotation.html#v:sep_balanced"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eKeep right variant of \u003ccode\u003e\u003ca\u003ezip\u003c/a\u003e\u003c/code\u003e, unused rhs values are returned.\n\u003c/p\u003e\u003cpre\u003e zip_kr [1..4] ['a'..'f'] == ([(1,'a'),(2,'b'),(3,'c'),(4,'d')],\"ef\")\n\u003c/pre\u003e",
          "module": "Music.Theory.Duration.Annotation",
          "name": "zip_kr",
          "package": "hmt",
          "signature": "[a] -\u003e [b] -\u003e ([(a, b)], [b])",
          "source": "src/Music-Theory-Duration-Annotation.html#zip_kr",
          "type": "function"
        },
        "index": {
          "description": "Keep right variant of zip unused rhs values are returned zip kr ef",
          "hierarchy": "Music Theory Duration Annotation",
          "module": "Music.Theory.Duration.Annotation",
          "name": "zip_kr",
          "normalized": "[a]-\u003e[b]-\u003e([(a,b)],[b])",
          "package": "hmt",
          "signature": "[a]-\u003e[b]-\u003e([(a,b)],[b])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Duration-Annotation.html#v:zip_kr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eKeep right variant of \u003ccode\u003e\u003ca\u003ezipWith\u003c/a\u003e\u003c/code\u003e, unused rhs values are returned.\n\u003c/p\u003e\u003cpre\u003e zip_with_kr (,) [1..3] ['a'..'e'] == ([(1,'a'),(2,'b'),(3,'c')],\"de\")\n\u003c/pre\u003e",
          "module": "Music.Theory.Duration.Annotation",
          "name": "zip_with_kr",
          "package": "hmt",
          "signature": "(a -\u003e b -\u003e c) -\u003e [a] -\u003e [b] -\u003e ([c], [b])",
          "source": "src/Music-Theory-Duration-Annotation.html#zip_with_kr",
          "type": "function"
        },
        "index": {
          "description": "Keep right variant of zipWith unused rhs values are returned zip with kr de",
          "hierarchy": "Music Theory Duration Annotation",
          "module": "Music.Theory.Duration.Annotation",
          "name": "zip_with_kr",
          "normalized": "(a-\u003eb-\u003ec)-\u003e[a]-\u003e[b]-\u003e([c],[b])",
          "package": "hmt",
          "signature": "(a-\u003eb-\u003ec)-\u003e[a]-\u003e[b]-\u003e([c],[b])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Duration-Annotation.html#v:zip_with_kr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eAbbreviated names for \u003ccode\u003e\u003ca\u003eDuration\u003c/a\u003e\u003c/code\u003e values when written as literals.\n There are \u003cem\u003eletter\u003c/em\u003e names where \u003ccode\u003e\u003ca\u003ew\u003c/a\u003e\u003c/code\u003e is \u003ccode\u003e\u003ca\u003ewhole_note\u003c/a\u003e\u003c/code\u003e and so on, and\n \u003cem\u003enumerical\u003c/em\u003e names where \u003ccode\u003e\u003ca\u003e_4\u003c/a\u003e\u003c/code\u003e is \u003ccode\u003e\u003ca\u003equarter_note\u003c/a\u003e\u003c/code\u003e and so on.  In both\n cases a \u003ccode\u003e'\u003c/code\u003e extension means a \u003ccode\u003edot\u003c/code\u003e so that \u003ccode\u003e\u003ca\u003ee''\u003c/a\u003e\u003c/code\u003e is a double\n dotted \u003ccode\u003e\u003ca\u003eeighth_note\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e zipWith duration_compare_meq [e,e,e,e'] [e,s,q,e] == [EQ,GT,LT,GT]\n zipWith sum_dur [e,q,q'] [e,e,e] == [Just q,Just q',Just h]\n zipWith sum_dur' [e,q,q'] [e,e,e] == [q,q',h]\n\u003c/pre\u003e\u003c/div\u003e",
          "module": "Music.Theory.Duration.Name.Abbreviation",
          "name": "Abbreviation",
          "package": "hmt",
          "source": "src/Music-Theory-Duration-Name-Abbreviation.html",
          "type": "module"
        },
        "index": {
          "description": "Abbreviated names for Duration values when written as literals There are letter names where is whole note and so on and numerical names where is quarter note and so on In both cases extension means dot so that is double dotted eighth note zipWith duration compare meq EQ GT LT GT zipWith sum dur Just Just Just zipWith sum dur",
          "hierarchy": "Music Theory Duration Name Abbreviation",
          "module": "Music.Theory.Duration.Name.Abbreviation",
          "name": "Abbreviation",
          "package": "hmt",
          "partial": "Abbreviation",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Duration-Name-Abbreviation.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Duration.Name.Abbreviation",
          "name": "_1",
          "package": "hmt",
          "signature": "Duration",
          "source": "src/Music-Theory-Duration-Name-Abbreviation.html#_1",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Duration Name Abbreviation",
          "module": "Music.Theory.Duration.Name.Abbreviation",
          "name": "_1",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Duration-Name-Abbreviation.html#v:_1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Duration.Name.Abbreviation",
          "name": "_1'",
          "package": "hmt",
          "signature": "Duration",
          "source": "src/Music-Theory-Duration-Name-Abbreviation.html#_1%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Duration Name Abbreviation",
          "module": "Music.Theory.Duration.Name.Abbreviation",
          "name": "_1'",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Duration-Name-Abbreviation.html#v:_1-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Duration.Name.Abbreviation",
          "name": "_1''",
          "package": "hmt",
          "signature": "Duration",
          "source": "src/Music-Theory-Duration-Name-Abbreviation.html#_1%27%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Duration Name Abbreviation",
          "module": "Music.Theory.Duration.Name.Abbreviation",
          "name": "_1''",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Duration-Name-Abbreviation.html#v:_1-39--39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Duration.Name.Abbreviation",
          "name": "_16",
          "package": "hmt",
          "signature": "Duration",
          "source": "src/Music-Theory-Duration-Name-Abbreviation.html#_16",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Duration Name Abbreviation",
          "module": "Music.Theory.Duration.Name.Abbreviation",
          "name": "_16",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Duration-Name-Abbreviation.html#v:_16"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Duration.Name.Abbreviation",
          "name": "_16'",
          "package": "hmt",
          "signature": "Duration",
          "source": "src/Music-Theory-Duration-Name-Abbreviation.html#_16%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Duration Name Abbreviation",
          "module": "Music.Theory.Duration.Name.Abbreviation",
          "name": "_16'",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Duration-Name-Abbreviation.html#v:_16-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Duration.Name.Abbreviation",
          "name": "_16''",
          "package": "hmt",
          "signature": "Duration",
          "source": "src/Music-Theory-Duration-Name-Abbreviation.html#_16%27%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Duration Name Abbreviation",
          "module": "Music.Theory.Duration.Name.Abbreviation",
          "name": "_16''",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Duration-Name-Abbreviation.html#v:_16-39--39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Duration.Name.Abbreviation",
          "name": "_2",
          "package": "hmt",
          "signature": "Duration",
          "source": "src/Music-Theory-Duration-Name-Abbreviation.html#_2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Duration Name Abbreviation",
          "module": "Music.Theory.Duration.Name.Abbreviation",
          "name": "_2",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Duration-Name-Abbreviation.html#v:_2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Duration.Name.Abbreviation",
          "name": "_2'",
          "package": "hmt",
          "signature": "Duration",
          "source": "src/Music-Theory-Duration-Name-Abbreviation.html#_2%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Duration Name Abbreviation",
          "module": "Music.Theory.Duration.Name.Abbreviation",
          "name": "_2'",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Duration-Name-Abbreviation.html#v:_2-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Duration.Name.Abbreviation",
          "name": "_2''",
          "package": "hmt",
          "signature": "Duration",
          "source": "src/Music-Theory-Duration-Name-Abbreviation.html#_2%27%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Duration Name Abbreviation",
          "module": "Music.Theory.Duration.Name.Abbreviation",
          "name": "_2''",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Duration-Name-Abbreviation.html#v:_2-39--39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Duration.Name.Abbreviation",
          "name": "_32",
          "package": "hmt",
          "signature": "Duration",
          "source": "src/Music-Theory-Duration-Name-Abbreviation.html#_32",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Duration Name Abbreviation",
          "module": "Music.Theory.Duration.Name.Abbreviation",
          "name": "_32",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Duration-Name-Abbreviation.html#v:_32"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Duration.Name.Abbreviation",
          "name": "_32'",
          "package": "hmt",
          "signature": "Duration",
          "source": "src/Music-Theory-Duration-Name-Abbreviation.html#_32%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Duration Name Abbreviation",
          "module": "Music.Theory.Duration.Name.Abbreviation",
          "name": "_32'",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Duration-Name-Abbreviation.html#v:_32-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Duration.Name.Abbreviation",
          "name": "_32''",
          "package": "hmt",
          "signature": "Duration",
          "source": "src/Music-Theory-Duration-Name-Abbreviation.html#_32%27%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Duration Name Abbreviation",
          "module": "Music.Theory.Duration.Name.Abbreviation",
          "name": "_32''",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Duration-Name-Abbreviation.html#v:_32-39--39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Duration.Name.Abbreviation",
          "name": "_4",
          "package": "hmt",
          "signature": "Duration",
          "source": "src/Music-Theory-Duration-Name-Abbreviation.html#_4",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Duration Name Abbreviation",
          "module": "Music.Theory.Duration.Name.Abbreviation",
          "name": "_4",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Duration-Name-Abbreviation.html#v:_4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Duration.Name.Abbreviation",
          "name": "_4'",
          "package": "hmt",
          "signature": "Duration",
          "source": "src/Music-Theory-Duration-Name-Abbreviation.html#_4%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Duration Name Abbreviation",
          "module": "Music.Theory.Duration.Name.Abbreviation",
          "name": "_4'",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Duration-Name-Abbreviation.html#v:_4-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Duration.Name.Abbreviation",
          "name": "_4''",
          "package": "hmt",
          "signature": "Duration",
          "source": "src/Music-Theory-Duration-Name-Abbreviation.html#_4%27%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Duration Name Abbreviation",
          "module": "Music.Theory.Duration.Name.Abbreviation",
          "name": "_4''",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Duration-Name-Abbreviation.html#v:_4-39--39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Duration.Name.Abbreviation",
          "name": "_8",
          "package": "hmt",
          "signature": "Duration",
          "source": "src/Music-Theory-Duration-Name-Abbreviation.html#_8",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Duration Name Abbreviation",
          "module": "Music.Theory.Duration.Name.Abbreviation",
          "name": "_8",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Duration-Name-Abbreviation.html#v:_8"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Duration.Name.Abbreviation",
          "name": "_8'",
          "package": "hmt",
          "signature": "Duration",
          "source": "src/Music-Theory-Duration-Name-Abbreviation.html#_8%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Duration Name Abbreviation",
          "module": "Music.Theory.Duration.Name.Abbreviation",
          "name": "_8'",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Duration-Name-Abbreviation.html#v:_8-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Duration.Name.Abbreviation",
          "name": "_8''",
          "package": "hmt",
          "signature": "Duration",
          "source": "src/Music-Theory-Duration-Name-Abbreviation.html#_8%27%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Duration Name Abbreviation",
          "module": "Music.Theory.Duration.Name.Abbreviation",
          "name": "_8''",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Duration-Name-Abbreviation.html#v:_8-39--39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Duration.Name.Abbreviation",
          "name": "e",
          "package": "hmt",
          "signature": "Duration",
          "source": "src/Music-Theory-Duration-Name-Abbreviation.html#e",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Duration Name Abbreviation",
          "module": "Music.Theory.Duration.Name.Abbreviation",
          "name": "e",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Duration-Name-Abbreviation.html#v:e"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Duration.Name.Abbreviation",
          "name": "e'",
          "package": "hmt",
          "signature": "Duration",
          "source": "src/Music-Theory-Duration-Name-Abbreviation.html#e%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Duration Name Abbreviation",
          "module": "Music.Theory.Duration.Name.Abbreviation",
          "name": "e'",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Duration-Name-Abbreviation.html#v:e-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Duration.Name.Abbreviation",
          "name": "e''",
          "package": "hmt",
          "signature": "Duration",
          "source": "src/Music-Theory-Duration-Name-Abbreviation.html#e%27%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Duration Name Abbreviation",
          "module": "Music.Theory.Duration.Name.Abbreviation",
          "name": "e''",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Duration-Name-Abbreviation.html#v:e-39--39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Duration.Name.Abbreviation",
          "name": "h",
          "package": "hmt",
          "signature": "Duration",
          "source": "src/Music-Theory-Duration-Name-Abbreviation.html#h",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Duration Name Abbreviation",
          "module": "Music.Theory.Duration.Name.Abbreviation",
          "name": "h",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Duration-Name-Abbreviation.html#v:h"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Duration.Name.Abbreviation",
          "name": "h'",
          "package": "hmt",
          "signature": "Duration",
          "source": "src/Music-Theory-Duration-Name-Abbreviation.html#h%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Duration Name Abbreviation",
          "module": "Music.Theory.Duration.Name.Abbreviation",
          "name": "h'",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Duration-Name-Abbreviation.html#v:h-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Duration.Name.Abbreviation",
          "name": "h''",
          "package": "hmt",
          "signature": "Duration",
          "source": "src/Music-Theory-Duration-Name-Abbreviation.html#h%27%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Duration Name Abbreviation",
          "module": "Music.Theory.Duration.Name.Abbreviation",
          "name": "h''",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Duration-Name-Abbreviation.html#v:h-39--39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Duration.Name.Abbreviation",
          "name": "q",
          "package": "hmt",
          "signature": "Duration",
          "source": "src/Music-Theory-Duration-Name-Abbreviation.html#q",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Duration Name Abbreviation",
          "module": "Music.Theory.Duration.Name.Abbreviation",
          "name": "q",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Duration-Name-Abbreviation.html#v:q"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Duration.Name.Abbreviation",
          "name": "q'",
          "package": "hmt",
          "signature": "Duration",
          "source": "src/Music-Theory-Duration-Name-Abbreviation.html#q%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Duration Name Abbreviation",
          "module": "Music.Theory.Duration.Name.Abbreviation",
          "name": "q'",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Duration-Name-Abbreviation.html#v:q-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Duration.Name.Abbreviation",
          "name": "q''",
          "package": "hmt",
          "signature": "Duration",
          "source": "src/Music-Theory-Duration-Name-Abbreviation.html#q%27%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Duration Name Abbreviation",
          "module": "Music.Theory.Duration.Name.Abbreviation",
          "name": "q''",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Duration-Name-Abbreviation.html#v:q-39--39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Duration.Name.Abbreviation",
          "name": "s",
          "package": "hmt",
          "signature": "Duration",
          "source": "src/Music-Theory-Duration-Name-Abbreviation.html#s",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Duration Name Abbreviation",
          "module": "Music.Theory.Duration.Name.Abbreviation",
          "name": "s",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Duration-Name-Abbreviation.html#v:s"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Duration.Name.Abbreviation",
          "name": "s'",
          "package": "hmt",
          "signature": "Duration",
          "source": "src/Music-Theory-Duration-Name-Abbreviation.html#s%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Duration Name Abbreviation",
          "module": "Music.Theory.Duration.Name.Abbreviation",
          "name": "s'",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Duration-Name-Abbreviation.html#v:s-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Duration.Name.Abbreviation",
          "name": "s''",
          "package": "hmt",
          "signature": "Duration",
          "source": "src/Music-Theory-Duration-Name-Abbreviation.html#s%27%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Duration Name Abbreviation",
          "module": "Music.Theory.Duration.Name.Abbreviation",
          "name": "s''",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Duration-Name-Abbreviation.html#v:s-39--39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Duration.Name.Abbreviation",
          "name": "w",
          "package": "hmt",
          "signature": "Duration",
          "source": "src/Music-Theory-Duration-Name-Abbreviation.html#w",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Duration Name Abbreviation",
          "module": "Music.Theory.Duration.Name.Abbreviation",
          "name": "w",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Duration-Name-Abbreviation.html#v:w"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Duration.Name.Abbreviation",
          "name": "w'",
          "package": "hmt",
          "signature": "Duration",
          "source": "src/Music-Theory-Duration-Name-Abbreviation.html#w%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Duration Name Abbreviation",
          "module": "Music.Theory.Duration.Name.Abbreviation",
          "name": "w'",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Duration-Name-Abbreviation.html#v:w-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Duration.Name.Abbreviation",
          "name": "w''",
          "package": "hmt",
          "signature": "Duration",
          "source": "src/Music-Theory-Duration-Name-Abbreviation.html#w%27%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Duration Name Abbreviation",
          "module": "Music.Theory.Duration.Name.Abbreviation",
          "name": "w''",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Duration-Name-Abbreviation.html#v:w-39--39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eNames for common music notation durations.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Music.Theory.Duration.Name",
          "name": "Name",
          "package": "hmt",
          "source": "src/Music-Theory-Duration-Name.html",
          "type": "module"
        },
        "index": {
          "description": "Names for common music notation durations",
          "hierarchy": "Music Theory Duration Name",
          "module": "Music.Theory.Duration.Name",
          "name": "Name",
          "package": "hmt",
          "partial": "Name",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Duration-Name.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Duration.Name",
          "name": "breve",
          "package": "hmt",
          "signature": "Duration",
          "source": "src/Music-Theory-Duration-Name.html#breve",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Duration Name",
          "module": "Music.Theory.Duration.Name",
          "name": "breve",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Duration-Name.html#v:breve"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Duration.Name",
          "name": "dotted_breve",
          "package": "hmt",
          "signature": "Duration",
          "source": "src/Music-Theory-Duration-Name.html#dotted_breve",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Duration Name",
          "module": "Music.Theory.Duration.Name",
          "name": "dotted_breve",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Duration-Name.html#v:dotted_breve"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Duration.Name",
          "name": "dotted_eighth_note",
          "package": "hmt",
          "signature": "Duration",
          "source": "src/Music-Theory-Duration-Name.html#dotted_eighth_note",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Duration Name",
          "module": "Music.Theory.Duration.Name",
          "name": "dotted_eighth_note",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Duration-Name.html#v:dotted_eighth_note"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Duration.Name",
          "name": "dotted_half_note",
          "package": "hmt",
          "signature": "Duration",
          "source": "src/Music-Theory-Duration-Name.html#dotted_half_note",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Duration Name",
          "module": "Music.Theory.Duration.Name",
          "name": "dotted_half_note",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Duration-Name.html#v:dotted_half_note"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Duration.Name",
          "name": "dotted_quarter_note",
          "package": "hmt",
          "signature": "Duration",
          "source": "src/Music-Theory-Duration-Name.html#dotted_quarter_note",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Duration Name",
          "module": "Music.Theory.Duration.Name",
          "name": "dotted_quarter_note",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Duration-Name.html#v:dotted_quarter_note"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Duration.Name",
          "name": "dotted_sixteenth_note",
          "package": "hmt",
          "signature": "Duration",
          "source": "src/Music-Theory-Duration-Name.html#dotted_sixteenth_note",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Duration Name",
          "module": "Music.Theory.Duration.Name",
          "name": "dotted_sixteenth_note",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Duration-Name.html#v:dotted_sixteenth_note"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Duration.Name",
          "name": "dotted_thirtysecond_note",
          "package": "hmt",
          "signature": "Duration",
          "source": "src/Music-Theory-Duration-Name.html#dotted_thirtysecond_note",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Duration Name",
          "module": "Music.Theory.Duration.Name",
          "name": "dotted_thirtysecond_note",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Duration-Name.html#v:dotted_thirtysecond_note"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Duration.Name",
          "name": "dotted_whole_note",
          "package": "hmt",
          "signature": "Duration",
          "source": "src/Music-Theory-Duration-Name.html#dotted_whole_note",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Duration Name",
          "module": "Music.Theory.Duration.Name",
          "name": "dotted_whole_note",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Duration-Name.html#v:dotted_whole_note"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Duration.Name",
          "name": "double_dotted_breve",
          "package": "hmt",
          "signature": "Duration",
          "source": "src/Music-Theory-Duration-Name.html#double_dotted_breve",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Duration Name",
          "module": "Music.Theory.Duration.Name",
          "name": "double_dotted_breve",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Duration-Name.html#v:double_dotted_breve"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Duration.Name",
          "name": "double_dotted_eighth_note",
          "package": "hmt",
          "signature": "Duration",
          "source": "src/Music-Theory-Duration-Name.html#double_dotted_eighth_note",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Duration Name",
          "module": "Music.Theory.Duration.Name",
          "name": "double_dotted_eighth_note",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Duration-Name.html#v:double_dotted_eighth_note"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Duration.Name",
          "name": "double_dotted_half_note",
          "package": "hmt",
          "signature": "Duration",
          "source": "src/Music-Theory-Duration-Name.html#double_dotted_half_note",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Duration Name",
          "module": "Music.Theory.Duration.Name",
          "name": "double_dotted_half_note",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Duration-Name.html#v:double_dotted_half_note"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Duration.Name",
          "name": "double_dotted_quarter_note",
          "package": "hmt",
          "signature": "Duration",
          "source": "src/Music-Theory-Duration-Name.html#double_dotted_quarter_note",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Duration Name",
          "module": "Music.Theory.Duration.Name",
          "name": "double_dotted_quarter_note",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Duration-Name.html#v:double_dotted_quarter_note"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Duration.Name",
          "name": "double_dotted_sixteenth_note",
          "package": "hmt",
          "signature": "Duration",
          "source": "src/Music-Theory-Duration-Name.html#double_dotted_sixteenth_note",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Duration Name",
          "module": "Music.Theory.Duration.Name",
          "name": "double_dotted_sixteenth_note",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Duration-Name.html#v:double_dotted_sixteenth_note"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Duration.Name",
          "name": "double_dotted_thirtysecond_note",
          "package": "hmt",
          "signature": "Duration",
          "source": "src/Music-Theory-Duration-Name.html#double_dotted_thirtysecond_note",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Duration Name",
          "module": "Music.Theory.Duration.Name",
          "name": "double_dotted_thirtysecond_note",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Duration-Name.html#v:double_dotted_thirtysecond_note"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Duration.Name",
          "name": "double_dotted_whole_note",
          "package": "hmt",
          "signature": "Duration",
          "source": "src/Music-Theory-Duration-Name.html#double_dotted_whole_note",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Duration Name",
          "module": "Music.Theory.Duration.Name",
          "name": "double_dotted_whole_note",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Duration-Name.html#v:double_dotted_whole_note"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Duration.Name",
          "name": "eighth_note",
          "package": "hmt",
          "signature": "Duration",
          "source": "src/Music-Theory-Duration-Name.html#eighth_note",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Duration Name",
          "module": "Music.Theory.Duration.Name",
          "name": "eighth_note",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Duration-Name.html#v:eighth_note"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Duration.Name",
          "name": "half_note",
          "package": "hmt",
          "signature": "Duration",
          "source": "src/Music-Theory-Duration-Name.html#half_note",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Duration Name",
          "module": "Music.Theory.Duration.Name",
          "name": "half_note",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Duration-Name.html#v:half_note"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Duration.Name",
          "name": "quarter_note",
          "package": "hmt",
          "signature": "Duration",
          "source": "src/Music-Theory-Duration-Name.html#quarter_note",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Duration Name",
          "module": "Music.Theory.Duration.Name",
          "name": "quarter_note",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Duration-Name.html#v:quarter_note"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Duration.Name",
          "name": "sixteenth_note",
          "package": "hmt",
          "signature": "Duration",
          "source": "src/Music-Theory-Duration-Name.html#sixteenth_note",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Duration Name",
          "module": "Music.Theory.Duration.Name",
          "name": "sixteenth_note",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Duration-Name.html#v:sixteenth_note"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Duration.Name",
          "name": "thirtysecond_note",
          "package": "hmt",
          "signature": "Duration",
          "source": "src/Music-Theory-Duration-Name.html#thirtysecond_note",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Duration Name",
          "module": "Music.Theory.Duration.Name",
          "name": "thirtysecond_note",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Duration-Name.html#v:thirtysecond_note"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Duration.Name",
          "name": "whole_note",
          "package": "hmt",
          "signature": "Duration",
          "source": "src/Music-Theory-Duration-Name.html#whole_note",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Duration Name",
          "module": "Music.Theory.Duration.Name",
          "name": "whole_note",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Duration-Name.html#v:whole_note"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003e\u003ccode\u003e\u003ca\u003eRQ\u003c/a\u003e\u003c/code\u003e sub-divisions.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Music.Theory.Duration.RQ.Division",
          "name": "Division",
          "package": "hmt",
          "source": "src/Music-Theory-Duration-RQ-Division.html",
          "type": "module"
        },
        "index": {
          "description": "RQ sub-divisions",
          "hierarchy": "Music Theory Duration RQ Division",
          "module": "Music.Theory.Duration.RQ.Division",
          "name": "Division",
          "package": "hmt",
          "partial": "Division",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Duration-RQ-Division.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eVariant of \u003ccode\u003e\u003ca\u003eRQ_Div\u003c/a\u003e\u003c/code\u003e where \u003cem\u003en\u003c/em\u003e is \u003ccode\u003e1\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Music.Theory.Duration.RQ.Division",
          "name": "RQ1_Div",
          "package": "hmt",
          "source": "src/Music-Theory-Duration-RQ-Division.html#RQ1_Div",
          "type": "type"
        },
        "index": {
          "description": "Variant of RQ Div where is",
          "hierarchy": "Music Theory Duration RQ Division",
          "module": "Music.Theory.Duration.RQ.Division",
          "name": "RQ1_Div",
          "package": "hmt",
          "partial": "RQ Div",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Duration-RQ-Division.html#t:RQ1_Div"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDivisions of \u003cem\u003en\u003c/em\u003e \u003ccode\u003e\u003ca\u003eRQ\u003c/a\u003e\u003c/code\u003e into \u003cem\u003ei\u003c/em\u003e equal parts grouped as \u003cem\u003ej\u003c/em\u003e.\n A quarter and eighth note triplet is written \u003ccode\u003e(1,1,[2,1],False)\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Music.Theory.Duration.RQ.Division",
          "name": "RQ_Div",
          "package": "hmt",
          "source": "src/Music-Theory-Duration-RQ-Division.html#RQ_Div",
          "type": "type"
        },
        "index": {
          "description": "Divisions of RQ into equal parts grouped as quarter and eighth note triplet is written False",
          "hierarchy": "Music Theory Duration RQ Division",
          "module": "Music.Theory.Duration.RQ.Division",
          "name": "RQ_Div",
          "package": "hmt",
          "partial": "RQ Div",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Duration-RQ-Division.html#t:RQ_Div"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePartitions of an \u003ccode\u003e\u003ca\u003eIntegral\u003c/a\u003e\u003c/code\u003e that sum to \u003cem\u003en\u003c/em\u003e.  This includes the\n two 'trivial paritions, into a set \u003cem\u003en\u003c/em\u003e \u003ccode\u003e1\u003c/code\u003e, and a set of \u003ccode\u003e1\u003c/code\u003e \u003cem\u003en\u003c/em\u003e.\n\u003c/p\u003e\u003cpre\u003e partitions_sum 4 == [[1,1,1,1],[2,1,1],[2,2],[3,1],[4]]\n\u003c/pre\u003e\u003cpre\u003e map (length . partitions_sum) [9..15] == [30,42,56,77,101,135,176]\n\u003c/pre\u003e",
          "module": "Music.Theory.Duration.RQ.Division",
          "name": "partitions_sum",
          "package": "hmt",
          "signature": "i -\u003e [[i]]",
          "source": "src/Music-Theory-Duration-RQ-Division.html#partitions_sum",
          "type": "function"
        },
        "index": {
          "description": "Partitions of an Integral that sum to This includes the two trivial paritions into set and set of partitions sum map length partitions sum",
          "hierarchy": "Music Theory Duration RQ Division",
          "module": "Music.Theory.Duration.RQ.Division",
          "name": "partitions_sum",
          "normalized": "a-\u003e[[a]]",
          "package": "hmt",
          "signature": "i-\u003e[[i]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Duration-RQ-Division.html#v:partitions_sum"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003emultiset_permutations\u003c/a\u003e\u003c/code\u003e of \u003ccode\u003e\u003ca\u003epartitions_sum\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e map (length . partitions_sum_p) [9..12] == [256,512,1024,2048]\n\u003c/pre\u003e",
          "module": "Music.Theory.Duration.RQ.Division",
          "name": "partitions_sum_p",
          "package": "hmt",
          "signature": "i -\u003e [[i]]",
          "source": "src/Music-Theory-Duration-RQ-Division.html#partitions_sum_p",
          "type": "function"
        },
        "index": {
          "description": "The multiset permutations of partitions sum map length partitions sum",
          "hierarchy": "Music Theory Duration RQ Division",
          "module": "Music.Theory.Duration.RQ.Division",
          "name": "partitions_sum_p",
          "normalized": "a-\u003e[[a]]",
          "package": "hmt",
          "signature": "i-\u003e[[i]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Duration-RQ-Division.html#v:partitions_sum_p"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLift \u003ccode\u003e\u003ca\u003eRQ1_Div\u003c/a\u003e\u003c/code\u003e to \u003ccode\u003e\u003ca\u003eRQ_Div\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Music.Theory.Duration.RQ.Division",
          "name": "rq1_div_to_rq_div",
          "package": "hmt",
          "signature": "RQ1_Div -\u003e RQ_Div",
          "source": "src/Music-Theory-Duration-RQ-Division.html#rq1_div_to_rq_div",
          "type": "function"
        },
        "index": {
          "description": "Lift RQ1 Div to RQ Div",
          "hierarchy": "Music Theory Duration RQ Division",
          "module": "Music.Theory.Duration.RQ.Division",
          "name": "rq1_div_to_rq_div",
          "normalized": "RQ Div-\u003eRQ_Div",
          "package": "hmt",
          "signature": "RQ Div-\u003eRQ_Div",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Duration-RQ-Division.html#v:rq1_div_to_rq_div"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe set of all \u003ccode\u003e\u003ca\u003eRQ1_Div\u003c/a\u003e\u003c/code\u003e that sum to \u003cem\u003en\u003c/em\u003e, a variant on\n \u003ccode\u003e\u003ca\u003epartitions_sum_p\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e map (length . rq1_div_univ) [3..5] == [8,16,32]\n map (length . rq1_div_univ) [9..12] == [512,1024,2048,4096]\n\u003c/pre\u003e",
          "module": "Music.Theory.Duration.RQ.Division",
          "name": "rq1_div_univ",
          "package": "hmt",
          "signature": "Integer -\u003e [RQ1_Div]",
          "source": "src/Music-Theory-Duration-RQ-Division.html#rq1_div_univ",
          "type": "function"
        },
        "index": {
          "description": "The set of all RQ1 Div that sum to variant on partitions sum map length rq1 div univ map length rq1 div univ",
          "hierarchy": "Music Theory Duration RQ Division",
          "module": "Music.Theory.Duration.RQ.Division",
          "name": "rq1_div_univ",
          "normalized": "Integer-\u003e[RQ Div]",
          "package": "hmt",
          "signature": "Integer-\u003e[RQ Div]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Duration-RQ-Division.html#v:rq1_div_univ"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Duration.RQ.Division",
          "name": "rq_div_mm_verify",
          "package": "hmt",
          "signature": "Int -\u003e [RQ_Div] -\u003e [(Integer, [RQ])]",
          "source": "src/Music-Theory-Duration-RQ-Division.html#rq_div_mm_verify",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Duration RQ Division",
          "module": "Music.Theory.Duration.RQ.Division",
          "name": "rq_div_mm_verify",
          "normalized": "Int-\u003e[RQ_Div]-\u003e[(Integer,[RQ])]",
          "package": "hmt",
          "signature": "Int-\u003e[RQ_Div]-\u003e[(Integer,[RQ])]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Duration-RQ-Division.html#v:rq_div_mm_verify"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTransform sequence of \u003ccode\u003e\u003ca\u003eRQ_Div\u003c/a\u003e\u003c/code\u003e into sequence of \u003ccode\u003e\u003ca\u003eRQ\u003c/a\u003e\u003c/code\u003e, discarding\n any final tie.\n\u003c/p\u003e\u003cpre\u003e let q = [(1,5,[1,3,1],True),(1/2,6,[3,1,2],True)]\n in rq_div_seq_rq q == [1/5,3/5,9/20,1/12,1/6]\n\u003c/pre\u003e",
          "module": "Music.Theory.Duration.RQ.Division",
          "name": "rq_div_seq_rq",
          "package": "hmt",
          "signature": "[RQ_Div] -\u003e [RQ]",
          "source": "src/Music-Theory-Duration-RQ-Division.html#rq_div_seq_rq",
          "type": "function"
        },
        "index": {
          "description": "Transform sequence of RQ Div into sequence of RQ discarding any final tie let True True in rq div seq rq",
          "hierarchy": "Music Theory Duration RQ Division",
          "module": "Music.Theory.Duration.RQ.Division",
          "name": "rq_div_seq_rq",
          "normalized": "[RQ_Div]-\u003e[RQ]",
          "package": "hmt",
          "signature": "[RQ_Div]-\u003e[RQ]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Duration-RQ-Division.html#v:rq_div_seq_rq"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTranslate from \u003ccode\u003e\u003ca\u003eRQ_Div\u003c/a\u003e\u003c/code\u003e to a sequence of \u003ccode\u003e\u003ca\u003eRQ\u003c/a\u003e\u003c/code\u003e values.\n\u003c/p\u003e\u003cpre\u003e rq_div_to_rq_set_t (1,5,[1,3,1],True) == ([1/5,3/5,1/5],True)\n rq_div_to_rq_set_t (1/2,6,[3,1,2],False) == ([1/4,1/12,1/6],False)\n\u003c/pre\u003e",
          "module": "Music.Theory.Duration.RQ.Division",
          "name": "rq_div_to_rq_set_t",
          "package": "hmt",
          "signature": "RQ_Div -\u003e ([RQ], Tied_Right)",
          "source": "src/Music-Theory-Duration-RQ-Division.html#rq_div_to_rq_set_t",
          "type": "function"
        },
        "index": {
          "description": "Translate from RQ Div to sequence of RQ values rq div to rq set True True rq div to rq set False False",
          "hierarchy": "Music Theory Duration RQ Division",
          "module": "Music.Theory.Duration.RQ.Division",
          "name": "rq_div_to_rq_set_t",
          "normalized": "RQ_Div-\u003e([RQ],Tied_Right)",
          "package": "hmt",
          "signature": "RQ_Div-\u003e([RQ],Tied_Right)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Duration-RQ-Division.html#v:rq_div_to_rq_set_t"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eVerify that grouping \u003cem\u003ej\u003c/em\u003e sums to the divisor \u003cem\u003ei\u003c/em\u003e.\n\u003c/p\u003e",
          "module": "Music.Theory.Duration.RQ.Division",
          "name": "rq_div_verify",
          "package": "hmt",
          "signature": "RQ_Div -\u003e Bool",
          "source": "src/Music-Theory-Duration-RQ-Division.html#rq_div_verify",
          "type": "function"
        },
        "index": {
          "description": "Verify that grouping sums to the divisor",
          "hierarchy": "Music Theory Duration RQ Division",
          "module": "Music.Theory.Duration.RQ.Division",
          "name": "rq_div_verify",
          "normalized": "RQ_Div-\u003eBool",
          "package": "hmt",
          "signature": "RQ_Div-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Duration-RQ-Division.html#v:rq_div_verify"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTranslate from result of \u003ccode\u003e\u003ca\u003erq_div_to_rq_set_t\u003c/a\u003e\u003c/code\u003e to seqeunce of \u003ccode\u003e\u003ca\u003eRQ_T\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e rq_set_t_to_rqt ([1/5,3/5,1/5],True) == [(1/5,_f),(3/5,_f),(1/5,_t)]\n\u003c/pre\u003e",
          "module": "Music.Theory.Duration.RQ.Division",
          "name": "rq_set_t_to_rqt",
          "package": "hmt",
          "signature": "([RQ], Tied_Right) -\u003e [RQ_T]",
          "source": "src/Music-Theory-Duration-RQ-Division.html#rq_set_t_to_rqt",
          "type": "function"
        },
        "index": {
          "description": "Translate from result of rq div to rq set to seqeunce of RQ rq set to rqt True",
          "hierarchy": "Music Theory Duration RQ Division",
          "module": "Music.Theory.Duration.RQ.Division",
          "name": "rq_set_t_to_rqt",
          "normalized": "([RQ],Tied_Right)-\u003e[RQ_T]",
          "package": "hmt",
          "signature": "([RQ],Tied_Right)-\u003e[RQ_T]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Duration-RQ-Division.html#v:rq_set_t_to_rqt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003e\u003ccode\u003e\u003ca\u003eRQ\u003c/a\u003e\u003c/code\u003e values with \u003cem\u003etie right\u003c/em\u003e qualifier.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Music.Theory.Duration.RQ.Tied",
          "name": "Tied",
          "package": "hmt",
          "source": "src/Music-Theory-Duration-RQ-Tied.html",
          "type": "module"
        },
        "index": {
          "description": "RQ values with tie right qualifier",
          "hierarchy": "Music Theory Duration RQ Tied",
          "module": "Music.Theory.Duration.RQ.Tied",
          "name": "Tied",
          "package": "hmt",
          "partial": "Tied",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Duration-RQ-Tied.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eRQ\u003c/a\u003e\u003c/code\u003e with \u003cem\u003etie right\u003c/em\u003e.\n\u003c/p\u003e",
          "module": "Music.Theory.Duration.RQ.Tied",
          "name": "RQ_T",
          "package": "hmt",
          "source": "src/Music-Theory-Duration-RQ-Tied.html#RQ_T",
          "type": "type"
        },
        "index": {
          "description": "RQ with tie right",
          "hierarchy": "Music Theory Duration RQ Tied",
          "module": "Music.Theory.Duration.RQ.Tied",
          "name": "RQ_T",
          "package": "hmt",
          "partial": "RQ",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Duration-RQ-Tied.html#t:RQ_T"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eBoolean.\n\u003c/p\u003e",
          "module": "Music.Theory.Duration.RQ.Tied",
          "name": "Tied_Right",
          "package": "hmt",
          "source": "src/Music-Theory-Duration-RQ-Tied.html#Tied_Right",
          "type": "type"
        },
        "index": {
          "description": "Boolean",
          "hierarchy": "Music Theory Duration RQ Tied",
          "module": "Music.Theory.Duration.RQ.Tied",
          "name": "Tied_Right",
          "package": "hmt",
          "partial": "Tied Right",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Duration-RQ-Tied.html#t:Tied_Right"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIs \u003ccode\u003e\u003ca\u003eRQ_T\u003c/a\u003e\u003c/code\u003e tied right.\n\u003c/p\u003e",
          "module": "Music.Theory.Duration.RQ.Tied",
          "name": "is_tied_right",
          "package": "hmt",
          "signature": "RQ_T -\u003e Bool",
          "source": "src/Music-Theory-Duration-RQ-Tied.html#is_tied_right",
          "type": "function"
        },
        "index": {
          "description": "Is RQ tied right",
          "hierarchy": "Music Theory Duration RQ Tied",
          "module": "Music.Theory.Duration.RQ.Tied",
          "name": "is_tied_right",
          "normalized": "RQ_T-\u003eBool",
          "package": "hmt",
          "signature": "RQ_T-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Duration-RQ-Tied.html#v:is_tied_right"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTransform \u003ccode\u003e\u003ca\u003eRQ\u003c/a\u003e\u003c/code\u003e to untied \u003ccode\u003e\u003ca\u003eRQ_T\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e rq_rqt 3 == (3,F)\n\u003c/pre\u003e",
          "module": "Music.Theory.Duration.RQ.Tied",
          "name": "rq_rqt",
          "package": "hmt",
          "signature": "RQ -\u003e RQ_T",
          "source": "src/Music-Theory-Duration-RQ-Tied.html#rq_rqt",
          "type": "function"
        },
        "index": {
          "description": "Transform RQ to untied RQ rq rqt",
          "hierarchy": "Music Theory Duration RQ Tied",
          "module": "Music.Theory.Duration.RQ.Tied",
          "name": "rq_rqt",
          "normalized": "RQ-\u003eRQ_T",
          "package": "hmt",
          "signature": "RQ-\u003eRQ_T",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Duration-RQ-Tied.html#v:rq_rqt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTie last element only of list of \u003ccode\u003e\u003ca\u003eRQ\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e rq_tie_last [1,2,3] == [(1,F),(2,F),(3,T)]\n\u003c/pre\u003e",
          "module": "Music.Theory.Duration.RQ.Tied",
          "name": "rq_tie_last",
          "package": "hmt",
          "signature": "[RQ] -\u003e [RQ_T]",
          "source": "src/Music-Theory-Duration-RQ-Tied.html#rq_tie_last",
          "type": "function"
        },
        "index": {
          "description": "Tie last element only of list of RQ rq tie last",
          "hierarchy": "Music Theory Duration RQ Tied",
          "module": "Music.Theory.Duration.RQ.Tied",
          "name": "rq_tie_last",
          "normalized": "[RQ]-\u003e[RQ_T]",
          "package": "hmt",
          "signature": "[RQ]-\u003e[RQ_T]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Duration-RQ-Tied.html#v:rq_tie_last"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstruct \u003ccode\u003e\u003ca\u003eRQ_T\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Music.Theory.Duration.RQ.Tied",
          "name": "rqt",
          "package": "hmt",
          "signature": "Tied_Right -\u003e RQ -\u003e RQ_T",
          "source": "src/Music-Theory-Duration-RQ-Tied.html#rqt",
          "type": "function"
        },
        "index": {
          "description": "Construct RQ",
          "hierarchy": "Music Theory Duration RQ Tied",
          "module": "Music.Theory.Duration.RQ.Tied",
          "name": "rqt",
          "normalized": "Tied_Right-\u003eRQ-\u003eRQ_T",
          "package": "hmt",
          "signature": "Tied_Right-\u003eRQ-\u003eRQ_T",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Duration-RQ-Tied.html#v:rqt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eRQ_T\u003c/a\u003e\u003c/code\u003e variant of \u003ccode\u003e\u003ca\u003erq_can_notate\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Music.Theory.Duration.RQ.Tied",
          "name": "rqt_can_notate",
          "package": "hmt",
          "signature": "[RQ_T] -\u003e Bool",
          "source": "src/Music-Theory-Duration-RQ-Tied.html#rqt_can_notate",
          "type": "function"
        },
        "index": {
          "description": "RQ variant of rq can notate",
          "hierarchy": "Music Theory Duration RQ Tied",
          "module": "Music.Theory.Duration.RQ.Tied",
          "name": "rqt_can_notate",
          "normalized": "[RQ_T]-\u003eBool",
          "package": "hmt",
          "signature": "[RQ_T]-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Duration-RQ-Tied.html#v:rqt_can_notate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eRQ\u003c/a\u003e\u003c/code\u003e field of \u003ccode\u003e\u003ca\u003eRQ_T\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Music.Theory.Duration.RQ.Tied",
          "name": "rqt_rq",
          "package": "hmt",
          "signature": "RQ_T -\u003e RQ",
          "source": "src/Music-Theory-Duration-RQ-Tied.html#rqt_rq",
          "type": "function"
        },
        "index": {
          "description": "RQ field of RQ",
          "hierarchy": "Music Theory Duration RQ Tied",
          "module": "Music.Theory.Duration.RQ.Tied",
          "name": "rqt_rq",
          "normalized": "RQ_T-\u003eRQ",
          "package": "hmt",
          "signature": "RQ_T-\u003eRQ",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Duration-RQ-Tied.html#v:rqt_rq"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003econcatMap\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003erqt_to_cmn_l\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e rqt_set_to_cmn [(1,T),(5/4,F)] == [(1,T),(1,T),(1/4,F)]\n\u003c/pre\u003e\u003cpre\u003e rqt_set_to_cmn [(1/5,True),(1/20,False),(1/2,False),(1/4,True)]\n\u003c/pre\u003e",
          "module": "Music.Theory.Duration.RQ.Tied",
          "name": "rqt_set_to_cmn",
          "package": "hmt",
          "signature": "[RQ_T] -\u003e [RQ_T]",
          "source": "src/Music-Theory-Duration-RQ-Tied.html#rqt_set_to_cmn",
          "type": "function"
        },
        "index": {
          "description": "concatMap rqt to cmn rqt set to cmn rqt set to cmn True False False True",
          "hierarchy": "Music Theory Duration RQ Tied",
          "module": "Music.Theory.Duration.RQ.Tied",
          "name": "rqt_set_to_cmn",
          "normalized": "[RQ_T]-\u003e[RQ_T]",
          "package": "hmt",
          "signature": "[RQ_T]-\u003e[RQ_T]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Duration-RQ-Tied.html#v:rqt_set_to_cmn"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eTied\u003c/code\u003e field of \u003ccode\u003e\u003ca\u003eRQ_T\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Music.Theory.Duration.RQ.Tied",
          "name": "rqt_tied",
          "package": "hmt",
          "signature": "RQ_T -\u003e Tied_Right",
          "source": "src/Music-Theory-Duration-RQ-Tied.html#rqt_tied",
          "type": "function"
        },
        "index": {
          "description": "Tied field of RQ",
          "hierarchy": "Music Theory Duration RQ Tied",
          "module": "Music.Theory.Duration.RQ.Tied",
          "name": "rqt_tied",
          "normalized": "RQ_T-\u003eTied_Right",
          "package": "hmt",
          "signature": "RQ_T-\u003eTied_Right",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Duration-RQ-Tied.html#v:rqt_tied"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eRQ_T\u003c/a\u003e\u003c/code\u003e variant of \u003ccode\u003e\u003ca\u003erq_to_cmn\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e rqt_to_cmn (5,T) == Just ((4,T),(1,T))\n rqt_to_cmn (5/4,T) == Just ((1,T),(1/4,T))\n rqt_to_cmn (5/7,F) == Just ((4/7,T),(1/7,F))\n\u003c/pre\u003e",
          "module": "Music.Theory.Duration.RQ.Tied",
          "name": "rqt_to_cmn",
          "package": "hmt",
          "signature": "RQ_T -\u003e Maybe (RQ_T, RQ_T)",
          "source": "src/Music-Theory-Duration-RQ-Tied.html#rqt_to_cmn",
          "type": "function"
        },
        "index": {
          "description": "RQ variant of rq to cmn rqt to cmn Just rqt to cmn Just rqt to cmn Just",
          "hierarchy": "Music Theory Duration RQ Tied",
          "module": "Music.Theory.Duration.RQ.Tied",
          "name": "rqt_to_cmn",
          "normalized": "RQ_T-\u003eMaybe(RQ_T,RQ_T)",
          "package": "hmt",
          "signature": "RQ_T-\u003eMaybe(RQ_T,RQ_T)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Duration-RQ-Tied.html#v:rqt_to_cmn"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eList variant of \u003ccode\u003e\u003ca\u003erqt_to_cmn\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e rqt_to_cmn_l (5,T) == [(4,T),(1,T)]\n\u003c/pre\u003e",
          "module": "Music.Theory.Duration.RQ.Tied",
          "name": "rqt_to_cmn_l",
          "package": "hmt",
          "signature": "RQ_T -\u003e [RQ_T]",
          "source": "src/Music-Theory-Duration-RQ-Tied.html#rqt_to_cmn_l",
          "type": "function"
        },
        "index": {
          "description": "List variant of rqt to cmn rqt to cmn",
          "hierarchy": "Music Theory Duration RQ Tied",
          "module": "Music.Theory.Duration.RQ.Tied",
          "name": "rqt_to_cmn_l",
          "normalized": "RQ_T-\u003e[RQ_T]",
          "package": "hmt",
          "signature": "RQ_T-\u003e[RQ_T]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Duration-RQ-Tied.html#v:rqt_to_cmn_l"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTransform a list of \u003ccode\u003e\u003ca\u003eRQ_T\u003c/a\u003e\u003c/code\u003e to a list of \u003ccode\u003e\u003ca\u003eDuration_A\u003c/a\u003e\u003c/code\u003e.  The flag\n indicates if the initial value is tied left.\n\u003c/p\u003e\u003cpre\u003e rqt_to_duration_a False [(1,T),(1/4,T),(3/4,F)]\n\u003c/pre\u003e",
          "module": "Music.Theory.Duration.RQ.Tied",
          "name": "rqt_to_duration_a",
          "package": "hmt",
          "signature": "Bool -\u003e [RQ_T] -\u003e [Duration_A]",
          "source": "src/Music-Theory-Duration-RQ-Tied.html#rqt_to_duration_a",
          "type": "function"
        },
        "index": {
          "description": "Transform list of RQ to list of Duration The flag indicates if the initial value is tied left rqt to duration False",
          "hierarchy": "Music Theory Duration RQ Tied",
          "module": "Music.Theory.Duration.RQ.Tied",
          "name": "rqt_to_duration_a",
          "normalized": "Bool-\u003e[RQ_T]-\u003e[Duration_A]",
          "package": "hmt",
          "signature": "Bool-\u003e[RQ_T]-\u003e[Duration_A]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Duration-RQ-Tied.html#v:rqt_to_duration_a"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eRQ_T\u003c/a\u003e\u003c/code\u003e variant of \u003ccode\u003e\u003ca\u003erq_un_tuplet\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e rqt_un_tuplet (3,2) (1,T) == (3/2,T)\n\u003c/pre\u003e\u003cpre\u003e let f = rqt_un_tuplet (7,4)\n in map f [(2/7,F),(4/7,T),(1/7,F)] == [(1/2,F),(1,T),(1/4,F)]\n\u003c/pre\u003e",
          "module": "Music.Theory.Duration.RQ.Tied",
          "name": "rqt_un_tuplet",
          "package": "hmt",
          "signature": "(Integer, Integer) -\u003e RQ_T -\u003e RQ_T",
          "source": "src/Music-Theory-Duration-RQ-Tied.html#rqt_un_tuplet",
          "type": "function"
        },
        "index": {
          "description": "RQ variant of rq un tuplet rqt un tuplet let rqt un tuplet in map",
          "hierarchy": "Music Theory Duration RQ Tied",
          "module": "Music.Theory.Duration.RQ.Tied",
          "name": "rqt_un_tuplet",
          "normalized": "(Integer,Integer)-\u003eRQ_T-\u003eRQ_T",
          "package": "hmt",
          "signature": "(Integer,Integer)-\u003eRQ_T-\u003eRQ_T",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Duration-RQ-Tied.html#v:rqt_un_tuplet"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eRational quarter-note notation for durations.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Music.Theory.Duration.RQ",
          "name": "RQ",
          "package": "hmt",
          "source": "src/Music-Theory-Duration-RQ.html",
          "type": "module"
        },
        "index": {
          "description": "Rational quarter-note notation for durations",
          "hierarchy": "Music Theory Duration RQ",
          "module": "Music.Theory.Duration.RQ",
          "name": "RQ",
          "package": "hmt",
          "partial": "RQ",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Duration-RQ.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRational Quarter-Note\n\u003c/p\u003e",
          "module": "Music.Theory.Duration.RQ",
          "name": "RQ",
          "package": "hmt",
          "source": "src/Music-Theory-Duration-RQ.html#RQ",
          "type": "type"
        },
        "index": {
          "description": "Rational Quarter-Note",
          "hierarchy": "Music Theory Duration RQ",
          "module": "Music.Theory.Duration.RQ",
          "name": "RQ",
          "package": "hmt",
          "partial": "RQ",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Duration-RQ.html#t:RQ"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003ecompare\u003c/a\u003e\u003c/code\u003e function for \u003ccode\u003e\u003ca\u003eDuration\u003c/a\u003e\u003c/code\u003e via \u003ccode\u003e\u003ca\u003eduration_to_rq\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e half_note `duration_compare_rq` quarter_note == GT\n\u003c/pre\u003e",
          "module": "Music.Theory.Duration.RQ",
          "name": "duration_compare_rq",
          "package": "hmt",
          "signature": "Duration -\u003e Duration -\u003e Ordering",
          "source": "src/Music-Theory-Duration-RQ.html#duration_compare_rq",
          "type": "function"
        },
        "index": {
          "description": "compare function for Duration via duration to rq half note duration compare rq quarter note GT",
          "hierarchy": "Music Theory Duration RQ",
          "module": "Music.Theory.Duration.RQ",
          "name": "duration_compare_rq",
          "normalized": "Duration-\u003eDuration-\u003eOrdering",
          "package": "hmt",
          "signature": "Duration-\u003eDuration-\u003eOrdering",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Duration-RQ.html#v:duration_compare_rq"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert \u003ccode\u003e\u003ca\u003eDuration\u003c/a\u003e\u003c/code\u003e to \u003ccode\u003e\u003ca\u003eRQ\u003c/a\u003e\u003c/code\u003e value, see \u003ccode\u003e\u003ca\u003erq_to_duration\u003c/a\u003e\u003c/code\u003e for\n partial inverse.\n\u003c/p\u003e\u003cpre\u003e map duration_to_rq [half_note,dotted_quarter_note] == [2,3/2]\n\u003c/pre\u003e",
          "module": "Music.Theory.Duration.RQ",
          "name": "duration_to_rq",
          "package": "hmt",
          "signature": "Duration -\u003e RQ",
          "source": "src/Music-Theory-Duration-RQ.html#duration_to_rq",
          "type": "function"
        },
        "index": {
          "description": "Convert Duration to RQ value see rq to duration for partial inverse map duration to rq half note dotted quarter note",
          "hierarchy": "Music Theory Duration RQ",
          "module": "Music.Theory.Duration.RQ",
          "name": "duration_to_rq",
          "normalized": "Duration-\u003eRQ",
          "package": "hmt",
          "signature": "Duration-\u003eRQ",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Duration-RQ.html#v:duration_to_rq"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eApply dots to an \u003ccode\u003e\u003ca\u003eRQ\u003c/a\u003e\u003c/code\u003e duration.\n\u003c/p\u003e\u003cpre\u003e map (rq_apply_dots 1) [1,2] == [3/2,7/4]\n\u003c/pre\u003e",
          "module": "Music.Theory.Duration.RQ",
          "name": "rq_apply_dots",
          "package": "hmt",
          "signature": "RQ -\u003e Integer -\u003e RQ",
          "source": "src/Music-Theory-Duration-RQ.html#rq_apply_dots",
          "type": "function"
        },
        "index": {
          "description": "Apply dots to an RQ duration map rq apply dots",
          "hierarchy": "Music Theory Duration RQ",
          "module": "Music.Theory.Duration.RQ",
          "name": "rq_apply_dots",
          "normalized": "RQ-\u003eInteger-\u003eRQ",
          "package": "hmt",
          "signature": "RQ-\u003eInteger-\u003eRQ",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Duration-RQ.html#v:rq_apply_dots"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePredicate to determine if a segment can be notated either without\n a tuplet or with a single tuplet.\n\u003c/p\u003e\u003cpre\u003e rq_can_notate [1/2,1/4,1/4] == True\n rq_can_notate [1/3,1/6] == True\n rq_can_notate [2/5,1/10] == True\n rq_can_notate [1/3,1/6,2/5,1/10] == False\n rq_can_notate [4/7,1/7,6/7,3/7] == True\n\u003c/pre\u003e",
          "module": "Music.Theory.Duration.RQ",
          "name": "rq_can_notate",
          "package": "hmt",
          "signature": "[RQ] -\u003e Bool",
          "source": "src/Music-Theory-Duration-RQ.html#rq_can_notate",
          "type": "function"
        },
        "index": {
          "description": "Predicate to determine if segment can be notated either without tuplet or with single tuplet rq can notate True rq can notate True rq can notate True rq can notate False rq can notate True",
          "hierarchy": "Music Theory Duration RQ",
          "module": "Music.Theory.Duration.RQ",
          "name": "rq_can_notate",
          "normalized": "[RQ]-\u003eBool",
          "package": "hmt",
          "signature": "[RQ]-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Duration-RQ.html#v:rq_can_notate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDerive the tuplet structure of a set of \u003ccode\u003e\u003ca\u003eRQ\u003c/a\u003e\u003c/code\u003e values.\n\u003c/p\u003e\u003cpre\u003e rq_derive_tuplet [1/4,1/8,1/8] == Nothing\n rq_derive_tuplet [1/3,2/3] == Just (3,2)\n rq_derive_tuplet [1/2,1/3,1/6] == Just (3,2)\n rq_derive_tuplet [2/5,3/5] == Just (5,4)\n rq_derive_tuplet [1/3,1/6,2/5,1/10] == Just (15,8)\n\u003c/pre\u003e",
          "module": "Music.Theory.Duration.RQ",
          "name": "rq_derive_tuplet",
          "package": "hmt",
          "signature": "[RQ] -\u003e Maybe (Integer, Integer)",
          "source": "src/Music-Theory-Duration-RQ.html#rq_derive_tuplet",
          "type": "function"
        },
        "index": {
          "description": "Derive the tuplet structure of set of RQ values rq derive tuplet Nothing rq derive tuplet Just rq derive tuplet Just rq derive tuplet Just rq derive tuplet Just",
          "hierarchy": "Music Theory Duration RQ",
          "module": "Music.Theory.Duration.RQ",
          "name": "rq_derive_tuplet",
          "normalized": "[RQ]-\u003eMaybe(Integer,Integer)",
          "package": "hmt",
          "signature": "[RQ]-\u003eMaybe(Integer,Integer)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Duration-RQ.html#v:rq_derive_tuplet"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDerive the tuplet structure of a set of \u003ccode\u003e\u003ca\u003eRQ\u003c/a\u003e\u003c/code\u003e values.\n\u003c/p\u003e\u003cpre\u003e rq_derive_tuplet_plain [1/2] == Nothing\n rq_derive_tuplet_plain [1/2,1/2] == Nothing\n rq_derive_tuplet_plain [1/4,1/4] == Nothing\n rq_derive_tuplet_plain [1/3,2/3] == Just (3,2)\n rq_derive_tuplet_plain [1/2,1/3,1/6] == Just (6,4)\n rq_derive_tuplet_plain [1/3,1/6] == Just (6,4)\n rq_derive_tuplet_plain [2/5,3/5] == Just (5,4)\n rq_derive_tuplet_plain [1/3,1/6,2/5,1/10] == Just (30,16)\n\u003c/pre\u003e\u003cpre\u003e map rq_derive_tuplet_plain [[1/3,1/6],[2/5,1/10]] == [Just (6,4)\n                                                      ,Just (10,8)]\n\u003c/pre\u003e",
          "module": "Music.Theory.Duration.RQ",
          "name": "rq_derive_tuplet_plain",
          "package": "hmt",
          "signature": "[RQ] -\u003e Maybe (Integer, Integer)",
          "source": "src/Music-Theory-Duration-RQ.html#rq_derive_tuplet_plain",
          "type": "function"
        },
        "index": {
          "description": "Derive the tuplet structure of set of RQ values rq derive tuplet plain Nothing rq derive tuplet plain Nothing rq derive tuplet plain Nothing rq derive tuplet plain Just rq derive tuplet plain Just rq derive tuplet plain Just rq derive tuplet plain Just rq derive tuplet plain Just map rq derive tuplet plain Just Just",
          "hierarchy": "Music Theory Duration RQ",
          "module": "Music.Theory.Duration.RQ",
          "name": "rq_derive_tuplet_plain",
          "normalized": "[RQ]-\u003eMaybe(Integer,Integer)",
          "package": "hmt",
          "signature": "[RQ]-\u003eMaybe(Integer,Integer)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Duration-RQ.html#v:rq_derive_tuplet_plain"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIs \u003cem\u003ep\u003c/em\u003e divisible by \u003cem\u003eq\u003c/em\u003e, ie. is the \u003ccode\u003e\u003ca\u003edenominator\u003c/a\u003e\u003c/code\u003e of \u003ccode\u003ep/q\u003c/code\u003e \u003ccode\u003e\u003ca\u003e==\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e1\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e map (rq_divisible_by (3%2)) [1%2,1%3] == [True,False]\n\u003c/pre\u003e",
          "module": "Music.Theory.Duration.RQ",
          "name": "rq_divisible_by",
          "package": "hmt",
          "signature": "RQ -\u003e RQ -\u003e Bool",
          "source": "src/Music-Theory-Duration-RQ.html#rq_divisible_by",
          "type": "function"
        },
        "index": {
          "description": "Is divisible by ie is the denominator of map rq divisible by True False",
          "hierarchy": "Music Theory Duration RQ",
          "module": "Music.Theory.Duration.RQ",
          "name": "rq_divisible_by",
          "normalized": "RQ-\u003eRQ-\u003eBool",
          "package": "hmt",
          "signature": "RQ-\u003eRQ-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Duration-RQ.html#v:rq_divisible_by"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn \u003ccode\u003e\u003ca\u003enumerator\u003c/a\u003e\u003c/code\u003e of \u003ccode\u003e\u003ca\u003eRQ\u003c/a\u003e\u003c/code\u003e if \u003ccode\u003e\u003ca\u003edenominator\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e==\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e1\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e map rq_integral [1,3/2,2] == [Just 1,Nothing,Just 2]\n\u003c/pre\u003e",
          "module": "Music.Theory.Duration.RQ",
          "name": "rq_integral",
          "package": "hmt",
          "signature": "RQ -\u003e Maybe Integer",
          "source": "src/Music-Theory-Duration-RQ.html#rq_integral",
          "type": "function"
        },
        "index": {
          "description": "Return numerator of RQ if denominator map rq integral Just Nothing Just",
          "hierarchy": "Music Theory Duration RQ",
          "module": "Music.Theory.Duration.RQ",
          "name": "rq_integral",
          "normalized": "RQ-\u003eMaybe Integer",
          "package": "hmt",
          "signature": "RQ-\u003eMaybe Integer",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Duration-RQ.html#v:rq_integral"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIs \u003ccode\u003e\u003ca\u003eRQ\u003c/a\u003e\u003c/code\u003e a \u003cem\u003ecmn\u003c/em\u003e duration.\n\u003c/p\u003e\u003cpre\u003e map rq_is_cmn [1/4,1/5,1/8] == [True,False,True]\n\u003c/pre\u003e",
          "module": "Music.Theory.Duration.RQ",
          "name": "rq_is_cmn",
          "package": "hmt",
          "signature": "RQ -\u003e Bool",
          "source": "src/Music-Theory-Duration-RQ.html#rq_is_cmn",
          "type": "function"
        },
        "index": {
          "description": "Is RQ cmn duration map rq is cmn True False True",
          "hierarchy": "Music Theory Duration RQ",
          "module": "Music.Theory.Duration.RQ",
          "name": "rq_is_cmn",
          "normalized": "RQ-\u003eBool",
          "package": "hmt",
          "signature": "RQ-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Duration-RQ.html#v:rq_is_cmn"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIs \u003ccode\u003e\u003ca\u003eRQ\u003c/a\u003e\u003c/code\u003e a whole number (ie. is \u003ccode\u003e\u003ca\u003edenominator\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e==\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e1\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e map rq_is_integral [1,3/2,2] == [True,False,True]\n\u003c/pre\u003e",
          "module": "Music.Theory.Duration.RQ",
          "name": "rq_is_integral",
          "package": "hmt",
          "signature": "RQ -\u003e Bool",
          "source": "src/Music-Theory-Duration-RQ.html#rq_is_integral",
          "type": "function"
        },
        "index": {
          "description": "Is RQ whole number ie is denominator map rq is integral True False True",
          "hierarchy": "Music Theory Duration RQ",
          "module": "Music.Theory.Duration.RQ",
          "name": "rq_is_integral",
          "normalized": "RQ-\u003eBool",
          "package": "hmt",
          "signature": "RQ-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Duration-RQ.html#v:rq_is_integral"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eRQ\u003c/a\u003e\u003c/code\u003e modulo.\n\u003c/p\u003e\u003cpre\u003e map (rq_mod (5/2)) [3/2,3/4,5/2] == [1,1/4,0]\n\u003c/pre\u003e",
          "module": "Music.Theory.Duration.RQ",
          "name": "rq_mod",
          "package": "hmt",
          "signature": "RQ -\u003e RQ -\u003e RQ",
          "source": "src/Music-Theory-Duration-RQ.html#rq_mod",
          "type": "function"
        },
        "index": {
          "description": "RQ modulo map rq mod",
          "hierarchy": "Music Theory Duration RQ",
          "module": "Music.Theory.Duration.RQ",
          "name": "rq_mod",
          "normalized": "RQ-\u003eRQ-\u003eRQ",
          "package": "hmt",
          "signature": "RQ-\u003eRQ-\u003eRQ",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Duration-RQ.html#v:rq_mod"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIf an \u003ccode\u003e\u003ca\u003eRQ\u003c/a\u003e\u003c/code\u003e duration is un-representable by a single \u003cem\u003ecmn\u003c/em\u003e\n duration, give tied notation.\n\u003c/p\u003e\u003cpre\u003e catMaybes (map rq_to_cmn [1..9]) == [(4,1),(4,3),(8,1)]\n\u003c/pre\u003e\u003cpre\u003e map rq_to_cmn [5/4,5/8] == [Just (1,1/4),Just (1/2,1/8)]\n\u003c/pre\u003e",
          "module": "Music.Theory.Duration.RQ",
          "name": "rq_to_cmn",
          "package": "hmt",
          "signature": "RQ -\u003e Maybe (RQ, RQ)",
          "source": "src/Music-Theory-Duration-RQ.html#rq_to_cmn",
          "type": "function"
        },
        "index": {
          "description": "If an RQ duration is un-representable by single cmn duration give tied notation catMaybes map rq to cmn map rq to cmn Just Just",
          "hierarchy": "Music Theory Duration RQ",
          "module": "Music.Theory.Duration.RQ",
          "name": "rq_to_cmn",
          "normalized": "RQ-\u003eMaybe(RQ,RQ)",
          "package": "hmt",
          "signature": "RQ-\u003eMaybe(RQ,RQ)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Duration-RQ.html#v:rq_to_cmn"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRational quarter note to duration value.  It is a mistake to hope\n this could handle tuplets directly since, for instance, a \u003ccode\u003e3:2\u003c/code\u003e\n dotted note will be of the same duration as a plain undotted note.\n\u003c/p\u003e\u003cpre\u003e rq_to_duration (3/4) == Just dotted_eighth_note\n\u003c/pre\u003e",
          "module": "Music.Theory.Duration.RQ",
          "name": "rq_to_duration",
          "package": "hmt",
          "signature": "RQ -\u003e Maybe Duration",
          "source": "src/Music-Theory-Duration-RQ.html#rq_to_duration",
          "type": "function"
        },
        "index": {
          "description": "Rational quarter note to duration value It is mistake to hope this could handle tuplets directly since for instance dotted note will be of the same duration as plain undotted note rq to duration Just dotted eighth note",
          "hierarchy": "Music Theory Duration RQ",
          "module": "Music.Theory.Duration.RQ",
          "name": "rq_to_duration",
          "normalized": "RQ-\u003eMaybe Duration",
          "package": "hmt",
          "signature": "RQ-\u003eMaybe Duration",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Duration-RQ.html#v:rq_to_duration"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eVariant of \u003ccode\u003e\u003ca\u003erq_to_duration\u003c/a\u003e\u003c/code\u003e with error message.\n\u003c/p\u003e",
          "module": "Music.Theory.Duration.RQ",
          "name": "rq_to_duration_err",
          "package": "hmt",
          "signature": "a -\u003e RQ -\u003e Duration",
          "source": "src/Music-Theory-Duration-RQ.html#rq_to_duration_err",
          "type": "function"
        },
        "index": {
          "description": "Variant of rq to duration with error message",
          "hierarchy": "Music Theory Duration RQ",
          "module": "Music.Theory.Duration.RQ",
          "name": "rq_to_duration_err",
          "normalized": "a-\u003eRQ-\u003eDuration",
          "package": "hmt",
          "signature": "a-\u003eRQ-\u003eDuration",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Duration-RQ.html#v:rq_to_duration_err"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRemove tuplet multiplier from value, ie. to give notated\n duration.  This seems odd but is neccessary to avoid ambiguity.\n Ie. is \u003ccode\u003e1\u003c/code\u003e a quarter note or a \u003ccode\u003e3:2\u003c/code\u003e tuplet dotted-quarter-note etc.\n\u003c/p\u003e\u003cpre\u003e map (rq_un_tuplet (3,2)) [1,2/3,1/2,1/3] == [3/2,1,3/4,1/2]\n\u003c/pre\u003e",
          "module": "Music.Theory.Duration.RQ",
          "name": "rq_un_tuplet",
          "package": "hmt",
          "signature": "(Integer, Integer) -\u003e RQ -\u003e RQ",
          "source": "src/Music-Theory-Duration-RQ.html#rq_un_tuplet",
          "type": "function"
        },
        "index": {
          "description": "Remove tuplet multiplier from value ie to give notated duration This seems odd but is neccessary to avoid ambiguity Ie is quarter note or tuplet dotted-quarter-note etc map rq un tuplet",
          "hierarchy": "Music Theory Duration RQ",
          "module": "Music.Theory.Duration.RQ",
          "name": "rq_un_tuplet",
          "normalized": "(Integer,Integer)-\u003eRQ-\u003eRQ",
          "package": "hmt",
          "signature": "(Integer,Integer)-\u003eRQ-\u003eRQ",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Duration-RQ.html#v:rq_un_tuplet"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert a whole note division integer to an \u003ccode\u003e\u003ca\u003eRQ\u003c/a\u003e\u003c/code\u003e value.\n\u003c/p\u003e\u003cpre\u003e map whole_note_division_to_rq [1,2,4,8] == [4,2,1,1/2]\n\u003c/pre\u003e",
          "module": "Music.Theory.Duration.RQ",
          "name": "whole_note_division_to_rq",
          "package": "hmt",
          "signature": "Integer -\u003e RQ",
          "source": "src/Music-Theory-Duration-RQ.html#whole_note_division_to_rq",
          "type": "function"
        },
        "index": {
          "description": "Convert whole note division integer to an RQ value map whole note division to rq",
          "hierarchy": "Music Theory Duration RQ",
          "module": "Music.Theory.Duration.RQ",
          "name": "whole_note_division_to_rq",
          "normalized": "Integer-\u003eRQ",
          "package": "hmt",
          "signature": "Integer-\u003eRQ",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Duration-RQ.html#v:whole_note_division_to_rq"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eNotation of a sequence of \u003ccode\u003e\u003ca\u003eRQ\u003c/a\u003e\u003c/code\u003e values as annotated \u003ccode\u003e\u003ca\u003eDuration\u003c/a\u003e\u003c/code\u003e values.\n\u003c/p\u003e\u003col\u003e\u003cli\u003e Separate input sequence into measures, adding tie annotations as\n required (see \u003ccode\u003e\u003ca\u003eto_measures_ts\u003c/a\u003e\u003c/code\u003e).  Ensure all \u003ccode\u003e\u003ca\u003eRQ_T\u003c/a\u003e\u003c/code\u003e values can be\n notated as \u003cem\u003ecommon music notation\u003c/em\u003e durations.\n\u003c/li\u003e\u003cli\u003e Separate each measure into pulses (see \u003ccode\u003e\u003ca\u003em_divisions_ts\u003c/a\u003e\u003c/code\u003e).\n Further subdivides pulses to ensure \u003cem\u003ecmn\u003c/em\u003e tuplet notation.  See\n \u003ccode\u003e\u003ca\u003eto_divisions_ts\u003c/a\u003e\u003c/code\u003e for a composition of \u003ccode\u003e\u003ca\u003eto_measures_ts\u003c/a\u003e\u003c/code\u003e and\n \u003ccode\u003e\u003ca\u003em_divisions_ts\u003c/a\u003e\u003c/code\u003e.\n\u003c/li\u003e\u003cli\u003e Simplify each measure (see \u003ccode\u003e\u003ca\u003em_simplify\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003edefault_rule\u003c/a\u003e\u003c/code\u003e).\n Coalesces tied durations where appropriate.\n\u003c/li\u003e\u003cli\u003e Notate measures (see \u003ccode\u003e\u003ca\u003em_notate\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003emm_notate\u003c/a\u003e\u003c/code\u003e).\n\u003c/li\u003e\u003cli\u003e Ascribe values to notated durations, see \u003ccode\u003e\u003ca\u003eascribe\u003c/a\u003e\u003c/code\u003e.\n\u003c/li\u003e\u003c/ol\u003e\u003c/div\u003e",
          "module": "Music.Theory.Duration.Sequence.Notate",
          "name": "Notate",
          "package": "hmt",
          "source": "src/Music-Theory-Duration-Sequence-Notate.html",
          "type": "module"
        },
        "index": {
          "description": "Notation of sequence of RQ values as annotated Duration values Separate input sequence into measures adding tie annotations as required see to measures ts Ensure all RQ values can be notated as common music notation durations Separate each measure into pulses see divisions ts Further subdivides pulses to ensure cmn tuplet notation See to divisions ts for composition of to measures ts and divisions ts Simplify each measure see simplify and default rule Coalesces tied durations where appropriate Notate measures see notate or mm notate Ascribe values to notated durations see ascribe",
          "hierarchy": "Music Theory Duration Sequence Notate",
          "module": "Music.Theory.Duration.Sequence.Notate",
          "name": "Notate",
          "package": "hmt",
          "partial": "Notate",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Duration-Sequence-Notate.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eVariant of \u003ccode\u003e\u003ca\u003eSimplify_T\u003c/a\u003e\u003c/code\u003e allowing multiple rules.\n\u003c/p\u003e",
          "module": "Music.Theory.Duration.Sequence.Notate",
          "name": "Simplify_M",
          "package": "hmt",
          "source": "src/Music-Theory-Duration-Sequence-Notate.html#Simplify_M",
          "type": "type"
        },
        "index": {
          "description": "Variant of Simplify allowing multiple rules",
          "hierarchy": "Music Theory Duration Sequence Notate",
          "module": "Music.Theory.Duration.Sequence.Notate",
          "name": "Simplify_M",
          "package": "hmt",
          "partial": "Simplify",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Duration-Sequence-Notate.html#t:Simplify_M"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePredicate function at \u003ccode\u003e\u003ca\u003eSimplify_T\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Music.Theory.Duration.Sequence.Notate",
          "name": "Simplify_P",
          "package": "hmt",
          "source": "src/Music-Theory-Duration-Sequence-Notate.html#Simplify_P",
          "type": "type"
        },
        "index": {
          "description": "Predicate function at Simplify",
          "hierarchy": "Music Theory Duration Sequence Notate",
          "module": "Music.Theory.Duration.Sequence.Notate",
          "name": "Simplify_P",
          "package": "hmt",
          "partial": "Simplify",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Duration-Sequence-Notate.html#t:Simplify_P"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eStructure given to \u003ccode\u003e\u003ca\u003eSimplify_P\u003c/a\u003e\u003c/code\u003e to decide simplification.  The\n structure is \u003cem\u003e(ts,start-rq,(left-rq,right-rq))\u003c/em\u003e.\n\u003c/p\u003e",
          "module": "Music.Theory.Duration.Sequence.Notate",
          "name": "Simplify_T",
          "package": "hmt",
          "source": "src/Music-Theory-Duration-Sequence-Notate.html#Simplify_T",
          "type": "type"
        },
        "index": {
          "description": "Structure given to Simplify to decide simplification The structure is ts start-rq left-rq right-rq",
          "hierarchy": "Music Theory Duration Sequence Notate",
          "module": "Music.Theory.Duration.Sequence.Notate",
          "name": "Simplify_T",
          "package": "hmt",
          "partial": "Simplify",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Duration-Sequence-Notate.html#t:Simplify_T"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAlias for \u003ccode\u003e\u003ca\u003eFalse\u003c/a\u003e\u003c/code\u003e, used locally for documentation.\n\u003c/p\u003e",
          "module": "Music.Theory.Duration.Sequence.Notate",
          "name": "_f",
          "package": "hmt",
          "signature": "Bool",
          "source": "src/Music-Theory-Duration-Sequence-Notate.html#_f",
          "type": "function"
        },
        "index": {
          "description": "Alias for False used locally for documentation",
          "hierarchy": "Music Theory Duration Sequence Notate",
          "module": "Music.Theory.Duration.Sequence.Notate",
          "name": "_f",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Duration-Sequence-Notate.html#v:_f"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAlias for \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e, used locally for documentation.\n\u003c/p\u003e",
          "module": "Music.Theory.Duration.Sequence.Notate",
          "name": "_t",
          "package": "hmt",
          "signature": "Bool",
          "source": "src/Music-Theory-Duration-Sequence-Notate.html#_t",
          "type": "function"
        },
        "index": {
          "description": "Alias for True used locally for documentation",
          "hierarchy": "Music Theory Duration Sequence Notate",
          "module": "Music.Theory.Duration.Sequence.Notate",
          "name": "_t",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Duration-Sequence-Notate.html#v:_t"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eVariant of \u003ccode\u003ecatMaybes\u003c/code\u003e.  If all elements of the list are \u003ccode\u003eJust\n a\u003c/code\u003e, then gives \u003ccode\u003eJust [a]\u003c/code\u003e else gives \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e all_just (map Just [1..3]) == Just [1..3]\n all_just [Just 1,Nothing,Just 3] == Nothing\n\u003c/pre\u003e",
          "module": "Music.Theory.Duration.Sequence.Notate",
          "name": "all_just",
          "package": "hmt",
          "signature": "[Maybe a] -\u003e Maybe [a]",
          "source": "src/Music-Theory-Duration-Sequence-Notate.html#all_just",
          "type": "function"
        },
        "index": {
          "description": "Variant of catMaybes If all elements of the list are Just then gives Just else gives Nothing all just map Just Just all just Just Nothing Just Nothing",
          "hierarchy": "Music Theory Duration Sequence Notate",
          "module": "Music.Theory.Duration.Sequence.Notate",
          "name": "all_just",
          "normalized": "[Maybe a]-\u003eMaybe[a]",
          "package": "hmt",
          "signature": "[Maybe a]-\u003eMaybe[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Duration-Sequence-Notate.html#v:all_just"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eVariant of \u003ccode\u003e\u003ca\u003erights\u003c/a\u003e\u003c/code\u003e that preserves first \u003ccode\u003e\u003ca\u003eLeft\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e all_right (map Right [1..3]) == Right [1..3]\n all_right [Right 1,Left 'a',Left 'b'] == Left 'a'\n\u003c/pre\u003e",
          "module": "Music.Theory.Duration.Sequence.Notate",
          "name": "all_right",
          "package": "hmt",
          "signature": "[Either a b] -\u003e Either a [b]",
          "source": "src/Music-Theory-Duration-Sequence-Notate.html#all_right",
          "type": "function"
        },
        "index": {
          "description": "Variant of rights that preserves first Left all right map Right Right all right Right Left Left Left",
          "hierarchy": "Music Theory Duration Sequence Notate",
          "module": "Music.Theory.Duration.Sequence.Notate",
          "name": "all_right",
          "normalized": "[Either a b]-\u003eEither a[b]",
          "package": "hmt",
          "signature": "[Either a b]-\u003eEither a[b]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Duration-Sequence-Notate.html#v:all_right"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003esnd\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003em_ascribe\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Music.Theory.Duration.Sequence.Notate",
          "name": "ascribe",
          "package": "hmt",
          "signature": "[Duration_A] -\u003e [x] -\u003e [(Duration_A, x)]",
          "source": "src/Music-Theory-Duration-Sequence-Notate.html#ascribe",
          "type": "function"
        },
        "index": {
          "description": "snd ascribe",
          "hierarchy": "Music Theory Duration Sequence Notate",
          "module": "Music.Theory.Duration.Sequence.Notate",
          "name": "ascribe",
          "normalized": "[Duration_A]-\u003e[a]-\u003e[(Duration_A,a)]",
          "package": "hmt",
          "signature": "[Duration_A]-\u003e[x]-\u003e[(Duration_A,x)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Duration-Sequence-Notate.html#v:ascribe"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eVariant of \u003ccode\u003e\u003ca\u003eascribe\u003c/a\u003e\u003c/code\u003e that groups the \u003cem\u003erhs\u003c/em\u003e elements using\n \u003ccode\u003e\u003ca\u003egroup_chd\u003c/a\u003e\u003c/code\u003e and with the indicated \u003cem\u003echord\u003c/em\u003e function, then rejoins\n the resulting sequence.\n\u003c/p\u003e",
          "module": "Music.Theory.Duration.Sequence.Notate",
          "name": "ascribe_chd",
          "package": "hmt",
          "signature": "(x -\u003e Bool) -\u003e [Duration_A] -\u003e [x] -\u003e [(Duration_A, x)]",
          "source": "src/Music-Theory-Duration-Sequence-Notate.html#ascribe_chd",
          "type": "function"
        },
        "index": {
          "description": "Variant of ascribe that groups the rhs elements using group chd and with the indicated chord function then rejoins the resulting sequence",
          "hierarchy": "Music Theory Duration Sequence Notate",
          "module": "Music.Theory.Duration.Sequence.Notate",
          "name": "ascribe_chd",
          "normalized": "(a-\u003eBool)-\u003e[Duration_A]-\u003e[a]-\u003e[(Duration_A,a)]",
          "package": "hmt",
          "signature": "(x-\u003eBool)-\u003e[Duration_A]-\u003e[x]-\u003e[(Duration_A,x)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Duration-Sequence-Notate.html#v:ascribe_chd"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eApplies a \u003cem\u003ejoin\u003c/em\u003e function to the first two elements of the list.\n If the \u003cem\u003ejoin\u003c/em\u003e function succeeds the joined element is considered\n for further coalescing.\n\u003c/p\u003e\u003cpre\u003e coalesce (\\p q -\u003e Just (p + q)) [1..5] == [15]\n\u003c/pre\u003e\u003cpre\u003e let jn p q = if even p then Just (p + q) else Nothing\n in coalesce jn [1..5] == map sum [[1],[2,3],[4,5]]\n\u003c/pre\u003e",
          "module": "Music.Theory.Duration.Sequence.Notate",
          "name": "coalesce",
          "package": "hmt",
          "signature": "(a -\u003e a -\u003e Maybe a) -\u003e [a] -\u003e [a]",
          "source": "src/Music-Theory-Duration-Sequence-Notate.html#coalesce",
          "type": "function"
        },
        "index": {
          "description": "Applies join function to the first two elements of the list If the join function succeeds the joined element is considered for further coalescing coalesce Just let jn if even then Just else Nothing in coalesce jn map sum",
          "hierarchy": "Music Theory Duration Sequence Notate",
          "module": "Music.Theory.Duration.Sequence.Notate",
          "name": "coalesce",
          "normalized": "(a-\u003ea-\u003eMaybe a)-\u003e[a]-\u003e[a]",
          "package": "hmt",
          "signature": "(a-\u003ea-\u003eMaybe a)-\u003e[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Duration-Sequence-Notate.html#v:coalesce"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eVariant of \u003ccode\u003e\u003ca\u003ecoalesce\u003c/a\u003e\u003c/code\u003e with accumulation parameter.\n\u003c/p\u003e\u003cpre\u003e coalesce_accum (\\i p q -\u003e Left (p + q)) 0 [1..5] == [(0,15)]\n\u003c/pre\u003e\u003cpre\u003e let jn i p q = if even p then Left (p + q) else Right (p + i)\n in coalesce_accum jn 0 [1..7] == [(0,1),(1,5),(6,9),(15,13)]\n\u003c/pre\u003e\u003cpre\u003e let jn i p q = if even p then Left (p + q) else Right [p,q]\n in coalesce_accum jn [] [1..5] == [([],1),([1,2],5),([5,4],9)]\n\u003c/pre\u003e",
          "module": "Music.Theory.Duration.Sequence.Notate",
          "name": "coalesce_accum",
          "package": "hmt",
          "signature": "(b -\u003e a -\u003e a -\u003e Either a b) -\u003e b -\u003e [a] -\u003e [(b, a)]",
          "source": "src/Music-Theory-Duration-Sequence-Notate.html#coalesce_accum",
          "type": "function"
        },
        "index": {
          "description": "Variant of coalesce with accumulation parameter coalesce accum Left let jn if even then Left else Right in coalesce accum jn let jn if even then Left else Right in coalesce accum jn",
          "hierarchy": "Music Theory Duration Sequence Notate",
          "module": "Music.Theory.Duration.Sequence.Notate",
          "name": "coalesce_accum",
          "normalized": "(a-\u003eb-\u003eb-\u003eEither b a)-\u003ea-\u003e[b]-\u003e[(a,b)]",
          "package": "hmt",
          "signature": "(b-\u003ea-\u003ea-\u003eEither a b)-\u003eb-\u003e[a]-\u003e[(b,a)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Duration-Sequence-Notate.html#v:coalesce_accum"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eVariant of \u003ccode\u003e\u003ca\u003ecoalesce_accum\u003c/a\u003e\u003c/code\u003e that accumulates running sum.\n\u003c/p\u003e\u003cpre\u003e let f i p q = if i == 1 then Just (p + q) else Nothing\n in coalesce_sum (+) 0 f [1,1/2,1/4,1/4] == [1,1]\n\u003c/pre\u003e",
          "module": "Music.Theory.Duration.Sequence.Notate",
          "name": "coalesce_sum",
          "package": "hmt",
          "signature": "(b -\u003e a -\u003e b) -\u003e b -\u003e (b -\u003e a -\u003e a -\u003e Maybe a) -\u003e [a] -\u003e [a]",
          "source": "src/Music-Theory-Duration-Sequence-Notate.html#coalesce_sum",
          "type": "function"
        },
        "index": {
          "description": "Variant of coalesce accum that accumulates running sum let if then Just else Nothing in coalesce sum",
          "hierarchy": "Music Theory Duration Sequence Notate",
          "module": "Music.Theory.Duration.Sequence.Notate",
          "name": "coalesce_sum",
          "normalized": "(a-\u003eb-\u003ea)-\u003ea-\u003e(a-\u003eb-\u003eb-\u003eMaybe b)-\u003e[b]-\u003e[b]",
          "package": "hmt",
          "signature": "(b-\u003ea-\u003eb)-\u003eb-\u003e(b-\u003ea-\u003ea-\u003eMaybe a)-\u003e[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Duration-Sequence-Notate.html#v:coalesce_sum"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe default quarter note pulse simplifier rule.\n\u003c/p\u003e\u003cpre\u003e default_4_rule ((3,4),0,(1,1/2)) == True\n default_4_rule ((3,4),0,(1,3/4)) == True\n default_4_rule ((4,4),1,(1,1)) == False\n default_4_rule ((4,4),2,(1,1)) == True\n default_4_rule ((4,4),2,(1,2)) == True\n default_4_rule ((4,4),0,(2,1)) == True\n default_4_rule ((3,4),1,(1,1)) == False\n\u003c/pre\u003e",
          "module": "Music.Theory.Duration.Sequence.Notate",
          "name": "default_4_rule",
          "package": "hmt",
          "signature": "Simplify_P",
          "source": "src/Music-Theory-Duration-Sequence-Notate.html#default_4_rule",
          "type": "function"
        },
        "index": {
          "description": "The default quarter note pulse simplifier rule default rule True default rule True default rule False default rule True default rule True default rule True default rule False",
          "hierarchy": "Music Theory Duration Sequence Notate",
          "module": "Music.Theory.Duration.Sequence.Notate",
          "name": "default_4_rule",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Duration-Sequence-Notate.html#v:default_4_rule"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe default eighth-note pulse simplifier rule.\n\u003c/p\u003e\u003cpre\u003e default_8_rule ((3,8),0,(1/2,1/2)) == True\n default_8_rule ((3,8),1/2,(1/2,1/2)) == True\n default_8_rule ((3,8),1,(1/2,1/2)) == True\n default_8_rule ((2,8),0,(1/2,1/2)) == True\n default_8_rule ((5,8),0,(1,1/2)) == True\n default_8_rule ((5,8),0,(2,1/2)) == True\n\u003c/pre\u003e",
          "module": "Music.Theory.Duration.Sequence.Notate",
          "name": "default_8_rule",
          "package": "hmt",
          "signature": "Simplify_P",
          "source": "src/Music-Theory-Duration-Sequence-Notate.html#default_8_rule",
          "type": "function"
        },
        "index": {
          "description": "The default eighth-note pulse simplifier rule default rule True default rule True default rule True default rule True default rule True default rule True",
          "hierarchy": "Music Theory Duration Sequence Notate",
          "module": "Music.Theory.Duration.Sequence.Notate",
          "name": "default_8_rule",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Duration-Sequence-Notate.html#v:default_8_rule"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe default simplifier rule.  To extend provide a list of\n \u003ccode\u003e\u003ca\u003eSimplify_T\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Music.Theory.Duration.Sequence.Notate",
          "name": "default_rule",
          "package": "hmt",
          "signature": "[Simplify_T] -\u003e Simplify_P",
          "source": "src/Music-Theory-Duration-Sequence-Notate.html#default_rule",
          "type": "function"
        },
        "index": {
          "description": "The default simplifier rule To extend provide list of Simplify",
          "hierarchy": "Music Theory Duration Sequence Notate",
          "module": "Music.Theory.Duration.Sequence.Notate",
          "name": "default_rule",
          "normalized": "[Simplify_T]-\u003eSimplify_P",
          "package": "hmt",
          "signature": "[Simplify_T]-\u003eSimplify_P",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Duration-Sequence-Notate.html#v:default_rule"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe default table of simplifiers.\n\u003c/p\u003e\u003cpre\u003e default_table ((3,4),1,(1,1)) == True\n\u003c/pre\u003e",
          "module": "Music.Theory.Duration.Sequence.Notate",
          "name": "default_table",
          "package": "hmt",
          "signature": "Simplify_P",
          "source": "src/Music-Theory-Duration-Sequence-Notate.html#default_table",
          "type": "function"
        },
        "index": {
          "description": "The default table of simplifiers default table True",
          "hierarchy": "Music Theory Duration Sequence Notate",
          "module": "Music.Theory.Duration.Sequence.Notate",
          "name": "default_table",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Duration-Sequence-Notate.html#v:default_table"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLower \u003ccode\u003e\u003ca\u003eEither\u003c/a\u003e\u003c/code\u003e to \u003ccode\u003e\u003ca\u003eMaybe\u003c/a\u003e\u003c/code\u003e by discarding \u003ccode\u003e\u003ca\u003eLeft\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Music.Theory.Duration.Sequence.Notate",
          "name": "either_to_maybe",
          "package": "hmt",
          "signature": "Either a b -\u003e Maybe b",
          "source": "src/Music-Theory-Duration-Sequence-Notate.html#either_to_maybe",
          "type": "function"
        },
        "index": {
          "description": "Lower Either to Maybe by discarding Left",
          "hierarchy": "Music Theory Duration Sequence Notate",
          "module": "Music.Theory.Duration.Sequence.Notate",
          "name": "either_to_maybe",
          "normalized": "Either a b-\u003eMaybe b",
          "package": "hmt",
          "signature": "Either a b-\u003eMaybe b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Duration-Sequence-Notate.html#v:either_to_maybe"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGroup elements as \u003cem\u003echords\u003c/em\u003e where a chord element is inidicated by\n the given predicate.\n\u003c/p\u003e\u003cpre\u003e group_chd even [1,2,3,4,4,5,7,8] == [[1,2],[3,4,4],[5],[7,8]]\n\u003c/pre\u003e",
          "module": "Music.Theory.Duration.Sequence.Notate",
          "name": "group_chd",
          "package": "hmt",
          "signature": "(x -\u003e Bool) -\u003e [x] -\u003e [[x]]",
          "source": "src/Music-Theory-Duration-Sequence-Notate.html#group_chd",
          "type": "function"
        },
        "index": {
          "description": "Group elements as chords where chord element is inidicated by the given predicate group chd even",
          "hierarchy": "Music Theory Duration Sequence Notate",
          "module": "Music.Theory.Duration.Sequence.Notate",
          "name": "group_chd",
          "normalized": "(a-\u003eBool)-\u003e[a]-\u003e[[a]]",
          "package": "hmt",
          "signature": "(x-\u003eBool)-\u003e[x]-\u003e[[x]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Duration-Sequence-Notate.html#v:group_chd"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eZip a list of \u003ccode\u003e\u003ca\u003eDuration_A\u003c/a\u003e\u003c/code\u003e elements duplicating elements of the\n right hand sequence for tied durations.\n\u003c/p\u003e\u003cpre\u003e let {Just d = to_divisions_ts [(4,4),(4,4)] [3,3,2]\n     ;f = map snd . snd . flip m_ascribe \"xyz\"}\n in fmap f (notate d) == Just \"xxxyyyzz\"\n\u003c/pre\u003e",
          "module": "Music.Theory.Duration.Sequence.Notate",
          "name": "m_ascribe",
          "package": "hmt",
          "signature": "[Duration_A] -\u003e [x] -\u003e ([x], [(Duration_A, x)])",
          "source": "src/Music-Theory-Duration-Sequence-Notate.html#m_ascribe",
          "type": "function"
        },
        "index": {
          "description": "Zip list of Duration elements duplicating elements of the right hand sequence for tied durations let Just to divisions ts map snd snd flip ascribe xyz in fmap notate Just xxxyyyzz",
          "hierarchy": "Music Theory Duration Sequence Notate",
          "module": "Music.Theory.Duration.Sequence.Notate",
          "name": "m_ascribe",
          "normalized": "[Duration_A]-\u003e[a]-\u003e([a],[(Duration_A,a)])",
          "package": "hmt",
          "signature": "[Duration_A]-\u003e[x]-\u003e([x],[(Duration_A,x)])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Duration-Sequence-Notate.html#v:m_ascribe"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDivide measure into pulses of indicated \u003ccode\u003e\u003ca\u003eRQ\u003c/a\u003e\u003c/code\u003e durations.  Measure\n must be of correct length but need not contain only \u003cem\u003ecmn\u003c/em\u003e\n durations.  Pulses are further subdivided if required to notate\n tuplets correctly, see \u003ccode\u003e\u003ca\u003erqt_tuplet_subdivide_seq\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e let d = [(1/4,_f),(1/4,_f),(2/3,_t),(1/6,_f),(16/15,_f),(1/5,_f)\n         ,(1/5,_f),(2/5,_t),(1/20,_f),(1/2,_f),(1/4,_t)]\n in m_divisions_rq [1,1,1,1] d\n\u003c/pre\u003e\u003cpre\u003e m_divisions_rq [1,1,1] [(4/7,_f),(33/28,_f),(9/20,_f),(4/5,_f)]\n\u003c/pre\u003e",
          "module": "Music.Theory.Duration.Sequence.Notate",
          "name": "m_divisions_rq",
          "package": "hmt",
          "signature": "[RQ] -\u003e [RQ_T] -\u003e Either String [[RQ_T]]",
          "source": "src/Music-Theory-Duration-Sequence-Notate.html#m_divisions_rq",
          "type": "function"
        },
        "index": {
          "description": "Divide measure into pulses of indicated RQ durations Measure must be of correct length but need not contain only cmn durations Pulses are further subdivided if required to notate tuplets correctly see rqt tuplet subdivide seq let in divisions rq divisions rq",
          "hierarchy": "Music Theory Duration Sequence Notate",
          "module": "Music.Theory.Duration.Sequence.Notate",
          "name": "m_divisions_rq",
          "normalized": "[RQ]-\u003e[RQ_T]-\u003eEither String[[RQ_T]]",
          "package": "hmt",
          "signature": "[RQ]-\u003e[RQ_T]-\u003eEither String[[RQ_T]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Duration-Sequence-Notate.html#v:m_divisions_rq"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eVariant of \u003ccode\u003e\u003ca\u003em_divisions_rq\u003c/a\u003e\u003c/code\u003e that determines pulse divisions from\n \u003ccode\u003e\u003ca\u003eTime_Signature\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e let d = [(4/7,_t),(1/7,_f),(2/7,_f)]\n in m_divisions_ts (1,4) d == Just [d]\n\u003c/pre\u003e\u003cpre\u003e let d = map rq_rqt [1/3,1/6,2/5,1/10]\n in m_divisions_ts (1,4) d == Just [[(1/3,_f),(1/6,_f)]\n                                   ,[(2/5,_f),(1/10,_f)]]\n\u003c/pre\u003e\u003cpre\u003e let d = map rq_rqt [4/7,33/28,9/20,4/5]\n in m_divisions_ts (3,4) d == Just [[(4/7,_f),(3/7,_t)]\n                                   ,[(3/4,_f),(1/4,_t)]\n                                   ,[(1/5,_f),(4/5,_f)]]\n\u003c/pre\u003e",
          "module": "Music.Theory.Duration.Sequence.Notate",
          "name": "m_divisions_ts",
          "package": "hmt",
          "signature": "Time_Signature -\u003e [RQ_T] -\u003e Either String [[RQ_T]]",
          "source": "src/Music-Theory-Duration-Sequence-Notate.html#m_divisions_ts",
          "type": "function"
        },
        "index": {
          "description": "Variant of divisions rq that determines pulse divisions from Time Signature let in divisions ts Just let map rq rqt in divisions ts Just let map rq rqt in divisions ts Just",
          "hierarchy": "Music Theory Duration Sequence Notate",
          "module": "Music.Theory.Duration.Sequence.Notate",
          "name": "m_divisions_ts",
          "normalized": "Time_Signature-\u003e[RQ_T]-\u003eEither String[[RQ_T]]",
          "package": "hmt",
          "signature": "Time_Signature-\u003e[RQ_T]-\u003eEither String[[RQ_T]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Duration-Sequence-Notate.html#v:m_divisions_ts"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eNotate measure.\n\u003c/p\u003e\u003cpre\u003e m_notate True [[(2/3,_f),(1/3,_t)],[(1,_t)],[(1,_f)]]\n\u003c/pre\u003e\u003cpre\u003e let f = m_notate False . concat\n\u003c/pre\u003e\u003cpre\u003e fmap f (to_divisions_ts [(4,4)] [3/5,2/5,1/3,1/6,7/10,17/15,1/2,1/6])\n fmap f (to_divisions_ts [(4,4)] [3/5,2/5,1/3,1/6,7/10,29/30,1/2,1/3])\n\u003c/pre\u003e",
          "module": "Music.Theory.Duration.Sequence.Notate",
          "name": "m_notate",
          "package": "hmt",
          "signature": "Bool -\u003e [[RQ_T]] -\u003e Either String [Duration_A]",
          "source": "src/Music-Theory-Duration-Sequence-Notate.html#m_notate",
          "type": "function"
        },
        "index": {
          "description": "Notate measure notate True let notate False concat fmap to divisions ts fmap to divisions ts",
          "hierarchy": "Music Theory Duration Sequence Notate",
          "module": "Music.Theory.Duration.Sequence.Notate",
          "name": "m_notate",
          "normalized": "Bool-\u003e[[RQ_T]]-\u003eEither String[Duration_A]",
          "package": "hmt",
          "signature": "Bool-\u003e[[RQ_T]]-\u003eEither String[Duration_A]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Duration-Sequence-Notate.html#v:m_notate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMeasure simplifier.  Apply given \u003ccode\u003e\u003ca\u003eSimplify_P\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Music.Theory.Duration.Sequence.Notate",
          "name": "m_simplify",
          "package": "hmt",
          "signature": "Simplify_P -\u003e Time_Signature -\u003e [Duration_A] -\u003e [Duration_A]",
          "source": "src/Music-Theory-Duration-Sequence-Notate.html#m_simplify",
          "type": "function"
        },
        "index": {
          "description": "Measure simplifier Apply given Simplify",
          "hierarchy": "Music Theory Duration Sequence Notate",
          "module": "Music.Theory.Duration.Sequence.Notate",
          "name": "m_simplify",
          "normalized": "Simplify_P-\u003eTime_Signature-\u003e[Duration_A]-\u003e[Duration_A]",
          "package": "hmt",
          "signature": "Simplify_P-\u003eTime_Signature-\u003e[Duration_A]-\u003e[Duration_A]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Duration-Sequence-Notate.html#v:m_simplify"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTransform \u003ccode\u003e\u003ca\u003eSimplify_M\u003c/a\u003e\u003c/code\u003e to \u003ccode\u003e\u003ca\u003eSimplify_P\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Music.Theory.Duration.Sequence.Notate",
          "name": "meta_table_p",
          "package": "hmt",
          "signature": "Simplify_M -\u003e Simplify_P",
          "source": "src/Music-Theory-Duration-Sequence-Notate.html#meta_table_p",
          "type": "function"
        },
        "index": {
          "description": "Transform Simplify to Simplify",
          "hierarchy": "Music Theory Duration Sequence Notate",
          "module": "Music.Theory.Duration.Sequence.Notate",
          "name": "meta_table_p",
          "normalized": "Simplify_M-\u003eSimplify_P",
          "package": "hmt",
          "signature": "Simplify_M-\u003eSimplify_P",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Duration-Sequence-Notate.html#v:meta_table_p"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTransform \u003ccode\u003e\u003ca\u003eSimplify_M\u003c/a\u003e\u003c/code\u003e to set of \u003ccode\u003e\u003ca\u003eSimplify_T\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Music.Theory.Duration.Sequence.Notate",
          "name": "meta_table_t",
          "package": "hmt",
          "signature": "Simplify_M -\u003e [Simplify_T]",
          "source": "src/Music-Theory-Duration-Sequence-Notate.html#meta_table_t",
          "type": "function"
        },
        "index": {
          "description": "Transform Simplify to set of Simplify",
          "hierarchy": "Music Theory Duration Sequence Notate",
          "module": "Music.Theory.Duration.Sequence.Notate",
          "name": "meta_table_t",
          "normalized": "Simplify_M-\u003e[Simplify_T]",
          "package": "hmt",
          "signature": "Simplify_M-\u003e[Simplify_T]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Duration-Sequence-Notate.html#v:meta_table_t"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eVariant of \u003ccode\u003e\u003ca\u003em_ascribe\u003c/a\u003e\u003c/code\u003e for a set of measures.\n\u003c/p\u003e",
          "module": "Music.Theory.Duration.Sequence.Notate",
          "name": "mm_ascribe",
          "package": "hmt",
          "signature": "[[Duration_A]] -\u003e [x] -\u003e [[(Duration_A, x)]]",
          "source": "src/Music-Theory-Duration-Sequence-Notate.html#mm_ascribe",
          "type": "function"
        },
        "index": {
          "description": "Variant of ascribe for set of measures",
          "hierarchy": "Music Theory Duration Sequence Notate",
          "module": "Music.Theory.Duration.Sequence.Notate",
          "name": "mm_ascribe",
          "normalized": "[[Duration_A]]-\u003e[a]-\u003e[[(Duration_A,a)]]",
          "package": "hmt",
          "signature": "[[Duration_A]]-\u003e[x]-\u003e[[(Duration_A,x)]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Duration-Sequence-Notate.html#v:mm_ascribe"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eVariant of \u003ccode\u003e\u003ca\u003emm_ascribe\u003c/a\u003e\u003c/code\u003e using \u003ccode\u003e\u003ca\u003egroup_chd\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Music.Theory.Duration.Sequence.Notate",
          "name": "mm_ascribe_chd",
          "package": "hmt",
          "signature": "(x -\u003e Bool) -\u003e [[Duration_A]] -\u003e [x] -\u003e [[(Duration_A, x)]]",
          "source": "src/Music-Theory-Duration-Sequence-Notate.html#mm_ascribe_chd",
          "type": "function"
        },
        "index": {
          "description": "Variant of mm ascribe using group chd",
          "hierarchy": "Music Theory Duration Sequence Notate",
          "module": "Music.Theory.Duration.Sequence.Notate",
          "name": "mm_ascribe_chd",
          "normalized": "(a-\u003eBool)-\u003e[[Duration_A]]-\u003e[a]-\u003e[[(Duration_A,a)]]",
          "package": "hmt",
          "signature": "(x-\u003eBool)-\u003e[[Duration_A]]-\u003e[x]-\u003e[[(Duration_A,x)]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Duration-Sequence-Notate.html#v:mm_ascribe_chd"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMultiple measure notation.\n\u003c/p\u003e\u003cpre\u003e let d = [2/7,1/7,4/7,5/7,8/7,1,1/7]\n in fmap mm_notate (to_divisions_ts [(4,4)] d)\n\u003c/pre\u003e\u003cpre\u003e let d = [2/7,1/7,4/7,5/7,1,6/7,3/7]\n in fmap mm_notate (to_divisions_ts [(4,4)] d)\n\u003c/pre\u003e\u003cpre\u003e let d = [3/5,2/5,1/3,1/6,7/10,4/5,1/2,1/2]\n in fmap mm_notate (to_divisions_ts [(4,4)] d)\n\u003c/pre\u003e",
          "module": "Music.Theory.Duration.Sequence.Notate",
          "name": "mm_notate",
          "package": "hmt",
          "signature": "[[[RQ_T]]] -\u003e Either String [[Duration_A]]",
          "source": "src/Music-Theory-Duration-Sequence-Notate.html#mm_notate",
          "type": "function"
        },
        "index": {
          "description": "Multiple measure notation let in fmap mm notate to divisions ts let in fmap mm notate to divisions ts let in fmap mm notate to divisions ts",
          "hierarchy": "Music Theory Duration Sequence Notate",
          "module": "Music.Theory.Duration.Sequence.Notate",
          "name": "mm_notate",
          "normalized": "[[[RQ_T]]]-\u003eEither String[[Duration_A]]",
          "package": "hmt",
          "signature": "[[[RQ_T]]]-\u003eEither String[[Duration_A]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Duration-Sequence-Notate.html#v:mm_notate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eComposition of \u003ccode\u003e\u003ca\u003eto_divisions_ts\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003emm_notate\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003em_simplify\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Music.Theory.Duration.Sequence.Notate",
          "name": "notate",
          "package": "hmt",
          "signature": "Simplify_P -\u003e [Time_Signature] -\u003e [RQ] -\u003e Either String [[Duration_A]]",
          "source": "src/Music-Theory-Duration-Sequence-Notate.html#notate",
          "type": "function"
        },
        "index": {
          "description": "Composition of to divisions ts mm notate simplify",
          "hierarchy": "Music Theory Duration Sequence Notate",
          "module": "Music.Theory.Duration.Sequence.Notate",
          "name": "notate",
          "normalized": "Simplify_P-\u003e[Time_Signature]-\u003e[RQ]-\u003eEither String[[Duration_A]]",
          "package": "hmt",
          "signature": "Simplify_P-\u003e[Time_Signature]-\u003e[RQ]-\u003eEither String[[Duration_A]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Duration-Sequence-Notate.html#v:notate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eNotate pulse, ie. derive tuplet if neccesary. The flag indicates\n if the initial value is tied left.\n\u003c/p\u003e\u003cpre\u003e p_notate False [(2/3,_f),(1/3,_t)]\n p_notate False [(2/5,_f),(1/10,_t)]\n p_notate False [(1/4,_t),(1/8,_f),(1/8,_f)]\n p_notate False (map rq_rqt [1/3,1/6])\n p_notate False (map rq_rqt [2/5,1/10])\n p_notate False (map rq_rqt [1/3,1/6,2/5,1/10]) == Nothing\n\u003c/pre\u003e",
          "module": "Music.Theory.Duration.Sequence.Notate",
          "name": "p_notate",
          "package": "hmt",
          "signature": "Bool -\u003e [RQ_T] -\u003e Either String [Duration_A]",
          "source": "src/Music-Theory-Duration-Sequence-Notate.html#p_notate",
          "type": "function"
        },
        "index": {
          "description": "Notate pulse ie derive tuplet if neccesary The flag indicates if the initial value is tied left notate False notate False notate False notate False map rq rqt notate False map rq rqt notate False map rq rqt Nothing",
          "hierarchy": "Music Theory Duration Sequence Notate",
          "module": "Music.Theory.Duration.Sequence.Notate",
          "name": "p_notate",
          "normalized": "Bool-\u003e[RQ_T]-\u003eEither String[Duration_A]",
          "package": "hmt",
          "signature": "Bool-\u003e[RQ_T]-\u003eEither String[Duration_A]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Duration-Sequence-Notate.html#v:p_notate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePulse simplifier.\n\u003c/p\u003e\u003cpre\u003e import Music.Theory.Duration.Name.Abbreviation\n p_simplify [(q,[Tie_Right]),(e,[Tie_Left])] == [(q',[])]\n p_simplify [(e,[Tie_Right]),(q,[Tie_Left])] == [(q',[])]\n p_simplify [(q,[Tie_Right]),(e',[Tie_Left])] == [(q'',[])]\n p_simplify [(q'',[Tie_Right]),(s,[Tie_Left])] == [(h,[])]\n p_simplify [(e,[Tie_Right]),(s,[Tie_Left]),(e',[])] == [(e',[]),(e',[])]\n\u003c/pre\u003e\u003cpre\u003e let f = rqt_to_duration_a False\n in p_simplify (f [(1/8,_t),(1/4,_t),(1/8,_f)]) == f [(1/2,_f)]\n\u003c/pre\u003e",
          "module": "Music.Theory.Duration.Sequence.Notate",
          "name": "p_simplify",
          "package": "hmt",
          "signature": "[Duration_A] -\u003e [Duration_A]",
          "source": "src/Music-Theory-Duration-Sequence-Notate.html#p_simplify",
          "type": "function"
        },
        "index": {
          "description": "Pulse simplifier import Music.Theory.Duration.Name.Abbreviation simplify Tie Right Tie Left simplify Tie Right Tie Left simplify Tie Right Tie Left simplify Tie Right Tie Left simplify Tie Right Tie Left let rqt to duration False in simplify",
          "hierarchy": "Music Theory Duration Sequence Notate",
          "module": "Music.Theory.Duration.Sequence.Notate",
          "name": "p_simplify",
          "normalized": "[Duration_A]-\u003e[Duration_A]",
          "package": "hmt",
          "signature": "[Duration_A]-\u003e[Duration_A]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Duration-Sequence-Notate.html#v:p_simplify"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePulse simplifier predicate, which is \u003ccode\u003e\u003ca\u003econst\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Music.Theory.Duration.Sequence.Notate",
          "name": "p_simplify_rule",
          "package": "hmt",
          "signature": "Simplify_P",
          "source": "src/Music-Theory-Duration-Sequence-Notate.html#p_simplify_rule",
          "type": "function"
        },
        "index": {
          "description": "Pulse simplifier predicate which is const True",
          "hierarchy": "Music Theory Duration Sequence Notate",
          "module": "Music.Theory.Duration.Sequence.Notate",
          "name": "p_simplify_rule",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Duration-Sequence-Notate.html#v:p_simplify_rule"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePulse tuplet derivation.\n\u003c/p\u003e\u003cpre\u003e p_tuplet_rqt [(2/3,_f),(1/3,_t)] == Just ((3,2),[(1,_f),(1/2,_t)])\n p_tuplet_rqt (map rq_rqt [1/3,1/6]) == Just ((3,2),[(1/2,_f),(1/4,_f)])\n p_tuplet_rqt (map rq_rqt [2/5,1/10]) == Just ((5,4),[(1/2,_f),(1/8,_f)])\n p_tuplet_rqt (map rq_rqt [1/3,1/6,2/5,1/10])\n\u003c/pre\u003e",
          "module": "Music.Theory.Duration.Sequence.Notate",
          "name": "p_tuplet_rqt",
          "package": "hmt",
          "signature": "[RQ_T] -\u003e Maybe ((Integer, Integer), [RQ_T])",
          "source": "src/Music-Theory-Duration-Sequence-Notate.html#p_tuplet_rqt",
          "type": "function"
        },
        "index": {
          "description": "Pulse tuplet derivation tuplet rqt Just tuplet rqt map rq rqt Just tuplet rqt map rq rqt Just tuplet rqt map rq rqt",
          "hierarchy": "Music Theory Duration Sequence Notate",
          "module": "Music.Theory.Duration.Sequence.Notate",
          "name": "p_tuplet_rqt",
          "normalized": "[RQ_T]-\u003eMaybe((Integer,Integer),[RQ_T])",
          "package": "hmt",
          "signature": "[RQ_T]-\u003eMaybe((Integer,Integer),[RQ_T])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Duration-Sequence-Notate.html#v:p_tuplet_rqt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSeparate \u003ccode\u003e\u003ca\u003eRQ_T\u003c/a\u003e\u003c/code\u003e values in sequences summing to \u003ccode\u003e\u003ca\u003eRQ\u003c/a\u003e\u003c/code\u003e values.  This\n is a recursive variant of \u003ccode\u003e\u003ca\u003erqt_split_sum\u003c/a\u003e\u003c/code\u003e.  Note that is does not\n ensure \u003cem\u003ecmn\u003c/em\u003e notation of values.\n\u003c/p\u003e\u003cpre\u003e let d = [(2,_f),(2,_f),(2,_f)]\n in rqt_separate [3,3] d == Right [[(2,_f),(1,_t)]\n                                 ,[(1,_f),(2,_f)]]\n\u003c/pre\u003e\u003cpre\u003e let d = [(5/8,_f),(1,_f),(3/8,_f)]\n in rqt_separate [1,1] d == Right [[(5/8,_f),(3/8,_t)]\n                                 ,[(5/8,_f),(3/8,_f)]]\n\u003c/pre\u003e\u003cpre\u003e let d = [(4/7,_t),(1/7,_f),(1,_f),(6/7,_f),(3/7,_f)]\n in rqt_separate [1,1,1] d == Right [[(4/7,_t),(1/7,_f),(2/7,_t)]\n                                    ,[(5/7,_f),(2/7,_t)]\n                                    ,[(4/7,_f),(3/7,_f)]]\n\u003c/pre\u003e",
          "module": "Music.Theory.Duration.Sequence.Notate",
          "name": "rqt_separate",
          "package": "hmt",
          "signature": "[RQ] -\u003e [RQ_T] -\u003e Either String [[RQ_T]]",
          "source": "src/Music-Theory-Duration-Sequence-Notate.html#rqt_separate",
          "type": "function"
        },
        "index": {
          "description": "Separate RQ values in sequences summing to RQ values This is recursive variant of rqt split sum Note that is does not ensure cmn notation of values let in rqt separate Right let in rqt separate Right let in rqt separate Right",
          "hierarchy": "Music Theory Duration Sequence Notate",
          "module": "Music.Theory.Duration.Sequence.Notate",
          "name": "rqt_separate",
          "normalized": "[RQ]-\u003e[RQ_T]-\u003eEither String[[RQ_T]]",
          "package": "hmt",
          "signature": "[RQ]-\u003e[RQ_T]-\u003eEither String[[RQ_T]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Duration-Sequence-Notate.html#v:rqt_separate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Duration.Sequence.Notate",
          "name": "rqt_separate_m",
          "package": "hmt",
          "signature": "[RQ] -\u003e [RQ_T] -\u003e Maybe [[RQ_T]]",
          "source": "src/Music-Theory-Duration-Sequence-Notate.html#rqt_separate_m",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Duration Sequence Notate",
          "module": "Music.Theory.Duration.Sequence.Notate",
          "name": "rqt_separate_m",
          "normalized": "[RQ]-\u003e[RQ_T]-\u003eMaybe[[RQ_T]]",
          "package": "hmt",
          "signature": "[RQ]-\u003e[RQ_T]-\u003eMaybe[[RQ_T]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Duration-Sequence-Notate.html#v:rqt_separate_m"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIf the input \u003ccode\u003e\u003ca\u003eRQ_T\u003c/a\u003e\u003c/code\u003e sequence cannot be notated (see\n \u003ccode\u003e\u003ca\u003erqt_can_notate\u003c/a\u003e\u003c/code\u003e) separate into equal parts, so long as each part\n is not less than \u003cem\u003ei\u003c/em\u003e.\n\u003c/p\u003e\u003cpre\u003e rqt_separate_tuplet undefined [(1/3,_f),(1/6,_f)]\n rqt_separate_tuplet undefined [(4/7,_t),(1/7,_f),(2/7,_f)]\n\u003c/pre\u003e\u003cpre\u003e let d = map rq_rqt [1/3,1/6,2/5,1/10]\n in rqt_separate_tuplet (1/8) d == Right [[(1/3,_f),(1/6,_f)]\n                                         ,[(2/5,_f),(1/10,_f)]]\n\u003c/pre\u003e\u003cpre\u003e let d = [(1/5,True),(1/20,False),(1/2,False),(1/4,True)]\n in rqt_separate_tuplet (1/16) d\n\u003c/pre\u003e\u003cpre\u003e let d = [(2/5,_f),(1/5,_f),(1/5,_f),(1/5,_t),(1/2,_f),(1/2,_f)]\n in rqt_separate_tuplet (1/2) d\n\u003c/pre\u003e\u003cpre\u003e let d = [(4/10,True),(1/10,False),(1/2,True)]\n in rqt_separate_tuplet (1/2) d\n\u003c/pre\u003e",
          "module": "Music.Theory.Duration.Sequence.Notate",
          "name": "rqt_separate_tuplet",
          "package": "hmt",
          "signature": "RQ -\u003e [RQ_T] -\u003e Either String [[RQ_T]]",
          "source": "src/Music-Theory-Duration-Sequence-Notate.html#rqt_separate_tuplet",
          "type": "function"
        },
        "index": {
          "description": "If the input RQ sequence cannot be notated see rqt can notate separate into equal parts so long as each part is not less than rqt separate tuplet undefined rqt separate tuplet undefined let map rq rqt in rqt separate tuplet Right let True False False True in rqt separate tuplet let in rqt separate tuplet let True False True in rqt separate tuplet",
          "hierarchy": "Music Theory Duration Sequence Notate",
          "module": "Music.Theory.Duration.Sequence.Notate",
          "name": "rqt_separate_tuplet",
          "normalized": "RQ-\u003e[RQ_T]-\u003eEither String[[RQ_T]]",
          "package": "hmt",
          "signature": "RQ-\u003e[RQ_T]-\u003eEither String[[RQ_T]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Duration-Sequence-Notate.html#v:rqt_separate_tuplet"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eVariant of \u003ccode\u003e\u003ca\u003esplit_sum\u003c/a\u003e\u003c/code\u003e that operates at \u003ccode\u003e\u003ca\u003eRQ_T\u003c/a\u003e\u003c/code\u003e sequences.\n\u003c/p\u003e\u003cpre\u003e let r = Just ([(3,_f),(2,_t)],[(1,_f)])\n in rqt_split_sum 5 [(3,_f),(2,_t),(1,_f)] == r\n\u003c/pre\u003e\u003cpre\u003e let r = Just ([(3,_f),(1,_t)],[(1,_t),(1,_f)])\n in rqt_split_sum 4 [(3,_f),(2,_t),(1,_f)] == r\n\u003c/pre\u003e",
          "module": "Music.Theory.Duration.Sequence.Notate",
          "name": "rqt_split_sum",
          "package": "hmt",
          "signature": "RQ -\u003e [RQ_T] -\u003e Maybe ([RQ_T], [RQ_T])",
          "source": "src/Music-Theory-Duration-Sequence-Notate.html#rqt_split_sum",
          "type": "function"
        },
        "index": {
          "description": "Variant of split sum that operates at RQ sequences let Just in rqt split sum let Just in rqt split sum",
          "hierarchy": "Music Theory Duration Sequence Notate",
          "module": "Music.Theory.Duration.Sequence.Notate",
          "name": "rqt_split_sum",
          "normalized": "RQ-\u003e[RQ_T]-\u003eMaybe([RQ_T],[RQ_T])",
          "package": "hmt",
          "signature": "RQ-\u003e[RQ_T]-\u003eMaybe([RQ_T],[RQ_T])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Duration-Sequence-Notate.html#v:rqt_split_sum"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIf a tuplet is all tied, it ought to be a plain value?!\n\u003c/p\u003e\u003cpre\u003e rqt_tuplet_sanity_ [(4/10,_t),(1/10,_f)] == [(1/2,_f)]\n\u003c/pre\u003e",
          "module": "Music.Theory.Duration.Sequence.Notate",
          "name": "rqt_tuplet_sanity_",
          "package": "hmt",
          "signature": "[RQ_T] -\u003e [RQ_T]",
          "source": "src/Music-Theory-Duration-Sequence-Notate.html#rqt_tuplet_sanity_",
          "type": "function"
        },
        "index": {
          "description": "If tuplet is all tied it ought to be plain value rqt tuplet sanity",
          "hierarchy": "Music Theory Duration Sequence Notate",
          "module": "Music.Theory.Duration.Sequence.Notate",
          "name": "rqt_tuplet_sanity_",
          "normalized": "[RQ_T]-\u003e[RQ_T]",
          "package": "hmt",
          "signature": "[RQ_T]-\u003e[RQ_T]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Duration-Sequence-Notate.html#v:rqt_tuplet_sanity_"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRecursive variant of \u003ccode\u003e\u003ca\u003erqt_separate_tuplet\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e let d = map rq_rqt [1,1/3,1/6,2/5,1/10]\n in rqt_tuplet_subdivide (1/8) d == [[(1/1,_f)]\n                                    ,[(1/3,_f),(1/6,_f)]\n                                    ,[(2/5,_f),(1/10,_f)]]\n\u003c/pre\u003e",
          "module": "Music.Theory.Duration.Sequence.Notate",
          "name": "rqt_tuplet_subdivide",
          "package": "hmt",
          "signature": "RQ -\u003e [RQ_T] -\u003e [[RQ_T]]",
          "source": "src/Music-Theory-Duration-Sequence-Notate.html#rqt_tuplet_subdivide",
          "type": "function"
        },
        "index": {
          "description": "Recursive variant of rqt separate tuplet let map rq rqt in rqt tuplet subdivide",
          "hierarchy": "Music Theory Duration Sequence Notate",
          "module": "Music.Theory.Duration.Sequence.Notate",
          "name": "rqt_tuplet_subdivide",
          "normalized": "RQ-\u003e[RQ_T]-\u003e[[RQ_T]]",
          "package": "hmt",
          "signature": "RQ-\u003e[RQ_T]-\u003e[[RQ_T]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Duration-Sequence-Notate.html#v:rqt_tuplet_subdivide"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSequence variant of \u003ccode\u003e\u003ca\u003erqt_tuplet_subdivide\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e let d = [(1/5,True),(1/20,False),(1/2,False),(1/4,True)]\n in rqt_tuplet_subdivide_seq (1/2) [d]\n\u003c/pre\u003e",
          "module": "Music.Theory.Duration.Sequence.Notate",
          "name": "rqt_tuplet_subdivide_seq",
          "package": "hmt",
          "signature": "RQ -\u003e [[RQ_T]] -\u003e [[RQ_T]]",
          "source": "src/Music-Theory-Duration-Sequence-Notate.html#rqt_tuplet_subdivide_seq",
          "type": "function"
        },
        "index": {
          "description": "Sequence variant of rqt tuplet subdivide let True False False True in rqt tuplet subdivide seq",
          "hierarchy": "Music Theory Duration Sequence Notate",
          "module": "Music.Theory.Duration.Sequence.Notate",
          "name": "rqt_tuplet_subdivide_seq",
          "normalized": "RQ-\u003e[[RQ_T]]-\u003e[[RQ_T]]",
          "package": "hmt",
          "signature": "RQ-\u003e[[RQ_T]]-\u003e[[RQ_T]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Duration-Sequence-Notate.html#v:rqt_tuplet_subdivide_seq"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Duration.Sequence.Notate",
          "name": "rqt_tuplet_subdivide_seq_sanity_",
          "package": "hmt",
          "signature": "RQ -\u003e [[RQ_T]] -\u003e [[RQ_T]]",
          "source": "src/Music-Theory-Duration-Sequence-Notate.html#rqt_tuplet_subdivide_seq_sanity_",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Duration Sequence Notate",
          "module": "Music.Theory.Duration.Sequence.Notate",
          "name": "rqt_tuplet_subdivide_seq_sanity_",
          "normalized": "RQ-\u003e[[RQ_T]]-\u003e[[RQ_T]]",
          "package": "hmt",
          "signature": "RQ-\u003e[[RQ_T]]-\u003e[[RQ_T]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Duration-Sequence-Notate.html#v:rqt_tuplet_subdivide_seq_sanity_"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSplit sequence such that the prefix sums to precisely \u003cem\u003em\u003c/em\u003e.  The\n third element of the result indicates if it was required to divide\n an element.  Not that zero elements are kept left.  If the required\n sum is non positive, or the input list does not sum to at least the\n required sum, gives nothing.\n\u003c/p\u003e\u003cpre\u003e split_sum 5 [2,3,1] == Just ([2,3],[1],Nothing)\n split_sum 5 [2,1,3] == Just ([2,1,2],[1],Just (2,1))\n split_sum 2 [3/2,3/2,3/2] == Just ([3/2,1/2],[1,3/2],Just (1/2,1))\n split_sum 6 [1..10] == Just ([1..3],[4..10],Nothing)\n fmap (\\(a,_,c)-\u003e(a,c)) (split_sum 5 [1..]) == Just ([1,2,2],Just (2,1))\n split_sum 0 [1..] == Nothing\n split_sum 3 [1,1] == Nothing\n split_sum 3 [2,1,0] == Just ([2,1,0],[],Nothing)\n split_sum 3 [2,1,0,1] == Just ([2,1,0],[1],Nothing)\n\u003c/pre\u003e",
          "module": "Music.Theory.Duration.Sequence.Notate",
          "name": "split_sum",
          "package": "hmt",
          "signature": "a -\u003e [a] -\u003e Maybe ([a], [a], Maybe (a, a))",
          "source": "src/Music-Theory-Duration-Sequence-Notate.html#split_sum",
          "type": "function"
        },
        "index": {
          "description": "Split sequence such that the prefix sums to precisely The third element of the result indicates if it was required to divide an element Not that zero elements are kept left If the required sum is non positive or the input list does not sum to at least the required sum gives nothing split sum Just Nothing split sum Just Just split sum Just Just split sum Just Nothing fmap split sum Just Just split sum Nothing split sum Nothing split sum Just Nothing split sum Just Nothing",
          "hierarchy": "Music Theory Duration Sequence Notate",
          "module": "Music.Theory.Duration.Sequence.Notate",
          "name": "split_sum",
          "normalized": "a-\u003e[a]-\u003eMaybe([a],[a],Maybe(a,a))",
          "package": "hmt",
          "signature": "a-\u003e[a]-\u003eMaybe([a],[a],Maybe(a,a))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Duration-Sequence-Notate.html#v:split_sum"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRecursive variant of \u003ccode\u003e\u003ca\u003etake_sum_by_eq\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e split_sum_by_eq id [3,3] [2,1,0,3] == Just [[2,1,0],[3]]\n split_sum_by_eq id [3,3] [2,2,2] == Nothing\n\u003c/pre\u003e",
          "module": "Music.Theory.Duration.Sequence.Notate",
          "name": "split_sum_by_eq",
          "package": "hmt",
          "signature": "(a -\u003e n) -\u003e [n] -\u003e [a] -\u003e Maybe [[a]]",
          "source": "src/Music-Theory-Duration-Sequence-Notate.html#split_sum_by_eq",
          "type": "function"
        },
        "index": {
          "description": "Recursive variant of take sum by eq split sum by eq id Just split sum by eq id Nothing",
          "hierarchy": "Music Theory Duration Sequence Notate",
          "module": "Music.Theory.Duration.Sequence.Notate",
          "name": "split_sum_by_eq",
          "normalized": "(a-\u003eb)-\u003e[b]-\u003e[a]-\u003eMaybe[[a]]",
          "package": "hmt",
          "signature": "(a-\u003en)-\u003e[n]-\u003e[a]-\u003eMaybe[[a]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Duration-Sequence-Notate.html#v:split_sum_by_eq"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eVariant of \u003ccode\u003e\u003ca\u003etake_sum_by\u003c/a\u003e\u003c/code\u003e with \u003ccode\u003e\u003ca\u003eid\u003c/a\u003e\u003c/code\u003e function.\n\u003c/p\u003e",
          "module": "Music.Theory.Duration.Sequence.Notate",
          "name": "take_sum",
          "package": "hmt",
          "signature": "a -\u003e [a] -\u003e ([a], a, [a])",
          "source": "src/Music-Theory-Duration-Sequence-Notate.html#take_sum",
          "type": "function"
        },
        "index": {
          "description": "Variant of take sum by with id function",
          "hierarchy": "Music Theory Duration Sequence Notate",
          "module": "Music.Theory.Duration.Sequence.Notate",
          "name": "take_sum",
          "normalized": "a-\u003e[a]-\u003e([a],a,[a])",
          "package": "hmt",
          "signature": "a-\u003e[a]-\u003e([a],a,[a])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Duration-Sequence-Notate.html#v:take_sum"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTake elements while the sum of the prefix is less than or equal\n to the indicated value.  Returns also the difference between the\n prefix sum and the requested sum.  Note that zero elements are kept\n left.\n\u003c/p\u003e\u003cpre\u003e take_sum_by id 3 [2,1] == ([2,1],0,[])\n take_sum_by id 3 [2,2] == ([2],1,[2])\n take_sum_by id 3 [2,1,0,1] == ([2,1,0],0,[1])\n take_sum_by id 3 [4] == ([],3,[4])\n take_sum_by id 0 [1..5] == ([],0,[1..5])\n\u003c/pre\u003e",
          "module": "Music.Theory.Duration.Sequence.Notate",
          "name": "take_sum_by",
          "package": "hmt",
          "signature": "(a -\u003e n) -\u003e n -\u003e [a] -\u003e ([a], n, [a])",
          "source": "src/Music-Theory-Duration-Sequence-Notate.html#take_sum_by",
          "type": "function"
        },
        "index": {
          "description": "Take elements while the sum of the prefix is less than or equal to the indicated value Returns also the difference between the prefix sum and the requested sum Note that zero elements are kept left take sum by id take sum by id take sum by id take sum by id take sum by id",
          "hierarchy": "Music Theory Duration Sequence Notate",
          "module": "Music.Theory.Duration.Sequence.Notate",
          "name": "take_sum_by",
          "normalized": "(a-\u003eb)-\u003eb-\u003e[a]-\u003e([a],b,[a])",
          "package": "hmt",
          "signature": "(a-\u003en)-\u003en-\u003e[a]-\u003e([a],n,[a])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Duration-Sequence-Notate.html#v:take_sum_by"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eVariant of \u003ccode\u003e\u003ca\u003etake_sum\u003c/a\u003e\u003c/code\u003e that requires the prefix to sum to value.\n\u003c/p\u003e\u003cpre\u003e take_sum_by_eq id 3 [2,1,0,1] == Just ([2,1,0],[1])\n take_sum_by_eq id 3 [2,2] == Nothing\n\u003c/pre\u003e",
          "module": "Music.Theory.Duration.Sequence.Notate",
          "name": "take_sum_by_eq",
          "package": "hmt",
          "signature": "(a -\u003e n) -\u003e n -\u003e [a] -\u003e Maybe ([a], [a])",
          "source": "src/Music-Theory-Duration-Sequence-Notate.html#take_sum_by_eq",
          "type": "function"
        },
        "index": {
          "description": "Variant of take sum that requires the prefix to sum to value take sum by eq id Just take sum by eq id Nothing",
          "hierarchy": "Music Theory Duration Sequence Notate",
          "module": "Music.Theory.Duration.Sequence.Notate",
          "name": "take_sum_by_eq",
          "normalized": "(a-\u003eb)-\u003eb-\u003e[a]-\u003eMaybe([a],[a])",
          "package": "hmt",
          "signature": "(a-\u003en)-\u003en-\u003e[a]-\u003eMaybe([a],[a])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Duration-Sequence-Notate.html#v:take_sum_by_eq"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eComposition of \u003ccode\u003e\u003ca\u003eto_measures_rq\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003em_divisions_rq\u003c/a\u003e\u003c/code\u003e, where\n measures are initially given as sets of divisions.\n\u003c/p\u003e\u003cpre\u003e let m = [[1,1,1],[1,1,1]]\n in to_divisions_rq m [2,2,2] == Just [[[(1,_t)],[(1,_f)],[(1,_t)]]\n                                      ,[[(1,_f)],[(1,_t)],[(1,_f)]]]\n\u003c/pre\u003e\u003cpre\u003e let d = [2/7,1/7,4/7,5/7,8/7,1,1/7]\n in to_divisions_rq [[1,1,1,1]] d == Just [[[(2/7,_f),(1/7,_f),(4/7,_f)]\n                                           ,[(4/7,_t),(1/7,_f),(2/7,_t)]\n                                           ,[(6/7,_f),(1/7,_t)]\n                                           ,[(6/7,_f),(1/7,_f)]]]\n\u003c/pre\u003e\u003cpre\u003e let d = [5/7,1,6/7,3/7]\n in to_divisions_rq [[1,1,1]] d == Just [[[(4/7,_t),(1/7,_f),(2/7,_t)]\n                                         ,[(4/7,_t),(1/7,_f),(2/7,_t)]\n                                         ,[(4/7,_f),(3/7,_f)]]]\n\u003c/pre\u003e\u003cpre\u003e let d = [2/7,1/7,4/7,5/7,1,6/7,3/7]\n in to_divisions_rq [[1,1,1,1]] d == Just [[[(2/7,_f),(1/7,_f),(4/7,_f)]\n                                           ,[(4/7,_t),(1/7,_f),(2/7,_t)]\n                                           ,[(4/7,_t),(1/7,_f),(2/7,_t)]\n                                           ,[(4/7,_f),(3/7,_f)]]]\n\u003c/pre\u003e\u003cpre\u003e let d = [4/7,33/28,9/20,4/5]\n in to_divisions_rq [[1,1,1]] d == Just [[[(4/7,_f),(3/7,_t)]\n                                         ,[(3/4,_f),(1/4,_t)]\n                                         ,[(1/5,_f),(4/5,_f)]]]\n\u003c/pre\u003e",
          "module": "Music.Theory.Duration.Sequence.Notate",
          "name": "to_divisions_rq",
          "package": "hmt",
          "signature": "[[RQ]] -\u003e [RQ] -\u003e Either String [[[RQ_T]]]",
          "source": "src/Music-Theory-Duration-Sequence-Notate.html#to_divisions_rq",
          "type": "function"
        },
        "index": {
          "description": "Composition of to measures rq and divisions rq where measures are initially given as sets of divisions let in to divisions rq Just let in to divisions rq Just let in to divisions rq Just let in to divisions rq Just let in to divisions rq Just",
          "hierarchy": "Music Theory Duration Sequence Notate",
          "module": "Music.Theory.Duration.Sequence.Notate",
          "name": "to_divisions_rq",
          "normalized": "[[RQ]]-\u003e[RQ]-\u003eEither String[[[RQ_T]]]",
          "package": "hmt",
          "signature": "[[RQ]]-\u003e[RQ]-\u003eEither String[[[RQ_T]]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Duration-Sequence-Notate.html#v:to_divisions_rq"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eVariant of \u003ccode\u003e\u003ca\u003eto_divisions_rq\u003c/a\u003e\u003c/code\u003e with measures given as set of\n \u003ccode\u003e\u003ca\u003eTime_Signature\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e let d = [3/5,2/5,1/3,1/6,7/10,17/15,1/2,1/6]\n in to_divisions_ts [(4,4)] d == Just [[[(3/5,_f),(2/5,_f)]\n                                       ,[(1/3,_f),(1/6,_f),(1/2,_t)]\n                                       ,[(1/5,_f),(4/5,_t)]\n                                       ,[(1/3,_f),(1/2,_f),(1/6,_f)]]]\n\u003c/pre\u003e\u003cpre\u003e let d = [3/5,2/5,1/3,1/6,7/10,29/30,1/2,1/3]\n in to_divisions_ts [(4,4)] d == Just [[[(3/5,_f),(2/5,_f)]\n                                       ,[(1/3,_f),(1/6,_f),(1/2,_t)]\n                                       ,[(1/5,_f),(4/5,_t)]\n                                       ,[(1/6,_f),(1/2,_f),(1/3,_f)]]]\n\u003c/pre\u003e\u003cpre\u003e let d = [3/5,2/5,1/3,1/6,7/10,4/5,1/2,1/2]\n in to_divisions_ts [(4,4)] d == Just [[[(3/5,_f),(2/5,_f)]\n                                       ,[(1/3,_f),(1/6,_f),(1/2,_t)]\n                                       ,[(1/5,_f),(4/5,_f)]\n                                       ,[(1/2,_f),(1/2,_f)]]]\n\u003c/pre\u003e\u003cpre\u003e let d = [4/7,33/28,9/20,4/5]\n in to_divisions_ts [(3,4)] d == Just [[[(4/7,_f),(3/7,_t)]\n                                       ,[(3/4,_f),(1/4,_t)]\n                                       ,[(1/5,_f),(4/5,_f)]]]\n\u003c/pre\u003e",
          "module": "Music.Theory.Duration.Sequence.Notate",
          "name": "to_divisions_ts",
          "package": "hmt",
          "signature": "[Time_Signature] -\u003e [RQ] -\u003e Either String [[[RQ_T]]]",
          "source": "src/Music-Theory-Duration-Sequence-Notate.html#to_divisions_ts",
          "type": "function"
        },
        "index": {
          "description": "Variant of to divisions rq with measures given as set of Time Signature let in to divisions ts Just let in to divisions ts Just let in to divisions ts Just let in to divisions ts Just",
          "hierarchy": "Music Theory Duration Sequence Notate",
          "module": "Music.Theory.Duration.Sequence.Notate",
          "name": "to_divisions_ts",
          "normalized": "[Time_Signature]-\u003e[RQ]-\u003eEither String[[[RQ_T]]]",
          "package": "hmt",
          "signature": "[Time_Signature]-\u003e[RQ]-\u003eEither String[[[RQ_T]]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Duration-Sequence-Notate.html#v:to_divisions_ts"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSeparate \u003ccode\u003e\u003ca\u003eRQ\u003c/a\u003e\u003c/code\u003e sequence into measures given by \u003ccode\u003e\u003ca\u003eRQ\u003c/a\u003e\u003c/code\u003e length.\n\u003c/p\u003e\u003cpre\u003e to_measures_rq [3,3] [2,2,2] == Right [[(2,_f),(1,_t)],[(1,_f),(2,_f)]]\n to_measures_rq [3,3] [6] == Right [[(3,_t)],[(3,_f)]]\n to_measures_rq [1,1,1] [3] == Right [[(1,_t)],[(1,_t)],[(1,_f)]]\n to_measures_rq [3,3] [2,2,1]\n to_measures_rq [3,2] [2,2,2]\n\u003c/pre\u003e\u003cpre\u003e let d = [4/7,33/28,9/20,4/5]\n in to_measures_rq [3] d == Right [[(4/7,_f),(33/28,_f),(9/20,_f),(4/5,_f)]]\n\u003c/pre\u003e",
          "module": "Music.Theory.Duration.Sequence.Notate",
          "name": "to_measures_rq",
          "package": "hmt",
          "signature": "[RQ] -\u003e [RQ] -\u003e Either String [[RQ_T]]",
          "source": "src/Music-Theory-Duration-Sequence-Notate.html#to_measures_rq",
          "type": "function"
        },
        "index": {
          "description": "Separate RQ sequence into measures given by RQ length to measures rq Right to measures rq Right to measures rq Right to measures rq to measures rq let in to measures rq Right",
          "hierarchy": "Music Theory Duration Sequence Notate",
          "module": "Music.Theory.Duration.Sequence.Notate",
          "name": "to_measures_rq",
          "normalized": "[RQ]-\u003e[RQ]-\u003eEither String[[RQ_T]]",
          "package": "hmt",
          "signature": "[RQ]-\u003e[RQ]-\u003eEither String[[RQ_T]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Duration-Sequence-Notate.html#v:to_measures_rq"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eVariant of \u003ccode\u003e\u003ca\u003eto_measures_rq\u003c/a\u003e\u003c/code\u003e that ensures \u003ccode\u003e\u003ca\u003eRQ_T\u003c/a\u003e\u003c/code\u003e are \u003cem\u003ecmn\u003c/em\u003e\n durations.  This is not a good composition.\n\u003c/p\u003e\u003cpre\u003e to_measures_rq_cmn [6,6] [5,5,2] == Right [[(4,_t),(1,_f),(1,_t)]\n                                           ,[(4,_f),(2,_f)]]\n\u003c/pre\u003e\u003cpre\u003e let r = [[(4/7,_t),(1/7,_f),(1,_f),(6/7,_f),(3/7,_f)]]\n in to_measures_rq_cmn [3] [5/7,1,6/7,3/7] == Right r\n\u003c/pre\u003e\u003cpre\u003e to_measures_rq_cmn [1,1,1] [5/7,1,6/7,3/7] == Right [[(4/7,_t),(1/7,_f),(2/7,_t)]\n                                                     ,[(4/7,_t),(1/7,_f),(2/7,_t)]\n                                                     ,[(4/7,_f),(3/7,_f)]]\n\u003c/pre\u003e",
          "module": "Music.Theory.Duration.Sequence.Notate",
          "name": "to_measures_rq_cmn",
          "package": "hmt",
          "signature": "[RQ] -\u003e [RQ] -\u003e Either String [[RQ_T]]",
          "source": "src/Music-Theory-Duration-Sequence-Notate.html#to_measures_rq_cmn",
          "type": "function"
        },
        "index": {
          "description": "Variant of to measures rq that ensures RQ are cmn durations This is not good composition to measures rq cmn Right let in to measures rq cmn Right to measures rq cmn Right",
          "hierarchy": "Music Theory Duration Sequence Notate",
          "module": "Music.Theory.Duration.Sequence.Notate",
          "name": "to_measures_rq_cmn",
          "normalized": "[RQ]-\u003e[RQ]-\u003eEither String[[RQ_T]]",
          "package": "hmt",
          "signature": "[RQ]-\u003e[RQ]-\u003eEither String[[RQ_T]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Duration-Sequence-Notate.html#v:to_measures_rq_cmn"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eVariant of \u003ccode\u003e\u003ca\u003eto_measures_rq\u003c/a\u003e\u003c/code\u003e with measures given by\n \u003ccode\u003e\u003ca\u003eTime_Signature\u003c/a\u003e\u003c/code\u003e values.  Does not ensure \u003ccode\u003e\u003ca\u003eRQ_T\u003c/a\u003e\u003c/code\u003e are \u003cem\u003ecmn\u003c/em\u003e\n durations.\n\u003c/p\u003e\u003cpre\u003e to_measures_ts [(1,4)] [5/8,3/8] /= Right [[(1/2,_t),(1/8,_f),(3/8,_f)]]\n to_measures_ts [(1,4)] [5/7,2/7] /= Right [[(4/7,_t),(1/7,_f),(2/7,_f)]]\n\u003c/pre\u003e\u003cpre\u003e let {m = replicate 18 (1,4)\n     ;x = [3/4,2,5/4,9/4,1/4,3/2,1/2,7/4,1,5/2,11/4,3/2]}\n in to_measures_ts m x == Right [[(3/4,_f),(1/4,_t)],[(1/1,_t)]\n                                ,[(3/4,_f),(1/4,_t)],[(1/1,_f)]\n                                ,[(1/1,_t)],[(1/1,_t)]\n                                ,[(1/4,_f),(1/4,_f),(1/2,_t)],[(1/1,_f)]\n                                ,[(1/2,_f),(1/2,_t)],[(1/1,_t)]\n                                ,[(1/4,_f),(3/4,_t)],[(1/4,_f),(3/4,_t)]\n                                ,[(1/1,_t)],[(3/4,_f),(1/4,_t)]\n                                ,[(1/1,_t)],[(1/1,_t)]\n                                ,[(1/2,_f),(1/2,_t)],[(1/1,_f)]]\n\u003c/pre\u003e\u003cpre\u003e to_measures_ts [(3,4)] [4/7,33/28,9/20,4/5]\n to_measures_ts (replicate 3 (1,4)) [4/7,33/28,9/20,4/5]\n\u003c/pre\u003e",
          "module": "Music.Theory.Duration.Sequence.Notate",
          "name": "to_measures_ts",
          "package": "hmt",
          "signature": "[Time_Signature] -\u003e [RQ] -\u003e Either String [[RQ_T]]",
          "source": "src/Music-Theory-Duration-Sequence-Notate.html#to_measures_ts",
          "type": "function"
        },
        "index": {
          "description": "Variant of to measures rq with measures given by Time Signature values Does not ensure RQ are cmn durations to measures ts Right to measures ts Right let replicate in to measures ts Right to measures ts to measures ts replicate",
          "hierarchy": "Music Theory Duration Sequence Notate",
          "module": "Music.Theory.Duration.Sequence.Notate",
          "name": "to_measures_ts",
          "normalized": "[Time_Signature]-\u003e[RQ]-\u003eEither String[[RQ_T]]",
          "package": "hmt",
          "signature": "[Time_Signature]-\u003e[RQ]-\u003eEither String[[RQ_T]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Duration-Sequence-Notate.html#v:to_measures_ts"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eVariant of \u003ccode\u003e\u003ca\u003eto_measures_ts\u003c/a\u003e\u003c/code\u003e that allows for duration field\n operation but requires that measures be well formed.  This is\n useful for re-grouping measures after notation and ascription.\n\u003c/p\u003e",
          "module": "Music.Theory.Duration.Sequence.Notate",
          "name": "to_measures_ts_by_eq",
          "package": "hmt",
          "signature": "(a -\u003e RQ) -\u003e [Time_Signature] -\u003e [a] -\u003e Maybe [[a]]",
          "source": "src/Music-Theory-Duration-Sequence-Notate.html#to_measures_ts_by_eq",
          "type": "function"
        },
        "index": {
          "description": "Variant of to measures ts that allows for duration field operation but requires that measures be well formed This is useful for re-grouping measures after notation and ascription",
          "hierarchy": "Music Theory Duration Sequence Notate",
          "module": "Music.Theory.Duration.Sequence.Notate",
          "name": "to_measures_ts_by_eq",
          "normalized": "(a-\u003eRQ)-\u003e[Time_Signature]-\u003e[a]-\u003eMaybe[[a]]",
          "package": "hmt",
          "signature": "(a-\u003eRQ)-\u003e[Time_Signature]-\u003e[a]-\u003eMaybe[[a]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Duration-Sequence-Notate.html#v:to_measures_ts_by_eq"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eVariant of \u003ccode\u003e\u003ca\u003ezip\u003c/a\u003e\u003c/code\u003e that retains elements of the right hand (rhs)\n list where elements of the left hand (lhs) list meet the given lhs\n predicate, and elements of the lhs list where elements of the ths\n meet the rhs predicate.  If the right hand side is longer the\n remaining elements to be processed are given.  It is an error for\n the right hand side to be short.\n\u003c/p\u003e\u003cpre\u003e zip_hold even (const False) [1..5] \"abc\" == ([],zip [1..6] \"abbcc\")\n zip_hold odd (const False) [1..6] \"abc\" == ([],zip [1..6] \"aabbcc\")\n zip_hold even (const False) [1] \"ab\" == (\"b\",[(1,'a')])\n zip_hold even (const False) [1,2] \"a\" == undefined\n\u003c/pre\u003e\u003cpre\u003e zip_hold odd even [1,2,6] [1..5] == ([4,5],[(1,1),(2,1),(6,2),(6,3)])\n\u003c/pre\u003e",
          "module": "Music.Theory.Duration.Sequence.Notate",
          "name": "zip_hold",
          "package": "hmt",
          "signature": "(x -\u003e Bool) -\u003e (t -\u003e Bool) -\u003e [x] -\u003e [t] -\u003e ([t], [(x, t)])",
          "source": "src/Music-Theory-Duration-Sequence-Notate.html#zip_hold",
          "type": "function"
        },
        "index": {
          "description": "Variant of zip that retains elements of the right hand rhs list where elements of the left hand lhs list meet the given lhs predicate and elements of the lhs list where elements of the ths meet the rhs predicate If the right hand side is longer the remaining elements to be processed are given It is an error for the right hand side to be short zip hold even const False abc zip abbcc zip hold odd const False abc zip aabbcc zip hold even const False ab zip hold even const False undefined zip hold odd even",
          "hierarchy": "Music Theory Duration Sequence Notate",
          "module": "Music.Theory.Duration.Sequence.Notate",
          "name": "zip_hold",
          "normalized": "(a-\u003eBool)-\u003e(b-\u003eBool)-\u003e[a]-\u003e[b]-\u003e([b],[(a,b)])",
          "package": "hmt",
          "signature": "(x-\u003eBool)-\u003e(t-\u003eBool)-\u003e[x]-\u003e[t]-\u003e([t],[(x,t)])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Duration-Sequence-Notate.html#v:zip_hold"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eVariant of \u003ccode\u003e\u003ca\u003ezip\u003c/a\u003e\u003c/code\u003e that retains elements of the right hand (rhs)\n list where elements of the left hand (lhs) list meet the given lhs\n predicate.  If the right hand side is longer the remaining elements\n to be processed are given.  It is an error for the right hand side\n to be short.\n\u003c/p\u003e\u003cpre\u003e zip_hold_lhs even [1..5] \"abc\" == ([],zip [1..6] \"abbcc\")\n zip_hold_lhs odd [1..6] \"abc\" == ([],zip [1..6] \"aabbcc\")\n zip_hold_lhs even [1] \"ab\" == (\"b\",[(1,'a')])\n zip_hold_lhs even [1,2] \"a\" == undefined\n\u003c/pre\u003e",
          "module": "Music.Theory.Duration.Sequence.Notate",
          "name": "zip_hold_lhs",
          "package": "hmt",
          "signature": "(x -\u003e Bool) -\u003e [x] -\u003e [t] -\u003e ([t], [(x, t)])",
          "source": "src/Music-Theory-Duration-Sequence-Notate.html#zip_hold_lhs",
          "type": "function"
        },
        "index": {
          "description": "Variant of zip that retains elements of the right hand rhs list where elements of the left hand lhs list meet the given lhs predicate If the right hand side is longer the remaining elements to be processed are given It is an error for the right hand side to be short zip hold lhs even abc zip abbcc zip hold lhs odd abc zip aabbcc zip hold lhs even ab zip hold lhs even undefined",
          "hierarchy": "Music Theory Duration Sequence Notate",
          "module": "Music.Theory.Duration.Sequence.Notate",
          "name": "zip_hold_lhs",
          "normalized": "(a-\u003eBool)-\u003e[a]-\u003e[b]-\u003e([b],[(a,b)])",
          "package": "hmt",
          "signature": "(x-\u003eBool)-\u003e[x]-\u003e[t]-\u003e([t],[(x,t)])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Duration-Sequence-Notate.html#v:zip_hold_lhs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eVariant of \u003ccode\u003e\u003ca\u003ezip_hold\u003c/a\u003e\u003c/code\u003e that requires the right hand side to be\n precisely the required length.\n\u003c/p\u003e\u003cpre\u003e zip_hold_lhs_err even [1..5] \"abc\" == zip [1..6] \"abbcc\"\n zip_hold_lhs_err odd [1..6] \"abc\" == zip [1..6] \"aabbcc\"\n zip_hold_lhs_err id [False,False] \"a\" == undefined\n zip_hold_lhs_err id [False] \"ab\" == undefined\n\u003c/pre\u003e",
          "module": "Music.Theory.Duration.Sequence.Notate",
          "name": "zip_hold_lhs_err",
          "package": "hmt",
          "signature": "(x -\u003e Bool) -\u003e [x] -\u003e [a] -\u003e [(x, a)]",
          "source": "src/Music-Theory-Duration-Sequence-Notate.html#zip_hold_lhs_err",
          "type": "function"
        },
        "index": {
          "description": "Variant of zip hold that requires the right hand side to be precisely the required length zip hold lhs err even abc zip abbcc zip hold lhs err odd abc zip aabbcc zip hold lhs err id False False undefined zip hold lhs err id False ab undefined",
          "hierarchy": "Music Theory Duration Sequence Notate",
          "module": "Music.Theory.Duration.Sequence.Notate",
          "name": "zip_hold_lhs_err",
          "normalized": "(a-\u003eBool)-\u003e[a]-\u003e[b]-\u003e[(a,b)]",
          "package": "hmt",
          "signature": "(x-\u003eBool)-\u003e[x]-\u003e[a]-\u003e[(x,a)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Duration-Sequence-Notate.html#v:zip_hold_lhs_err"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eCommon music notation duration model.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Music.Theory.Duration",
          "name": "Duration",
          "package": "hmt",
          "source": "src/Music-Theory-Duration.html",
          "type": "module"
        },
        "index": {
          "description": "Common music notation duration model",
          "hierarchy": "Music Theory Duration",
          "module": "Music.Theory.Duration",
          "name": "Duration",
          "package": "hmt",
          "partial": "Duration",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Duration.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCommon music notation durational model\n\u003c/p\u003e",
          "module": "Music.Theory.Duration",
          "name": "Duration",
          "package": "hmt",
          "source": "src/Music-Theory-Duration.html#Duration",
          "type": "data"
        },
        "index": {
          "description": "Common music notation durational model",
          "hierarchy": "Music Theory Duration",
          "module": "Music.Theory.Duration",
          "name": "Duration",
          "package": "hmt",
          "partial": "Duration",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Duration.html#t:Duration"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Duration",
          "name": "Duration",
          "package": "hmt",
          "signature": "Duration",
          "source": "src/Music-Theory-Duration.html#Duration",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Duration",
          "module": "Music.Theory.Duration",
          "name": "Duration",
          "package": "hmt",
          "partial": "Duration",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Duration.html#v:Duration"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003edivision of whole note\n\u003c/p\u003e",
          "module": "Music.Theory.Duration",
          "name": "division",
          "package": "hmt",
          "signature": "Integer",
          "source": "src/Music-Theory-Duration.html#Duration",
          "type": "function"
        },
        "index": {
          "description": "division of whole note",
          "hierarchy": "Music Theory Duration",
          "module": "Music.Theory.Duration",
          "name": "division",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Duration.html#v:division"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003enumber of dots\n\u003c/p\u003e",
          "module": "Music.Theory.Duration",
          "name": "dots",
          "package": "hmt",
          "signature": "Integer",
          "source": "src/Music-Theory-Duration.html#Duration",
          "type": "function"
        },
        "index": {
          "description": "number of dots",
          "hierarchy": "Music Theory Duration",
          "module": "Music.Theory.Duration",
          "name": "dots",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Duration.html#v:dots"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCalculate number of beams at \u003ccode\u003e\u003ca\u003eDuration\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e map duration_beam_count [half_note,sixteenth_note] == [0,2]\n\u003c/pre\u003e",
          "module": "Music.Theory.Duration",
          "name": "duration_beam_count",
          "package": "hmt",
          "signature": "Duration -\u003e Integer",
          "source": "src/Music-Theory-Duration.html#duration_beam_count",
          "type": "function"
        },
        "index": {
          "description": "Calculate number of beams at Duration map duration beam count half note sixteenth note",
          "hierarchy": "Music Theory Duration",
          "module": "Music.Theory.Duration",
          "name": "duration_beam_count",
          "normalized": "Duration-\u003eInteger",
          "package": "hmt",
          "signature": "Duration-\u003eInteger",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Duration.html#v:duration_beam_count"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCompare durations with equal multipliers.\n\u003c/p\u003e",
          "module": "Music.Theory.Duration",
          "name": "duration_compare_meq",
          "package": "hmt",
          "signature": "Duration -\u003e Duration -\u003e Maybe Ordering",
          "source": "src/Music-Theory-Duration.html#duration_compare_meq",
          "type": "function"
        },
        "index": {
          "description": "Compare durations with equal multipliers",
          "hierarchy": "Music Theory Duration",
          "module": "Music.Theory.Duration",
          "name": "duration_compare_meq",
          "normalized": "Duration-\u003eDuration-\u003eMaybe Ordering",
          "package": "hmt",
          "signature": "Duration-\u003eDuration-\u003eMaybe Ordering",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Duration.html#v:duration_compare_meq"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eErroring variant of \u003ccode\u003e\u003ca\u003eduration_compare_meq\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Music.Theory.Duration",
          "name": "duration_compare_meq_err",
          "package": "hmt",
          "signature": "Duration -\u003e Duration -\u003e Ordering",
          "source": "src/Music-Theory-Duration.html#duration_compare_meq_err",
          "type": "function"
        },
        "index": {
          "description": "Erroring variant of duration compare meq",
          "hierarchy": "Music Theory Duration",
          "module": "Music.Theory.Duration",
          "name": "duration_compare_meq_err",
          "normalized": "Duration-\u003eDuration-\u003eOrdering",
          "package": "hmt",
          "signature": "Duration-\u003eDuration-\u003eOrdering",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Duration.html#v:duration_compare_meq_err"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAre multipliers equal?\n\u003c/p\u003e",
          "module": "Music.Theory.Duration",
          "name": "duration_meq",
          "package": "hmt",
          "signature": "Duration -\u003e Duration -\u003e Bool",
          "source": "src/Music-Theory-Duration.html#duration_meq",
          "type": "function"
        },
        "index": {
          "description": "Are multipliers equal",
          "hierarchy": "Music Theory Duration",
          "module": "Music.Theory.Duration",
          "name": "duration_meq",
          "normalized": "Duration-\u003eDuration-\u003eBool",
          "package": "hmt",
          "signature": "Duration-\u003eDuration-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Duration.html#v:duration_meq"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Duration",
          "name": "duration_pp",
          "package": "hmt",
          "signature": "Duration -\u003e Maybe String",
          "source": "src/Music-Theory-Duration.html#duration_pp",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Duration",
          "module": "Music.Theory.Duration",
          "name": "duration_pp",
          "normalized": "Duration-\u003eMaybe String",
          "package": "hmt",
          "signature": "Duration-\u003eMaybe String",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Duration.html#v:duration_pp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGive \u003cem\u003eLilypond\u003c/em\u003e notation for \u003ccode\u003e\u003ca\u003eDuration\u003c/a\u003e\u003c/code\u003e.  Note that the duration\n multiplier is \u003cem\u003enot\u003c/em\u003e written.\n\u003c/p\u003e\u003cpre\u003e import Music.Theory.Duration.Name\n map duration_to_lilypond_type [half_note,dotted_quarter_note] == [\"2\",\"4.\"]\n\u003c/pre\u003e",
          "module": "Music.Theory.Duration",
          "name": "duration_to_lilypond_type",
          "package": "hmt",
          "signature": "Duration -\u003e String",
          "source": "src/Music-Theory-Duration.html#duration_to_lilypond_type",
          "type": "function"
        },
        "index": {
          "description": "Give Lilypond notation for Duration Note that the duration multiplier is not written import Music.Theory.Duration.Name map duration to lilypond type half note dotted quarter note",
          "hierarchy": "Music Theory Duration",
          "module": "Music.Theory.Duration",
          "name": "duration_to_lilypond_type",
          "normalized": "Duration-\u003eString",
          "package": "hmt",
          "signature": "Duration-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Duration.html#v:duration_to_lilypond_type"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eVariant of \u003ccode\u003e\u003ca\u003ewhole_note_division_to_musicxml_type\u003c/a\u003e\u003c/code\u003e extracting\n \u003ccode\u003e\u003ca\u003edivision\u003c/a\u003e\u003c/code\u003e from \u003ccode\u003e\u003ca\u003eDuration\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e duration_to_musicxml_type quarter_note == \"quarter\"\n\u003c/pre\u003e",
          "module": "Music.Theory.Duration",
          "name": "duration_to_musicxml_type",
          "package": "hmt",
          "signature": "Duration -\u003e String",
          "source": "src/Music-Theory-Duration.html#duration_to_musicxml_type",
          "type": "function"
        },
        "index": {
          "description": "Variant of whole note division to musicxml type extracting division from Duration duration to musicxml type quarter note quarter",
          "hierarchy": "Music Theory Duration",
          "module": "Music.Theory.Duration",
          "name": "duration_to_musicxml_type",
          "normalized": "Duration-\u003eString",
          "package": "hmt",
          "signature": "Duration-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Duration.html#v:duration_to_musicxml_type"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003etuplet modifier\n\u003c/p\u003e",
          "module": "Music.Theory.Duration",
          "name": "multiplier",
          "package": "hmt",
          "signature": "Rational",
          "source": "src/Music-Theory-Duration.html#Duration",
          "type": "function"
        },
        "index": {
          "description": "tuplet modifier",
          "hierarchy": "Music Theory Duration",
          "module": "Music.Theory.Duration",
          "name": "multiplier",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Duration.html#v:multiplier"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTrue if neither duration is dotted.\n\u003c/p\u003e",
          "module": "Music.Theory.Duration",
          "name": "no_dots",
          "package": "hmt",
          "signature": "(Duration, Duration) -\u003e Bool",
          "source": "src/Music-Theory-Duration.html#no_dots",
          "type": "function"
        },
        "index": {
          "description": "True if neither duration is dotted",
          "hierarchy": "Music Theory Duration",
          "module": "Music.Theory.Duration",
          "name": "no_dots",
          "normalized": "(Duration,Duration)-\u003eBool",
          "package": "hmt",
          "signature": "(Duration,Duration)-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Duration.html#v:no_dots"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Duration",
          "name": "order_pair",
          "package": "hmt",
          "signature": "Ordering -\u003e (t, t) -\u003e (t, t)",
          "source": "src/Music-Theory-Duration.html#order_pair",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Duration",
          "module": "Music.Theory.Duration",
          "name": "order_pair",
          "normalized": "Ordering-\u003e(a,a)-\u003e(a,a)",
          "package": "hmt",
          "signature": "Ordering-\u003e(t,t)-\u003e(t,t)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Duration.html#v:order_pair"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSort a pair of equal type values using given comparison function.\n\u003c/p\u003e\u003cpre\u003e sort_pair compare ('b','a') == ('a','b')\n\u003c/pre\u003e",
          "module": "Music.Theory.Duration",
          "name": "sort_pair",
          "package": "hmt",
          "signature": "(t -\u003e t -\u003e Ordering) -\u003e (t, t) -\u003e (t, t)",
          "source": "src/Music-Theory-Duration.html#sort_pair",
          "type": "function"
        },
        "index": {
          "description": "Sort pair of equal type values using given comparison function sort pair compare",
          "hierarchy": "Music Theory Duration",
          "module": "Music.Theory.Duration",
          "name": "sort_pair",
          "normalized": "(a-\u003ea-\u003eOrdering)-\u003e(a,a)-\u003e(a,a)",
          "package": "hmt",
          "signature": "(t-\u003et-\u003eOrdering)-\u003e(t,t)-\u003e(t,t)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Duration.html#v:sort_pair"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Duration",
          "name": "sort_pair_m",
          "package": "hmt",
          "signature": "(t -\u003e t -\u003e Maybe Ordering) -\u003e (t, t) -\u003e Maybe (t, t)",
          "source": "src/Music-Theory-Duration.html#sort_pair_m",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Duration",
          "module": "Music.Theory.Duration",
          "name": "sort_pair_m",
          "normalized": "(a-\u003ea-\u003eMaybe Ordering)-\u003e(a,a)-\u003eMaybe(a,a)",
          "package": "hmt",
          "signature": "(t-\u003et-\u003eMaybe Ordering)-\u003e(t,t)-\u003eMaybe(t,t)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Duration.html#v:sort_pair_m"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSum durations.  Not all durations can be summed, and the present\n   algorithm is not exhaustive.\n\u003c/p\u003e\u003cpre\u003e import Music.Theory.Duration.Name\n sum_dur quarter_note eighth_note == Just dotted_quarter_note\n sum_dur dotted_quarter_note eighth_note == Just half_note\n sum_dur quarter_note dotted_eighth_note == Just double_dotted_quarter_note\n\u003c/pre\u003e",
          "module": "Music.Theory.Duration",
          "name": "sum_dur",
          "package": "hmt",
          "signature": "Duration -\u003e Duration -\u003e Maybe Duration",
          "source": "src/Music-Theory-Duration.html#sum_dur",
          "type": "function"
        },
        "index": {
          "description": "Sum durations Not all durations can be summed and the present algorithm is not exhaustive import Music.Theory.Duration.Name sum dur quarter note eighth note Just dotted quarter note sum dur dotted quarter note eighth note Just half note sum dur quarter note dotted eighth note Just double dotted quarter note",
          "hierarchy": "Music Theory Duration",
          "module": "Music.Theory.Duration",
          "name": "sum_dur",
          "normalized": "Duration-\u003eDuration-\u003eMaybe Duration",
          "package": "hmt",
          "signature": "Duration-\u003eDuration-\u003eMaybe Duration",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Duration.html#v:sum_dur"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eErroring variant of \u003ccode\u003e\u003ca\u003esum_dur\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Music.Theory.Duration",
          "name": "sum_dur'",
          "package": "hmt",
          "signature": "Duration -\u003e Duration -\u003e Duration",
          "source": "src/Music-Theory-Duration.html#sum_dur%27",
          "type": "function"
        },
        "index": {
          "description": "Erroring variant of sum dur",
          "hierarchy": "Music Theory Duration",
          "module": "Music.Theory.Duration",
          "name": "sum_dur'",
          "normalized": "Duration-\u003eDuration-\u003eDuration",
          "package": "hmt",
          "signature": "Duration-\u003eDuration-\u003eDuration",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Duration.html#v:sum_dur-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSum dotted divisions, input is required to be sorted.\n\u003c/p\u003e\u003cpre\u003e sum_dur_dotted (4,1,4,1) == Just (Duration 2 1 1)\n sum_dur_dotted (4,0,2,1) == Just (Duration 1 0 1)\n sum_dur_dotted (8,1,4,0) == Just (Duration 4 2 1)\n sum_dur_dotted (16,0,4,2) == Just (Duration 2 0 1)\n\u003c/pre\u003e",
          "module": "Music.Theory.Duration",
          "name": "sum_dur_dotted",
          "package": "hmt",
          "signature": "(Integer, Integer, Integer, Integer) -\u003e Maybe Duration",
          "source": "src/Music-Theory-Duration.html#sum_dur_dotted",
          "type": "function"
        },
        "index": {
          "description": "Sum dotted divisions input is required to be sorted sum dur dotted Just Duration sum dur dotted Just Duration sum dur dotted Just Duration sum dur dotted Just Duration",
          "hierarchy": "Music Theory Duration",
          "module": "Music.Theory.Duration",
          "name": "sum_dur_dotted",
          "normalized": "(Integer,Integer,Integer,Integer)-\u003eMaybe Duration",
          "package": "hmt",
          "signature": "(Integer,Integer,Integer,Integer)-\u003eMaybe Duration",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Duration.html#v:sum_dur_dotted"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSum undotted divisions, input is required to be sorted.\n\u003c/p\u003e",
          "module": "Music.Theory.Duration",
          "name": "sum_dur_undotted",
          "package": "hmt",
          "signature": "(Integer, Integer) -\u003e Maybe Duration",
          "source": "src/Music-Theory-Duration.html#sum_dur_undotted",
          "type": "function"
        },
        "index": {
          "description": "Sum undotted divisions input is required to be sorted",
          "hierarchy": "Music Theory Duration",
          "module": "Music.Theory.Duration",
          "name": "sum_dur_undotted",
          "normalized": "(Integer,Integer)-\u003eMaybe Duration",
          "package": "hmt",
          "signature": "(Integer,Integer)-\u003eMaybe Duration",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Duration.html#v:sum_dur_undotted"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Duration",
          "name": "whole_note_division_pp",
          "package": "hmt",
          "signature": "Integer -\u003e Maybe Char",
          "source": "src/Music-Theory-Duration.html#whole_note_division_pp",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Duration",
          "module": "Music.Theory.Duration",
          "name": "whole_note_division_pp",
          "normalized": "Integer-\u003eMaybe Char",
          "package": "hmt",
          "signature": "Integer-\u003eMaybe Char",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Duration.html#v:whole_note_division_pp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCalculate number of beams at notated division.\n\u003c/p\u003e\u003cpre\u003e whole_note_division_to_beam_count 32 == Just 3\n\u003c/pre\u003e",
          "module": "Music.Theory.Duration",
          "name": "whole_note_division_to_beam_count",
          "package": "hmt",
          "signature": "Integer -\u003e Maybe Integer",
          "source": "src/Music-Theory-Duration.html#whole_note_division_to_beam_count",
          "type": "function"
        },
        "index": {
          "description": "Calculate number of beams at notated division whole note division to beam count Just",
          "hierarchy": "Music Theory Duration",
          "module": "Music.Theory.Duration",
          "name": "whole_note_division_to_beam_count",
          "normalized": "Integer-\u003eMaybe Integer",
          "package": "hmt",
          "signature": "Integer-\u003eMaybe Integer",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Duration.html#v:whole_note_division_to_beam_count"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGive \u003ccode\u003eMusicXML\u003c/code\u003e type for division.\n\u003c/p\u003e\u003cpre\u003e map whole_note_division_to_musicxml_type [2,4] == [\"half\",\"quarter\"]\n\u003c/pre\u003e",
          "module": "Music.Theory.Duration",
          "name": "whole_note_division_to_musicxml_type",
          "package": "hmt",
          "signature": "Integer -\u003e String",
          "source": "src/Music-Theory-Duration.html#whole_note_division_to_musicxml_type",
          "type": "function"
        },
        "index": {
          "description": "Give MusicXML type for division map whole note division to musicxml type half quarter",
          "hierarchy": "Music Theory Duration",
          "module": "Music.Theory.Duration",
          "name": "whole_note_division_to_musicxml_type",
          "normalized": "Integer-\u003eString",
          "package": "hmt",
          "signature": "Integer-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Duration.html#v:whole_note_division_to_musicxml_type"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eCommon music notation dynamic marks.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Music.Theory.Dynamic_Mark",
          "name": "Dynamic_Mark",
          "package": "hmt",
          "source": "src/Music-Theory-Dynamic_Mark.html",
          "type": "module"
        },
        "index": {
          "description": "Common music notation dynamic marks",
          "hierarchy": "Music Theory Dynamic_Mark",
          "module": "Music.Theory.Dynamic_Mark",
          "name": "Dynamic_Mark",
          "package": "hmt",
          "partial": "Dynamic Mark",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Dynamic_Mark.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEnumeration of dynamic mark symbols.\n\u003c/p\u003e",
          "module": "Music.Theory.Dynamic_Mark",
          "name": "Dynamic_Mark_T",
          "package": "hmt",
          "source": "src/Music-Theory-Dynamic_Mark.html#Dynamic_Mark_T",
          "type": "data"
        },
        "index": {
          "description": "Enumeration of dynamic mark symbols",
          "hierarchy": "Music Theory Dynamic_Mark",
          "module": "Music.Theory.Dynamic_Mark",
          "name": "Dynamic_Mark_T",
          "package": "hmt",
          "partial": "Dynamic Mark",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Dynamic_Mark.html#t:Dynamic_Mark_T"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA node in a dynamic sequence.\n\u003c/p\u003e",
          "module": "Music.Theory.Dynamic_Mark",
          "name": "Dynamic_Node",
          "package": "hmt",
          "source": "src/Music-Theory-Dynamic_Mark.html#Dynamic_Node",
          "type": "type"
        },
        "index": {
          "description": "node in dynamic sequence",
          "hierarchy": "Music Theory Dynamic_Mark",
          "module": "Music.Theory.Dynamic_Mark",
          "name": "Dynamic_Node",
          "package": "hmt",
          "partial": "Dynamic Node",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Dynamic_Mark.html#t:Dynamic_Node"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEnumeration of hairpin indicators.\n\u003c/p\u003e",
          "module": "Music.Theory.Dynamic_Mark",
          "name": "Hairpin_T",
          "package": "hmt",
          "source": "src/Music-Theory-Dynamic_Mark.html#Hairpin_T",
          "type": "data"
        },
        "index": {
          "description": "Enumeration of hairpin indicators",
          "hierarchy": "Music Theory Dynamic_Mark",
          "module": "Music.Theory.Dynamic_Mark",
          "name": "Hairpin_T",
          "package": "hmt",
          "partial": "Hairpin",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Dynamic_Mark.html#t:Hairpin_T"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Dynamic_Mark",
          "name": "Crescendo",
          "package": "hmt",
          "signature": "Crescendo",
          "source": "src/Music-Theory-Dynamic_Mark.html#Hairpin_T",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Dynamic_Mark",
          "module": "Music.Theory.Dynamic_Mark",
          "name": "Crescendo",
          "package": "hmt",
          "partial": "Crescendo",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Dynamic_Mark.html#v:Crescendo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Dynamic_Mark",
          "name": "Diminuendo",
          "package": "hmt",
          "signature": "Diminuendo",
          "source": "src/Music-Theory-Dynamic_Mark.html#Hairpin_T",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Dynamic_Mark",
          "module": "Music.Theory.Dynamic_Mark",
          "name": "Diminuendo",
          "package": "hmt",
          "partial": "Diminuendo",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Dynamic_Mark.html#v:Diminuendo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Dynamic_Mark",
          "name": "End_Hairpin",
          "package": "hmt",
          "signature": "End_Hairpin",
          "source": "src/Music-Theory-Dynamic_Mark.html#Hairpin_T",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Dynamic_Mark",
          "module": "Music.Theory.Dynamic_Mark",
          "name": "End_Hairpin",
          "package": "hmt",
          "partial": "End Hairpin",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Dynamic_Mark.html#v:End_Hairpin"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Dynamic_Mark",
          "name": "F",
          "package": "hmt",
          "signature": "F",
          "source": "src/Music-Theory-Dynamic_Mark.html#Dynamic_Mark_T",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Dynamic_Mark",
          "module": "Music.Theory.Dynamic_Mark",
          "name": "F",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Dynamic_Mark.html#v:F"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Dynamic_Mark",
          "name": "FF",
          "package": "hmt",
          "signature": "FF",
          "source": "src/Music-Theory-Dynamic_Mark.html#Dynamic_Mark_T",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Dynamic_Mark",
          "module": "Music.Theory.Dynamic_Mark",
          "name": "FF",
          "package": "hmt",
          "partial": "FF",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Dynamic_Mark.html#v:FF"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Dynamic_Mark",
          "name": "FFF",
          "package": "hmt",
          "signature": "FFF",
          "source": "src/Music-Theory-Dynamic_Mark.html#Dynamic_Mark_T",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Dynamic_Mark",
          "module": "Music.Theory.Dynamic_Mark",
          "name": "FFF",
          "package": "hmt",
          "partial": "FFF",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Dynamic_Mark.html#v:FFF"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Dynamic_Mark",
          "name": "FFFF",
          "package": "hmt",
          "signature": "FFFF",
          "source": "src/Music-Theory-Dynamic_Mark.html#Dynamic_Mark_T",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Dynamic_Mark",
          "module": "Music.Theory.Dynamic_Mark",
          "name": "FFFF",
          "package": "hmt",
          "partial": "FFFF",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Dynamic_Mark.html#v:FFFF"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Dynamic_Mark",
          "name": "FFFFF",
          "package": "hmt",
          "signature": "FFFFF",
          "source": "src/Music-Theory-Dynamic_Mark.html#Dynamic_Mark_T",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Dynamic_Mark",
          "module": "Music.Theory.Dynamic_Mark",
          "name": "FFFFF",
          "package": "hmt",
          "partial": "FFFFF",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Dynamic_Mark.html#v:FFFFF"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Dynamic_Mark",
          "name": "FP",
          "package": "hmt",
          "signature": "FP",
          "source": "src/Music-Theory-Dynamic_Mark.html#Dynamic_Mark_T",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Dynamic_Mark",
          "module": "Music.Theory.Dynamic_Mark",
          "name": "FP",
          "package": "hmt",
          "partial": "FP",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Dynamic_Mark.html#v:FP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Dynamic_Mark",
          "name": "MF",
          "package": "hmt",
          "signature": "MF",
          "source": "src/Music-Theory-Dynamic_Mark.html#Dynamic_Mark_T",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Dynamic_Mark",
          "module": "Music.Theory.Dynamic_Mark",
          "name": "MF",
          "package": "hmt",
          "partial": "MF",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Dynamic_Mark.html#v:MF"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Dynamic_Mark",
          "name": "MP",
          "package": "hmt",
          "signature": "MP",
          "source": "src/Music-Theory-Dynamic_Mark.html#Dynamic_Mark_T",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Dynamic_Mark",
          "module": "Music.Theory.Dynamic_Mark",
          "name": "MP",
          "package": "hmt",
          "partial": "MP",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Dynamic_Mark.html#v:MP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Dynamic_Mark",
          "name": "Niente",
          "package": "hmt",
          "signature": "Niente",
          "source": "src/Music-Theory-Dynamic_Mark.html#Dynamic_Mark_T",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Dynamic_Mark",
          "module": "Music.Theory.Dynamic_Mark",
          "name": "Niente",
          "package": "hmt",
          "partial": "Niente",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Dynamic_Mark.html#v:Niente"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Dynamic_Mark",
          "name": "P",
          "package": "hmt",
          "signature": "P",
          "source": "src/Music-Theory-Dynamic_Mark.html#Dynamic_Mark_T",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Dynamic_Mark",
          "module": "Music.Theory.Dynamic_Mark",
          "name": "P",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Dynamic_Mark.html#v:P"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Dynamic_Mark",
          "name": "PP",
          "package": "hmt",
          "signature": "PP",
          "source": "src/Music-Theory-Dynamic_Mark.html#Dynamic_Mark_T",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Dynamic_Mark",
          "module": "Music.Theory.Dynamic_Mark",
          "name": "PP",
          "package": "hmt",
          "partial": "PP",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Dynamic_Mark.html#v:PP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Dynamic_Mark",
          "name": "PPP",
          "package": "hmt",
          "signature": "PPP",
          "source": "src/Music-Theory-Dynamic_Mark.html#Dynamic_Mark_T",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Dynamic_Mark",
          "module": "Music.Theory.Dynamic_Mark",
          "name": "PPP",
          "package": "hmt",
          "partial": "PPP",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Dynamic_Mark.html#v:PPP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Dynamic_Mark",
          "name": "PPPP",
          "package": "hmt",
          "signature": "PPPP",
          "source": "src/Music-Theory-Dynamic_Mark.html#Dynamic_Mark_T",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Dynamic_Mark",
          "module": "Music.Theory.Dynamic_Mark",
          "name": "PPPP",
          "package": "hmt",
          "partial": "PPPP",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Dynamic_Mark.html#v:PPPP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Dynamic_Mark",
          "name": "PPPPP",
          "package": "hmt",
          "signature": "PPPPP",
          "source": "src/Music-Theory-Dynamic_Mark.html#Dynamic_Mark_T",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Dynamic_Mark",
          "module": "Music.Theory.Dynamic_Mark",
          "name": "PPPPP",
          "package": "hmt",
          "partial": "PPPPP",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Dynamic_Mark.html#v:PPPPP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Dynamic_Mark",
          "name": "SF",
          "package": "hmt",
          "signature": "SF",
          "source": "src/Music-Theory-Dynamic_Mark.html#Dynamic_Mark_T",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Dynamic_Mark",
          "module": "Music.Theory.Dynamic_Mark",
          "name": "SF",
          "package": "hmt",
          "partial": "SF",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Dynamic_Mark.html#v:SF"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Dynamic_Mark",
          "name": "SFFZ",
          "package": "hmt",
          "signature": "SFFZ",
          "source": "src/Music-Theory-Dynamic_Mark.html#Dynamic_Mark_T",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Dynamic_Mark",
          "module": "Music.Theory.Dynamic_Mark",
          "name": "SFFZ",
          "package": "hmt",
          "partial": "SFFZ",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Dynamic_Mark.html#v:SFFZ"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Dynamic_Mark",
          "name": "SFP",
          "package": "hmt",
          "signature": "SFP",
          "source": "src/Music-Theory-Dynamic_Mark.html#Dynamic_Mark_T",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Dynamic_Mark",
          "module": "Music.Theory.Dynamic_Mark",
          "name": "SFP",
          "package": "hmt",
          "partial": "SFP",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Dynamic_Mark.html#v:SFP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Dynamic_Mark",
          "name": "SFPP",
          "package": "hmt",
          "signature": "SFPP",
          "source": "src/Music-Theory-Dynamic_Mark.html#Dynamic_Mark_T",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Dynamic_Mark",
          "module": "Music.Theory.Dynamic_Mark",
          "name": "SFPP",
          "package": "hmt",
          "partial": "SFPP",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Dynamic_Mark.html#v:SFPP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Dynamic_Mark",
          "name": "SFZ",
          "package": "hmt",
          "signature": "SFZ",
          "source": "src/Music-Theory-Dynamic_Mark.html#Dynamic_Mark_T",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Dynamic_Mark",
          "module": "Music.Theory.Dynamic_Mark",
          "name": "SFZ",
          "package": "hmt",
          "partial": "SFZ",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Dynamic_Mark.html#v:SFZ"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eApply \u003ccode\u003e\u003ca\u003eHairpin_T\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003eDynamic_Mark_T\u003c/a\u003e\u003c/code\u003e functions in that order as\n required by \u003ccode\u003e\u003ca\u003eDynamic_Node\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e let f _ x = show x\n in apply_dynamic_node f f (Nothing,Just Crescendo) undefined\n\u003c/pre\u003e",
          "module": "Music.Theory.Dynamic_Mark",
          "name": "apply_dynamic_node",
          "package": "hmt",
          "signature": "(a -\u003e Dynamic_Mark_T -\u003e a) -\u003e (a -\u003e Hairpin_T -\u003e a) -\u003e Dynamic_Node -\u003e a -\u003e a",
          "source": "src/Music-Theory-Dynamic_Mark.html#apply_dynamic_node",
          "type": "function"
        },
        "index": {
          "description": "Apply Hairpin and Dynamic Mark functions in that order as required by Dynamic Node let show in apply dynamic node Nothing Just Crescendo undefined",
          "hierarchy": "Music Theory Dynamic_Mark",
          "module": "Music.Theory.Dynamic_Mark",
          "name": "apply_dynamic_node",
          "normalized": "(a-\u003eDynamic_Mark_T-\u003ea)-\u003e(a-\u003eHairpin_T-\u003ea)-\u003eDynamic_Node-\u003ea-\u003ea",
          "package": "hmt",
          "signature": "(a-\u003eDynamic_Mark_T-\u003ea)-\u003e(a-\u003eHairpin_T-\u003ea)-\u003eDynamic_Node-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Dynamic_Mark.html#v:apply_dynamic_node"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDelete redundant (unaltered) dynamic marks.\n\u003c/p\u003e\u003cpre\u003e let s = [Just P,Nothing,Just P,Just P,Just F]\n in delete_redundant_marks s == [Just P,Nothing,Nothing,Nothing,Just F]\n\u003c/pre\u003e",
          "module": "Music.Theory.Dynamic_Mark",
          "name": "delete_redundant_marks",
          "package": "hmt",
          "signature": "[Maybe Dynamic_Mark_T] -\u003e [Maybe Dynamic_Mark_T]",
          "source": "src/Music-Theory-Dynamic_Mark.html#delete_redundant_marks",
          "type": "function"
        },
        "index": {
          "description": "Delete redundant unaltered dynamic marks let Just Nothing Just Just Just in delete redundant marks Just Nothing Nothing Nothing Just",
          "hierarchy": "Music Theory Dynamic_Mark",
          "module": "Music.Theory.Dynamic_Mark",
          "name": "delete_redundant_marks",
          "normalized": "[Maybe Dynamic_Mark_T]-\u003e[Maybe Dynamic_Mark_T]",
          "package": "hmt",
          "signature": "[Maybe Dynamic_Mark_T]-\u003e[Maybe Dynamic_Mark_T]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Dynamic_Mark.html#v:delete_redundant_marks"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTranslate \u003cem\u003efixed\u003c/em\u003e \u003ccode\u003e\u003ca\u003eDynamic_Mark_T\u003c/a\u003e\u003c/code\u003es to \u003cem\u003edb\u003c/em\u003e amplitude over given\n \u003cem\u003erange\u003c/em\u003e.\n\u003c/p\u003e\u003cpre\u003e mapMaybe (dynamic_mark_db 120) [Niente,P,F,FFFFF] == [-120,-70,-40,0]\n mapMaybe (dynamic_mark_db 60) [Niente,P,F,FFFFF] == [-60,-35,-20,0]\n\u003c/pre\u003e",
          "module": "Music.Theory.Dynamic_Mark",
          "name": "dynamic_mark_db",
          "package": "hmt",
          "signature": "n -\u003e Dynamic_Mark_T -\u003e Maybe n",
          "source": "src/Music-Theory-Dynamic_Mark.html#dynamic_mark_db",
          "type": "function"
        },
        "index": {
          "description": "Translate fixed Dynamic Mark to db amplitude over given range mapMaybe dynamic mark db Niente FFFFF mapMaybe dynamic mark db Niente FFFFF",
          "hierarchy": "Music Theory Dynamic_Mark",
          "module": "Music.Theory.Dynamic_Mark",
          "name": "dynamic_mark_db",
          "normalized": "a-\u003eDynamic_Mark_T-\u003eMaybe a",
          "package": "hmt",
          "signature": "n-\u003eDynamic_Mark_T-\u003eMaybe n",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Dynamic_Mark.html#v:dynamic_mark_db"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLookup MIDI velocity for \u003ccode\u003e\u003ca\u003eDynamic_Mark_T\u003c/a\u003e\u003c/code\u003e.  The range is linear\n in \u003ccode\u003e0-127\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e let r = [0,6,17,28,39,50,61,72,83,94,105,116,127]\n in mapMaybe dynamic_mark_midi [Niente .. FFFFF] == r\n\u003c/pre\u003e",
          "module": "Music.Theory.Dynamic_Mark",
          "name": "dynamic_mark_midi",
          "package": "hmt",
          "signature": "Dynamic_Mark_T -\u003e Maybe n",
          "source": "src/Music-Theory-Dynamic_Mark.html#dynamic_mark_midi",
          "type": "function"
        },
        "index": {
          "description": "Lookup MIDI velocity for Dynamic Mark The range is linear in let in mapMaybe dynamic mark midi Niente FFFFF",
          "hierarchy": "Music Theory Dynamic_Mark",
          "module": "Music.Theory.Dynamic_Mark",
          "name": "dynamic_mark_midi",
          "normalized": "Dynamic_Mark_T-\u003eMaybe a",
          "package": "hmt",
          "signature": "Dynamic_Mark_T-\u003eMaybe n",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Dynamic_Mark.html#v:dynamic_mark_midi"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCalculate a \u003ccode\u003e\u003ca\u003eDynamic_Node\u003c/a\u003e\u003c/code\u003e sequence from a sequence of\n \u003ccode\u003e\u003ca\u003eDynamic_Mark_T\u003c/a\u003e\u003c/code\u003es.\n\u003c/p\u003e\u003cpre\u003e dynamic_sequence [PP,MP,MP,PP] == [(Just PP,Just Crescendo)\n                                   ,(Just MP,Just End_Hairpin)\n                                   ,(Nothing,Just Diminuendo)\n                                   ,(Just PP,Just End_Hairpin)]\n\u003c/pre\u003e",
          "module": "Music.Theory.Dynamic_Mark",
          "name": "dynamic_sequence",
          "package": "hmt",
          "signature": "[Dynamic_Mark_T] -\u003e [Dynamic_Node]",
          "source": "src/Music-Theory-Dynamic_Mark.html#dynamic_sequence",
          "type": "function"
        },
        "index": {
          "description": "Calculate Dynamic Node sequence from sequence of Dynamic Mark dynamic sequence PP MP MP PP Just PP Just Crescendo Just MP Just End Hairpin Nothing Just Diminuendo Just PP Just End Hairpin",
          "hierarchy": "Music Theory Dynamic_Mark",
          "module": "Music.Theory.Dynamic_Mark",
          "name": "dynamic_sequence",
          "normalized": "[Dynamic_Mark_T]-\u003e[Dynamic_Node]",
          "package": "hmt",
          "signature": "[Dynamic_Mark_T]-\u003e[Dynamic_Node]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Dynamic_Mark.html#v:dynamic_sequence"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eVariant of \u003ccode\u003e\u003ca\u003edynamic_sequence\u003c/a\u003e\u003c/code\u003e for sequences of \u003ccode\u003e\u003ca\u003eDynamic_Mark_T\u003c/a\u003e\u003c/code\u003e\n with holes (ie. rests).  Runs \u003ccode\u003e\u003ca\u003edelete_redundant_marks\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e let r = [Just (Just P,Just Crescendo),Just (Just F,Just End_Hairpin)\n         ,Nothing,Just (Just P,Nothing)]\n in dynamic_sequence_sets [Just P,Just F,Nothing,Just P] == r\n\u003c/pre\u003e\u003cpre\u003e let s = [Just P,Nothing,Just P]\n in dynamic_sequence_sets s = [Just (Just P,Nothing),Nothing,Nothing]\n\u003c/pre\u003e",
          "module": "Music.Theory.Dynamic_Mark",
          "name": "dynamic_sequence_sets",
          "package": "hmt",
          "signature": "[Maybe Dynamic_Mark_T] -\u003e [Maybe Dynamic_Node]",
          "source": "src/Music-Theory-Dynamic_Mark.html#dynamic_sequence_sets",
          "type": "function"
        },
        "index": {
          "description": "Variant of dynamic sequence for sequences of Dynamic Mark with holes ie rests Runs delete redundant marks let Just Just Just Crescendo Just Just Just End Hairpin Nothing Just Just Nothing in dynamic sequence sets Just Just Nothing Just let Just Nothing Just in dynamic sequence sets Just Just Nothing Nothing Nothing",
          "hierarchy": "Music Theory Dynamic_Mark",
          "module": "Music.Theory.Dynamic_Mark",
          "name": "dynamic_sequence_sets",
          "normalized": "[Maybe Dynamic_Mark_T]-\u003e[Maybe Dynamic_Node]",
          "package": "hmt",
          "signature": "[Maybe Dynamic_Mark_T]-\u003e[Maybe Dynamic_Node]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Dynamic_Mark.html#v:dynamic_sequence_sets"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe empty \u003ccode\u003e\u003ca\u003eDynamic_Node\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Music.Theory.Dynamic_Mark",
          "name": "empty_dynamic_node",
          "package": "hmt",
          "signature": "Dynamic_Node",
          "source": "src/Music-Theory-Dynamic_Mark.html#empty_dynamic_node",
          "type": "function"
        },
        "index": {
          "description": "The empty Dynamic Node",
          "hierarchy": "Music Theory Dynamic_Mark",
          "module": "Music.Theory.Dynamic_Mark",
          "name": "empty_dynamic_node",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Dynamic_Mark.html#v:empty_dynamic_node"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003eHairpin_T\u003c/a\u003e\u003c/code\u003e implied by a ordered pair of \u003ccode\u003e\u003ca\u003eDynamic_Mark_T\u003c/a\u003e\u003c/code\u003es.\n\u003c/p\u003e\u003cpre\u003e map (implied_hairpin MF) [MP,F] == [Just Diminuendo,Just Crescendo]\n\u003c/pre\u003e",
          "module": "Music.Theory.Dynamic_Mark",
          "name": "implied_hairpin",
          "package": "hmt",
          "signature": "Dynamic_Mark_T -\u003e Dynamic_Mark_T -\u003e Maybe Hairpin_T",
          "source": "src/Music-Theory-Dynamic_Mark.html#implied_hairpin",
          "type": "function"
        },
        "index": {
          "description": "The Hairpin implied by ordered pair of Dynamic Mark map implied hairpin MF MP Just Diminuendo Just Crescendo",
          "hierarchy": "Music Theory Dynamic_Mark",
          "module": "Music.Theory.Dynamic_Mark",
          "name": "implied_hairpin",
          "normalized": "Dynamic_Mark_T-\u003eDynamic_Mark_T-\u003eMaybe Hairpin_T",
          "package": "hmt",
          "signature": "Dynamic_Mark_T-\u003eDynamic_Mark_T-\u003eMaybe Hairpin_T",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Dynamic_Mark.html#v:implied_hairpin"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eClarence Barlow. \"Two Essays on Theory\".\n \u003cem\u003eComputer Music Journal\u003c/em\u003e, 11(1):44-60, 1987.\n Translated by Henning Lohner.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Music.Theory.Interval.Barlow_1987",
          "name": "Barlow_1987",
          "package": "hmt",
          "source": "src/Music-Theory-Interval-Barlow_1987.html",
          "type": "module"
        },
        "index": {
          "description": "Clarence Barlow Two Essays on Theory Computer Music Journal Translated by Henning Lohner",
          "hierarchy": "Music Theory Interval Barlow_1987",
          "module": "Music.Theory.Interval.Barlow_1987",
          "name": "Barlow_1987",
          "package": "hmt",
          "partial": "Barlow",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Interval-Barlow_1987.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSet of 1. interval size (cents), 2. intervals as product of\n powers of primes, 3. frequency ratio and 4. harmonicity value.\n\u003c/p\u003e",
          "module": "Music.Theory.Interval.Barlow_1987",
          "name": "Table_2_Row",
          "package": "hmt",
          "source": "src/Music-Theory-Interval-Barlow_1987.html#Table_2_Row",
          "type": "type"
        },
        "index": {
          "description": "Set of interval size cents intervals as product of powers of primes frequency ratio and harmonicity value",
          "hierarchy": "Music Theory Interval Barlow_1987",
          "module": "Music.Theory.Interval.Barlow_1987",
          "name": "Table_2_Row",
          "package": "hmt",
          "partial": "Table Row",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Interval-Barlow_1987.html#t:Table_2_Row"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eBarlow's \u003cem\u003eindigestibility\u003c/em\u003e function for prime numbers.\n\u003c/p\u003e\u003cpre\u003e map barlow [1,2,3,5,7,11,13] == [0,1,8/3,32/5,72/7,200/11,288/13]\n\u003c/pre\u003e",
          "module": "Music.Theory.Interval.Barlow_1987",
          "name": "barlow",
          "package": "hmt",
          "signature": "a -\u003e b",
          "source": "src/Music-Theory-Interval-Barlow_1987.html#barlow",
          "type": "function"
        },
        "index": {
          "description": "Barlow indigestibility function for prime numbers map barlow",
          "hierarchy": "Music Theory Interval Barlow_1987",
          "module": "Music.Theory.Interval.Barlow_1987",
          "name": "barlow",
          "normalized": "a-\u003eb",
          "package": "hmt",
          "signature": "a-\u003eb",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Interval-Barlow_1987.html#v:barlow"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInterval ratio to cents.\n\u003c/p\u003e\u003cpre\u003e map cents [16%15,16%9] == [111.73128526977776,996.0899982692251]\n\u003c/pre\u003e",
          "module": "Music.Theory.Interval.Barlow_1987",
          "name": "cents",
          "package": "hmt",
          "signature": "a -\u003e b",
          "source": "src/Music-Theory-Interval-Barlow_1987.html#cents",
          "type": "function"
        },
        "index": {
          "description": "Interval ratio to cents map cents",
          "hierarchy": "Music Theory Interval Barlow_1987",
          "module": "Music.Theory.Interval.Barlow_1987",
          "name": "cents",
          "normalized": "a-\u003eb",
          "package": "hmt",
          "signature": "a-\u003eb",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Interval-Barlow_1987.html#v:cents"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCompute the disharmonicity of the interval \u003cem\u003e(p,q)\u003c/em\u003e using the\n prime valuation function \u003cem\u003epv\u003c/em\u003e.\n\u003c/p\u003e\u003cpre\u003e map (disharmonicity barlow) [(9,10),(8,9)] ~= [12.733333,8.333333]\n\u003c/pre\u003e",
          "module": "Music.Theory.Interval.Barlow_1987",
          "name": "disharmonicity",
          "package": "hmt",
          "signature": "(a -\u003e b) -\u003e (a, a) -\u003e b",
          "source": "src/Music-Theory-Interval-Barlow_1987.html#disharmonicity",
          "type": "function"
        },
        "index": {
          "description": "Compute the disharmonicity of the interval using the prime valuation function pv map disharmonicity barlow",
          "hierarchy": "Music Theory Interval Barlow_1987",
          "module": "Music.Theory.Interval.Barlow_1987",
          "name": "disharmonicity",
          "normalized": "(a-\u003eb)-\u003e(a,a)-\u003eb",
          "package": "hmt",
          "signature": "(a-\u003eb)-\u003e(a,a)-\u003eb",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Interval-Barlow_1987.html#v:disharmonicity"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGenerate list of factors of \u003cem\u003en\u003c/em\u003e from \u003cem\u003ex\u003c/em\u003e.\n\u003c/p\u003e\u003cpre\u003e factor primes 315 == [3,3,5,7]\n\u003c/pre\u003e",
          "module": "Music.Theory.Interval.Barlow_1987",
          "name": "factor",
          "package": "hmt",
          "signature": "[a] -\u003e a -\u003e [a]",
          "source": "src/Music-Theory-Interval-Barlow_1987.html#factor",
          "type": "function"
        },
        "index": {
          "description": "Generate list of factors of from factor primes",
          "hierarchy": "Music Theory Interval Barlow_1987",
          "module": "Music.Theory.Interval.Barlow_1987",
          "name": "factor",
          "normalized": "[a]-\u003ea-\u003e[a]",
          "package": "hmt",
          "signature": "[a]-\u003ea-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Interval-Barlow_1987.html#v:factor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMake \u003ccode\u003e\u003ca\u003enumerator\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003edenominator\u003c/a\u003e\u003c/code\u003e pair of \u003cem\u003en\u003c/em\u003e.\n\u003c/p\u003e",
          "module": "Music.Theory.Interval.Barlow_1987",
          "name": "from_rational",
          "package": "hmt",
          "signature": "Ratio t -\u003e (t, t)",
          "source": "src/Music-Theory-Interval-Barlow_1987.html#from_rational",
          "type": "function"
        },
        "index": {
          "description": "Make numerator denominator pair of",
          "hierarchy": "Music Theory Interval Barlow_1987",
          "module": "Music.Theory.Interval.Barlow_1987",
          "name": "from_rational",
          "normalized": "Ratio a-\u003e(a,a)",
          "package": "hmt",
          "signature": "Ratio t-\u003e(t,t)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Interval-Barlow_1987.html#v:from_rational"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe reciprocal of \u003ccode\u003e\u003ca\u003edisharmonicity\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e map (harmonicity barlow) [(9,10),(8,9)] ~= [0.078534,0.120000]\n\u003c/pre\u003e",
          "module": "Music.Theory.Interval.Barlow_1987",
          "name": "harmonicity",
          "package": "hmt",
          "signature": "(a -\u003e b) -\u003e (a, a) -\u003e b",
          "source": "src/Music-Theory-Interval-Barlow_1987.html#harmonicity",
          "type": "function"
        },
        "index": {
          "description": "The reciprocal of disharmonicity map harmonicity barlow",
          "hierarchy": "Music Theory Interval Barlow_1987",
          "module": "Music.Theory.Interval.Barlow_1987",
          "name": "harmonicity",
          "normalized": "(a-\u003eb)-\u003e(a,a)-\u003eb",
          "package": "hmt",
          "signature": "(a-\u003eb)-\u003e(a,a)-\u003eb",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Interval-Barlow_1987.html#v:harmonicity"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eVariant of \u003ccode\u003e\u003ca\u003eharmonicity\u003c/a\u003e\u003c/code\u003e with \u003ccode\u003e\u003ca\u003eRatio\u003c/a\u003e\u003c/code\u003e input.\n\u003c/p\u003e",
          "module": "Music.Theory.Interval.Barlow_1987",
          "name": "harmonicity_r",
          "package": "hmt",
          "signature": "(a -\u003e b) -\u003e Ratio a -\u003e b",
          "source": "src/Music-Theory-Interval-Barlow_1987.html#harmonicity_r",
          "type": "function"
        },
        "index": {
          "description": "Variant of harmonicity with Ratio input",
          "hierarchy": "Music Theory Interval Barlow_1987",
          "module": "Music.Theory.Interval.Barlow_1987",
          "name": "harmonicity_r",
          "normalized": "(a-\u003eb)-\u003eRatio a-\u003eb",
          "package": "hmt",
          "signature": "(a-\u003eb)-\u003eRatio a-\u003eb",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Interval-Barlow_1987.html#v:harmonicity_r"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMerging function for \u003ccode\u003e\u003ca\u003erational_prime_factors_m\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Music.Theory.Interval.Barlow_1987",
          "name": "merge",
          "package": "hmt",
          "signature": "[(a, b)] -\u003e [(a, b)] -\u003e [(a, b)]",
          "source": "src/Music-Theory-Interval-Barlow_1987.html#merge",
          "type": "function"
        },
        "index": {
          "description": "Merging function for rational prime factors",
          "hierarchy": "Music Theory Interval Barlow_1987",
          "module": "Music.Theory.Interval.Barlow_1987",
          "name": "merge",
          "normalized": "[(a,b)]-\u003e[(a,b)]-\u003e[(a,b)]",
          "package": "hmt",
          "signature": "[(a,b)]-\u003e[(a,b)]-\u003e[(a,b)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Interval-Barlow_1987.html#v:merge"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCollect number of occurences of each element of a sorted list.\n\u003c/p\u003e\u003cpre\u003e multiplicities [1,1,1,2,2,3] == [(1,3),(2,2),(3,1)]\n\u003c/pre\u003e",
          "module": "Music.Theory.Interval.Barlow_1987",
          "name": "multiplicities",
          "package": "hmt",
          "signature": "[a] -\u003e [(a, n)]",
          "source": "src/Music-Theory-Interval-Barlow_1987.html#multiplicities",
          "type": "function"
        },
        "index": {
          "description": "Collect number of occurences of each element of sorted list multiplicities",
          "hierarchy": "Music Theory Interval Barlow_1987",
          "module": "Music.Theory.Interval.Barlow_1987",
          "name": "multiplicities",
          "normalized": "[a]-\u003e[(a,b)]",
          "package": "hmt",
          "signature": "[a]-\u003e[(a,n)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Interval-Barlow_1987.html#v:multiplicities"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003efactor\u003c/a\u003e\u003c/code\u003e \u003cem\u003en\u003c/em\u003e from \u003ccode\u003e\u003ca\u003eprimes\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e prime_factors 315 == [3,3,5,7]\n\u003c/pre\u003e",
          "module": "Music.Theory.Interval.Barlow_1987",
          "name": "prime_factors",
          "package": "hmt",
          "signature": "a -\u003e [a]",
          "source": "src/Music-Theory-Interval-Barlow_1987.html#prime_factors",
          "type": "function"
        },
        "index": {
          "description": "factor from primes prime factors",
          "hierarchy": "Music Theory Interval Barlow_1987",
          "module": "Music.Theory.Interval.Barlow_1987",
          "name": "prime_factors",
          "normalized": "a-\u003e[a]",
          "package": "hmt",
          "signature": "a-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Interval-Barlow_1987.html#v:prime_factors"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003emultiplicities\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eprime_factors\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e prime_factors_m 315 == [(3,2),(5,1),(7,1)]\n\u003c/pre\u003e",
          "module": "Music.Theory.Interval.Barlow_1987",
          "name": "prime_factors_m",
          "package": "hmt",
          "signature": "a -\u003e [(a, a)]",
          "source": "src/Music-Theory-Interval-Barlow_1987.html#prime_factors_m",
          "type": "function"
        },
        "index": {
          "description": "multiplicities prime factors prime factors",
          "hierarchy": "Music Theory Interval Barlow_1987",
          "module": "Music.Theory.Interval.Barlow_1987",
          "name": "prime_factors_m",
          "normalized": "a-\u003e[(a,a)]",
          "package": "hmt",
          "signature": "a-\u003e[(a,a)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Interval-Barlow_1987.html#v:prime_factors_m"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCollect the prime factors in a rational number given as a\n numerator/ denominator pair (n,m). Prime factors are listed in\n ascending order with their positive or negative multiplicities,\n depending on whether the prime factor occurs in the numerator or\n the denominator (after cancelling out common factors).\n\u003c/p\u003e\u003cpre\u003e rational_prime_factors_m (16,15) == [(2,4),(3,-1),(5,-1)]\n rational_prime_factors_m (10,9) == [(2,1),(3,-2),(5,1)]\n rational_prime_factors_m (81,64) == [(2,-6),(3,4)]\n rational_prime_factors_m (27,16) == [(2,-4),(3,3)]\n rational_prime_factors_m (12,7) == [(2,2),(3,1),(7,-1)]\n\u003c/pre\u003e",
          "module": "Music.Theory.Interval.Barlow_1987",
          "name": "rational_prime_factors_m",
          "package": "hmt",
          "signature": "(b, b) -\u003e [(b, b)]",
          "source": "src/Music-Theory-Interval-Barlow_1987.html#rational_prime_factors_m",
          "type": "function"
        },
        "index": {
          "description": "Collect the prime factors in rational number given as numerator denominator pair Prime factors are listed in ascending order with their positive or negative multiplicities depending on whether the prime factor occurs in the numerator or the denominator after cancelling out common factors rational prime factors rational prime factors rational prime factors rational prime factors rational prime factors",
          "hierarchy": "Music Theory Interval Barlow_1987",
          "module": "Music.Theory.Interval.Barlow_1987",
          "name": "rational_prime_factors_m",
          "normalized": "(a,a)-\u003e[(a,a)]",
          "package": "hmt",
          "signature": "(b,b)-\u003e[(b,b)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Interval-Barlow_1987.html#v:rational_prime_factors_m"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eVariant of \u003ccode\u003e\u003ca\u003erational_prime_factors_m\u003c/a\u003e\u003c/code\u003e giving results in a table\n up to the \u003cem\u003en\u003c/em\u003eth prime.\n\u003c/p\u003e\u003cpre\u003e rational_prime_factors_t 6 (12,7) == [2,1,0,-1,0,0]\n\u003c/pre\u003e",
          "module": "Music.Theory.Interval.Barlow_1987",
          "name": "rational_prime_factors_t",
          "package": "hmt",
          "signature": "Int -\u003e (b, b) -\u003e [b]",
          "source": "src/Music-Theory-Interval-Barlow_1987.html#rational_prime_factors_t",
          "type": "function"
        },
        "index": {
          "description": "Variant of rational prime factors giving results in table up to the th prime rational prime factors",
          "hierarchy": "Music Theory Interval Barlow_1987",
          "module": "Music.Theory.Interval.Barlow_1987",
          "name": "rational_prime_factors_t",
          "normalized": "Int-\u003e(a,a)-\u003e[a]",
          "package": "hmt",
          "signature": "Int-\u003e(b,b)-\u003e[b]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Interval-Barlow_1987.html#v:rational_prime_factors_t"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTable 2 (p.45)\n\u003c/p\u003e\u003cpre\u003e length (table_2 0.06) == 24\n\u003c/pre\u003e",
          "module": "Music.Theory.Interval.Barlow_1987",
          "name": "table_2",
          "package": "hmt",
          "signature": "Double -\u003e [Table_2_Row]",
          "source": "src/Music-Theory-Interval-Barlow_1987.html#table_2",
          "type": "function"
        },
        "index": {
          "description": "Table p.45 length table",
          "hierarchy": "Music Theory Interval Barlow_1987",
          "module": "Music.Theory.Interval.Barlow_1987",
          "name": "table_2",
          "normalized": "Double-\u003e[Table_ Row]",
          "package": "hmt",
          "signature": "Double-\u003e[Table_ Row]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Interval-Barlow_1987.html#v:table_2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePretty printer for \u003ccode\u003e\u003ca\u003eTable_2_Row\u003c/a\u003e\u003c/code\u003e values.\n\u003c/p\u003e\u003cpre\u003e mapM_ (putStrLn . table_2_pp) (table_2 0.06)\n\u003c/pre\u003e\u003cpre\u003e    0.000 |  0  0  0  0  0  0 |  1:1  | Infinity\n  111.731 |  4 -1 -1  0  0  0 | 15:16 | 0.076531\n  182.404 |  1 -2  1  0  0  0 |  9:10 | 0.078534\n  203.910 | -3  2  0  0  0  0 |  8:9  | 0.120000\n  231.174 |  3  0  0 -1  0  0 |  7:8  | 0.075269\n  266.871 | -1 -1  0  1  0  0 |  6:7  | 0.071672\n  294.135 |  5 -3  0  0  0  0 | 27:32 | 0.076923\n  315.641 |  1  1 -1  0  0  0 |  5:6  | 0.099338\n  386.314 | -2  0  1  0  0  0 |  4:5  | 0.119048\n  407.820 | -6  4  0  0  0  0 | 64:81 | 0.060000\n  435.084 |  0  2  0 -1  0  0 |  7:9  | 0.064024\n  498.045 |  2 -1  0  0  0  0 |  3:4  | 0.214286\n  519.551 | -2  3 -1  0  0  0 | 20:27 | 0.060976\n  701.955 | -1  1  0  0  0  0 |  2:3  | 0.272727\n  764.916 |  1 -2  0  1  0  0 |  9:14 | 0.060172\n  813.686 |  3  0 -1  0  0  0 |  5:8  | 0.106383\n  884.359 |  0 -1  1  0  0  0 |  3:5  | 0.110294\n  905.865 | -4  3  0  0  0  0 | 16:27 | 0.083333\n  933.129 |  2  1  0 -1  0  0 |  7:12 | 0.066879\n  968.826 | -2  0  0  1  0  0 |  4:7  | 0.081395\n  996.090 |  4 -2  0  0  0  0 |  9:16 | 0.107143\n 1017.596 |  0  2 -1  0  0  0 |  5:9  | 0.085227\n 1088.269 | -3  1  1  0  0  0 |  8:15 | 0.082873\n 1200.000 |  1  0  0  0  0  0 |  1:2  | 1.000000\n\u003c/pre\u003e",
          "module": "Music.Theory.Interval.Barlow_1987",
          "name": "table_2_pp",
          "package": "hmt",
          "signature": "Table_2_Row -\u003e String",
          "source": "src/Music-Theory-Interval-Barlow_1987.html#table_2_pp",
          "type": "function"
        },
        "index": {
          "description": "Pretty printer for Table Row values mapM putStrLn table pp table Infinity",
          "hierarchy": "Music Theory Interval Barlow_1987",
          "module": "Music.Theory.Interval.Barlow_1987",
          "name": "table_2_pp",
          "normalized": "Table_ Row-\u003eString",
          "package": "hmt",
          "signature": "Table_ Row-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Interval-Barlow_1987.html#v:table_2_pp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003euncurry\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003e%\u003c/a\u003e\u003c/code\u003e).\n\u003c/p\u003e",
          "module": "Music.Theory.Interval.Barlow_1987",
          "name": "to_rational",
          "package": "hmt",
          "signature": "(a, a) -\u003e Ratio a",
          "source": "src/Music-Theory-Interval-Barlow_1987.html#to_rational",
          "type": "function"
        },
        "index": {
          "description": "uncurry",
          "hierarchy": "Music Theory Interval Barlow_1987",
          "module": "Music.Theory.Interval.Barlow_1987",
          "name": "to_rational",
          "normalized": "(a,a)-\u003eRatio a",
          "package": "hmt",
          "signature": "(a,a)-\u003eRatio a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Interval-Barlow_1987.html#v:to_rational"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eConstants names for ascending \u003ccode\u003e\u003ca\u003eInterval\u003c/a\u003e\u003c/code\u003e values.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Music.Theory.Interval.Name",
          "name": "Name",
          "package": "hmt",
          "source": "src/Music-Theory-Interval-Name.html",
          "type": "module"
        },
        "index": {
          "description": "Constants names for ascending Interval values",
          "hierarchy": "Music Theory Interval Name",
          "module": "Music.Theory.Interval.Name",
          "name": "Name",
          "package": "hmt",
          "partial": "Name",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Interval-Name.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Interval.Name",
          "name": "major_seventh",
          "package": "hmt",
          "signature": "Interval",
          "source": "src/Music-Theory-Interval-Name.html#major_seventh",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Interval Name",
          "module": "Music.Theory.Interval.Name",
          "name": "major_seventh",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Interval-Name.html#v:major_seventh"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Interval.Name",
          "name": "perfect_fifth",
          "package": "hmt",
          "signature": "Interval",
          "source": "src/Music-Theory-Interval-Name.html#perfect_fifth",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Interval Name",
          "module": "Music.Theory.Interval.Name",
          "name": "perfect_fifth",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Interval-Name.html#v:perfect_fifth"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Interval.Name",
          "name": "perfect_fourth",
          "package": "hmt",
          "signature": "Interval",
          "source": "src/Music-Theory-Interval-Name.html#perfect_fourth",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Interval Name",
          "module": "Music.Theory.Interval.Name",
          "name": "perfect_fourth",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Interval-Name.html#v:perfect_fourth"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eSpelling rules for \u003ccode\u003e\u003ca\u003eInterval\u003c/a\u003e\u003c/code\u003e values.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Music.Theory.Interval.Spelling",
          "name": "Spelling",
          "package": "hmt",
          "source": "src/Music-Theory-Interval-Spelling.html",
          "type": "module"
        },
        "index": {
          "description": "Spelling rules for Interval values",
          "hierarchy": "Music Theory Interval Spelling",
          "module": "Music.Theory.Interval.Spelling",
          "name": "Spelling",
          "package": "hmt",
          "partial": "Spelling",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Interval-Spelling.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSimplest spelling for semitone intervals.  This is ambiguous for\n \u003ccode\u003e6\u003c/code\u003e which could be either \u003cem\u003eaug.4\u003c/em\u003e or \u003cem\u003edim.5\u003c/em\u003e.\n\u003c/p\u003e\u003cpre\u003e i_to_interval 6 == Interval Fourth Augmented LT 0\n map i_to_interval [0..11]\n\u003c/pre\u003e",
          "module": "Music.Theory.Interval.Spelling",
          "name": "i_to_interval",
          "package": "hmt",
          "signature": "Int -\u003e Interval",
          "source": "src/Music-Theory-Interval-Spelling.html#i_to_interval",
          "type": "function"
        },
        "index": {
          "description": "Simplest spelling for semitone intervals This is ambiguous for which could be either aug.4 or dim.5 to interval Interval Fourth Augmented LT map to interval",
          "hierarchy": "Music Theory Interval Spelling",
          "module": "Music.Theory.Interval.Spelling",
          "name": "i_to_interval",
          "normalized": "Int-\u003eInterval",
          "package": "hmt",
          "signature": "Int-\u003eInterval",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Interval-Spelling.html#v:i_to_interval"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePerform some interval simplifications.  For non-tonal music some\n spellings are poor, ie. (f,g#).\n\u003c/p\u003e\u003cpre\u003e interval_simplify (Interval Second Augmented LT 0) == Interval Third Minor LT 0\n\u003c/pre\u003e",
          "module": "Music.Theory.Interval.Spelling",
          "name": "interval_simplify",
          "package": "hmt",
          "signature": "Interval -\u003e Interval",
          "source": "src/Music-Theory-Interval-Spelling.html#interval_simplify",
          "type": "function"
        },
        "index": {
          "description": "Perform some interval simplifications For non-tonal music some spellings are poor ie interval simplify Interval Second Augmented LT Interval Third Minor LT",
          "hierarchy": "Music Theory Interval Spelling",
          "module": "Music.Theory.Interval.Spelling",
          "name": "interval_simplify",
          "normalized": "Interval-\u003eInterval",
          "package": "hmt",
          "signature": "Interval-\u003eInterval",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Interval-Spelling.html#v:interval_simplify"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eCommon music notation intervals.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Music.Theory.Interval",
          "name": "Interval",
          "package": "hmt",
          "source": "src/Music-Theory-Interval.html",
          "type": "module"
        },
        "index": {
          "description": "Common music notation intervals",
          "hierarchy": "Music Theory Interval",
          "module": "Music.Theory.Interval",
          "name": "Interval",
          "package": "hmt",
          "partial": "Interval",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Interval.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCommon music notation interval.  An \u003ccode\u003e\u003ca\u003eOrdering\u003c/a\u003e\u003c/code\u003e of \u003ccode\u003e\u003ca\u003eLT\u003c/a\u003e\u003c/code\u003e indicates\n an ascending interval, \u003ccode\u003e\u003ca\u003eGT\u003c/a\u003e\u003c/code\u003e a descending interval, and \u003ccode\u003e\u003ca\u003eEQ\u003c/a\u003e\u003c/code\u003e a\n unison.\n\u003c/p\u003e",
          "module": "Music.Theory.Interval",
          "name": "Interval",
          "package": "hmt",
          "source": "src/Music-Theory-Interval.html#Interval",
          "type": "data"
        },
        "index": {
          "description": "Common music notation interval An Ordering of LT indicates an ascending interval GT descending interval and EQ unison",
          "hierarchy": "Music Theory Interval",
          "module": "Music.Theory.Interval",
          "name": "Interval",
          "package": "hmt",
          "partial": "Interval",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Interval.html#t:Interval"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInterval quality.\n\u003c/p\u003e",
          "module": "Music.Theory.Interval",
          "name": "Interval_Q",
          "package": "hmt",
          "source": "src/Music-Theory-Interval.html#Interval_Q",
          "type": "data"
        },
        "index": {
          "description": "Interval quality",
          "hierarchy": "Music Theory Interval",
          "module": "Music.Theory.Interval",
          "name": "Interval_Q",
          "package": "hmt",
          "partial": "Interval",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Interval.html#t:Interval_Q"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInterval type or degree.\n\u003c/p\u003e",
          "module": "Music.Theory.Interval",
          "name": "Interval_T",
          "package": "hmt",
          "source": "src/Music-Theory-Interval.html#Interval_T",
          "type": "data"
        },
        "index": {
          "description": "Interval type or degree",
          "hierarchy": "Music Theory Interval",
          "module": "Music.Theory.Interval",
          "name": "Interval_T",
          "package": "hmt",
          "partial": "Interval",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Interval.html#t:Interval_T"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Interval",
          "name": "Augmented",
          "package": "hmt",
          "signature": "Augmented",
          "source": "src/Music-Theory-Interval.html#Interval_Q",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Interval",
          "module": "Music.Theory.Interval",
          "name": "Augmented",
          "package": "hmt",
          "partial": "Augmented",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Interval.html#v:Augmented"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Interval",
          "name": "Diminished",
          "package": "hmt",
          "signature": "Diminished",
          "source": "src/Music-Theory-Interval.html#Interval_Q",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Interval",
          "module": "Music.Theory.Interval",
          "name": "Diminished",
          "package": "hmt",
          "partial": "Diminished",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Interval.html#v:Diminished"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Interval",
          "name": "Fifth",
          "package": "hmt",
          "signature": "Fifth",
          "source": "src/Music-Theory-Interval.html#Interval_T",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Interval",
          "module": "Music.Theory.Interval",
          "name": "Fifth",
          "package": "hmt",
          "partial": "Fifth",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Interval.html#v:Fifth"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Interval",
          "name": "Fourth",
          "package": "hmt",
          "signature": "Fourth",
          "source": "src/Music-Theory-Interval.html#Interval_T",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Interval",
          "module": "Music.Theory.Interval",
          "name": "Fourth",
          "package": "hmt",
          "partial": "Fourth",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Interval.html#v:Fourth"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Interval",
          "name": "Interval",
          "package": "hmt",
          "signature": "Interval",
          "source": "src/Music-Theory-Interval.html#Interval",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Interval",
          "module": "Music.Theory.Interval",
          "name": "Interval",
          "package": "hmt",
          "partial": "Interval",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Interval.html#v:Interval"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Interval",
          "name": "Major",
          "package": "hmt",
          "signature": "Major",
          "source": "src/Music-Theory-Interval.html#Interval_Q",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Interval",
          "module": "Music.Theory.Interval",
          "name": "Major",
          "package": "hmt",
          "partial": "Major",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Interval.html#v:Major"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Interval",
          "name": "Minor",
          "package": "hmt",
          "signature": "Minor",
          "source": "src/Music-Theory-Interval.html#Interval_Q",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Interval",
          "module": "Music.Theory.Interval",
          "name": "Minor",
          "package": "hmt",
          "partial": "Minor",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Interval.html#v:Minor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Interval",
          "name": "Perfect",
          "package": "hmt",
          "signature": "Perfect",
          "source": "src/Music-Theory-Interval.html#Interval_Q",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Interval",
          "module": "Music.Theory.Interval",
          "name": "Perfect",
          "package": "hmt",
          "partial": "Perfect",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Interval.html#v:Perfect"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Interval",
          "name": "Second",
          "package": "hmt",
          "signature": "Second",
          "source": "src/Music-Theory-Interval.html#Interval_T",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Interval",
          "module": "Music.Theory.Interval",
          "name": "Second",
          "package": "hmt",
          "partial": "Second",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Interval.html#v:Second"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Interval",
          "name": "Seventh",
          "package": "hmt",
          "signature": "Seventh",
          "source": "src/Music-Theory-Interval.html#Interval_T",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Interval",
          "module": "Music.Theory.Interval",
          "name": "Seventh",
          "package": "hmt",
          "partial": "Seventh",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Interval.html#v:Seventh"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Interval",
          "name": "Sixth",
          "package": "hmt",
          "signature": "Sixth",
          "source": "src/Music-Theory-Interval.html#Interval_T",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Interval",
          "module": "Music.Theory.Interval",
          "name": "Sixth",
          "package": "hmt",
          "partial": "Sixth",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Interval.html#v:Sixth"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Interval",
          "name": "Third",
          "package": "hmt",
          "signature": "Third",
          "source": "src/Music-Theory-Interval.html#Interval_T",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Interval",
          "module": "Music.Theory.Interval",
          "name": "Third",
          "package": "hmt",
          "partial": "Third",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Interval.html#v:Third"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Interval",
          "name": "Unison",
          "package": "hmt",
          "signature": "Unison",
          "source": "src/Music-Theory-Interval.html#Interval_T",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Interval",
          "module": "Music.Theory.Interval",
          "name": "Unison",
          "package": "hmt",
          "partial": "Unison",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Interval.html#v:Unison"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMake leftwards (perfect fourth) and and rightwards (perfect\n fifth) circles from \u003ccode\u003e\u003ca\u003ePitch\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e let c = circle_of_fifths (Pitch F Sharp 4)\n in map pitch_to_pc (snd c) == [6,1,8,3,10,5,12,7,2,9,4,11]\n\u003c/pre\u003e",
          "module": "Music.Theory.Interval",
          "name": "circle_of_fifths",
          "package": "hmt",
          "signature": "Pitch -\u003e ([Pitch], [Pitch])",
          "source": "src/Music-Theory-Interval.html#circle_of_fifths",
          "type": "function"
        },
        "index": {
          "description": "Make leftwards perfect fourth and and rightwards perfect fifth circles from Pitch let circle of fifths Pitch Sharp in map pitch to pc snd",
          "hierarchy": "Music Theory Interval",
          "module": "Music.Theory.Interval",
          "name": "circle_of_fifths",
          "normalized": "Pitch-\u003e([Pitch],[Pitch])",
          "package": "hmt",
          "signature": "Pitch-\u003e([Pitch],[Pitch])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Interval.html#v:circle_of_fifths"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDetermine \u003ccode\u003e\u003ca\u003eInterval\u003c/a\u003e\u003c/code\u003e between two \u003ccode\u003e\u003ca\u003ePitch\u003c/a\u003e\u003c/code\u003ees.\n\u003c/p\u003e\u003cpre\u003e interval (Pitch C Sharp 4) (Pitch D Flat 4) == Interval Second Diminished EQ 0\n interval (Pitch C Sharp 4) (Pitch E Sharp 5) == Interval Third Major LT 1\n\u003c/pre\u003e",
          "module": "Music.Theory.Interval",
          "name": "interval",
          "package": "hmt",
          "signature": "Pitch -\u003e Pitch -\u003e Interval",
          "source": "src/Music-Theory-Interval.html#interval",
          "type": "function"
        },
        "index": {
          "description": "Determine Interval between two Pitch es interval Pitch Sharp Pitch Flat Interval Second Diminished EQ interval Pitch Sharp Pitch Sharp Interval Third Major LT",
          "hierarchy": "Music Theory Interval",
          "module": "Music.Theory.Interval",
          "name": "interval",
          "normalized": "Pitch-\u003ePitch-\u003eInterval",
          "package": "hmt",
          "signature": "Pitch-\u003ePitch-\u003eInterval",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Interval.html#v:interval"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Interval",
          "name": "interval_direction",
          "package": "hmt",
          "signature": "Ordering",
          "source": "src/Music-Theory-Interval.html#Interval",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Interval",
          "module": "Music.Theory.Interval",
          "name": "interval_direction",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Interval.html#v:interval_direction"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Interval",
          "name": "interval_octave",
          "package": "hmt",
          "signature": "Octave",
          "source": "src/Music-Theory-Interval.html#Interval",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Interval",
          "module": "Music.Theory.Interval",
          "name": "interval_octave",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Interval.html#v:interval_octave"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLookup \u003ccode\u003e\u003ca\u003eInterval_Q\u003c/a\u003e\u003c/code\u003e for given \u003ccode\u003e\u003ca\u003eInterval_T\u003c/a\u003e\u003c/code\u003e and semitone count.\n\u003c/p\u003e\u003cpre\u003e interval_q Unison 11 == Just Diminished\n interval_q Third 5 == Just Augmented\n interval_q Fourth 5 == Just Perfect\n interval_q Unison 3 == Nothing\n\u003c/pre\u003e",
          "module": "Music.Theory.Interval",
          "name": "interval_q",
          "package": "hmt",
          "signature": "Interval_T -\u003e Int -\u003e Maybe Interval_Q",
          "source": "src/Music-Theory-Interval.html#interval_q",
          "type": "function"
        },
        "index": {
          "description": "Lookup Interval for given Interval and semitone count interval Unison Just Diminished interval Third Just Augmented interval Fourth Just Perfect interval Unison Nothing",
          "hierarchy": "Music Theory Interval",
          "module": "Music.Theory.Interval",
          "name": "interval_q",
          "normalized": "Interval_T-\u003eInt-\u003eMaybe Interval_Q",
          "package": "hmt",
          "signature": "Interval_T-\u003eInt-\u003eMaybe Interval_Q",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Interval.html#v:interval_q"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLookup semitone difference of \u003ccode\u003e\u003ca\u003eInterval_T\u003c/a\u003e\u003c/code\u003e with \u003ccode\u003e\u003ca\u003eInterval_Q\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e interval_q_reverse Third Minor == Just 3\n interval_q_reverse Unison Diminished == Just 11\n\u003c/pre\u003e",
          "module": "Music.Theory.Interval",
          "name": "interval_q_reverse",
          "package": "hmt",
          "signature": "Interval_T -\u003e Interval_Q -\u003e Maybe Integer",
          "source": "src/Music-Theory-Interval.html#interval_q_reverse",
          "type": "function"
        },
        "index": {
          "description": "Lookup semitone difference of Interval with Interval interval reverse Third Minor Just interval reverse Unison Diminished Just",
          "hierarchy": "Music Theory Interval",
          "module": "Music.Theory.Interval",
          "name": "interval_q_reverse",
          "normalized": "Interval_T-\u003eInterval_Q-\u003eMaybe Integer",
          "package": "hmt",
          "signature": "Interval_T-\u003eInterval_Q-\u003eMaybe Integer",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Interval.html#v:interval_q_reverse"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTable of interval qualities.  For each \u003ccode\u003e\u003ca\u003eInterval_T\u003c/a\u003e\u003c/code\u003e gives\n directed semitone interval counts for each allowable \u003ccode\u003e\u003ca\u003eInterval_Q\u003c/a\u003e\u003c/code\u003e.\n For lookup function see \u003ccode\u003e\u003ca\u003einterval_q\u003c/a\u003e\u003c/code\u003e, for reverse lookup see\n \u003ccode\u003e\u003ca\u003einterval_q_reverse\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Music.Theory.Interval",
          "name": "interval_q_tbl",
          "package": "hmt",
          "signature": "[(Interval_T, [(n, Interval_Q)])]",
          "source": "src/Music-Theory-Interval.html#interval_q_tbl",
          "type": "function"
        },
        "index": {
          "description": "Table of interval qualities For each Interval gives directed semitone interval counts for each allowable Interval For lookup function see interval for reverse lookup see interval reverse",
          "hierarchy": "Music Theory Interval",
          "module": "Music.Theory.Interval",
          "name": "interval_q_tbl",
          "normalized": "[(Interval_T,[(a,Interval_Q)])]",
          "package": "hmt",
          "signature": "[(Interval_T,[(n,Interval_Q)])]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Interval.html#v:interval_q_tbl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Interval",
          "name": "interval_quality",
          "package": "hmt",
          "signature": "Interval_Q",
          "source": "src/Music-Theory-Interval.html#Interval",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Interval",
          "module": "Music.Theory.Interval",
          "name": "interval_quality",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Interval.html#v:interval_quality"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSemitone difference of \u003ccode\u003e\u003ca\u003eInterval\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e interval_semitones (interval (Pitch C Sharp 4) (Pitch E Sharp 5)) == 16\n interval_semitones (interval (Pitch C Natural 4) (Pitch D Sharp 3)) == -9\n\u003c/pre\u003e",
          "module": "Music.Theory.Interval",
          "name": "interval_semitones",
          "package": "hmt",
          "signature": "Interval -\u003e Integer",
          "source": "src/Music-Theory-Interval.html#interval_semitones",
          "type": "function"
        },
        "index": {
          "description": "Semitone difference of Interval interval semitones interval Pitch Sharp Pitch Sharp interval semitones interval Pitch Natural Pitch Sharp",
          "hierarchy": "Music Theory Interval",
          "module": "Music.Theory.Interval",
          "name": "interval_semitones",
          "normalized": "Interval-\u003eInteger",
          "package": "hmt",
          "signature": "Interval-\u003eInteger",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Interval.html#v:interval_semitones"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInterval type between \u003ccode\u003e\u003ca\u003eNote_T\u003c/a\u003e\u003c/code\u003e values.\n\u003c/p\u003e\u003cpre\u003e map (interval_ty C) [E,B] == [Third,Seventh]\n\u003c/pre\u003e",
          "module": "Music.Theory.Interval",
          "name": "interval_ty",
          "package": "hmt",
          "signature": "Note_T -\u003e Note_T -\u003e Interval_T",
          "source": "src/Music-Theory-Interval.html#interval_ty",
          "type": "function"
        },
        "index": {
          "description": "Interval type between Note values map interval ty Third Seventh",
          "hierarchy": "Music Theory Interval",
          "module": "Music.Theory.Interval",
          "name": "interval_ty",
          "normalized": "Note_T-\u003eNote_T-\u003eInterval_T",
          "package": "hmt",
          "signature": "Note_T-\u003eNote_T-\u003eInterval_T",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Interval.html#v:interval_ty"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Interval",
          "name": "interval_type",
          "package": "hmt",
          "signature": "Interval_T",
          "source": "src/Music-Theory-Interval.html#Interval",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Interval",
          "module": "Music.Theory.Interval",
          "name": "interval_type",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Interval.html#v:interval_type"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eApply \u003ccode\u003e\u003ca\u003einvert_ordering\u003c/a\u003e\u003c/code\u003e to \u003ccode\u003e\u003ca\u003einterval_direction\u003c/a\u003e\u003c/code\u003e of \u003ccode\u003e\u003ca\u003eInterval\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e invert_interval (Interval Third Major LT 1) == Interval Third Major GT 1\n\u003c/pre\u003e",
          "module": "Music.Theory.Interval",
          "name": "invert_interval",
          "package": "hmt",
          "signature": "Interval -\u003e Interval",
          "source": "src/Music-Theory-Interval.html#invert_interval",
          "type": "function"
        },
        "index": {
          "description": "Apply invert ordering to interval direction of Interval invert interval Interval Third Major LT Interval Third Major GT",
          "hierarchy": "Music Theory Interval",
          "module": "Music.Theory.Interval",
          "name": "invert_interval",
          "normalized": "Interval-\u003eInterval",
          "package": "hmt",
          "signature": "Interval-\u003eInterval",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Interval.html#v:invert_interval"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInvert \u003ccode\u003e\u003ca\u003eOrdering\u003c/a\u003e\u003c/code\u003e, ie. \u003ccode\u003e\u003ca\u003eGT\u003c/a\u003e\u003c/code\u003e becomes \u003ccode\u003e\u003ca\u003eLT\u003c/a\u003e\u003c/code\u003e and vice versa.\n\u003c/p\u003e\u003cpre\u003e map invert_ordering [LT,EQ,GT] == [GT,EQ,LT]\n\u003c/pre\u003e",
          "module": "Music.Theory.Interval",
          "name": "invert_ordering",
          "package": "hmt",
          "signature": "Ordering -\u003e Ordering",
          "source": "src/Music-Theory-Interval.html#invert_ordering",
          "type": "function"
        },
        "index": {
          "description": "Invert Ordering ie GT becomes LT and vice versa map invert ordering LT EQ GT GT EQ LT",
          "hierarchy": "Music Theory Interval",
          "module": "Music.Theory.Interval",
          "name": "invert_ordering",
          "normalized": "Ordering-\u003eOrdering",
          "package": "hmt",
          "signature": "Ordering-\u003eOrdering",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Interval.html#v:invert_ordering"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInclusive set of \u003ccode\u003e\u003ca\u003eNote_T\u003c/a\u003e\u003c/code\u003e within indicated interval.  This is not\n equal to \u003ccode\u003e\u003ca\u003eenumFromTo\u003c/a\u003e\u003c/code\u003e which is not circular.\n\u003c/p\u003e\u003cpre\u003e note_span E B == [E,F,G,A,B]\n note_span B D == [B,C,D]\n enumFromTo B D == []\n\u003c/pre\u003e",
          "module": "Music.Theory.Interval",
          "name": "note_span",
          "package": "hmt",
          "signature": "Note_T -\u003e Note_T -\u003e [Note_T]",
          "source": "src/Music-Theory-Interval.html#note_span",
          "type": "function"
        },
        "index": {
          "description": "Inclusive set of Note within indicated interval This is not equal to enumFromTo which is not circular note span note span enumFromTo",
          "hierarchy": "Music Theory Interval",
          "module": "Music.Theory.Interval",
          "name": "note_span",
          "normalized": "Note_T-\u003eNote_T-\u003e[Note_T]",
          "package": "hmt",
          "signature": "Note_T-\u003eNote_T-\u003e[Note_T]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Interval.html#v:note_span"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eErroring variant of \u003ccode\u003e\u003ca\u003equality_difference_m\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Music.Theory.Interval",
          "name": "quality_difference",
          "package": "hmt",
          "signature": "Interval_Q -\u003e Interval_Q -\u003e Int",
          "source": "src/Music-Theory-Interval.html#quality_difference",
          "type": "function"
        },
        "index": {
          "description": "Erroring variant of quality difference",
          "hierarchy": "Music Theory Interval",
          "module": "Music.Theory.Interval",
          "name": "quality_difference",
          "normalized": "Interval_Q-\u003eInterval_Q-\u003eInt",
          "package": "hmt",
          "signature": "Interval_Q-\u003eInterval_Q-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Interval.html#v:quality_difference"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe signed difference in semitones between two \u003ccode\u003e\u003ca\u003eInterval_Q\u003c/a\u003e\u003c/code\u003e\n values when applied to the same \u003ccode\u003e\u003ca\u003eInterval_T\u003c/a\u003e\u003c/code\u003e.  Can this be written\n correctly without knowing the Interval_T?\n\u003c/p\u003e\u003cpre\u003e quality_difference_m Minor Augmented == Just 2\n quality_difference_m Augmented Diminished == Just (-3)\n quality_difference_m Major Perfect == Nothing\n\u003c/pre\u003e",
          "module": "Music.Theory.Interval",
          "name": "quality_difference_m",
          "package": "hmt",
          "signature": "Interval_Q -\u003e Interval_Q -\u003e Maybe Int",
          "source": "src/Music-Theory-Interval.html#quality_difference_m",
          "type": "function"
        },
        "index": {
          "description": "The signed difference in semitones between two Interval values when applied to the same Interval Can this be written correctly without knowing the Interval quality difference Minor Augmented Just quality difference Augmented Diminished Just quality difference Major Perfect Nothing",
          "hierarchy": "Music Theory Interval",
          "module": "Music.Theory.Interval",
          "name": "quality_difference_m",
          "normalized": "Interval_Q-\u003eInterval_Q-\u003eMaybe Int",
          "package": "hmt",
          "signature": "Interval_Q-\u003eInterval_Q-\u003eMaybe Int",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Interval.html#v:quality_difference_m"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTranspose a \u003ccode\u003e\u003ca\u003ePitch\u003c/a\u003e\u003c/code\u003e by an \u003ccode\u003e\u003ca\u003eInterval\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e transpose (Interval Third Diminished LT 0) (Pitch C Sharp 4) == Pitch E Flat 4\n\u003c/pre\u003e",
          "module": "Music.Theory.Interval",
          "name": "transpose",
          "package": "hmt",
          "signature": "Interval -\u003e Pitch -\u003e Pitch",
          "source": "src/Music-Theory-Interval.html#transpose",
          "type": "function"
        },
        "index": {
          "description": "Transpose Pitch by an Interval transpose Interval Third Diminished LT Pitch Sharp Pitch Flat",
          "hierarchy": "Music Theory Interval",
          "module": "Music.Theory.Interval",
          "name": "transpose",
          "normalized": "Interval-\u003ePitch-\u003ePitch",
          "package": "hmt",
          "signature": "Interval-\u003ePitch-\u003ePitch",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Interval.html#v:transpose"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eCommon music keys.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Music.Theory.Key",
          "name": "Key",
          "package": "hmt",
          "source": "src/Music-Theory-Key.html",
          "type": "module"
        },
        "index": {
          "description": "Common music keys",
          "hierarchy": "Music Theory Key",
          "module": "Music.Theory.Key",
          "name": "Key",
          "package": "hmt",
          "partial": "Key",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Key.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA common music notation key is a \u003ccode\u003e\u003ca\u003eNote_T\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eAlteration_T\u003c/a\u003e\u003c/code\u003e,\n \u003ccode\u003e\u003ca\u003eMode_T\u003c/a\u003e\u003c/code\u003e triple.\n\u003c/p\u003e",
          "module": "Music.Theory.Key",
          "name": "Key",
          "package": "hmt",
          "source": "src/Music-Theory-Key.html#Key",
          "type": "type"
        },
        "index": {
          "description": "common music notation key is Note Alteration Mode triple",
          "hierarchy": "Music Theory Key",
          "module": "Music.Theory.Key",
          "name": "Key",
          "package": "hmt",
          "partial": "Key",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Key.html#t:Key"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEnumeration of common music notation modes.\n\u003c/p\u003e",
          "module": "Music.Theory.Key",
          "name": "Mode_T",
          "package": "hmt",
          "source": "src/Music-Theory-Key.html#Mode_T",
          "type": "data"
        },
        "index": {
          "description": "Enumeration of common music notation modes",
          "hierarchy": "Music Theory Key",
          "module": "Music.Theory.Key",
          "name": "Mode_T",
          "package": "hmt",
          "partial": "Mode",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Key.html#t:Mode_T"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Key",
          "name": "Major_Mode",
          "package": "hmt",
          "signature": "Major_Mode",
          "source": "src/Music-Theory-Key.html#Mode_T",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Key",
          "module": "Music.Theory.Key",
          "name": "Major_Mode",
          "package": "hmt",
          "partial": "Major Mode",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Key.html#v:Major_Mode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Key",
          "name": "Minor_Mode",
          "package": "hmt",
          "signature": "Minor_Mode",
          "source": "src/Music-Theory-Key.html#Mode_T",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Key",
          "module": "Music.Theory.Key",
          "name": "Minor_Mode",
          "package": "hmt",
          "partial": "Minor Mode",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Key.html#v:Minor_Mode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDistance along circle of fifths path of indicated \u003ccode\u003e\u003ca\u003eKey\u003c/a\u003e\u003c/code\u003e.  A\n positive number indicates the number of sharps, a negative number\n the number of flats.\n\u003c/p\u003e\u003cpre\u003e key_fifths (A,Natural,Minor_Mode) == 0\n key_fifths (A,Natural,Major_Mode) == 3\n key_fifths (C,Natural,Minor_Mode) == -3\n\u003c/pre\u003e",
          "module": "Music.Theory.Key",
          "name": "key_fifths",
          "package": "hmt",
          "signature": "Key -\u003e Int",
          "source": "src/Music-Theory-Key.html#key_fifths",
          "type": "function"
        },
        "index": {
          "description": "Distance along circle of fifths path of indicated Key positive number indicates the number of sharps negative number the number of flats key fifths Natural Minor Mode key fifths Natural Major Mode key fifths Natural Minor Mode",
          "hierarchy": "Music Theory Key",
          "module": "Music.Theory.Key",
          "name": "key_fifths",
          "normalized": "Key-\u003eInt",
          "package": "hmt",
          "signature": "Key-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Key.html#v:key_fifths"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eShared list functions.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Music.Theory.List",
          "name": "List",
          "package": "hmt",
          "source": "src/Music-Theory-List.html",
          "type": "module"
        },
        "index": {
          "description": "Shared list functions",
          "hierarchy": "Music Theory List",
          "module": "Music.Theory.List",
          "name": "List",
          "package": "hmt",
          "partial": "List",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-List.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAdjacent elements of list, at indicated distance, as pairs.\n\u003c/p\u003e\u003cpre\u003e adj2 1 [1..5] == [(1,2),(2,3),(3,4),(4,5)]\n adj2 2 [1..4] == [(1,2),(3,4)]\n adj2 3 [1..5] == [(1,2),(4,5)]\n\u003c/pre\u003e",
          "module": "Music.Theory.List",
          "name": "adj2",
          "package": "hmt",
          "signature": "Int -\u003e [t] -\u003e [(t, t)]",
          "source": "src/Music-Theory-List.html#adj2",
          "type": "function"
        },
        "index": {
          "description": "Adjacent elements of list at indicated distance as pairs adj2 adj2 adj2",
          "hierarchy": "Music Theory List",
          "module": "Music.Theory.List",
          "name": "adj2",
          "normalized": "Int-\u003e[a]-\u003e[(a,a)]",
          "package": "hmt",
          "signature": "Int-\u003e[t]-\u003e[(t,t)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-List.html#v:adj2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eadj2\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eclose\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e adj2_cyclic 1 [1..3] == [(1,2),(2,3),(3,1)]\n\u003c/pre\u003e",
          "module": "Music.Theory.List",
          "name": "adj2_cyclic",
          "package": "hmt",
          "signature": "Int -\u003e [t] -\u003e [(t, t)]",
          "source": "src/Music-Theory-List.html#adj2_cyclic",
          "type": "function"
        },
        "index": {
          "description": "adj2 close adj2 cyclic",
          "hierarchy": "Music Theory List",
          "module": "Music.Theory.List",
          "name": "adj2_cyclic",
          "normalized": "Int-\u003e[a]-\u003e[(a,a)]",
          "package": "hmt",
          "signature": "Int-\u003e[t]-\u003e[(t,t)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-List.html#v:adj2_cyclic"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIntersection of adjacent elements of list at distance \u003cem\u003en\u003c/em\u003e.\n\u003c/p\u003e\u003cpre\u003e adj_intersect 1 [[1,2],[1,2,3],[1,2,3,4]] == [[1,2],[1,2,3]]\n\u003c/pre\u003e",
          "module": "Music.Theory.List",
          "name": "adj_intersect",
          "package": "hmt",
          "signature": "Int -\u003e [[a]] -\u003e [[a]]",
          "source": "src/Music-Theory-List.html#adj_intersect",
          "type": "function"
        },
        "index": {
          "description": "Intersection of adjacent elements of list at distance adj intersect",
          "hierarchy": "Music Theory List",
          "module": "Music.Theory.List",
          "name": "adj_intersect",
          "normalized": "Int-\u003e[[a]]-\u003e[[a]]",
          "package": "hmt",
          "signature": "Int-\u003e[[a]]-\u003e[[a]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-List.html#v:adj_intersect"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.List",
          "name": "adjacent_groupBy",
          "package": "hmt",
          "signature": "(a -\u003e a -\u003e Bool) -\u003e [a] -\u003e [[a]]",
          "source": "src/Music-Theory-List.html#adjacent_groupBy",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory List",
          "module": "Music.Theory.List",
          "name": "adjacent_groupBy",
          "normalized": "(a-\u003ea-\u003eBool)-\u003e[a]-\u003e[[a]]",
          "package": "hmt",
          "partial": "By",
          "signature": "(a-\u003ea-\u003eBool)-\u003e[a]-\u003e[[a]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-List.html#v:adjacent_groupBy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eApply \u003cem\u003ef\u003c/em\u003e at first element, and \u003cem\u003eg\u003c/em\u003e at all other elements.\n\u003c/p\u003e\u003cpre\u003e at_head negate id [1..5] == [-1,2,3,4,5]\n\u003c/pre\u003e",
          "module": "Music.Theory.List",
          "name": "at_head",
          "package": "hmt",
          "signature": "(a -\u003e b) -\u003e (a -\u003e b) -\u003e [a] -\u003e [b]",
          "source": "src/Music-Theory-List.html#at_head",
          "type": "function"
        },
        "index": {
          "description": "Apply at first element and at all other elements at head negate id",
          "hierarchy": "Music Theory List",
          "module": "Music.Theory.List",
          "name": "at_head",
          "normalized": "(a-\u003eb)-\u003e(a-\u003eb)-\u003e[a]-\u003e[b]",
          "package": "hmt",
          "signature": "(a-\u003eb)-\u003e(a-\u003eb)-\u003e[a]-\u003e[b]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-List.html#v:at_head"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eApply \u003cem\u003ef\u003c/em\u003e at all but last element, and \u003cem\u003eg\u003c/em\u003e at last element.\n\u003c/p\u003e\u003cpre\u003e at_last (* 2) negate [1..4] == [2,4,6,-4]\n\u003c/pre\u003e",
          "module": "Music.Theory.List",
          "name": "at_last",
          "package": "hmt",
          "signature": "(a -\u003e b) -\u003e (a -\u003e b) -\u003e [a] -\u003e [b]",
          "source": "src/Music-Theory-List.html#at_last",
          "type": "function"
        },
        "index": {
          "description": "Apply at all but last element and at last element at last negate",
          "hierarchy": "Music Theory List",
          "module": "Music.Theory.List",
          "name": "at_last",
          "normalized": "(a-\u003eb)-\u003e(a-\u003eb)-\u003e[a]-\u003e[b]",
          "package": "hmt",
          "signature": "(a-\u003eb)-\u003e(a-\u003eb)-\u003e[a]-\u003e[b]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-List.html#v:at_last"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eBracket sequence with left and right values.\n\u003c/p\u003e\u003cpre\u003e bracket ('\u003c','\u003e') \"1,2,3\" == \"\u003c1,2,3\u003e\"\n\u003c/pre\u003e",
          "module": "Music.Theory.List",
          "name": "bracket",
          "package": "hmt",
          "signature": "(a, a) -\u003e [a] -\u003e [a]",
          "source": "src/Music-Theory-List.html#bracket",
          "type": "function"
        },
        "index": {
          "description": "Bracket sequence with left and right values bracket",
          "hierarchy": "Music Theory List",
          "module": "Music.Theory.List",
          "name": "bracket",
          "normalized": "(a,a)-\u003e[a]-\u003e[a]",
          "package": "hmt",
          "signature": "(a,a)-\u003e[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-List.html#v:bracket"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAppend first element to end of list.\n\u003c/p\u003e\u003cpre\u003e close [1..3] == [1,2,3,1]\n\u003c/pre\u003e",
          "module": "Music.Theory.List",
          "name": "close",
          "package": "hmt",
          "signature": "[a] -\u003e [a]",
          "source": "src/Music-Theory-List.html#close",
          "type": "function"
        },
        "index": {
          "description": "Append first element to end of list close",
          "hierarchy": "Music Theory List",
          "module": "Music.Theory.List",
          "name": "close",
          "normalized": "[a]-\u003e[a]",
          "package": "hmt",
          "signature": "[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-List.html#v:close"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCollate values of equal keys at \u003cem\u003eassoc\u003c/em\u003e list.\n\u003c/p\u003e\u003cpre\u003e collate [(1,'a'),(2,'b'),(1,'c')] == [(1,\"ac\"),(2,\"b\")]\n\u003c/pre\u003e",
          "module": "Music.Theory.List",
          "name": "collate",
          "package": "hmt",
          "signature": "[(a, b)] -\u003e [(a, [b])]",
          "source": "src/Music-Theory-List.html#collate",
          "type": "function"
        },
        "index": {
          "description": "Collate values of equal keys at assoc list collate ac",
          "hierarchy": "Music Theory List",
          "module": "Music.Theory.List",
          "name": "collate",
          "normalized": "[(a,b)]-\u003e[(a,[b])]",
          "package": "hmt",
          "signature": "[(a,b)]-\u003e[(a,[b])]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-List.html#v:collate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eList of cycles at distance \u003cem\u003en\u003c/em\u003e.\n\u003c/p\u003e\u003cpre\u003e cycles 2 [1..6] == [[1,3,5],[2,4,6]]\n cycles 3 [1..9] == [[1,4,7],[2,5,8],[3,6,9]]\n cycles 4 [1..8] == [[1,5],[2,6],[3,7],[4,8]]\n\u003c/pre\u003e",
          "module": "Music.Theory.List",
          "name": "cycles",
          "package": "hmt",
          "signature": "Int -\u003e [a] -\u003e [[a]]",
          "source": "src/Music-Theory-List.html#cycles",
          "type": "function"
        },
        "index": {
          "description": "List of cycles at distance cycles cycles cycles",
          "hierarchy": "Music Theory List",
          "module": "Music.Theory.List",
          "name": "cycles",
          "normalized": "Int-\u003e[a]-\u003e[[a]]",
          "package": "hmt",
          "signature": "Int-\u003e[a]-\u003e[[a]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-List.html#v:cycles"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIntegrate, ie. pitch class segment to interval sequence.\n\u003c/p\u003e\u003cpre\u003e d_dx [5,6,8,11] == [1,2,3]\n\u003c/pre\u003e",
          "module": "Music.Theory.List",
          "name": "d_dx",
          "package": "hmt",
          "signature": "[a] -\u003e [a]",
          "source": "src/Music-Theory-List.html#d_dx",
          "type": "function"
        },
        "index": {
          "description": "Integrate ie pitch class segment to interval sequence dx",
          "hierarchy": "Music Theory List",
          "module": "Music.Theory.List",
          "name": "d_dx",
          "normalized": "[a]-\u003e[a]",
          "package": "hmt",
          "signature": "[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-List.html#v:d_dx"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eElements of \u003cem\u003ep\u003c/em\u003e not in \u003cem\u003eq\u003c/em\u003e.\n\u003c/p\u003e\u003cpre\u003e [1,2,3] `difference` [1,2] == [3]\n\u003c/pre\u003e",
          "module": "Music.Theory.List",
          "name": "difference",
          "package": "hmt",
          "signature": "[a] -\u003e [a] -\u003e [a]",
          "source": "src/Music-Theory-List.html#difference",
          "type": "function"
        },
        "index": {
          "description": "Elements of not in difference",
          "hierarchy": "Music Theory List",
          "module": "Music.Theory.List",
          "name": "difference",
          "normalized": "[a]-\u003e[a]-\u003e[a]",
          "package": "hmt",
          "signature": "[a]-\u003e[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-List.html#v:difference"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eVariant of \u003ccode\u003e\u003ca\u003edrop\u003c/a\u003e\u003c/code\u003e from right of list.\n\u003c/p\u003e\u003cpre\u003e dropRight 1 [1..9] == [1..8]\n\u003c/pre\u003e",
          "module": "Music.Theory.List",
          "name": "dropRight",
          "package": "hmt",
          "signature": "Int -\u003e [a] -\u003e [a]",
          "source": "src/Music-Theory-List.html#dropRight",
          "type": "function"
        },
        "index": {
          "description": "Variant of drop from right of list dropRight",
          "hierarchy": "Music Theory List",
          "module": "Music.Theory.List",
          "name": "dropRight",
          "normalized": "Int-\u003e[a]-\u003e[a]",
          "package": "hmt",
          "partial": "Right",
          "signature": "Int-\u003e[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-List.html#v:dropRight"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIntervals to values, zero is \u003cem\u003en\u003c/em\u003e.\n\u003c/p\u003e\u003cpre\u003e dx_d 5 [1,2,3] == [5,6,8,11]\n\u003c/pre\u003e",
          "module": "Music.Theory.List",
          "name": "dx_d",
          "package": "hmt",
          "signature": "a -\u003e [a] -\u003e [a]",
          "source": "src/Music-Theory-List.html#dx_d",
          "type": "function"
        },
        "index": {
          "description": "Intervals to values zero is dx",
          "hierarchy": "Music Theory List",
          "module": "Music.Theory.List",
          "name": "dx_d",
          "normalized": "a-\u003e[a]-\u003e[a]",
          "package": "hmt",
          "signature": "a-\u003e[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-List.html#v:dx_d"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eVariant of \u003ccode\u003e\u003ca\u003eelemIndices\u003c/a\u003e\u003c/code\u003e that requires \u003cem\u003ee\u003c/em\u003e to be unique in \u003cem\u003ep\u003c/em\u003e.\n\u003c/p\u003e\u003cpre\u003e elem_index_unique 'a' \"abcda\" == undefined\n\u003c/pre\u003e",
          "module": "Music.Theory.List",
          "name": "elem_index_unique",
          "package": "hmt",
          "signature": "a -\u003e [a] -\u003e Int",
          "source": "src/Music-Theory-List.html#elem_index_unique",
          "type": "function"
        },
        "index": {
          "description": "Variant of elemIndices that requires to be unique in elem index unique abcda undefined",
          "hierarchy": "Music Theory List",
          "module": "Music.Theory.List",
          "name": "elem_index_unique",
          "normalized": "a-\u003e[a]-\u003eInt",
          "package": "hmt",
          "signature": "a-\u003e[a]-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-List.html#v:elem_index_unique"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFind adjacent elements of list that bound element under given\n comparator.\n\u003c/p\u003e\u003cpre\u003e let f = find_bounds compare (adj [1..5])\n in map f [1,3.5,5] == [Just (1,2),Just (3,4),Nothing]\n\u003c/pre\u003e",
          "module": "Music.Theory.List",
          "name": "find_bounds",
          "package": "hmt",
          "signature": "(t -\u003e s -\u003e Ordering) -\u003e [(t, t)] -\u003e s -\u003e Maybe (t, t)",
          "source": "src/Music-Theory-List.html#find_bounds",
          "type": "function"
        },
        "index": {
          "description": "Find adjacent elements of list that bound element under given comparator let find bounds compare adj in map Just Just Nothing",
          "hierarchy": "Music Theory List",
          "module": "Music.Theory.List",
          "name": "find_bounds",
          "normalized": "(a-\u003eb-\u003eOrdering)-\u003e[(a,a)]-\u003eb-\u003eMaybe(a,a)",
          "package": "hmt",
          "signature": "(t-\u003es-\u003eOrdering)-\u003e[(t,t)]-\u003es-\u003eMaybe(t,t)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-List.html#v:find_bounds"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.List",
          "name": "genericAdj2",
          "package": "hmt",
          "signature": "n -\u003e [t] -\u003e [(t, t)]",
          "source": "src/Music-Theory-List.html#genericAdj2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory List",
          "module": "Music.Theory.List",
          "name": "genericAdj2",
          "normalized": "a-\u003e[b]-\u003e[(b,b)]",
          "package": "hmt",
          "partial": "Adj",
          "signature": "n-\u003e[t]-\u003e[(t,t)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-List.html#v:genericAdj2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.List",
          "name": "genericRotate_left",
          "package": "hmt",
          "signature": "i -\u003e [a] -\u003e [a]",
          "source": "src/Music-Theory-List.html#genericRotate_left",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory List",
          "module": "Music.Theory.List",
          "name": "genericRotate_left",
          "normalized": "a-\u003e[b]-\u003e[b]",
          "package": "hmt",
          "partial": "Rotate",
          "signature": "i-\u003e[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-List.html#v:genericRotate_left"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.List",
          "name": "genericRotate_right",
          "package": "hmt",
          "signature": "n -\u003e [a] -\u003e [a]",
          "source": "src/Music-Theory-List.html#genericRotate_right",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory List",
          "module": "Music.Theory.List",
          "name": "genericRotate_right",
          "normalized": "a-\u003e[b]-\u003e[b]",
          "package": "hmt",
          "partial": "Rotate",
          "signature": "n-\u003e[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-List.html#v:genericRotate_right"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.List",
          "name": "group_just",
          "package": "hmt",
          "signature": "[Maybe a] -\u003e [[Maybe a]]",
          "source": "src/Music-Theory-List.html#group_just",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory List",
          "module": "Music.Theory.List",
          "name": "group_just",
          "normalized": "[Maybe a]-\u003e[[Maybe a]]",
          "package": "hmt",
          "signature": "[Maybe a]-\u003e[[Maybe a]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-List.html#v:group_just"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCount occurences of elements in list.\n\u003c/p\u003e\u003cpre\u003e histogram \"hohoh\" == [('h',3),('o',2)]\n\u003c/pre\u003e",
          "module": "Music.Theory.List",
          "name": "histogram",
          "package": "hmt",
          "signature": "[a] -\u003e [(a, i)]",
          "source": "src/Music-Theory-List.html#histogram",
          "type": "function"
        },
        "index": {
          "description": "Count occurences of elements in list histogram hohoh",
          "hierarchy": "Music Theory List",
          "module": "Music.Theory.List",
          "name": "histogram",
          "normalized": "[a]-\u003e[(a,b)]",
          "package": "hmt",
          "signature": "[a]-\u003e[(a,i)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-List.html#v:histogram"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReplace directly repeated elements with \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e indicate_repetitions \"abba\" == [Just 'a',Just 'b',Nothing,Just 'a']\n\u003c/pre\u003e",
          "module": "Music.Theory.List",
          "name": "indicate_repetitions",
          "package": "hmt",
          "signature": "[a] -\u003e [Maybe a]",
          "source": "src/Music-Theory-List.html#indicate_repetitions",
          "type": "function"
        },
        "index": {
          "description": "Replace directly repeated elements with Nothing indicate repetitions abba Just Just Nothing Just",
          "hierarchy": "Music Theory List",
          "module": "Music.Theory.List",
          "name": "indicate_repetitions",
          "normalized": "[a]-\u003e[Maybe a]",
          "package": "hmt",
          "signature": "[a]-\u003e[Maybe a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-List.html#v:indicate_repetitions"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInterleave elements of \u003cem\u003ep\u003c/em\u003e and \u003cem\u003eq\u003c/em\u003e.\n\u003c/p\u003e\u003cpre\u003e interleave [1..3] [4..6] == [1,4,2,5,3,6]\n\u003c/pre\u003e",
          "module": "Music.Theory.List",
          "name": "interleave",
          "package": "hmt",
          "signature": "[b] -\u003e [b] -\u003e [b]",
          "source": "src/Music-Theory-List.html#interleave",
          "type": "function"
        },
        "index": {
          "description": "Interleave elements of and interleave",
          "hierarchy": "Music Theory List",
          "module": "Music.Theory.List",
          "name": "interleave",
          "normalized": "[a]-\u003e[a]-\u003e[a]",
          "package": "hmt",
          "signature": "[b]-\u003e[b]-\u003e[b]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-List.html#v:interleave"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003einterleave\u003c/a\u003e\u003c/code\u003e of \u003ccode\u003e\u003ca\u003erotate_left\u003c/a\u003e\u003c/code\u003e by \u003cem\u003ei\u003c/em\u003e and \u003cem\u003ej\u003c/em\u003e.\n\u003c/p\u003e\u003cpre\u003e interleave_rotations 9 3 [1..13] == [10,4,11,5,12,6,13,7,1,8,2,9,3,10,4,11,5,12,6,13,7,1,8,2,9,3]\n\u003c/pre\u003e",
          "module": "Music.Theory.List",
          "name": "interleave_rotations",
          "package": "hmt",
          "signature": "Int -\u003e Int -\u003e [b] -\u003e [b]",
          "source": "src/Music-Theory-List.html#interleave_rotations",
          "type": "function"
        },
        "index": {
          "description": "interleave of rotate left by and interleave rotations",
          "hierarchy": "Music Theory List",
          "module": "Music.Theory.List",
          "name": "interleave_rotations",
          "normalized": "Int-\u003eInt-\u003e[a]-\u003e[a]",
          "package": "hmt",
          "signature": "Int-\u003eInt-\u003e[b]-\u003e[b]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-List.html#v:interleave_rotations"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003efoldl1\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eintersect\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e intersect_l [[1,2],[1,2,3],[1,2,3,4]] == [1,2]\n\u003c/pre\u003e",
          "module": "Music.Theory.List",
          "name": "intersect_l",
          "package": "hmt",
          "signature": "[[a]] -\u003e [a]",
          "source": "src/Music-Theory-List.html#intersect_l",
          "type": "function"
        },
        "index": {
          "description": "foldl1 intersect intersect",
          "hierarchy": "Music Theory List",
          "module": "Music.Theory.List",
          "name": "intersect_l",
          "normalized": "[[a]]-\u003e[a]",
          "package": "hmt",
          "signature": "[[a]]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-List.html#v:intersect_l"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIs \u003cem\u003ep\u003c/em\u003e a subset of \u003cem\u003eq\u003c/em\u003e, ie. is \u003ccode\u003e\u003ca\u003eintersect\u003c/a\u003e\u003c/code\u003e of \u003cem\u003ep\u003c/em\u003e and \u003cem\u003eq\u003c/em\u003e \u003ccode\u003e\u003ca\u003e==\u003c/a\u003e\u003c/code\u003e \u003cem\u003ep\u003c/em\u003e.\n\u003c/p\u003e\u003cpre\u003e is_subset [1,2] [1,2,3] == True\n\u003c/pre\u003e",
          "module": "Music.Theory.List",
          "name": "is_subset",
          "package": "hmt",
          "signature": "[a] -\u003e [a] -\u003e Bool",
          "source": "src/Music-Theory-List.html#is_subset",
          "type": "function"
        },
        "index": {
          "description": "Is subset of ie is intersect of and is subset True",
          "hierarchy": "Music Theory List",
          "module": "Music.Theory.List",
          "name": "is_subset",
          "normalized": "[a]-\u003e[a]-\u003eBool",
          "package": "hmt",
          "signature": "[a]-\u003e[a]-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-List.html#v:is_subset"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIs \u003cem\u003ep\u003c/em\u003e a superset of \u003cem\u003eq\u003c/em\u003e, ie. \u003ccode\u003e\u003ca\u003eflip\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eis_subset\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e is_superset [1,2,3] [1,2] == True\n\u003c/pre\u003e",
          "module": "Music.Theory.List",
          "name": "is_superset",
          "package": "hmt",
          "signature": "[a] -\u003e [a] -\u003e Bool",
          "source": "src/Music-Theory-List.html#is_superset",
          "type": "function"
        },
        "index": {
          "description": "Is superset of ie flip is subset is superset True",
          "hierarchy": "Music Theory List",
          "module": "Music.Theory.List",
          "name": "is_superset",
          "normalized": "[a]-\u003e[a]-\u003eBool",
          "package": "hmt",
          "signature": "[a]-\u003e[a]-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-List.html#v:is_superset"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003emergeBy\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003ecompare\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Music.Theory.List",
          "name": "merge",
          "package": "hmt",
          "signature": "[a] -\u003e [a] -\u003e [a]",
          "source": "src/Music-Theory-List.html#merge",
          "type": "function"
        },
        "index": {
          "description": "mergeBy compare",
          "hierarchy": "Music Theory List",
          "module": "Music.Theory.List",
          "name": "merge",
          "normalized": "[a]-\u003e[a]-\u003e[a]",
          "package": "hmt",
          "signature": "[a]-\u003e[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-List.html#v:merge"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGiven a comparison function, merge two ascending lists.\n\u003c/p\u003e\u003cpre\u003e mergeBy compare [1,3,5] [2,4] == [1..5]\n\u003c/pre\u003e",
          "module": "Music.Theory.List",
          "name": "mergeBy",
          "package": "hmt",
          "signature": "(a -\u003e a -\u003e Ordering) -\u003e [a] -\u003e [a] -\u003e [a]",
          "source": "src/Music-Theory-List.html#mergeBy",
          "type": "function"
        },
        "index": {
          "description": "Given comparison function merge two ascending lists mergeBy compare",
          "hierarchy": "Music Theory List",
          "module": "Music.Theory.List",
          "name": "mergeBy",
          "normalized": "(a-\u003ea-\u003eOrdering)-\u003e[a]-\u003e[a]-\u003e[a]",
          "package": "hmt",
          "partial": "By",
          "signature": "(a-\u003ea-\u003eOrdering)-\u003e[a]-\u003e[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-List.html#v:mergeBy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003emerge\u003c/a\u003e\u003c/code\u003e a set of ordered sequences.\n\u003c/p\u003e\u003cpre\u003e merge_set [[1,3..9],[2,4..8],[10]] == [1..10]\n\u003c/pre\u003e",
          "module": "Music.Theory.List",
          "name": "merge_set",
          "package": "hmt",
          "signature": "[[a]] -\u003e [a]",
          "source": "src/Music-Theory-List.html#merge_set",
          "type": "function"
        },
        "index": {
          "description": "merge set of ordered sequences merge set",
          "hierarchy": "Music Theory List",
          "module": "Music.Theory.List",
          "name": "merge_set",
          "normalized": "[[a]]-\u003e[a]",
          "package": "hmt",
          "signature": "[[a]]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-List.html#v:merge_set"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRotate left by \u003cem\u003en\u003c/em\u003e \u003ccode\u003e\u003ca\u003emod\u003c/a\u003e\u003c/code\u003e \u003cem\u003e#p\u003c/em\u003e places.\n\u003c/p\u003e\u003cpre\u003e rotate 8 [1..5] == [4,5,1,2,3]\n\u003c/pre\u003e",
          "module": "Music.Theory.List",
          "name": "rotate",
          "package": "hmt",
          "signature": "n -\u003e [a] -\u003e [a]",
          "source": "src/Music-Theory-List.html#rotate",
          "type": "function"
        },
        "index": {
          "description": "Rotate left by mod places rotate",
          "hierarchy": "Music Theory List",
          "module": "Music.Theory.List",
          "name": "rotate",
          "normalized": "a-\u003e[b]-\u003e[b]",
          "package": "hmt",
          "signature": "n-\u003e[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-List.html#v:rotate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLeft rotation.\n\u003c/p\u003e\u003cpre\u003e rotate_left 1 [1..3] == [2,3,1]\n rotate_left 3 [1..5] == [4,5,1,2,3]\n\u003c/pre\u003e",
          "module": "Music.Theory.List",
          "name": "rotate_left",
          "package": "hmt",
          "signature": "Int -\u003e [a] -\u003e [a]",
          "source": "src/Music-Theory-List.html#rotate_left",
          "type": "function"
        },
        "index": {
          "description": "Left rotation rotate left rotate left",
          "hierarchy": "Music Theory List",
          "module": "Music.Theory.List",
          "name": "rotate_left",
          "normalized": "Int-\u003e[a]-\u003e[a]",
          "package": "hmt",
          "signature": "Int-\u003e[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-List.html#v:rotate_left"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRotate right by \u003cem\u003en\u003c/em\u003e places.\n\u003c/p\u003e\u003cpre\u003e rotate_r 8 [1..5] == [3,4,5,1,2]\n\u003c/pre\u003e",
          "module": "Music.Theory.List",
          "name": "rotate_r",
          "package": "hmt",
          "signature": "n -\u003e [a] -\u003e [a]",
          "source": "src/Music-Theory-List.html#rotate_r",
          "type": "function"
        },
        "index": {
          "description": "Rotate right by places rotate",
          "hierarchy": "Music Theory List",
          "module": "Music.Theory.List",
          "name": "rotate_r",
          "normalized": "a-\u003e[b]-\u003e[b]",
          "package": "hmt",
          "signature": "n-\u003e[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-List.html#v:rotate_r"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRight rotation.\n\u003c/p\u003e\u003cpre\u003e rotate_right 1 [1..3] == [3,1,2]\n\u003c/pre\u003e",
          "module": "Music.Theory.List",
          "name": "rotate_right",
          "package": "hmt",
          "signature": "Int -\u003e [a] -\u003e [a]",
          "source": "src/Music-Theory-List.html#rotate_right",
          "type": "function"
        },
        "index": {
          "description": "Right rotation rotate right",
          "hierarchy": "Music Theory List",
          "module": "Music.Theory.List",
          "name": "rotate_right",
          "normalized": "Int-\u003e[a]-\u003e[a]",
          "package": "hmt",
          "signature": "Int-\u003e[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-List.html#v:rotate_right"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAll rotations.\n\u003c/p\u003e\u003cpre\u003e rotations [0,1,3] == [[0,1,3],[1,3,0],[3,0,1]]\n\u003c/pre\u003e",
          "module": "Music.Theory.List",
          "name": "rotations",
          "package": "hmt",
          "signature": "[a] -\u003e [[a]]",
          "source": "src/Music-Theory-List.html#rotations",
          "type": "function"
        },
        "index": {
          "description": "All rotations rotations",
          "hierarchy": "Music Theory List",
          "module": "Music.Theory.List",
          "name": "rotations",
          "normalized": "[a]-\u003e[[a]]",
          "package": "hmt",
          "signature": "[a]-\u003e[[a]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-List.html#v:rotations"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eList segments of length \u003cem\u003ei\u003c/em\u003e at distance \u003cem\u003ej\u003c/em\u003e.\n\u003c/p\u003e\u003cpre\u003e segments 2 1 [1..5] == [[1,2],[2,3],[3,4],[4,5]]\n segments 2 2 [1..5] == [[1,2],[3,4]]\n\u003c/pre\u003e",
          "module": "Music.Theory.List",
          "name": "segments",
          "package": "hmt",
          "signature": "Int -\u003e Int -\u003e [a] -\u003e [[a]]",
          "source": "src/Music-Theory-List.html#segments",
          "type": "function"
        },
        "index": {
          "description": "List segments of length at distance segments segments",
          "hierarchy": "Music Theory List",
          "module": "Music.Theory.List",
          "name": "segments",
          "normalized": "Int-\u003eInt-\u003e[a]-\u003e[[a]]",
          "package": "hmt",
          "signature": "Int-\u003eInt-\u003e[a]-\u003e[[a]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-List.html#v:segments"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSeparate list into an initial list and a last element tuple.\n\u003c/p\u003e\u003cpre\u003e separate_last [1..5] == ([1..4],5)\n\u003c/pre\u003e",
          "module": "Music.Theory.List",
          "name": "separate_last",
          "package": "hmt",
          "signature": "[a] -\u003e ([a], a)",
          "source": "src/Music-Theory-List.html#separate_last",
          "type": "function"
        },
        "index": {
          "description": "Separate list into an initial list and last element tuple separate last",
          "hierarchy": "Music Theory List",
          "module": "Music.Theory.List",
          "name": "separate_last",
          "normalized": "[a]-\u003e([a],a)",
          "package": "hmt",
          "signature": "[a]-\u003e([a],a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-List.html#v:separate_last"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIs \u003cem\u003ep\u003c/em\u003e a subsequence of \u003cem\u003eq\u003c/em\u003e, ie. synonym for \u003ccode\u003e\u003ca\u003eisInfixOf\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e subsequence [1,2] [1,2,3] == True\n\u003c/pre\u003e",
          "module": "Music.Theory.List",
          "name": "subsequence",
          "package": "hmt",
          "signature": "[a] -\u003e [a] -\u003e Bool",
          "source": "src/Music-Theory-List.html#subsequence",
          "type": "function"
        },
        "index": {
          "description": "Is subsequence of ie synonym for isInfixOf subsequence True",
          "hierarchy": "Music Theory List",
          "module": "Music.Theory.List",
          "name": "subsequence",
          "normalized": "[a]-\u003e[a]-\u003eBool",
          "package": "hmt",
          "signature": "[a]-\u003e[a]-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-List.html#v:subsequence"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003efoldl1\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eunion\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e sort (union_l [[1,3],[2,3],[3]]) == [1,2,3]\n\u003c/pre\u003e",
          "module": "Music.Theory.List",
          "name": "union_l",
          "package": "hmt",
          "signature": "[[a]] -\u003e [a]",
          "source": "src/Music-Theory-List.html#union_l",
          "type": "function"
        },
        "index": {
          "description": "foldl1 union sort union",
          "hierarchy": "Music Theory List",
          "module": "Music.Theory.List",
          "name": "union_l",
          "normalized": "[[a]]-\u003e[a]",
          "package": "hmt",
          "signature": "[[a]]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-List.html#v:union_l"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMake \u003cem\u003eassoc\u003c/em\u003e list with given \u003cem\u003ekey\u003c/em\u003e.\n\u003c/p\u003e\u003cpre\u003e with_key 'a' [1..3] == [('a',1),('a',2),('a',3)]\n\u003c/pre\u003e",
          "module": "Music.Theory.List",
          "name": "with_key",
          "package": "hmt",
          "signature": "k -\u003e [v] -\u003e [(k, v)]",
          "source": "src/Music-Theory-List.html#with_key",
          "type": "function"
        },
        "index": {
          "description": "Make assoc list with given key with key",
          "hierarchy": "Music Theory List",
          "module": "Music.Theory.List",
          "name": "with_key",
          "normalized": "a-\u003e[b]-\u003e[(a,b)]",
          "package": "hmt",
          "signature": "k-\u003e[v]-\u003e[(k,v)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-List.html#v:with_key"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eClarence Barlow. \"Two Essays on Theory\".\n \u003cem\u003eComputer Music Journal\u003c/em\u003e, 11(1):44-60, 1987.\n Translated by Henning Lohner.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Music.Theory.Meter.Barlow_1987",
          "name": "Barlow_1987",
          "package": "hmt",
          "source": "src/Music-Theory-Meter-Barlow_1987.html",
          "type": "module"
        },
        "index": {
          "description": "Clarence Barlow Two Essays on Theory Computer Music Journal Translated by Henning Lohner",
          "hierarchy": "Music Theory Meter Barlow_1987",
          "module": "Music.Theory.Meter.Barlow_1987",
          "name": "Barlow_1987",
          "package": "hmt",
          "partial": "Barlow",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Meter-Barlow_1987.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAlias for \u003ccode\u003e\u003ca\u003eDouble\u003c/a\u003e\u003c/code\u003e (quieten compiler).\n\u003c/p\u003e",
          "module": "Music.Theory.Meter.Barlow_1987",
          "name": "R",
          "package": "hmt",
          "source": "src/Music-Theory-Meter-Barlow_1987.html#R",
          "type": "type"
        },
        "index": {
          "description": "Alias for Double quieten compiler",
          "hierarchy": "Music Theory Meter Barlow_1987",
          "module": "Music.Theory.Meter.Barlow_1987",
          "name": "R",
          "package": "hmt",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Meter-Barlow_1987.html#t:R"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eType pairing a stratification and a tempo.\n\u003c/p\u003e",
          "module": "Music.Theory.Meter.Barlow_1987",
          "name": "S_MM",
          "package": "hmt",
          "source": "src/Music-Theory-Meter-Barlow_1987.html#S_MM",
          "type": "type"
        },
        "index": {
          "description": "Type pairing stratification and tempo",
          "hierarchy": "Music Theory Meter Barlow_1987",
          "module": "Music.Theory.Meter.Barlow_1987",
          "name": "S_MM",
          "package": "hmt",
          "partial": "MM",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Meter-Barlow_1987.html#t:S_MM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA stratification is a tree of integral subdivisions.\n\u003c/p\u003e",
          "module": "Music.Theory.Meter.Barlow_1987",
          "name": "Stratification",
          "package": "hmt",
          "source": "src/Music-Theory-Meter-Barlow_1987.html#Stratification",
          "type": "type"
        },
        "index": {
          "description": "stratification is tree of integral subdivisions",
          "hierarchy": "Music Theory Meter Barlow_1987",
          "module": "Music.Theory.Meter.Barlow_1987",
          "name": "Stratification",
          "package": "hmt",
          "partial": "Stratification",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Meter-Barlow_1987.html#t:Stratification"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAlign two meters (given as stratifications) to least common\n multiple of their degrees.  The \u003ccode\u003e\u003ca\u003eindispensibilities\u003c/a\u003e\u003c/code\u003e function is\n given as an argument so that it may be relative if required.  This\n generates Table 7 (p.58).\n\u003c/p\u003e\u003cpre\u003e let r = [(5,5),(0,0),(2,3),(4,1),(1,4),(3,2)]\n in align_meters indispensibilities [2,3] [3,2] == r\n\u003c/pre\u003e\u003cpre\u003e let r = [(1,1),(0,0),(0.4,0.6),(0.8,0.2),(0.2,0.8),(0.6,0.4)]\n in align_meters relative_indispensibilities [2,3] [3,2] == r\n\u003c/pre\u003e\u003cpre\u003e align_meters indispensibilities [2,2,3] [3,5]\n align_meters relative_indispensibilities [2,2,3] [3,5]\n\u003c/pre\u003e",
          "module": "Music.Theory.Meter.Barlow_1987",
          "name": "align_meters",
          "package": "hmt",
          "signature": "(t -\u003e [b]) -\u003e t -\u003e t -\u003e [(b, b)]",
          "source": "src/Music-Theory-Meter-Barlow_1987.html#align_meters",
          "type": "function"
        },
        "index": {
          "description": "Align two meters given as stratifications to least common multiple of their degrees The indispensibilities function is given as an argument so that it may be relative if required This generates Table p.58 let in align meters indispensibilities let in align meters relative indispensibilities align meters indispensibilities align meters relative indispensibilities",
          "hierarchy": "Music Theory Meter Barlow_1987",
          "module": "Music.Theory.Meter.Barlow_1987",
          "name": "align_meters",
          "normalized": "(a-\u003e[b])-\u003ea-\u003ea-\u003e[(b,b)]",
          "package": "hmt",
          "signature": "(t-\u003e[b])-\u003et-\u003et-\u003e[(b,b)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Meter-Barlow_1987.html#v:align_meters"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eComposition of \u003ccode\u003e\u003ca\u003eprolong_stratifications\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003ealign_meters\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e align_s_mm indispensibilities ([2,2,3],5) ([3,5],4)\n\u003c/pre\u003e",
          "module": "Music.Theory.Meter.Barlow_1987",
          "name": "align_s_mm",
          "package": "hmt",
          "signature": "([n] -\u003e [t]) -\u003e S_MM n -\u003e S_MM n -\u003e [(t, t)]",
          "source": "src/Music-Theory-Meter-Barlow_1987.html#align_s_mm",
          "type": "function"
        },
        "index": {
          "description": "Composition of prolong stratifications and align meters align mm indispensibilities",
          "hierarchy": "Music Theory Meter Barlow_1987",
          "module": "Music.Theory.Meter.Barlow_1987",
          "name": "align_s_mm",
          "normalized": "([a]-\u003e[b])-\u003eS_MM a-\u003eS_MM a-\u003e[(b,b)]",
          "package": "hmt",
          "signature": "([n]-\u003e[t])-\u003eS_MM n-\u003eS_MM n-\u003e[(t,t)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Meter-Barlow_1987.html#v:align_s_mm"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eOne indexed variant of \u003ccode\u003e\u003ca\u003egenericIndex\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e map (at [11..13]) [1..3] == [11,12,13]\n\u003c/pre\u003e",
          "module": "Music.Theory.Meter.Barlow_1987",
          "name": "at",
          "package": "hmt",
          "signature": "[a] -\u003e n -\u003e a",
          "source": "src/Music-Theory-Meter-Barlow_1987.html#at",
          "type": "function"
        },
        "index": {
          "description": "One indexed variant of genericIndex map at",
          "hierarchy": "Music Theory Meter Barlow_1987",
          "module": "Music.Theory.Meter.Barlow_1987",
          "name": "at",
          "normalized": "[a]-\u003eb-\u003ea",
          "package": "hmt",
          "signature": "[a]-\u003en-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Meter-Barlow_1987.html#v:at"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eVariant of \u003ccode\u003e\u003ca\u003eat\u003c/a\u003e\u003c/code\u003e with boundary rules and specified error message.\n\u003c/p\u003e\u003cpre\u003e map (at' 'x' [11..13]) [0..4] == [1,11,12,13,1]\n at' 'x' [0] 3 == undefined\n\u003c/pre\u003e",
          "module": "Music.Theory.Meter.Barlow_1987",
          "name": "at'",
          "package": "hmt",
          "signature": "m -\u003e [a] -\u003e n -\u003e a",
          "source": "src/Music-Theory-Meter-Barlow_1987.html#at%27",
          "type": "function"
        },
        "index": {
          "description": "Variant of at with boundary rules and specified error message map at at undefined",
          "hierarchy": "Music Theory Meter Barlow_1987",
          "module": "Music.Theory.Meter.Barlow_1987",
          "name": "at'",
          "normalized": "a-\u003e[b]-\u003ec-\u003eb",
          "package": "hmt",
          "signature": "m-\u003e[a]-\u003en-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Meter-Barlow_1987.html#v:at-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eVariant on \u003ccode\u003e\u003ca\u003ediv\u003c/a\u003e\u003c/code\u003e with input constraints.\n\u003c/p\u003e",
          "module": "Music.Theory.Meter.Barlow_1987",
          "name": "div'",
          "package": "hmt",
          "signature": "String -\u003e a -\u003e a -\u003e a",
          "source": "src/Music-Theory-Meter-Barlow_1987.html#div%27",
          "type": "function"
        },
        "index": {
          "description": "Variant on div with input constraints",
          "hierarchy": "Music Theory Meter Barlow_1987",
          "module": "Music.Theory.Meter.Barlow_1987",
          "name": "div'",
          "normalized": "String-\u003ea-\u003ea-\u003ea",
          "package": "hmt",
          "signature": "String-\u003ea-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Meter-Barlow_1987.html#v:div-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIndispensibilities from stratification.\n\u003c/p\u003e\u003cpre\u003e indispensibilities [3,2,2] == [11,0,6,3,9,1,7,4,10,2,8,5]\n indispensibilities [2,3,2] == [11,0,6,2,8,4,10,1,7,3,9,5]\n indispensibilities [2,2,3] == [11,0,4,8,2,6,10,1,5,9,3,7]\n indispensibilities [3,5] == [14,0,9,3,6,12,1,10,4,7,13,2,11,5,8]\n\u003c/pre\u003e",
          "module": "Music.Theory.Meter.Barlow_1987",
          "name": "indispensibilities",
          "package": "hmt",
          "signature": "Stratification n -\u003e [n]",
          "source": "src/Music-Theory-Meter-Barlow_1987.html#indispensibilities",
          "type": "function"
        },
        "index": {
          "description": "Indispensibilities from stratification indispensibilities indispensibilities indispensibilities indispensibilities",
          "hierarchy": "Music Theory Meter Barlow_1987",
          "module": "Music.Theory.Meter.Barlow_1987",
          "name": "indispensibilities",
          "normalized": "Stratification a-\u003e[a]",
          "package": "hmt",
          "signature": "Stratification n-\u003e[n]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Meter-Barlow_1987.html#v:indispensibilities"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe indispensibility measure (&#968;).\n\u003c/p\u003e\u003cpre\u003e map (lower_psi [2] 1) [1..2] == [1,0]\n map (lower_psi [3] 1) [1..3] == [2,0,1]\n map (lower_psi [2,2] 2) [1..4] == [3,0,2,1]\n map (lower_psi [5] 1) [1..5] == [4,0,3,1,2]\n map (lower_psi [3,2] 2) [1..6] == [5,0,3,1,4,2]\n map (lower_psi [2,3] 2) [1..6] == [5,0,2,4,1,3]\n\u003c/pre\u003e",
          "module": "Music.Theory.Meter.Barlow_1987",
          "name": "lower_psi",
          "package": "hmt",
          "signature": "Stratification a -\u003e a -\u003e a -\u003e a",
          "source": "src/Music-Theory-Meter-Barlow_1987.html#lower_psi",
          "type": "function"
        },
        "index": {
          "description": "The indispensibility measure map lower psi map lower psi map lower psi map lower psi map lower psi map lower psi",
          "hierarchy": "Music Theory Meter Barlow_1987",
          "module": "Music.Theory.Meter.Barlow_1987",
          "name": "lower_psi",
          "normalized": "Stratification a-\u003ea-\u003ea-\u003ea",
          "package": "hmt",
          "signature": "Stratification a-\u003ea-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Meter-Barlow_1987.html#v:lower_psi"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eArithmetic mean (average) of a list.\n\u003c/p\u003e\u003cpre\u003e mean [0..5] == 2.5\n\u003c/pre\u003e",
          "module": "Music.Theory.Meter.Barlow_1987",
          "name": "mean",
          "package": "hmt",
          "signature": "[a] -\u003e a",
          "source": "src/Music-Theory-Meter-Barlow_1987.html#mean",
          "type": "function"
        },
        "index": {
          "description": "Arithmetic mean average of list mean",
          "hierarchy": "Music Theory Meter Barlow_1987",
          "module": "Music.Theory.Meter.Barlow_1987",
          "name": "mean",
          "normalized": "[a]-\u003ea",
          "package": "hmt",
          "signature": "[a]-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Meter-Barlow_1987.html#v:mean"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe square of the product of the input sequence is summed, then\n divided by the square of the sequence length.\n\u003c/p\u003e\u003cpre\u003e mean_square_product [(0,0),(1,1),(2,2),(3,3)] == 6.125\n mean_square_product [(2,3),(4,5)] == (6^2 + 20^2) / 2^2\n\u003c/pre\u003e",
          "module": "Music.Theory.Meter.Barlow_1987",
          "name": "mean_square_product",
          "package": "hmt",
          "signature": "[(n, n)] -\u003e n",
          "source": "src/Music-Theory-Meter-Barlow_1987.html#mean_square_product",
          "type": "function"
        },
        "index": {
          "description": "The square of the product of the input sequence is summed then divided by the square of the sequence length mean square product mean square product",
          "hierarchy": "Music Theory Meter Barlow_1987",
          "module": "Music.Theory.Meter.Barlow_1987",
          "name": "mean_square_product",
          "normalized": "[(a,a)]-\u003ea",
          "package": "hmt",
          "signature": "[(n,n)]-\u003en",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Meter-Barlow_1987.html#v:mean_square_product"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn incorrect attempt at the description in paragraph two of p.58\n of the \u003cem\u003eCMJ\u003c/em\u003e paper.\n\u003c/p\u003e\u003cpre\u003e let p ~= q = abs (p - q) \u003c 1e-4\n metrical_affinity [2,3] 1 [3,2] 1 ~= 0.0324\n metrical_affinity [2,2,3] 20 [3,5] 16 ~= 0.0028\n\u003c/pre\u003e",
          "module": "Music.Theory.Meter.Barlow_1987",
          "name": "metrical_affinity",
          "package": "hmt",
          "signature": "[n] -\u003e n -\u003e [n] -\u003e n -\u003e R",
          "source": "src/Music-Theory-Meter-Barlow_1987.html#metrical_affinity",
          "type": "function"
        },
        "index": {
          "description": "An incorrect attempt at the description in paragraph two of p.58 of the CMJ paper let abs e-4 metrical affinity metrical affinity",
          "hierarchy": "Music Theory Meter Barlow_1987",
          "module": "Music.Theory.Meter.Barlow_1987",
          "name": "metrical_affinity",
          "normalized": "[a]-\u003ea-\u003e[a]-\u003ea-\u003eR",
          "package": "hmt",
          "signature": "[n]-\u003en-\u003e[n]-\u003en-\u003eR",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Meter-Barlow_1987.html#v:metrical_affinity"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn incorrect attempt at Equation 6 of the \u003cem\u003eCMJ\u003c/em\u003e paper, see\n omega_z.\n\u003c/p\u003e\u003cpre\u003e let p ~= q = abs (p - q) \u003c 1e-4\n metrical_affinity' [2,2,2] 1 [2,2,2] 1 ~= 1.06735\n metrical_affinity' [2,2,2] 1 [2,2,3] 1 ~= 0.57185\n metrical_affinity' [2,2,2] 1 [2,3,2] 1 ~= 0.48575\n metrical_affinity' [2,2,2] 1 [3,2,2] 1 ~= 0.45872\n\u003c/pre\u003e\u003cpre\u003e metrical_affinity' [3,2,2] 3 [2,2,3] 2 ~= 0.10282\n\u003c/pre\u003e",
          "module": "Music.Theory.Meter.Barlow_1987",
          "name": "metrical_affinity'",
          "package": "hmt",
          "signature": "[t] -\u003e t -\u003e [t] -\u003e t -\u003e R",
          "source": "src/Music-Theory-Meter-Barlow_1987.html#metrical_affinity%27",
          "type": "function"
        },
        "index": {
          "description": "An incorrect attempt at Equation of the CMJ paper see omega let abs e-4 metrical affinity metrical affinity metrical affinity metrical affinity metrical affinity",
          "hierarchy": "Music Theory Meter Barlow_1987",
          "module": "Music.Theory.Meter.Barlow_1987",
          "name": "metrical_affinity'",
          "normalized": "[a]-\u003ea-\u003e[a]-\u003ea-\u003eR",
          "package": "hmt",
          "signature": "[t]-\u003et-\u003e[t]-\u003et-\u003eR",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Meter-Barlow_1987.html#v:metrical_affinity-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eVariant of \u003ccode\u003e\u003ca\u003emod\u003c/a\u003e\u003c/code\u003e with input constraints.\n\u003c/p\u003e\u003cpre\u003e mod' (-1) 2 == 1\n\u003c/pre\u003e",
          "module": "Music.Theory.Meter.Barlow_1987",
          "name": "mod'",
          "package": "hmt",
          "signature": "a -\u003e a -\u003e a",
          "source": "src/Music-Theory-Meter-Barlow_1987.html#mod%27",
          "type": "function"
        },
        "index": {
          "description": "Variant of mod with input constraints mod",
          "hierarchy": "Music Theory Meter Barlow_1987",
          "module": "Music.Theory.Meter.Barlow_1987",
          "name": "mod'",
          "normalized": "a-\u003ea-\u003ea",
          "package": "hmt",
          "signature": "a-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Meter-Barlow_1987.html#v:mod-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003cem\u003eMPS\u003c/em\u003e limit equation given on p.58.\n\u003c/p\u003e\u003cpre\u003e mps_limit 3 == 21 + 7/9\n\u003c/pre\u003e",
          "module": "Music.Theory.Meter.Barlow_1987",
          "name": "mps_limit",
          "package": "hmt",
          "signature": "a -\u003e a",
          "source": "src/Music-Theory-Meter-Barlow_1987.html#mps_limit",
          "type": "function"
        },
        "index": {
          "description": "The MPS limit equation given on p.58 mps limit",
          "hierarchy": "Music Theory Meter Barlow_1987",
          "module": "Music.Theory.Meter.Barlow_1987",
          "name": "mps_limit",
          "normalized": "a-\u003ea",
          "package": "hmt",
          "signature": "a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Meter-Barlow_1987.html#v:mps_limit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGenerate prime stratification for \u003cem\u003en\u003c/em\u003e.\n\u003c/p\u003e\u003cpre\u003e map prime_stratification [2,3,5,7,11] == [[2],[3],[5],[7],[11]]\n map prime_stratification [6,8,9,12] == [[3,2],[2,2,2],[3,3],[3,2,2]]\n map prime_stratification [22,10,4,1] == [[11,2],[5,2],[2,2],[]]\n map prime_stratification [18,16,12] == [[3,3,2],[2,2,2,2],[3,2,2]]\n\u003c/pre\u003e",
          "module": "Music.Theory.Meter.Barlow_1987",
          "name": "prime_stratification",
          "package": "hmt",
          "signature": "n -\u003e Stratification n",
          "source": "src/Music-Theory-Meter-Barlow_1987.html#prime_stratification",
          "type": "function"
        },
        "index": {
          "description": "Generate prime stratification for map prime stratification map prime stratification map prime stratification map prime stratification",
          "hierarchy": "Music Theory Meter Barlow_1987",
          "module": "Music.Theory.Meter.Barlow_1987",
          "name": "prime_stratification",
          "normalized": "a-\u003eStratification a",
          "package": "hmt",
          "signature": "n-\u003eStratification n",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Meter-Barlow_1987.html#v:prime_stratification"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRule to prolong stratification of two \u003ccode\u003e\u003ca\u003eS_MM\u003c/a\u003e\u003c/code\u003e values such that\n pulse at the deeper level are aligned.  (Paragraph 2, p.58)\n\u003c/p\u003e\u003cpre\u003e let x = ([2,2,2],1)\n in prolong_stratifications x x == (fst x,fst x)\n\u003c/pre\u003e\u003cpre\u003e let r = ([2,5,3,3,2],[3,2,5,5])\n in prolong_stratifications ([2,5],50) ([3,2],60) == r\n\u003c/pre\u003e\u003cpre\u003e prolong_stratifications ([2,2,3],5) ([3,5],4) == ([2,2,3],[3,5])\n\u003c/pre\u003e",
          "module": "Music.Theory.Meter.Barlow_1987",
          "name": "prolong_stratifications",
          "package": "hmt",
          "signature": "S_MM n -\u003e S_MM n -\u003e ([n], [n])",
          "source": "src/Music-Theory-Meter-Barlow_1987.html#prolong_stratifications",
          "type": "function"
        },
        "index": {
          "description": "Rule to prolong stratification of two MM values such that pulse at the deeper level are aligned Paragraph p.58 let in prolong stratifications fst fst let in prolong stratifications prolong stratifications",
          "hierarchy": "Music Theory Meter Barlow_1987",
          "module": "Music.Theory.Meter.Barlow_1987",
          "name": "prolong_stratifications",
          "normalized": "S_MM a-\u003eS_MM a-\u003e([a],[a])",
          "package": "hmt",
          "signature": "S_MM n-\u003eS_MM n-\u003e([n],[n])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Meter-Barlow_1987.html#v:prolong_stratifications"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eVariant of \u003ccode\u003e\u003ca\u003eindispensibilities\u003c/a\u003e\u003c/code\u003e that scales value to lie in\n \u003ccode\u003e(0,1)\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003erelative_indispensibilities [3,2] == [1,0,0.6,0.2,0.8,0.4]\n\u003c/p\u003e",
          "module": "Music.Theory.Meter.Barlow_1987",
          "name": "relative_indispensibilities",
          "package": "hmt",
          "signature": "Stratification n -\u003e [R]",
          "source": "src/Music-Theory-Meter-Barlow_1987.html#relative_indispensibilities",
          "type": "function"
        },
        "index": {
          "description": "Variant of indispensibilities that scales value to lie in relative indispensibilities",
          "hierarchy": "Music Theory Meter Barlow_1987",
          "module": "Music.Theory.Meter.Barlow_1987",
          "name": "relative_indispensibilities",
          "normalized": "Stratification a-\u003e[R]",
          "package": "hmt",
          "signature": "Stratification n-\u003e[R]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Meter-Barlow_1987.html#v:relative_indispensibilities"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eScale values against length of list minus one.\n\u003c/p\u003e\u003cpre\u003e relative_to_length [0..5] == [0.0,0.2,0.4,0.6,0.8,1.0]\n\u003c/pre\u003e",
          "module": "Music.Theory.Meter.Barlow_1987",
          "name": "relative_to_length",
          "package": "hmt",
          "signature": "[a] -\u003e [b]",
          "source": "src/Music-Theory-Meter-Barlow_1987.html#relative_to_length",
          "type": "function"
        },
        "index": {
          "description": "Scale values against length of list minus one relative to length",
          "hierarchy": "Music Theory Meter Barlow_1987",
          "module": "Music.Theory.Meter.Barlow_1987",
          "name": "relative_to_length",
          "normalized": "[a]-\u003e[b]",
          "package": "hmt",
          "signature": "[a]-\u003e[b]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Meter-Barlow_1987.html#v:relative_to_length"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe first \u003cem\u003en\u003c/em\u003eth primes, reversed.\n\u003c/p\u003e\u003cpre\u003e reverse_primes 14 == [43,41,37,31,29,23,19,17,13,11,7,5,3,2]\n\u003c/pre\u003e",
          "module": "Music.Theory.Meter.Barlow_1987",
          "name": "reverse_primes",
          "package": "hmt",
          "signature": "n -\u003e [n]",
          "source": "src/Music-Theory-Meter-Barlow_1987.html#reverse_primes",
          "type": "function"
        },
        "index": {
          "description": "The first th primes reversed reverse primes",
          "hierarchy": "Music Theory Meter Barlow_1987",
          "module": "Music.Theory.Meter.Barlow_1987",
          "name": "reverse_primes",
          "normalized": "a-\u003e[a]",
          "package": "hmt",
          "signature": "n-\u003e[n]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Meter-Barlow_1987.html#v:reverse_primes"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSquare of \u003cem\u003en\u003c/em\u003e.\n\u003c/p\u003e\u003cpre\u003e square 5 == 25\n\u003c/pre\u003e",
          "module": "Music.Theory.Meter.Barlow_1987",
          "name": "square",
          "package": "hmt",
          "signature": "a -\u003e a",
          "source": "src/Music-Theory-Meter-Barlow_1987.html#square",
          "type": "function"
        },
        "index": {
          "description": "Square of square",
          "hierarchy": "Music Theory Meter Barlow_1987",
          "module": "Music.Theory.Meter.Barlow_1987",
          "name": "square",
          "normalized": "a-\u003ea",
          "package": "hmt",
          "signature": "a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Meter-Barlow_1987.html#v:square"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTable such that each subsequent row deletes the least\n indispensibile pulse.\n\u003c/p\u003e\u003cpre\u003e thinning_table [3,2] == [[True,True,True,True,True,True]\n                         ,[True,False,True,True,True,True]\n                         ,[True,False,True,False,True,True]\n                         ,[True,False,True,False,True,False]\n                         ,[True,False,False,False,True,False]\n                         ,[True,False,False,False,False,False]]\n\u003c/pre\u003e",
          "module": "Music.Theory.Meter.Barlow_1987",
          "name": "thinning_table",
          "package": "hmt",
          "signature": "Stratification n -\u003e [[Bool]]",
          "source": "src/Music-Theory-Meter-Barlow_1987.html#thinning_table",
          "type": "function"
        },
        "index": {
          "description": "Table such that each subsequent row deletes the least indispensibile pulse thinning table True True True True True True True False True True True True True False True False True True True False True False True False True False False False True False True False False False False False",
          "hierarchy": "Music Theory Meter Barlow_1987",
          "module": "Music.Theory.Meter.Barlow_1987",
          "name": "thinning_table",
          "normalized": "Stratification a-\u003e[[Bool]]",
          "package": "hmt",
          "signature": "Stratification n-\u003e[[Bool]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Meter-Barlow_1987.html#v:thinning_table"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTrivial pretty printer for \u003ccode\u003e\u003ca\u003ethinning_table\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e putStrLn (thinning_table_pp [3,2])\n putStrLn (thinning_table_pp [2,3])\n\u003c/pre\u003e\u003cpre\u003e ******   ******\n *.****   *.****\n *.*.**   *.**.*\n *.*.*.   *..*.*\n *...*.   *..*..\n *.....   *.....\n\u003c/pre\u003e",
          "module": "Music.Theory.Meter.Barlow_1987",
          "name": "thinning_table_pp",
          "package": "hmt",
          "signature": "Stratification n -\u003e String",
          "source": "src/Music-Theory-Meter-Barlow_1987.html#thinning_table_pp",
          "type": "function"
        },
        "index": {
          "description": "Trivial pretty printer for thinning table putStrLn thinning table pp putStrLn thinning table pp",
          "hierarchy": "Music Theory Meter Barlow_1987",
          "module": "Music.Theory.Meter.Barlow_1987",
          "name": "thinning_table_pp",
          "normalized": "Stratification a-\u003eString",
          "package": "hmt",
          "signature": "Stratification n-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Meter-Barlow_1987.html#v:thinning_table_pp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSpecialised variant of \u003ccode\u003e\u003ca\u003efromIntegral\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Music.Theory.Meter.Barlow_1987",
          "name": "to_r",
          "package": "hmt",
          "signature": "n -\u003e R",
          "source": "src/Music-Theory-Meter-Barlow_1987.html#to_r",
          "type": "function"
        },
        "index": {
          "description": "Specialised variant of fromIntegral",
          "hierarchy": "Music Theory Meter Barlow_1987",
          "module": "Music.Theory.Meter.Barlow_1987",
          "name": "to_r",
          "normalized": "a-\u003eR",
          "package": "hmt",
          "signature": "n-\u003eR",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Meter-Barlow_1987.html#v:to_r"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Meter.Barlow_1987",
          "name": "traceShow",
          "package": "hmt",
          "signature": "a -\u003e b -\u003e b",
          "source": "src/Music-Theory-Meter-Barlow_1987.html#traceShow",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Meter Barlow_1987",
          "module": "Music.Theory.Meter.Barlow_1987",
          "name": "traceShow",
          "normalized": "a-\u003eb-\u003eb",
          "package": "hmt",
          "partial": "Show",
          "signature": "a-\u003eb-\u003eb",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Meter-Barlow_1987.html#v:traceShow"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFundamental indispensibilities for prime numbers (&#936;).\n\u003c/p\u003e\u003cpre\u003e map (upper_psi 2) [1..2] == [1,0]\n map (upper_psi 3) [1..3] == [2,0,1]\n map (upper_psi 5) [1..5] == [4,0,3,1,2]\n map (upper_psi 7) [1..7] == [6,0,4,2,5,1,3]\n map (upper_psi 11) [1..11] == [10,0,6,4,9,1,7,3,8,2,5]\n map (upper_psi 13) [1..13] == [12,0,7,4,10,1,8,5,11,2,9,3,6]\n\u003c/pre\u003e",
          "module": "Music.Theory.Meter.Barlow_1987",
          "name": "upper_psi",
          "package": "hmt",
          "signature": "a -\u003e a -\u003e a",
          "source": "src/Music-Theory-Meter-Barlow_1987.html#upper_psi",
          "type": "function"
        },
        "index": {
          "description": "Fundamental indispensibilities for prime numbers map upper psi map upper psi map upper psi map upper psi map upper psi map upper psi",
          "hierarchy": "Music Theory Meter Barlow_1987",
          "module": "Music.Theory.Meter.Barlow_1987",
          "name": "upper_psi",
          "normalized": "a-\u003ea-\u003ea",
          "package": "hmt",
          "signature": "a-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Meter-Barlow_1987.html#v:upper_psi"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn attempt at Equation 5 of the \u003cem\u003eCMJ\u003c/em\u003e paper.  When \u003cem\u003en\u003c/em\u003e is \u003cem\u003eh-1\u003c/em\u003e\n the output is incorrect (it is the product of the correct values\n for \u003cem\u003en\u003c/em\u003e at \u003cem\u003eh-1\u003c/em\u003e and \u003cem\u003eh\u003c/em\u003e).\n\u003c/p\u003e\u003cpre\u003e map (upper_psi' 5) [1..5] /= [4,0,3,1,2]\n map (upper_psi' 7) [1..7] /= [6,0,4,2,5,1,3]\n map (upper_psi' 11) [1..11] /= [10,0,6,4,9,1,7,3,8,2,5]\n map (upper_psi' 13) [1..13] /= [12,0,7,4,10,1,8,5,11,2,9,3,6]\n\u003c/pre\u003e",
          "module": "Music.Theory.Meter.Barlow_1987",
          "name": "upper_psi'",
          "package": "hmt",
          "signature": "a -\u003e a -\u003e a",
          "source": "src/Music-Theory-Meter-Barlow_1987.html#upper_psi%27",
          "type": "function"
        },
        "index": {
          "description": "An attempt at Equation of the CMJ paper When is h-1 the output is incorrect it is the product of the correct values for at h-1 and map upper psi map upper psi map upper psi map upper psi",
          "hierarchy": "Music Theory Meter Barlow_1987",
          "module": "Music.Theory.Meter.Barlow_1987",
          "name": "upper_psi'",
          "normalized": "a-\u003ea-\u003ea",
          "package": "hmt",
          "signature": "a-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Meter-Barlow_1987.html#v:upper_psi-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eVariant of \u003ccode\u003e\u003ca\u003ediv\u003c/a\u003e\u003c/code\u003e that requires \u003ccode\u003e\u003ca\u003emod\u003c/a\u003e\u003c/code\u003e be \u003ccode\u003e0\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Music.Theory.Meter.Barlow_1987",
          "name": "whole_div",
          "package": "hmt",
          "signature": "a -\u003e a -\u003e a",
          "source": "src/Music-Theory-Meter-Barlow_1987.html#whole_div",
          "type": "function"
        },
        "index": {
          "description": "Variant of div that requires mod be",
          "hierarchy": "Music Theory Meter Barlow_1987",
          "module": "Music.Theory.Meter.Barlow_1987",
          "name": "whole_div",
          "normalized": "a-\u003ea-\u003ea",
          "package": "hmt",
          "signature": "a-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Meter-Barlow_1987.html#v:whole_div"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eVariant of \u003ccode\u003e\u003ca\u003equot\u003c/a\u003e\u003c/code\u003e that requires \u003ccode\u003e\u003ca\u003erem\u003c/a\u003e\u003c/code\u003e be \u003ccode\u003e0\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Music.Theory.Meter.Barlow_1987",
          "name": "whole_quot",
          "package": "hmt",
          "signature": "a -\u003e a -\u003e a",
          "source": "src/Music-Theory-Meter-Barlow_1987.html#whole_quot",
          "type": "function"
        },
        "index": {
          "description": "Variant of quot that requires rem be",
          "hierarchy": "Music Theory Meter Barlow_1987",
          "module": "Music.Theory.Meter.Barlow_1987",
          "name": "whole_quot",
          "normalized": "a-\u003ea-\u003ea",
          "package": "hmt",
          "signature": "a-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Meter-Barlow_1987.html#v:whole_quot"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eMichael Buchler. \"Relative Saturation of Subsets and Interval\n Cycles as a Means for Determining Set-Class Similarity\". PhD\n thesis, University of Rochester, 1998\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Music.Theory.Metric.Buchler_1998",
          "name": "Buchler_1998",
          "package": "hmt",
          "source": "src/Music-Theory-Metric-Buchler_1998.html",
          "type": "module"
        },
        "index": {
          "description": "Michael Buchler Relative Saturation of Subsets and Interval Cycles as Means for Determining Set-Class Similarity PhD thesis University of Rochester",
          "hierarchy": "Music Theory Metric Buchler_1998",
          "module": "Music.Theory.Metric.Buchler_1998",
          "name": "Buchler_1998",
          "package": "hmt",
          "partial": "Buchler",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Metric-Buchler_1998.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Metric.Buchler_1998",
          "name": "D",
          "package": "hmt",
          "source": "src/Music-Theory-Metric-Buchler_1998.html#D",
          "type": "type"
        },
        "index": {
          "hierarchy": "Music Theory Metric Buchler_1998",
          "module": "Music.Theory.Metric.Buchler_1998",
          "name": "D",
          "package": "hmt",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Metric-Buchler_1998.html#t:D"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Metric.Buchler_1998",
          "name": "R",
          "package": "hmt",
          "source": "src/Music-Theory-Metric-Buchler_1998.html#R",
          "type": "data"
        },
        "index": {
          "hierarchy": "Music Theory Metric Buchler_1998",
          "module": "Music.Theory.Metric.Buchler_1998",
          "name": "R",
          "package": "hmt",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Metric-Buchler_1998.html#t:R"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Metric.Buchler_1998",
          "name": "SATV",
          "package": "hmt",
          "source": "src/Music-Theory-Metric-Buchler_1998.html#SATV",
          "type": "type"
        },
        "index": {
          "hierarchy": "Music Theory Metric Buchler_1998",
          "module": "Music.Theory.Metric.Buchler_1998",
          "name": "SATV",
          "package": "hmt",
          "partial": "SATV",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Metric-Buchler_1998.html#t:SATV"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Metric.Buchler_1998",
          "name": "MAX",
          "package": "hmt",
          "signature": "MAX",
          "source": "src/Music-Theory-Metric-Buchler_1998.html#R",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Metric Buchler_1998",
          "module": "Music.Theory.Metric.Buchler_1998",
          "name": "MAX",
          "package": "hmt",
          "partial": "MAX",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Metric-Buchler_1998.html#v:MAX"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Metric.Buchler_1998",
          "name": "MIN",
          "package": "hmt",
          "signature": "MIN",
          "source": "src/Music-Theory-Metric-Buchler_1998.html#R",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Metric Buchler_1998",
          "module": "Music.Theory.Metric.Buchler_1998",
          "name": "MIN",
          "package": "hmt",
          "partial": "MIN",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Metric-Buchler_1998.html#v:MIN"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAbsolute difference.\n\u003c/p\u003e",
          "module": "Music.Theory.Metric.Buchler_1998",
          "name": "abs_dif",
          "package": "hmt",
          "signature": "a -\u003e a -\u003e a",
          "source": "src/Music-Theory-Metric-Buchler_1998.html#abs_dif",
          "type": "function"
        },
        "index": {
          "description": "Absolute difference",
          "hierarchy": "Music Theory Metric Buchler_1998",
          "module": "Music.Theory.Metric.Buchler_1998",
          "name": "abs_dif",
          "normalized": "a-\u003ea-\u003ea",
          "package": "hmt",
          "signature": "a-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Metric-Buchler_1998.html#v:abs_dif"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMinima and maxima of ICV of SCs of cardinality \u003cem\u003en\u003c/em\u003e.\n\u003c/p\u003e\u003cpre\u003e icv_minmax 5 == ([0,0,0,1,0,0],[4,4,4,4,4,2])\n\u003c/pre\u003e",
          "module": "Music.Theory.Metric.Buchler_1998",
          "name": "icv_minmax",
          "package": "hmt",
          "signature": "n -\u003e ([b], [b])",
          "source": "src/Music-Theory-Metric-Buchler_1998.html#icv_minmax",
          "type": "function"
        },
        "index": {
          "description": "Minima and maxima of ICV of SCs of cardinality icv minmax",
          "hierarchy": "Music Theory Metric Buchler_1998",
          "module": "Music.Theory.Metric.Buchler_1998",
          "name": "icv_minmax",
          "normalized": "a-\u003e([b],[b])",
          "package": "hmt",
          "signature": "n-\u003e([b],[b])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Metric-Buchler_1998.html#v:icv_minmax"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePredicate for list with cardinality \u003cem\u003en\u003c/em\u003e.\n\u003c/p\u003e",
          "module": "Music.Theory.Metric.Buchler_1998",
          "name": "of_c",
          "package": "hmt",
          "signature": "n -\u003e [a] -\u003e Bool",
          "source": "src/Music-Theory-Metric-Buchler_1998.html#of_c",
          "type": "function"
        },
        "index": {
          "description": "Predicate for list with cardinality",
          "hierarchy": "Music Theory Metric Buchler_1998",
          "module": "Music.Theory.Metric.Buchler_1998",
          "name": "of_c",
          "normalized": "a-\u003e[b]-\u003eBool",
          "package": "hmt",
          "signature": "n-\u003e[a]-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Metric-Buchler_1998.html#v:of_c"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePretty printer for \u003ccode\u003e\u003ca\u003eR\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e map r_pp [MIN,MAX] == [\"+\",\"-\"]\n\u003c/pre\u003e",
          "module": "Music.Theory.Metric.Buchler_1998",
          "name": "r_pp",
          "package": "hmt",
          "signature": "R -\u003e String",
          "source": "src/Music-Theory-Metric-Buchler_1998.html#r_pp",
          "type": "function"
        },
        "index": {
          "description": "Pretty printer for map pp MIN MAX",
          "hierarchy": "Music Theory Metric Buchler_1998",
          "module": "Music.Theory.Metric.Buchler_1998",
          "name": "r_pp",
          "normalized": "R-\u003eString",
          "package": "hmt",
          "signature": "R-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Metric-Buchler_1998.html#v:r_pp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eSATSIM\u003c/code\u003e metric.\n\u003c/p\u003e\u003cpre\u003e satsim [0,1,2,6,7,8] [0,3,6,9] == 25/46\n satsim [0,4] [0,1,3,4,6,9] == 25/34\n satsim [0,4] [0,1,3,6,7,9] == 25/34\n satsim [0,1,2,3,6] [0,1,2,3,4,6] == 1/49\n satsim [0,1,3,6,8] [0,2,3,5,7,9] == 1/49\n satsim [0,1,2,3,4] [0,1,4,5,7] == 8/21\n satsim [0,1,2,3,4] [0,2,4,6,8] == 4/7\n satsim [0,1,4,5,7] [0,2,4,6,8] == 4/7\n\u003c/pre\u003e",
          "module": "Music.Theory.Metric.Buchler_1998",
          "name": "satsim",
          "package": "hmt",
          "signature": "[Z12] -\u003e [Z12] -\u003e Ratio a",
          "source": "src/Music-Theory-Metric-Buchler_1998.html#satsim",
          "type": "function"
        },
        "index": {
          "description": "SATSIM metric satsim satsim satsim satsim satsim satsim satsim satsim",
          "hierarchy": "Music Theory Metric Buchler_1998",
          "module": "Music.Theory.Metric.Buchler_1998",
          "name": "satsim",
          "normalized": "[Z]-\u003e[Z]-\u003eRatio a",
          "package": "hmt",
          "signature": "[Z]-\u003e[Z]-\u003eRatio a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Metric-Buchler_1998.html#v:satsim"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTable of \u003ccode\u003e\u003ca\u003esatsim\u003c/a\u003e\u003c/code\u003e measures for all \u003ccode\u003eSC\u003c/code\u003e pairs.\n\u003c/p\u003e\u003cpre\u003e length satsim_table == 24310\n\u003c/pre\u003e",
          "module": "Music.Theory.Metric.Buchler_1998",
          "name": "satsim_table",
          "package": "hmt",
          "signature": "[(([Z12], [Z12]), Ratio i)]",
          "source": "src/Music-Theory-Metric-Buchler_1998.html#satsim_table",
          "type": "function"
        },
        "index": {
          "description": "Table of satsim measures for all SC pairs length satsim table",
          "hierarchy": "Music Theory Metric Buchler_1998",
          "module": "Music.Theory.Metric.Buchler_1998",
          "name": "satsim_table",
          "normalized": "[(([Z],[Z]),Ratio a)]",
          "package": "hmt",
          "signature": "[(([Z],[Z]),Ratio i)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Metric-Buchler_1998.html#v:satsim_table"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eHistogram of values at \u003ccode\u003e\u003ca\u003esatsim_table\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e satsim_table_histogram == L.histogram (map snd satsim_table)\n\u003c/pre\u003e",
          "module": "Music.Theory.Metric.Buchler_1998",
          "name": "satsim_table_histogram",
          "package": "hmt",
          "signature": "[(Ratio i, i)]",
          "source": "src/Music-Theory-Metric-Buchler_1998.html#satsim_table_histogram",
          "type": "function"
        },
        "index": {
          "description": "Histogram of values at satsim table satsim table histogram L.histogram map snd satsim table",
          "hierarchy": "Music Theory Metric Buchler_1998",
          "module": "Music.Theory.Metric.Buchler_1998",
          "name": "satsim_table_histogram",
          "normalized": "[(Ratio a,a)]",
          "package": "hmt",
          "signature": "[(Ratio i,i)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Metric-Buchler_1998.html#v:satsim_table_histogram"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eSATV\u003c/a\u003e\u003c/code\u003e measure.\n\u003c/p\u003e\u003cpre\u003e satv_pp (satv [0,3,6,9]) == \"(\u003c+0,+0,-0,+0,+0,-0\u003e,\u003c-3,-3,+4,-3,-3,+2\u003e)\"\n satv_pp (satv [0,1,3,4,8]) == \"(\u003c-2,+1,-2,-1,-2,+0\u003e,\u003c+2,-3,+2,+2,+2,-2\u003e)\"\n satv_pp (satv [0,1,2,6,7,8]) == \"(\u003c-1,+2,+0,+0,-1,-0\u003e,\u003c+4,-4,-5,-4,+4,+3\u003e)\"\n satv_pp (satv [0,4]) == \"(\u003c+0,+0,+0,-0,+0,+0\u003e,\u003c-1,-1,-1,+1,-1,-1\u003e)\"\n satv_pp (satv [0,1,3,4,6,9]) == \"(\u003c+2,+2,-0,+0,+2,-1\u003e,\u003c-3,-4,+5,-4,-3,+2\u003e)\"\n satv_pp (satv [0,1,3,6,7,9]) == \"(\u003c+2,+2,-1,+0,+2,-0\u003e,\u003c-3,-4,+4,-4,-3,+3\u003e)\"\n satv_pp (satv [0,1,2,3,6]) == \"(\u003c-1,-2,-2,+0,+1,-1\u003e,\u003c+3,+2,+2,-3,-3,+1\u003e)\"\n satv_pp (satv [0,1,2,3,4,6]) == \"(\u003c-1,-2,-2,+0,+1,+1\u003e,\u003c+4,+4,+3,-4,-4,-2\u003e)\"\n satv_pp (satv [0,1,3,6,8]) == \"(\u003c+1,-2,-2,+0,-1,-1\u003e,\u003c-3,+2,+2,-3,+3,+1\u003e)\"\n satv_pp (satv [0,2,3,5,7,9]) == \"(\u003c+1,-2,-2,+0,-1,+1\u003e,\u003c-4,+4,+3,-4,+4,-2\u003e)\"\n\u003c/pre\u003e",
          "module": "Music.Theory.Metric.Buchler_1998",
          "name": "satv",
          "package": "hmt",
          "signature": "[Z12] -\u003e SATV i",
          "source": "src/Music-Theory-Metric-Buchler_1998.html#satv",
          "type": "function"
        },
        "index": {
          "description": "SATV measure satv pp satv satv pp satv satv pp satv satv pp satv satv pp satv satv pp satv satv pp satv satv pp satv satv pp satv satv pp satv",
          "hierarchy": "Music Theory Metric Buchler_1998",
          "module": "Music.Theory.Metric.Buchler_1998",
          "name": "satv",
          "normalized": "[Z]-\u003eSATV a",
          "package": "hmt",
          "signature": "[Z]-\u003eSATV i",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Metric-Buchler_1998.html#v:satv"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eSATVa\u003c/code\u003e measure.\n\u003c/p\u003e\u003cpre\u003e satv_e_pp (satv_a [0,1,2,6,7,8]) == \"\u003c-1,+2,+0,+0,-1,-0\u003e\"\n satv_e_pp (satv_a [0,1,2,3,4]) == \"\u003c-0,-1,-2,+0,+0,+0\u003e\"\n\u003c/pre\u003e",
          "module": "Music.Theory.Metric.Buchler_1998",
          "name": "satv_a",
          "package": "hmt",
          "signature": "[Z12] -\u003e [D i]",
          "source": "src/Music-Theory-Metric-Buchler_1998.html#satv_a",
          "type": "function"
        },
        "index": {
          "description": "SATVa measure satv pp satv satv pp satv",
          "hierarchy": "Music Theory Metric Buchler_1998",
          "module": "Music.Theory.Metric.Buchler_1998",
          "name": "satv_a",
          "normalized": "[Z]-\u003e[D a]",
          "package": "hmt",
          "signature": "[Z]-\u003e[D i]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Metric-Buchler_1998.html#v:satv_a"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eSATVb\u003c/code\u003e measure.\n\u003c/p\u003e\u003cpre\u003e satv_e_pp (satv_b [0,1,2,6,7,8]) == \"\u003c+4,-4,-5,-4,+4,+3\u003e\"\n satv_e_pp (satv_b [0,1,2,3,4]) == \"\u003c+4,+3,+2,-3,-4,-2\u003e\"\n\u003c/pre\u003e",
          "module": "Music.Theory.Metric.Buchler_1998",
          "name": "satv_b",
          "package": "hmt",
          "signature": "[Z12] -\u003e [D i]",
          "source": "src/Music-Theory-Metric-Buchler_1998.html#satv_b",
          "type": "function"
        },
        "index": {
          "description": "SATVb measure satv pp satv satv pp satv",
          "hierarchy": "Music Theory Metric Buchler_1998",
          "module": "Music.Theory.Metric.Buchler_1998",
          "name": "satv_b",
          "normalized": "[Z]-\u003e[D a]",
          "package": "hmt",
          "signature": "[Z]-\u003e[D i]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Metric-Buchler_1998.html#v:satv_b"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePretty printer for SATV element.\n\u003c/p\u003e\u003cpre\u003e satv_e_pp (satv_a [0,1,2,6,7,8]) == \"\u003c-1,+2,+0,+0,-1,-0\u003e\"\n\u003c/pre\u003e",
          "module": "Music.Theory.Metric.Buchler_1998",
          "name": "satv_e_pp",
          "package": "hmt",
          "signature": "[D i] -\u003e String",
          "source": "src/Music-Theory-Metric-Buchler_1998.html#satv_e_pp",
          "type": "function"
        },
        "index": {
          "description": "Pretty printer for SATV element satv pp satv",
          "hierarchy": "Music Theory Metric Buchler_1998",
          "module": "Music.Theory.Metric.Buchler_1998",
          "name": "satv_e_pp",
          "normalized": "[D a]-\u003eString",
          "package": "hmt",
          "signature": "[D i]-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Metric-Buchler_1998.html#v:satv_e_pp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eSATV\u003c/a\u003e\u003c/code\u003e element measure with given funtion.\n\u003c/p\u003e",
          "module": "Music.Theory.Metric.Buchler_1998",
          "name": "satv_f",
          "package": "hmt",
          "signature": "((n, n, n) -\u003e D n) -\u003e [Z12] -\u003e [D n]",
          "source": "src/Music-Theory-Metric-Buchler_1998.html#satv_f",
          "type": "function"
        },
        "index": {
          "description": "SATV element measure with given funtion",
          "hierarchy": "Music Theory Metric Buchler_1998",
          "module": "Music.Theory.Metric.Buchler_1998",
          "name": "satv_f",
          "normalized": "((a,a,a)-\u003eD a)-\u003e[Z]-\u003e[D a]",
          "package": "hmt",
          "signature": "((n,n,n)-\u003eD n)-\u003e[Z]-\u003e[D n]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Metric-Buchler_1998.html#v:satv_f"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eSATV\u003c/a\u003e\u003c/code\u003e reorganised by \u003ccode\u003e\u003ca\u003eR\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e satv_minmax (satv [0,1,2,6,7,8]) == ([4,2,0,0,4,3],[1,4,5,4,1,0])\n\u003c/pre\u003e",
          "module": "Music.Theory.Metric.Buchler_1998",
          "name": "satv_minmax",
          "package": "hmt",
          "signature": "SATV i -\u003e ([i], [i])",
          "source": "src/Music-Theory-Metric-Buchler_1998.html#satv_minmax",
          "type": "function"
        },
        "index": {
          "description": "SATV reorganised by satv minmax satv",
          "hierarchy": "Music Theory Metric Buchler_1998",
          "module": "Music.Theory.Metric.Buchler_1998",
          "name": "satv_minmax",
          "normalized": "SATV a-\u003e([a],[a])",
          "package": "hmt",
          "signature": "SATV i-\u003e([i],[i])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Metric-Buchler_1998.html#v:satv_minmax"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSum of numerical components of \u003ccode\u003ea\u003c/code\u003e and \u003ccode\u003eb\u003c/code\u003e parts of \u003ccode\u003e\u003ca\u003eSATV\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e satv_n_sum (satv [0,1,2,6,7,8]) == [5,6,5,4,5,3]\n satv_n_sum (satv [0,3,6,9]) = [3,3,4,3,3,2]\n\u003c/pre\u003e",
          "module": "Music.Theory.Metric.Buchler_1998",
          "name": "satv_n_sum",
          "package": "hmt",
          "signature": "SATV c -\u003e [c]",
          "source": "src/Music-Theory-Metric-Buchler_1998.html#satv_n_sum",
          "type": "function"
        },
        "index": {
          "description": "Sum of numerical components of and parts of SATV satv sum satv satv sum satv",
          "hierarchy": "Music Theory Metric Buchler_1998",
          "module": "Music.Theory.Metric.Buchler_1998",
          "name": "satv_n_sum",
          "normalized": "SATV a-\u003e[a]",
          "package": "hmt",
          "signature": "SATV c-\u003e[c]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Metric-Buchler_1998.html#v:satv_n_sum"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePretty printer for \u003ccode\u003e\u003ca\u003eSATV\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Music.Theory.Metric.Buchler_1998",
          "name": "satv_pp",
          "package": "hmt",
          "signature": "SATV i -\u003e String",
          "source": "src/Music-Theory-Metric-Buchler_1998.html#satv_pp",
          "type": "function"
        },
        "index": {
          "description": "Pretty printer for SATV",
          "hierarchy": "Music Theory Metric Buchler_1998",
          "module": "Music.Theory.Metric.Buchler_1998",
          "name": "satv_pp",
          "normalized": "SATV a-\u003eString",
          "package": "hmt",
          "signature": "SATV i-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Metric-Buchler_1998.html#v:satv_pp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSet classes of cardinality \u003cem\u003en\u003c/em\u003e.\n\u003c/p\u003e\u003cpre\u003e sc_table_n 2 == [[0,1],[0,2],[0,3],[0,4],[0,5],[0,6]]\n\u003c/pre\u003e",
          "module": "Music.Theory.Metric.Buchler_1998",
          "name": "sc_table_n",
          "package": "hmt",
          "signature": "n -\u003e [[Z12]]",
          "source": "src/Music-Theory-Metric-Buchler_1998.html#sc_table_n",
          "type": "function"
        },
        "index": {
          "description": "Set classes of cardinality sc table",
          "hierarchy": "Music Theory Metric Buchler_1998",
          "module": "Music.Theory.Metric.Buchler_1998",
          "name": "sc_table_n",
          "normalized": "a-\u003e[[Z]]",
          "package": "hmt",
          "signature": "n-\u003e[[Z]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Metric-Buchler_1998.html#v:sc_table_n"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Metric.Buchler_1998",
          "name": "two_part_difference_vector",
          "package": "hmt",
          "signature": "[D i] -\u003e SATV i -\u003e [i]",
          "source": "src/Music-Theory-Metric-Buchler_1998.html#two_part_difference_vector",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Metric Buchler_1998",
          "module": "Music.Theory.Metric.Buchler_1998",
          "name": "two_part_difference_vector",
          "normalized": "[D a]-\u003eSATV a-\u003e[a]",
          "package": "hmt",
          "signature": "[D i]-\u003eSATV i-\u003e[i]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Metric-Buchler_1998.html#v:two_part_difference_vector"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Metric.Buchler_1998",
          "name": "two_part_difference_vector_set",
          "package": "hmt",
          "signature": "SATV i -\u003e SATV i -\u003e ([i], [i])",
          "source": "src/Music-Theory-Metric-Buchler_1998.html#two_part_difference_vector_set",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Metric Buchler_1998",
          "module": "Music.Theory.Metric.Buchler_1998",
          "name": "two_part_difference_vector_set",
          "normalized": "SATV a-\u003eSATV a-\u003e([a],[a])",
          "package": "hmt",
          "signature": "SATV i-\u003eSATV i-\u003e([i],[i])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Metric-Buchler_1998.html#v:two_part_difference_vector_set"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eRobert Morris. \"A Similarity Index for Pitch-Class\n Sets\". Perspectives of New Music, 18(2):445-460, 1980.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Music.Theory.Metric.Morris_1980",
          "name": "Morris_1980",
          "package": "hmt",
          "source": "src/Music-Theory-Metric-Morris_1980.html",
          "type": "module"
        },
        "index": {
          "description": "Robert Morris Similarity Index for Pitch-Class Sets Perspectives of New Music",
          "hierarchy": "Music Theory Metric Morris_1980",
          "module": "Music.Theory.Metric.Morris_1980",
          "name": "Morris_1980",
          "package": "hmt",
          "partial": "Morris",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Metric-Morris_1980.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eASIM\n\u003c/p\u003e\u003cpre\u003e asim [0,1,3,6] [0,2,4,7] == 6/12\n asim [0,1,2,4,5,8] [0,1,3,7] == 9/21\n asim [0,1,2,3,4] [0,1,4,5,7] == 2/5\n asim [0,1,2,3,4] [0,2,4,6,8] == 3/5\n asim [0,1,4,5,7] [0,2,4,6,8] == 3/5\n\u003c/pre\u003e",
          "module": "Music.Theory.Metric.Morris_1980",
          "name": "asim",
          "package": "hmt",
          "signature": "[Z12] -\u003e [Z12] -\u003e Ratio n",
          "source": "src/Music-Theory-Metric-Morris_1980.html#asim",
          "type": "function"
        },
        "index": {
          "description": "ASIM asim asim asim asim asim",
          "hierarchy": "Music Theory Metric Morris_1980",
          "module": "Music.Theory.Metric.Morris_1980",
          "name": "asim",
          "normalized": "[Z]-\u003e[Z]-\u003eRatio a",
          "package": "hmt",
          "signature": "[Z]-\u003e[Z]-\u003eRatio n",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Metric-Morris_1980.html#v:asim"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSIM\n\u003c/p\u003e\u003cpre\u003e icv [0,1,3,6] == [1,1,2,0,1,1] && icv [0,2,4,7] == [0,2,1,1,2,0]\n sim [0,1,3,6] [0,2,4,7] == 6\n sim [0,1,2,4,5,8] [0,1,3,7] == 9\n\u003c/pre\u003e",
          "module": "Music.Theory.Metric.Morris_1980",
          "name": "sim",
          "package": "hmt",
          "signature": "[Z12] -\u003e [Z12] -\u003e a",
          "source": "src/Music-Theory-Metric-Morris_1980.html#sim",
          "type": "function"
        },
        "index": {
          "description": "SIM icv icv sim sim",
          "hierarchy": "Music Theory Metric Morris_1980",
          "module": "Music.Theory.Metric.Morris_1980",
          "name": "sim",
          "normalized": "[Z]-\u003e[Z]-\u003ea",
          "package": "hmt",
          "signature": "[Z]-\u003e[Z]-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Metric-Morris_1980.html#v:sim"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eLarry Polansky. \"Morphological Metrics\". Journal of New Music\n Research, 25(4):289-368, 1996.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Music.Theory.Metric.Polansky_1996",
          "name": "Polansky_1996",
          "package": "hmt",
          "source": "src/Music-Theory-Metric-Polansky_1996.html",
          "type": "module"
        },
        "index": {
          "description": "Larry Polansky Morphological Metrics Journal of New Music Research",
          "hierarchy": "Music Theory Metric Polansky_1996",
          "module": "Music.Theory.Metric.Polansky_1996",
          "name": "Polansky_1996",
          "package": "hmt",
          "partial": "Polansky",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Metric-Polansky_1996.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eDelta\u003c/a\u003e\u003c/code\u003e (&#916;) determines an interval given a sequence and an index.\n\u003c/p\u003e",
          "module": "Music.Theory.Metric.Polansky_1996",
          "name": "Delta",
          "package": "hmt",
          "source": "src/Music-Theory-Metric-Polansky_1996.html#Delta",
          "type": "type"
        },
        "index": {
          "description": "Delta determines an interval given sequence and an index",
          "hierarchy": "Music Theory Metric Polansky_1996",
          "module": "Music.Theory.Metric.Polansky_1996",
          "name": "Delta",
          "package": "hmt",
          "partial": "Delta",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Metric-Polansky_1996.html#t:Delta"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDistance function, ordinarily \u003cem\u003en\u003c/em\u003e below is in \u003ccode\u003e\u003ca\u003eNum\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eFractional\u003c/a\u003e\u003c/code\u003e\n or \u003ccode\u003e\u003ca\u003eReal\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Music.Theory.Metric.Polansky_1996",
          "name": "Interval",
          "package": "hmt",
          "source": "src/Music-Theory-Metric-Polansky_1996.html#Interval",
          "type": "type"
        },
        "index": {
          "description": "Distance function ordinarily below is in Num Fractional or Real",
          "hierarchy": "Music Theory Metric Polansky_1996",
          "module": "Music.Theory.Metric.Polansky_1996",
          "name": "Interval",
          "package": "hmt",
          "partial": "Interval",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Metric-Polansky_1996.html#t:Interval"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003ePsi\u003c/a\u003e\u003c/code\u003e (&#936;) joins \u003ccode\u003e\u003ca\u003eDelta\u003c/a\u003e\u003c/code\u003e equivalent intervals from morphologies \u003cem\u003em\u003c/em\u003e and \u003cem\u003en\u003c/em\u003e.\n\u003c/p\u003e",
          "module": "Music.Theory.Metric.Polansky_1996",
          "name": "Psi",
          "package": "hmt",
          "source": "src/Music-Theory-Metric-Polansky_1996.html#Psi",
          "type": "type"
        },
        "index": {
          "description": "Psi joins Delta equivalent intervals from morphologies and",
          "hierarchy": "Music Theory Metric Polansky_1996",
          "module": "Music.Theory.Metric.Polansky_1996",
          "name": "Psi",
          "package": "hmt",
          "partial": "Psi",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Metric-Polansky_1996.html#t:Psi"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eabs\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e \u003cem\u003ef\u003c/em\u003e.\n\u003c/p\u003e",
          "module": "Music.Theory.Metric.Polansky_1996",
          "name": "abs_dif",
          "package": "hmt",
          "signature": "Interval a n -\u003e a -\u003e a -\u003e n",
          "source": "src/Music-Theory-Metric-Polansky_1996.html#abs_dif",
          "type": "function"
        },
        "index": {
          "description": "abs",
          "hierarchy": "Music Theory Metric Polansky_1996",
          "module": "Music.Theory.Metric.Polansky_1996",
          "name": "abs_dif",
          "normalized": "Interval a b-\u003ea-\u003ea-\u003eb",
          "package": "hmt",
          "signature": "Interval a n-\u003ea-\u003ea-\u003en",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Metric-Polansky_1996.html#v:abs_dif"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eabs\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eix_dif\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e\u003cpre\u003e map (abs_ix_dif (-) [0,2,4,1,0]) [0..3] == [2,2,3,1]\n\u003c/pre\u003e",
          "module": "Music.Theory.Metric.Polansky_1996",
          "name": "abs_ix_dif",
          "package": "hmt",
          "signature": "Interval a n -\u003e Delta a n",
          "source": "src/Music-Theory-Metric-Polansky_1996.html#abs_ix_dif",
          "type": "function"
        },
        "index": {
          "description": "abs ix dif map abs ix dif",
          "hierarchy": "Music Theory Metric Polansky_1996",
          "module": "Music.Theory.Metric.Polansky_1996",
          "name": "abs_ix_dif",
          "normalized": "Interval a b-\u003eDelta a b",
          "package": "hmt",
          "signature": "Interval a n-\u003eDelta a n",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Metric-Polansky_1996.html#v:abs_ix_dif"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCube root.\n\u003c/p\u003e\u003cpre\u003e map cbrt [1,8,27] == [1,2,3]\n\u003c/pre\u003e",
          "module": "Music.Theory.Metric.Polansky_1996",
          "name": "cbrt",
          "package": "hmt",
          "signature": "a -\u003e a",
          "source": "src/Music-Theory-Metric-Polansky_1996.html#cbrt",
          "type": "function"
        },
        "index": {
          "description": "Cube root map cbrt",
          "hierarchy": "Music Theory Metric Polansky_1996",
          "module": "Music.Theory.Metric.Polansky_1996",
          "name": "cbrt",
          "normalized": "a-\u003ea",
          "package": "hmt",
          "signature": "a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Metric-Polansky_1996.html#v:cbrt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCity block metric, p.296\n\u003c/p\u003e\u003cpre\u003e city_block_metric (-) (1,2) (3,5) == 2+3\n\u003c/pre\u003e",
          "module": "Music.Theory.Metric.Polansky_1996",
          "name": "city_block_metric",
          "package": "hmt",
          "signature": "Interval a n -\u003e (a, a) -\u003e (a, a) -\u003e n",
          "source": "src/Music-Theory-Metric-Polansky_1996.html#city_block_metric",
          "type": "function"
        },
        "index": {
          "description": "City block metric p.296 city block metric",
          "hierarchy": "Music Theory Metric Polansky_1996",
          "module": "Music.Theory.Metric.Polansky_1996",
          "name": "city_block_metric",
          "normalized": "Interval a b-\u003e(a,a)-\u003e(a,a)-\u003eb",
          "package": "hmt",
          "signature": "Interval a n-\u003e(a,a)-\u003e(a,a)-\u003en",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Metric-Polansky_1996.html#v:city_block_metric"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003ehalf_matrix_f\u003c/a\u003e\u003c/code\u003e, Fig.9, p.318\n\u003c/p\u003e\u003cpre\u003e let r = [[2,3,1,4]\n           ,[1,3,6]\n             ,[4,7]\n               ,[3]]\n in combinatorial_magnitude_matrix (abs_dif (-)) [5,3,2,6,9] == r\n\u003c/pre\u003e",
          "module": "Music.Theory.Metric.Polansky_1996",
          "name": "combinatorial_magnitude_matrix",
          "package": "hmt",
          "signature": "Interval a n -\u003e [a] -\u003e [[n]]",
          "source": "src/Music-Theory-Metric-Polansky_1996.html#combinatorial_magnitude_matrix",
          "type": "function"
        },
        "index": {
          "description": "half matrix Fig.9 p.318 let in combinatorial magnitude matrix abs dif",
          "hierarchy": "Music Theory Metric Polansky_1996",
          "module": "Music.Theory.Metric.Polansky_1996",
          "name": "combinatorial_magnitude_matrix",
          "normalized": "Interval a b-\u003e[a]-\u003e[[b]]",
          "package": "hmt",
          "signature": "Interval a n-\u003e[a]-\u003e[[n]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Metric-Polansky_1996.html#v:combinatorial_magnitude_matrix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIntegration with \u003cem\u003ef\u003c/em\u003e.\n\u003c/p\u003e\u003cpre\u003e d_dx (-) [0,2,4,1,0] == [2,2,-3,-1]\n d_dx (-) [2,3,0,4,1] == [1,-3,4,-3]\n\u003c/pre\u003e",
          "module": "Music.Theory.Metric.Polansky_1996",
          "name": "d_dx",
          "package": "hmt",
          "signature": "Interval a n -\u003e [a] -\u003e [n]",
          "source": "src/Music-Theory-Metric-Polansky_1996.html#d_dx",
          "type": "function"
        },
        "index": {
          "description": "Integration with dx dx",
          "hierarchy": "Music Theory Metric Polansky_1996",
          "module": "Music.Theory.Metric.Polansky_1996",
          "name": "d_dx",
          "normalized": "Interval a b-\u003e[a]-\u003e[b]",
          "package": "hmt",
          "signature": "Interval a n-\u003e[a]-\u003e[n]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Metric-Polansky_1996.html#v:d_dx"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003emap\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eabs\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003ed_dx\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e d_dx_abs (-) [0,2,4,1,0] == [2,2,3,1]\n d_dx_abs (-) [2,3,0,4,1] == [1,3,4,3]\n\u003c/pre\u003e",
          "module": "Music.Theory.Metric.Polansky_1996",
          "name": "d_dx_abs",
          "package": "hmt",
          "signature": "Interval a n -\u003e [a] -\u003e [n]",
          "source": "src/Music-Theory-Metric-Polansky_1996.html#d_dx_abs",
          "type": "function"
        },
        "index": {
          "description": "map abs dx dx abs dx abs",
          "hierarchy": "Music Theory Metric Polansky_1996",
          "module": "Music.Theory.Metric.Polansky_1996",
          "name": "d_dx_abs",
          "normalized": "Interval a b-\u003e[a]-\u003e[b]",
          "package": "hmt",
          "signature": "Interval a n-\u003e[a]-\u003e[n]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Metric-Polansky_1996.html#v:d_dx_abs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003efromIntegral\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e-\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Music.Theory.Metric.Polansky_1996",
          "name": "dif_i",
          "package": "hmt",
          "signature": "a -\u003e a -\u003e b",
          "source": "src/Music-Theory-Metric-Polansky_1996.html#dif_i",
          "type": "function"
        },
        "index": {
          "description": "fromIntegral",
          "hierarchy": "Music Theory Metric Polansky_1996",
          "module": "Music.Theory.Metric.Polansky_1996",
          "name": "dif_i",
          "normalized": "a-\u003ea-\u003eb",
          "package": "hmt",
          "signature": "a-\u003ea-\u003eb",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Metric-Polansky_1996.html#v:dif_i"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003erealToFrac\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e-\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Music.Theory.Metric.Polansky_1996",
          "name": "dif_r",
          "package": "hmt",
          "signature": "a -\u003e a -\u003e b",
          "source": "src/Music-Theory-Metric-Polansky_1996.html#dif_r",
          "type": "function"
        },
        "index": {
          "description": "realToFrac",
          "hierarchy": "Music Theory Metric Polansky_1996",
          "module": "Music.Theory.Metric.Polansky_1996",
          "name": "dif_r",
          "normalized": "a-\u003ea-\u003eb",
          "package": "hmt",
          "signature": "a-\u003ea-\u003eb",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Metric-Polansky_1996.html#v:dif_r"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003ed_dx\u003c/a\u003e\u003c/code\u003e of \u003ccode\u003e\u003ca\u003eflip\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003ecompare\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e direction_interval [5,9,3,2] == [LT,GT,GT]\n direction_interval [2,5,6,6] == [LT,LT,EQ]\n\u003c/pre\u003e",
          "module": "Music.Theory.Metric.Polansky_1996",
          "name": "direction_interval",
          "package": "hmt",
          "signature": "[i] -\u003e [Ordering]",
          "source": "src/Music-Theory-Metric-Polansky_1996.html#direction_interval",
          "type": "function"
        },
        "index": {
          "description": "dx of flip compare direction interval LT GT GT direction interval LT LT EQ",
          "hierarchy": "Music Theory Metric Polansky_1996",
          "module": "Music.Theory.Metric.Polansky_1996",
          "name": "direction_interval",
          "normalized": "[a]-\u003e[Ordering]",
          "package": "hmt",
          "signature": "[i]-\u003e[Ordering]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Metric-Polansky_1996.html#v:direction_interval"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eHistogram of \u003cem\u003edirections\u003c/em\u003e of adjacent elements, p.312.\n\u003c/p\u003e\u003cpre\u003e direction_vector [5,9,3,2] == (1,0,2)\n direction_vector [2,5,6,6] == (2,1,0)\n\u003c/pre\u003e",
          "module": "Music.Theory.Metric.Polansky_1996",
          "name": "direction_vector",
          "package": "hmt",
          "signature": "[a] -\u003e (i, i, i)",
          "source": "src/Music-Theory-Metric-Polansky_1996.html#direction_vector",
          "type": "function"
        },
        "index": {
          "description": "Histogram of directions of adjacent elements p.312 direction vector direction vector",
          "hierarchy": "Music Theory Metric Polansky_1996",
          "module": "Music.Theory.Metric.Polansky_1996",
          "name": "direction_vector",
          "normalized": "[a]-\u003e(b,b,b)",
          "package": "hmt",
          "signature": "[a]-\u003e(i,i,i)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Metric-Polansky_1996.html#v:direction_vector"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTwo-dimensional euclidean metric, p.297.\n\u003c/p\u003e\u003cpre\u003e euclidean_metric_2 (-) (1,2) (3,5) == sqrt (4+9)\n\u003c/pre\u003e",
          "module": "Music.Theory.Metric.Polansky_1996",
          "name": "euclidean_metric_2",
          "package": "hmt",
          "signature": "Interval a n -\u003e (a, a) -\u003e (a, a) -\u003e n",
          "source": "src/Music-Theory-Metric-Polansky_1996.html#euclidean_metric_2",
          "type": "function"
        },
        "index": {
          "description": "Two-dimensional euclidean metric p.297 euclidean metric sqrt",
          "hierarchy": "Music Theory Metric Polansky_1996",
          "module": "Music.Theory.Metric.Polansky_1996",
          "name": "euclidean_metric_2",
          "normalized": "Interval a b-\u003e(a,a)-\u003e(a,a)-\u003eb",
          "package": "hmt",
          "signature": "Interval a n-\u003e(a,a)-\u003e(a,a)-\u003en",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Metric-Polansky_1996.html#v:euclidean_metric_2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003en\u003c/em\u003e-dimensional euclidean metric\n\u003c/p\u003e\u003cpre\u003e euclidean_metric_l (-) [1,2] [3,5] == sqrt (4+9)\n euclidean_metric_l (-) [1,2,3] [2,4,6] == sqrt (1+4+9)\n\u003c/pre\u003e",
          "module": "Music.Theory.Metric.Polansky_1996",
          "name": "euclidean_metric_l",
          "package": "hmt",
          "signature": "Interval b c -\u003e [b] -\u003e [b] -\u003e c",
          "source": "src/Music-Theory-Metric-Polansky_1996.html#euclidean_metric_l",
          "type": "function"
        },
        "index": {
          "description": "dimensional euclidean metric euclidean metric sqrt euclidean metric sqrt",
          "hierarchy": "Music Theory Metric Polansky_1996",
          "module": "Music.Theory.Metric.Polansky_1996",
          "name": "euclidean_metric_l",
          "normalized": "Interval a b-\u003e[a]-\u003e[a]-\u003eb",
          "package": "hmt",
          "signature": "Interval b c-\u003e[b]-\u003e[b]-\u003ec",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Metric-Polansky_1996.html#v:euclidean_metric_l"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003ef\u003c/em\u003e at indices \u003cem\u003ei\u003c/em\u003e and \u003cem\u003ei+1\u003c/em\u003e of \u003cem\u003ex\u003c/em\u003e.\n\u003c/p\u003e\u003cpre\u003e map (ix_dif (-) [0,1,3,6,10]) [0..3] == [-1,-2,-3,-4]\n\u003c/pre\u003e",
          "module": "Music.Theory.Metric.Polansky_1996",
          "name": "ix_dif",
          "package": "hmt",
          "signature": "Interval a t -\u003e Delta a t",
          "source": "src/Music-Theory-Metric-Polansky_1996.html#ix_dif",
          "type": "function"
        },
        "index": {
          "description": "at indices and of map ix dif",
          "hierarchy": "Music Theory Metric Polansky_1996",
          "module": "Music.Theory.Metric.Polansky_1996",
          "name": "ix_dif",
          "normalized": "Interval a b-\u003eDelta a b",
          "package": "hmt",
          "signature": "Interval a t-\u003eDelta a t",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Metric-Polansky_1996.html#v:ix_dif"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTwo-dimensional Minkowski metric, p.297\n\u003c/p\u003e\u003cpre\u003e minkowski_metric_2 (-) 1 (1,2) (3,5) == 5\n minkowski_metric_2 (-) 2 (1,2) (3,5) == sqrt (4+9)\n minkowski_metric_2 (-) 3 (1,2) (3,5) == cbrt (8+27)\n\u003c/pre\u003e",
          "module": "Music.Theory.Metric.Polansky_1996",
          "name": "minkowski_metric_2",
          "package": "hmt",
          "signature": "Interval t a -\u003e a -\u003e (t, t) -\u003e (t, t) -\u003e a",
          "source": "src/Music-Theory-Metric-Polansky_1996.html#minkowski_metric_2",
          "type": "function"
        },
        "index": {
          "description": "Two-dimensional Minkowski metric p.297 minkowski metric minkowski metric sqrt minkowski metric cbrt",
          "hierarchy": "Music Theory Metric Polansky_1996",
          "module": "Music.Theory.Metric.Polansky_1996",
          "name": "minkowski_metric_2",
          "normalized": "Interval a b-\u003eb-\u003e(a,a)-\u003e(a,a)-\u003eb",
          "package": "hmt",
          "signature": "Interval t a-\u003ea-\u003e(t,t)-\u003e(t,t)-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Metric-Polansky_1996.html#v:minkowski_metric_2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003en\u003c/em\u003e-dimensional Minkowski metric\n\u003c/p\u003e\u003cpre\u003e minkowski_metric_l (-) 2 [1,2,3] [2,4,6] == sqrt (1+4+9)\n minkowski_metric_l (-) 3 [1,2,3] [2,4,6] == cbrt (1+8+27)\n\u003c/pre\u003e",
          "module": "Music.Theory.Metric.Polansky_1996",
          "name": "minkowski_metric_l",
          "package": "hmt",
          "signature": "Interval t a -\u003e a -\u003e [t] -\u003e [t] -\u003e a",
          "source": "src/Music-Theory-Metric-Polansky_1996.html#minkowski_metric_l",
          "type": "function"
        },
        "index": {
          "description": "dimensional Minkowski metric minkowski metric sqrt minkowski metric cbrt",
          "hierarchy": "Music Theory Metric Polansky_1996",
          "module": "Music.Theory.Metric.Polansky_1996",
          "name": "minkowski_metric_l",
          "normalized": "Interval a b-\u003eb-\u003e[a]-\u003e[a]-\u003eb",
          "package": "hmt",
          "signature": "Interval t a-\u003ea-\u003e[t]-\u003e[t]-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Metric-Polansky_1996.html#v:minkowski_metric_l"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003en\u003c/em\u003e-th root\n\u003c/p\u003e\u003cpre\u003e map (nthrt 4) [1,16,81] == [1,2,3]\n\u003c/pre\u003e",
          "module": "Music.Theory.Metric.Polansky_1996",
          "name": "nthrt",
          "package": "hmt",
          "signature": "a -\u003e a -\u003e a",
          "source": "src/Music-Theory-Metric-Polansky_1996.html#nthrt",
          "type": "function"
        },
        "index": {
          "description": "th root map nthrt",
          "hierarchy": "Music Theory Metric Polansky_1996",
          "module": "Music.Theory.Metric.Polansky_1996",
          "name": "nthrt",
          "normalized": "a-\u003ea-\u003ea",
          "package": "hmt",
          "signature": "a-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Metric-Polansky_1996.html#v:nthrt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eOrdered combinatorial direction, p.314\n\u003c/p\u003e\u003cpre\u003e ocd [5,9,3,2] [2,5,6,6] == 5/6\n ocd [5,3,6,1,4] [3,6,1,4,2] == 4/5\n\u003c/pre\u003e",
          "module": "Music.Theory.Metric.Polansky_1996",
          "name": "ocd",
          "package": "hmt",
          "signature": "[a] -\u003e [a] -\u003e Ratio i",
          "source": "src/Music-Theory-Metric-Polansky_1996.html#ocd",
          "type": "function"
        },
        "index": {
          "description": "Ordered combinatorial direction p.314 ocd ocd",
          "hierarchy": "Music Theory Metric Polansky_1996",
          "module": "Music.Theory.Metric.Polansky_1996",
          "name": "ocd",
          "normalized": "[a]-\u003e[a]-\u003eRatio b",
          "package": "hmt",
          "signature": "[a]-\u003e[a]-\u003eRatio i",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Metric-Polansky_1996.html#v:ocd"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eOrdered combinatorial magnitude (OCM), p.323\n\u003c/p\u003e\u003cpre\u003e ocm (abs_dif (-)) [1,6,2,5,11] [3,15,13,2,9] == 5.2\n ocm (abs_dif (-)) [1,5,12,2,9,6] [7,6,4,9,8,1] == 3.6\n\u003c/pre\u003e",
          "module": "Music.Theory.Metric.Polansky_1996",
          "name": "ocm",
          "package": "hmt",
          "signature": "Interval a n -\u003e [a] -\u003e [a] -\u003e n",
          "source": "src/Music-Theory-Metric-Polansky_1996.html#ocm",
          "type": "function"
        },
        "index": {
          "description": "Ordered combinatorial magnitude OCM p.323 ocm abs dif ocm abs dif",
          "hierarchy": "Music Theory Metric Polansky_1996",
          "module": "Music.Theory.Metric.Polansky_1996",
          "name": "ocm",
          "normalized": "Interval a b-\u003e[a]-\u003e[a]-\u003eb",
          "package": "hmt",
          "signature": "Interval a n-\u003e[a]-\u003e[a]-\u003en",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Metric-Polansky_1996.html#v:ocm"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eOrdered combinatorial magnitude (OCM), p.323\n\u003c/p\u003e\u003cpre\u003e ocm_absolute_scaled (abs_dif (-)) [1,6,2,5,11] [3,15,13,2,9] == 0.4\n ocm_absolute_scaled (abs_dif (-)) [1,5,12,2,9,6] [7,6,4,9,8,1] == 54/(15*11)\n\u003c/pre\u003e",
          "module": "Music.Theory.Metric.Polansky_1996",
          "name": "ocm_absolute_scaled",
          "package": "hmt",
          "signature": "Interval a n -\u003e [a] -\u003e [a] -\u003e n",
          "source": "src/Music-Theory-Metric-Polansky_1996.html#ocm_absolute_scaled",
          "type": "function"
        },
        "index": {
          "description": "Ordered combinatorial magnitude OCM p.323 ocm absolute scaled abs dif ocm absolute scaled abs dif",
          "hierarchy": "Music Theory Metric Polansky_1996",
          "module": "Music.Theory.Metric.Polansky_1996",
          "name": "ocm_absolute_scaled",
          "normalized": "Interval a b-\u003e[a]-\u003e[a]-\u003eb",
          "package": "hmt",
          "signature": "Interval a n-\u003e[a]-\u003e[a]-\u003en",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Metric-Polansky_1996.html#v:ocm_absolute_scaled"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Metric.Polansky_1996",
          "name": "ocm_zcm",
          "package": "hmt",
          "signature": "Interval a n -\u003e [a] -\u003e [a] -\u003e (n, n, [n])",
          "source": "src/Music-Theory-Metric-Polansky_1996.html#ocm_zcm",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Metric Polansky_1996",
          "module": "Music.Theory.Metric.Polansky_1996",
          "name": "ocm_zcm",
          "normalized": "Interval a b-\u003e[a]-\u003e[a]-\u003e(b,b,[b])",
          "package": "hmt",
          "signature": "Interval a n-\u003e[a]-\u003e[a]-\u003e(n,n,[n])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Metric-Polansky_1996.html#v:ocm_zcm"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eOrdered linear direction, p.312\n\u003c/p\u003e\u003cpre\u003e direction_interval [5,3,6,1,4] == [GT,LT,GT,LT]\n direction_interval [3,6,1,4,2] == [LT,GT,LT,GT]\n old [5,3,6,1,4] [3,6,1,4,2] == 1\n\u003c/pre\u003e",
          "module": "Music.Theory.Metric.Polansky_1996",
          "name": "old",
          "package": "hmt",
          "signature": "[i] -\u003e [i] -\u003e Ratio a",
          "source": "src/Music-Theory-Metric-Polansky_1996.html#old",
          "type": "function"
        },
        "index": {
          "description": "Ordered linear direction p.312 direction interval GT LT GT LT direction interval LT GT LT GT old",
          "hierarchy": "Music Theory Metric Polansky_1996",
          "module": "Music.Theory.Metric.Polansky_1996",
          "name": "old",
          "normalized": "[a]-\u003e[a]-\u003eRatio b",
          "package": "hmt",
          "signature": "[i]-\u003e[i]-\u003eRatio a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Metric-Polansky_1996.html#v:old"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eOrdered linear magintude (generalised-interval form) p.305\n\u003c/p\u003e\u003cpre\u003e olm (abs_dif dif_r) (abs_ix_dif dif_r) (const 1) [1,5,12,2,9,6] [7,6,4,9,8,1] == 4.6\n olm (abs_dif dif_r) (abs_ix_dif dif_r) maximum [1,5,12,2,9,6] [7,6,4,9,8,1] == 0.46\n\u003c/pre\u003e",
          "module": "Music.Theory.Metric.Polansky_1996",
          "name": "olm",
          "package": "hmt",
          "signature": "Psi a -\u003e Delta n a -\u003e ([a] -\u003e a) -\u003e [n] -\u003e [n] -\u003e a",
          "source": "src/Music-Theory-Metric-Polansky_1996.html#olm",
          "type": "function"
        },
        "index": {
          "description": "Ordered linear magintude generalised-interval form p.305 olm abs dif dif abs ix dif dif const olm abs dif dif abs ix dif dif maximum",
          "hierarchy": "Music Theory Metric Polansky_1996",
          "module": "Music.Theory.Metric.Polansky_1996",
          "name": "olm",
          "normalized": "Psi a-\u003eDelta b a-\u003e([a]-\u003ea)-\u003e[b]-\u003e[b]-\u003ea",
          "package": "hmt",
          "signature": "Psi a-\u003eDelta n a-\u003e([a]-\u003ea)-\u003e[n]-\u003e[n]-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Metric-Polansky_1996.html#v:olm"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eOrdered linear magintude (general form) p.302\n\u003c/p\u003e\u003cpre\u003e olm_general (abs_dif (-)) [0,2,4,1,0] [2,3,0,4,1] == 1.25\n olm_general (abs_dif (-)) [1,5,12,2,9,6] [7,6,4,9,8,1] == 4.6\n\u003c/pre\u003e",
          "module": "Music.Theory.Metric.Polansky_1996",
          "name": "olm_general",
          "package": "hmt",
          "signature": "Interval a n -\u003e [a] -\u003e [a] -\u003e n",
          "source": "src/Music-Theory-Metric-Polansky_1996.html#olm_general",
          "type": "function"
        },
        "index": {
          "description": "Ordered linear magintude general form p.302 olm general abs dif olm general abs dif",
          "hierarchy": "Music Theory Metric Polansky_1996",
          "module": "Music.Theory.Metric.Polansky_1996",
          "name": "olm_general",
          "normalized": "Interval a b-\u003e[a]-\u003e[a]-\u003eb",
          "package": "hmt",
          "signature": "Interval a n-\u003e[a]-\u003e[a]-\u003en",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Metric-Polansky_1996.html#v:olm_general"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Metric.Polansky_1996",
          "name": "olm_no_delta",
          "package": "hmt",
          "signature": "[a] -\u003e [a] -\u003e n",
          "source": "src/Music-Theory-Metric-Polansky_1996.html#olm_no_delta",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Metric Polansky_1996",
          "module": "Music.Theory.Metric.Polansky_1996",
          "name": "olm_no_delta",
          "normalized": "[a]-\u003e[a]-\u003eb",
          "package": "hmt",
          "signature": "[a]-\u003e[a]-\u003en",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Metric-Polansky_1996.html#v:olm_no_delta"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eOrdered linear magnitude (no delta), p.300\n\u003c/p\u003e\u003cpre\u003e olm_no_delta' [0,2,4,1,0] [2,3,0,4,1] == 1.25\n\u003c/pre\u003e",
          "module": "Music.Theory.Metric.Polansky_1996",
          "name": "olm_no_delta'",
          "package": "hmt",
          "signature": "[a] -\u003e [a] -\u003e a",
          "source": "src/Music-Theory-Metric-Polansky_1996.html#olm_no_delta%27",
          "type": "function"
        },
        "index": {
          "description": "Ordered linear magnitude no delta p.300 olm no delta",
          "hierarchy": "Music Theory Metric Polansky_1996",
          "module": "Music.Theory.Metric.Polansky_1996",
          "name": "olm_no_delta'",
          "normalized": "[a]-\u003e[a]-\u003ea",
          "package": "hmt",
          "signature": "[a]-\u003e[a]-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Metric-Polansky_1996.html#v:olm_no_delta-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Metric.Polansky_1996",
          "name": "olm_no_delta_second_order",
          "package": "hmt",
          "signature": "[a] -\u003e [a] -\u003e a",
          "source": "src/Music-Theory-Metric-Polansky_1996.html#olm_no_delta_second_order",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Metric Polansky_1996",
          "module": "Music.Theory.Metric.Polansky_1996",
          "name": "olm_no_delta_second_order",
          "normalized": "[a]-\u003e[a]-\u003ea",
          "package": "hmt",
          "signature": "[a]-\u003e[a]-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Metric-Polansky_1996.html#v:olm_no_delta_second_order"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Metric.Polansky_1996",
          "name": "olm_no_delta_squared",
          "package": "hmt",
          "signature": "[a] -\u003e [a] -\u003e a",
          "source": "src/Music-Theory-Metric-Polansky_1996.html#olm_no_delta_squared",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Metric Polansky_1996",
          "module": "Music.Theory.Metric.Polansky_1996",
          "name": "olm_no_delta_squared",
          "normalized": "[a]-\u003e[a]-\u003ea",
          "package": "hmt",
          "signature": "[a]-\u003e[a]-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Metric-Polansky_1996.html#v:olm_no_delta_squared"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Metric.Polansky_1996",
          "name": "olm_no_delta_squared_second_order",
          "package": "hmt",
          "signature": "[a] -\u003e [a] -\u003e a",
          "source": "src/Music-Theory-Metric-Polansky_1996.html#olm_no_delta_squared_second_order",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Metric Polansky_1996",
          "module": "Music.Theory.Metric.Polansky_1996",
          "name": "olm_no_delta_squared_second_order",
          "normalized": "[a]-\u003e[a]-\u003ea",
          "package": "hmt",
          "signature": "[a]-\u003e[a]-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Metric-Polansky_1996.html#v:olm_no_delta_squared_second_order"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eHistogram of list of \u003ccode\u003e\u003ca\u003eOrdering\u003c/a\u003e\u003c/code\u003es.\n\u003c/p\u003e\u003cpre\u003e ord_hist [LT,GT,GT] == (1,0,2)\n\u003c/pre\u003e",
          "module": "Music.Theory.Metric.Polansky_1996",
          "name": "ord_hist",
          "package": "hmt",
          "signature": "[Ordering] -\u003e (t, t, t)",
          "source": "src/Music-Theory-Metric-Polansky_1996.html#ord_hist",
          "type": "function"
        },
        "index": {
          "description": "Histogram of list of Ordering ord hist LT GT GT",
          "hierarchy": "Music Theory Metric Polansky_1996",
          "module": "Music.Theory.Metric.Polansky_1996",
          "name": "ord_hist",
          "normalized": "[Ordering]-\u003e(a,a,a)",
          "package": "hmt",
          "signature": "[Ordering]-\u003e(t,t,t)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Metric-Polansky_1996.html#v:ord_hist"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Metric.Polansky_1996",
          "name": "second_order",
          "package": "hmt",
          "signature": "([n] -\u003e [n] -\u003e t) -\u003e [n] -\u003e [n] -\u003e t",
          "source": "src/Music-Theory-Metric-Polansky_1996.html#second_order",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Metric Polansky_1996",
          "module": "Music.Theory.Metric.Polansky_1996",
          "name": "second_order",
          "normalized": "([a]-\u003e[a]-\u003eb)-\u003e[a]-\u003e[a]-\u003eb",
          "package": "hmt",
          "signature": "([n]-\u003e[n]-\u003et)-\u003e[n]-\u003e[n]-\u003et",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Metric-Polansky_1996.html#v:second_order"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSecond order binomial coefficient, p.307\n\u003c/p\u003e\u003cpre\u003e map second_order_binonial_coefficient [2..10] == [1,3,6,10,15,21,28,36,45]\n\u003c/pre\u003e",
          "module": "Music.Theory.Metric.Polansky_1996",
          "name": "second_order_binonial_coefficient",
          "package": "hmt",
          "signature": "a -\u003e a",
          "source": "src/Music-Theory-Metric-Polansky_1996.html#second_order_binonial_coefficient",
          "type": "function"
        },
        "index": {
          "description": "Second order binomial coefficient p.307 map second order binonial coefficient",
          "hierarchy": "Music Theory Metric Polansky_1996",
          "module": "Music.Theory.Metric.Polansky_1996",
          "name": "second_order_binonial_coefficient",
          "normalized": "a-\u003ea",
          "package": "hmt",
          "signature": "a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Metric-Polansky_1996.html#v:second_order_binonial_coefficient"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSquare.\n\u003c/p\u003e",
          "module": "Music.Theory.Metric.Polansky_1996",
          "name": "sqr",
          "package": "hmt",
          "signature": "a -\u003e a",
          "source": "src/Music-Theory-Metric-Polansky_1996.html#sqr",
          "type": "function"
        },
        "index": {
          "description": "Square",
          "hierarchy": "Music Theory Metric Polansky_1996",
          "module": "Music.Theory.Metric.Polansky_1996",
          "name": "sqr",
          "normalized": "a-\u003ea",
          "package": "hmt",
          "signature": "a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Metric-Polansky_1996.html#v:sqr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003esqr\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eabs\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e \u003cem\u003ef\u003c/em\u003e.\n\u003c/p\u003e",
          "module": "Music.Theory.Metric.Polansky_1996",
          "name": "sqr_abs_dif",
          "package": "hmt",
          "signature": "Interval a n -\u003e a -\u003e a -\u003e n",
          "source": "src/Music-Theory-Metric-Polansky_1996.html#sqr_abs_dif",
          "type": "function"
        },
        "index": {
          "description": "sqr abs",
          "hierarchy": "Music Theory Metric Polansky_1996",
          "module": "Music.Theory.Metric.Polansky_1996",
          "name": "sqr_abs_dif",
          "normalized": "Interval a b-\u003ea-\u003ea-\u003eb",
          "package": "hmt",
          "signature": "Interval a n-\u003ea-\u003ea-\u003en",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Metric-Polansky_1996.html#v:sqr_abs_dif"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003esqr\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eabs_ix_dif\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e\u003cpre\u003e map (sqr_abs_ix_dif (-) [0,2,4,1,0]) [0..3] == [4,4,9,1]\n map (sqr_abs_ix_dif (-) [2,3,0,4,1]) [0..3] == [1,9,16,9]\n\u003c/pre\u003e",
          "module": "Music.Theory.Metric.Polansky_1996",
          "name": "sqr_abs_ix_dif",
          "package": "hmt",
          "signature": "Interval a n -\u003e Delta a n",
          "source": "src/Music-Theory-Metric-Polansky_1996.html#sqr_abs_ix_dif",
          "type": "function"
        },
        "index": {
          "description": "sqr abs ix dif map sqr abs ix dif map sqr abs ix dif",
          "hierarchy": "Music Theory Metric Polansky_1996",
          "module": "Music.Theory.Metric.Polansky_1996",
          "name": "sqr_abs_ix_dif",
          "normalized": "Interval a b-\u003eDelta a b",
          "package": "hmt",
          "signature": "Interval a n-\u003eDelta a n",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Metric-Polansky_1996.html#v:sqr_abs_ix_dif"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003esqr\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e \u003cem\u003ef\u003c/em\u003e.\n\u003c/p\u003e",
          "module": "Music.Theory.Metric.Polansky_1996",
          "name": "sqr_dif",
          "package": "hmt",
          "signature": "Interval a n -\u003e a -\u003e a -\u003e n",
          "source": "src/Music-Theory-Metric-Polansky_1996.html#sqr_dif",
          "type": "function"
        },
        "index": {
          "description": "sqr",
          "hierarchy": "Music Theory Metric Polansky_1996",
          "module": "Music.Theory.Metric.Polansky_1996",
          "name": "sqr_dif",
          "normalized": "Interval a b-\u003ea-\u003ea-\u003eb",
          "package": "hmt",
          "signature": "Interval a n-\u003ea-\u003ea-\u003en",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Metric-Polansky_1996.html#v:sqr_dif"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003esqrt\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eabs\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e \u003cem\u003ef\u003c/em\u003e.\n\u003c/p\u003e",
          "module": "Music.Theory.Metric.Polansky_1996",
          "name": "sqrt_abs_dif",
          "package": "hmt",
          "signature": "Interval a c -\u003e a -\u003e a -\u003e c",
          "source": "src/Music-Theory-Metric-Polansky_1996.html#sqrt_abs_dif",
          "type": "function"
        },
        "index": {
          "description": "sqrt abs",
          "hierarchy": "Music Theory Metric Polansky_1996",
          "module": "Music.Theory.Metric.Polansky_1996",
          "name": "sqrt_abs_dif",
          "normalized": "Interval a b-\u003ea-\u003ea-\u003eb",
          "package": "hmt",
          "signature": "Interval a c-\u003ea-\u003ea-\u003ec",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Metric-Polansky_1996.html#v:sqrt_abs_dif"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUnordered combinatorial direction, p.314\n\u003c/p\u003e\u003cpre\u003e ucd [5,9,3,2] [2,5,6,6] == 5/6\n ucd [5,3,6,1,4] [3,6,1,4,2] == 0\n ucd [5,3,7,6] [2,1,2,1] == 1/2\n ucd [2,1,2,1] [8,3,5,4] == 1/3\n ucd [5,3,7,6] [8,3,5,4] == 1/3\n\u003c/pre\u003e",
          "module": "Music.Theory.Metric.Polansky_1996",
          "name": "ucd",
          "package": "hmt",
          "signature": "[a] -\u003e [a] -\u003e Ratio n",
          "source": "src/Music-Theory-Metric-Polansky_1996.html#ucd",
          "type": "function"
        },
        "index": {
          "description": "Unordered combinatorial direction p.314 ucd ucd ucd ucd ucd",
          "hierarchy": "Music Theory Metric Polansky_1996",
          "module": "Music.Theory.Metric.Polansky_1996",
          "name": "ucd",
          "normalized": "[a]-\u003e[a]-\u003eRatio b",
          "package": "hmt",
          "signature": "[a]-\u003e[a]-\u003eRatio n",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Metric-Polansky_1996.html#v:ucd"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUnordered linear direction, p.311 (Fig. 5)\n\u003c/p\u003e\u003cpre\u003e uld [5,9,3,2] [2,5,6,6] == 2/3\n uld [5,3,6,1,4] [3,6,1,4,2] == 0\n\u003c/pre\u003e",
          "module": "Music.Theory.Metric.Polansky_1996",
          "name": "uld",
          "package": "hmt",
          "signature": "[a] -\u003e [a] -\u003e Ratio n",
          "source": "src/Music-Theory-Metric-Polansky_1996.html#uld",
          "type": "function"
        },
        "index": {
          "description": "Unordered linear direction p.311 Fig uld uld",
          "hierarchy": "Music Theory Metric Polansky_1996",
          "module": "Music.Theory.Metric.Polansky_1996",
          "name": "uld",
          "normalized": "[a]-\u003e[a]-\u003eRatio b",
          "package": "hmt",
          "signature": "[a]-\u003e[a]-\u003eRatio n",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Metric-Polansky_1996.html#v:uld"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUnordered linear magnitude (simplified), p.320-321\n\u003c/p\u003e\u003cpre\u003e let r = abs (sum [5,4,3,6] - sum [12,2,11,7]) / 4\n in ulm_simplified (abs_dif (-)) [1,6,2,5,11] [3,15,13,2,9] == r\n\u003c/pre\u003e\u003cpre\u003e ulm_simplified (abs_dif (-)) [1,5,12,2,9,6] [7,6,4,9,8,1] == 3\n\u003c/pre\u003e",
          "module": "Music.Theory.Metric.Polansky_1996",
          "name": "ulm_simplified",
          "package": "hmt",
          "signature": "Interval a n -\u003e [a] -\u003e [a] -\u003e n",
          "source": "src/Music-Theory-Metric-Polansky_1996.html#ulm_simplified",
          "type": "function"
        },
        "index": {
          "description": "Unordered linear magnitude simplified p.320-321 let abs sum sum in ulm simplified abs dif ulm simplified abs dif",
          "hierarchy": "Music Theory Metric Polansky_1996",
          "module": "Music.Theory.Metric.Polansky_1996",
          "name": "ulm_simplified",
          "normalized": "Interval a b-\u003e[a]-\u003e[a]-\u003eb",
          "package": "hmt",
          "signature": "Interval a n-\u003e[a]-\u003e[a]-\u003en",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Metric-Polansky_1996.html#v:ulm_simplified"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eList permutation functions.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Music.Theory.Permutations.List",
          "name": "List",
          "package": "hmt",
          "source": "src/Music-Theory-Permutations-List.html",
          "type": "module"
        },
        "index": {
          "description": "List permutation functions",
          "hierarchy": "Music Theory Permutations List",
          "module": "Music.Theory.Permutations.List",
          "name": "List",
          "package": "hmt",
          "partial": "List",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Permutations-List.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGenerate all distinct permutations of a multi-set.\n\u003c/p\u003e\u003cpre\u003e multiset_permutations [0,1,1] == [[0,1,1],[1,1,0],[1,0,1]]\n\u003c/pre\u003e",
          "module": "Music.Theory.Permutations.List",
          "name": "multiset_permutations",
          "package": "hmt",
          "signature": "[a] -\u003e [[a]]",
          "source": "src/Music-Theory-Permutations-List.html#multiset_permutations",
          "type": "function"
        },
        "index": {
          "description": "Generate all distinct permutations of multi-set multiset permutations",
          "hierarchy": "Music Theory Permutations List",
          "module": "Music.Theory.Permutations.List",
          "name": "multiset_permutations",
          "normalized": "[a]-\u003e[[a]]",
          "package": "hmt",
          "signature": "[a]-\u003e[[a]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Permutations-List.html#v:multiset_permutations"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGenerate all permutations.\n\u003c/p\u003e\u003cpre\u003e permutations [0,3] == [[0,3],[3,0]]\n length (permutations [1..5]) == P.n_permutations 5\n\u003c/pre\u003e",
          "module": "Music.Theory.Permutations.List",
          "name": "permutations",
          "package": "hmt",
          "signature": "[a] -\u003e [[a]]",
          "source": "src/Music-Theory-Permutations-List.html#permutations",
          "type": "function"
        },
        "index": {
          "description": "Generate all permutations permutations length permutations P.n permutations",
          "hierarchy": "Music Theory Permutations List",
          "module": "Music.Theory.Permutations.List",
          "name": "permutations",
          "normalized": "[a]-\u003e[[a]]",
          "package": "hmt",
          "signature": "[a]-\u003e[[a]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Permutations-List.html#v:permutations"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003ePermutation functions.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Music.Theory.Permutations",
          "name": "Permutations",
          "package": "hmt",
          "source": "src/Music-Theory-Permutations.html",
          "type": "module"
        },
        "index": {
          "description": "Permutation functions",
          "hierarchy": "Music Theory Permutations",
          "module": "Music.Theory.Permutations",
          "name": "Permutations",
          "package": "hmt",
          "partial": "Permutations",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Permutations.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eApply permutation \u003cem\u003ef\u003c/em\u003e to \u003cem\u003ep\u003c/em\u003e.\n\u003c/p\u003e\u003cpre\u003e let p = permutation [1..4] [4,3,2,1]\n in apply_permutation p [1..4] == [4,3,2,1]\n\u003c/pre\u003e",
          "module": "Music.Theory.Permutations",
          "name": "apply_permutation",
          "package": "hmt",
          "signature": "Permute -\u003e [a] -\u003e [a]",
          "source": "src/Music-Theory-Permutations.html#apply_permutation",
          "type": "function"
        },
        "index": {
          "description": "Apply permutation to let permutation in apply permutation",
          "hierarchy": "Music Theory Permutations",
          "module": "Music.Theory.Permutations",
          "name": "apply_permutation",
          "normalized": "Permute-\u003e[a]-\u003e[a]",
          "package": "hmt",
          "signature": "Permute-\u003e[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Permutations.html#v:apply_permutation"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eComposition of \u003ccode\u003e\u003ca\u003eapply_permutation\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003efrom_cycles\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e apply_permutation_c [[0,3],[1,2]] [1..4] == [4,3,2,1]\n apply_permutation_c [[0,2],[1],[3,4]] [1..5] == [3,2,1,5,4]\n apply_permutation_c [[0,1,4],[2,3]] [1..5] == [2,5,4,3,1]\n apply_permutation_c [[0,1,3],[2,4]] [1..5] == [2,4,5,1,3]\n\u003c/pre\u003e",
          "module": "Music.Theory.Permutations",
          "name": "apply_permutation_c",
          "package": "hmt",
          "signature": "[[Int]] -\u003e [a] -\u003e [a]",
          "source": "src/Music-Theory-Permutations.html#apply_permutation_c",
          "type": "function"
        },
        "index": {
          "description": "Composition of apply permutation and from cycles apply permutation apply permutation apply permutation apply permutation",
          "hierarchy": "Music Theory Permutations",
          "module": "Music.Theory.Permutations",
          "name": "apply_permutation_c",
          "normalized": "[[Int]]-\u003e[a]-\u003e[a]",
          "package": "hmt",
          "signature": "[[Int]]-\u003e[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Permutations.html#v:apply_permutation_c"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eComposition of \u003cem\u003eq\u003c/em\u003e then \u003cem\u003ep\u003c/em\u003e.\n\u003c/p\u003e\u003cpre\u003e let {p = from_cycles [[0,2],[1],[3,4]]\n     ;q = from_cycles [[0,1,4],[2,3]]\n     ;r = p `compose` q}\n in apply_permutation r [1,2,3,4,5] == [2,4,5,1,3]\n\u003c/pre\u003e",
          "module": "Music.Theory.Permutations",
          "name": "compose",
          "package": "hmt",
          "signature": "Permute -\u003e Permute -\u003e Permute",
          "source": "src/Music-Theory-Permutations.html#compose",
          "type": "function"
        },
        "index": {
          "description": "Composition of then let from cycles from cycles compose in apply permutation",
          "hierarchy": "Music Theory Permutations",
          "module": "Music.Theory.Permutations",
          "name": "compose",
          "normalized": "Permute-\u003ePermute-\u003ePermute",
          "package": "hmt",
          "signature": "Permute-\u003ePermute-\u003ePermute",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Permutations.html#v:compose"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFactorial function.\n\u003c/p\u003e\u003cpre\u003e (factorial 13,maxBound::Int)\n\u003c/pre\u003e",
          "module": "Music.Theory.Permutations",
          "name": "factorial",
          "package": "hmt",
          "signature": "a -\u003e a",
          "source": "src/Music-Theory-Permutations.html#factorial",
          "type": "function"
        },
        "index": {
          "description": "Factorial function factorial maxBound Int",
          "hierarchy": "Music Theory Permutations",
          "module": "Music.Theory.Permutations",
          "name": "factorial",
          "normalized": "a-\u003ea",
          "package": "hmt",
          "signature": "a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Permutations.html#v:factorial"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGenerate a permutation from the cycles \u003cem\u003ec\u003c/em\u003e.\n\u003c/p\u003e\u003cpre\u003e apply_permutation (from_cycles [[0,1,2,3]]) [1..4] == [2,3,4,1]\n\u003c/pre\u003e",
          "module": "Music.Theory.Permutations",
          "name": "from_cycles",
          "package": "hmt",
          "signature": "[[Int]] -\u003e Permute",
          "source": "src/Music-Theory-Permutations.html#from_cycles",
          "type": "function"
        },
        "index": {
          "description": "Generate permutation from the cycles apply permutation from cycles",
          "hierarchy": "Music Theory Permutations",
          "module": "Music.Theory.Permutations",
          "name": "from_cycles",
          "normalized": "[[Int]]-\u003ePermute",
          "package": "hmt",
          "signature": "[[Int]]-\u003ePermute",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Permutations.html#v:from_cycles"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMultiplication table of symmetric group \u003cem\u003en\u003c/em\u003e.\n\u003c/p\u003e\u003cpre\u003e unlines (map (unwords . map one_line_compact) (multiplication_table 3))\n\u003c/pre\u003e\u003cpre\u003e\n ==\u003e 123 132 213 231 312 321\n     132 123 312 321 213 231\n     213 231 123 132 321 312\n     231 213 321 312 123 132\n     312 321 132 123 231 213\n     321 312 231 213 132 123\n\u003c/pre\u003e",
          "module": "Music.Theory.Permutations",
          "name": "multiplication_table",
          "package": "hmt",
          "signature": "Int -\u003e [[Permute]]",
          "source": "src/Music-Theory-Permutations.html#multiplication_table",
          "type": "function"
        },
        "index": {
          "description": "Multiplication table of symmetric group unlines map unwords map one line compact multiplication table",
          "hierarchy": "Music Theory Permutations",
          "module": "Music.Theory.Permutations",
          "name": "multiplication_table",
          "normalized": "Int-\u003e[[Permute]]",
          "package": "hmt",
          "signature": "Int-\u003e[[Permute]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Permutations.html#v:multiplication_table"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eNumber of \u003cem\u003enk\u003c/em\u003e permutations where \u003cem\u003en\u003c/em\u003e \u003ccode\u003e\u003ca\u003e==\u003c/a\u003e\u003c/code\u003e \u003cem\u003ek\u003c/em\u003e.\n\u003c/p\u003e\u003cpre\u003e map n_permutations [1..8] == [1,2,6,24,120,720,5040,40320]\n n_permutations 16 `div` 1000000 == 20922789\n\u003c/pre\u003e",
          "module": "Music.Theory.Permutations",
          "name": "n_permutations",
          "package": "hmt",
          "signature": "a -\u003e a",
          "source": "src/Music-Theory-Permutations.html#n_permutations",
          "type": "function"
        },
        "index": {
          "description": "Number of nk permutations where map permutations permutations div",
          "hierarchy": "Music Theory Permutations",
          "module": "Music.Theory.Permutations",
          "name": "n_permutations",
          "normalized": "a-\u003ea",
          "package": "hmt",
          "signature": "a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Permutations.html#v:n_permutations"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eNumber of \u003cem\u003ek\u003c/em\u003e element permutations of a set of \u003cem\u003en\u003c/em\u003e elements.\n\u003c/p\u003e\u003cpre\u003e (nk_permutations 4 3,nk_permutations 13 3) == (24,1716)\n\u003c/pre\u003e",
          "module": "Music.Theory.Permutations",
          "name": "nk_permutations",
          "package": "hmt",
          "signature": "a -\u003e a -\u003e a",
          "source": "src/Music-Theory-Permutations.html#nk_permutations",
          "type": "function"
        },
        "index": {
          "description": "Number of element permutations of set of elements nk permutations nk permutations",
          "hierarchy": "Music Theory Permutations",
          "module": "Music.Theory.Permutations",
          "name": "nk_permutations",
          "normalized": "a-\u003ea-\u003ea",
          "package": "hmt",
          "signature": "a-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Permutations.html#v:nk_permutations"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTrue if the inverse of \u003cem\u003ep\u003c/em\u003e is \u003cem\u003ep\u003c/em\u003e.\n\u003c/p\u003e\u003cpre\u003e non_invertible (permutation [0,1,3] [1,0,3]) == True\n\u003c/pre\u003e\u003cpre\u003e let p = permutation [1..4] [4,3,2,1]\n in non_invertible p == True && P.cycles p == [[0,3],[1,2]]\n\u003c/pre\u003e",
          "module": "Music.Theory.Permutations",
          "name": "non_invertible",
          "package": "hmt",
          "signature": "Permute -\u003e Bool",
          "source": "src/Music-Theory-Permutations.html#non_invertible",
          "type": "function"
        },
        "index": {
          "description": "True if the inverse of is non invertible permutation True let permutation in non invertible True P.cycles",
          "hierarchy": "Music Theory Permutations",
          "module": "Music.Theory.Permutations",
          "name": "non_invertible",
          "normalized": "Permute-\u003eBool",
          "package": "hmt",
          "signature": "Permute-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Permutations.html#v:non_invertible"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eOne line notation of \u003cem\u003ep\u003c/em\u003e.\n\u003c/p\u003e\u003cpre\u003e one_line (permutation [0,1,3] [1,0,3]) == [2,1,3]\n\u003c/pre\u003e\u003cpre\u003e map one_line (permutations_n 3) == [[1,2,3],[1,3,2]\n                                    ,[2,1,3],[2,3,1]\n                                    ,[3,1,2],[3,2,1]]\n\u003c/pre\u003e",
          "module": "Music.Theory.Permutations",
          "name": "one_line",
          "package": "hmt",
          "signature": "Permute -\u003e [Int]",
          "source": "src/Music-Theory-Permutations.html#one_line",
          "type": "function"
        },
        "index": {
          "description": "One line notation of one line permutation map one line permutations",
          "hierarchy": "Music Theory Permutations",
          "module": "Music.Theory.Permutations",
          "name": "one_line",
          "normalized": "Permute-\u003e[Int]",
          "package": "hmt",
          "signature": "Permute-\u003e[Int]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Permutations.html#v:one_line"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eVariant of \u003ccode\u003e\u003ca\u003eone_line\u003c/a\u003e\u003c/code\u003e that produces a compact string.\n\u003c/p\u003e\u003cpre\u003e one_line_compact (permutation [0,1,3] [1,0,3]) == \"213\"\n\u003c/pre\u003e\u003cpre\u003e let p = permutations_n 3\n in unwords (map one_line_compact p) == \"123 132 213 231 312 321\"\n\u003c/pre\u003e",
          "module": "Music.Theory.Permutations",
          "name": "one_line_compact",
          "package": "hmt",
          "signature": "Permute -\u003e String",
          "source": "src/Music-Theory-Permutations.html#one_line_compact",
          "type": "function"
        },
        "index": {
          "description": "Variant of one line that produces compact string one line compact permutation let permutations in unwords map one line compact",
          "hierarchy": "Music Theory Permutations",
          "module": "Music.Theory.Permutations",
          "name": "one_line_compact",
          "normalized": "Permute-\u003eString",
          "package": "hmt",
          "signature": "Permute-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Permutations.html#v:one_line_compact"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGenerate the permutation from \u003cem\u003ep\u003c/em\u003e to \u003cem\u003eq\u003c/em\u003e, ie. the permutation\n that, when applied to \u003cem\u003ep\u003c/em\u003e, gives \u003cem\u003eq\u003c/em\u003e.\n\u003c/p\u003e\u003cpre\u003e apply_permutation (permutation [0,1,3] [1,0,3]) [0,1,3] == [1,0,3]\n\u003c/pre\u003e",
          "module": "Music.Theory.Permutations",
          "name": "permutation",
          "package": "hmt",
          "signature": "[a] -\u003e [a] -\u003e Permute",
          "source": "src/Music-Theory-Permutations.html#permutation",
          "type": "function"
        },
        "index": {
          "description": "Generate the permutation from to ie the permutation that when applied to gives apply permutation permutation",
          "hierarchy": "Music Theory Permutations",
          "module": "Music.Theory.Permutations",
          "name": "permutation",
          "normalized": "[a]-\u003e[a]-\u003ePermute",
          "package": "hmt",
          "signature": "[a]-\u003e[a]-\u003ePermute",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Permutations.html#v:permutation"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGenerate all permutations of size \u003cem\u003en\u003c/em\u003e.\n\u003c/p\u003e\u003cpre\u003e map one_line (permutations_n 3) == [[1,2,3],[1,3,2]\n                                    ,[2,1,3],[2,3,1]\n                                    ,[3,1,2],[3,2,1]]\n\u003c/pre\u003e",
          "module": "Music.Theory.Permutations",
          "name": "permutations_n",
          "package": "hmt",
          "signature": "Int -\u003e [Permute]",
          "source": "src/Music-Theory-Permutations.html#permutations_n",
          "type": "function"
        },
        "index": {
          "description": "Generate all permutations of size map one line permutations",
          "hierarchy": "Music Theory Permutations",
          "module": "Music.Theory.Permutations",
          "name": "permutations_n",
          "normalized": "Int-\u003e[Permute]",
          "package": "hmt",
          "signature": "Int-\u003e[Permute]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Permutations.html#v:permutations_n"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTwo line notation of \u003cem\u003ep\u003c/em\u003e.\n\u003c/p\u003e\u003cpre\u003e two_line (permutation [0,1,3] [1,0,3]) == ([1,2,3],[2,1,3])\n\u003c/pre\u003e",
          "module": "Music.Theory.Permutations",
          "name": "two_line",
          "package": "hmt",
          "signature": "Permute -\u003e ([Int], [Int])",
          "source": "src/Music-Theory-Permutations.html#two_line",
          "type": "function"
        },
        "index": {
          "description": "Two line notation of two line permutation",
          "hierarchy": "Music Theory Permutations",
          "module": "Music.Theory.Permutations",
          "name": "two_line",
          "normalized": "Permute-\u003e([Int],[Int])",
          "package": "hmt",
          "signature": "Permute-\u003e([Int],[Int])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Permutations.html#v:two_line"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eConstants names for \u003ccode\u003e\u003ca\u003ePitch\u003c/a\u003e\u003c/code\u003e values.  \u003cem\u003eeses\u003c/em\u003e indicates double\n flat, \u003cem\u003eeseh\u003c/em\u003e three quarter tone flat, \u003cem\u003ees\u003c/em\u003e flat, \u003cem\u003eeh\u003c/em\u003e quarter tone\n flat, \u003cem\u003eih\u003c/em\u003e quarter tone sharp, \u003cem\u003eis\u003c/em\u003e sharp, \u003cem\u003eisih\u003c/em\u003e three quarter\n tone sharp and \u003cem\u003eisis\u003c/em\u003e double sharp.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Music.Theory.Pitch.Name",
          "name": "Name",
          "package": "hmt",
          "source": "src/Music-Theory-Pitch-Name.html",
          "type": "module"
        },
        "index": {
          "description": "Constants names for Pitch values eses indicates double flat eseh three quarter tone flat es flat eh quarter tone flat ih quarter tone sharp is sharp isih three quarter tone sharp and isis double sharp",
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "Name",
          "package": "hmt",
          "partial": "Name",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "a0",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#a0",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "a0",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:a0"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "a1",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#a1",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "a1",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:a1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "a2",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#a2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "a2",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:a2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "a3",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#a3",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "a3",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:a3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "a4",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#a4",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "a4",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:a4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "a5",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#a5",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "a5",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:a5"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "a6",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#a6",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "a6",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:a6"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "a7",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#a7",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "a7",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:a7"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "aeh3",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#aeh3",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "aeh3",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:aeh3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "aeh4",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#aeh4",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "aeh4",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:aeh4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "aeh5",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#aeh5",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "aeh5",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:aeh5"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "aeh6",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#aeh6",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "aeh6",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:aeh6"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "aes1",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#aes1",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "aes1",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:aes1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "aes2",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#aes2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "aes2",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:aes2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "aes3",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#aes3",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "aes3",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:aes3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "aes4",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#aes4",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "aes4",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:aes4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "aes5",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#aes5",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "aes5",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:aes5"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "aes6",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#aes6",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "aes6",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:aes6"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "aes7",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#aes7",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "aes7",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:aes7"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "aeseh3",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#aeseh3",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "aeseh3",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:aeseh3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "aeseh4",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#aeseh4",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "aeseh4",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:aeseh4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "aeseh5",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#aeseh5",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "aeseh5",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:aeseh5"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "aeseh6",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#aeseh6",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "aeseh6",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:aeseh6"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "aeses3",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#aeses3",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "aeses3",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:aeses3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "aeses4",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#aeses4",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "aeses4",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:aeses4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "aeses5",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#aeses5",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "aeses5",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:aeses5"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "aih3",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#aih3",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "aih3",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:aih3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "aih4",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#aih4",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "aih4",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:aih4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "aih5",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#aih5",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "aih5",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:aih5"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "aih6",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#aih6",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "aih6",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:aih6"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "ais0",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#ais0",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "ais0",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:ais0"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "ais1",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#ais1",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "ais1",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:ais1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "ais2",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#ais2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "ais2",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:ais2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "ais3",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#ais3",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "ais3",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:ais3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "ais4",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#ais4",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "ais4",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:ais4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "ais5",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#ais5",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "ais5",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:ais5"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "ais6",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#ais6",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "ais6",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:ais6"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "ais7",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#ais7",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "ais7",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:ais7"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "aisih3",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#aisih3",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "aisih3",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:aisih3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "aisih4",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#aisih4",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "aisih4",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:aisih4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "aisih5",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#aisih5",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "aisih5",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:aisih5"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "aisih6",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#aisih6",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "aisih6",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:aisih6"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "aisis2",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#aisis2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "aisis2",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:aisis2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "aisis3",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#aisis3",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "aisis3",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:aisis3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "aisis4",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#aisis4",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "aisis4",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:aisis4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "aisis5",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#aisis5",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "aisis5",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:aisis5"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "b0",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#b0",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "b0",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:b0"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "b1",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#b1",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "b1",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:b1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "b2",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#b2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "b2",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:b2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "b3",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#b3",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "b3",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:b3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "b4",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#b4",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "b4",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:b4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "b5",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#b5",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "b5",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:b5"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "b6",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#b6",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "b6",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:b6"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "b7",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#b7",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "b7",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:b7"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "beh3",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#beh3",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "beh3",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:beh3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "beh4",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#beh4",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "beh4",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:beh4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "beh5",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#beh5",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "beh5",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:beh5"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "beh6",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#beh6",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "beh6",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:beh6"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "bes0",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#bes0",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "bes0",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:bes0"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "bes1",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#bes1",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "bes1",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:bes1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "bes2",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#bes2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "bes2",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:bes2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "bes3",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#bes3",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "bes3",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:bes3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "bes4",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#bes4",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "bes4",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:bes4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "bes5",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#bes5",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "bes5",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:bes5"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "bes6",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#bes6",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "bes6",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:bes6"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "bes7",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#bes7",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "bes7",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:bes7"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "beseh3",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#beseh3",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "beseh3",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:beseh3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "beseh4",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#beseh4",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "beseh4",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:beseh4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "beseh5",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#beseh5",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "beseh5",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:beseh5"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "beseh6",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#beseh6",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "beseh6",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:beseh6"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "beses3",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#beses3",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "beses3",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:beses3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "beses4",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#beses4",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "beses4",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:beses4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "beses5",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#beses5",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "beses5",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:beses5"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "bih3",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#bih3",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "bih3",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:bih3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "bih4",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#bih4",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "bih4",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:bih4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "bih5",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#bih5",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "bih5",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:bih5"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "bih6",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#bih6",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "bih6",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:bih6"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "bis0",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#bis0",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "bis0",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:bis0"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "bis1",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#bis1",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "bis1",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:bis1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "bis2",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#bis2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "bis2",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:bis2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "bis3",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#bis3",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "bis3",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:bis3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "bis4",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#bis4",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "bis4",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:bis4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "bis5",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#bis5",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "bis5",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:bis5"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "bis6",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#bis6",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "bis6",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:bis6"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "bis7",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#bis7",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "bis7",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:bis7"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "bisih3",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#bisih3",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "bisih3",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:bisih3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "bisih4",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#bisih4",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "bisih4",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:bisih4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "bisih5",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#bisih5",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "bisih5",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:bisih5"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "bisih6",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#bisih6",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "bisih6",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:bisih6"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "bisis2",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#bisis2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "bisis2",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:bisis2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "bisis3",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#bisis3",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "bisis3",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:bisis3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "bisis4",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#bisis4",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "bisis4",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:bisis4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "bisis5",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#bisis5",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "bisis5",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:bisis5"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "c1",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#c1",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "c1",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:c1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "c2",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#c2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "c2",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:c2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "c3",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#c3",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "c3",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:c3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "c4",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#c4",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "c4",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:c4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "c5",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#c5",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "c5",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:c5"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "c6",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#c6",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "c6",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:c6"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "c7",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#c7",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "c7",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:c7"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "c8",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#c8",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "c8",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:c8"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "ceh3",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#ceh3",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "ceh3",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:ceh3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "ceh4",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#ceh4",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "ceh4",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:ceh4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "ceh5",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#ceh5",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "ceh5",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:ceh5"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "ceh6",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#ceh6",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "ceh6",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:ceh6"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "ces1",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#ces1",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "ces1",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:ces1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "ces2",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#ces2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "ces2",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:ces2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "ces3",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#ces3",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "ces3",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:ces3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "ces4",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#ces4",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "ces4",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:ces4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "ces5",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#ces5",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "ces5",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:ces5"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "ces6",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#ces6",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "ces6",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:ces6"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "ces7",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#ces7",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "ces7",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:ces7"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "ceseh3",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#ceseh3",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "ceseh3",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:ceseh3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "ceseh4",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#ceseh4",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "ceseh4",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:ceseh4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "ceseh5",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#ceseh5",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "ceseh5",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:ceseh5"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "ceseh6",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#ceseh6",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "ceseh6",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:ceseh6"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "ceses3",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#ceses3",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "ceses3",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:ceses3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "ceses4",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#ceses4",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "ceses4",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:ceses4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "ceses5",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#ceses5",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "ceses5",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:ceses5"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "cih3",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#cih3",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "cih3",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:cih3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "cih4",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#cih4",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "cih4",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:cih4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "cih5",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#cih5",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "cih5",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:cih5"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "cih6",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#cih6",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "cih6",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:cih6"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "cis1",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#cis1",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "cis1",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:cis1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "cis2",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#cis2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "cis2",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:cis2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "cis3",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#cis3",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "cis3",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:cis3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "cis4",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#cis4",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "cis4",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:cis4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "cis5",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#cis5",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "cis5",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:cis5"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "cis6",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#cis6",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "cis6",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:cis6"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "cis7",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#cis7",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "cis7",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:cis7"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "cis8",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#cis8",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "cis8",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:cis8"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "cisih3",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#cisih3",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "cisih3",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:cisih3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "cisih4",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#cisih4",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "cisih4",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:cisih4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "cisih5",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#cisih5",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "cisih5",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:cisih5"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "cisih6",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#cisih6",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "cisih6",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:cisih6"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "cisis2",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#cisis2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "cisis2",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:cisis2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "cisis3",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#cisis3",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "cisis3",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:cisis3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "cisis4",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#cisis4",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "cisis4",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:cisis4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "cisis5",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#cisis5",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "cisis5",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:cisis5"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "d1",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#d1",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "d1",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:d1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "d2",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#d2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "d2",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:d2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "d3",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#d3",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "d3",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:d3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "d4",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#d4",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "d4",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:d4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "d5",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#d5",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "d5",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:d5"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "d6",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#d6",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "d6",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:d6"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "d7",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#d7",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "d7",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:d7"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "d8",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#d8",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "d8",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:d8"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "deh3",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#deh3",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "deh3",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:deh3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "deh4",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#deh4",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "deh4",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:deh4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "deh5",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#deh5",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "deh5",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:deh5"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "deh6",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#deh6",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "deh6",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:deh6"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "des1",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#des1",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "des1",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:des1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "des2",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#des2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "des2",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:des2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "des3",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#des3",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "des3",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:des3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "des4",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#des4",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "des4",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:des4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "des5",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#des5",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "des5",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:des5"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "des6",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#des6",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "des6",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:des6"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "des7",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#des7",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "des7",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:des7"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "deseh3",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#deseh3",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "deseh3",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:deseh3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "deseh4",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#deseh4",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "deseh4",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:deseh4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "deseh5",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#deseh5",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "deseh5",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:deseh5"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "deseh6",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#deseh6",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "deseh6",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:deseh6"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "deses3",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#deses3",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "deses3",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:deses3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "deses4",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#deses4",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "deses4",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:deses4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "deses5",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#deses5",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "deses5",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:deses5"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "dih3",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#dih3",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "dih3",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:dih3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "dih4",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#dih4",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "dih4",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:dih4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "dih5",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#dih5",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "dih5",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:dih5"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "dih6",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#dih6",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "dih6",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:dih6"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "dis1",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#dis1",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "dis1",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:dis1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "dis2",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#dis2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "dis2",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:dis2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "dis3",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#dis3",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "dis3",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:dis3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "dis4",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#dis4",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "dis4",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:dis4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "dis5",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#dis5",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "dis5",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:dis5"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "dis6",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#dis6",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "dis6",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:dis6"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "dis7",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#dis7",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "dis7",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:dis7"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "disih3",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#disih3",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "disih3",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:disih3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "disih4",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#disih4",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "disih4",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:disih4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "disih5",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#disih5",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "disih5",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:disih5"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "disih6",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#disih6",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "disih6",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:disih6"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "disis2",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#disis2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "disis2",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:disis2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "disis3",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#disis3",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "disis3",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:disis3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "disis4",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#disis4",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "disis4",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:disis4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "disis5",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#disis5",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "disis5",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:disis5"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "e1",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#e1",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "e1",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:e1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "e2",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#e2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "e2",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:e2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "e3",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#e3",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "e3",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:e3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "e4",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#e4",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "e4",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:e4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "e5",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#e5",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "e5",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:e5"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "e6",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#e6",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "e6",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:e6"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "e7",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#e7",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "e7",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:e7"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "eeh3",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#eeh3",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "eeh3",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:eeh3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "eeh4",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#eeh4",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "eeh4",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:eeh4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "eeh5",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#eeh5",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "eeh5",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:eeh5"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "eeh6",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#eeh6",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "eeh6",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:eeh6"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "ees1",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#ees1",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "ees1",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:ees1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "ees2",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#ees2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "ees2",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:ees2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "ees3",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#ees3",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "ees3",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:ees3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "ees4",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#ees4",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "ees4",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:ees4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "ees5",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#ees5",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "ees5",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:ees5"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "ees6",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#ees6",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "ees6",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:ees6"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "ees7",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#ees7",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "ees7",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:ees7"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "eeseh3",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#eeseh3",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "eeseh3",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:eeseh3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "eeseh4",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#eeseh4",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "eeseh4",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:eeseh4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "eeseh5",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#eeseh5",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "eeseh5",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:eeseh5"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "eeseh6",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#eeseh6",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "eeseh6",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:eeseh6"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "eeses3",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#eeses3",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "eeses3",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:eeses3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "eeses4",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#eeses4",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "eeses4",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:eeses4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "eeses5",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#eeses5",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "eeses5",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:eeses5"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "eih3",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#eih3",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "eih3",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:eih3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "eih4",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#eih4",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "eih4",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:eih4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "eih5",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#eih5",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "eih5",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:eih5"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "eih6",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#eih6",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "eih6",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:eih6"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "eis1",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#eis1",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "eis1",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:eis1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "eis2",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#eis2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "eis2",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:eis2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "eis3",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#eis3",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "eis3",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:eis3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "eis4",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#eis4",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "eis4",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:eis4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "eis5",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#eis5",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "eis5",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:eis5"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "eis6",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#eis6",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "eis6",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:eis6"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "eis7",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#eis7",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "eis7",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:eis7"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "eisih3",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#eisih3",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "eisih3",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:eisih3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "eisih4",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#eisih4",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "eisih4",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:eisih4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "eisih5",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#eisih5",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "eisih5",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:eisih5"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "eisih6",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#eisih6",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "eisih6",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:eisih6"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "eisis2",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#eisis2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "eisis2",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:eisis2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "eisis3",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#eisis3",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "eisis3",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:eisis3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "eisis4",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#eisis4",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "eisis4",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:eisis4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "eisis5",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#eisis5",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "eisis5",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:eisis5"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "f1",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#f1",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "f1",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:f1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "f2",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#f2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "f2",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:f2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "f3",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#f3",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "f3",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:f3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "f4",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#f4",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "f4",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:f4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "f5",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#f5",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "f5",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:f5"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "f6",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#f6",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "f6",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:f6"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "f7",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#f7",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "f7",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:f7"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "feh3",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#feh3",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "feh3",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:feh3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "feh4",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#feh4",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "feh4",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:feh4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "feh5",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#feh5",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "feh5",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:feh5"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "feh6",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#feh6",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "feh6",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:feh6"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "fes1",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#fes1",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "fes1",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:fes1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "fes2",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#fes2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "fes2",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:fes2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "fes3",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#fes3",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "fes3",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:fes3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "fes4",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#fes4",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "fes4",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:fes4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "fes5",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#fes5",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "fes5",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:fes5"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "fes6",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#fes6",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "fes6",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:fes6"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "fes7",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#fes7",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "fes7",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:fes7"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "feseh3",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#feseh3",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "feseh3",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:feseh3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "feseh4",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#feseh4",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "feseh4",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:feseh4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "feseh5",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#feseh5",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "feseh5",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:feseh5"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "feseh6",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#feseh6",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "feseh6",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:feseh6"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "feses3",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#feses3",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "feses3",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:feses3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "feses4",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#feses4",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "feses4",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:feses4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "feses5",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#feses5",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "feses5",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:feses5"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "fih3",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#fih3",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "fih3",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:fih3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "fih4",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#fih4",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "fih4",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:fih4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "fih5",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#fih5",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "fih5",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:fih5"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "fih6",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#fih6",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "fih6",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:fih6"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "fis1",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#fis1",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "fis1",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:fis1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "fis2",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#fis2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "fis2",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:fis2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "fis3",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#fis3",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "fis3",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:fis3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "fis4",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#fis4",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "fis4",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:fis4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "fis5",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#fis5",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "fis5",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:fis5"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "fis6",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#fis6",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "fis6",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:fis6"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "fis7",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#fis7",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "fis7",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:fis7"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "fisih3",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#fisih3",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "fisih3",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:fisih3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "fisih4",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#fisih4",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "fisih4",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:fisih4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "fisih5",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#fisih5",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "fisih5",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:fisih5"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "fisih6",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#fisih6",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "fisih6",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:fisih6"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "fisis2",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#fisis2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "fisis2",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:fisis2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "fisis3",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#fisis3",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "fisis3",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:fisis3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "fisis4",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#fisis4",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "fisis4",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:fisis4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "fisis5",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#fisis5",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "fisis5",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:fisis5"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "g1",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#g1",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "g1",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:g1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "g2",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#g2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "g2",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:g2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "g3",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#g3",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "g3",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:g3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "g4",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#g4",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "g4",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:g4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "g5",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#g5",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "g5",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:g5"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "g6",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#g6",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "g6",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:g6"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "g7",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#g7",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "g7",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:g7"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "geh3",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#geh3",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "geh3",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:geh3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "geh4",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#geh4",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "geh4",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:geh4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "geh5",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#geh5",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "geh5",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:geh5"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "geh6",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#geh6",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "geh6",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:geh6"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "ges1",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#ges1",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "ges1",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:ges1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "ges2",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#ges2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "ges2",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:ges2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "ges3",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#ges3",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "ges3",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:ges3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "ges4",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#ges4",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "ges4",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:ges4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "ges5",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#ges5",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "ges5",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:ges5"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "ges6",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#ges6",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "ges6",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:ges6"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "ges7",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#ges7",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "ges7",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:ges7"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "geseh3",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#geseh3",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "geseh3",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:geseh3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "geseh4",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#geseh4",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "geseh4",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:geseh4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "geseh5",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#geseh5",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "geseh5",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:geseh5"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "geseh6",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#geseh6",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "geseh6",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:geseh6"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "geses3",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#geses3",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "geses3",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:geses3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "geses4",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#geses4",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "geses4",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:geses4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "geses5",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#geses5",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "geses5",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:geses5"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "gih3",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#gih3",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "gih3",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:gih3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "gih4",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#gih4",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "gih4",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:gih4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "gih5",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#gih5",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "gih5",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:gih5"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "gih6",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#gih6",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "gih6",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:gih6"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "gis1",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#gis1",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "gis1",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:gis1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "gis2",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#gis2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "gis2",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:gis2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "gis3",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#gis3",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "gis3",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:gis3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "gis4",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#gis4",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "gis4",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:gis4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "gis5",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#gis5",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "gis5",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:gis5"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "gis6",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#gis6",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "gis6",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:gis6"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "gis7",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#gis7",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "gis7",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:gis7"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "gisih3",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#gisih3",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "gisih3",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:gisih3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "gisih4",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#gisih4",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "gisih4",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:gisih4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "gisih5",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#gisih5",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "gisih5",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:gisih5"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "gisih6",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#gisih6",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "gisih6",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:gisih6"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "gisis2",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#gisis2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "gisis2",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:gisis2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "gisis3",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#gisis3",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "gisis3",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:gisis3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "gisis4",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#gisis4",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "gisis4",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:gisis4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch.Name",
          "name": "gisis5",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch-Name.html#gisis5",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch Name",
          "module": "Music.Theory.Pitch.Name",
          "name": "gisis5",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Name.html#v:gisis5"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eSpelling for chromatic clusters.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Music.Theory.Pitch.Spelling.Cluster",
          "name": "Cluster",
          "package": "hmt",
          "source": "src/Music-Theory-Pitch-Spelling-Cluster.html",
          "type": "module"
        },
        "index": {
          "description": "Spelling for chromatic clusters",
          "hierarchy": "Music Theory Pitch Spelling Cluster",
          "module": "Music.Theory.Pitch.Spelling.Cluster",
          "name": "Cluster",
          "package": "hmt",
          "partial": "Cluster",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Spelling-Cluster.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eVariant of \u003ccode\u003e\u003ca\u003espell_cluster_c4\u003c/a\u003e\u003c/code\u003e that runs \u003ccode\u003e\u003ca\u003epitch_edit_octave\u003c/a\u003e\u003c/code\u003e.  An\n octave of \u003ccode\u003e4\u003c/code\u003e is the identitiy, \u003ccode\u003e3\u003c/code\u003e an octave below, \u003ccode\u003e5\u003c/code\u003e an octave\n above.\n\u003c/p\u003e\u003cpre\u003e fmap (map pitch_pp) (spell_cluster_c 3 [11,0]) == Just [\"B2\",\"C3\"]\n fmap (map pitch_pp) (spell_cluster_c 3 [10,11]) == Just [\"A&#9839;3\",\"B3\"]\n\u003c/pre\u003e",
          "module": "Music.Theory.Pitch.Spelling.Cluster",
          "name": "spell_cluster_c",
          "package": "hmt",
          "signature": "Octave -\u003e [PitchClass] -\u003e Maybe [Pitch]",
          "source": "src/Music-Theory-Pitch-Spelling-Cluster.html#spell_cluster_c",
          "type": "function"
        },
        "index": {
          "description": "Variant of spell cluster c4 that runs pitch edit octave An octave of is the identitiy an octave below an octave above fmap map pitch pp spell cluster Just B2 C3 fmap map pitch pp spell cluster Just B3",
          "hierarchy": "Music Theory Pitch Spelling Cluster",
          "module": "Music.Theory.Pitch.Spelling.Cluster",
          "name": "spell_cluster_c",
          "normalized": "Octave-\u003e[PitchClass]-\u003eMaybe[Pitch]",
          "package": "hmt",
          "signature": "Octave-\u003e[PitchClass]-\u003eMaybe[Pitch]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Spelling-Cluster.html#v:spell_cluster_c"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSpelling for chromatic clusters.  Sequence must be ascending.\n Pitch class \u003ccode\u003e0\u003c/code\u003e maps to \u003ccode\u003e\u003ca\u003ec4\u003c/a\u003e\u003c/code\u003e, if there is no \u003ccode\u003e0\u003c/code\u003e then all notes are\n in octave \u003ccode\u003e4\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e let f = fmap (map pitch_pp) . spell_cluster_c4\n in map f [[11,0],[11]] == [Just [\"B3\",\"C4\"],Just [\"B4\"]]\n\u003c/pre\u003e\u003cpre\u003e fmap (map pitch_pp) (spell_cluster_c4 [10,11]) == Just [\"A&#9839;4\",\"B4\"]\n\u003c/pre\u003e",
          "module": "Music.Theory.Pitch.Spelling.Cluster",
          "name": "spell_cluster_c4",
          "package": "hmt",
          "signature": "[PitchClass] -\u003e Maybe [Pitch]",
          "source": "src/Music-Theory-Pitch-Spelling-Cluster.html#spell_cluster_c4",
          "type": "function"
        },
        "index": {
          "description": "Spelling for chromatic clusters Sequence must be ascending Pitch class maps to c4 if there is no then all notes are in octave let fmap map pitch pp spell cluster c4 in map Just B3 C4 Just B4 fmap map pitch pp spell cluster c4 Just B4",
          "hierarchy": "Music Theory Pitch Spelling Cluster",
          "module": "Music.Theory.Pitch.Spelling.Cluster",
          "name": "spell_cluster_c4",
          "normalized": "[PitchClass]-\u003eMaybe[Pitch]",
          "package": "hmt",
          "signature": "[PitchClass]-\u003eMaybe[Pitch]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Spelling-Cluster.html#v:spell_cluster_c4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSpelling table for chromatic clusters.\n\u003c/p\u003e\u003cpre\u003e let f (p,q) = p == sort (map (snd . pitch_to_octpc) q)\n in all f spell_cluster_c4_table == True\n\u003c/pre\u003e",
          "module": "Music.Theory.Pitch.Spelling.Cluster",
          "name": "spell_cluster_c4_table",
          "package": "hmt",
          "signature": "[([PitchClass], [Pitch])]",
          "source": "src/Music-Theory-Pitch-Spelling-Cluster.html#spell_cluster_c4_table",
          "type": "function"
        },
        "index": {
          "description": "Spelling table for chromatic clusters let sort map snd pitch to octpc in all spell cluster c4 table True",
          "hierarchy": "Music Theory Pitch Spelling Cluster",
          "module": "Music.Theory.Pitch.Spelling.Cluster",
          "name": "spell_cluster_c4_table",
          "normalized": "[([PitchClass],[Pitch])]",
          "package": "hmt",
          "signature": "[([PitchClass],[Pitch])]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Spelling-Cluster.html#v:spell_cluster_c4_table"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eVariant of \u003ccode\u003e\u003ca\u003espell_cluster_c4\u003c/a\u003e\u003c/code\u003e that runs \u003ccode\u003e\u003ca\u003epitch_edit_octave\u003c/a\u003e\u003c/code\u003e so\n that the left-most note is in the octave given by \u003cem\u003ef\u003c/em\u003e.\n\u003c/p\u003e\u003cpre\u003e import Data.Maybe\n\u003c/pre\u003e\u003cpre\u003e let {f n = if n \u003e= 11 then 3 else 4\n     ;g = map pitch_pp .fromJust . spell_cluster_f f\n     ;r = [[\"B3\",\"C4\"],[\"B3\"],[\"C4\"],[\"A&#9839;4\",\"B4\"]]}\n in map g [[11,0],[11],[0],[10,11]] == r\n\u003c/pre\u003e",
          "module": "Music.Theory.Pitch.Spelling.Cluster",
          "name": "spell_cluster_f",
          "package": "hmt",
          "signature": "(PitchClass -\u003e Octave) -\u003e [PitchClass] -\u003e Maybe [Pitch]",
          "source": "src/Music-Theory-Pitch-Spelling-Cluster.html#spell_cluster_f",
          "type": "function"
        },
        "index": {
          "description": "Variant of spell cluster c4 that runs pitch edit octave so that the left-most note is in the octave given by import Data.Maybe let if then else map pitch pp fromJust spell cluster B3 C4 B3 C4 B4 in map",
          "hierarchy": "Music Theory Pitch Spelling Cluster",
          "module": "Music.Theory.Pitch.Spelling.Cluster",
          "name": "spell_cluster_f",
          "normalized": "(PitchClass-\u003eOctave)-\u003e[PitchClass]-\u003eMaybe[Pitch]",
          "package": "hmt",
          "signature": "(PitchClass-\u003eOctave)-\u003e[PitchClass]-\u003eMaybe[Pitch]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Spelling-Cluster.html#v:spell_cluster_f"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eVariant of \u003ccode\u003e\u003ca\u003espell_cluster_c4\u003c/a\u003e\u003c/code\u003e that runs \u003ccode\u003e\u003ca\u003epitch_edit_octave\u003c/a\u003e\u003c/code\u003e so\n that the left-most note is in octave \u003cem\u003eo\u003c/em\u003e.\n\u003c/p\u003e\u003cpre\u003e fmap (map pitch_pp) (spell_cluster_left 3 [11,0]) == Just [\"B3\",\"C4\"]\n fmap (map pitch_pp) (spell_cluster_left 3 [10,11]) == Just [\"A&#9839;3\",\"B3\"]\n\u003c/pre\u003e",
          "module": "Music.Theory.Pitch.Spelling.Cluster",
          "name": "spell_cluster_left",
          "package": "hmt",
          "signature": "Octave -\u003e [PitchClass] -\u003e Maybe [Pitch]",
          "source": "src/Music-Theory-Pitch-Spelling-Cluster.html#spell_cluster_left",
          "type": "function"
        },
        "index": {
          "description": "Variant of spell cluster c4 that runs pitch edit octave so that the left-most note is in octave fmap map pitch pp spell cluster left Just B3 C4 fmap map pitch pp spell cluster left Just B3",
          "hierarchy": "Music Theory Pitch Spelling Cluster",
          "module": "Music.Theory.Pitch.Spelling.Cluster",
          "name": "spell_cluster_left",
          "normalized": "Octave-\u003e[PitchClass]-\u003eMaybe[Pitch]",
          "package": "hmt",
          "signature": "Octave-\u003e[PitchClass]-\u003eMaybe[Pitch]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Spelling-Cluster.html#v:spell_cluster_left"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eSpelling rules for common music notation.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Music.Theory.Pitch.Spelling",
          "name": "Spelling",
          "package": "hmt",
          "source": "src/Music-Theory-Pitch-Spelling.html",
          "type": "module"
        },
        "index": {
          "description": "Spelling rules for common music notation",
          "hierarchy": "Music Theory Pitch Spelling",
          "module": "Music.Theory.Pitch.Spelling",
          "name": "Spelling",
          "package": "hmt",
          "partial": "Spelling",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Spelling.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eVariant of \u003ccode\u003e\u003ca\u003eSpelling\u003c/a\u003e\u003c/code\u003e for incomplete functions.\n\u003c/p\u003e",
          "module": "Music.Theory.Pitch.Spelling",
          "name": "Spelling_M",
          "package": "hmt",
          "source": "src/Music-Theory-Pitch-Spelling.html#Spelling_M",
          "type": "type"
        },
        "index": {
          "description": "Variant of Spelling for incomplete functions",
          "hierarchy": "Music Theory Pitch Spelling",
          "module": "Music.Theory.Pitch.Spelling",
          "name": "Spelling_M",
          "package": "hmt",
          "partial": "Spelling",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Spelling.html#t:Spelling_M"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUse always flat (&#9837;) spelling.\n\u003c/p\u003e\u003cpre\u003e  map pc_spell_flat [6,8] == [(G,Flat),(A,Flat)]\n  Data.List.nub (map (snd . pc_spell_flat) [1,3,6,8,10]) == [Flat]\n\u003c/pre\u003e",
          "module": "Music.Theory.Pitch.Spelling",
          "name": "pc_spell_flat",
          "package": "hmt",
          "signature": "Spelling i",
          "source": "src/Music-Theory-Pitch-Spelling.html#pc_spell_flat",
          "type": "function"
        },
        "index": {
          "description": "Use always flat spelling map pc spell flat Flat Flat Data.List.nub map snd pc spell flat Flat",
          "hierarchy": "Music Theory Pitch Spelling",
          "module": "Music.Theory.Pitch.Spelling",
          "name": "pc_spell_flat",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Spelling.html#v:pc_spell_flat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUse spelling from simplest key-signature.  Note that this is\n ambiguous for \u003ccode\u003e8\u003c/code\u003e, which could be either G Sharp (&#9839;) in \u003cem\u003eA Major\u003c/em\u003e\n or A Flat (&#9837;) in \u003cem\u003eE Flat (&#9837;) Major\u003c/em\u003e.\n\u003c/p\u003e\u003cpre\u003e map pc_spell_ks [6,8] == [(F,Sharp),(A,Flat)]\n\u003c/pre\u003e",
          "module": "Music.Theory.Pitch.Spelling",
          "name": "pc_spell_ks",
          "package": "hmt",
          "signature": "Spelling i",
          "source": "src/Music-Theory-Pitch-Spelling.html#pc_spell_ks",
          "type": "function"
        },
        "index": {
          "description": "Use spelling from simplest key-signature Note that this is ambiguous for which could be either Sharp in Major or Flat in Flat Major map pc spell ks Sharp Flat",
          "hierarchy": "Music Theory Pitch Spelling",
          "module": "Music.Theory.Pitch.Spelling",
          "name": "pc_spell_ks",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Spelling.html#v:pc_spell_ks"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eErroring variant of \u003ccode\u003e\u003ca\u003epc_spell_natural_m\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e map pc_spell_natural [0,5,7] == [(C,Natural),(F,Natural),(G,Natural)]\n\u003c/pre\u003e",
          "module": "Music.Theory.Pitch.Spelling",
          "name": "pc_spell_natural",
          "package": "hmt",
          "signature": "Spelling i",
          "source": "src/Music-Theory-Pitch-Spelling.html#pc_spell_natural",
          "type": "function"
        },
        "index": {
          "description": "Erroring variant of pc spell natural map pc spell natural Natural Natural Natural",
          "hierarchy": "Music Theory Pitch Spelling",
          "module": "Music.Theory.Pitch.Spelling",
          "name": "pc_spell_natural",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Spelling.html#v:pc_spell_natural"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSpelling for natural (&#9838;) notes only.\n\u003c/p\u003e\u003cpre\u003e map pc_spell_natural_m [0,1] == [Just (C,Natural),Nothing]\n\u003c/pre\u003e",
          "module": "Music.Theory.Pitch.Spelling",
          "name": "pc_spell_natural_m",
          "package": "hmt",
          "signature": "Spelling_M i",
          "source": "src/Music-Theory-Pitch-Spelling.html#pc_spell_natural_m",
          "type": "function"
        },
        "index": {
          "description": "Spelling for natural notes only map pc spell natural Just Natural Nothing",
          "hierarchy": "Music Theory Pitch Spelling",
          "module": "Music.Theory.Pitch.Spelling",
          "name": "pc_spell_natural_m",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Spelling.html#v:pc_spell_natural_m"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUse always sharp (&#9839;) spelling.\n\u003c/p\u003e\u003cpre\u003e map pc_spell_sharp [6,8] == [(F,Sharp),(G,Sharp)]\n Data.List.nub (map (snd . pc_spell_sharp) [1,3,6,8,10]) == [Sharp]\n octpc_to_pitch pc_spell_sharp (4,6) == Pitch F Sharp 4\n\u003c/pre\u003e",
          "module": "Music.Theory.Pitch.Spelling",
          "name": "pc_spell_sharp",
          "package": "hmt",
          "signature": "Spelling i",
          "source": "src/Music-Theory-Pitch-Spelling.html#pc_spell_sharp",
          "type": "function"
        },
        "index": {
          "description": "Use always sharp spelling map pc spell sharp Sharp Sharp Data.List.nub map snd pc spell sharp Sharp octpc to pitch pc spell sharp Pitch Sharp",
          "hierarchy": "Music Theory Pitch Spelling",
          "module": "Music.Theory.Pitch.Spelling",
          "name": "pc_spell_sharp",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch-Spelling.html#v:pc_spell_sharp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eCommon music notation pitch values.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Music.Theory.Pitch",
          "name": "Pitch",
          "package": "hmt",
          "source": "src/Music-Theory-Pitch.html",
          "type": "module"
        },
        "index": {
          "description": "Common music notation pitch values",
          "hierarchy": "Music Theory Pitch",
          "module": "Music.Theory.Pitch",
          "name": "Pitch",
          "package": "hmt",
          "partial": "Pitch",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEnumeration of common music notation note alterations.\n\u003c/p\u003e",
          "module": "Music.Theory.Pitch",
          "name": "Alteration_T",
          "package": "hmt",
          "source": "src/Music-Theory-Pitch.html#Alteration_T",
          "type": "data"
        },
        "index": {
          "description": "Enumeration of common music notation note alterations",
          "hierarchy": "Music Theory Pitch",
          "module": "Music.Theory.Pitch",
          "name": "Alteration_T",
          "package": "hmt",
          "partial": "Alteration",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch.html#t:Alteration_T"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEnumeration of common music notation note names (\u003ccode\u003eC\u003c/code\u003e to \u003ccode\u003eB\u003c/code\u003e).\n\u003c/p\u003e",
          "module": "Music.Theory.Pitch",
          "name": "Note_T",
          "package": "hmt",
          "source": "src/Music-Theory-Pitch.html#Note_T",
          "type": "data"
        },
        "index": {
          "description": "Enumeration of common music notation note names to",
          "hierarchy": "Music Theory Pitch",
          "module": "Music.Theory.Pitch",
          "name": "Note_T",
          "package": "hmt",
          "partial": "Note",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch.html#t:Note_T"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch",
          "name": "OctPC",
          "package": "hmt",
          "source": "src/Music-Theory-Pitch.html#OctPC",
          "type": "type"
        },
        "index": {
          "hierarchy": "Music Theory Pitch",
          "module": "Music.Theory.Pitch",
          "name": "OctPC",
          "package": "hmt",
          "partial": "Oct PC",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch.html#t:OctPC"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eOctaves are \u003ccode\u003e\u003ca\u003eInteger\u003c/a\u003e\u003c/code\u003es, the octave of middle C is \u003ccode\u003e4\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Music.Theory.Pitch",
          "name": "Octave",
          "package": "hmt",
          "source": "src/Music-Theory-Pitch.html#Octave",
          "type": "type"
        },
        "index": {
          "description": "Octaves are Integer the octave of middle is",
          "hierarchy": "Music Theory Pitch",
          "module": "Music.Theory.Pitch",
          "name": "Octave",
          "package": "hmt",
          "partial": "Octave",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch.html#t:Octave"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eOctave\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003ePitchClass\u003c/a\u003e\u003c/code\u003e duple.\n\u003c/p\u003e",
          "module": "Music.Theory.Pitch",
          "name": "Octave_PitchClass",
          "package": "hmt",
          "source": "src/Music-Theory-Pitch.html#Octave_PitchClass",
          "type": "type"
        },
        "index": {
          "description": "Octave and PitchClass duple",
          "hierarchy": "Music Theory Pitch",
          "module": "Music.Theory.Pitch",
          "name": "Octave_PitchClass",
          "package": "hmt",
          "partial": "Octave Pitch Class",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch.html#t:Octave_PitchClass"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCommon music notation pitch value.\n\u003c/p\u003e",
          "module": "Music.Theory.Pitch",
          "name": "Pitch",
          "package": "hmt",
          "source": "src/Music-Theory-Pitch.html#Pitch",
          "type": "data"
        },
        "index": {
          "description": "Common music notation pitch value",
          "hierarchy": "Music Theory Pitch",
          "module": "Music.Theory.Pitch",
          "name": "Pitch",
          "package": "hmt",
          "partial": "Pitch",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch.html#t:Pitch"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePitch classes are modulo twelve integers.\n\u003c/p\u003e",
          "module": "Music.Theory.Pitch",
          "name": "PitchClass",
          "package": "hmt",
          "source": "src/Music-Theory-Pitch.html#PitchClass",
          "type": "type"
        },
        "index": {
          "description": "Pitch classes are modulo twelve integers",
          "hierarchy": "Music Theory Pitch",
          "module": "Music.Theory.Pitch",
          "name": "PitchClass",
          "package": "hmt",
          "partial": "Pitch Class",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch.html#t:PitchClass"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFunction to spell a \u003ccode\u003e\u003ca\u003ePitchClass\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Music.Theory.Pitch",
          "name": "Spelling",
          "package": "hmt",
          "source": "src/Music-Theory-Pitch.html#Spelling",
          "type": "type"
        },
        "index": {
          "description": "Function to spell PitchClass",
          "hierarchy": "Music Theory Pitch",
          "module": "Music.Theory.Pitch",
          "name": "Spelling",
          "package": "hmt",
          "partial": "Spelling",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch.html#t:Spelling"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch",
          "name": "A",
          "package": "hmt",
          "signature": "A",
          "source": "src/Music-Theory-Pitch.html#Note_T",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch",
          "module": "Music.Theory.Pitch",
          "name": "A",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch.html#v:A"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch",
          "name": "B",
          "package": "hmt",
          "signature": "B",
          "source": "src/Music-Theory-Pitch.html#Note_T",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch",
          "module": "Music.Theory.Pitch",
          "name": "B",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch.html#v:B"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch",
          "name": "C",
          "package": "hmt",
          "signature": "C",
          "source": "src/Music-Theory-Pitch.html#Note_T",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch",
          "module": "Music.Theory.Pitch",
          "name": "C",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch.html#v:C"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch",
          "name": "D",
          "package": "hmt",
          "signature": "D",
          "source": "src/Music-Theory-Pitch.html#Note_T",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch",
          "module": "Music.Theory.Pitch",
          "name": "D",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch.html#v:D"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch",
          "name": "DoubleFlat",
          "package": "hmt",
          "signature": "DoubleFlat",
          "source": "src/Music-Theory-Pitch.html#Alteration_T",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch",
          "module": "Music.Theory.Pitch",
          "name": "DoubleFlat",
          "package": "hmt",
          "partial": "Double Flat",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch.html#v:DoubleFlat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch",
          "name": "DoubleSharp",
          "package": "hmt",
          "signature": "DoubleSharp",
          "source": "src/Music-Theory-Pitch.html#Alteration_T",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch",
          "module": "Music.Theory.Pitch",
          "name": "DoubleSharp",
          "package": "hmt",
          "partial": "Double Sharp",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch.html#v:DoubleSharp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch",
          "name": "E",
          "package": "hmt",
          "signature": "E",
          "source": "src/Music-Theory-Pitch.html#Note_T",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch",
          "module": "Music.Theory.Pitch",
          "name": "E",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch.html#v:E"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch",
          "name": "F",
          "package": "hmt",
          "signature": "F",
          "source": "src/Music-Theory-Pitch.html#Note_T",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch",
          "module": "Music.Theory.Pitch",
          "name": "F",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch.html#v:F"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch",
          "name": "Flat",
          "package": "hmt",
          "signature": "Flat",
          "source": "src/Music-Theory-Pitch.html#Alteration_T",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch",
          "module": "Music.Theory.Pitch",
          "name": "Flat",
          "package": "hmt",
          "partial": "Flat",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch.html#v:Flat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch",
          "name": "G",
          "package": "hmt",
          "signature": "G",
          "source": "src/Music-Theory-Pitch.html#Note_T",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch",
          "module": "Music.Theory.Pitch",
          "name": "G",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch.html#v:G"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch",
          "name": "Natural",
          "package": "hmt",
          "signature": "Natural",
          "source": "src/Music-Theory-Pitch.html#Alteration_T",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch",
          "module": "Music.Theory.Pitch",
          "name": "Natural",
          "package": "hmt",
          "partial": "Natural",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch.html#v:Natural"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch",
          "name": "Pitch",
          "package": "hmt",
          "signature": "Pitch",
          "source": "src/Music-Theory-Pitch.html#Pitch",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch",
          "module": "Music.Theory.Pitch",
          "name": "Pitch",
          "package": "hmt",
          "partial": "Pitch",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch.html#v:Pitch"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch",
          "name": "QuarterToneFlat",
          "package": "hmt",
          "signature": "QuarterToneFlat",
          "source": "src/Music-Theory-Pitch.html#Alteration_T",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch",
          "module": "Music.Theory.Pitch",
          "name": "QuarterToneFlat",
          "package": "hmt",
          "partial": "Quarter Tone Flat",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch.html#v:QuarterToneFlat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch",
          "name": "QuarterToneSharp",
          "package": "hmt",
          "signature": "QuarterToneSharp",
          "source": "src/Music-Theory-Pitch.html#Alteration_T",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch",
          "module": "Music.Theory.Pitch",
          "name": "QuarterToneSharp",
          "package": "hmt",
          "partial": "Quarter Tone Sharp",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch.html#v:QuarterToneSharp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch",
          "name": "Sharp",
          "package": "hmt",
          "signature": "Sharp",
          "source": "src/Music-Theory-Pitch.html#Alteration_T",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch",
          "module": "Music.Theory.Pitch",
          "name": "Sharp",
          "package": "hmt",
          "partial": "Sharp",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch.html#v:Sharp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch",
          "name": "ThreeQuarterToneFlat",
          "package": "hmt",
          "signature": "ThreeQuarterToneFlat",
          "source": "src/Music-Theory-Pitch.html#Alteration_T",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch",
          "module": "Music.Theory.Pitch",
          "name": "ThreeQuarterToneFlat",
          "package": "hmt",
          "partial": "Three Quarter Tone Flat",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch.html#v:ThreeQuarterToneFlat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch",
          "name": "ThreeQuarterToneSharp",
          "package": "hmt",
          "signature": "ThreeQuarterToneSharp",
          "source": "src/Music-Theory-Pitch.html#Alteration_T",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch",
          "module": "Music.Theory.Pitch",
          "name": "ThreeQuarterToneSharp",
          "package": "hmt",
          "partial": "Three Quarter Tone Sharp",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch.html#v:ThreeQuarterToneSharp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch",
          "name": "alteration",
          "package": "hmt",
          "signature": "Alteration_T",
          "source": "src/Music-Theory-Pitch.html#Pitch",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch",
          "module": "Music.Theory.Pitch",
          "name": "alteration",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch.html#v:alteration"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSimplify \u003ccode\u003e\u003ca\u003eAlteration_T\u003c/a\u003e\u003c/code\u003e to standard 12ET by deleting quarter tones.\n\u003c/p\u003e\u003cpre\u003e Data.List.nub (map alteration_clear_quarter_tone [minBound..maxBound])\n\u003c/pre\u003e",
          "module": "Music.Theory.Pitch",
          "name": "alteration_clear_quarter_tone",
          "package": "hmt",
          "signature": "Alteration_T -\u003e Alteration_T",
          "source": "src/Music-Theory-Pitch.html#alteration_clear_quarter_tone",
          "type": "function"
        },
        "index": {
          "description": "Simplify Alteration to standard ET by deleting quarter tones Data.List.nub map alteration clear quarter tone minBound..maxBound",
          "hierarchy": "Music Theory Pitch",
          "module": "Music.Theory.Pitch",
          "name": "alteration_clear_quarter_tone",
          "normalized": "Alteration_T-\u003eAlteration_T",
          "package": "hmt",
          "signature": "Alteration_T-\u003eAlteration_T",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch.html#v:alteration_clear_quarter_tone"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEdit \u003ccode\u003e\u003ca\u003eAlteration_T\u003c/a\u003e\u003c/code\u003e by a quarter tone where possible, \u003ccode\u003e-0.5\u003c/code\u003e\n lowers, \u003ccode\u003e0\u003c/code\u003e retains, \u003ccode\u003e0.5\u003c/code\u003e raises.\n\u003c/p\u003e",
          "module": "Music.Theory.Pitch",
          "name": "alteration_edit_quarter_tone",
          "package": "hmt",
          "signature": "n -\u003e Alteration_T -\u003e Maybe Alteration_T",
          "source": "src/Music-Theory-Pitch.html#alteration_edit_quarter_tone",
          "type": "function"
        },
        "index": {
          "description": "Edit Alteration by quarter tone where possible lowers retains raises",
          "hierarchy": "Music Theory Pitch",
          "module": "Music.Theory.Pitch",
          "name": "alteration_edit_quarter_tone",
          "normalized": "a-\u003eAlteration_T-\u003eMaybe Alteration_T",
          "package": "hmt",
          "signature": "n-\u003eAlteration_T-\u003eMaybe Alteration_T",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch.html#v:alteration_edit_quarter_tone"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLower \u003ccode\u003e\u003ca\u003eAlteration_T\u003c/a\u003e\u003c/code\u003e by a quarter tone where possible.\n\u003c/p\u003e\u003cpre\u003e alteration_lower_quarter_tone Sharp == Just QuarterToneSharp\n alteration_lower_quarter_tone DoubleFlat == Nothing\n\u003c/pre\u003e",
          "module": "Music.Theory.Pitch",
          "name": "alteration_lower_quarter_tone",
          "package": "hmt",
          "signature": "Alteration_T -\u003e Maybe Alteration_T",
          "source": "src/Music-Theory-Pitch.html#alteration_lower_quarter_tone",
          "type": "function"
        },
        "index": {
          "description": "Lower Alteration by quarter tone where possible alteration lower quarter tone Sharp Just QuarterToneSharp alteration lower quarter tone DoubleFlat Nothing",
          "hierarchy": "Music Theory Pitch",
          "module": "Music.Theory.Pitch",
          "name": "alteration_lower_quarter_tone",
          "normalized": "Alteration_T-\u003eMaybe Alteration_T",
          "package": "hmt",
          "signature": "Alteration_T-\u003eMaybe Alteration_T",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch.html#v:alteration_lower_quarter_tone"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003eLilypond\u003c/code\u003e ASCII spellings for alterations.\n\u003c/p\u003e\u003cpre\u003e map alteration_ly_name [Flat .. Sharp] == [\"es\",\"eh\",\"\",\"ih\",\"is\"]\n\u003c/pre\u003e",
          "module": "Music.Theory.Pitch",
          "name": "alteration_ly_name",
          "package": "hmt",
          "signature": "Alteration_T -\u003e String",
          "source": "src/Music-Theory-Pitch.html#alteration_ly_name",
          "type": "function"
        },
        "index": {
          "description": "The Lilypond ASCII spellings for alterations map alteration ly name Flat Sharp es eh ih is",
          "hierarchy": "Music Theory Pitch",
          "module": "Music.Theory.Pitch",
          "name": "alteration_ly_name",
          "normalized": "Alteration_T-\u003eString",
          "package": "hmt",
          "signature": "Alteration_T-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch.html#v:alteration_ly_name"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRaise \u003ccode\u003e\u003ca\u003eAlteration_T\u003c/a\u003e\u003c/code\u003e by a quarter tone where possible.\n\u003c/p\u003e\u003cpre\u003e alteration_raise_quarter_tone Flat == Just QuarterToneFlat\n alteration_raise_quarter_tone DoubleSharp == Nothing\n\u003c/pre\u003e",
          "module": "Music.Theory.Pitch",
          "name": "alteration_raise_quarter_tone",
          "package": "hmt",
          "signature": "Alteration_T -\u003e Maybe Alteration_T",
          "source": "src/Music-Theory-Pitch.html#alteration_raise_quarter_tone",
          "type": "function"
        },
        "index": {
          "description": "Raise Alteration by quarter tone where possible alteration raise quarter tone Flat Just QuarterToneFlat alteration raise quarter tone DoubleSharp Nothing",
          "hierarchy": "Music Theory Pitch",
          "module": "Music.Theory.Pitch",
          "name": "alteration_raise_quarter_tone",
          "normalized": "Alteration_T-\u003eMaybe Alteration_T",
          "package": "hmt",
          "signature": "Alteration_T-\u003eMaybe Alteration_T",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch.html#v:alteration_raise_quarter_tone"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUnicode has entries for \u003cem\u003eMusical Symbols\u003c/em\u003e in the range \u003ccode\u003eU+1D100\u003c/code\u003e\n through \u003ccode\u003eU+1D1FF\u003c/code\u003e.  The \u003ccode\u003e3/4\u003c/code\u003e symbols are non-standard, here they\n correspond to \u003ccode\u003eMUSICAL SYMBOL FLAT DOWN\u003c/code\u003e and \u003ccode\u003eMUSICAL SYMBOL SHARP\n UP\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e map alteration_symbol [minBound .. maxBound] == \"&#119083;&#119085;&#9837;&#119091;&#9838;&#119090;&#9839;&#119088;&#119082;\"\n\u003c/pre\u003e",
          "module": "Music.Theory.Pitch",
          "name": "alteration_symbol",
          "package": "hmt",
          "signature": "Alteration_T -\u003e Char",
          "source": "src/Music-Theory-Pitch.html#alteration_symbol",
          "type": "function"
        },
        "index": {
          "description": "Unicode has entries for Musical Symbols in the range D100 through D1FF The symbols are non-standard here they correspond to MUSICAL SYMBOL FLAT DOWN and MUSICAL SYMBOL SHARP UP map alteration symbol minBound maxBound",
          "hierarchy": "Music Theory Pitch",
          "module": "Music.Theory.Pitch",
          "name": "alteration_symbol",
          "normalized": "Alteration_T-\u003eChar",
          "package": "hmt",
          "signature": "Alteration_T-\u003eChar",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch.html#v:alteration_symbol"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTransform \u003ccode\u003e\u003ca\u003eAlteration_T\u003c/a\u003e\u003c/code\u003e to semitone alteration.  Returns\n \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e for non-semitone alterations.\n\u003c/p\u003e\u003cpre\u003e map alteration_to_diff [Flat,QuarterToneSharp] == [Just (-1),Nothing]\n\u003c/pre\u003e",
          "module": "Music.Theory.Pitch",
          "name": "alteration_to_diff",
          "package": "hmt",
          "signature": "Alteration_T -\u003e Maybe i",
          "source": "src/Music-Theory-Pitch.html#alteration_to_diff",
          "type": "function"
        },
        "index": {
          "description": "Transform Alteration to semitone alteration Returns Nothing for non-semitone alterations map alteration to diff Flat QuarterToneSharp Just Nothing",
          "hierarchy": "Music Theory Pitch",
          "module": "Music.Theory.Pitch",
          "name": "alteration_to_diff",
          "normalized": "Alteration_T-\u003eMaybe a",
          "package": "hmt",
          "signature": "Alteration_T-\u003eMaybe i",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch.html#v:alteration_to_diff"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTransform \u003ccode\u003e\u003ca\u003eAlteration_T\u003c/a\u003e\u003c/code\u003e to semitone alteration.\n\u003c/p\u003e\u003cpre\u003e map alteration_to_diff_err [Flat,Sharp] == [-1,1]\n\u003c/pre\u003e",
          "module": "Music.Theory.Pitch",
          "name": "alteration_to_diff_err",
          "package": "hmt",
          "signature": "Alteration_T -\u003e i",
          "source": "src/Music-Theory-Pitch.html#alteration_to_diff_err",
          "type": "function"
        },
        "index": {
          "description": "Transform Alteration to semitone alteration map alteration to diff err Flat Sharp",
          "hierarchy": "Music Theory Pitch",
          "module": "Music.Theory.Pitch",
          "name": "alteration_to_diff_err",
          "normalized": "Alteration_T-\u003ea",
          "package": "hmt",
          "signature": "Alteration_T-\u003ei",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch.html#v:alteration_to_diff_err"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTransform \u003ccode\u003e\u003ca\u003eAlteration_T\u003c/a\u003e\u003c/code\u003e to fractional semitone alteration,\n ie. allow quarter tones.\n\u003c/p\u003e\u003cpre\u003e alteration_to_fdiff QuarterToneSharp == 0.5\n\u003c/pre\u003e",
          "module": "Music.Theory.Pitch",
          "name": "alteration_to_fdiff",
          "package": "hmt",
          "signature": "Alteration_T -\u003e n",
          "source": "src/Music-Theory-Pitch.html#alteration_to_fdiff",
          "type": "function"
        },
        "index": {
          "description": "Transform Alteration to fractional semitone alteration ie allow quarter tones alteration to fdiff QuarterToneSharp",
          "hierarchy": "Music Theory Pitch",
          "module": "Music.Theory.Pitch",
          "name": "alteration_to_fdiff",
          "normalized": "Alteration_T-\u003ea",
          "package": "hmt",
          "signature": "Alteration_T-\u003en",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch.html#v:alteration_to_fdiff"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFrequency (cycles per second) to fractional \u003cem\u003emidi\u003c/em\u003e note number.\n\u003c/p\u003e\u003cpre\u003e cps_to_fmidi 440 == 69\n cps_to_fmidi (fmidi_to_cps 60.25) == 60.25\n\u003c/pre\u003e",
          "module": "Music.Theory.Pitch",
          "name": "cps_to_fmidi",
          "package": "hmt",
          "signature": "a -\u003e a",
          "source": "src/Music-Theory-Pitch.html#cps_to_fmidi",
          "type": "function"
        },
        "index": {
          "description": "Frequency cycles per second to fractional midi note number cps to fmidi cps to fmidi fmidi to cps",
          "hierarchy": "Music Theory Pitch",
          "module": "Music.Theory.Pitch",
          "name": "cps_to_fmidi",
          "normalized": "a-\u003ea",
          "package": "hmt",
          "signature": "a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch.html#v:cps_to_fmidi"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFrequency (cycles per second) to \u003cem\u003emidi\u003c/em\u003e note number.\n\u003c/p\u003e\u003cpre\u003e map cps_to_midi [261.6,440] == [60,69]\n\u003c/pre\u003e",
          "module": "Music.Theory.Pitch",
          "name": "cps_to_midi",
          "package": "hmt",
          "signature": "f -\u003e i",
          "source": "src/Music-Theory-Pitch.html#cps_to_midi",
          "type": "function"
        },
        "index": {
          "description": "Frequency cycles per second to midi note number map cps to midi",
          "hierarchy": "Music Theory Pitch",
          "module": "Music.Theory.Pitch",
          "name": "cps_to_midi",
          "normalized": "a-\u003eb",
          "package": "hmt",
          "signature": "f-\u003ei",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch.html#v:cps_to_midi"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTransform fractional semitone alteration to \u003ccode\u003e\u003ca\u003eAlteration_T\u003c/a\u003e\u003c/code\u003e,\n ie. allow quarter tones.\n\u003c/p\u003e\u003cpre\u003e map fdiff_to_alteration [-0.5,0.5] == [Just QuarterToneFlat\n                                       ,Just QuarterToneSharp]\n\u003c/pre\u003e",
          "module": "Music.Theory.Pitch",
          "name": "fdiff_to_alteration",
          "package": "hmt",
          "signature": "n -\u003e Maybe Alteration_T",
          "source": "src/Music-Theory-Pitch.html#fdiff_to_alteration",
          "type": "function"
        },
        "index": {
          "description": "Transform fractional semitone alteration to Alteration ie allow quarter tones map fdiff to alteration Just QuarterToneFlat Just QuarterToneSharp",
          "hierarchy": "Music Theory Pitch",
          "module": "Music.Theory.Pitch",
          "name": "fdiff_to_alteration",
          "normalized": "a-\u003eMaybe Alteration_T",
          "package": "hmt",
          "signature": "n-\u003eMaybe Alteration_T",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch.html#v:fdiff_to_alteration"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFractional \u003cem\u003emidi\u003c/em\u003e note number to cycles per second.\n\u003c/p\u003e\u003cpre\u003e map fmidi_to_cps [69,69.1] == [440.0,442.5488940698553]\n\u003c/pre\u003e",
          "module": "Music.Theory.Pitch",
          "name": "fmidi_to_cps",
          "package": "hmt",
          "signature": "a -\u003e a",
          "source": "src/Music-Theory-Pitch.html#fmidi_to_cps",
          "type": "function"
        },
        "index": {
          "description": "Fractional midi note number to cycles per second map fmidi to cps",
          "hierarchy": "Music Theory Pitch",
          "module": "Music.Theory.Pitch",
          "name": "fmidi_to_cps",
          "normalized": "a-\u003ea",
          "package": "hmt",
          "signature": "a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch.html#v:fmidi_to_cps"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFractional midi note number to \u003ccode\u003e\u003ca\u003ePitch\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e import Music.Theory.Pitch.Spelling\n pitch_pp (fmidi_to_pitch pc_spell_ks 65.5) == \"F&#119090;4\"\n pitch_pp (fmidi_to_pitch pc_spell_ks 66.5) == \"F&#119088;4\"\n pitch_pp (fmidi_to_pitch pc_spell_ks 67.5) == \"A&#119085;4\"\n pitch_pp (fmidi_to_pitch pc_spell_ks 69.5) == \"B&#119085;4\"\n\u003c/pre\u003e",
          "module": "Music.Theory.Pitch",
          "name": "fmidi_to_pitch",
          "package": "hmt",
          "signature": "Spelling Integer -\u003e n -\u003e Pitch",
          "source": "src/Music-Theory-Pitch.html#fmidi_to_pitch",
          "type": "function"
        },
        "index": {
          "description": "Fractional midi note number to Pitch import Music.Theory.Pitch.Spelling pitch pp fmidi to pitch pc spell ks pitch pp fmidi to pitch pc spell ks pitch pp fmidi to pitch pc spell ks pitch pp fmidi to pitch pc spell ks",
          "hierarchy": "Music Theory Pitch",
          "module": "Music.Theory.Pitch",
          "name": "fmidi_to_pitch",
          "normalized": "Spelling Integer-\u003ea-\u003ePitch",
          "package": "hmt",
          "signature": "Spelling Integer-\u003en-\u003ePitch",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch.html#v:fmidi_to_pitch"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eMidi\u003c/em\u003e note number to cycles per second.\n\u003c/p\u003e\u003cpre\u003e map midi_to_cps [60,69] == [261.6255653005986,440.0]\n\u003c/pre\u003e",
          "module": "Music.Theory.Pitch",
          "name": "midi_to_cps",
          "package": "hmt",
          "signature": "i -\u003e f",
          "source": "src/Music-Theory-Pitch.html#midi_to_cps",
          "type": "function"
        },
        "index": {
          "description": "Midi note number to cycles per second map midi to cps",
          "hierarchy": "Music Theory Pitch",
          "module": "Music.Theory.Pitch",
          "name": "midi_to_cps",
          "normalized": "a-\u003eb",
          "package": "hmt",
          "signature": "i-\u003ef",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch.html#v:midi_to_cps"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInverse of \u003ccode\u003e\u003ca\u003eoctpc_to_midi\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e midi_to_octpc 69 == (4,9)\n\u003c/pre\u003e",
          "module": "Music.Theory.Pitch",
          "name": "midi_to_octpc",
          "package": "hmt",
          "signature": "i -\u003e Octave_PitchClass i",
          "source": "src/Music-Theory-Pitch.html#midi_to_octpc",
          "type": "function"
        },
        "index": {
          "description": "Inverse of octpc to midi midi to octpc",
          "hierarchy": "Music Theory Pitch",
          "module": "Music.Theory.Pitch",
          "name": "midi_to_octpc",
          "normalized": "a-\u003eOctave_PitchClass a",
          "package": "hmt",
          "signature": "i-\u003eOctave_PitchClass i",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch.html#v:midi_to_octpc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMidi note number to \u003ccode\u003e\u003ca\u003ePitch\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e let r = [\"C4\",\"E&#9837;4\",\"F&#9839;4\"]\n in map (pitch_pp . midi_to_pitch pc_spell_ks) [60,63,66] == r\n\u003c/pre\u003e",
          "module": "Music.Theory.Pitch",
          "name": "midi_to_pitch",
          "package": "hmt",
          "signature": "Spelling i -\u003e i -\u003e Pitch",
          "source": "src/Music-Theory-Pitch.html#midi_to_pitch",
          "type": "function"
        },
        "index": {
          "description": "Midi note number to Pitch let C4 in map pitch pp midi to pitch pc spell ks",
          "hierarchy": "Music Theory Pitch",
          "module": "Music.Theory.Pitch",
          "name": "midi_to_pitch",
          "normalized": "Spelling a-\u003ea-\u003ePitch",
          "package": "hmt",
          "signature": "Spelling i-\u003ei-\u003ePitch",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch.html#v:midi_to_pitch"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch",
          "name": "note",
          "package": "hmt",
          "signature": "Note_T",
          "source": "src/Music-Theory-Pitch.html#Pitch",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch",
          "module": "Music.Theory.Pitch",
          "name": "note",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch.html#v:note"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eModal transposition of \u003ccode\u003e\u003ca\u003eNote_T\u003c/a\u003e\u003c/code\u003e value.\n\u003c/p\u003e\u003cpre\u003e note_t_transpose C 2 == E\n\u003c/pre\u003e",
          "module": "Music.Theory.Pitch",
          "name": "note_t_transpose",
          "package": "hmt",
          "signature": "Note_T -\u003e Int -\u003e Note_T",
          "source": "src/Music-Theory-Pitch.html#note_t_transpose",
          "type": "function"
        },
        "index": {
          "description": "Modal transposition of Note value note transpose",
          "hierarchy": "Music Theory Pitch",
          "module": "Music.Theory.Pitch",
          "name": "note_t_transpose",
          "normalized": "Note_T-\u003eInt-\u003eNote_T",
          "package": "hmt",
          "signature": "Note_T-\u003eInt-\u003eNote_T",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch.html#v:note_t_transpose"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTransform \u003ccode\u003e\u003ca\u003eNote_T\u003c/a\u003e\u003c/code\u003e to pitch-class number.\n\u003c/p\u003e\u003cpre\u003e map note_to_pc [C,E,G] == [0,4,7]\n\u003c/pre\u003e",
          "module": "Music.Theory.Pitch",
          "name": "note_to_pc",
          "package": "hmt",
          "signature": "Note_T -\u003e i",
          "source": "src/Music-Theory-Pitch.html#note_to_pc",
          "type": "function"
        },
        "index": {
          "description": "Transform Note to pitch-class number map note to pc",
          "hierarchy": "Music Theory Pitch",
          "module": "Music.Theory.Pitch",
          "name": "note_to_pc",
          "normalized": "Note_T-\u003ea",
          "package": "hmt",
          "signature": "Note_T-\u003ei",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch.html#v:note_to_pc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Pitch",
          "name": "octave",
          "package": "hmt",
          "signature": "Octave",
          "source": "src/Music-Theory-Pitch.html#Pitch",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Pitch",
          "module": "Music.Theory.Pitch",
          "name": "octave",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch.html#v:octave"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eNormalise \u003ccode\u003e\u003ca\u003eOctPC\u003c/a\u003e\u003c/code\u003e value, ie. ensure \u003ccode\u003e\u003ca\u003ePitchClass\u003c/a\u003e\u003c/code\u003e is in (0,11).\n\u003c/p\u003e\u003cpre\u003e octpc_nrm (4,16) == (5,4)\n\u003c/pre\u003e",
          "module": "Music.Theory.Pitch",
          "name": "octpc_nrm",
          "package": "hmt",
          "signature": "Octave_PitchClass i -\u003e Octave_PitchClass i",
          "source": "src/Music-Theory-Pitch.html#octpc_nrm",
          "type": "function"
        },
        "index": {
          "description": "Normalise OctPC value ie ensure PitchClass is in octpc nrm",
          "hierarchy": "Music Theory Pitch",
          "module": "Music.Theory.Pitch",
          "name": "octpc_nrm",
          "normalized": "Octave_PitchClass a-\u003eOctave_PitchClass a",
          "package": "hmt",
          "signature": "Octave_PitchClass i-\u003eOctave_PitchClass i",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch.html#v:octpc_nrm"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003emidi_to_cps\u003c/a\u003e\u003c/code\u003e of \u003ccode\u003e\u003ca\u003eoctpc_to_midi\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e octpc_to_cps (4,9) == 440\n\u003c/pre\u003e",
          "module": "Music.Theory.Pitch",
          "name": "octpc_to_cps",
          "package": "hmt",
          "signature": "Octave_PitchClass i -\u003e n",
          "source": "src/Music-Theory-Pitch.html#octpc_to_cps",
          "type": "function"
        },
        "index": {
          "description": "midi to cps of octpc to midi octpc to cps",
          "hierarchy": "Music Theory Pitch",
          "module": "Music.Theory.Pitch",
          "name": "octpc_to_cps",
          "normalized": "Octave_PitchClass a-\u003eb",
          "package": "hmt",
          "signature": "Octave_PitchClass i-\u003en",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch.html#v:octpc_to_cps"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eOctPC\u003c/a\u003e\u003c/code\u003e value to integral \u003cem\u003emidi\u003c/em\u003e note number.\n\u003c/p\u003e\u003cpre\u003e octpc_to_midi (4,9) == 69\n\u003c/pre\u003e",
          "module": "Music.Theory.Pitch",
          "name": "octpc_to_midi",
          "package": "hmt",
          "signature": "Octave_PitchClass i -\u003e i",
          "source": "src/Music-Theory-Pitch.html#octpc_to_midi",
          "type": "function"
        },
        "index": {
          "description": "OctPC value to integral midi note number octpc to midi",
          "hierarchy": "Music Theory Pitch",
          "module": "Music.Theory.Pitch",
          "name": "octpc_to_midi",
          "normalized": "Octave_PitchClass a-\u003ea",
          "package": "hmt",
          "signature": "Octave_PitchClass i-\u003ei",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch.html#v:octpc_to_midi"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGiven \u003ccode\u003e\u003ca\u003eSpelling\u003c/a\u003e\u003c/code\u003e function translate from \u003ccode\u003e\u003ca\u003eOctPC\u003c/a\u003e\u003c/code\u003e notation to\n \u003ccode\u003e\u003ca\u003ePitch\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Music.Theory.Pitch",
          "name": "octpc_to_pitch",
          "package": "hmt",
          "signature": "Spelling i -\u003e Octave_PitchClass i -\u003e Pitch",
          "source": "src/Music-Theory-Pitch.html#octpc_to_pitch",
          "type": "function"
        },
        "index": {
          "description": "Given Spelling function translate from OctPC notation to Pitch",
          "hierarchy": "Music Theory Pitch",
          "module": "Music.Theory.Pitch",
          "name": "octpc_to_pitch",
          "normalized": "Spelling a-\u003eOctave_PitchClass a-\u003ePitch",
          "package": "hmt",
          "signature": "Spelling i-\u003eOctave_PitchClass i-\u003ePitch",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch.html#v:octpc_to_pitch"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTranspose \u003ccode\u003e\u003ca\u003eOctPC\u003c/a\u003e\u003c/code\u003e value.\n\u003c/p\u003e\u003cpre\u003e octpc_trs 7 (4,9) == (5,4)\n octpc_trs (-11) (4,9) == (3,10)\n\u003c/pre\u003e",
          "module": "Music.Theory.Pitch",
          "name": "octpc_trs",
          "package": "hmt",
          "signature": "i -\u003e Octave_PitchClass i -\u003e Octave_PitchClass i",
          "source": "src/Music-Theory-Pitch.html#octpc_trs",
          "type": "function"
        },
        "index": {
          "description": "Transpose OctPC value octpc trs octpc trs",
          "hierarchy": "Music Theory Pitch",
          "module": "Music.Theory.Pitch",
          "name": "octpc_trs",
          "normalized": "a-\u003eOctave_PitchClass a-\u003eOctave_PitchClass a",
          "package": "hmt",
          "signature": "i-\u003eOctave_PitchClass i-\u003eOctave_PitchClass i",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch.html#v:octpc_trs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSimplify \u003ccode\u003e\u003ca\u003ePitch\u003c/a\u003e\u003c/code\u003e to standard 12ET by deleting quarter tones.\n\u003c/p\u003e\u003cpre\u003e let p = Pitch A QuarterToneSharp 4\n in alteration (pitch_clear_quarter_tone p) == Sharp\n\u003c/pre\u003e",
          "module": "Music.Theory.Pitch",
          "name": "pitch_clear_quarter_tone",
          "package": "hmt",
          "signature": "Pitch -\u003e Pitch",
          "source": "src/Music-Theory-Pitch.html#pitch_clear_quarter_tone",
          "type": "function"
        },
        "index": {
          "description": "Simplify Pitch to standard ET by deleting quarter tones let Pitch QuarterToneSharp in alteration pitch clear quarter tone Sharp",
          "hierarchy": "Music Theory Pitch",
          "module": "Music.Theory.Pitch",
          "name": "pitch_clear_quarter_tone",
          "normalized": "Pitch-\u003ePitch",
          "package": "hmt",
          "signature": "Pitch-\u003ePitch",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch.html#v:pitch_clear_quarter_tone"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003ePitch\u003c/a\u003e\u003c/code\u003e comparison, implemented via \u003ccode\u003e\u003ca\u003epitch_to_fmidi\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e pitch_compare (Pitch A Natural 4) (Pitch A QuarterToneSharp 4) == LT\n\u003c/pre\u003e",
          "module": "Music.Theory.Pitch",
          "name": "pitch_compare",
          "package": "hmt",
          "signature": "Pitch -\u003e Pitch -\u003e Ordering",
          "source": "src/Music-Theory-Pitch.html#pitch_compare",
          "type": "function"
        },
        "index": {
          "description": "Pitch comparison implemented via pitch to fmidi pitch compare Pitch Natural Pitch QuarterToneSharp LT",
          "hierarchy": "Music Theory Pitch",
          "module": "Music.Theory.Pitch",
          "name": "pitch_compare",
          "normalized": "Pitch-\u003ePitch-\u003eOrdering",
          "package": "hmt",
          "signature": "Pitch-\u003ePitch-\u003eOrdering",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch.html#v:pitch_compare"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eApply function to \u003ccode\u003e\u003ca\u003eoctave\u003c/a\u003e\u003c/code\u003e of \u003ccode\u003e\u003ca\u003ePitchClass\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e pitch_edit_octave (+ 1) (Pitch A Natural 4) == Pitch A Natural 5\n\u003c/pre\u003e",
          "module": "Music.Theory.Pitch",
          "name": "pitch_edit_octave",
          "package": "hmt",
          "signature": "(Integer -\u003e Integer) -\u003e Pitch -\u003e Pitch",
          "source": "src/Music-Theory-Pitch.html#pitch_edit_octave",
          "type": "function"
        },
        "index": {
          "description": "Apply function to octave of PitchClass pitch edit octave Pitch Natural Pitch Natural",
          "hierarchy": "Music Theory Pitch",
          "module": "Music.Theory.Pitch",
          "name": "pitch_edit_octave",
          "normalized": "(Integer-\u003eInteger)-\u003ePitch-\u003ePitch",
          "package": "hmt",
          "signature": "(Integer-\u003eInteger)-\u003ePitch-\u003ePitch",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch.html#v:pitch_edit_octave"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLower \u003ccode\u003e\u003ca\u003eNote_T\u003c/a\u003e\u003c/code\u003e of \u003ccode\u003e\u003ca\u003ePitch\u003c/a\u003e\u003c/code\u003e, account for octave transposition.\n\u003c/p\u003e\u003cpre\u003e pitch_note_lower (Pitch C Flat 4) == Pitch B Flat 3\n\u003c/pre\u003e",
          "module": "Music.Theory.Pitch",
          "name": "pitch_note_lower",
          "package": "hmt",
          "signature": "Pitch -\u003e Pitch",
          "source": "src/Music-Theory-Pitch.html#pitch_note_lower",
          "type": "function"
        },
        "index": {
          "description": "Lower Note of Pitch account for octave transposition pitch note lower Pitch Flat Pitch Flat",
          "hierarchy": "Music Theory Pitch",
          "module": "Music.Theory.Pitch",
          "name": "pitch_note_lower",
          "normalized": "Pitch-\u003ePitch",
          "package": "hmt",
          "signature": "Pitch-\u003ePitch",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch.html#v:pitch_note_lower"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRaise \u003ccode\u003e\u003ca\u003eNote_T\u003c/a\u003e\u003c/code\u003e of \u003ccode\u003e\u003ca\u003ePitch\u003c/a\u003e\u003c/code\u003e, account for octave transposition.\n\u003c/p\u003e\u003cpre\u003e pitch_note_raise (Pitch B Natural 3) == Pitch C Natural 4\n\u003c/pre\u003e",
          "module": "Music.Theory.Pitch",
          "name": "pitch_note_raise",
          "package": "hmt",
          "signature": "Pitch -\u003e Pitch",
          "source": "src/Music-Theory-Pitch.html#pitch_note_raise",
          "type": "function"
        },
        "index": {
          "description": "Raise Note of Pitch account for octave transposition pitch note raise Pitch Natural Pitch Natural",
          "hierarchy": "Music Theory Pitch",
          "module": "Music.Theory.Pitch",
          "name": "pitch_note_raise",
          "normalized": "Pitch-\u003ePitch",
          "package": "hmt",
          "signature": "Pitch-\u003ePitch",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch.html#v:pitch_note_raise"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePretty printer for \u003ccode\u003e\u003ca\u003ePitch\u003c/a\u003e\u003c/code\u003e (unicode, see \u003ccode\u003e\u003ca\u003ealteration_symbol\u003c/a\u003e\u003c/code\u003e).\n\u003c/p\u003e\u003cpre\u003e pitch_pp (Pitch E Flat 4) == \"E&#9837;4\"\n pitch_pp (Pitch F QuarterToneSharp 3) == \"F&#119090;3\"\n\u003c/pre\u003e",
          "module": "Music.Theory.Pitch",
          "name": "pitch_pp",
          "package": "hmt",
          "signature": "Pitch -\u003e String",
          "source": "src/Music-Theory-Pitch.html#pitch_pp",
          "type": "function"
        },
        "index": {
          "description": "Pretty printer for Pitch unicode see alteration symbol pitch pp Pitch Flat pitch pp Pitch QuarterToneSharp",
          "hierarchy": "Music Theory Pitch",
          "module": "Music.Theory.Pitch",
          "name": "pitch_pp",
          "normalized": "Pitch-\u003eString",
          "package": "hmt",
          "signature": "Pitch-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch.html#v:pitch_pp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePretty printer for \u003ccode\u003e\u003ca\u003ePitch\u003c/a\u003e\u003c/code\u003e (ASCII, see \u003ccode\u003e\u003ca\u003ealteration_ly_name\u003c/a\u003e\u003c/code\u003e).\n\u003c/p\u003e\u003cpre\u003e pitch_pp_ascii (Pitch E Flat 4) == \"ees4\"\n pitch_pp_ascii (Pitch F QuarterToneSharp 3) == \"fih3\"\n\u003c/pre\u003e",
          "module": "Music.Theory.Pitch",
          "name": "pitch_pp_ascii",
          "package": "hmt",
          "signature": "Pitch -\u003e String",
          "source": "src/Music-Theory-Pitch.html#pitch_pp_ascii",
          "type": "function"
        },
        "index": {
          "description": "Pretty printer for Pitch ASCII see alteration ly name pitch pp ascii Pitch Flat ees4 pitch pp ascii Pitch QuarterToneSharp fih3",
          "hierarchy": "Music Theory Pitch",
          "module": "Music.Theory.Pitch",
          "name": "pitch_pp_ascii",
          "normalized": "Pitch-\u003eString",
          "package": "hmt",
          "signature": "Pitch-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch.html#v:pitch_pp_ascii"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRewrite \u003ccode\u003e\u003ca\u003ePitch\u003c/a\u003e\u003c/code\u003e to not use \u003ccode\u003e3/4\u003c/code\u003e tone alterations, ie. re-spell\n to \u003ccode\u003e1/4\u003c/code\u003e alteration.\n\u003c/p\u003e\u003cpre\u003e let {p = Pitch A ThreeQuarterToneFlat 4\n     ;q = Pitch G QuarterToneSharp 4}\n in pitch_rewrite_threequarter_alteration p == q\n\u003c/pre\u003e",
          "module": "Music.Theory.Pitch",
          "name": "pitch_rewrite_threequarter_alteration",
          "package": "hmt",
          "signature": "Pitch -\u003e Pitch",
          "source": "src/Music-Theory-Pitch.html#pitch_rewrite_threequarter_alteration",
          "type": "function"
        },
        "index": {
          "description": "Rewrite Pitch to not use tone alterations ie re-spell to alteration let Pitch ThreeQuarterToneFlat Pitch QuarterToneSharp in pitch rewrite threequarter alteration",
          "hierarchy": "Music Theory Pitch",
          "module": "Music.Theory.Pitch",
          "name": "pitch_rewrite_threequarter_alteration",
          "normalized": "Pitch-\u003ePitch",
          "package": "hmt",
          "signature": "Pitch-\u003ePitch",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch.html#v:pitch_rewrite_threequarter_alteration"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003ePitch\u003c/a\u003e\u003c/code\u003e to fractional midi note number notation.\n\u003c/p\u003e\u003cpre\u003e pitch_to_fmidi (Pitch A QuarterToneSharp 4) == 69.5\n\u003c/pre\u003e",
          "module": "Music.Theory.Pitch",
          "name": "pitch_to_fmidi",
          "package": "hmt",
          "signature": "Pitch -\u003e Double",
          "source": "src/Music-Theory-Pitch.html#pitch_to_fmidi",
          "type": "function"
        },
        "index": {
          "description": "Pitch to fractional midi note number notation pitch to fmidi Pitch QuarterToneSharp",
          "hierarchy": "Music Theory Pitch",
          "module": "Music.Theory.Pitch",
          "name": "pitch_to_fmidi",
          "normalized": "Pitch-\u003eDouble",
          "package": "hmt",
          "signature": "Pitch-\u003eDouble",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch.html#v:pitch_to_fmidi"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003ePitch\u003c/a\u003e\u003c/code\u003e to midi note number notation.\n\u003c/p\u003e\u003cpre\u003e pitch_to_midi (Pitch A Natural 4) == 69\n\u003c/pre\u003e",
          "module": "Music.Theory.Pitch",
          "name": "pitch_to_midi",
          "package": "hmt",
          "signature": "Pitch -\u003e i",
          "source": "src/Music-Theory-Pitch.html#pitch_to_midi",
          "type": "function"
        },
        "index": {
          "description": "Pitch to midi note number notation pitch to midi Pitch Natural",
          "hierarchy": "Music Theory Pitch",
          "module": "Music.Theory.Pitch",
          "name": "pitch_to_midi",
          "normalized": "Pitch-\u003ea",
          "package": "hmt",
          "signature": "Pitch-\u003ei",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch.html#v:pitch_to_midi"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003ePitch\u003c/a\u003e\u003c/code\u003e to \u003ccode\u003e\u003ca\u003eOctave\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003ePitchClass\u003c/a\u003e\u003c/code\u003e notation.\n\u003c/p\u003e\u003cpre\u003e pitch_to_octpc (Pitch F Sharp 4) == (4,6)\n\u003c/pre\u003e",
          "module": "Music.Theory.Pitch",
          "name": "pitch_to_octpc",
          "package": "hmt",
          "signature": "Pitch -\u003e Octave_PitchClass i",
          "source": "src/Music-Theory-Pitch.html#pitch_to_octpc",
          "type": "function"
        },
        "index": {
          "description": "Pitch to Octave and PitchClass notation pitch to octpc Pitch Sharp",
          "hierarchy": "Music Theory Pitch",
          "module": "Music.Theory.Pitch",
          "name": "pitch_to_octpc",
          "normalized": "Pitch-\u003eOctave_PitchClass a",
          "package": "hmt",
          "signature": "Pitch-\u003eOctave_PitchClass i",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch.html#v:pitch_to_octpc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExtract \u003ccode\u003e\u003ca\u003ePitchClass\u003c/a\u003e\u003c/code\u003e of \u003ccode\u003e\u003ca\u003ePitch\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e\u003cpre\u003e pitch_to_pc (Pitch A Natural 4) == 9\n pitch_to_pc (Pitch F Sharp 4) == 6\n\u003c/pre\u003e",
          "module": "Music.Theory.Pitch",
          "name": "pitch_to_pc",
          "package": "hmt",
          "signature": "Pitch -\u003e PitchClass",
          "source": "src/Music-Theory-Pitch.html#pitch_to_pc",
          "type": "function"
        },
        "index": {
          "description": "Extract PitchClass of Pitch pitch to pc Pitch Natural pitch to pc Pitch Sharp",
          "hierarchy": "Music Theory Pitch",
          "module": "Music.Theory.Pitch",
          "name": "pitch_to_pc",
          "normalized": "Pitch-\u003ePitchClass",
          "package": "hmt",
          "signature": "Pitch-\u003ePitchClass",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Pitch.html#v:pitch_to_pc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eSet operations on lists.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Music.Theory.Set.List",
          "name": "List",
          "package": "hmt",
          "source": "src/Music-Theory-Set-List.html",
          "type": "module"
        },
        "index": {
          "description": "Set operations on lists",
          "hierarchy": "Music Theory Set List",
          "module": "Music.Theory.Set.List",
          "name": "List",
          "package": "hmt",
          "partial": "List",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Set-List.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCartesian product of two sets.\n\u003c/p\u003e\u003cpre\u003e let r = [('a',1),('a',2),('b',1),('b',2),('c',1),('c',2)]\n in cartesian_product \"abc\" [1,2] == r\n\u003c/pre\u003e",
          "module": "Music.Theory.Set.List",
          "name": "cartesian_product",
          "package": "hmt",
          "signature": "[a] -\u003e [b] -\u003e [(a, b)]",
          "source": "src/Music-Theory-Set-List.html#cartesian_product",
          "type": "function"
        },
        "index": {
          "description": "Cartesian product of two sets let in cartesian product abc",
          "hierarchy": "Music Theory Set List",
          "module": "Music.Theory.Set.List",
          "name": "cartesian_product",
          "normalized": "[a]-\u003e[b]-\u003e[(a,b)]",
          "package": "hmt",
          "signature": "[a]-\u003e[b]-\u003e[(a,b)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Set-List.html#v:cartesian_product"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSet expansion (ie. to multiset of degree \u003cem\u003en\u003c/em\u003e).\n\u003c/p\u003e\u003cpre\u003e expand_set 4 [1,2,3] == [[1,1,2,3],[1,2,2,3],[1,2,3,3]]\n\u003c/pre\u003e",
          "module": "Music.Theory.Set.List",
          "name": "expand_set",
          "package": "hmt",
          "signature": "Int -\u003e [a] -\u003e [[a]]",
          "source": "src/Music-Theory-Set-List.html#expand_set",
          "type": "function"
        },
        "index": {
          "description": "Set expansion ie to multiset of degree expand set",
          "hierarchy": "Music Theory Set List",
          "module": "Music.Theory.Set.List",
          "name": "expand_set",
          "normalized": "Int-\u003e[a]-\u003e[[a]]",
          "package": "hmt",
          "signature": "Int-\u003e[a]-\u003e[[a]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Set-List.html#v:expand_set"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSize of powerset of set of cardinality \u003cem\u003en\u003c/em\u003e, ie. \u003ccode\u003e2\u003c/code\u003e \u003ccode\u003e\u003ca\u003e^\u003c/a\u003e\u003c/code\u003e \u003cem\u003en\u003c/em\u003e.\n\u003c/p\u003e\u003cpre\u003e map n_powerset [6..9] == [64,128,256,512]\n\u003c/pre\u003e",
          "module": "Music.Theory.Set.List",
          "name": "n_powerset",
          "package": "hmt",
          "signature": "n -\u003e n",
          "source": "src/Music-Theory-Set-List.html#n_powerset",
          "type": "function"
        },
        "index": {
          "description": "Size of powerset of set of cardinality ie map powerset",
          "hierarchy": "Music Theory Set List",
          "module": "Music.Theory.Set.List",
          "name": "n_powerset",
          "normalized": "a-\u003ea",
          "package": "hmt",
          "signature": "n-\u003en",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Set-List.html#v:n_powerset"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTwo element subsets.\n\u003c/p\u003e\u003cpre\u003e pairs [1,2,3] == [(1,2),(1,3),(2,3)]\n\u003c/pre\u003e",
          "module": "Music.Theory.Set.List",
          "name": "pairs",
          "package": "hmt",
          "signature": "[a] -\u003e [(a, a)]",
          "source": "src/Music-Theory-Set-List.html#pairs",
          "type": "function"
        },
        "index": {
          "description": "Two element subsets pairs",
          "hierarchy": "Music Theory Set List",
          "module": "Music.Theory.Set.List",
          "name": "pairs",
          "normalized": "[a]-\u003e[(a,a)]",
          "package": "hmt",
          "signature": "[a]-\u003e[(a,a)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Set-List.html#v:pairs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAll distinct multiset partitions, see \u003ccode\u003e\u003ca\u003epartitions\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e partitions \"aab\" == [[\"aab\"],[\"a\",\"ab\"],[\"b\",\"aa\"],[\"b\",\"a\",\"a\"]]\n\u003c/pre\u003e\u003cpre\u003e partitions \"abc\" == [[\"abc\"]\n                     ,[\"bc\",\"a\"],[\"b\",\"ac\"],[\"c\",\"ab\"]\n                     ,[\"c\",\"b\",\"a\"]]\n\u003c/pre\u003e",
          "module": "Music.Theory.Set.List",
          "name": "partitions",
          "package": "hmt",
          "signature": "[a] -\u003e [[[a]]]",
          "source": "src/Music-Theory-Set-List.html#partitions",
          "type": "function"
        },
        "index": {
          "description": "All distinct multiset partitions see partitions partitions aab aab ab aa partitions abc abc bc ac ab",
          "hierarchy": "Music Theory Set List",
          "module": "Music.Theory.Set.List",
          "name": "partitions",
          "normalized": "[a]-\u003e[[[a]]]",
          "package": "hmt",
          "signature": "[a]-\u003e[[[a]]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Set-List.html#v:partitions"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePowerset, ie. set of all subsets.\n\u003c/p\u003e\u003cpre\u003e sort (powerset [1,2]) == [[],[1],[1,2],[2]]\n map length (map (\\n -\u003e powerset [1..n]) [6..9]) == [64,128,256,512]\n\u003c/pre\u003e",
          "module": "Music.Theory.Set.List",
          "name": "powerset",
          "package": "hmt",
          "signature": "[a] -\u003e [[a]]",
          "source": "src/Music-Theory-Set-List.html#powerset",
          "type": "function"
        },
        "index": {
          "description": "Powerset ie set of all subsets sort powerset map length map powerset",
          "hierarchy": "Music Theory Set List",
          "module": "Music.Theory.Set.List",
          "name": "powerset",
          "normalized": "[a]-\u003e[[a]]",
          "package": "hmt",
          "signature": "[a]-\u003e[[a]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Set-List.html#v:powerset"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRemove duplicate elements with \u003ccode\u003e\u003ca\u003enub\u003c/a\u003e\u003c/code\u003e and then \u003ccode\u003e\u003ca\u003esort\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e set_l [3,3,3,2,2,1] == [1,2,3]\n\u003c/pre\u003e",
          "module": "Music.Theory.Set.List",
          "name": "set",
          "package": "hmt",
          "signature": "[a] -\u003e [a]",
          "source": "src/Music-Theory-Set-List.html#set",
          "type": "function"
        },
        "index": {
          "description": "Remove duplicate elements with nub and then sort set",
          "hierarchy": "Music Theory Set List",
          "module": "Music.Theory.Set.List",
          "name": "set",
          "normalized": "[a]-\u003e[a]",
          "package": "hmt",
          "signature": "[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Set-List.html#v:set"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThree element subsets.\n\u003c/p\u003e\u003cpre\u003e triples [1..4] == [(1,2,3),(1,2,4),(1,3,4),(2,3,4)]\n\u003c/pre\u003e\u003cpre\u003e let f n = genericLength (triples [1..n]) == nk_combinations n 3\n in all f [1..15]\n\u003c/pre\u003e",
          "module": "Music.Theory.Set.List",
          "name": "triples",
          "package": "hmt",
          "signature": "[a] -\u003e [(a, a, a)]",
          "source": "src/Music-Theory-Set-List.html#triples",
          "type": "function"
        },
        "index": {
          "description": "Three element subsets triples let genericLength triples nk combinations in all",
          "hierarchy": "Music Theory Set List",
          "module": "Music.Theory.Set.List",
          "name": "triples",
          "normalized": "[a]-\u003e[(a,a,a)]",
          "package": "hmt",
          "signature": "[a]-\u003e[(a,a,a)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Set-List.html#v:triples"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eSet operations on \u003ccode\u003eSet\u003c/code\u003es.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Music.Theory.Set.Set",
          "name": "Set",
          "package": "hmt",
          "source": "src/Music-Theory-Set-Set.html",
          "type": "module"
        },
        "index": {
          "description": "Set operations on Set",
          "hierarchy": "Music Theory Set Set",
          "module": "Music.Theory.Set.Set",
          "name": "Set",
          "package": "hmt",
          "partial": "Set",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Set-Set.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Set.Set",
          "name": "pairs",
          "package": "hmt",
          "signature": "Set a -\u003e Set (a, a)",
          "source": "src/Music-Theory-Set-Set.html#pairs",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Set Set",
          "module": "Music.Theory.Set.Set",
          "name": "pairs",
          "normalized": "Set a-\u003eSet(a,a)",
          "package": "hmt",
          "signature": "Set a-\u003eSet(a,a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Set-Set.html#v:pairs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Set.Set",
          "name": "powerset",
          "package": "hmt",
          "signature": "Set a -\u003e Set (Set a)",
          "source": "src/Music-Theory-Set-Set.html#powerset",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Set Set",
          "module": "Music.Theory.Set.Set",
          "name": "powerset",
          "normalized": "Set a-\u003eSet(Set a)",
          "package": "hmt",
          "signature": "Set a-\u003eSet(Set a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Set-Set.html#v:powerset"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Set.Set",
          "name": "set",
          "package": "hmt",
          "signature": "[a] -\u003e Set a",
          "source": "src/Music-Theory-Set-Set.html#set",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Set Set",
          "module": "Music.Theory.Set.Set",
          "name": "set",
          "normalized": "[a]-\u003eSet a",
          "package": "hmt",
          "signature": "[a]-\u003eSet a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Set-Set.html#v:set"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eCommon music notation tempo indications.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Music.Theory.Tempo_Marking",
          "name": "Tempo_Marking",
          "package": "hmt",
          "source": "src/Music-Theory-Tempo_Marking.html",
          "type": "module"
        },
        "index": {
          "description": "Common music notation tempo indications",
          "hierarchy": "Music Theory Tempo_Marking",
          "module": "Music.Theory.Tempo_Marking",
          "name": "Tempo_Marking",
          "package": "hmt",
          "partial": "Tempo Marking",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tempo_Marking.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA tempo marking is in terms of a common music notation \u003ccode\u003e\u003ca\u003eDuration\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Music.Theory.Tempo_Marking",
          "name": "Tempo_Marking",
          "package": "hmt",
          "source": "src/Music-Theory-Tempo_Marking.html#Tempo_Marking",
          "type": "type"
        },
        "index": {
          "description": "tempo marking is in terms of common music notation Duration",
          "hierarchy": "Music Theory Tempo_Marking",
          "module": "Music.Theory.Tempo_Marking",
          "name": "Tempo_Marking",
          "package": "hmt",
          "partial": "Tempo Marking",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tempo_Marking.html#t:Tempo_Marking"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe duration, in seconds, of a measure at the indicated time\n   signaure and tempo marking.\n\u003c/p\u003e\u003cpre\u003e measure_duration (3,4) (quarter_note,90) == 2\n measure_duration (6,8) (quarter_note,120) == 3/2\n\u003c/pre\u003e",
          "module": "Music.Theory.Tempo_Marking",
          "name": "measure_duration",
          "package": "hmt",
          "signature": "Time_Signature -\u003e Tempo_Marking -\u003e Rational",
          "source": "src/Music-Theory-Tempo_Marking.html#measure_duration",
          "type": "function"
        },
        "index": {
          "description": "The duration in seconds of measure at the indicated time signaure and tempo marking measure duration quarter note measure duration quarter note",
          "hierarchy": "Music Theory Tempo_Marking",
          "module": "Music.Theory.Tempo_Marking",
          "name": "measure_duration",
          "normalized": "Time_Signature-\u003eTempo_Marking-\u003eRational",
          "package": "hmt",
          "signature": "Time_Signature-\u003eTempo_Marking-\u003eRational",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tempo_Marking.html#v:measure_duration"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eFractional\u003c/a\u003e\u003c/code\u003e variant of \u003ccode\u003e\u003ca\u003emeasure_duration\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Music.Theory.Tempo_Marking",
          "name": "measure_duration_f",
          "package": "hmt",
          "signature": "Time_Signature -\u003e Tempo_Marking -\u003e c",
          "source": "src/Music-Theory-Tempo_Marking.html#measure_duration_f",
          "type": "function"
        },
        "index": {
          "description": "Fractional variant of measure duration",
          "hierarchy": "Music Theory Tempo_Marking",
          "module": "Music.Theory.Tempo_Marking",
          "name": "measure_duration_f",
          "normalized": "Time_Signature-\u003eTempo_Marking-\u003ea",
          "package": "hmt",
          "signature": "Time_Signature-\u003eTempo_Marking-\u003ec",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tempo_Marking.html#v:measure_duration_f"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe duration, in seconds, of a pulse at the indicated time\n   signature and tempo marking.\n\u003c/p\u003e\u003cpre\u003e import Music.Theory.Duration.Name\n pulse_duration (6,8) (quarter_note,60) == 1/2\n\u003c/pre\u003e",
          "module": "Music.Theory.Tempo_Marking",
          "name": "pulse_duration",
          "package": "hmt",
          "signature": "Time_Signature -\u003e Tempo_Marking -\u003e Rational",
          "source": "src/Music-Theory-Tempo_Marking.html#pulse_duration",
          "type": "function"
        },
        "index": {
          "description": "The duration in seconds of pulse at the indicated time signature and tempo marking import Music.Theory.Duration.Name pulse duration quarter note",
          "hierarchy": "Music Theory Tempo_Marking",
          "module": "Music.Theory.Tempo_Marking",
          "name": "pulse_duration",
          "normalized": "Time_Signature-\u003eTempo_Marking-\u003eRational",
          "package": "hmt",
          "signature": "Time_Signature-\u003eTempo_Marking-\u003eRational",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tempo_Marking.html#v:pulse_duration"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDuration of a RQ value, in seconds, given indicated tempo.\n\u003c/p\u003e\u003cpre\u003e rq_to_seconds (quarter_note,90) 1 == 60/90\n\u003c/pre\u003e",
          "module": "Music.Theory.Tempo_Marking",
          "name": "rq_to_seconds",
          "package": "hmt",
          "signature": "Tempo_Marking -\u003e RQ -\u003e Rational",
          "source": "src/Music-Theory-Tempo_Marking.html#rq_to_seconds",
          "type": "function"
        },
        "index": {
          "description": "Duration of RQ value in seconds given indicated tempo rq to seconds quarter note",
          "hierarchy": "Music Theory Tempo_Marking",
          "module": "Music.Theory.Tempo_Marking",
          "name": "rq_to_seconds",
          "normalized": "Tempo_Marking-\u003eRQ-\u003eRational",
          "package": "hmt",
          "signature": "Tempo_Marking-\u003eRQ-\u003eRational",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tempo_Marking.html#v:rq_to_seconds"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Tiling.Canon",
          "name": "Canon",
          "package": "hmt",
          "source": "src/Music-Theory-Tiling-Canon.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Music Theory Tiling Canon",
          "module": "Music.Theory.Tiling.Canon",
          "name": "Canon",
          "package": "hmt",
          "partial": "Canon",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tiling-Canon.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eElement of \u003cem\u003e(sequence,multiplier,displacement)\u003c/em\u003e.\n\u003c/p\u003e",
          "module": "Music.Theory.Tiling.Canon",
          "name": "E",
          "package": "hmt",
          "source": "src/Music-Theory-Tiling-Canon.html#E",
          "type": "type"
        },
        "index": {
          "description": "Element of sequence multiplier displacement",
          "hierarchy": "Music Theory Tiling Canon",
          "module": "Music.Theory.Tiling.Canon",
          "name": "E",
          "package": "hmt",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tiling-Canon.html#t:E"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCanon of \u003cem\u003e(period,sequence,multipliers,displacements)\u003c/em\u003e.\n\u003c/p\u003e",
          "module": "Music.Theory.Tiling.Canon",
          "name": "R",
          "package": "hmt",
          "source": "src/Music-Theory-Tiling-Canon.html#R",
          "type": "type"
        },
        "index": {
          "description": "Canon of period sequence multipliers displacements",
          "hierarchy": "Music Theory Tiling Canon",
          "module": "Music.Theory.Tiling.Canon",
          "name": "R",
          "package": "hmt",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tiling-Canon.html#t:R"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSequence.\n\u003c/p\u003e",
          "module": "Music.Theory.Tiling.Canon",
          "name": "S",
          "package": "hmt",
          "source": "src/Music-Theory-Tiling-Canon.html#S",
          "type": "type"
        },
        "index": {
          "description": "Sequence",
          "hierarchy": "Music Theory Tiling Canon",
          "module": "Music.Theory.Tiling.Canon",
          "name": "S",
          "package": "hmt",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tiling-Canon.html#t:S"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTiling (sequence)\n\u003c/p\u003e",
          "module": "Music.Theory.Tiling.Canon",
          "name": "T",
          "package": "hmt",
          "source": "src/Music-Theory-Tiling-Canon.html#T",
          "type": "type"
        },
        "index": {
          "description": "Tiling sequence",
          "hierarchy": "Music Theory Tiling Canon",
          "module": "Music.Theory.Tiling.Canon",
          "name": "T",
          "package": "hmt",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tiling-Canon.html#t:T"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eVoice.\n\u003c/p\u003e",
          "module": "Music.Theory.Tiling.Canon",
          "name": "V",
          "package": "hmt",
          "source": "src/Music-Theory-Tiling-Canon.html#V",
          "type": "type"
        },
        "index": {
          "description": "Voice",
          "hierarchy": "Music Theory Tiling Canon",
          "module": "Music.Theory.Tiling.Canon",
          "name": "V",
          "package": "hmt",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tiling-Canon.html#t:V"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInfer \u003ccode\u003e\u003ca\u003eE\u003c/a\u003e\u003c/code\u003e from sequence.\n\u003c/p\u003e\u003cpre\u003e e_from_seq [1,5,11] == ([0,2,5],2,1)\n e_from_seq [4,7] == ([0,1],3,4)\n e_from_seq [2] == ([0],1,2)\n\u003c/pre\u003e",
          "module": "Music.Theory.Tiling.Canon",
          "name": "e_from_seq",
          "package": "hmt",
          "signature": "[Int] -\u003e E",
          "source": "src/Music-Theory-Tiling-Canon.html#e_from_seq",
          "type": "function"
        },
        "index": {
          "description": "Infer from sequence from seq from seq from seq",
          "hierarchy": "Music Theory Tiling Canon",
          "module": "Music.Theory.Tiling.Canon",
          "name": "e_from_seq",
          "normalized": "[Int]-\u003eE",
          "package": "hmt",
          "signature": "[Int]-\u003eE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tiling-Canon.html#v:e_from_seq"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eResolve sequence from \u003ccode\u003e\u003ca\u003eE\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e e_to_seq ([0,2,5],2,1) == [1,5,11]\n e_to_seq ([0,1],3,4) == [4,7]\n e_to_seq ([0],1,2) == [2]\n\u003c/pre\u003e",
          "module": "Music.Theory.Tiling.Canon",
          "name": "e_to_seq",
          "package": "hmt",
          "signature": "E -\u003e [Int]",
          "source": "src/Music-Theory-Tiling-Canon.html#e_to_seq",
          "type": "function"
        },
        "index": {
          "description": "Resolve sequence from to seq to seq to seq",
          "hierarchy": "Music Theory Tiling Canon",
          "module": "Music.Theory.Tiling.Canon",
          "name": "e_to_seq",
          "normalized": "E-\u003e[Int]",
          "package": "hmt",
          "signature": "E-\u003e[Int]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tiling-Canon.html#v:e_to_seq"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eVariant of \u003ccode\u003e\u003ca\u003eelem\u003c/a\u003e\u003c/code\u003e for ordered sequences, which can therefore\n return \u003ccode\u003e\u003ca\u003eFalse\u003c/a\u003e\u003c/code\u003e when searching infinite sequences.\n\u003c/p\u003e\u003cpre\u003e 5 `elemOrd` [0,2..] == False && 10 `elemOrd` [0,2..] == True\n\u003c/pre\u003e",
          "module": "Music.Theory.Tiling.Canon",
          "name": "elemOrd",
          "package": "hmt",
          "signature": "a -\u003e [a] -\u003e Bool",
          "source": "src/Music-Theory-Tiling-Canon.html#elemOrd",
          "type": "function"
        },
        "index": {
          "description": "Variant of elem for ordered sequences which can therefore return False when searching infinite sequences elemOrd False elemOrd True",
          "hierarchy": "Music Theory Tiling Canon",
          "module": "Music.Theory.Tiling.Canon",
          "name": "elemOrd",
          "normalized": "a-\u003e[a]-\u003eBool",
          "package": "hmt",
          "partial": "Ord",
          "signature": "a-\u003e[a]-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tiling-Canon.html#v:elemOrd"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003emsum\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003emap\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003ereturn\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e observeAll (fromList [1..7]) == [1..7]\n\u003c/pre\u003e",
          "module": "Music.Theory.Tiling.Canon",
          "name": "fromList",
          "package": "hmt",
          "signature": "[a] -\u003e m a",
          "source": "src/Music-Theory-Tiling-Canon.html#fromList",
          "type": "function"
        },
        "index": {
          "description": "msum map return observeAll fromList",
          "hierarchy": "Music Theory Tiling Canon",
          "module": "Music.Theory.Tiling.Canon",
          "name": "fromList",
          "normalized": "[a]-\u003eb a",
          "package": "hmt",
          "partial": "List",
          "signature": "[a]-\u003em a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tiling-Canon.html#v:fromList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCycle at \u003cem\u003eperiod\u003c/em\u003e.\n\u003c/p\u003e\u003cpre\u003e take 9 (p_cycle 18 [0,2,5]) == [0,2,5,18,20,23,36,38,41]\n\u003c/pre\u003e",
          "module": "Music.Theory.Tiling.Canon",
          "name": "p_cycle",
          "package": "hmt",
          "signature": "Int -\u003e [Int] -\u003e [Int]",
          "source": "src/Music-Theory-Tiling-Canon.html#p_cycle",
          "type": "function"
        },
        "index": {
          "description": "Cycle at period take cycle",
          "hierarchy": "Music Theory Tiling Canon",
          "module": "Music.Theory.Tiling.Canon",
          "name": "p_cycle",
          "normalized": "Int-\u003e[Int]-\u003e[Int]",
          "package": "hmt",
          "signature": "Int-\u003e[Int]-\u003e[Int]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tiling-Canon.html#v:p_cycle"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003et_normal\u003c/a\u003e\u003c/code\u003e of \u003ccode\u003e\u003ca\u003eobserveAll\u003c/a\u003e\u003c/code\u003e of \u003ccode\u003e\u003ca\u003eperfect_tilings_m\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e perfect_tilings [[0,1]] [1..3] 6 3 == []\n\u003c/pre\u003e\u003cpre\u003e let r = [[[0,7,14],[1,5,9],[2,4,6],[3,8,13],[10,11,12]]]\n in perfect_tilings [[0,1,2]] [1,2,4,5,7] 15 5 == r\n\u003c/pre\u003e\u003cpre\u003e length (perfect_tilings [[0,1,2]] [1..12] 15 5) == 1\n\u003c/pre\u003e\u003cpre\u003e let r = [[[0,1],[2,5],[3,7],[4,6]]\n         ,[[0,1],[2,6],[3,5],[4,7]]\n         ,[[0,2],[1,4],[3,7],[5,6]]]\n in perfect_tilings [[0,1]] [1..4] 8 4 == r\n\u003c/pre\u003e\u003cpre\u003e let r = [[[0,1],[2,5],[3,7],[4,9],[6,8]]\n         ,[[0,1],[2,7],[3,5],[4,8],[6,9]]\n         ,[[0,2],[1,4],[3,8],[5,9],[6,7]]\n         ,[[0,2],[1,5],[3,6],[4,9],[7,8]]\n         ,[[0,3],[1,6],[2,4],[5,9],[7,8]]]\n in perfect_tilings [[0,1]] [1..5] 10 5 == r\n\u003c/pre\u003e\u003cp\u003eJohnson 2004, p.2\n\u003c/p\u003e\u003cpre\u003e let r = [[0,6,12],[1,8,15],[2,11,20],[3,5,7],[4,9,14],[10,13,16],[17,18,19]]\n in perfect_tilings [[0,1,2]] [1,2,3,5,6,7,9] 21 7 == [r]\n\u003c/pre\u003e\u003cpre\u003e let r = [[0,10,20],[1,9,17],[2,4,6],[3,7,11],[5,12,19],[8,13,18],[14,15,16]]\n in perfect_tilings [[0,1,2]] [1,2,4,5,7,8,10] 21 7 == [t_retrograde r]\n\u003c/pre\u003e",
          "module": "Music.Theory.Tiling.Canon",
          "name": "perfect_tilings",
          "package": "hmt",
          "signature": "[S] -\u003e [Int] -\u003e Int -\u003e Int -\u003e [T]",
          "source": "src/Music-Theory-Tiling-Canon.html#perfect_tilings",
          "type": "function"
        },
        "index": {
          "description": "normal of observeAll of perfect tilings perfect tilings let in perfect tilings length perfect tilings let in perfect tilings let in perfect tilings Johnson p.2 let in perfect tilings let in perfect tilings retrograde",
          "hierarchy": "Music Theory Tiling Canon",
          "module": "Music.Theory.Tiling.Canon",
          "name": "perfect_tilings",
          "normalized": "[S]-\u003e[Int]-\u003eInt-\u003eInt-\u003e[T]",
          "package": "hmt",
          "signature": "[S]-\u003e[Int]-\u003eInt-\u003eInt-\u003e[T]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tiling-Canon.html#v:perfect_tilings"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSearch for \u003cem\u003eperfect\u003c/em\u003e tilings of the sequence \u003ccode\u003e\u003ca\u003eS\u003c/a\u003e\u003c/code\u003e using\n multipliers from \u003cem\u003em\u003c/em\u003e to degree \u003cem\u003en\u003c/em\u003e with \u003cem\u003ek\u003c/em\u003e parts.\n\u003c/p\u003e",
          "module": "Music.Theory.Tiling.Canon",
          "name": "perfect_tilings_m",
          "package": "hmt",
          "signature": "[S] -\u003e [Int] -\u003e Int -\u003e Int -\u003e m T",
          "source": "src/Music-Theory-Tiling-Canon.html#perfect_tilings_m",
          "type": "function"
        },
        "index": {
          "description": "Search for perfect tilings of the sequence using multipliers from to degree with parts",
          "hierarchy": "Music Theory Tiling Canon",
          "module": "Music.Theory.Tiling.Canon",
          "name": "perfect_tilings_m",
          "normalized": "[S]-\u003e[Int]-\u003eInt-\u003eInt-\u003ea T",
          "package": "hmt",
          "signature": "[S]-\u003e[Int]-\u003eInt-\u003eInt-\u003em T",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tiling-Canon.html#v:perfect_tilings_m"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDerive set of \u003ccode\u003e\u003ca\u003eR\u003c/a\u003e\u003c/code\u003e from \u003ccode\u003e\u003ca\u003eT\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e let {r = [(21,[0,1,2],[10,8,2,4,7,5,1],[0,1,2,3,5,8,14])]\n     ;t = [[0,10,20],[1,9,17],[2,4,6],[3,7,11],[5,12,19],[8,13,18],[14,15,16]]}\n in r_from_t t == r\n\u003c/pre\u003e",
          "module": "Music.Theory.Tiling.Canon",
          "name": "r_from_t",
          "package": "hmt",
          "signature": "T -\u003e [R]",
          "source": "src/Music-Theory-Tiling-Canon.html#r_from_t",
          "type": "function"
        },
        "index": {
          "description": "Derive set of from let in from",
          "hierarchy": "Music Theory Tiling Canon",
          "module": "Music.Theory.Tiling.Canon",
          "name": "r_from_t",
          "normalized": "T-\u003e[R]",
          "package": "hmt",
          "signature": "T-\u003e[R]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tiling-Canon.html#v:r_from_t"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSet of \u003ccode\u003e\u003ca\u003eV\u003c/a\u003e\u003c/code\u003e from \u003ccode\u003e\u003ca\u003eR\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Music.Theory.Tiling.Canon",
          "name": "r_voices",
          "package": "hmt",
          "signature": "R -\u003e [V]",
          "source": "src/Music-Theory-Tiling-Canon.html#r_voices",
          "type": "function"
        },
        "index": {
          "description": "Set of from",
          "hierarchy": "Music Theory Tiling Canon",
          "module": "Music.Theory.Tiling.Canon",
          "name": "r_voices",
          "normalized": "R-\u003e[V]",
          "package": "hmt",
          "signature": "R-\u003e[V]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tiling-Canon.html#v:r_voices"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003econcatMap\u003c/a\u003e\u003c/code\u003e of \u003ccode\u003e\u003ca\u003er_voices\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Music.Theory.Tiling.Canon",
          "name": "rr_voices",
          "package": "hmt",
          "signature": "[R] -\u003e [V]",
          "source": "src/Music-Theory-Tiling-Canon.html#rr_voices",
          "type": "function"
        },
        "index": {
          "description": "concatMap of voices",
          "hierarchy": "Music Theory Tiling Canon",
          "module": "Music.Theory.Tiling.Canon",
          "name": "rr_voices",
          "normalized": "[R]-\u003e[V]",
          "package": "hmt",
          "signature": "[R]-\u003e[V]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tiling-Canon.html#v:rr_voices"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe normal form of \u003ccode\u003e\u003ca\u003eT\u003c/a\u003e\u003c/code\u003e is the \u003ccode\u003e\u003ca\u003emin\u003c/a\u003e\u003c/code\u003e of \u003cem\u003et\u003c/em\u003e and it's \u003ccode\u003e\u003ca\u003et_retrograde\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e let r = [[0,7,14],[1,5,9],[2,4,6],[3,8,13],[10,11,12]]\n in t_normal [[0,7,14],[1,6,11],[2,3,4],[5,9,13],[8,10,12]] == r\n\u003c/pre\u003e",
          "module": "Music.Theory.Tiling.Canon",
          "name": "t_normal",
          "package": "hmt",
          "signature": "T -\u003e T",
          "source": "src/Music-Theory-Tiling-Canon.html#t_normal",
          "type": "function"
        },
        "index": {
          "description": "The normal form of is the min of and it retrograde let in normal",
          "hierarchy": "Music Theory Tiling Canon",
          "module": "Music.Theory.Tiling.Canon",
          "name": "t_normal",
          "normalized": "T-\u003eT",
          "package": "hmt",
          "signature": "T-\u003eT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tiling-Canon.html#v:t_normal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRetrograde of \u003ccode\u003e\u003ca\u003eT\u003c/a\u003e\u003c/code\u003e, the result \u003ccode\u003e\u003ca\u003eT\u003c/a\u003e\u003c/code\u003e is sorted.\n\u003c/p\u003e\u003cpre\u003e let r = [[0,7,14],[1,5,9],[2,4,6],[3,8,13],[10,11,12]]\n in t_retrograde [[0,7,14],[1,6,11],[2,3,4],[5,9,13],[8,10,12]] == r\n\u003c/pre\u003e",
          "module": "Music.Theory.Tiling.Canon",
          "name": "t_retrograde",
          "package": "hmt",
          "signature": "T -\u003e T",
          "source": "src/Music-Theory-Tiling-Canon.html#t_retrograde",
          "type": "function"
        },
        "index": {
          "description": "Retrograde of the result is sorted let in retrograde",
          "hierarchy": "Music Theory Tiling Canon",
          "module": "Music.Theory.Tiling.Canon",
          "name": "t_retrograde",
          "normalized": "T-\u003eT",
          "package": "hmt",
          "signature": "T-\u003eT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tiling-Canon.html#v:t_retrograde"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA \u003ccode\u003e.*\u003c/code\u003e diagram of \u003cem\u003en\u003c/em\u003e places of \u003ccode\u003e\u003ca\u003eV\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e v_dot_star 18 [0,2..] == \"*.*.*.*.*.*.*.*.*.\"\n\u003c/pre\u003e",
          "module": "Music.Theory.Tiling.Canon",
          "name": "v_dot_star",
          "package": "hmt",
          "signature": "Int -\u003e V -\u003e String",
          "source": "src/Music-Theory-Tiling-Canon.html#v_dot_star",
          "type": "function"
        },
        "index": {
          "description": "diagram of places of dot star",
          "hierarchy": "Music Theory Tiling Canon",
          "module": "Music.Theory.Tiling.Canon",
          "name": "v_dot_star",
          "normalized": "Int-\u003eV-\u003eString",
          "package": "hmt",
          "signature": "Int-\u003eV-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tiling-Canon.html#v:v_dot_star"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eVariant with measure length \u003cem\u003em\u003c/em\u003e and number of measures \u003cem\u003en\u003c/em\u003e.\n\u003c/p\u003e\u003cpre\u003e v_dot_star_m 6 3 [0,2..] == \"*.*.*.|*.*.*.|*.*.*.\"\n\u003c/pre\u003e",
          "module": "Music.Theory.Tiling.Canon",
          "name": "v_dot_star_m",
          "package": "hmt",
          "signature": "Int -\u003e Int -\u003e V -\u003e String",
          "source": "src/Music-Theory-Tiling-Canon.html#v_dot_star_m",
          "type": "function"
        },
        "index": {
          "description": "Variant with measure length and number of measures dot star",
          "hierarchy": "Music Theory Tiling Canon",
          "module": "Music.Theory.Tiling.Canon",
          "name": "v_dot_star_m",
          "normalized": "Int-\u003eInt-\u003eV-\u003eString",
          "package": "hmt",
          "signature": "Int-\u003eInt-\u003eV-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tiling-Canon.html#v:v_dot_star_m"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePrint \u003ccode\u003e.*\u003c/code\u003e diagram.\n\u003c/p\u003e",
          "module": "Music.Theory.Tiling.Canon",
          "name": "v_print",
          "package": "hmt",
          "signature": "Int -\u003e [V] -\u003e IO ()",
          "source": "src/Music-Theory-Tiling-Canon.html#v_print",
          "type": "function"
        },
        "index": {
          "description": "Print diagram",
          "hierarchy": "Music Theory Tiling Canon",
          "module": "Music.Theory.Tiling.Canon",
          "name": "v_print",
          "normalized": "Int-\u003e[V]-\u003eIO()",
          "package": "hmt",
          "signature": "Int-\u003e[V]-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tiling-Canon.html#v:v_print"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eVariant to print \u003ccode\u003e|\u003c/code\u003e at measures.\n\u003c/p\u003e",
          "module": "Music.Theory.Tiling.Canon",
          "name": "v_print_m",
          "package": "hmt",
          "signature": "Int -\u003e Int -\u003e [V] -\u003e IO ()",
          "source": "src/Music-Theory-Tiling-Canon.html#v_print_m",
          "type": "function"
        },
        "index": {
          "description": "Variant to print at measures",
          "hierarchy": "Music Theory Tiling Canon",
          "module": "Music.Theory.Tiling.Canon",
          "name": "v_print_m",
          "normalized": "Int-\u003eInt-\u003e[V]-\u003eIO()",
          "package": "hmt",
          "signature": "Int-\u003eInt-\u003e[V]-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tiling-Canon.html#v:v_print_m"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eVariant that discards first \u003cem\u003ek\u003c/em\u003e measures.\n\u003c/p\u003e",
          "module": "Music.Theory.Tiling.Canon",
          "name": "v_print_m_from",
          "package": "hmt",
          "signature": "Int -\u003e Int -\u003e Int -\u003e [V] -\u003e IO ()",
          "source": "src/Music-Theory-Tiling-Canon.html#v_print_m_from",
          "type": "function"
        },
        "index": {
          "description": "Variant that discards first measures",
          "hierarchy": "Music Theory Tiling Canon",
          "module": "Music.Theory.Tiling.Canon",
          "name": "v_print_m_from",
          "normalized": "Int-\u003eInt-\u003eInt-\u003e[V]-\u003eIO()",
          "package": "hmt",
          "signature": "Int-\u003eInt-\u003eInt-\u003e[V]-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tiling-Canon.html#v:v_print_m_from"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA white space and index diagram of \u003cem\u003en\u003c/em\u003e places of \u003ccode\u003e\u003ca\u003eV\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003emapM_ (putStrLn . v_space_ix 9) [[0,2..],[1,3..]]\n\u003c/code\u003e\u003c/strong\u003e\u003e\n\u003e  0   2   4   6   8\n\u003e    1   3   5   7\n\u003c/pre\u003e",
          "module": "Music.Theory.Tiling.Canon",
          "name": "v_space_ix",
          "package": "hmt",
          "signature": "Int -\u003e V -\u003e String",
          "source": "src/Music-Theory-Tiling-Canon.html#v_space_ix",
          "type": "function"
        },
        "index": {
          "description": "white space and index diagram of places of mapM putStrLn space ix",
          "hierarchy": "Music Theory Tiling Canon",
          "module": "Music.Theory.Tiling.Canon",
          "name": "v_space_ix",
          "normalized": "Int-\u003eV-\u003eString",
          "package": "hmt",
          "signature": "Int-\u003eV-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tiling-Canon.html#v:v_space_ix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInsert \u003ccode\u003e|\u003c/code\u003e every \u003cem\u003en\u003c/em\u003e places.\n\u003c/p\u003e\u003cpre\u003e with_bars 6 (v_dot_star 18 [0,2..]) == \"*.*.*.|*.*.*.|*.*.*.\"\n\u003c/pre\u003e",
          "module": "Music.Theory.Tiling.Canon",
          "name": "with_bars",
          "package": "hmt",
          "signature": "Int -\u003e String -\u003e String",
          "source": "src/Music-Theory-Tiling-Canon.html#with_bars",
          "type": "function"
        },
        "index": {
          "description": "Insert every places with bars dot star",
          "hierarchy": "Music Theory Tiling Canon",
          "module": "Music.Theory.Tiling.Canon",
          "name": "with_bars",
          "normalized": "Int-\u003eString-\u003eString",
          "package": "hmt",
          "signature": "Int-\u003eString-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tiling-Canon.html#v:with_bars"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eTom Johnson. \"Perfect Rhythmic Tilings\".\n Technical report, IRCAM, 24 January 2004. MaMuX Lecture.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Music.Theory.Tiling.Johnson_2004",
          "name": "Johnson_2004",
          "package": "hmt",
          "source": "src/Music-Theory-Tiling-Johnson_2004.html",
          "type": "module"
        },
        "index": {
          "description": "Tom Johnson Perfect Rhythmic Tilings Technical report IRCAM January MaMuX Lecture",
          "hierarchy": "Music Theory Tiling Johnson_2004",
          "module": "Music.Theory.Tiling.Johnson_2004",
          "name": "Johnson_2004",
          "package": "hmt",
          "partial": "Johnson",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tiling-Johnson_2004.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e{0,1,2}\u003c/code\u003e order 5, p.1\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003ev_print 15 (r_voices p1)\n\u003c/code\u003e\u003c/strong\u003e\u003e\n\u003e ..***..........\n\u003e ........*.*.*..\n\u003e .....*...*...*.\n\u003e .*....*....*...\n\u003e *......*......*\n\u003c/pre\u003e",
          "module": "Music.Theory.Tiling.Johnson_2004",
          "name": "p1",
          "package": "hmt",
          "signature": "R",
          "source": "src/Music-Theory-Tiling-Johnson_2004.html#p1",
          "type": "function"
        },
        "index": {
          "description": "order p.1 print voices p1",
          "hierarchy": "Music Theory Tiling Johnson_2004",
          "module": "Music.Theory.Tiling.Johnson_2004",
          "name": "p1",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tiling-Johnson_2004.html#v:p1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e{0,1,2}\u003c/code\u003e order 7, p.2\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003ev_print 21 (r_voices p2)\n\u003c/code\u003e\u003c/strong\u003e\u003e\n\u003e ..............***....\n\u003e ..*.*.*..............\n\u003e ...*...*...*.........\n\u003e ........*....*....*..\n\u003e .....*......*......*.\n\u003e .*.......*.......*...\n\u003e *.........*.........*\n\u003c/pre\u003e",
          "module": "Music.Theory.Tiling.Johnson_2004",
          "name": "p2",
          "package": "hmt",
          "signature": "R",
          "source": "src/Music-Theory-Tiling-Johnson_2004.html#p2",
          "type": "function"
        },
        "index": {
          "description": "order p.2 print voices p2",
          "hierarchy": "Music Theory Tiling Johnson_2004",
          "module": "Music.Theory.Tiling.Johnson_2004",
          "name": "p2",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tiling-Johnson_2004.html#v:p2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e{0,1}\u003c/code\u003e order 4, p.3\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003ev_print 8 (r_voices p3)\n\u003c/code\u003e\u003c/strong\u003e\u003e\n\u003e *...*...\n\u003e .**.....\n\u003e ...*..*.\n\u003e .....*.*\n\u003c/pre\u003e",
          "module": "Music.Theory.Tiling.Johnson_2004",
          "name": "p3",
          "package": "hmt",
          "signature": "R",
          "source": "src/Music-Theory-Tiling-Johnson_2004.html#p3",
          "type": "function"
        },
        "index": {
          "description": "order p.3 print voices p3",
          "hierarchy": "Music Theory Tiling Johnson_2004",
          "module": "Music.Theory.Tiling.Johnson_2004",
          "name": "p3",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tiling-Johnson_2004.html#v:p3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e{0,1}\u003c/code\u003e order 5, p.4\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003emapM_ (v_print 10 . r_voices) p4\n\u003c/code\u003e\u003c/strong\u003e\u003e\n\u003e *...*.....\n\u003e .**.......\n\u003e ...*....*.\n\u003e .....*.*..\n\u003e ......*..*\n\u003e\n\u003e *....*....\n\u003e .**.......\n\u003e ...*..*...\n\u003e ....*...*.\n\u003e .......*.*\n\u003e\n\u003e *...*.....\n\u003e .*....*...\n\u003e ..**......\n\u003e .....*..*.\n\u003e .......*.*\n\u003c/pre\u003e",
          "module": "Music.Theory.Tiling.Johnson_2004",
          "name": "p4",
          "package": "hmt",
          "signature": "[R]",
          "source": "src/Music-Theory-Tiling-Johnson_2004.html#p4",
          "type": "function"
        },
        "index": {
          "description": "order p.4 mapM print voices p4",
          "hierarchy": "Music Theory Tiling Johnson_2004",
          "module": "Music.Theory.Tiling.Johnson_2004",
          "name": "p4",
          "normalized": "[R]",
          "package": "hmt",
          "signature": "[R]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tiling-Johnson_2004.html#v:p4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eOpen \u003ccode\u003e{1,2,3}\u003c/code\u003e order 5, p.4\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003ev_print 18 (r_voices p4_b)\n\u003c/code\u003e\u003c/strong\u003e\u003e\n\u003e ...***............\n\u003e ........*.*.*.....\n\u003e .........*...*...*\n\u003e .*....*....*......\n\u003e *......*......*...\n\u003c/pre\u003e",
          "module": "Music.Theory.Tiling.Johnson_2004",
          "name": "p4_b",
          "package": "hmt",
          "signature": "R",
          "source": "src/Music-Theory-Tiling-Johnson_2004.html#p4_b",
          "type": "function"
        },
        "index": {
          "description": "Open order p.4 print voices p4",
          "hierarchy": "Music Theory Tiling Johnson_2004",
          "module": "Music.Theory.Tiling.Johnson_2004",
          "name": "p4_b",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tiling-Johnson_2004.html#v:p4_b"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eTom Johnson. \"Tiling in my Music\".\n \u003cem\u003eThe Experimental Music Yearbook\u003c/em\u003e, 1, 2009.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Music.Theory.Tiling.Johnson_2009",
          "name": "Johnson_2009",
          "package": "hmt",
          "source": "src/Music-Theory-Tiling-Johnson_2009.html",
          "type": "module"
        },
        "index": {
          "description": "Tom Johnson Tiling in my Music The Experimental Music Yearbook",
          "hierarchy": "Music Theory Tiling Johnson_2009",
          "module": "Music.Theory.Tiling.Johnson_2009",
          "name": "Johnson_2009",
          "package": "hmt",
          "partial": "Johnson",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tiling-Johnson_2009.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTilework for Log Drums (2005), p.10\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003ev_print 18 (r_voices p10)\n\u003c/code\u003e\u003c/strong\u003e\u003e\n\u003e *.*.*.............\n\u003e .*...*...*........\n\u003e ...*...*...*......\n\u003e ......*...*...*...\n\u003e ........*...*...*.\n\u003e .............*.*.*\n\u003c/pre\u003e",
          "module": "Music.Theory.Tiling.Johnson_2009",
          "name": "p10",
          "package": "hmt",
          "signature": "R",
          "source": "src/Music-Theory-Tiling-Johnson_2009.html#p10",
          "type": "function"
        },
        "index": {
          "description": "Tilework for Log Drums p.10 print voices p10",
          "hierarchy": "Music Theory Tiling Johnson_2009",
          "module": "Music.Theory.Tiling.Johnson_2009",
          "name": "p10",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tiling-Johnson_2009.html#v:p10"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSelf-Similar Melodies (1996), p.11\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003ev_print_m 20 5 (r_voices p11)\n\u003c/code\u003e\u003c/strong\u003e\u003e\n\u003e *.....*.....*..*..*.|....*.....*.....*...|..*..*..*.....*.....|*.....*.....*..*..*.|....*.....*.....*...\n\u003e ....................|*.....*.....*..*..*.|....*.....*.....*...|..*..*..*.....*.....|*.....*.....*..*..*.\n\u003e ....................|....................|*.....*.....*..*..*.|....*.....*.....*...|..*..*..*.....*.....\n\u003c/pre\u003e",
          "module": "Music.Theory.Tiling.Johnson_2009",
          "name": "p11",
          "package": "hmt",
          "signature": "R",
          "source": "src/Music-Theory-Tiling-Johnson_2009.html#p11",
          "type": "function"
        },
        "index": {
          "description": "Self-Similar Melodies p.11 print voices p11",
          "hierarchy": "Music Theory Tiling Johnson_2009",
          "module": "Music.Theory.Tiling.Johnson_2009",
          "name": "p11",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tiling-Johnson_2009.html#v:p11"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTilework for Clarinet, p.3\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003ev_print 36 (rr_voices p3)\n\u003c/code\u003e\u003c/strong\u003e\u003e\n\u003e *.*..*............*.*..*............\n\u003e .*.*..*............*.*..*...........\n\u003e ........*.*..*............*.*..*....\n\u003e ....*..*.*............*..*.*........\n\u003e ...........*..*.*............*..*.*.\n\u003e ............*..*.*............*..*.*\n\u003c/pre\u003e",
          "module": "Music.Theory.Tiling.Johnson_2009",
          "name": "p3",
          "package": "hmt",
          "signature": "[R]",
          "source": "src/Music-Theory-Tiling-Johnson_2009.html#p3",
          "type": "function"
        },
        "index": {
          "description": "Tilework for Clarinet p.3 print rr voices p3",
          "hierarchy": "Music Theory Tiling Johnson_2009",
          "module": "Music.Theory.Tiling.Johnson_2009",
          "name": "p3",
          "normalized": "[R]",
          "package": "hmt",
          "signature": "[R]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tiling-Johnson_2009.html#v:p3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTilework for String Quartet, p.5\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003emapM_ (v_print 24 . r_voices) p5\n\u003c/code\u003e\u003c/strong\u003e\u003e\n\u003e ******......******......\n\u003e ......******......******\n\u003e\n\u003e *.****.*....*.****.*....\n\u003e ......*.****.*....*.****\n\u003e\n\u003e **.***..*...**.***..*...\n\u003e ......**.***..*...**.***\n\u003e\n\u003e *..***.**...*..***.**...\n\u003e ......*..***.**...*..***\n\u003c/pre\u003e",
          "module": "Music.Theory.Tiling.Johnson_2009",
          "name": "p5",
          "package": "hmt",
          "signature": "[R]",
          "source": "src/Music-Theory-Tiling-Johnson_2009.html#p5",
          "type": "function"
        },
        "index": {
          "description": "Tilework for String Quartet p.5 mapM print voices p5",
          "hierarchy": "Music Theory Tiling Johnson_2009",
          "module": "Music.Theory.Tiling.Johnson_2009",
          "name": "p5",
          "normalized": "[R]",
          "package": "hmt",
          "signature": "[R]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tiling-Johnson_2009.html#v:p5"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExtra Perfect (p.7)\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003ev_print_m_from 18 6 6 (r_voices p7)\n\u003c/code\u003e\u003c/strong\u003e\u003e\n\u003e **.*..|......|......|......|......|......\n\u003e ......|.*.*..|.*....|......|......|......\n\u003e ......|......|......|......|.*..*.|....*.\n\u003e ......|......|...*..|.*....|...*..|......\n\u003e ......|......|....*.|...*..|......|.*....\n\u003e ......|*.....|*.....|......|*.....|......\n\u003e ....*.|......|......|*.....|......|...*..\n\u003e ......|......|......|....*.|......|*.....\n\u003c/pre\u003e",
          "module": "Music.Theory.Tiling.Johnson_2009",
          "name": "p7",
          "package": "hmt",
          "signature": "R",
          "source": "src/Music-Theory-Tiling-Johnson_2009.html#p7",
          "type": "function"
        },
        "index": {
          "description": "Extra Perfect p.7 print from voices p7",
          "hierarchy": "Music Theory Tiling Johnson_2009",
          "module": "Music.Theory.Tiling.Johnson_2009",
          "name": "p7",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tiling-Johnson_2009.html#v:p7"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eTime Signatures.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Music.Theory.Time_Signature",
          "name": "Time_Signature",
          "package": "hmt",
          "source": "src/Music-Theory-Time_Signature.html",
          "type": "module"
        },
        "index": {
          "description": "Time Signatures",
          "hierarchy": "Music Theory Time_Signature",
          "module": "Music.Theory.Time_Signature",
          "name": "Time_Signature",
          "package": "hmt",
          "partial": "Time Signature",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Time_Signature.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA Time Signature is a \u003cem\u003e(numerator,denominator)\u003c/em\u003e pair.\n\u003c/p\u003e",
          "module": "Music.Theory.Time_Signature",
          "name": "Time_Signature",
          "package": "hmt",
          "source": "src/Music-Theory-Time_Signature.html#Time_Signature",
          "type": "type"
        },
        "index": {
          "description": "Time Signature is numerator denominator pair",
          "hierarchy": "Music Theory Time_Signature",
          "module": "Music.Theory.Time_Signature",
          "name": "Time_Signature",
          "package": "hmt",
          "partial": "Time Signature",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Time_Signature.html#t:Time_Signature"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUniform division of time signature.\n\u003c/p\u003e\u003cpre\u003e ts_divisions (3,4) == [1,1,1]\n ts_divisions (3,8) == [1/2,1/2,1/2]\n ts_divisions (2,2) == [2,2]\n ts_divisions (1,1) == [4]\n\u003c/pre\u003e",
          "module": "Music.Theory.Time_Signature",
          "name": "ts_divisions",
          "package": "hmt",
          "signature": "Time_Signature -\u003e [RQ]",
          "source": "src/Music-Theory-Time_Signature.html#ts_divisions",
          "type": "function"
        },
        "index": {
          "description": "Uniform division of time signature ts divisions ts divisions ts divisions ts divisions",
          "hierarchy": "Music Theory Time_Signature",
          "module": "Music.Theory.Time_Signature",
          "name": "ts_divisions",
          "normalized": "Time_Signature-\u003e[RQ]",
          "package": "hmt",
          "signature": "Time_Signature-\u003e[RQ]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Time_Signature.html#v:ts_divisions"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert a duration to a pulse count in relation to the indicated\n   time signature.\n\u003c/p\u003e\u003cpre\u003e ts_duration_pulses (3,8) quarter_note == 2\n\u003c/pre\u003e",
          "module": "Music.Theory.Time_Signature",
          "name": "ts_duration_pulses",
          "package": "hmt",
          "signature": "Time_Signature -\u003e Duration -\u003e Rational",
          "source": "src/Music-Theory-Time_Signature.html#ts_duration_pulses",
          "type": "function"
        },
        "index": {
          "description": "Convert duration to pulse count in relation to the indicated time signature ts duration pulses quarter note",
          "hierarchy": "Music Theory Time_Signature",
          "module": "Music.Theory.Time_Signature",
          "name": "ts_duration_pulses",
          "normalized": "Time_Signature-\u003eDuration-\u003eRational",
          "package": "hmt",
          "signature": "Time_Signature-\u003eDuration-\u003eRational",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Time_Signature.html#v:ts_duration_pulses"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRewrite time signature to indicated denominator.\n\u003c/p\u003e\u003cpre\u003e ts_rewrite 8 (3,4) == (6,8)\n\u003c/pre\u003e",
          "module": "Music.Theory.Time_Signature",
          "name": "ts_rewrite",
          "package": "hmt",
          "signature": "Integer -\u003e Time_Signature -\u003e Time_Signature",
          "source": "src/Music-Theory-Time_Signature.html#ts_rewrite",
          "type": "function"
        },
        "index": {
          "description": "Rewrite time signature to indicated denominator ts rewrite",
          "hierarchy": "Music Theory Time_Signature",
          "module": "Music.Theory.Time_Signature",
          "name": "ts_rewrite",
          "normalized": "Integer-\u003eTime_Signature-\u003eTime_Signature",
          "package": "hmt",
          "signature": "Integer-\u003eTime_Signature-\u003eTime_Signature",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Time_Signature.html#v:ts_rewrite"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDuration, in \u003ccode\u003e\u003ca\u003eRQ\u003c/a\u003e\u003c/code\u003e, of a measure of indicated \u003ccode\u003e\u003ca\u003eTime_Signature\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e map ts_rq [(3,4),(5,8)] == [3,5/2]\n\u003c/pre\u003e",
          "module": "Music.Theory.Time_Signature",
          "name": "ts_rq",
          "package": "hmt",
          "signature": "Time_Signature -\u003e RQ",
          "source": "src/Music-Theory-Time_Signature.html#ts_rq",
          "type": "function"
        },
        "index": {
          "description": "Duration in RQ of measure of indicated Time Signature map ts rq",
          "hierarchy": "Music Theory Time_Signature",
          "module": "Music.Theory.Time_Signature",
          "name": "ts_rq",
          "normalized": "Time_Signature-\u003eRQ",
          "package": "hmt",
          "signature": "Time_Signature-\u003eRQ",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Time_Signature.html#v:ts_rq"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSum time signatures.\n\u003c/p\u003e\u003cpre\u003e ts_sum [(3,16),(1,2)] == (11,16)\n\u003c/pre\u003e",
          "module": "Music.Theory.Time_Signature",
          "name": "ts_sum",
          "package": "hmt",
          "signature": "[Time_Signature] -\u003e Time_Signature",
          "source": "src/Music-Theory-Time_Signature.html#ts_sum",
          "type": "function"
        },
        "index": {
          "description": "Sum time signatures ts sum",
          "hierarchy": "Music Theory Time_Signature",
          "module": "Music.Theory.Time_Signature",
          "name": "ts_sum",
          "normalized": "[Time_Signature]-\u003eTime_Signature",
          "package": "hmt",
          "signature": "[Time_Signature]-\u003eTime_Signature",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Time_Signature.html#v:ts_sum"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTied, non-multiplied durations to fill a whole measure.\n\u003c/p\u003e\u003cpre\u003e ts_whole_note (3,8) == [dotted_quarter_note]\n ts_whole_note (2,2) == [whole_note]\n\u003c/pre\u003e",
          "module": "Music.Theory.Time_Signature",
          "name": "ts_whole_note",
          "package": "hmt",
          "signature": "Time_Signature -\u003e [Duration]",
          "source": "src/Music-Theory-Time_Signature.html#ts_whole_note",
          "type": "function"
        },
        "index": {
          "description": "Tied non-multiplied durations to fill whole measure ts whole note dotted quarter note ts whole note whole note",
          "hierarchy": "Music Theory Time_Signature",
          "module": "Music.Theory.Time_Signature",
          "name": "ts_whole_note",
          "normalized": "Time_Signature-\u003e[Duration]",
          "package": "hmt",
          "signature": "Time_Signature-\u003e[Duration]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Time_Signature.html#v:ts_whole_note"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDuration of measure in \u003ccode\u003e\u003ca\u003eRQ\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e map ts_whole_note_rq [(3,8),(2,2)] == [3/2,4]\n\u003c/pre\u003e",
          "module": "Music.Theory.Time_Signature",
          "name": "ts_whole_note_rq",
          "package": "hmt",
          "signature": "Time_Signature -\u003e RQ",
          "source": "src/Music-Theory-Time_Signature.html#ts_whole_note_rq",
          "type": "function"
        },
        "index": {
          "description": "Duration of measure in RQ map ts whole note rq",
          "hierarchy": "Music Theory Time_Signature",
          "module": "Music.Theory.Time_Signature",
          "name": "ts_whole_note_rq",
          "normalized": "Time_Signature-\u003eRQ",
          "package": "hmt",
          "signature": "Time_Signature-\u003eRQ",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Time_Signature.html#v:ts_whole_note_rq"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eBill Alves. \"Pleng: Composing for a Justly Tuned Gender\n Barung\". 1/1: Journal of the Just Intonation Network, 1:4-11, Spring\n 1997.  \u003ca\u003ehttp://www2.hmc.edu/~alves/pleng.html\u003c/a\u003e\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Music.Theory.Tuning.Alves_1997",
          "name": "Alves_1997",
          "package": "hmt",
          "source": "src/Music-Theory-Tuning-Alves_1997.html",
          "type": "module"
        },
        "index": {
          "description": "Bill Alves Pleng Composing for Justly Tuned Gender Barung Journal of the Just Intonation Network Spring http www2.hmc.edu alves pleng.html",
          "hierarchy": "Music Theory Tuning Alves_1997",
          "module": "Music.Theory.Tuning.Alves_1997",
          "name": "Alves_1997",
          "package": "hmt",
          "partial": "Alves",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tuning-Alves_1997.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eHMC \u003cem\u003epelog barang\u003c/em\u003e tuning.\n\u003c/p\u003e\u003cpre\u003e cents_i alves_pelog_23467 == [0,386,471,702,969]\n\u003c/pre\u003e",
          "module": "Music.Theory.Tuning.Alves_1997",
          "name": "alves_pelog_23467",
          "package": "hmt",
          "signature": "Tuning",
          "source": "src/Music-Theory-Tuning-Alves_1997.html#alves_pelog_23467",
          "type": "function"
        },
        "index": {
          "description": "HMC pelog barang tuning cents alves pelog",
          "hierarchy": "Music Theory Tuning Alves_1997",
          "module": "Music.Theory.Tuning.Alves_1997",
          "name": "alves_pelog_23467",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tuning-Alves_1997.html#v:alves_pelog_23467"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Tuning.Alves_1997",
          "name": "alves_pelog_23467_r",
          "package": "hmt",
          "signature": "[Rational]",
          "source": "src/Music-Theory-Tuning-Alves_1997.html#alves_pelog_23467_r",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Tuning Alves_1997",
          "module": "Music.Theory.Tuning.Alves_1997",
          "name": "alves_pelog_23467_r",
          "normalized": "[Rational]",
          "package": "hmt",
          "signature": "[Rational]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tuning-Alves_1997.html#v:alves_pelog_23467_r"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eHMC \u003cem\u003epelog 2,3,4,6,7\u003c/em\u003e tuning.\n\u003c/p\u003e\u003cpre\u003e cents_i alves_pelog_barang == [0,386,471,857,969]\n\u003c/pre\u003e",
          "module": "Music.Theory.Tuning.Alves_1997",
          "name": "alves_pelog_barang",
          "package": "hmt",
          "signature": "Tuning",
          "source": "src/Music-Theory-Tuning-Alves_1997.html#alves_pelog_barang",
          "type": "function"
        },
        "index": {
          "description": "HMC pelog tuning cents alves pelog barang",
          "hierarchy": "Music Theory Tuning Alves_1997",
          "module": "Music.Theory.Tuning.Alves_1997",
          "name": "alves_pelog_barang",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tuning-Alves_1997.html#v:alves_pelog_barang"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Tuning.Alves_1997",
          "name": "alves_pelog_barang_r",
          "package": "hmt",
          "signature": "[Rational]",
          "source": "src/Music-Theory-Tuning-Alves_1997.html#alves_pelog_barang_r",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Tuning Alves_1997",
          "module": "Music.Theory.Tuning.Alves_1997",
          "name": "alves_pelog_barang_r",
          "normalized": "[Rational]",
          "package": "hmt",
          "signature": "[Rational]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tuning-Alves_1997.html#v:alves_pelog_barang_r"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eHMC \u003cem\u003epelog bem\u003c/em\u003e tuning.\n\u003c/p\u003e\u003cpre\u003e cents_i alves_pelog_bem == [0,231,316,702,814]\n\u003c/pre\u003e",
          "module": "Music.Theory.Tuning.Alves_1997",
          "name": "alves_pelog_bem",
          "package": "hmt",
          "signature": "Tuning",
          "source": "src/Music-Theory-Tuning-Alves_1997.html#alves_pelog_bem",
          "type": "function"
        },
        "index": {
          "description": "HMC pelog bem tuning cents alves pelog bem",
          "hierarchy": "Music Theory Tuning Alves_1997",
          "module": "Music.Theory.Tuning.Alves_1997",
          "name": "alves_pelog_bem",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tuning-Alves_1997.html#v:alves_pelog_bem"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Tuning.Alves_1997",
          "name": "alves_pelog_bem_r",
          "package": "hmt",
          "signature": "[Rational]",
          "source": "src/Music-Theory-Tuning-Alves_1997.html#alves_pelog_bem_r",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Tuning Alves_1997",
          "module": "Music.Theory.Tuning.Alves_1997",
          "name": "alves_pelog_bem_r",
          "normalized": "[Rational]",
          "package": "hmt",
          "signature": "[Rational]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tuning-Alves_1997.html#v:alves_pelog_bem_r"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eHMC \u003cem\u003eslendro\u003c/em\u003e tuning.\n\u003c/p\u003e\u003cpre\u003e cents_i alves_slendro == [0,231,498,765,996]\n\u003c/pre\u003e",
          "module": "Music.Theory.Tuning.Alves_1997",
          "name": "alves_slendro",
          "package": "hmt",
          "signature": "Tuning",
          "source": "src/Music-Theory-Tuning-Alves_1997.html#alves_slendro",
          "type": "function"
        },
        "index": {
          "description": "HMC slendro tuning cents alves slendro",
          "hierarchy": "Music Theory Tuning Alves_1997",
          "module": "Music.Theory.Tuning.Alves_1997",
          "name": "alves_slendro",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tuning-Alves_1997.html#v:alves_slendro"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Tuning.Alves_1997",
          "name": "alves_slendro_r",
          "package": "hmt",
          "signature": "[Rational]",
          "source": "src/Music-Theory-Tuning-Alves_1997.html#alves_slendro_r",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Tuning Alves_1997",
          "module": "Music.Theory.Tuning.Alves_1997",
          "name": "alves_slendro_r",
          "normalized": "[Rational]",
          "package": "hmt",
          "signature": "[Rational]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tuning-Alves_1997.html#v:alves_slendro_r"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eMax Meyer. \"The musician's arithmetic: drill problems for an\n introduction to the scientific study of musical composition.\" The\n University of Missouri, 1929.  p.22\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Music.Theory.Tuning.Meyer_1929",
          "name": "Meyer_1929",
          "package": "hmt",
          "source": "src/Music-Theory-Tuning-Meyer_1929.html",
          "type": "module"
        },
        "index": {
          "description": "Max Meyer The musician arithmetic drill problems for an introduction to the scientific study of musical composition The University of Missouri p.22",
          "hierarchy": "Music Theory Tuning Meyer_1929",
          "module": "Music.Theory.Tuning.Meyer_1929",
          "name": "Meyer_1929",
          "package": "hmt",
          "partial": "Meyer",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tuning-Meyer_1929.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGenerate initial column for \u003cem\u003en\u003c/em\u003e.\n\u003c/p\u003e\u003cpre\u003e column 7 == [1,8/5,4/3,8/7]\n\u003c/pre\u003e",
          "module": "Music.Theory.Tuning.Meyer_1929",
          "name": "column",
          "package": "hmt",
          "signature": "i -\u003e [Ratio i]",
          "source": "src/Music-Theory-Tuning-Meyer_1929.html#column",
          "type": "function"
        },
        "index": {
          "description": "Generate initial column for column",
          "hierarchy": "Music Theory Tuning Meyer_1929",
          "module": "Music.Theory.Tuning.Meyer_1929",
          "name": "column",
          "normalized": "a-\u003e[Ratio a]",
          "package": "hmt",
          "signature": "i-\u003e[Ratio i]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tuning-Meyer_1929.html#v:column"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eNumber of unique elements at \u003cem\u003en\u003c/em\u003e table.\n\u003c/p\u003e\u003cpre\u003e map degree [7,9,11,13,15] == [13,19,29,41,49]\n\u003c/pre\u003e",
          "module": "Music.Theory.Tuning.Meyer_1929",
          "name": "degree",
          "package": "hmt",
          "signature": "i -\u003e i",
          "source": "src/Music-Theory-Tuning-Meyer_1929.html#degree",
          "type": "function"
        },
        "index": {
          "description": "Number of unique elements at table map degree",
          "hierarchy": "Music Theory Tuning Meyer_1929",
          "module": "Music.Theory.Tuning.Meyer_1929",
          "name": "degree",
          "normalized": "a-\u003ea",
          "package": "hmt",
          "signature": "i-\u003ei",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tuning-Meyer_1929.html#v:degree"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSet of unique ratios in \u003cem\u003en\u003c/em\u003e table.\n\u003c/p\u003e\u003cpre\u003e elements 7 == [1,8/7,7/6,6/5,5/4,4/3,7/5,10/7,3/2,8/5,5/3,12/7,7/4]\n\u003c/pre\u003e\u003cpre\u003e elements 9 == [1,10/9,9/8,8/7,7/6,6/5,5/4,9/7,4/3,7/5,10/7\n               ,3/2,14/9,8/5,5/3,12/7,7/4,16/9,9/5]\n\u003c/pre\u003e",
          "module": "Music.Theory.Tuning.Meyer_1929",
          "name": "elements",
          "package": "hmt",
          "signature": "i -\u003e [Ratio i]",
          "source": "src/Music-Theory-Tuning-Meyer_1929.html#elements",
          "type": "function"
        },
        "index": {
          "description": "Set of unique ratios in table elements elements",
          "hierarchy": "Music Theory Tuning Meyer_1929",
          "module": "Music.Theory.Tuning.Meyer_1929",
          "name": "elements",
          "normalized": "a-\u003e[Ratio a]",
          "package": "hmt",
          "signature": "i-\u003e[Ratio i]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tuning-Meyer_1929.html#v:elements"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ca\u003ehttp://en.wikipedia.org/wiki/Farey_sequence\u003c/a\u003e\n\u003c/p\u003e\u003cpre\u003e let r = [[0,1/2,1]\n         ,[0,1/3,1/2,2/3,1]\n         ,[0,1/4,1/3,1/2,2/3,3/4,1]\n         ,[0,1/5,1/4,1/3,2/5,1/2,3/5,2/3,3/4,4/5,1]\n         ,[0,1/6,1/5,1/4,1/3,2/5,1/2,3/5,2/3,3/4,4/5,5/6,1]]\n in map farey_sequence [2..6] == r\n\u003c/pre\u003e",
          "module": "Music.Theory.Tuning.Meyer_1929",
          "name": "farey_sequence",
          "package": "hmt",
          "signature": "a -\u003e [Ratio a]",
          "source": "src/Music-Theory-Tuning-Meyer_1929.html#farey_sequence",
          "type": "function"
        },
        "index": {
          "description": "http en.wikipedia.org wiki Farey sequence let in map farey sequence",
          "hierarchy": "Music Theory Tuning Meyer_1929",
          "module": "Music.Theory.Tuning.Meyer_1929",
          "name": "farey_sequence",
          "normalized": "a-\u003e[Ratio a]",
          "package": "hmt",
          "signature": "a-\u003e[Ratio a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tuning-Meyer_1929.html#v:farey_sequence"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003efold_to_octave\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e*\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Music.Theory.Tuning.Meyer_1929",
          "name": "in_oct_mul",
          "package": "hmt",
          "signature": "Ratio i -\u003e Ratio i -\u003e Ratio i",
          "source": "src/Music-Theory-Tuning-Meyer_1929.html#in_oct_mul",
          "type": "function"
        },
        "index": {
          "description": "fold to octave",
          "hierarchy": "Music Theory Tuning Meyer_1929",
          "module": "Music.Theory.Tuning.Meyer_1929",
          "name": "in_oct_mul",
          "normalized": "Ratio a-\u003eRatio a-\u003eRatio a",
          "package": "hmt",
          "signature": "Ratio i-\u003eRatio i-\u003eRatio i",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tuning-Meyer_1929.html#v:in_oct_mul"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGiven \u003cem\u003erow\u003c/em\u003e and \u003cem\u003ecolumn\u003c/em\u003e generate matrix value at \u003cem\u003e(i,j)\u003c/em\u003e.\n\u003c/p\u003e\u003cpre\u003e inner (row 7,column 7) (1,2) == 6/5\n\u003c/pre\u003e",
          "module": "Music.Theory.Tuning.Meyer_1929",
          "name": "inner",
          "package": "hmt",
          "signature": "([Ratio i], [Ratio i]) -\u003e (i, i) -\u003e Ratio i",
          "source": "src/Music-Theory-Tuning-Meyer_1929.html#inner",
          "type": "function"
        },
        "index": {
          "description": "Given row and column generate matrix value at inner row column",
          "hierarchy": "Music Theory Tuning Meyer_1929",
          "module": "Music.Theory.Tuning.Meyer_1929",
          "name": "inner",
          "normalized": "([Ratio a],[Ratio a])-\u003e(a,a)-\u003eRatio a",
          "package": "hmt",
          "signature": "([Ratio i],[Ratio i])-\u003e(i,i)-\u003eRatio i",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tuning-Meyer_1929.html#v:inner"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMeyer table in form \u003cem\u003e(r,c,n)\u003c/em\u003e.\n\u003c/p\u003e\u003cpre\u003e meyer_table_indices 7 == [(0,0,1/1),(0,1,5/4),(0,2,3/2),(0,3,7/4)\n                          ,(1,0,8/5),(1,1,1/1),(1,2,6/5),(1,3,7/5)\n                          ,(2,0,4/3),(2,1,5/3),(2,2,1/1),(2,3,7/6)\n                          ,(3,0,8/7),(3,1,10/7),(3,2,12/7),(3,3,1/1)]\n\u003c/pre\u003e",
          "module": "Music.Theory.Tuning.Meyer_1929",
          "name": "meyer_table_indices",
          "package": "hmt",
          "signature": "i -\u003e [(i, i, Ratio i)]",
          "source": "src/Music-Theory-Tuning-Meyer_1929.html#meyer_table_indices",
          "type": "function"
        },
        "index": {
          "description": "Meyer table in form meyer table indices",
          "hierarchy": "Music Theory Tuning Meyer_1929",
          "module": "Music.Theory.Tuning.Meyer_1929",
          "name": "meyer_table_indices",
          "normalized": "a-\u003e[(a,a,Ratio a)]",
          "package": "hmt",
          "signature": "i-\u003e[(i,i,Ratio i)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tuning-Meyer_1929.html#v:meyer_table_indices"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Tuning.Meyer_1929",
          "name": "meyer_table_rck",
          "package": "hmt",
          "signature": "i -\u003e ([Ratio i], [Ratio i], i)",
          "source": "src/Music-Theory-Tuning-Meyer_1929.html#meyer_table_rck",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Tuning Meyer_1929",
          "module": "Music.Theory.Tuning.Meyer_1929",
          "name": "meyer_table_rck",
          "normalized": "a-\u003e([Ratio a],[Ratio a],a)",
          "package": "hmt",
          "signature": "i-\u003e([Ratio i],[Ratio i],i)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tuning-Meyer_1929.html#v:meyer_table_rck"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMeyer table as set of rows.\n\u003c/p\u003e\u003cpre\u003e meyer_table_rows 7 == [[1/1, 5/4, 3/2,7/4]\n                       ,[8/5, 1/1, 6/5,7/5]\n                       ,[4/3, 5/3, 1/1,7/6]\n                       ,[8/7,10/7,12/7,1/1]]\n\u003c/pre\u003e\u003cpre\u003e let r = [[ 1/1,   9/8,   5/4,  11/8,   3/2,  13/8,   7/4,  15/8]\n         ,[16/9,   1/1,  10/9,  11/9,   4/3,  13/9,  14/9,   5/3]\n         ,[ 8/5,   9/5,   1/1,  11/10,  6/5,  13/10,  7/5,   3/2]\n         ,[16/11, 18/11, 20/11,  1/1,  12/11, 13/11, 14/11, 15/11]\n         ,[ 4/3,   3/2,   5/3,  11/6,   1/1,  13/12,  7/6,   5/4]\n         ,[16/13, 18/13, 20/13, 22/13, 24/13,  1/1,  14/13, 15/13]\n         ,[ 8/7,   9/7,   10/7, 11/7,  12/7,  13/7,   1/1,  15/14]\n         ,[16/15,  6/5,    4/3, 22/15,  8/5,  26/15, 28/15,  1/1]]\n in meyer_table_rows 15 == r\n\u003c/pre\u003e",
          "module": "Music.Theory.Tuning.Meyer_1929",
          "name": "meyer_table_rows",
          "package": "hmt",
          "signature": "a -\u003e [[Ratio a]]",
          "source": "src/Music-Theory-Tuning-Meyer_1929.html#meyer_table_rows",
          "type": "function"
        },
        "index": {
          "description": "Meyer table as set of rows meyer table rows let in meyer table rows",
          "hierarchy": "Music Theory Tuning Meyer_1929",
          "module": "Music.Theory.Tuning.Meyer_1929",
          "name": "meyer_table_rows",
          "normalized": "a-\u003e[[Ratio a]]",
          "package": "hmt",
          "signature": "a-\u003e[[Ratio a]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tuning-Meyer_1929.html#v:meyer_table_rows"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eOdd numbers to \u003cem\u003en\u003c/em\u003e.\n\u003c/p\u003e\u003cpre\u003e odd_to 7 == [1,3,5,7]\n\u003c/pre\u003e",
          "module": "Music.Theory.Tuning.Meyer_1929",
          "name": "odd_to",
          "package": "hmt",
          "signature": "t -\u003e [t]",
          "source": "src/Music-Theory-Tuning-Meyer_1929.html#odd_to",
          "type": "function"
        },
        "index": {
          "description": "Odd numbers to odd to",
          "hierarchy": "Music Theory Tuning Meyer_1929",
          "module": "Music.Theory.Tuning.Meyer_1929",
          "name": "odd_to",
          "normalized": "a-\u003e[a]",
          "package": "hmt",
          "signature": "t-\u003e[t]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tuning-Meyer_1929.html#v:odd_to"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGenerate initial row for \u003cem\u003en\u003c/em\u003e.\n\u003c/p\u003e\u003cpre\u003e row 7 == [1,5/4,3/2,7/4]\n\u003c/pre\u003e",
          "module": "Music.Theory.Tuning.Meyer_1929",
          "name": "row",
          "package": "hmt",
          "signature": "i -\u003e [Ratio i]",
          "source": "src/Music-Theory-Tuning-Meyer_1929.html#row",
          "type": "function"
        },
        "index": {
          "description": "Generate initial row for row",
          "hierarchy": "Music Theory Tuning Meyer_1929",
          "module": "Music.Theory.Tuning.Meyer_1929",
          "name": "row",
          "normalized": "a-\u003e[Ratio a]",
          "package": "hmt",
          "signature": "i-\u003e[Ratio i]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tuning-Meyer_1929.html#v:row"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThird element of three-tuple.\n\u003c/p\u003e",
          "module": "Music.Theory.Tuning.Meyer_1929",
          "name": "t3_3",
          "package": "hmt",
          "signature": "(t1, t2, t3) -\u003e t3",
          "source": "src/Music-Theory-Tuning-Meyer_1929.html#t3_3",
          "type": "function"
        },
        "index": {
          "description": "Third element of three-tuple",
          "hierarchy": "Music Theory Tuning Meyer_1929",
          "module": "Music.Theory.Tuning.Meyer_1929",
          "name": "t3_3",
          "normalized": "(a,a,a)-\u003ea",
          "package": "hmt",
          "signature": "(t,t,t)-\u003et",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tuning-Meyer_1929.html#v:t3_3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eLarry Polansky. \"Psaltery (for Lou Harrison)\". Frog Peak Music,\n 1978.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Music.Theory.Tuning.Polansky_1978",
          "name": "Polansky_1978",
          "package": "hmt",
          "source": "src/Music-Theory-Tuning-Polansky_1978.html",
          "type": "module"
        },
        "index": {
          "description": "Larry Polansky Psaltery for Lou Harrison Frog Peak Music",
          "hierarchy": "Music Theory Tuning Polansky_1978",
          "module": "Music.Theory.Tuning.Polansky_1978",
          "name": "Polansky_1978",
          "package": "hmt",
          "partial": "Polansky",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tuning-Polansky_1978.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThree interlocking harmonic series on 1:5:3, by Larry Polansky in\n \"Psaltery\".\n\u003c/p\u003e\u003cpre\u003e import qualified Music.Theory.Tuning.Scala as T\n let fn = \"/home/rohan/opt/scala/scl/polansky_ps.scl\"\n s \u003c- T.load fn\n T.scale_pitch_representations s == (0,50)\n 1 : Data.Either.rights (T.scale_pitches s) == psaltery\n\u003c/pre\u003e",
          "module": "Music.Theory.Tuning.Polansky_1978",
          "name": "psaltery",
          "package": "hmt",
          "signature": "[Rational]",
          "source": "src/Music-Theory-Tuning-Polansky_1978.html#psaltery",
          "type": "function"
        },
        "index": {
          "description": "Three interlocking harmonic series on by Larry Polansky in Psaltery import qualified Music.Theory.Tuning.Scala as let fn home rohan opt scala scl polansky ps.scl T.load fn T.scale pitch representations Data.Either.rights T.scale pitches psaltery",
          "hierarchy": "Music Theory Tuning Polansky_1978",
          "module": "Music.Theory.Tuning.Polansky_1978",
          "name": "psaltery",
          "normalized": "[Rational]",
          "package": "hmt",
          "signature": "[Rational]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tuning-Polansky_1978.html#v:psaltery"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003efold_ratio_to_octave\u003c/a\u003e\u003c/code\u003e of \u003ccode\u003e\u003ca\u003epsaltery\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e length psaltery == 51 && length psaltery_o == 21\n psaltery_o == [1,65/64,33/32,17/16,35/32,9/8,75/64,39/32\n               ,5/4,21/16,85/64,11/8,45/32\n               ,3/2,25/16,51/32,13/8,27/16,55/32,7/4,15/8]\n\u003c/pre\u003e",
          "module": "Music.Theory.Tuning.Polansky_1978",
          "name": "psaltery_o",
          "package": "hmt",
          "signature": "[Rational]",
          "source": "src/Music-Theory-Tuning-Polansky_1978.html#psaltery_o",
          "type": "function"
        },
        "index": {
          "description": "fold ratio to octave of psaltery length psaltery length psaltery psaltery",
          "hierarchy": "Music Theory Tuning Polansky_1978",
          "module": "Music.Theory.Tuning.Polansky_1978",
          "name": "psaltery_o",
          "normalized": "[Rational]",
          "package": "hmt",
          "signature": "[Rational]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tuning-Polansky_1978.html#v:psaltery_o"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eLarry Polansky. \"Tuning Systems in American Gamelan, Part I:\n Interval Sizes in Javanese Slendro\". \u003cem\u003eBalungan\u003c/em\u003e, 1(2):9-11, 1984\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Music.Theory.Tuning.Polansky_1984",
          "name": "Polansky_1984",
          "package": "hmt",
          "source": "src/Music-Theory-Tuning-Polansky_1984.html",
          "type": "module"
        },
        "index": {
          "description": "Larry Polansky Tuning Systems in American Gamelan Part Interval Sizes in Javanese Slendro Balungan",
          "hierarchy": "Music Theory Tuning Polansky_1984",
          "module": "Music.Theory.Tuning.Polansky_1984",
          "name": "Polansky_1984",
          "package": "hmt",
          "partial": "Polansky",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tuning-Polansky_1984.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGiven a set of equal length lists calculate the average value of\n each position.\n\u003c/p\u003e\u003cpre\u003e calculate_averages [[1,2,3],[3,2,1]] == [2,2,2]\n\u003c/pre\u003e",
          "module": "Music.Theory.Tuning.Polansky_1984",
          "name": "calculate_averages",
          "package": "hmt",
          "signature": "[[n]] -\u003e [n]",
          "source": "src/Music-Theory-Tuning-Polansky_1984.html#calculate_averages",
          "type": "function"
        },
        "index": {
          "description": "Given set of equal length lists calculate the average value of each position calculate averages",
          "hierarchy": "Music Theory Tuning Polansky_1984",
          "module": "Music.Theory.Tuning.Polansky_1984",
          "name": "calculate_averages",
          "normalized": "[[a]]-\u003e[a]",
          "package": "hmt",
          "signature": "[[n]]-\u003e[n]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tuning-Polansky_1984.html#v:calculate_averages"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Tuning.Polansky_1984",
          "name": "gm_1",
          "package": "hmt",
          "signature": "[n]",
          "source": "src/Music-Theory-Tuning-Polansky_1984.html#gm_1",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Tuning Polansky_1984",
          "module": "Music.Theory.Tuning.Polansky_1984",
          "name": "gm_1",
          "normalized": "[a]",
          "package": "hmt",
          "signature": "[n]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tuning-Polansky_1984.html#v:gm_1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Tuning.Polansky_1984",
          "name": "gm_2",
          "package": "hmt",
          "signature": "[n]",
          "source": "src/Music-Theory-Tuning-Polansky_1984.html#gm_2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Tuning Polansky_1984",
          "module": "Music.Theory.Tuning.Polansky_1984",
          "name": "gm_2",
          "normalized": "[a]",
          "package": "hmt",
          "signature": "[n]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tuning-Polansky_1984.html#v:gm_2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Tuning.Polansky_1984",
          "name": "gm_3",
          "package": "hmt",
          "signature": "[n]",
          "source": "src/Music-Theory-Tuning-Polansky_1984.html#gm_3",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Tuning Polansky_1984",
          "module": "Music.Theory.Tuning.Polansky_1984",
          "name": "gm_3",
          "normalized": "[a]",
          "package": "hmt",
          "signature": "[n]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tuning-Polansky_1984.html#v:gm_3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Tuning.Polansky_1984",
          "name": "gm_4",
          "package": "hmt",
          "signature": "[n]",
          "source": "src/Music-Theory-Tuning-Polansky_1984.html#gm_4",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Tuning Polansky_1984",
          "module": "Music.Theory.Tuning.Polansky_1984",
          "name": "gm_4",
          "normalized": "[a]",
          "package": "hmt",
          "signature": "[n]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tuning-Polansky_1984.html#v:gm_4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Tuning.Polansky_1984",
          "name": "gm_5",
          "package": "hmt",
          "signature": "[n]",
          "source": "src/Music-Theory-Tuning-Polansky_1984.html#gm_5",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Tuning Polansky_1984",
          "module": "Music.Theory.Tuning.Polansky_1984",
          "name": "gm_5",
          "normalized": "[a]",
          "package": "hmt",
          "signature": "[n]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tuning-Polansky_1984.html#v:gm_5"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Tuning.Polansky_1984",
          "name": "gm_6",
          "package": "hmt",
          "signature": "[n]",
          "source": "src/Music-Theory-Tuning-Polansky_1984.html#gm_6",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Tuning Polansky_1984",
          "module": "Music.Theory.Tuning.Polansky_1984",
          "name": "gm_6",
          "normalized": "[a]",
          "package": "hmt",
          "signature": "[n]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tuning-Polansky_1984.html#v:gm_6"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Tuning.Polansky_1984",
          "name": "gm_7",
          "package": "hmt",
          "signature": "[n]",
          "source": "src/Music-Theory-Tuning-Polansky_1984.html#gm_7",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Tuning Polansky_1984",
          "module": "Music.Theory.Tuning.Polansky_1984",
          "name": "gm_7",
          "normalized": "[a]",
          "package": "hmt",
          "signature": "[n]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tuning-Polansky_1984.html#v:gm_7"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Tuning.Polansky_1984",
          "name": "gm_8",
          "package": "hmt",
          "signature": "[n]",
          "source": "src/Music-Theory-Tuning-Polansky_1984.html#gm_8",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Tuning Polansky_1984",
          "module": "Music.Theory.Tuning.Polansky_1984",
          "name": "gm_8",
          "normalized": "[a]",
          "package": "hmt",
          "signature": "[n]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tuning-Polansky_1984.html#v:gm_8"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAverages of \u003cem\u003eGM\u003c/em\u003e set, p. 10.\n\u003c/p\u003e\u003cpre\u003e gm_averages == [234.0,240.25,247.625,243.125,254.0625]\n\u003c/pre\u003e",
          "module": "Music.Theory.Tuning.Polansky_1984",
          "name": "gm_averages",
          "package": "hmt",
          "signature": "[n]",
          "source": "src/Music-Theory-Tuning-Polansky_1984.html#gm_averages",
          "type": "function"
        },
        "index": {
          "description": "Averages of GM set gm averages",
          "hierarchy": "Music Theory Tuning Polansky_1984",
          "module": "Music.Theory.Tuning.Polansky_1984",
          "name": "gm_averages",
          "normalized": "[a]",
          "package": "hmt",
          "signature": "[n]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tuning-Polansky_1984.html#v:gm_averages"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe set of \u003cem\u003eGM\u003c/em\u003e (Gadja Mada University) slendro tunings.\n\u003c/p\u003e\u003cpre\u003e map length gm_set == replicate (length gm_set) 5\n minimum (concat gm_set) == 218\n maximum (concat gm_set) == 262\n\u003c/pre\u003e",
          "module": "Music.Theory.Tuning.Polansky_1984",
          "name": "gm_set",
          "package": "hmt",
          "signature": "[[n]]",
          "source": "src/Music-Theory-Tuning-Polansky_1984.html#gm_set",
          "type": "function"
        },
        "index": {
          "description": "The set of GM Gadja Mada University slendro tunings map length gm set replicate length gm set minimum concat gm set maximum concat gm set",
          "hierarchy": "Music Theory Tuning Polansky_1984",
          "module": "Music.Theory.Tuning.Polansky_1984",
          "name": "gm_set",
          "normalized": "[[a]]",
          "package": "hmt",
          "signature": "[[n]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tuning-Polansky_1984.html#v:gm_set"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAssociation list giving interval boundaries for interval class\n categories (pp.10-11).\n\u003c/p\u003e",
          "module": "Music.Theory.Tuning.Polansky_1984",
          "name": "i_categories",
          "package": "hmt",
          "signature": "[((n, n), String)]",
          "source": "src/Music-Theory-Tuning-Polansky_1984.html#i_categories",
          "type": "function"
        },
        "index": {
          "description": "Association list giving interval boundaries for interval class categories pp.10-11",
          "hierarchy": "Music Theory Tuning Polansky_1984",
          "module": "Music.Theory.Tuning.Polansky_1984",
          "name": "i_categories",
          "normalized": "[((a,a),String)]",
          "package": "hmt",
          "signature": "[((n,n),String)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tuning-Polansky_1984.html#v:i_categories"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCategorise an interval.\n\u003c/p\u003e",
          "module": "Music.Theory.Tuning.Polansky_1984",
          "name": "i_category",
          "package": "hmt",
          "signature": "a -\u003e String",
          "source": "src/Music-Theory-Tuning-Polansky_1984.html#i_category",
          "type": "function"
        },
        "index": {
          "description": "Categorise an interval",
          "hierarchy": "Music Theory Tuning Polansky_1984",
          "module": "Music.Theory.Tuning.Polansky_1984",
          "name": "i_category",
          "normalized": "a-\u003eString",
          "package": "hmt",
          "signature": "a-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tuning-Polansky_1984.html#v:i_category"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePretty interval category table (pp. 10-11).\n\u003c/p\u003e\u003cpre\u003e i_category_table k_set ==\n  [\"S    L    S    S    L  \"\n  ,\"S    L    S    S    L  \"\n  ,\"L    L    S    S    S  \"\n  ,\"L    S    S    S    L  \"\n  ,\"S    S    L    S    L  \"\n  ,\"S    E-L  S    L    L  \"\n  ,\"L    E    E    S    S  \"\n  ,\"S    S    S-E  L    L  \"]\n\u003c/pre\u003e\u003cpre\u003e i_category_table gm_set ==\n  [\"S    L    E-L  E    L  \"\n  ,\"L    S-E  E    S    L  \"\n  ,\"S    S-E  S    L    S-E\"\n  ,\"S    L    L    S    L  \"\n  ,\"S    S-E  E-L  S    L  \"\n  ,\"S    S-E  E    E    L  \"\n  ,\"S-E  S    L    E    L  \"\n  ,\"S    S    E-L  L    L  \"]\n\u003c/pre\u003e",
          "module": "Music.Theory.Tuning.Polansky_1984",
          "name": "i_category_table",
          "package": "hmt",
          "signature": "[[a]] -\u003e [String]",
          "source": "src/Music-Theory-Tuning-Polansky_1984.html#i_category_table",
          "type": "function"
        },
        "index": {
          "description": "Pretty interval category table pp category table set E-L S-E category table gm set E-L S-E S-E S-E S-E E-L S-E S-E E-L",
          "hierarchy": "Music Theory Tuning Polansky_1984",
          "module": "Music.Theory.Tuning.Polansky_1984",
          "name": "i_category_table",
          "normalized": "[[a]]-\u003e[String]",
          "package": "hmt",
          "signature": "[[a]]-\u003e[String]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tuning-Polansky_1984.html#v:i_category_table"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAverages of \u003cem\u003eK\u003c/em\u003e set, p. 10.\n\u003c/p\u003e\u003cpre\u003e k_averages == [233.8125,245.0625,234.0,240.8125,251.875]\n\u003c/pre\u003e",
          "module": "Music.Theory.Tuning.Polansky_1984",
          "name": "k_averages",
          "package": "hmt",
          "signature": "[n]",
          "source": "src/Music-Theory-Tuning-Polansky_1984.html#k_averages",
          "type": "function"
        },
        "index": {
          "description": "Averages of set averages",
          "hierarchy": "Music Theory Tuning Polansky_1984",
          "module": "Music.Theory.Tuning.Polansky_1984",
          "name": "k_averages",
          "normalized": "[a]",
          "package": "hmt",
          "signature": "[n]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tuning-Polansky_1984.html#v:k_averages"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Tuning.Polansky_1984",
          "name": "k_hardjanagara",
          "package": "hmt",
          "signature": "[n]",
          "source": "src/Music-Theory-Tuning-Polansky_1984.html#k_hardjanagara",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Tuning Polansky_1984",
          "module": "Music.Theory.Tuning.Polansky_1984",
          "name": "k_hardjanagara",
          "normalized": "[a]",
          "package": "hmt",
          "signature": "[n]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tuning-Polansky_1984.html#v:k_hardjanagara"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Tuning.Polansky_1984",
          "name": "k_kanjutmesem",
          "package": "hmt",
          "signature": "[n]",
          "source": "src/Music-Theory-Tuning-Polansky_1984.html#k_kanjutmesem",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Tuning Polansky_1984",
          "module": "Music.Theory.Tuning.Polansky_1984",
          "name": "k_kanjutmesem",
          "normalized": "[a]",
          "package": "hmt",
          "signature": "[n]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tuning-Polansky_1984.html#v:k_kanjutmesem"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Tuning.Polansky_1984",
          "name": "k_madukentir",
          "package": "hmt",
          "signature": "[n]",
          "source": "src/Music-Theory-Tuning-Polansky_1984.html#k_madukentir",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Tuning Polansky_1984",
          "module": "Music.Theory.Tuning.Polansky_1984",
          "name": "k_madukentir",
          "normalized": "[a]",
          "package": "hmt",
          "signature": "[n]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tuning-Polansky_1984.html#v:k_madukentir"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Tuning.Polansky_1984",
          "name": "k_manisrenga",
          "package": "hmt",
          "signature": "[n]",
          "source": "src/Music-Theory-Tuning-Polansky_1984.html#k_manisrenga",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Tuning Polansky_1984",
          "module": "Music.Theory.Tuning.Polansky_1984",
          "name": "k_manisrenga",
          "normalized": "[a]",
          "package": "hmt",
          "signature": "[n]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tuning-Polansky_1984.html#v:k_manisrenga"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Tuning.Polansky_1984",
          "name": "k_pengawesari",
          "package": "hmt",
          "signature": "[n]",
          "source": "src/Music-Theory-Tuning-Polansky_1984.html#k_pengawesari",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Tuning Polansky_1984",
          "module": "Music.Theory.Tuning.Polansky_1984",
          "name": "k_pengawesari",
          "normalized": "[a]",
          "package": "hmt",
          "signature": "[n]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tuning-Polansky_1984.html#v:k_pengawesari"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Tuning.Polansky_1984",
          "name": "k_rarasrum",
          "package": "hmt",
          "signature": "[n]",
          "source": "src/Music-Theory-Tuning-Polansky_1984.html#k_rarasrum",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Tuning Polansky_1984",
          "module": "Music.Theory.Tuning.Polansky_1984",
          "name": "k_rarasrum",
          "normalized": "[a]",
          "package": "hmt",
          "signature": "[n]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tuning-Polansky_1984.html#v:k_rarasrum"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe set of \u003cem\u003eK\u003c/em\u003e slendro tunings.\n\u003c/p\u003e\u003cpre\u003e map length k_set == replicate (length k_set) 5\n minimum (concat k_set) == 206\n maximum (concat k_set) == 268.5\n\u003c/pre\u003e",
          "module": "Music.Theory.Tuning.Polansky_1984",
          "name": "k_set",
          "package": "hmt",
          "signature": "[[n]]",
          "source": "src/Music-Theory-Tuning-Polansky_1984.html#k_set",
          "type": "function"
        },
        "index": {
          "description": "The set of slendro tunings map length set replicate length set minimum concat set maximum concat set",
          "hierarchy": "Music Theory Tuning Polansky_1984",
          "module": "Music.Theory.Tuning.Polansky_1984",
          "name": "k_set",
          "normalized": "[[a]]",
          "package": "hmt",
          "signature": "[[n]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tuning-Polansky_1984.html#v:k_set"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Tuning.Polansky_1984",
          "name": "k_surak",
          "package": "hmt",
          "signature": "[n]",
          "source": "src/Music-Theory-Tuning-Polansky_1984.html#k_surak",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Tuning Polansky_1984",
          "module": "Music.Theory.Tuning.Polansky_1984",
          "name": "k_surak",
          "normalized": "[a]",
          "package": "hmt",
          "signature": "[n]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tuning-Polansky_1984.html#v:k_surak"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Tuning.Polansky_1984",
          "name": "k_udanriris",
          "package": "hmt",
          "signature": "[n]",
          "source": "src/Music-Theory-Tuning-Polansky_1984.html#k_udanriris",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Tuning Polansky_1984",
          "module": "Music.Theory.Tuning.Polansky_1984",
          "name": "k_udanriris",
          "normalized": "[a]",
          "package": "hmt",
          "signature": "[n]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tuning-Polansky_1984.html#v:k_udanriris"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePad \u003ccode\u003e\u003ca\u003eString\u003c/a\u003e\u003c/code\u003e to right with spaces until at least \u003cem\u003en\u003c/em\u003e characters.\n\u003c/p\u003e\u003cpre\u003e map (pad 3) [\"S\",\"E-L\"] == [\"S  \",\"E-L\"]\n\u003c/pre\u003e",
          "module": "Music.Theory.Tuning.Polansky_1984",
          "name": "pad",
          "package": "hmt",
          "signature": "Int -\u003e String -\u003e String",
          "source": "src/Music-Theory-Tuning-Polansky_1984.html#pad",
          "type": "function"
        },
        "index": {
          "description": "Pad String to right with spaces until at least characters map pad E-L E-L",
          "hierarchy": "Music Theory Tuning Polansky_1984",
          "module": "Music.Theory.Tuning.Polansky_1984",
          "name": "pad",
          "normalized": "Int-\u003eString-\u003eString",
          "package": "hmt",
          "signature": "Int-\u003eString-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tuning-Polansky_1984.html#v:pad"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eto_cents_r\u003c/a\u003e\u003c/code\u003e of \u003ccode\u003e\u003ca\u003epolansky_1984_r\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e import Music.Theory.List\n map round (d_dx polansky_1984_c) == [231,240,223,240,231]\n\u003c/pre\u003e",
          "module": "Music.Theory.Tuning.Polansky_1984",
          "name": "polansky_1984_c",
          "package": "hmt",
          "signature": "[Cents]",
          "source": "src/Music-Theory-Tuning-Polansky_1984.html#polansky_1984_c",
          "type": "function"
        },
        "index": {
          "description": "to cents of polansky import Music.Theory.List map round dx polansky",
          "hierarchy": "Music Theory Tuning Polansky_1984",
          "module": "Music.Theory.Tuning.Polansky_1984",
          "name": "polansky_1984_c",
          "normalized": "[Cents]",
          "package": "hmt",
          "signature": "[Cents]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tuning-Polansky_1984.html#v:polansky_1984_c"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRational tuning derived from \u003ccode\u003e\u003ca\u003egm_averages\u003c/a\u003e\u003c/code\u003e, p.11.\n\u003c/p\u003e\u003cpre\u003e polansky_1984_r == sort polansky_1984_r\n polansky_1984_r == [1/1,8/7,21/16,512/343,12/7,96/49]\n\u003c/pre\u003e\u003cpre\u003e import Music.Theory.List\n d_dx polansky_1984_r == [1/7,19/112,989/5488,76/343,12/49]\n\u003c/pre\u003e",
          "module": "Music.Theory.Tuning.Polansky_1984",
          "name": "polansky_1984_r",
          "package": "hmt",
          "signature": "[Rational]",
          "source": "src/Music-Theory-Tuning-Polansky_1984.html#polansky_1984_r",
          "type": "function"
        },
        "index": {
          "description": "Rational tuning derived from gm averages p.11 polansky sort polansky polansky import Music.Theory.List dx polansky",
          "hierarchy": "Music Theory Tuning Polansky_1984",
          "module": "Music.Theory.Tuning.Polansky_1984",
          "name": "polansky_1984_r",
          "normalized": "[Rational]",
          "package": "hmt",
          "signature": "[Rational]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tuning-Polansky_1984.html#v:polansky_1984_r"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eLarry Polansky. \"Notes on the Tunings of Three Central Javanese\n Slendro/Pelog Pairs\". \u003cem\u003eExperimental Musical Instruments\u003c/em\u003e,\n 6(2):12-13,16-17, 1990.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Music.Theory.Tuning.Polansky_1990",
          "name": "Polansky_1990",
          "package": "hmt",
          "source": "src/Music-Theory-Tuning-Polansky_1990.html",
          "type": "module"
        },
        "index": {
          "description": "Larry Polansky Notes on the Tunings of Three Central Javanese Slendro Pelog Pairs Experimental Musical Instruments",
          "hierarchy": "Music Theory Tuning Polansky_1990",
          "module": "Music.Theory.Tuning.Polansky_1990",
          "name": "Polansky_1990",
          "package": "hmt",
          "partial": "Polansky",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tuning-Polansky_1990.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReconstruct approximate ratios to within \u003ccode\u003e1e-3\u003c/code\u003e from intervals.\n\u003c/p\u003e",
          "module": "Music.Theory.Tuning.Polansky_1990",
          "name": "ax_r",
          "package": "hmt",
          "signature": "[n] -\u003e [Rational]",
          "source": "src/Music-Theory-Tuning-Polansky_1990.html#ax_r",
          "type": "function"
        },
        "index": {
          "description": "Reconstruct approximate ratios to within e-3 from intervals",
          "hierarchy": "Music Theory Tuning Polansky_1990",
          "module": "Music.Theory.Tuning.Polansky_1990",
          "name": "ax_r",
          "normalized": "[a]-\u003e[Rational]",
          "package": "hmt",
          "signature": "[n]-\u003e[Rational]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tuning-Polansky_1990.html#v:ax_r"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDarius Slendro (S1,S2,S3,S5,S6,S1')\n\u003c/p\u003e\u003cpre\u003e L.d_dx darius_s == [204,231,267,231,267]\n ax_r darius_s == [9/8,8/7,7/6,8/7,7/6]\n\u003c/pre\u003e",
          "module": "Music.Theory.Tuning.Polansky_1990",
          "name": "darius_s",
          "package": "hmt",
          "signature": "[n]",
          "source": "src/Music-Theory-Tuning-Polansky_1990.html#darius_s",
          "type": "function"
        },
        "index": {
          "description": "Darius Slendro S1 S2 S3 S5 S6 S1 L.d dx darius ax darius",
          "hierarchy": "Music Theory Tuning Polansky_1990",
          "module": "Music.Theory.Tuning.Polansky_1990",
          "name": "darius_s",
          "normalized": "[a]",
          "package": "hmt",
          "signature": "[n]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tuning-Polansky_1990.html#v:darius_s"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIdealized ET Pelog, subset of 9-tone equal temperament (p.17)\n\u003c/p\u003e\u003cpre\u003e L.d_dx idealized_et_p == [400/3,800/3,400/3,400/3,400/3,400/3,800/3]\n\u003c/pre\u003e",
          "module": "Music.Theory.Tuning.Polansky_1990",
          "name": "idealized_et_p",
          "package": "hmt",
          "signature": "[Ratio n]",
          "source": "src/Music-Theory-Tuning-Polansky_1990.html#idealized_et_p",
          "type": "function"
        },
        "index": {
          "description": "Idealized ET Pelog subset of tone equal temperament p.17 L.d dx idealized et",
          "hierarchy": "Music Theory Tuning Polansky_1990",
          "module": "Music.Theory.Tuning.Polansky_1990",
          "name": "idealized_et_p",
          "normalized": "[Ratio a]",
          "package": "hmt",
          "signature": "[Ratio n]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tuning-Polansky_1990.html#v:idealized_et_p"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIdealized ET Slendro, 5-tone equal temperament (p.17)\n\u003c/p\u003e\u003cpre\u003e L.d_dx idealized_et_s == [240,240,240,240,240]\n\u003c/pre\u003e",
          "module": "Music.Theory.Tuning.Polansky_1990",
          "name": "idealized_et_s",
          "package": "hmt",
          "signature": "[n]",
          "source": "src/Music-Theory-Tuning-Polansky_1990.html#idealized_et_s",
          "type": "function"
        },
        "index": {
          "description": "Idealized ET Slendro tone equal temperament p.17 L.d dx idealized et",
          "hierarchy": "Music Theory Tuning Polansky_1990",
          "module": "Music.Theory.Tuning.Polansky_1990",
          "name": "idealized_et_s",
          "normalized": "[a]",
          "package": "hmt",
          "signature": "[n]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tuning-Polansky_1990.html#v:idealized_et_s"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eKanjutmesem Pelog (P1,P2,P3,P4,P5,P6,P7,P1')\n\u003c/p\u003e\u003cpre\u003e L.d_dx kanjutmesem_p == [141,141,272,140,115,172,246]\n\u003c/pre\u003e",
          "module": "Music.Theory.Tuning.Polansky_1990",
          "name": "kanjutmesem_p",
          "package": "hmt",
          "signature": "[n]",
          "source": "src/Music-Theory-Tuning-Polansky_1990.html#kanjutmesem_p",
          "type": "function"
        },
        "index": {
          "description": "Kanjutmesem Pelog P1 P2 P3 P4 P5 P6 P7 P1 L.d dx kanjutmesem",
          "hierarchy": "Music Theory Tuning Polansky_1990",
          "module": "Music.Theory.Tuning.Polansky_1990",
          "name": "kanjutmesem_p",
          "normalized": "[a]",
          "package": "hmt",
          "signature": "[n]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tuning-Polansky_1990.html#v:kanjutmesem_p"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eKanjutmesem Slendro (S1,S2,S3,S5,S6,S1')\n\u003c/p\u003e\u003cpre\u003e L.d_dx kanjutmesem_s == [252,238,241,236,253]\n\u003c/pre\u003e",
          "module": "Music.Theory.Tuning.Polansky_1990",
          "name": "kanjutmesem_s",
          "package": "hmt",
          "signature": "[n]",
          "source": "src/Music-Theory-Tuning-Polansky_1990.html#kanjutmesem_s",
          "type": "function"
        },
        "index": {
          "description": "Kanjutmesem Slendro S1 S2 S3 S5 S6 S1 L.d dx kanjutmesem",
          "hierarchy": "Music Theory Tuning Polansky_1990",
          "module": "Music.Theory.Tuning.Polansky_1990",
          "name": "kanjutmesem_s",
          "normalized": "[a]",
          "package": "hmt",
          "signature": "[n]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tuning-Polansky_1990.html#v:kanjutmesem_s"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLipur Sih Pelog (P1,P2,P3,P4,P5,P6,P7,P1')\n\u003c/p\u003e\u003cpre\u003e L.d_dx lipur_sih_p == [110,153,253,146,113,179]\n\u003c/pre\u003e",
          "module": "Music.Theory.Tuning.Polansky_1990",
          "name": "lipur_sih_p",
          "package": "hmt",
          "signature": "[n]",
          "source": "src/Music-Theory-Tuning-Polansky_1990.html#lipur_sih_p",
          "type": "function"
        },
        "index": {
          "description": "Lipur Sih Pelog P1 P2 P3 P4 P5 P6 P7 P1 L.d dx lipur sih",
          "hierarchy": "Music Theory Tuning Polansky_1990",
          "module": "Music.Theory.Tuning.Polansky_1990",
          "name": "lipur_sih_p",
          "normalized": "[a]",
          "package": "hmt",
          "signature": "[n]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tuning-Polansky_1990.html#v:lipur_sih_p"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLipur Sih Slendro (S1,S2,S3,S5,S6,S1')\n\u003c/p\u003e\u003cpre\u003e L.d_dx lipur_sih_s == [273,236,224,258,256]\n\u003c/pre\u003e",
          "module": "Music.Theory.Tuning.Polansky_1990",
          "name": "lipur_sih_s",
          "package": "hmt",
          "signature": "[n]",
          "source": "src/Music-Theory-Tuning-Polansky_1990.html#lipur_sih_s",
          "type": "function"
        },
        "index": {
          "description": "Lipur Sih Slendro S1 S2 S3 S5 S6 S1 L.d dx lipur sih",
          "hierarchy": "Music Theory Tuning Polansky_1990",
          "module": "Music.Theory.Tuning.Polansky_1990",
          "name": "lipur_sih_s",
          "normalized": "[a]",
          "package": "hmt",
          "signature": "[n]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tuning-Polansky_1990.html#v:lipur_sih_s"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMadeleine Pelog (P1,P2,P3,P4,P5,P6,P7,P1')\n\u003c/p\u003e\u003cpre\u003e L.d_dx madeleine_p == [139,128,336,99,94,173,231]\n ax_r madeleine_p == [13/12,14/13,17/14,18/17,19/18,21/19,8/7]\n\u003c/pre\u003e",
          "module": "Music.Theory.Tuning.Polansky_1990",
          "name": "madeleine_p",
          "package": "hmt",
          "signature": "[n]",
          "source": "src/Music-Theory-Tuning-Polansky_1990.html#madeleine_p",
          "type": "function"
        },
        "index": {
          "description": "Madeleine Pelog P1 P2 P3 P4 P5 P6 P7 P1 L.d dx madeleine ax madeleine",
          "hierarchy": "Music Theory Tuning Polansky_1990",
          "module": "Music.Theory.Tuning.Polansky_1990",
          "name": "madeleine_p",
          "normalized": "[a]",
          "package": "hmt",
          "signature": "[n]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tuning-Polansky_1990.html#v:madeleine_p"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eParser for the Scala scale file format.  See\n \u003ca\u003ehttp://www.huygens-fokker.org/scala/scl_format.html\u003c/a\u003e for details.\n This module succesfully parses all 4115 scales in v.77 of the scale\n library.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Music.Theory.Tuning.Scala",
          "name": "Scala",
          "package": "hmt",
          "source": "src/Music-Theory-Tuning-Scala.html",
          "type": "module"
        },
        "index": {
          "description": "Parser for the Scala scale file format See http www.huygens-fokker.org scala scl format.html for details This module succesfully parses all scales in v.77 of the scale library",
          "hierarchy": "Music Theory Tuning Scala",
          "module": "Music.Theory.Tuning.Scala",
          "name": "Scala",
          "package": "hmt",
          "partial": "Scala",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tuning-Scala.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Tuning.Scala",
          "name": "Epsilon",
          "package": "hmt",
          "source": "src/Music-Theory-Tuning-Scala.html#Epsilon",
          "type": "type"
        },
        "index": {
          "hierarchy": "Music Theory Tuning Scala",
          "module": "Music.Theory.Tuning.Scala",
          "name": "Epsilon",
          "package": "hmt",
          "partial": "Epsilon",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tuning-Scala.html#t:Epsilon"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA \u003ccode\u003e.scl\u003c/code\u003e pitch is either in \u003ccode\u003eCents\u003c/code\u003e or is a \u003ccode\u003e\u003ca\u003eRatio\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Music.Theory.Tuning.Scala",
          "name": "Pitch",
          "package": "hmt",
          "source": "src/Music-Theory-Tuning-Scala.html#Pitch",
          "type": "type"
        },
        "index": {
          "description": "scl pitch is either in Cents or is Ratio",
          "hierarchy": "Music Theory Tuning Scala",
          "module": "Music.Theory.Tuning.Scala",
          "name": "Pitch",
          "package": "hmt",
          "partial": "Pitch",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tuning-Scala.html#t:Pitch"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA scale has a description, a degree, and a list of \u003ccode\u003e\u003ca\u003ePitch\u003c/a\u003e\u003c/code\u003ees.\n\u003c/p\u003e",
          "module": "Music.Theory.Tuning.Scala",
          "name": "Scale",
          "package": "hmt",
          "source": "src/Music-Theory-Tuning-Scala.html#Scale",
          "type": "type"
        },
        "index": {
          "description": "scale has description degree and list of Pitch es",
          "hierarchy": "Music Theory Tuning Scala",
          "module": "Music.Theory.Tuning.Scala",
          "name": "Scale",
          "package": "hmt",
          "partial": "Scale",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tuning-Scala.html#t:Scale"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eComment lines being with \u003ccode\u003e!\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Music.Theory.Tuning.Scala",
          "name": "comment_p",
          "package": "hmt",
          "signature": "String -\u003e Bool",
          "source": "src/Music-Theory-Tuning-Scala.html#comment_p",
          "type": "function"
        },
        "index": {
          "description": "Comment lines being with",
          "hierarchy": "Music Theory Tuning Scala",
          "module": "Music.Theory.Tuning.Scala",
          "name": "comment_p",
          "normalized": "String-\u003eBool",
          "package": "hmt",
          "signature": "String-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tuning-Scala.html#v:comment_p"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDelete trailing \u003ccode\u003e.\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eread\u003c/a\u003e\u003c/code\u003e fails for \u003ccode\u003e700.\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Music.Theory.Tuning.Scala",
          "name": "delete_trailing_point",
          "package": "hmt",
          "signature": "String -\u003e String",
          "source": "src/Music-Theory-Tuning-Scala.html#delete_trailing_point",
          "type": "function"
        },
        "index": {
          "description": "Delete trailing read fails for",
          "hierarchy": "Music Theory Tuning Scala",
          "module": "Music.Theory.Tuning.Scala",
          "name": "delete_trailing_point",
          "normalized": "String-\u003eString",
          "package": "hmt",
          "signature": "String-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tuning-Scala.html#v:delete_trailing_point"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSubset of files in \u003cem\u003edir\u003c/em\u003e with an extension in \u003cem\u003eext\u003c/em\u003e.\n\u003c/p\u003e",
          "module": "Music.Theory.Tuning.Scala",
          "name": "dir_subset",
          "package": "hmt",
          "signature": "[String] -\u003e FilePath -\u003e IO [FilePath]",
          "source": "src/Music-Theory-Tuning-Scala.html#dir_subset",
          "type": "function"
        },
        "index": {
          "description": "Subset of files in dir with an extension in ext",
          "hierarchy": "Music Theory Tuning Scala",
          "module": "Music.Theory.Tuning.Scala",
          "name": "dir_subset",
          "normalized": "[String]-\u003eFilePath-\u003eIO[FilePath]",
          "package": "hmt",
          "signature": "[String]-\u003eFilePath-\u003eIO[FilePath]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tuning-Scala.html#v:dir_subset"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRemove comments and null lines.\n\u003c/p\u003e\u003cpre\u003e filter_comments [\"!a\",\"b\",\"\",\"c\"] == [\"b\",\"c\"]\n\u003c/pre\u003e",
          "module": "Music.Theory.Tuning.Scala",
          "name": "filter_comments",
          "package": "hmt",
          "signature": "[String] -\u003e [String]",
          "source": "src/Music-Theory-Tuning-Scala.html#filter_comments",
          "type": "function"
        },
        "index": {
          "description": "Remove comments and null lines filter comments",
          "hierarchy": "Music Theory Tuning Scala",
          "module": "Music.Theory.Tuning.Scala",
          "name": "filter_comments",
          "normalized": "[String]-\u003e[String]",
          "package": "hmt",
          "signature": "[String]-\u003e[String]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tuning-Scala.html#v:filter_comments"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRemove \u003ccode\u003er\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Music.Theory.Tuning.Scala",
          "name": "filter_cr",
          "package": "hmt",
          "signature": "String -\u003e String",
          "source": "src/Music-Theory-Tuning-Scala.html#filter_cr",
          "type": "function"
        },
        "index": {
          "description": "Remove",
          "hierarchy": "Music Theory Tuning Scala",
          "module": "Music.Theory.Tuning.Scala",
          "name": "filter_cr",
          "normalized": "String-\u003eString",
          "package": "hmt",
          "signature": "String-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tuning-Scala.html#v:filter_cr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLoad \u003ccode\u003e.scl\u003c/code\u003e file.\n\u003c/p\u003e\u003cpre\u003e s \u003c- load \"/home/rohan/opt/scala/scl/xenakis_chrom.scl\"\n scale_pitch_representations s == (6,1)\n scale_ratios 1e-3 s == [1,21/20,29/23,179/134,280/187,11/7,100/53,2]\n\u003c/pre\u003e",
          "module": "Music.Theory.Tuning.Scala",
          "name": "load",
          "package": "hmt",
          "signature": "FilePath -\u003e IO (Scale i)",
          "source": "src/Music-Theory-Tuning-Scala.html#load",
          "type": "function"
        },
        "index": {
          "description": "Load scl file load home rohan opt scala scl xenakis chrom.scl scale pitch representations scale ratios e-3",
          "hierarchy": "Music Theory Tuning Scala",
          "module": "Music.Theory.Tuning.Scala",
          "name": "load",
          "normalized": "FilePath-\u003eIO(Scale a)",
          "package": "hmt",
          "signature": "FilePath-\u003eIO(Scale i)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tuning-Scala.html#v:load"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLoad all \u003ccode\u003e.scl\u003c/code\u003e files at \u003cem\u003edir\u003c/em\u003e.\n\u003c/p\u003e\u003cpre\u003e db \u003c- load_dir \"/home/rohan/opt/scala/scl\"\n length db == 4115\n length (filter ((== 0) . scale_degree) db) == 1\n length (filter (== Just (Right 2)) (map scale_octave db)) == 3562\n\u003c/pre\u003e\u003cpre\u003e let r = [0,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24\n         ,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44\n         ,45,46,47,48,49,50,51,53,54,55,56,57,58,59,60,61,62,63,64\n         ,65,66,67,68,69,70,71,72,74,75,77,78,79,80,81,84,87,88\n         ,90,91,92,95,96,99,100,101,105,110,112,117,118,130,140,171\n         ,180,271,311,342,366,441,612]\n in nub (sort (map scale_degree db)) == r\n\u003c/pre\u003e\u003cpre\u003e let r = [\"Xenakis's Byzantine Liturgical mode, 5 + 19 + 6 parts\"\n         ,\"Xenakis's Byzantine Liturgical mode, 12 + 11 + 7 parts\"\n         ,\"Xenakis's Byzantine Liturgical mode, 7 + 16 + 7 parts\"]\n in filter (isInfixOf \"Xenakis\") (map scale_description db) == r\n\u003c/pre\u003e\u003cpre\u003e length (filter (not . perfect_octave) db) == 544\n\u003c/pre\u003e\u003cpre\u003e mapM_ (putStrLn.scale_description) (filter (not . perfect_octave) db)\n\u003c/pre\u003e",
          "module": "Music.Theory.Tuning.Scala",
          "name": "load_dir",
          "package": "hmt",
          "signature": "FilePath -\u003e IO [Scale i]",
          "source": "src/Music-Theory-Tuning-Scala.html#load_dir",
          "type": "function"
        },
        "index": {
          "description": "Load all scl files at dir db load dir home rohan opt scala scl length db length filter scale degree db length filter Just Right map scale octave db let in nub sort map scale degree db let Xenakis Byzantine Liturgical mode parts Xenakis Byzantine Liturgical mode parts Xenakis Byzantine Liturgical mode parts in filter isInfixOf Xenakis map scale description db length filter not perfect octave db mapM putStrLn.scale description filter not perfect octave db",
          "hierarchy": "Music Theory Tuning Scala",
          "module": "Music.Theory.Tuning.Scala",
          "name": "load_dir",
          "normalized": "FilePath-\u003eIO[Scale a]",
          "package": "hmt",
          "signature": "FilePath-\u003eIO[Scale i]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tuning-Scala.html#v:load_dir"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLogical \u003cem\u003eor\u003c/em\u003e of list of predicates.\n\u003c/p\u003e",
          "module": "Music.Theory.Tuning.Scala",
          "name": "p_or",
          "package": "hmt",
          "signature": "[a -\u003e Bool] -\u003e a -\u003e Bool",
          "source": "src/Music-Theory-Tuning-Scala.html#p_or",
          "type": "function"
        },
        "index": {
          "description": "Logical or of list of predicates",
          "hierarchy": "Music Theory Tuning Scala",
          "module": "Music.Theory.Tuning.Scala",
          "name": "p_or",
          "normalized": "[a-\u003eBool]-\u003ea-\u003eBool",
          "package": "hmt",
          "signature": "[a-\u003eBool]-\u003ea-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tuning-Scala.html#v:p_or"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eParse \u003ccode\u003e.scl\u003c/code\u003e file.\n\u003c/p\u003e",
          "module": "Music.Theory.Tuning.Scala",
          "name": "parse",
          "package": "hmt",
          "signature": "String -\u003e Scale i",
          "source": "src/Music-Theory-Tuning-Scala.html#parse",
          "type": "function"
        },
        "index": {
          "description": "Parse scl file",
          "hierarchy": "Music Theory Tuning Scala",
          "module": "Music.Theory.Tuning.Scala",
          "name": "parse",
          "normalized": "String-\u003eScale a",
          "package": "hmt",
          "signature": "String-\u003eScale i",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tuning-Scala.html#v:parse"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIs \u003ccode\u003e\u003ca\u003escale_octave\u003c/a\u003e\u003c/code\u003e perfect, ie. \u003ccode\u003e\u003ca\u003eRatio\u003c/a\u003e\u003c/code\u003e of \u003ccode\u003e2\u003c/code\u003e or \u003ccode\u003eCents\u003c/code\u003e of\n \u003ccode\u003e1200\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Music.Theory.Tuning.Scala",
          "name": "perfect_octave",
          "package": "hmt",
          "signature": "Scale i -\u003e Bool",
          "source": "src/Music-Theory-Tuning-Scala.html#perfect_octave",
          "type": "function"
        },
        "index": {
          "description": "Is scale octave perfect ie Ratio of or Cents of",
          "hierarchy": "Music Theory Tuning Scala",
          "module": "Music.Theory.Tuning.Scala",
          "name": "perfect_octave",
          "normalized": "Scale a-\u003eBool",
          "package": "hmt",
          "signature": "Scale i-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tuning-Scala.html#v:perfect_octave"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePitches are either cents (with decimal point) or ratios (with \u003ccode\u003e/\u003c/code\u003e).\n\u003c/p\u003e\u003cpre\u003e map pitch [\"700.0\",\"3/2\",\"2\"] == [Left 700,Right (3/2),Right 2]\n\u003c/pre\u003e",
          "module": "Music.Theory.Tuning.Scala",
          "name": "pitch",
          "package": "hmt",
          "signature": "String -\u003e Pitch i",
          "source": "src/Music-Theory-Tuning-Scala.html#pitch",
          "type": "function"
        },
        "index": {
          "description": "Pitches are either cents with decimal point or ratios with map pitch Left Right Right",
          "hierarchy": "Music Theory Tuning Scala",
          "module": "Music.Theory.Tuning.Scala",
          "name": "pitch",
          "normalized": "String-\u003ePitch a",
          "package": "hmt",
          "signature": "String-\u003ePitch i",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tuning-Scala.html#v:pitch"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePitch as \u003ccode\u003e\u003ca\u003eCents\u003c/a\u003e\u003c/code\u003e, conversion by \u003ccode\u003e\u003ca\u003eto_cents_r\u003c/a\u003e\u003c/code\u003e if necessary.\n\u003c/p\u003e",
          "module": "Music.Theory.Tuning.Scala",
          "name": "pitch_cents",
          "package": "hmt",
          "signature": "Pitch Integer -\u003e Cents",
          "source": "src/Music-Theory-Tuning-Scala.html#pitch_cents",
          "type": "function"
        },
        "index": {
          "description": "Pitch as Cents conversion by to cents if necessary",
          "hierarchy": "Music Theory Tuning Scala",
          "module": "Music.Theory.Tuning.Scala",
          "name": "pitch_cents",
          "normalized": "Pitch Integer-\u003eCents",
          "package": "hmt",
          "signature": "Pitch Integer-\u003eCents",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tuning-Scala.html#v:pitch_cents"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePitch lines may contain commentary.\n\u003c/p\u003e",
          "module": "Music.Theory.Tuning.Scala",
          "name": "pitch_ln",
          "package": "hmt",
          "signature": "String -\u003e Pitch i",
          "source": "src/Music-Theory-Tuning-Scala.html#pitch_ln",
          "type": "function"
        },
        "index": {
          "description": "Pitch lines may contain commentary",
          "hierarchy": "Music Theory Tuning Scala",
          "module": "Music.Theory.Tuning.Scala",
          "name": "pitch_ln",
          "normalized": "String-\u003ePitch a",
          "package": "hmt",
          "signature": "String-\u003ePitch i",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tuning-Scala.html#v:pitch_ln"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePitch as \u003ccode\u003e\u003ca\u003eRational\u003c/a\u003e\u003c/code\u003e, conversion by \u003ccode\u003e\u003ca\u003ereconstructed_ratio\u003c/a\u003e\u003c/code\u003e if\n necessary, hence \u003cem\u003eepsilon\u003c/em\u003e.\n\u003c/p\u003e",
          "module": "Music.Theory.Tuning.Scala",
          "name": "pitch_ratio",
          "package": "hmt",
          "signature": "Epsilon -\u003e Pitch Integer -\u003e Rational",
          "source": "src/Music-Theory-Tuning-Scala.html#pitch_ratio",
          "type": "function"
        },
        "index": {
          "description": "Pitch as Rational conversion by reconstructed ratio if necessary hence epsilon",
          "hierarchy": "Music Theory Tuning Scala",
          "module": "Music.Theory.Tuning.Scala",
          "name": "pitch_ratio",
          "normalized": "Epsilon-\u003ePitch Integer-\u003eRational",
          "package": "hmt",
          "signature": "Epsilon-\u003ePitch Integer-\u003eRational",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tuning-Scala.html#v:pitch_ratio"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRemove to end of line \u003ccode\u003e!\u003c/code\u003e comments.\n\u003c/p\u003e",
          "module": "Music.Theory.Tuning.Scala",
          "name": "remove_eol_comments",
          "package": "hmt",
          "signature": "String -\u003e String",
          "source": "src/Music-Theory-Tuning-Scala.html#remove_eol_comments",
          "type": "function"
        },
        "index": {
          "description": "Remove to end of line comments",
          "hierarchy": "Music Theory Tuning Scala",
          "module": "Music.Theory.Tuning.Scala",
          "name": "remove_eol_comments",
          "normalized": "String-\u003eString",
          "package": "hmt",
          "signature": "String-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tuning-Scala.html#v:remove_eol_comments"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eScale as list of \u003ccode\u003e\u003ca\u003eCents\u003c/a\u003e\u003c/code\u003e (ie. \u003ccode\u003e\u003ca\u003epitch_cents\u003c/a\u003e\u003c/code\u003e) with \u003ccode\u003e0\u003c/code\u003e prefix.\n\u003c/p\u003e",
          "module": "Music.Theory.Tuning.Scala",
          "name": "scale_cents",
          "package": "hmt",
          "signature": "Scale Integer -\u003e [Cents]",
          "source": "src/Music-Theory-Tuning-Scala.html#scale_cents",
          "type": "function"
        },
        "index": {
          "description": "Scale as list of Cents ie pitch cents with prefix",
          "hierarchy": "Music Theory Tuning Scala",
          "module": "Music.Theory.Tuning.Scala",
          "name": "scale_cents",
          "normalized": "Scale Integer-\u003e[Cents]",
          "package": "hmt",
          "signature": "Scale Integer-\u003e[Cents]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tuning-Scala.html#v:scale_cents"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe degree of the scale (number of \u003ccode\u003e\u003ca\u003ePitch\u003c/a\u003e\u003c/code\u003ees).\n\u003c/p\u003e",
          "module": "Music.Theory.Tuning.Scala",
          "name": "scale_degree",
          "package": "hmt",
          "signature": "Scale i -\u003e i",
          "source": "src/Music-Theory-Tuning-Scala.html#scale_degree",
          "type": "function"
        },
        "index": {
          "description": "The degree of the scale number of Pitch es",
          "hierarchy": "Music Theory Tuning Scala",
          "module": "Music.Theory.Tuning.Scala",
          "name": "scale_degree",
          "normalized": "Scale a-\u003ea",
          "package": "hmt",
          "signature": "Scale i-\u003ei",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tuning-Scala.html#v:scale_degree"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eText description of scale.\n\u003c/p\u003e",
          "module": "Music.Theory.Tuning.Scala",
          "name": "scale_description",
          "package": "hmt",
          "signature": "Scale i -\u003e String",
          "source": "src/Music-Theory-Tuning-Scala.html#scale_description",
          "type": "function"
        },
        "index": {
          "description": "Text description of scale",
          "hierarchy": "Music Theory Tuning Scala",
          "module": "Music.Theory.Tuning.Scala",
          "name": "scale_description",
          "normalized": "Scale a-\u003eString",
          "package": "hmt",
          "signature": "Scale i-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tuning-Scala.html#v:scale_description"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe last \u003ccode\u003e\u003ca\u003ePitch\u003c/a\u003e\u003c/code\u003e element of the scale (ie. the \u003cem\u003eocatve\u003c/em\u003e).\n\u003c/p\u003e",
          "module": "Music.Theory.Tuning.Scala",
          "name": "scale_octave",
          "package": "hmt",
          "signature": "Scale i -\u003e Maybe (Pitch i)",
          "source": "src/Music-Theory-Tuning-Scala.html#scale_octave",
          "type": "function"
        },
        "index": {
          "description": "The last Pitch element of the scale ie the ocatve",
          "hierarchy": "Music Theory Tuning Scala",
          "module": "Music.Theory.Tuning.Scala",
          "name": "scale_octave",
          "normalized": "Scale a-\u003eMaybe(Pitch a)",
          "package": "hmt",
          "signature": "Scale i-\u003eMaybe(Pitch i)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tuning-Scala.html#v:scale_octave"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA pair giving the number of \u003ccode\u003eCents\u003c/code\u003e and number of \u003ccode\u003e\u003ca\u003eRatio\u003c/a\u003e\u003c/code\u003e pitches\n at \u003ccode\u003e\u003ca\u003eScale\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Music.Theory.Tuning.Scala",
          "name": "scale_pitch_representations",
          "package": "hmt",
          "signature": "Scale i -\u003e (t, t)",
          "source": "src/Music-Theory-Tuning-Scala.html#scale_pitch_representations",
          "type": "function"
        },
        "index": {
          "description": "pair giving the number of Cents and number of Ratio pitches at Scale",
          "hierarchy": "Music Theory Tuning Scala",
          "module": "Music.Theory.Tuning.Scala",
          "name": "scale_pitch_representations",
          "normalized": "Scale a-\u003e(b,b)",
          "package": "hmt",
          "signature": "Scale i-\u003e(t,t)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tuning-Scala.html#v:scale_pitch_representations"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003ePitch\u003c/a\u003e\u003c/code\u003ees at \u003ccode\u003e\u003ca\u003eScale\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Music.Theory.Tuning.Scala",
          "name": "scale_pitches",
          "package": "hmt",
          "signature": "Scale i -\u003e [Pitch i]",
          "source": "src/Music-Theory-Tuning-Scala.html#scale_pitches",
          "type": "function"
        },
        "index": {
          "description": "The Pitch es at Scale",
          "hierarchy": "Music Theory Tuning Scala",
          "module": "Music.Theory.Tuning.Scala",
          "name": "scale_pitches",
          "normalized": "Scale a-\u003e[Pitch a]",
          "package": "hmt",
          "signature": "Scale i-\u003e[Pitch i]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tuning-Scala.html#v:scale_pitches"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eScale as list of \u003ccode\u003e\u003ca\u003eRational\u003c/a\u003e\u003c/code\u003e (ie. \u003ccode\u003e\u003ca\u003epitch_ratio\u003c/a\u003e\u003c/code\u003e) with \u003ccode\u003e1\u003c/code\u003e prefix.\n\u003c/p\u003e",
          "module": "Music.Theory.Tuning.Scala",
          "name": "scale_ratios",
          "package": "hmt",
          "signature": "Epsilon -\u003e Scale Integer -\u003e [Rational]",
          "source": "src/Music-Theory-Tuning-Scala.html#scale_ratios",
          "type": "function"
        },
        "index": {
          "description": "Scale as list of Rational ie pitch ratio with prefix",
          "hierarchy": "Music Theory Tuning Scala",
          "module": "Music.Theory.Tuning.Scala",
          "name": "scale_ratios",
          "normalized": "Epsilon-\u003eScale Integer-\u003e[Rational]",
          "package": "hmt",
          "signature": "Epsilon-\u003eScale Integer-\u003e[Rational]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tuning-Scala.html#v:scale_ratios"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMake scale pitches uniform, conforming to the most promininent\n pitch type.\n\u003c/p\u003e",
          "module": "Music.Theory.Tuning.Scala",
          "name": "scale_uniform",
          "package": "hmt",
          "signature": "Epsilon -\u003e Scale Integer -\u003e Scale Integer",
          "source": "src/Music-Theory-Tuning-Scala.html#scale_uniform",
          "type": "function"
        },
        "index": {
          "description": "Make scale pitches uniform conforming to the most promininent pitch type",
          "hierarchy": "Music Theory Tuning Scala",
          "module": "Music.Theory.Tuning.Scala",
          "name": "scale_uniform",
          "normalized": "Epsilon-\u003eScale Integer-\u003eScale Integer",
          "package": "hmt",
          "signature": "Epsilon-\u003eScale Integer-\u003eScale Integer",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tuning-Scala.html#v:scale_uniform"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eTuning theory\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Music.Theory.Tuning",
          "name": "Tuning",
          "package": "hmt",
          "source": "src/Music-Theory-Tuning.html",
          "type": "module"
        },
        "index": {
          "description": "Tuning theory",
          "hierarchy": "Music Theory Tuning",
          "module": "Music.Theory.Tuning",
          "name": "Tuning",
          "package": "hmt",
          "partial": "Tuning",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tuning.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn approximation of a ratio.\n\u003c/p\u003e",
          "module": "Music.Theory.Tuning",
          "name": "Approximate_Ratio",
          "package": "hmt",
          "source": "src/Music-Theory-Tuning.html#Approximate_Ratio",
          "type": "type"
        },
        "index": {
          "description": "An approximation of ratio",
          "hierarchy": "Music Theory Tuning",
          "module": "Music.Theory.Tuning",
          "name": "Approximate_Ratio",
          "package": "hmt",
          "partial": "Approximate Ratio",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tuning.html#t:Approximate_Ratio"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA real valued division of a tone into one hundred parts.\n\u003c/p\u003e",
          "module": "Music.Theory.Tuning",
          "name": "Cents",
          "package": "hmt",
          "source": "src/Music-Theory-Tuning.html#Cents",
          "type": "type"
        },
        "index": {
          "description": "real valued division of tone into one hundred parts",
          "hierarchy": "Music Theory Tuning",
          "module": "Music.Theory.Tuning",
          "name": "Cents",
          "package": "hmt",
          "partial": "Cents",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tuning.html#t:Cents"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA tuning specified \u003ccode\u003e\u003ca\u003eEither\u003c/a\u003e\u003c/code\u003e as a sequence of exact ratios, or as\n a sequence of possibly inexact \u003ccode\u003e\u003ca\u003eCents\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Music.Theory.Tuning",
          "name": "Tuning",
          "package": "hmt",
          "source": "src/Music-Theory-Tuning.html#Tuning",
          "type": "data"
        },
        "index": {
          "description": "tuning specified Either as sequence of exact ratios or as sequence of possibly inexact Cents",
          "hierarchy": "Music Theory Tuning",
          "module": "Music.Theory.Tuning",
          "name": "Tuning",
          "package": "hmt",
          "partial": "Tuning",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tuning.html#t:Tuning"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Tuning",
          "name": "Tuning",
          "package": "hmt",
          "signature": "Tuning",
          "source": "src/Music-Theory-Tuning.html#Tuning",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Tuning",
          "module": "Music.Theory.Tuning",
          "name": "Tuning",
          "package": "hmt",
          "partial": "Tuning",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tuning.html#v:Tuning"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert from \u003ccode\u003e\u003ca\u003eRational\u003c/a\u003e\u003c/code\u003e to \u003ccode\u003e\u003ca\u003eApproximate_Ratio\u003c/a\u003e\u003c/code\u003e, ie. \u003ccode\u003e\u003ca\u003efromRational\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Music.Theory.Tuning",
          "name": "approximate_ratio",
          "package": "hmt",
          "signature": "Rational -\u003e Approximate_Ratio",
          "source": "src/Music-Theory-Tuning.html#approximate_ratio",
          "type": "function"
        },
        "index": {
          "description": "Convert from Rational to Approximate Ratio ie fromRational",
          "hierarchy": "Music Theory Tuning",
          "module": "Music.Theory.Tuning",
          "name": "approximate_ratio",
          "normalized": "Rational-\u003eApproximate_Ratio",
          "package": "hmt",
          "signature": "Rational-\u003eApproximate_Ratio",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tuning.html#v:approximate_ratio"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePossibly inexact \u003ccode\u003e\u003ca\u003eApproximate_Ratio\u003c/a\u003e\u003c/code\u003es of tuning.\n\u003c/p\u003e",
          "module": "Music.Theory.Tuning",
          "name": "approximate_ratios",
          "package": "hmt",
          "signature": "Tuning -\u003e [Approximate_Ratio]",
          "source": "src/Music-Theory-Tuning.html#approximate_ratios",
          "type": "function"
        },
        "index": {
          "description": "Possibly inexact Approximate Ratio of tuning",
          "hierarchy": "Music Theory Tuning",
          "module": "Music.Theory.Tuning",
          "name": "approximate_ratios",
          "normalized": "Tuning-\u003e[Approximate_Ratio]",
          "package": "hmt",
          "signature": "Tuning-\u003e[Approximate_Ratio]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tuning.html#v:approximate_ratios"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eBen Johnston's \"Suite for Microtonal Piano\" (1977), see\n \u003ca\u003ehttp://www.kylegann.com/tuning.html\u003c/a\u003e\n\u003c/p\u003e\u003cpre\u003e cents_i ben_johnston == [0,105,204,298,386,471,551,702,841,906,969,1088]\n\u003c/pre\u003e",
          "module": "Music.Theory.Tuning",
          "name": "ben_johnston",
          "package": "hmt",
          "signature": "Tuning",
          "source": "src/Music-Theory-Tuning.html#ben_johnston",
          "type": "function"
        },
        "index": {
          "description": "Ben Johnston Suite for Microtonal Piano see http www.kylegann.com tuning.html cents ben johnston",
          "hierarchy": "Music Theory Tuning",
          "module": "Music.Theory.Tuning",
          "name": "ben_johnston",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tuning.html#v:ben_johnston"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Tuning",
          "name": "ben_johnston_r",
          "package": "hmt",
          "signature": "[Rational]",
          "source": "src/Music-Theory-Tuning.html#ben_johnston_r",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Tuning",
          "module": "Music.Theory.Tuning",
          "name": "ben_johnston_r",
          "normalized": "[Rational]",
          "package": "hmt",
          "signature": "[Rational]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tuning.html#v:ben_johnston_r"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePossibly inexact \u003ccode\u003e\u003ca\u003eCents\u003c/a\u003e\u003c/code\u003e of tuning.\n\u003c/p\u003e",
          "module": "Music.Theory.Tuning",
          "name": "cents",
          "package": "hmt",
          "signature": "Tuning -\u003e [Cents]",
          "source": "src/Music-Theory-Tuning.html#cents",
          "type": "function"
        },
        "index": {
          "description": "Possibly inexact Cents of tuning",
          "hierarchy": "Music Theory Tuning",
          "module": "Music.Theory.Tuning",
          "name": "cents",
          "normalized": "Tuning-\u003e[Cents]",
          "package": "hmt",
          "signature": "Tuning-\u003e[Cents]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tuning.html#v:cents"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003emap\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eround\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003ecents\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Music.Theory.Tuning",
          "name": "cents_i",
          "package": "hmt",
          "signature": "Tuning -\u003e [i]",
          "source": "src/Music-Theory-Tuning.html#cents_i",
          "type": "function"
        },
        "index": {
          "description": "map round cents",
          "hierarchy": "Music Theory Tuning",
          "module": "Music.Theory.Tuning",
          "name": "cents_i",
          "normalized": "Tuning-\u003e[a]",
          "package": "hmt",
          "signature": "Tuning-\u003e[i]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tuning.html#v:cents_i"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert from cents invterval to frequency ratio.\n\u003c/p\u003e\u003cpre\u003e map cents_to_ratio [0,701.9550008653874,1200] == [1,3/2,2]\n\u003c/pre\u003e",
          "module": "Music.Theory.Tuning",
          "name": "cents_to_ratio",
          "package": "hmt",
          "signature": "a -\u003e a",
          "source": "src/Music-Theory-Tuning.html#cents_to_ratio",
          "type": "function"
        },
        "index": {
          "description": "Convert from cents invterval to frequency ratio map cents to ratio",
          "hierarchy": "Music Theory Tuning",
          "module": "Music.Theory.Tuning",
          "name": "cents_to_ratio",
          "normalized": "a-\u003ea",
          "package": "hmt",
          "signature": "a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tuning.html#v:cents_to_ratio"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInterval in \u003cem\u003ecents\u003c/em\u003e from \u003cem\u003ep\u003c/em\u003e to \u003cem\u003eq\u003c/em\u003e, ie. \u003ccode\u003e\u003ca\u003eratio_to_cents\u003c/a\u003e\u003c/code\u003e of \u003cem\u003ep\u003c/em\u003e\n \u003ccode\u003e\u003ca\u003e/\u003c/a\u003e\u003c/code\u003e \u003cem\u003eq\u003c/em\u003e.\n\u003c/p\u003e\u003cpre\u003e cps_difference_cents 440 (octpc_to_cps (5,2)) == 500\n\u003c/pre\u003e\u003cpre\u003e let abs_dif i j = abs (i - j)\n in cps_difference_cents 440 (fmidi_to_cps 69.1) `abs_dif` 10 \u003c 1e9\n\u003c/pre\u003e",
          "module": "Music.Theory.Tuning",
          "name": "cps_difference_cents",
          "package": "hmt",
          "signature": "a -\u003e a -\u003e a",
          "source": "src/Music-Theory-Tuning.html#cps_difference_cents",
          "type": "function"
        },
        "index": {
          "description": "Interval in cents from to ie ratio to cents of cps difference cents octpc to cps let abs dif abs in cps difference cents fmidi to cps abs dif e9",
          "hierarchy": "Music Theory Tuning",
          "module": "Music.Theory.Tuning",
          "name": "cps_difference_cents",
          "normalized": "a-\u003ea-\u003ea",
          "package": "hmt",
          "signature": "a-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tuning.html#v:cps_difference_cents"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFrequency \u003cem\u003en\u003c/em\u003e cents from \u003cem\u003ef\u003c/em\u003e.\n\u003c/p\u003e\u003cpre\u003e map (cps_shift_cents 440) [-100,100] == map octpc_to_cps [(4,8),(4,10)]\n\u003c/pre\u003e",
          "module": "Music.Theory.Tuning",
          "name": "cps_shift_cents",
          "package": "hmt",
          "signature": "a -\u003e a -\u003e a",
          "source": "src/Music-Theory-Tuning.html#cps_shift_cents",
          "type": "function"
        },
        "index": {
          "description": "Frequency cents from map cps shift cents map octpc to cps",
          "hierarchy": "Music Theory Tuning",
          "module": "Music.Theory.Tuning",
          "name": "cps_shift_cents",
          "normalized": "a-\u003ea-\u003ea",
          "package": "hmt",
          "signature": "a-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tuning.html#v:cps_shift_cents"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDitone/pythagorean tuning,\n see \u003ca\u003ehttp://www.billalves.com/porgitaro/ditonesettuning.html\u003c/a\u003e\n\u003c/p\u003e\u003cpre\u003e cents_i ditone == [0,114,204,294,408,498,612,702,816,906,996,1110]\n\u003c/pre\u003e",
          "module": "Music.Theory.Tuning",
          "name": "ditone",
          "package": "hmt",
          "signature": "Tuning",
          "source": "src/Music-Theory-Tuning.html#ditone",
          "type": "function"
        },
        "index": {
          "description": "Ditone pythagorean tuning see http www.billalves.com porgitaro ditonesettuning.html cents ditone",
          "hierarchy": "Music Theory Tuning",
          "module": "Music.Theory.Tuning",
          "name": "ditone",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tuning.html#v:ditone"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Tuning",
          "name": "ditone_r",
          "package": "hmt",
          "signature": "[Rational]",
          "source": "src/Music-Theory-Tuning.html#ditone_r",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Tuning",
          "module": "Music.Theory.Tuning",
          "name": "ditone_r",
          "normalized": "[Rational]",
          "package": "hmt",
          "signature": "[Rational]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tuning.html#v:ditone_r"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDivisions of octave.\n\u003c/p\u003e\u003cpre\u003e divisions ditone == 12\n\u003c/pre\u003e",
          "module": "Music.Theory.Tuning",
          "name": "divisions",
          "package": "hmt",
          "signature": "Tuning -\u003e Int",
          "source": "src/Music-Theory-Tuning.html#divisions",
          "type": "function"
        },
        "index": {
          "description": "Divisions of octave divisions ditone",
          "hierarchy": "Music Theory Tuning",
          "module": "Music.Theory.Tuning",
          "name": "divisions",
          "normalized": "Tuning-\u003eInt",
          "package": "hmt",
          "signature": "Tuning-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tuning.html#v:divisions"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEqual temperament.\n\u003c/p\u003e\u003cpre\u003e cents equal_temperament == [0,100..1100]\n\u003c/pre\u003e",
          "module": "Music.Theory.Tuning",
          "name": "equal_temperament",
          "package": "hmt",
          "signature": "Tuning",
          "source": "src/Music-Theory-Tuning.html#equal_temperament",
          "type": "function"
        },
        "index": {
          "description": "Equal temperament cents equal temperament",
          "hierarchy": "Music Theory Tuning",
          "module": "Music.Theory.Tuning",
          "name": "equal_temperament",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tuning.html#v:equal_temperament"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Tuning",
          "name": "equal_temperament_c",
          "package": "hmt",
          "signature": "[Cents]",
          "source": "src/Music-Theory-Tuning.html#equal_temperament_c",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Tuning",
          "module": "Music.Theory.Tuning",
          "name": "equal_temperament_c",
          "normalized": "[Cents]",
          "package": "hmt",
          "signature": "[Cents]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tuning.html#v:equal_temperament_c"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFive-limit tuning (five limit just intonation).\n\u003c/p\u003e\u003cpre\u003e cents_i five_limit_tuning == [0,112,204,316,386,498,590,702,814,884,996,1088]\n\u003c/pre\u003e",
          "module": "Music.Theory.Tuning",
          "name": "five_limit_tuning",
          "package": "hmt",
          "signature": "Tuning",
          "source": "src/Music-Theory-Tuning.html#five_limit_tuning",
          "type": "function"
        },
        "index": {
          "description": "Five-limit tuning five limit just intonation cents five limit tuning",
          "hierarchy": "Music Theory Tuning",
          "module": "Music.Theory.Tuning",
          "name": "five_limit_tuning",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tuning.html#v:five_limit_tuning"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Tuning",
          "name": "five_limit_tuning_r",
          "package": "hmt",
          "signature": "[Rational]",
          "source": "src/Music-Theory-Tuning.html#five_limit_tuning_r",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Tuning",
          "module": "Music.Theory.Tuning",
          "name": "five_limit_tuning_r",
          "normalized": "[Rational]",
          "package": "hmt",
          "signature": "[Rational]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tuning.html#v:five_limit_tuning_r"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRaise or lower the frequency \u003cem\u003eq\u003c/em\u003e by octaves until it is in the\n octave starting at \u003cem\u003ep\u003c/em\u003e.\n\u003c/p\u003e\u003cpre\u003e fold_to_octave_of 55 392 == 98\n\u003c/pre\u003e",
          "module": "Music.Theory.Tuning",
          "name": "fold_cps_to_octave_of",
          "package": "hmt",
          "signature": "a -\u003e a -\u003e a",
          "source": "src/Music-Theory-Tuning.html#fold_cps_to_octave_of",
          "type": "function"
        },
        "index": {
          "description": "Raise or lower the frequency by octaves until it is in the octave starting at fold to octave of",
          "hierarchy": "Music Theory Tuning",
          "module": "Music.Theory.Tuning",
          "name": "fold_cps_to_octave_of",
          "normalized": "a-\u003ea-\u003ea",
          "package": "hmt",
          "signature": "a-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tuning.html#v:fold_cps_to_octave_of"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFold ratio until within an octave, ie. \u003ccode\u003e1\u003c/code\u003e \u003ccode\u003e\u003ca\u003e\u003c\u003c/a\u003e\u003c/code\u003e \u003cem\u003en\u003c/em\u003e \u003ccode\u003e\u003ca\u003e\u003c=\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e2\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Music.Theory.Tuning",
          "name": "fold_ratio_to_octave",
          "package": "hmt",
          "signature": "Ratio i -\u003e Ratio i",
          "source": "src/Music-Theory-Tuning.html#fold_ratio_to_octave",
          "type": "function"
        },
        "index": {
          "description": "Fold ratio until within an octave ie",
          "hierarchy": "Music Theory Tuning",
          "module": "Music.Theory.Tuning",
          "name": "fold_ratio_to_octave",
          "normalized": "Ratio a-\u003eRatio a",
          "package": "hmt",
          "signature": "Ratio i-\u003eRatio i",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tuning.html#v:fold_ratio_to_octave"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMaybe \u003ccode\u003e\u003ca\u003eLeft\u003c/a\u003e\u003c/code\u003e of \u003ccode\u003e\u003ca\u003eEither\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Music.Theory.Tuning",
          "name": "fromLeft",
          "package": "hmt",
          "signature": "Either a b -\u003e Maybe a",
          "source": "src/Music-Theory-Tuning.html#fromLeft",
          "type": "function"
        },
        "index": {
          "description": "Maybe Left of Either",
          "hierarchy": "Music Theory Tuning",
          "module": "Music.Theory.Tuning",
          "name": "fromLeft",
          "normalized": "Either a b-\u003eMaybe a",
          "package": "hmt",
          "partial": "Left",
          "signature": "Either a b-\u003eMaybe a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tuning.html#v:fromLeft"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMaybe \u003ccode\u003e\u003ca\u003eRight\u003c/a\u003e\u003c/code\u003e of \u003ccode\u003e\u003ca\u003eEither\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Music.Theory.Tuning",
          "name": "fromRight",
          "package": "hmt",
          "signature": "Either a b -\u003e Maybe b",
          "source": "src/Music-Theory-Tuning.html#fromRight",
          "type": "function"
        },
        "index": {
          "description": "Maybe Right of Either",
          "hierarchy": "Music Theory Tuning",
          "module": "Music.Theory.Tuning",
          "name": "fromRight",
          "normalized": "Either a b-\u003eMaybe b",
          "package": "hmt",
          "partial": "Right",
          "signature": "Either a b-\u003eMaybe b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tuning.html#v:fromRight"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eHarmonic series on \u003cem\u003en\u003c/em\u003e.\n\u003c/p\u003e",
          "module": "Music.Theory.Tuning",
          "name": "harmonic_series_cps",
          "package": "hmt",
          "signature": "t -\u003e [t]",
          "source": "src/Music-Theory-Tuning.html#harmonic_series_cps",
          "type": "function"
        },
        "index": {
          "description": "Harmonic series on",
          "hierarchy": "Music Theory Tuning",
          "module": "Music.Theory.Tuning",
          "name": "harmonic_series_cps",
          "normalized": "a-\u003e[a]",
          "package": "hmt",
          "signature": "t-\u003e[t]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tuning.html#v:harmonic_series_cps"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDerivative harmonic series, based on \u003cem\u003ek\u003c/em\u003eth partial of \u003cem\u003ef1\u003c/em\u003e.\n\u003c/p\u003e\u003cpre\u003e let {r = [52,103,155,206,258,309,361,412,464,515,567,618,670,721,773]\n     ;d = harmonic_series_cps_derived 5 (octpc_to_cps (1,4))}\n in map round (take 15 d) == r\n\u003c/pre\u003e",
          "module": "Music.Theory.Tuning",
          "name": "harmonic_series_cps_derived",
          "package": "hmt",
          "signature": "Int -\u003e a -\u003e [a]",
          "source": "src/Music-Theory-Tuning.html#harmonic_series_cps_derived",
          "type": "function"
        },
        "index": {
          "description": "Derivative harmonic series based on th partial of f1 let harmonic series cps derived octpc to cps in map round take",
          "hierarchy": "Music Theory Tuning",
          "module": "Music.Theory.Tuning",
          "name": "harmonic_series_cps_derived",
          "normalized": "Int-\u003ea-\u003e[a]",
          "package": "hmt",
          "signature": "Int-\u003ea-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tuning.html#v:harmonic_series_cps_derived"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003en\u003c/em\u003e elements of \u003ccode\u003e\u003ca\u003eharmonic_series_cps\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e harmonic_series_cps_n 14 55 == [55,110,165,220,275,330,385,440,495,550,605,660,715,770]\n\u003c/pre\u003e",
          "module": "Music.Theory.Tuning",
          "name": "harmonic_series_cps_n",
          "package": "hmt",
          "signature": "Int -\u003e a -\u003e [a]",
          "source": "src/Music-Theory-Tuning.html#harmonic_series_cps_n",
          "type": "function"
        },
        "index": {
          "description": "elements of harmonic series cps harmonic series cps",
          "hierarchy": "Music Theory Tuning",
          "module": "Music.Theory.Tuning",
          "name": "harmonic_series_cps_n",
          "normalized": "Int-\u003ea-\u003e[a]",
          "package": "hmt",
          "signature": "Int-\u003ea-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tuning.html#v:harmonic_series_cps_n"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eHarmonic series to \u003cem\u003en\u003c/em\u003eth harmonic (folded).\n\u003c/p\u003e\u003cpre\u003e harmonic_series_folded 17 == [1,17/16,9/8,5/4,11/8,3/2,13/8,7/4,15/8]\n\u003c/pre\u003e",
          "module": "Music.Theory.Tuning",
          "name": "harmonic_series_folded",
          "package": "hmt",
          "signature": "Integer -\u003e [Rational]",
          "source": "src/Music-Theory-Tuning.html#harmonic_series_folded",
          "type": "function"
        },
        "index": {
          "description": "Harmonic series to th harmonic folded harmonic series folded",
          "hierarchy": "Music Theory Tuning",
          "module": "Music.Theory.Tuning",
          "name": "harmonic_series_folded",
          "normalized": "Integer-\u003e[Rational]",
          "package": "hmt",
          "signature": "Integer-\u003e[Rational]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tuning.html#v:harmonic_series_folded"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e12\u003c/code\u003e-tone tuning of first \u003ccode\u003e21\u003c/code\u003e elements of the harmonic series.\n\u003c/p\u003e\u003cpre\u003e cents_i harmonic_series_folded_21 == [0,105,204,298,386,471,551,702,841,969,1088]\n\u003c/pre\u003e",
          "module": "Music.Theory.Tuning",
          "name": "harmonic_series_folded_21",
          "package": "hmt",
          "signature": "Tuning",
          "source": "src/Music-Theory-Tuning.html#harmonic_series_folded_21",
          "type": "function"
        },
        "index": {
          "description": "tone tuning of first elements of the harmonic series cents harmonic series folded",
          "hierarchy": "Music Theory Tuning",
          "module": "Music.Theory.Tuning",
          "name": "harmonic_series_folded_21",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tuning.html#v:harmonic_series_folded_21"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eto_cents_r\u003c/a\u003e\u003c/code\u003e variant of \u003ccode\u003e\u003ca\u003eharmonic_series_folded\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e map round (harmonic_series_folded_c 21) == [0,105,204,298,386,471,551,702,841,969,1088]\n\u003c/pre\u003e",
          "module": "Music.Theory.Tuning",
          "name": "harmonic_series_folded_c",
          "package": "hmt",
          "signature": "Integer -\u003e [Cents]",
          "source": "src/Music-Theory-Tuning.html#harmonic_series_folded_c",
          "type": "function"
        },
        "index": {
          "description": "to cents variant of harmonic series folded map round harmonic series folded",
          "hierarchy": "Music Theory Tuning",
          "module": "Music.Theory.Tuning",
          "name": "harmonic_series_folded_c",
          "normalized": "Integer-\u003e[Cents]",
          "package": "hmt",
          "signature": "Integer-\u003e[Cents]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tuning.html#v:harmonic_series_folded_c"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Tuning",
          "name": "kirnberger_iii",
          "package": "hmt",
          "signature": "Tuning",
          "source": "src/Music-Theory-Tuning.html#kirnberger_iii",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Tuning",
          "module": "Music.Theory.Tuning",
          "name": "kirnberger_iii",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tuning.html#v:kirnberger_iii"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Tuning",
          "name": "kirnberger_iii_ar",
          "package": "hmt",
          "signature": "[Approximate_Ratio]",
          "source": "src/Music-Theory-Tuning.html#kirnberger_iii_ar",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Tuning",
          "module": "Music.Theory.Tuning",
          "name": "kirnberger_iii_ar",
          "normalized": "[Approximate_Ratio]",
          "package": "hmt",
          "signature": "[Approximate_Ratio]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tuning.html#v:kirnberger_iii_ar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLa Monte Young's \"The Well-Tuned Piano\", see\n \u003ca\u003ehttp://www.kylegann.com/tuning.html\u003c/a\u003e.\n\u003c/p\u003e\u003cpre\u003e cents_i la_monte_young == [0,177,204,240,471,444,675,702,738,969,942,1173]\n\u003c/pre\u003e",
          "module": "Music.Theory.Tuning",
          "name": "la_monte_young",
          "package": "hmt",
          "signature": "Tuning",
          "source": "src/Music-Theory-Tuning.html#la_monte_young",
          "type": "function"
        },
        "index": {
          "description": "La Monte Young The Well-Tuned Piano see http www.kylegann.com tuning.html cents la monte young",
          "hierarchy": "Music Theory Tuning",
          "module": "Music.Theory.Tuning",
          "name": "la_monte_young",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tuning.html#v:la_monte_young"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Tuning",
          "name": "la_monte_young_r",
          "package": "hmt",
          "signature": "[Rational]",
          "source": "src/Music-Theory-Tuning.html#la_monte_young_r",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Tuning",
          "module": "Music.Theory.Tuning",
          "name": "la_monte_young_r",
          "normalized": "[Rational]",
          "package": "hmt",
          "signature": "[Rational]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tuning.html#v:la_monte_young_r"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLou Harrison 16 tone Just Intonation scale, see\n \u003ca\u003ehttp://www.microtonal-synthesis.com/scale_harrison_16.html\u003c/a\u003e\n\u003c/p\u003e\u003cpre\u003e cents_i lou_harrison_16 == [0,112,182,231,267,316,386,498,603,702,814,884,933,969,1018,1088]\n\u003c/pre\u003e",
          "module": "Music.Theory.Tuning",
          "name": "lou_harrison_16",
          "package": "hmt",
          "signature": "Tuning",
          "source": "src/Music-Theory-Tuning.html#lou_harrison_16",
          "type": "function"
        },
        "index": {
          "description": "Lou Harrison tone Just Intonation scale see http www.microtonal-synthesis.com scale harrison html cents lou harrison",
          "hierarchy": "Music Theory Tuning",
          "module": "Music.Theory.Tuning",
          "name": "lou_harrison_16",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tuning.html#v:lou_harrison_16"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Tuning",
          "name": "lou_harrison_16_r",
          "package": "hmt",
          "signature": "[Rational]",
          "source": "src/Music-Theory-Tuning.html#lou_harrison_16_r",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Tuning",
          "module": "Music.Theory.Tuning",
          "name": "lou_harrison_16_r",
          "normalized": "[Rational]",
          "package": "hmt",
          "signature": "[Rational]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tuning.html#v:lou_harrison_16_r"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Tuning",
          "name": "mayumi_reinhard",
          "package": "hmt",
          "signature": "Tuning",
          "source": "src/Music-Theory-Tuning.html#mayumi_reinhard",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Tuning",
          "module": "Music.Theory.Tuning",
          "name": "mayumi_reinhard",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tuning.html#v:mayumi_reinhard"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Tuning",
          "name": "mayumi_reinhard_r",
          "package": "hmt",
          "signature": "[Rational]",
          "source": "src/Music-Theory-Tuning.html#mayumi_reinhard_r",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Tuning",
          "module": "Music.Theory.Tuning",
          "name": "mayumi_reinhard_r",
          "normalized": "[Rational]",
          "package": "hmt",
          "signature": "[Rational]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tuning.html#v:mayumi_reinhard_r"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMercators comma.\n\u003c/p\u003e\u003cpre\u003e mercators_comma == 3^53 / 2^84\n\u003c/pre\u003e",
          "module": "Music.Theory.Tuning",
          "name": "mercators_comma",
          "package": "hmt",
          "signature": "Rational",
          "source": "src/Music-Theory-Tuning.html#mercators_comma",
          "type": "function"
        },
        "index": {
          "description": "Mercators comma mercators comma",
          "hierarchy": "Music Theory Tuning",
          "module": "Music.Theory.Tuning",
          "name": "mercators_comma",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tuning.html#v:mercators_comma"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA minimal isomorphic note layout.\n\u003c/p\u003e\u003cpre\u003e let [i,j,k] = mk_isomorphic_layout 3 5 (3,-4)\n in [i,take 4 j,(2,-4):take 4 k] == minimal_isomorphic_note_layout\n\u003c/pre\u003e",
          "module": "Music.Theory.Tuning",
          "name": "minimal_isomorphic_note_layout",
          "package": "hmt",
          "signature": "[[(Int, Int)]]",
          "source": "src/Music-Theory-Tuning.html#minimal_isomorphic_note_layout",
          "type": "function"
        },
        "index": {
          "description": "minimal isomorphic note layout let mk isomorphic layout in take take minimal isomorphic note layout",
          "hierarchy": "Music Theory Tuning",
          "module": "Music.Theory.Tuning",
          "name": "minimal_isomorphic_note_layout",
          "normalized": "[[(Int,Int)]]",
          "package": "hmt",
          "signature": "[[(Int,Int)]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tuning.html#v:minimal_isomorphic_note_layout"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstruct an isomorphic layout of \u003cem\u003er\u003c/em\u003e rows and \u003cem\u003ec\u003c/em\u003e columns with\n an upper left value of \u003cem\u003e(i,j)\u003c/em\u003e.\n\u003c/p\u003e",
          "module": "Music.Theory.Tuning",
          "name": "mk_isomorphic_layout",
          "package": "hmt",
          "signature": "a -\u003e a -\u003e (a, a) -\u003e [[(a, a)]]",
          "source": "src/Music-Theory-Tuning.html#mk_isomorphic_layout",
          "type": "function"
        },
        "index": {
          "description": "Construct an isomorphic layout of rows and columns with an upper left value of",
          "hierarchy": "Music Theory Tuning",
          "module": "Music.Theory.Tuning",
          "name": "mk_isomorphic_layout",
          "normalized": "a-\u003ea-\u003e(a,a)-\u003e[[(a,a)]]",
          "package": "hmt",
          "signature": "a-\u003ea-\u003e(a,a)-\u003e[[(a,a)]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tuning.html#v:mk_isomorphic_layout"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSyntonic tuning system based on \u003ccode\u003e\u003ca\u003emk_isomorphic_layout\u003c/a\u003e\u003c/code\u003e of \u003ccode\u003e5\u003c/code\u003e\n rows and \u003ccode\u003e7\u003c/code\u003e columns starting at \u003ccode\u003e(3,-4)\u003c/code\u003e and a\n \u003ccode\u003e\u003ca\u003erank_two_regular_temperament\u003c/a\u003e\u003c/code\u003e with \u003cem\u003ea\u003c/em\u003e of \u003ccode\u003e1200\u003c/code\u003e and indicated\n \u003cem\u003eb\u003c/em\u003e.\n\u003c/p\u003e",
          "module": "Music.Theory.Tuning",
          "name": "mk_syntonic_tuning",
          "package": "hmt",
          "signature": "Int -\u003e [Cents]",
          "source": "src/Music-Theory-Tuning.html#mk_syntonic_tuning",
          "type": "function"
        },
        "index": {
          "description": "Syntonic tuning system based on mk isomorphic layout of rows and columns starting at and rank two regular temperament with of and indicated",
          "hierarchy": "Music Theory Tuning",
          "module": "Music.Theory.Tuning",
          "name": "mk_syntonic_tuning",
          "normalized": "Int-\u003e[Cents]",
          "package": "hmt",
          "signature": "Int-\u003e[Cents]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tuning.html#v:mk_syntonic_tuning"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCalculate \u003cem\u003en\u003c/em\u003eth root of \u003cem\u003ex\u003c/em\u003e.\n\u003c/p\u003e\u003cpre\u003e 12 `nth_root` 2  == twelve_tone_equal_temperament_comma\n\u003c/pre\u003e",
          "module": "Music.Theory.Tuning",
          "name": "nth_root",
          "package": "hmt",
          "signature": "a -\u003e a -\u003e a",
          "source": "src/Music-Theory-Tuning.html#nth_root",
          "type": "function"
        },
        "index": {
          "description": "Calculate th root of nth root twelve tone equal temperament comma",
          "hierarchy": "Music Theory Tuning",
          "module": "Music.Theory.Tuning",
          "name": "nth_root",
          "normalized": "a-\u003ea-\u003ea",
          "package": "hmt",
          "signature": "a-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tuning.html#v:nth_root"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Tuning",
          "name": "octave_ratio",
          "package": "hmt",
          "signature": "Rational",
          "source": "src/Music-Theory-Tuning.html#Tuning",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Tuning",
          "module": "Music.Theory.Tuning",
          "name": "octave_ratio",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tuning.html#v:octave_ratio"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eHarry Partch 43 tone scale, see\n \u003ca\u003ehttp://www.microtonal-synthesis.com/scale_partch.html\u003c/a\u003e\n\u003c/p\u003e\u003cpre\u003e cents_i partch_43 == [0,22,53,84,112,151,165\n                      ,182,204,231,267,294,316\n                      ,347,386,418,435\n                      ,471,498,520,551,583,617,649\n                      ,680,702,729,765,782,814,853,884,906,933\n                      ,969,996,1018,1035,1049,1088,1116,1147,1178]\n\u003c/pre\u003e",
          "module": "Music.Theory.Tuning",
          "name": "partch_43",
          "package": "hmt",
          "signature": "Tuning",
          "source": "src/Music-Theory-Tuning.html#partch_43",
          "type": "function"
        },
        "index": {
          "description": "Harry Partch tone scale see http www.microtonal-synthesis.com scale partch.html cents partch",
          "hierarchy": "Music Theory Tuning",
          "module": "Music.Theory.Tuning",
          "name": "partch_43",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tuning.html#v:partch_43"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Tuning",
          "name": "partch_43_r",
          "package": "hmt",
          "signature": "[Rational]",
          "source": "src/Music-Theory-Tuning.html#partch_43_r",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Tuning",
          "module": "Music.Theory.Tuning",
          "name": "partch_43_r",
          "normalized": "[Rational]",
          "package": "hmt",
          "signature": "[Rational]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tuning.html#v:partch_43_r"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003en\u003c/em\u003eth partial of \u003cem\u003ef1\u003c/em\u003e, ie. one indexed.\n\u003c/p\u003e\u003cpre\u003e map (partial 55) [1,5,3] == [55,275,165]\n\u003c/pre\u003e",
          "module": "Music.Theory.Tuning",
          "name": "partial",
          "package": "hmt",
          "signature": "a -\u003e Int -\u003e a",
          "source": "src/Music-Theory-Tuning.html#partial",
          "type": "function"
        },
        "index": {
          "description": "th partial of f1 ie one indexed map partial",
          "hierarchy": "Music Theory Tuning",
          "module": "Music.Theory.Tuning",
          "name": "partial",
          "normalized": "a-\u003eInt-\u003ea",
          "package": "hmt",
          "signature": "a-\u003eInt-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tuning.html#v:partial"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePietro Aaron (1523) meantone temperament, see\n \u003ca\u003ehttp://www.kylegann.com/histune.html\u003c/a\u003e\n\u003c/p\u003e\u003cpre\u003e cents_i pietro_aaron_1523 == [0,76,193,310,386,503,580,697,773,890,1007,1083]\n\u003c/pre\u003e",
          "module": "Music.Theory.Tuning",
          "name": "pietro_aaron_1523",
          "package": "hmt",
          "signature": "Tuning",
          "source": "src/Music-Theory-Tuning.html#pietro_aaron_1523",
          "type": "function"
        },
        "index": {
          "description": "Pietro Aaron meantone temperament see http www.kylegann.com histune.html cents pietro aaron",
          "hierarchy": "Music Theory Tuning",
          "module": "Music.Theory.Tuning",
          "name": "pietro_aaron_1523",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tuning.html#v:pietro_aaron_1523"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Tuning",
          "name": "pietro_aaron_1523_c",
          "package": "hmt",
          "signature": "[Cents]",
          "source": "src/Music-Theory-Tuning.html#pietro_aaron_1523_c",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Tuning",
          "module": "Music.Theory.Tuning",
          "name": "pietro_aaron_1523_c",
          "normalized": "[Cents]",
          "package": "hmt",
          "signature": "[Cents]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tuning.html#v:pietro_aaron_1523_c"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePythagorean tuning.\n\u003c/p\u003e\u003cpre\u003e cents_i pythagorean == [0,90,204,294,408,498,612,702,792,906,996,1110]\n\u003c/pre\u003e",
          "module": "Music.Theory.Tuning",
          "name": "pythagorean",
          "package": "hmt",
          "signature": "Tuning",
          "source": "src/Music-Theory-Tuning.html#pythagorean",
          "type": "function"
        },
        "index": {
          "description": "Pythagorean tuning cents pythagorean",
          "hierarchy": "Music Theory Tuning",
          "module": "Music.Theory.Tuning",
          "name": "pythagorean",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tuning.html#v:pythagorean"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe Pythagorean comma.\n\u003c/p\u003e\u003cpre\u003e pythagorean_comma == 3^12 / 2^19\n\u003c/pre\u003e",
          "module": "Music.Theory.Tuning",
          "name": "pythagorean_comma",
          "package": "hmt",
          "signature": "Rational",
          "source": "src/Music-Theory-Tuning.html#pythagorean_comma",
          "type": "function"
        },
        "index": {
          "description": "The Pythagorean comma pythagorean comma",
          "hierarchy": "Music Theory Tuning",
          "module": "Music.Theory.Tuning",
          "name": "pythagorean_comma",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tuning.html#v:pythagorean_comma"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Tuning",
          "name": "pythagorean_r",
          "package": "hmt",
          "signature": "[Rational]",
          "source": "src/Music-Theory-Tuning.html#pythagorean_r",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Tuning",
          "module": "Music.Theory.Tuning",
          "name": "pythagorean_r",
          "normalized": "[Rational]",
          "package": "hmt",
          "signature": "[Rational]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tuning.html#v:pythagorean_r"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMake a rank two regular temperament from a list of \u003cem\u003e(i,j)\u003c/em\u003e\n positions by applying the scalars \u003cem\u003ea\u003c/em\u003e and \u003cem\u003eb\u003c/em\u003e.\n\u003c/p\u003e",
          "module": "Music.Theory.Tuning",
          "name": "rank_two_regular_temperament",
          "package": "hmt",
          "signature": "a -\u003e a -\u003e [(a, a)] -\u003e [a]",
          "source": "src/Music-Theory-Tuning.html#rank_two_regular_temperament",
          "type": "function"
        },
        "index": {
          "description": "Make rank two regular temperament from list of positions by applying the scalars and",
          "hierarchy": "Music Theory Tuning",
          "module": "Music.Theory.Tuning",
          "name": "rank_two_regular_temperament",
          "normalized": "a-\u003ea-\u003e[(a,a)]-\u003e[a]",
          "package": "hmt",
          "signature": "a-\u003ea-\u003e[(a,a)]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tuning.html#v:rank_two_regular_temperament"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert from frequency ratio to cents interval.\n\u003c/p\u003e\u003cpre\u003e map ratio_to_cents [1,4/3,2] == [0.0,498.04499913461245,1200.0]\n\u003c/pre\u003e",
          "module": "Music.Theory.Tuning",
          "name": "ratio_to_cents",
          "package": "hmt",
          "signature": "a -\u003e a",
          "source": "src/Music-Theory-Tuning.html#ratio_to_cents",
          "type": "function"
        },
        "index": {
          "description": "Convert from frequency ratio to cents interval map ratio to cents",
          "hierarchy": "Music Theory Tuning",
          "module": "Music.Theory.Tuning",
          "name": "ratio_to_cents",
          "normalized": "a-\u003ea",
          "package": "hmt",
          "signature": "a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tuning.html#v:ratio_to_cents"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eMaybe\u003c/a\u003e\u003c/code\u003e exact ratios of \u003ccode\u003e\u003ca\u003eTuning\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Music.Theory.Tuning",
          "name": "ratios",
          "package": "hmt",
          "signature": "Tuning -\u003e Maybe [Rational]",
          "source": "src/Music-Theory-Tuning.html#ratios",
          "type": "function"
        },
        "index": {
          "description": "Maybe exact ratios of Tuning",
          "hierarchy": "Music Theory Tuning",
          "module": "Music.Theory.Tuning",
          "name": "ratios",
          "normalized": "Tuning-\u003eMaybe[Rational]",
          "package": "hmt",
          "signature": "Tuning-\u003eMaybe[Rational]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tuning.html#v:ratios"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Tuning",
          "name": "ratios_or_cents",
          "package": "hmt",
          "signature": "Either [Rational] [Cents]",
          "source": "src/Music-Theory-Tuning.html#Tuning",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Tuning",
          "module": "Music.Theory.Tuning",
          "name": "ratios_or_cents",
          "normalized": "Either[Rational][Cents]",
          "package": "hmt",
          "signature": "Either[Rational][Cents]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tuning.html#v:ratios_or_cents"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstruct an exact \u003ccode\u003e\u003ca\u003eRational\u003c/a\u003e\u003c/code\u003e that approximates \u003ccode\u003e\u003ca\u003eCents\u003c/a\u003e\u003c/code\u003e to within\n \u003cem\u003eepsilon\u003c/em\u003e.\n\u003c/p\u003e\u003cpre\u003e map (reconstructed_ratio 1e-5) [0,700,1200] == [1,442/295,2]\n\u003c/pre\u003e\u003cpre\u003e to_cents_r (442/295) == 699.9976981706735\n\u003c/pre\u003e",
          "module": "Music.Theory.Tuning",
          "name": "reconstructed_ratio",
          "package": "hmt",
          "signature": "Double -\u003e Cents -\u003e Rational",
          "source": "src/Music-Theory-Tuning.html#reconstructed_ratio",
          "type": "function"
        },
        "index": {
          "description": "Construct an exact Rational that approximates Cents to within epsilon map reconstructed ratio e-5 to cents",
          "hierarchy": "Music Theory Tuning",
          "module": "Music.Theory.Tuning",
          "name": "reconstructed_ratio",
          "normalized": "Double-\u003eCents-\u003eRational",
          "package": "hmt",
          "signature": "Double-\u003eCents-\u003eRational",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tuning.html#v:reconstructed_ratio"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eMaybe\u003c/a\u003e\u003c/code\u003e exact ratios reconstructued from possibly inexact \u003ccode\u003e\u003ca\u003eCents\u003c/a\u003e\u003c/code\u003e\n of \u003ccode\u003e\u003ca\u003eTuning\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e let r = [1,17/16,9/8,13/11,5/4,4/3,7/5,3/2,11/7,5/3,16/9,15/8]\n in reconstructed_ratios 1e-2 werckmeister_iii == Just r\n\u003c/pre\u003e",
          "module": "Music.Theory.Tuning",
          "name": "reconstructed_ratios",
          "package": "hmt",
          "signature": "Double -\u003e Tuning -\u003e Maybe [Rational]",
          "source": "src/Music-Theory-Tuning.html#reconstructed_ratios",
          "type": "function"
        },
        "index": {
          "description": "Maybe exact ratios reconstructued from possibly inexact Cents of Tuning let in reconstructed ratios e-2 werckmeister iii Just",
          "hierarchy": "Music Theory Tuning",
          "module": "Music.Theory.Tuning",
          "name": "reconstructed_ratios",
          "normalized": "Double-\u003eTuning-\u003eMaybe[Rational]",
          "package": "hmt",
          "signature": "Double-\u003eTuning-\u003eMaybe[Rational]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tuning.html#v:reconstructed_ratios"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Tuning",
          "name": "septimal_tritone_just_intonation",
          "package": "hmt",
          "signature": "Tuning",
          "source": "src/Music-Theory-Tuning.html#septimal_tritone_just_intonation",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Tuning",
          "module": "Music.Theory.Tuning",
          "name": "septimal_tritone_just_intonation",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tuning.html#v:septimal_tritone_just_intonation"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Tuning",
          "name": "septimal_tritone_just_intonation_r",
          "package": "hmt",
          "signature": "[Rational]",
          "source": "src/Music-Theory-Tuning.html#septimal_tritone_just_intonation_r",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Tuning",
          "module": "Music.Theory.Tuning",
          "name": "septimal_tritone_just_intonation_r",
          "normalized": "[Rational]",
          "package": "hmt",
          "signature": "[Rational]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tuning.html#v:septimal_tritone_just_intonation_r"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Tuning",
          "name": "seven_limit_just_intonation",
          "package": "hmt",
          "signature": "Tuning",
          "source": "src/Music-Theory-Tuning.html#seven_limit_just_intonation",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Tuning",
          "module": "Music.Theory.Tuning",
          "name": "seven_limit_just_intonation",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tuning.html#v:seven_limit_just_intonation"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Tuning",
          "name": "seven_limit_just_intonation_r",
          "package": "hmt",
          "signature": "[Rational]",
          "source": "src/Music-Theory-Tuning.html#seven_limit_just_intonation_r",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Tuning",
          "module": "Music.Theory.Tuning",
          "name": "seven_limit_just_intonation_r",
          "normalized": "[Rational]",
          "package": "hmt",
          "signature": "[Rational]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tuning.html#v:seven_limit_just_intonation_r"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003emk_syntonic_tuning\u003c/a\u003e\u003c/code\u003e of \u003ccode\u003e697\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e divisions syntonic_697 == 17\n cents_i syntonic_697 == [0,79,194,273,309,388,467,503,582,697,776,812,891,970,1006,1085,1164]\n\u003c/pre\u003e",
          "module": "Music.Theory.Tuning",
          "name": "syntonic_697",
          "package": "hmt",
          "signature": "Tuning",
          "source": "src/Music-Theory-Tuning.html#syntonic_697",
          "type": "function"
        },
        "index": {
          "description": "mk syntonic tuning of divisions syntonic cents syntonic",
          "hierarchy": "Music Theory Tuning",
          "module": "Music.Theory.Tuning",
          "name": "syntonic_697",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tuning.html#v:syntonic_697"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003emk_syntonic_tuning\u003c/a\u003e\u003c/code\u003e of \u003ccode\u003e702\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e divisions syntonic_702 == 17\n cents_i syntonic_702 == [0,24,114,204,294,318,408,498,522,612,702,792,816,906,996,1020,1110]\n\u003c/pre\u003e",
          "module": "Music.Theory.Tuning",
          "name": "syntonic_702",
          "package": "hmt",
          "signature": "Tuning",
          "source": "src/Music-Theory-Tuning.html#syntonic_702",
          "type": "function"
        },
        "index": {
          "description": "mk syntonic tuning of divisions syntonic cents syntonic",
          "hierarchy": "Music Theory Tuning",
          "module": "Music.Theory.Tuning",
          "name": "syntonic_702",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tuning.html#v:syntonic_702"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe Syntonic comma.\n\u003c/p\u003e\u003cpre\u003e syntonic_comma == 81/80\n\u003c/pre\u003e",
          "module": "Music.Theory.Tuning",
          "name": "syntonic_comma",
          "package": "hmt",
          "signature": "Rational",
          "source": "src/Music-Theory-Tuning.html#syntonic_comma",
          "type": "function"
        },
        "index": {
          "description": "The Syntonic comma syntonic comma",
          "hierarchy": "Music Theory Tuning",
          "module": "Music.Theory.Tuning",
          "name": "syntonic_comma",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tuning.html#v:syntonic_comma"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThomas Young (1799) - Well Temperament\n\u003c/p\u003e\u003cpre\u003e cents_i thomas_young_1799 == [0,94,196,298,392,500,592,698,796,894,1000,1092]\n\u003c/pre\u003e",
          "module": "Music.Theory.Tuning",
          "name": "thomas_young_1799",
          "package": "hmt",
          "signature": "Tuning",
          "source": "src/Music-Theory-Tuning.html#thomas_young_1799",
          "type": "function"
        },
        "index": {
          "description": "Thomas Young Well Temperament cents thomas young",
          "hierarchy": "Music Theory Tuning",
          "module": "Music.Theory.Tuning",
          "name": "thomas_young_1799",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tuning.html#v:thomas_young_1799"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Tuning",
          "name": "thomas_young_1799_c",
          "package": "hmt",
          "signature": "[Cents]",
          "source": "src/Music-Theory-Tuning.html#thomas_young_1799_c",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Tuning",
          "module": "Music.Theory.Tuning",
          "name": "thomas_young_1799_c",
          "normalized": "[Cents]",
          "package": "hmt",
          "signature": "[Cents]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tuning.html#v:thomas_young_1799_c"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert from an \u003ccode\u003e\u003ca\u003eApproximate_Ratio\u003c/a\u003e\u003c/code\u003e to \u003ccode\u003e\u003ca\u003eCents\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e round (to_cents (3/2)) == 702\n\u003c/pre\u003e",
          "module": "Music.Theory.Tuning",
          "name": "to_cents",
          "package": "hmt",
          "signature": "Approximate_Ratio -\u003e Cents",
          "source": "src/Music-Theory-Tuning.html#to_cents",
          "type": "function"
        },
        "index": {
          "description": "Convert from an Approximate Ratio to Cents round to cents",
          "hierarchy": "Music Theory Tuning",
          "module": "Music.Theory.Tuning",
          "name": "to_cents",
          "normalized": "Approximate_Ratio-\u003eCents",
          "package": "hmt",
          "signature": "Approximate_Ratio-\u003eCents",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tuning.html#v:to_cents"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eto_cents\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eapproximate_ratio\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Music.Theory.Tuning",
          "name": "to_cents_r",
          "package": "hmt",
          "signature": "Rational -\u003e Cents",
          "source": "src/Music-Theory-Tuning.html#to_cents_r",
          "type": "function"
        },
        "index": {
          "description": "to cents approximate ratio",
          "hierarchy": "Music Theory Tuning",
          "module": "Music.Theory.Tuning",
          "name": "to_cents_r",
          "normalized": "Rational-\u003eCents",
          "package": "hmt",
          "signature": "Rational-\u003eCents",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tuning.html#v:to_cents_r"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e12-tone equal temperament comma (ie. 12th root of 2).\n\u003c/p\u003e\u003cpre\u003e twelve_tone_equal_temperament_comma == 1.0594630943592953\n\u003c/pre\u003e",
          "module": "Music.Theory.Tuning",
          "name": "twelve_tone_equal_temperament_comma",
          "package": "hmt",
          "signature": "a",
          "source": "src/Music-Theory-Tuning.html#twelve_tone_equal_temperament_comma",
          "type": "function"
        },
        "index": {
          "description": "tone equal temperament comma ie th root of twelve tone equal temperament comma",
          "hierarchy": "Music Theory Tuning",
          "module": "Music.Theory.Tuning",
          "name": "twelve_tone_equal_temperament_comma",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tuning.html#v:twelve_tone_equal_temperament_comma"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Tuning",
          "name": "vallotti",
          "package": "hmt",
          "signature": "Tuning",
          "source": "src/Music-Theory-Tuning.html#vallotti",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Tuning",
          "module": "Music.Theory.Tuning",
          "name": "vallotti",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tuning.html#v:vallotti"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Tuning",
          "name": "vallotti_c",
          "package": "hmt",
          "signature": "[Cents]",
          "source": "src/Music-Theory-Tuning.html#vallotti_c",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Tuning",
          "module": "Music.Theory.Tuning",
          "name": "vallotti_c",
          "normalized": "[Cents]",
          "package": "hmt",
          "signature": "[Cents]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tuning.html#v:vallotti_c"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWerckmeister III, Andreas Werckmeister (1645-1706)\n\u003c/p\u003e\u003cpre\u003e cents_i werckmeister_iii == [0,90,192,294,390,498,588,696,792,888,996,1092]\n\u003c/pre\u003e",
          "module": "Music.Theory.Tuning",
          "name": "werckmeister_iii",
          "package": "hmt",
          "signature": "Tuning",
          "source": "src/Music-Theory-Tuning.html#werckmeister_iii",
          "type": "function"
        },
        "index": {
          "description": "Werckmeister III Andreas Werckmeister cents werckmeister iii",
          "hierarchy": "Music Theory Tuning",
          "module": "Music.Theory.Tuning",
          "name": "werckmeister_iii",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tuning.html#v:werckmeister_iii"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Tuning",
          "name": "werckmeister_iii_ar",
          "package": "hmt",
          "signature": "[Approximate_Ratio]",
          "source": "src/Music-Theory-Tuning.html#werckmeister_iii_ar",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Tuning",
          "module": "Music.Theory.Tuning",
          "name": "werckmeister_iii_ar",
          "normalized": "[Approximate_Ratio]",
          "package": "hmt",
          "signature": "[Approximate_Ratio]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tuning.html#v:werckmeister_iii_ar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Tuning",
          "name": "werckmeister_iii_c",
          "package": "hmt",
          "signature": "[Cents]",
          "source": "src/Music-Theory-Tuning.html#werckmeister_iii_c",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Tuning",
          "module": "Music.Theory.Tuning",
          "name": "werckmeister_iii_c",
          "normalized": "[Cents]",
          "package": "hmt",
          "signature": "[Cents]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tuning.html#v:werckmeister_iii_c"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWerckmeister IV, Andreas Werckmeister (1645-1706)\n\u003c/p\u003e\u003cpre\u003e cents_i werckmeister_iv == [0,82,196,294,392,498,588,694,784,890,1004,1086]\n\u003c/pre\u003e",
          "module": "Music.Theory.Tuning",
          "name": "werckmeister_iv",
          "package": "hmt",
          "signature": "Tuning",
          "source": "src/Music-Theory-Tuning.html#werckmeister_iv",
          "type": "function"
        },
        "index": {
          "description": "Werckmeister IV Andreas Werckmeister cents werckmeister iv",
          "hierarchy": "Music Theory Tuning",
          "module": "Music.Theory.Tuning",
          "name": "werckmeister_iv",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tuning.html#v:werckmeister_iv"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Tuning",
          "name": "werckmeister_iv_ar",
          "package": "hmt",
          "signature": "[Approximate_Ratio]",
          "source": "src/Music-Theory-Tuning.html#werckmeister_iv_ar",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Tuning",
          "module": "Music.Theory.Tuning",
          "name": "werckmeister_iv_ar",
          "normalized": "[Approximate_Ratio]",
          "package": "hmt",
          "signature": "[Approximate_Ratio]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tuning.html#v:werckmeister_iv_ar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Tuning",
          "name": "werckmeister_iv_c",
          "package": "hmt",
          "signature": "[Cents]",
          "source": "src/Music-Theory-Tuning.html#werckmeister_iv_c",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Tuning",
          "module": "Music.Theory.Tuning",
          "name": "werckmeister_iv_c",
          "normalized": "[Cents]",
          "package": "hmt",
          "signature": "[Cents]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tuning.html#v:werckmeister_iv_c"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWerckmeister V, Andreas Werckmeister (1645-1706)\n\u003c/p\u003e\u003cpre\u003e cents_i werckmeister_v == [0,96,204,300,396,504,600,702,792,900,1002,1098]\n\u003c/pre\u003e",
          "module": "Music.Theory.Tuning",
          "name": "werckmeister_v",
          "package": "hmt",
          "signature": "Tuning",
          "source": "src/Music-Theory-Tuning.html#werckmeister_v",
          "type": "function"
        },
        "index": {
          "description": "Werckmeister Andreas Werckmeister cents werckmeister",
          "hierarchy": "Music Theory Tuning",
          "module": "Music.Theory.Tuning",
          "name": "werckmeister_v",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tuning.html#v:werckmeister_v"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Tuning",
          "name": "werckmeister_v_ar",
          "package": "hmt",
          "signature": "[Approximate_Ratio]",
          "source": "src/Music-Theory-Tuning.html#werckmeister_v_ar",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Tuning",
          "module": "Music.Theory.Tuning",
          "name": "werckmeister_v_ar",
          "normalized": "[Approximate_Ratio]",
          "package": "hmt",
          "signature": "[Approximate_Ratio]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tuning.html#v:werckmeister_v_ar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Tuning",
          "name": "werckmeister_v_c",
          "package": "hmt",
          "signature": "[Cents]",
          "source": "src/Music-Theory-Tuning.html#werckmeister_v_c",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Tuning",
          "module": "Music.Theory.Tuning",
          "name": "werckmeister_v_c",
          "normalized": "[Cents]",
          "package": "hmt",
          "signature": "[Cents]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tuning.html#v:werckmeister_v_c"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWerckmeister VI, Andreas Werckmeister (1645-1706)\n\u003c/p\u003e\u003cpre\u003e cents_i werckmeister_vi == [0,91,196,298,395,498,595,698,793,893,1000,1097]\n\u003c/pre\u003e",
          "module": "Music.Theory.Tuning",
          "name": "werckmeister_vi",
          "package": "hmt",
          "signature": "Tuning",
          "source": "src/Music-Theory-Tuning.html#werckmeister_vi",
          "type": "function"
        },
        "index": {
          "description": "Werckmeister VI Andreas Werckmeister cents werckmeister vi",
          "hierarchy": "Music Theory Tuning",
          "module": "Music.Theory.Tuning",
          "name": "werckmeister_vi",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tuning.html#v:werckmeister_vi"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Tuning",
          "name": "werckmeister_vi_r",
          "package": "hmt",
          "signature": "[Rational]",
          "source": "src/Music-Theory-Tuning.html#werckmeister_vi_r",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Tuning",
          "module": "Music.Theory.Tuning",
          "name": "werckmeister_vi_r",
          "normalized": "[Rational]",
          "package": "hmt",
          "signature": "[Rational]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Tuning.html#v:werckmeister_vi_r"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eSymetric Group S4 as related to the composition \"Nomos Alpha\"\n by Iannis Xenakis.  In particular in relation to the discussion in\n \"Towards a Philosophy of Music\", \u003cem\u003eFormalized Music\u003c/em\u003e pp. 219 -- 221\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Music.Theory.Xenakis.S4",
          "name": "S4",
          "package": "hmt",
          "source": "src/Music-Theory-Xenakis-S4.html",
          "type": "module"
        },
        "index": {
          "description": "Symetric Group S4 as related to the composition Nomos Alpha by Iannis Xenakis In particular in relation to the discussion in Towards Philosophy of Music Formalized Music pp",
          "hierarchy": "Music Theory Xenakis S4",
          "module": "Music.Theory.Xenakis.S4",
          "name": "S4",
          "package": "hmt",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Xenakis-S4.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEnumeration of set of \u003cem\u003efaces\u003c/em\u003e of a cube.\n\u003c/p\u003e",
          "module": "Music.Theory.Xenakis.S4",
          "name": "Face",
          "package": "hmt",
          "source": "src/Music-Theory-Xenakis-S4.html#Face",
          "type": "data"
        },
        "index": {
          "description": "Enumeration of set of faces of cube",
          "hierarchy": "Music Theory Xenakis S4",
          "module": "Music.Theory.Xenakis.S4",
          "name": "Face",
          "package": "hmt",
          "partial": "Face",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Xenakis-S4.html#t:Face"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInitial half of \u003ccode\u003e\u003ca\u003eSeq\u003c/a\u003e\u003c/code\u003e (ie. #4).  The complete \u003ccode\u003e\u003ca\u003eSeq\u003c/a\u003e\u003c/code\u003e is formed by\n appending the \u003ccode\u003e\u003ca\u003ecomplement\u003c/a\u003e\u003c/code\u003e of the \u003ccode\u003e\u003ca\u003eHalf_Seq\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Music.Theory.Xenakis.S4",
          "name": "Half_Seq",
          "package": "hmt",
          "source": "src/Music-Theory-Xenakis-S4.html#Half_Seq",
          "type": "type"
        },
        "index": {
          "description": "Initial half of Seq ie The complete Seq is formed by appending the complement of the Half Seq",
          "hierarchy": "Music Theory Xenakis S4",
          "module": "Music.Theory.Xenakis.S4",
          "name": "Half_Seq",
          "package": "hmt",
          "partial": "Half Seq",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Xenakis-S4.html#t:Half_Seq"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eLabel\u003c/a\u003e\u003c/code\u003es for elements of the symmetric group P4.\n\u003c/p\u003e",
          "module": "Music.Theory.Xenakis.S4",
          "name": "Label",
          "package": "hmt",
          "source": "src/Music-Theory-Xenakis-S4.html#Label",
          "type": "data"
        },
        "index": {
          "description": "Label for elements of the symmetric group P4",
          "hierarchy": "Music Theory Xenakis S4",
          "module": "Music.Theory.Xenakis.S4",
          "name": "Label",
          "package": "hmt",
          "partial": "Label",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Xenakis-S4.html#t:Label"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRelation between to \u003ccode\u003e\u003ca\u003eHalf_Seq\u003c/a\u003e\u003c/code\u003e values as a\n \u003cem\u003e(complementary,permutation)\u003c/em\u003e pair.\n\u003c/p\u003e",
          "module": "Music.Theory.Xenakis.S4",
          "name": "Rel",
          "package": "hmt",
          "source": "src/Music-Theory-Xenakis-S4.html#Rel",
          "type": "type"
        },
        "index": {
          "description": "Relation between to Half Seq values as complementary permutation pair",
          "hierarchy": "Music Theory Xenakis S4",
          "module": "Music.Theory.Xenakis.S4",
          "name": "Rel",
          "package": "hmt",
          "partial": "Rel",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Xenakis-S4.html#t:Rel"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eComplete sequence (ie. #8).\n\u003c/p\u003e",
          "module": "Music.Theory.Xenakis.S4",
          "name": "Seq",
          "package": "hmt",
          "source": "src/Music-Theory-Xenakis-S4.html#Seq",
          "type": "type"
        },
        "index": {
          "description": "Complete sequence ie",
          "hierarchy": "Music Theory Xenakis S4",
          "module": "Music.Theory.Xenakis.S4",
          "name": "Seq",
          "package": "hmt",
          "partial": "Seq",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Xenakis-S4.html#t:Seq"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Xenakis.S4",
          "name": "A",
          "package": "hmt",
          "signature": "A",
          "source": "src/Music-Theory-Xenakis-S4.html#Label",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Xenakis S4",
          "module": "Music.Theory.Xenakis.S4",
          "name": "A",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Xenakis-S4.html#v:A"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Xenakis.S4",
          "name": "B",
          "package": "hmt",
          "signature": "B",
          "source": "src/Music-Theory-Xenakis-S4.html#Label",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Xenakis S4",
          "module": "Music.Theory.Xenakis.S4",
          "name": "B",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Xenakis-S4.html#v:B"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Xenakis.S4",
          "name": "C",
          "package": "hmt",
          "signature": "C",
          "source": "src/Music-Theory-Xenakis-S4.html#Label",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Xenakis S4",
          "module": "Music.Theory.Xenakis.S4",
          "name": "C",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Xenakis-S4.html#v:C"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Xenakis.S4",
          "name": "D",
          "package": "hmt",
          "signature": "D",
          "source": "src/Music-Theory-Xenakis-S4.html#Label",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Xenakis S4",
          "module": "Music.Theory.Xenakis.S4",
          "name": "D",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Xenakis-S4.html#v:D"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Xenakis.S4",
          "name": "D2",
          "package": "hmt",
          "signature": "D2",
          "source": "src/Music-Theory-Xenakis-S4.html#Label",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Xenakis S4",
          "module": "Music.Theory.Xenakis.S4",
          "name": "D2",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Xenakis-S4.html#v:D2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Xenakis.S4",
          "name": "E",
          "package": "hmt",
          "signature": "E",
          "source": "src/Music-Theory-Xenakis-S4.html#Label",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Xenakis S4",
          "module": "Music.Theory.Xenakis.S4",
          "name": "E",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Xenakis-S4.html#v:E"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Xenakis.S4",
          "name": "E2",
          "package": "hmt",
          "signature": "E2",
          "source": "src/Music-Theory-Xenakis-S4.html#Label",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Xenakis S4",
          "module": "Music.Theory.Xenakis.S4",
          "name": "E2",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Xenakis-S4.html#v:E2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Xenakis.S4",
          "name": "F_Back",
          "package": "hmt",
          "signature": "F_Back",
          "source": "src/Music-Theory-Xenakis-S4.html#Face",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Xenakis S4",
          "module": "Music.Theory.Xenakis.S4",
          "name": "F_Back",
          "package": "hmt",
          "partial": "Back",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Xenakis-S4.html#v:F_Back"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Xenakis.S4",
          "name": "F_Bottom",
          "package": "hmt",
          "signature": "F_Bottom",
          "source": "src/Music-Theory-Xenakis-S4.html#Face",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Xenakis S4",
          "module": "Music.Theory.Xenakis.S4",
          "name": "F_Bottom",
          "package": "hmt",
          "partial": "Bottom",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Xenakis-S4.html#v:F_Bottom"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Xenakis.S4",
          "name": "F_Front",
          "package": "hmt",
          "signature": "F_Front",
          "source": "src/Music-Theory-Xenakis-S4.html#Face",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Xenakis S4",
          "module": "Music.Theory.Xenakis.S4",
          "name": "F_Front",
          "package": "hmt",
          "partial": "Front",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Xenakis-S4.html#v:F_Front"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Xenakis.S4",
          "name": "F_Left",
          "package": "hmt",
          "signature": "F_Left",
          "source": "src/Music-Theory-Xenakis-S4.html#Face",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Xenakis S4",
          "module": "Music.Theory.Xenakis.S4",
          "name": "F_Left",
          "package": "hmt",
          "partial": "Left",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Xenakis-S4.html#v:F_Left"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Xenakis.S4",
          "name": "F_Right",
          "package": "hmt",
          "signature": "F_Right",
          "source": "src/Music-Theory-Xenakis-S4.html#Face",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Xenakis S4",
          "module": "Music.Theory.Xenakis.S4",
          "name": "F_Right",
          "package": "hmt",
          "partial": "Right",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Xenakis-S4.html#v:F_Right"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Xenakis.S4",
          "name": "F_Top",
          "package": "hmt",
          "signature": "F_Top",
          "source": "src/Music-Theory-Xenakis-S4.html#Face",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Xenakis S4",
          "module": "Music.Theory.Xenakis.S4",
          "name": "F_Top",
          "package": "hmt",
          "partial": "Top",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Xenakis-S4.html#v:F_Top"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Xenakis.S4",
          "name": "G",
          "package": "hmt",
          "signature": "G",
          "source": "src/Music-Theory-Xenakis-S4.html#Label",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Xenakis S4",
          "module": "Music.Theory.Xenakis.S4",
          "name": "G",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Xenakis-S4.html#v:G"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Xenakis.S4",
          "name": "G2",
          "package": "hmt",
          "signature": "G2",
          "source": "src/Music-Theory-Xenakis-S4.html#Label",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Xenakis S4",
          "module": "Music.Theory.Xenakis.S4",
          "name": "G2",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Xenakis-S4.html#v:G2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Xenakis.S4",
          "name": "I",
          "package": "hmt",
          "signature": "I",
          "source": "src/Music-Theory-Xenakis-S4.html#Label",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Xenakis S4",
          "module": "Music.Theory.Xenakis.S4",
          "name": "I",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Xenakis-S4.html#v:I"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Xenakis.S4",
          "name": "L",
          "package": "hmt",
          "signature": "L",
          "source": "src/Music-Theory-Xenakis-S4.html#Label",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Xenakis S4",
          "module": "Music.Theory.Xenakis.S4",
          "name": "L",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Xenakis-S4.html#v:L"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Xenakis.S4",
          "name": "L2",
          "package": "hmt",
          "signature": "L2",
          "source": "src/Music-Theory-Xenakis-S4.html#Label",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Xenakis S4",
          "module": "Music.Theory.Xenakis.S4",
          "name": "L2",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Xenakis-S4.html#v:L2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Xenakis.S4",
          "name": "Q1",
          "package": "hmt",
          "signature": "Q1",
          "source": "src/Music-Theory-Xenakis-S4.html#Label",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Xenakis S4",
          "module": "Music.Theory.Xenakis.S4",
          "name": "Q1",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Xenakis-S4.html#v:Q1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Xenakis.S4",
          "name": "Q10",
          "package": "hmt",
          "signature": "Q10",
          "source": "src/Music-Theory-Xenakis-S4.html#Label",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Xenakis S4",
          "module": "Music.Theory.Xenakis.S4",
          "name": "Q10",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Xenakis-S4.html#v:Q10"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Xenakis.S4",
          "name": "Q11",
          "package": "hmt",
          "signature": "Q11",
          "source": "src/Music-Theory-Xenakis-S4.html#Label",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Xenakis S4",
          "module": "Music.Theory.Xenakis.S4",
          "name": "Q11",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Xenakis-S4.html#v:Q11"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Xenakis.S4",
          "name": "Q12",
          "package": "hmt",
          "signature": "Q12",
          "source": "src/Music-Theory-Xenakis-S4.html#Label",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Xenakis S4",
          "module": "Music.Theory.Xenakis.S4",
          "name": "Q12",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Xenakis-S4.html#v:Q12"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Xenakis.S4",
          "name": "Q2",
          "package": "hmt",
          "signature": "Q2",
          "source": "src/Music-Theory-Xenakis-S4.html#Label",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Xenakis S4",
          "module": "Music.Theory.Xenakis.S4",
          "name": "Q2",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Xenakis-S4.html#v:Q2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Xenakis.S4",
          "name": "Q3",
          "package": "hmt",
          "signature": "Q3",
          "source": "src/Music-Theory-Xenakis-S4.html#Label",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Xenakis S4",
          "module": "Music.Theory.Xenakis.S4",
          "name": "Q3",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Xenakis-S4.html#v:Q3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Xenakis.S4",
          "name": "Q4",
          "package": "hmt",
          "signature": "Q4",
          "source": "src/Music-Theory-Xenakis-S4.html#Label",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Xenakis S4",
          "module": "Music.Theory.Xenakis.S4",
          "name": "Q4",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Xenakis-S4.html#v:Q4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Xenakis.S4",
          "name": "Q5",
          "package": "hmt",
          "signature": "Q5",
          "source": "src/Music-Theory-Xenakis-S4.html#Label",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Xenakis S4",
          "module": "Music.Theory.Xenakis.S4",
          "name": "Q5",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Xenakis-S4.html#v:Q5"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Xenakis.S4",
          "name": "Q6",
          "package": "hmt",
          "signature": "Q6",
          "source": "src/Music-Theory-Xenakis-S4.html#Label",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Xenakis S4",
          "module": "Music.Theory.Xenakis.S4",
          "name": "Q6",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Xenakis-S4.html#v:Q6"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Xenakis.S4",
          "name": "Q7",
          "package": "hmt",
          "signature": "Q7",
          "source": "src/Music-Theory-Xenakis-S4.html#Label",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Xenakis S4",
          "module": "Music.Theory.Xenakis.S4",
          "name": "Q7",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Xenakis-S4.html#v:Q7"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Xenakis.S4",
          "name": "Q8",
          "package": "hmt",
          "signature": "Q8",
          "source": "src/Music-Theory-Xenakis-S4.html#Label",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Xenakis S4",
          "module": "Music.Theory.Xenakis.S4",
          "name": "Q8",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Xenakis-S4.html#v:Q8"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Xenakis.S4",
          "name": "Q9",
          "package": "hmt",
          "signature": "Q9",
          "source": "src/Music-Theory-Xenakis-S4.html#Label",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Xenakis S4",
          "module": "Music.Theory.Xenakis.S4",
          "name": "Q9",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Xenakis-S4.html#v:Q9"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eApply \u003ccode\u003e\u003ca\u003eRel\u003c/a\u003e\u003c/code\u003e to \u003ccode\u003e\u003ca\u003eHalf_Seq\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e apply_relation (False,P.listPermute 4 [0,3,1,2]) [1,4,2,3] == [1,3,4,2]\n\u003c/pre\u003e",
          "module": "Music.Theory.Xenakis.S4",
          "name": "apply_relation",
          "package": "hmt",
          "signature": "Rel -\u003e Half_Seq -\u003e Half_Seq",
          "source": "src/Music-Theory-Xenakis-S4.html#apply_relation",
          "type": "function"
        },
        "index": {
          "description": "Apply Rel to Half Seq apply relation False P.listPermute",
          "hierarchy": "Music Theory Xenakis S4",
          "module": "Music.Theory.Xenakis.S4",
          "name": "apply_relation",
          "normalized": "Rel-\u003eHalf_Seq-\u003eHalf_Seq",
          "package": "hmt",
          "signature": "Rel-\u003eHalf_Seq-\u003eHalf_Seq",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Xenakis-S4.html#v:apply_relation"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eApply sequence of \u003ccode\u003e\u003ca\u003eRel\u003c/a\u003e\u003c/code\u003e to initial \u003ccode\u003e\u003ca\u003eHalf_Seq\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Music.Theory.Xenakis.S4",
          "name": "apply_relations",
          "package": "hmt",
          "signature": "[Rel] -\u003e Half_Seq -\u003e [Half_Seq]",
          "source": "src/Music-Theory-Xenakis-S4.html#apply_relations",
          "type": "function"
        },
        "index": {
          "description": "Apply sequence of Rel to initial Half Seq",
          "hierarchy": "Music Theory Xenakis S4",
          "module": "Music.Theory.Xenakis.S4",
          "name": "apply_relations",
          "normalized": "[Rel]-\u003eHalf_Seq-\u003e[Half_Seq]",
          "package": "hmt",
          "signature": "[Rel]-\u003eHalf_Seq-\u003e[Half_Seq]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Xenakis-S4.html#v:apply_relations"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eVariant of \u003ccode\u003e\u003ca\u003eapply_relations\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e apply_relations_l (relations_l [L2,L,A,Q1]) L2 == [L2,L,A,Q1]\n\u003c/pre\u003e",
          "module": "Music.Theory.Xenakis.S4",
          "name": "apply_relations_l",
          "package": "hmt",
          "signature": "[Rel] -\u003e Label -\u003e [Label]",
          "source": "src/Music-Theory-Xenakis-S4.html#apply_relations_l",
          "type": "function"
        },
        "index": {
          "description": "Variant of apply relations apply relations relations L2 Q1 L2 L2 Q1",
          "hierarchy": "Music Theory Xenakis S4",
          "module": "Music.Theory.Xenakis.S4",
          "name": "apply_relations_l",
          "normalized": "[Rel]-\u003eLabel-\u003e[Label]",
          "package": "hmt",
          "signature": "[Rel]-\u003eLabel-\u003e[Label]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Xenakis-S4.html#v:apply_relations_l"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eComplement of a \u003ccode\u003e\u003ca\u003eHalf_Seq\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e map complement [[4,1,3,2],[6,7,8,5]] == [[8,5,7,6],[2,3,4,1]]\n\u003c/pre\u003e",
          "module": "Music.Theory.Xenakis.S4",
          "name": "complement",
          "package": "hmt",
          "signature": "Half_Seq -\u003e Half_Seq",
          "source": "src/Music-Theory-Xenakis-S4.html#complement",
          "type": "function"
        },
        "index": {
          "description": "Complement of Half Seq map complement",
          "hierarchy": "Music Theory Xenakis S4",
          "module": "Music.Theory.Xenakis.S4",
          "name": "complement",
          "normalized": "Half_Seq-\u003eHalf_Seq",
          "package": "hmt",
          "signature": "Half_Seq-\u003eHalf_Seq",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Xenakis-S4.html#v:complement"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e if two \u003ccode\u003e\u003ca\u003eHalf_Seq\u003c/a\u003e\u003c/code\u003es are complementary, ie. form a \u003ccode\u003e\u003ca\u003eSeq\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e complementary [4,2,1,3] [8,6,5,7] == True\n\u003c/pre\u003e",
          "module": "Music.Theory.Xenakis.S4",
          "name": "complementary",
          "package": "hmt",
          "signature": "Half_Seq -\u003e Half_Seq -\u003e Bool",
          "source": "src/Music-Theory-Xenakis-S4.html#complementary",
          "type": "function"
        },
        "index": {
          "description": "True if two Half Seq are complementary ie form Seq complementary True",
          "hierarchy": "Music Theory Xenakis S4",
          "module": "Music.Theory.Xenakis.S4",
          "name": "complementary",
          "normalized": "Half_Seq-\u003eHalf_Seq-\u003eBool",
          "package": "hmt",
          "signature": "Half_Seq-\u003eHalf_Seq-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Xenakis-S4.html#v:complementary"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTable indicating set of faces of cubes as drawn in Fig. VIII-6\n (p.220).\n\u003c/p\u003e\u003cpre\u003e lookup [1,4,6,7] faces == Just F_Left\n reverse_lookup F_Right faces == Just [2,3,5,8]\n\u003c/pre\u003e",
          "module": "Music.Theory.Xenakis.S4",
          "name": "faces",
          "package": "hmt",
          "signature": "[([Int], Face)]",
          "source": "src/Music-Theory-Xenakis-S4.html#faces",
          "type": "function"
        },
        "index": {
          "description": "Table indicating set of faces of cubes as drawn in Fig VIII-6 p.220 lookup faces Just Left reverse lookup Right faces Just",
          "hierarchy": "Music Theory Xenakis S4",
          "module": "Music.Theory.Xenakis.S4",
          "name": "faces",
          "normalized": "[([Int],Face)]",
          "package": "hmt",
          "signature": "[([Int],Face)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Xenakis-S4.html#v:faces"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eForm \u003ccode\u003e\u003ca\u003eSeq\u003c/a\u003e\u003c/code\u003e from \u003ccode\u003e\u003ca\u003eHalf_Seq\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e full_seq [3,2,4,1] == [3,2,4,1,7,6,8,5]\n label_of (full_seq [3,2,4,1]) == G2\n label_of (full_seq [1,4,2,3]) == L\n\u003c/pre\u003e",
          "module": "Music.Theory.Xenakis.S4",
          "name": "full_seq",
          "package": "hmt",
          "signature": "Half_Seq -\u003e Seq",
          "source": "src/Music-Theory-Xenakis-S4.html#full_seq",
          "type": "function"
        },
        "index": {
          "description": "Form Seq from Half Seq full seq label of full seq G2 label of full seq",
          "hierarchy": "Music Theory Xenakis S4",
          "module": "Music.Theory.Xenakis.S4",
          "name": "full_seq",
          "normalized": "Half_Seq-\u003eSeq",
          "package": "hmt",
          "signature": "Half_Seq-\u003eSeq",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Xenakis-S4.html#v:full_seq"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eHalf_Seq\u003c/a\u003e\u003c/code\u003e of \u003ccode\u003e\u003ca\u003eSeq\u003c/a\u003e\u003c/code\u003e, ie. \u003ccode\u003e\u003ca\u003etake\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e4\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e complement (half_seq (seq_of Q7)) == [3,4,2,1]\n\u003c/pre\u003e",
          "module": "Music.Theory.Xenakis.S4",
          "name": "half_seq",
          "package": "hmt",
          "signature": "Seq -\u003e Half_Seq",
          "source": "src/Music-Theory-Xenakis-S4.html#half_seq",
          "type": "function"
        },
        "index": {
          "description": "Half Seq of Seq ie take complement half seq seq of Q7",
          "hierarchy": "Music Theory Xenakis S4",
          "module": "Music.Theory.Xenakis.S4",
          "name": "half_seq",
          "normalized": "Seq-\u003eHalf_Seq",
          "package": "hmt",
          "signature": "Seq-\u003eHalf_Seq",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Xenakis-S4.html#v:half_seq"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eHalf_Seq\u003c/a\u003e\u003c/code\u003e of \u003ccode\u003e\u003ca\u003eLabel\u003c/a\u003e\u003c/code\u003e, ie. \u003ccode\u003e\u003ca\u003ehalf_seq\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eseq_of\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e half_seq_of Q1 == [8,7,5,6]\n\u003c/pre\u003e",
          "module": "Music.Theory.Xenakis.S4",
          "name": "half_seq_of",
          "package": "hmt",
          "signature": "Label -\u003e Seq",
          "source": "src/Music-Theory-Xenakis-S4.html#half_seq_of",
          "type": "function"
        },
        "index": {
          "description": "Half Seq of Label ie half seq seq of half seq of Q1",
          "hierarchy": "Music Theory Xenakis S4",
          "module": "Music.Theory.Xenakis.S4",
          "name": "half_seq_of",
          "normalized": "Label-\u003eSeq",
          "package": "hmt",
          "signature": "Label-\u003eSeq",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Xenakis-S4.html#v:half_seq_of"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eApplication of \u003ccode\u003e\u003ca\u003eLabel\u003c/a\u003e\u003c/code\u003e \u003cem\u003ep\u003c/em\u003e on \u003cem\u003eq\u003c/em\u003e.\n\u003c/p\u003e\u003cpre\u003e l_on Q1 I == Q1\n l_on D A == G\n [l_on L L,l_on E D,l_on D E] == [L2,C,B]\n\u003c/pre\u003e",
          "module": "Music.Theory.Xenakis.S4",
          "name": "l_on",
          "package": "hmt",
          "signature": "Label -\u003e Label -\u003e Label",
          "source": "src/Music-Theory-Xenakis-S4.html#l_on",
          "type": "function"
        },
        "index": {
          "description": "Application of Label on on Q1 Q1 on on on on L2",
          "hierarchy": "Music Theory Xenakis S4",
          "module": "Music.Theory.Xenakis.S4",
          "name": "l_on",
          "normalized": "Label-\u003eLabel-\u003eLabel",
          "package": "hmt",
          "signature": "Label-\u003eLabel-\u003eLabel",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Xenakis-S4.html#v:l_on"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eLabel\u003c/a\u003e\u003c/code\u003e of \u003ccode\u003e\u003ca\u003eSeq\u003c/a\u003e\u003c/code\u003e, inverse of \u003ccode\u003e\u003ca\u003eseq_of\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e label_of [8,7,5,6,4,3,1,2] == Q1\n label_of (seq_of Q4) == Q4\n\u003c/pre\u003e",
          "module": "Music.Theory.Xenakis.S4",
          "name": "label_of",
          "package": "hmt",
          "signature": "Seq -\u003e Label",
          "source": "src/Music-Theory-Xenakis-S4.html#label_of",
          "type": "function"
        },
        "index": {
          "description": "Label of Seq inverse of seq of label of Q1 label of seq of Q4 Q4",
          "hierarchy": "Music Theory Xenakis S4",
          "module": "Music.Theory.Xenakis.S4",
          "name": "label_of",
          "normalized": "Seq-\u003eLabel",
          "package": "hmt",
          "signature": "Seq-\u003eLabel",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Xenakis-S4.html#v:label_of"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLower \u003ccode\u003e\u003ca\u003eHalf_Seq\u003c/a\u003e\u003c/code\u003e, ie. \u003ccode\u003e\u003ca\u003ecomplement\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eid\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e map lower [[4,1,3,2],[6,7,8,5]] == [[4,1,3,2],[2,3,4,1]]\n\u003c/pre\u003e",
          "module": "Music.Theory.Xenakis.S4",
          "name": "lower",
          "package": "hmt",
          "signature": "Half_Seq -\u003e Half_Seq",
          "source": "src/Music-Theory-Xenakis-S4.html#lower",
          "type": "function"
        },
        "index": {
          "description": "Lower Half Seq ie complement or id map lower",
          "hierarchy": "Music Theory Xenakis S4",
          "module": "Music.Theory.Xenakis.S4",
          "name": "lower",
          "normalized": "Half_Seq-\u003eHalf_Seq",
          "package": "hmt",
          "signature": "Half_Seq-\u003eHalf_Seq",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Xenakis-S4.html#v:lower"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDetermine \u003ccode\u003e\u003ca\u003eRel\u003c/a\u003e\u003c/code\u003e of \u003ccode\u003e\u003ca\u003eHalf_Seq\u003c/a\u003e\u003c/code\u003es.\n\u003c/p\u003e\u003cpre\u003e relate [1,4,2,3] [1,3,4,2] == (False,P.listPermute 4 [0,3,1,2])\n relate [1,4,2,3] [8,5,6,7] == (True,P.listPermute 4 [1,0,2,3])\n\u003c/pre\u003e",
          "module": "Music.Theory.Xenakis.S4",
          "name": "relate",
          "package": "hmt",
          "signature": "Half_Seq -\u003e Half_Seq -\u003e Rel",
          "source": "src/Music-Theory-Xenakis-S4.html#relate",
          "type": "function"
        },
        "index": {
          "description": "Determine Rel of Half Seq relate False P.listPermute relate True P.listPermute",
          "hierarchy": "Music Theory Xenakis S4",
          "module": "Music.Theory.Xenakis.S4",
          "name": "relate",
          "normalized": "Half_Seq-\u003eHalf_Seq-\u003eRel",
          "package": "hmt",
          "signature": "Half_Seq-\u003eHalf_Seq-\u003eRel",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Xenakis-S4.html#v:relate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eRel\u003c/a\u003e\u003c/code\u003e from \u003ccode\u003e\u003ca\u003eLabel\u003c/a\u003e\u003c/code\u003e \u003cem\u003ep\u003c/em\u003e to \u003cem\u003eq\u003c/em\u003e.\n\u003c/p\u003e\u003cpre\u003e relate_l L L2 == (False,P.listPermute 4 [0,3,1,2])\n\u003c/pre\u003e",
          "module": "Music.Theory.Xenakis.S4",
          "name": "relate_l",
          "package": "hmt",
          "signature": "Label -\u003e Label -\u003e Rel",
          "source": "src/Music-Theory-Xenakis-S4.html#relate_l",
          "type": "function"
        },
        "index": {
          "description": "Rel from Label to relate L2 False P.listPermute",
          "hierarchy": "Music Theory Xenakis S4",
          "module": "Music.Theory.Xenakis.S4",
          "name": "relate_l",
          "normalized": "Label-\u003eLabel-\u003eRel",
          "package": "hmt",
          "signature": "Label-\u003eLabel-\u003eRel",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Xenakis-S4.html#v:relate_l"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003erelate\u003c/a\u003e\u003c/code\u003e adjacent \u003ccode\u003e\u003ca\u003eHalf_Seq\u003c/a\u003e\u003c/code\u003e, see also \u003ccode\u003e\u003ca\u003erelations_l\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Music.Theory.Xenakis.S4",
          "name": "relations",
          "package": "hmt",
          "signature": "[Half_Seq] -\u003e [Rel]",
          "source": "src/Music-Theory-Xenakis-S4.html#relations",
          "type": "function"
        },
        "index": {
          "description": "relate adjacent Half Seq see also relations",
          "hierarchy": "Music Theory Xenakis S4",
          "module": "Music.Theory.Xenakis.S4",
          "name": "relations",
          "normalized": "[Half_Seq]-\u003e[Rel]",
          "package": "hmt",
          "signature": "[Half_Seq]-\u003e[Rel]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Xenakis-S4.html#v:relations"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003erelate\u003c/a\u003e\u003c/code\u003e adjacent \u003ccode\u003e\u003ca\u003eLabel\u003c/a\u003e\u003c/code\u003es.\n\u003c/p\u003e\u003cpre\u003e relations_l [L2,L,A] == [(False,P.listPermute 4 [0,2,3,1])\n                         ,(False,P.listPermute 4 [2,0,1,3])]\n\u003c/pre\u003e",
          "module": "Music.Theory.Xenakis.S4",
          "name": "relations_l",
          "package": "hmt",
          "signature": "[Label] -\u003e [Rel]",
          "source": "src/Music-Theory-Xenakis-S4.html#relations_l",
          "type": "function"
        },
        "index": {
          "description": "relate adjacent Label relations L2 False P.listPermute False P.listPermute",
          "hierarchy": "Music Theory Xenakis S4",
          "module": "Music.Theory.Xenakis.S4",
          "name": "relations_l",
          "normalized": "[Label]-\u003e[Rel]",
          "package": "hmt",
          "signature": "[Label]-\u003e[Rel]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Xenakis-S4.html#v:relations_l"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReverse table \u003ccode\u003e\u003ca\u003elookup\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e reverse_lookup 'b' (zip [1..] ['a'..]) == Just 2\n lookup 2 (zip [1..] ['a'..]) == Just 'b'\n\u003c/pre\u003e",
          "module": "Music.Theory.Xenakis.S4",
          "name": "reverse_lookup",
          "package": "hmt",
          "signature": "a -\u003e [(b, a)] -\u003e Maybe b",
          "source": "src/Music-Theory-Xenakis-S4.html#reverse_lookup",
          "type": "function"
        },
        "index": {
          "description": "Reverse table lookup reverse lookup zip Just lookup zip Just",
          "hierarchy": "Music Theory Xenakis S4",
          "module": "Music.Theory.Xenakis.S4",
          "name": "reverse_lookup",
          "normalized": "a-\u003e[(b,a)]-\u003eMaybe b",
          "package": "hmt",
          "signature": "a-\u003e[(b,a)]-\u003eMaybe b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Xenakis-S4.html#v:reverse_lookup"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eSeq\u003c/a\u003e\u003c/code\u003e of \u003ccode\u003e\u003ca\u003eLabel\u003c/a\u003e\u003c/code\u003e, inverse of \u003ccode\u003e\u003ca\u003elabel_of\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e seq_of Q1 == [8,7,5,6,4,3,1,2]\n\u003c/pre\u003e",
          "module": "Music.Theory.Xenakis.S4",
          "name": "seq_of",
          "package": "hmt",
          "signature": "Label -\u003e Seq",
          "source": "src/Music-Theory-Xenakis-S4.html#seq_of",
          "type": "function"
        },
        "index": {
          "description": "Seq of Label inverse of label of seq of Q1",
          "hierarchy": "Music Theory Xenakis S4",
          "module": "Music.Theory.Xenakis.S4",
          "name": "seq_of",
          "normalized": "Label-\u003eSeq",
          "package": "hmt",
          "signature": "Label-\u003eSeq",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Xenakis-S4.html#v:seq_of"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFig. VIII-6. Hexahedral (Octahedral) Group (p. 220)\n\u003c/p\u003e\u003cpre\u003e length viii_6_l == 24\n take 7 viii_6_l == [L2,L,A,Q1,Q7,Q3,Q9]\n\u003c/pre\u003e",
          "module": "Music.Theory.Xenakis.S4",
          "name": "viii_6_l",
          "package": "hmt",
          "signature": "[Label]",
          "source": "src/Music-Theory-Xenakis-S4.html#viii_6_l",
          "type": "function"
        },
        "index": {
          "description": "Fig VIII-6 Hexahedral Octahedral Group length viii take viii L2 Q1 Q7 Q3 Q9",
          "hierarchy": "Music Theory Xenakis S4",
          "module": "Music.Theory.Xenakis.S4",
          "name": "viii_6_l",
          "normalized": "[Label]",
          "package": "hmt",
          "signature": "[Label]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Xenakis-S4.html#v:viii_6_l"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe sequence of \u003ccode\u003e\u003ca\u003eRel\u003c/a\u003e\u003c/code\u003e to give \u003ccode\u003e\u003ca\u003eviii_6_l\u003c/a\u003e\u003c/code\u003e from \u003ccode\u003e\u003ca\u003eL2\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e apply_relations_l viii_6_relations L2 == viii_6_l\n length (nub viii_6_relations) == 14\n\u003c/pre\u003e",
          "module": "Music.Theory.Xenakis.S4",
          "name": "viii_6_relations",
          "package": "hmt",
          "signature": "[Rel]",
          "source": "src/Music-Theory-Xenakis-S4.html#viii_6_relations",
          "type": "function"
        },
        "index": {
          "description": "The sequence of Rel to give viii from L2 apply relations viii relations L2 viii length nub viii relations",
          "hierarchy": "Music Theory Xenakis S4",
          "module": "Music.Theory.Xenakis.S4",
          "name": "viii_6_relations",
          "normalized": "[Rel]",
          "package": "hmt",
          "signature": "[Rel]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Xenakis-S4.html#v:viii_6_relations"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFig. VIII-6/b.\n\u003c/p\u003e\u003cpre\u003e map (viii_6b !!) [0,8,16] == [(I,[1,2,3,4,5,6,7,8])\n                              ,(G2,[3,2,4,1,7,6,8,5])\n                              ,(Q8,[6,8,5,7,2,4,1,3])]\n\u003c/pre\u003e",
          "module": "Music.Theory.Xenakis.S4",
          "name": "viii_6b",
          "package": "hmt",
          "signature": "[(Label, Seq)]",
          "source": "src/Music-Theory-Xenakis-S4.html#viii_6b",
          "type": "function"
        },
        "index": {
          "description": "Fig VIII-6 map viii G2 Q8",
          "hierarchy": "Music Theory Xenakis S4",
          "module": "Music.Theory.Xenakis.S4",
          "name": "viii_6b",
          "normalized": "[(Label,Seq)]",
          "package": "hmt",
          "signature": "[(Label,Seq)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Xenakis-S4.html#v:viii_6b"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eVariant of \u003ccode\u003e\u003ca\u003eviii_6b\u003c/a\u003e\u003c/code\u003e with \u003ccode\u003e\u003ca\u003eHalf_Seq\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Music.Theory.Xenakis.S4",
          "name": "viii_6b'",
          "package": "hmt",
          "signature": "[(Label, Half_Seq)]",
          "source": "src/Music-Theory-Xenakis-S4.html#viii_6b%27",
          "type": "function"
        },
        "index": {
          "description": "Variant of viii with Half Seq",
          "hierarchy": "Music Theory Xenakis S4",
          "module": "Music.Theory.Xenakis.S4",
          "name": "viii_6b'",
          "normalized": "[(Label,Half_Seq)]",
          "package": "hmt",
          "signature": "[(Label,Half_Seq)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Xenakis-S4.html#v:viii_6b-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFig. VIII-6/b \u003ccode\u003eLabels\u003c/code\u003e (p.221)\n\u003c/p\u003e\u003cpre\u003e length viii_6b_l == length viii_6_l\n take 8 viii_6b_l == [I,A,B,C,D2,D,E2,E]\n\u003c/pre\u003e",
          "module": "Music.Theory.Xenakis.S4",
          "name": "viii_6b_l",
          "package": "hmt",
          "signature": "[Label]",
          "source": "src/Music-Theory-Xenakis-S4.html#viii_6b_l",
          "type": "function"
        },
        "index": {
          "description": "Fig VIII-6 Labels p.221 length viii length viii take viii D2 E2",
          "hierarchy": "Music Theory Xenakis S4",
          "module": "Music.Theory.Xenakis.S4",
          "name": "viii_6b_l",
          "normalized": "[Label]",
          "package": "hmt",
          "signature": "[Label]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Xenakis-S4.html#v:viii_6b_l"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFig. VIII-6/b \u003ccode\u003e\u003ca\u003eHalf_Seq\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e viii_6b_p' == map half_seq_of viii_6b_l\n nub (map (length . nub) viii_6b_p') == [4]\n\u003c/pre\u003e",
          "module": "Music.Theory.Xenakis.S4",
          "name": "viii_6b_p'",
          "package": "hmt",
          "signature": "[Half_Seq]",
          "source": "src/Music-Theory-Xenakis-S4.html#viii_6b_p%27",
          "type": "function"
        },
        "index": {
          "description": "Fig VIII-6 Half Seq viii map half seq of viii nub map length nub viii",
          "hierarchy": "Music Theory Xenakis S4",
          "module": "Music.Theory.Xenakis.S4",
          "name": "viii_6b_p'",
          "normalized": "[Half_Seq]",
          "package": "hmt",
          "signature": "[Half_Seq]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Xenakis-S4.html#v:viii_6b_p-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe sequence of \u003ccode\u003e\u003ca\u003eRel\u003c/a\u003e\u003c/code\u003e to give \u003ccode\u003e\u003ca\u003eviii_6b_l\u003c/a\u003e\u003c/code\u003e from \u003ccode\u003e\u003ca\u003eI\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e apply_relations_l viii_6b_relations I == viii_6b_l\n length (nub viii_6b_relations) == 10\n\u003c/pre\u003e",
          "module": "Music.Theory.Xenakis.S4",
          "name": "viii_6b_relations",
          "package": "hmt",
          "signature": "[Rel]",
          "source": "src/Music-Theory-Xenakis-S4.html#viii_6b_relations",
          "type": "function"
        },
        "index": {
          "description": "The sequence of Rel to give viii from apply relations viii relations viii length nub viii relations",
          "hierarchy": "Music Theory Xenakis S4",
          "module": "Music.Theory.Xenakis.S4",
          "name": "viii_6b_relations",
          "normalized": "[Rel]",
          "package": "hmt",
          "signature": "[Rel]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Xenakis-S4.html#v:viii_6b_relations"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFig. VIII-7 (p.221)\n\u003c/p\u003e\u003cpre\u003e map (take 4) (take 4 viii_7) == [[I,A,B,C]\n                                 ,[A,I,C,B]\n                                 ,[B,C,I,A]\n                                 ,[C,B,A,I]]\n\u003c/pre\u003e",
          "module": "Music.Theory.Xenakis.S4",
          "name": "viii_7",
          "package": "hmt",
          "signature": "[[Label]]",
          "source": "src/Music-Theory-Xenakis-S4.html#viii_7",
          "type": "function"
        },
        "index": {
          "description": "Fig VIII-7 p.221 map take take viii",
          "hierarchy": "Music Theory Xenakis S4",
          "module": "Music.Theory.Xenakis.S4",
          "name": "viii_7",
          "normalized": "[[Label]]",
          "package": "hmt",
          "signature": "[[Label]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Xenakis-S4.html#v:viii_7"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003e\"Sieves\" by Iannis Xenakis and John Rahn\n \u003cem\u003ePerspectives of New Music\u003c/em\u003e\n Vol. 28, No. 1 (Winter, 1990), pp. 58-78\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Music.Theory.Xenakis.Sieve",
          "name": "Sieve",
          "package": "hmt",
          "source": "src/Music-Theory-Xenakis-Sieve.html",
          "type": "module"
        },
        "index": {
          "description": "Sieves by Iannis Xenakis and John Rahn Perspectives of New Music Vol No Winter pp",
          "hierarchy": "Music Theory Xenakis Sieve",
          "module": "Music.Theory.Xenakis.Sieve",
          "name": "Sieve",
          "package": "hmt",
          "partial": "Sieve",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Xenakis-Sieve.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSynonym for \u003ccode\u003e\u003ca\u003eInteger\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Music.Theory.Xenakis.Sieve",
          "name": "I",
          "package": "hmt",
          "source": "src/Music-Theory-Xenakis-Sieve.html#I",
          "type": "type"
        },
        "index": {
          "description": "Synonym for Integer",
          "hierarchy": "Music Theory Xenakis Sieve",
          "module": "Music.Theory.Xenakis.Sieve",
          "name": "I",
          "package": "hmt",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Xenakis-Sieve.html#t:I"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA Sieve.\n\u003c/p\u003e",
          "module": "Music.Theory.Xenakis.Sieve",
          "name": "Sieve",
          "package": "hmt",
          "source": "src/Music-Theory-Xenakis-Sieve.html#Sieve",
          "type": "data"
        },
        "index": {
          "description": "Sieve",
          "hierarchy": "Music Theory Xenakis Sieve",
          "module": "Music.Theory.Xenakis.Sieve",
          "name": "Sieve",
          "package": "hmt",
          "partial": "Sieve",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Xenakis-Sieve.html#t:Sieve"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUnicode synonym for \u003ccode\u003e\u003ca\u003eIntersection\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Music.Theory.Xenakis.Sieve",
          "name": "()",
          "package": "hmt",
          "signature": "Sieve -\u003e Sieve -\u003e Sieve",
          "source": "src/Music-Theory-Xenakis-Sieve.html#%2229",
          "type": "function"
        },
        "index": {
          "description": "Unicode synonym for Intersection",
          "hierarchy": "Music Theory Xenakis Sieve",
          "module": "Music.Theory.Xenakis.Sieve",
          "name": "() ",
          "normalized": "Sieve-\u003eSieve-\u003eSieve",
          "package": "hmt",
          "signature": "Sieve-\u003eSieve-\u003eSieve",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Xenakis-Sieve.html#v:-8745-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUnicode synonym for \u003ccode\u003e\u003ca\u003eUnion\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Music.Theory.Xenakis.Sieve",
          "name": "()",
          "package": "hmt",
          "signature": "Sieve -\u003e Sieve -\u003e Sieve",
          "source": "src/Music-Theory-Xenakis-Sieve.html#%222A",
          "type": "function"
        },
        "index": {
          "description": "Unicode synonym for Union",
          "hierarchy": "Music Theory Xenakis Sieve",
          "module": "Music.Theory.Xenakis.Sieve",
          "name": "() ",
          "normalized": "Sieve-\u003eSieve-\u003eSieve",
          "package": "hmt",
          "signature": "Sieve-\u003eSieve-\u003eSieve",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Xenakis-Sieve.html#v:-8746-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eunicode synonym for \u003ccode\u003e\u003ca\u003el\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Music.Theory.Xenakis.Sieve",
          "name": "()",
          "package": "hmt",
          "signature": "I -\u003e I -\u003e Sieve",
          "source": "src/Music-Theory-Xenakis-Sieve.html#%22C4",
          "type": "function"
        },
        "index": {
          "description": "unicode synonym for",
          "hierarchy": "Music Theory Xenakis Sieve",
          "module": "Music.Theory.Xenakis.Sieve",
          "name": "() ",
          "normalized": "I-\u003eI-\u003eSieve",
          "package": "hmt",
          "signature": "I-\u003eI-\u003eSieve",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Xenakis-Sieve.html#v:-8900-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eEmpty\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eSieve\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Music.Theory.Xenakis.Sieve",
          "name": "Empty",
          "package": "hmt",
          "signature": "Empty",
          "source": "src/Music-Theory-Xenakis-Sieve.html#Sieve",
          "type": "function"
        },
        "index": {
          "description": "Empty Sieve",
          "hierarchy": "Music Theory Xenakis Sieve",
          "module": "Music.Theory.Xenakis.Sieve",
          "name": "Empty",
          "package": "hmt",
          "partial": "Empty",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Xenakis-Sieve.html#v:Empty"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eIntersection\u003c/a\u003e\u003c/code\u003e of two \u003ccode\u003e\u003ca\u003eSieve\u003c/a\u003e\u003c/code\u003es\n\u003c/p\u003e",
          "module": "Music.Theory.Xenakis.Sieve",
          "name": "Intersection",
          "package": "hmt",
          "signature": "Intersection Sieve Sieve",
          "source": "src/Music-Theory-Xenakis-Sieve.html#Sieve",
          "type": "function"
        },
        "index": {
          "description": "Intersection of two Sieve",
          "hierarchy": "Music Theory Xenakis Sieve",
          "module": "Music.Theory.Xenakis.Sieve",
          "name": "Intersection",
          "package": "hmt",
          "partial": "Intersection",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Xenakis-Sieve.html#v:Intersection"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePrimitive \u003ccode\u003e\u003ca\u003eSieve\u003c/a\u003e\u003c/code\u003e of \u003cem\u003emodulo\u003c/em\u003e and \u003cem\u003eindex\u003c/em\u003e\n\u003c/p\u003e",
          "module": "Music.Theory.Xenakis.Sieve",
          "name": "L",
          "package": "hmt",
          "signature": "L (I, I)",
          "source": "src/Music-Theory-Xenakis-Sieve.html#Sieve",
          "type": "function"
        },
        "index": {
          "description": "Primitive Sieve of modulo and index",
          "hierarchy": "Music Theory Xenakis Sieve",
          "module": "Music.Theory.Xenakis.Sieve",
          "name": "L",
          "normalized": "L(I,I)",
          "package": "hmt",
          "signature": "L(I,I)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Xenakis-Sieve.html#v:L"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eUnion\u003c/a\u003e\u003c/code\u003e of two \u003ccode\u003e\u003ca\u003eSieve\u003c/a\u003e\u003c/code\u003es\n\u003c/p\u003e",
          "module": "Music.Theory.Xenakis.Sieve",
          "name": "Union",
          "package": "hmt",
          "signature": "Union Sieve Sieve",
          "source": "src/Music-Theory-Xenakis-Sieve.html#Sieve",
          "type": "function"
        },
        "index": {
          "description": "Union of two Sieve",
          "hierarchy": "Music Theory Xenakis Sieve",
          "module": "Music.Theory.Xenakis.Sieve",
          "name": "Union",
          "package": "hmt",
          "partial": "Union",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Xenakis-Sieve.html#v:Union"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstruct the sequence defined by a \u003ccode\u003e\u003ca\u003eSieve\u003c/a\u003e\u003c/code\u003e.  Note that building\n a sieve that contains an intersection clause that has no elements\n gives \u003ccode\u003e_|_\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e let d = [0,2,4,5,7,9,11]\n in take 7 (build (union (map (l 12) d))) == d\n\u003c/pre\u003e",
          "module": "Music.Theory.Xenakis.Sieve",
          "name": "build",
          "package": "hmt",
          "signature": "Sieve -\u003e [I]",
          "source": "src/Music-Theory-Xenakis-Sieve.html#build",
          "type": "function"
        },
        "index": {
          "description": "Construct the sequence defined by Sieve Note that building sieve that contains an intersection clause that has no elements gives let in take build union map",
          "hierarchy": "Music Theory Xenakis Sieve",
          "module": "Music.Theory.Xenakis.Sieve",
          "name": "build",
          "normalized": "Sieve-\u003e[I]",
          "package": "hmt",
          "signature": "Sieve-\u003e[I]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Xenakis-Sieve.html#v:build"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eVariant of \u003ccode\u003e\u003ca\u003ebuild\u003c/a\u003e\u003c/code\u003e that gives the first \u003cem\u003en\u003c/em\u003e places of the\n \u003ccode\u003e\u003ca\u003ereduce\u003c/a\u003e\u003c/code\u003e of \u003ccode\u003e\u003ca\u003eSieve\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e buildn 6 (union (map (l 8) [0,3,6])) == [0,3,6,8,11,14]\n buildn 12 (L (3,2)) == [2,5,8,11,14,17,20,23,26,29,32,35]\n buildn 9 (L (8,0)) == [0,8,16,24,32,40,48,56,64]\n buildn 3 (L (3,2) &#8745; L (8,0)) == [8,32,56]\n buildn 12 (L (3,1) &#8746; L (4,0)) == [0,1,4,7,8,10,12,13,16,19,20,22]\n buildn 14 (5&#8900;4 &#8746; 3&#8900;2 &#8746; 7&#8900;3) == [2,3,4,5,8,9,10,11,14,17,19,20,23,24]\n buildn 6 (3&#8900;0 &#8746; 4&#8900;0) == [0,3,4,6,8,9]\n buildn 8 (5&#8900;2 &#8745; 2&#8900;0 &#8746; 7&#8900;3) == [2,3,10,12,17,22,24,31]\n buildn 12 (5&#8900;1 &#8746; 7&#8900;2) == [1,2,6,9,11,16,21,23,26,30,31,36]\n\u003c/pre\u003e\u003cpre\u003e buildn 10 (3&#8900;2 &#8745; 4&#8900;7 &#8746; 6&#8900;9 &#8745; 15&#8900;18) == [3,11,23,33,35,47,59,63,71,83]\n\u003c/pre\u003e\u003cpre\u003e let s = 3&#8900;2&#8745;4&#8900;7&#8745;6&#8900;11&#8745;8&#8900;7 &#8746; 6&#8900;9&#8745;15&#8900;18 &#8746; 13&#8900;5&#8745;8&#8900;6&#8745;4&#8900;2 &#8746; 6&#8900;9&#8745;15&#8900;19\n in buildn 16 s == buildn 16 (24&#8900;23 &#8746; 30&#8900;3 &#8746; 104&#8900;70)\n\u003c/pre\u003e\u003cpre\u003e buildn 10 (24&#8900;23 &#8746; 30&#8900;3 &#8746; 104&#8900;70) == [3,23,33,47,63,70,71,93,95,119]\n\u003c/pre\u003e",
          "module": "Music.Theory.Xenakis.Sieve",
          "name": "buildn",
          "package": "hmt",
          "signature": "Int -\u003e Sieve -\u003e [I]",
          "source": "src/Music-Theory-Xenakis-Sieve.html#buildn",
          "type": "function"
        },
        "index": {
          "description": "Variant of build that gives the first places of the reduce of Sieve buildn union map buildn buildn buildn buildn buildn buildn buildn buildn buildn let in buildn buildn buildn",
          "hierarchy": "Music Theory Xenakis Sieve",
          "module": "Music.Theory.Xenakis.Sieve",
          "name": "buildn",
          "normalized": "Int-\u003eSieve-\u003e[I]",
          "package": "hmt",
          "signature": "Int-\u003eSieve-\u003e[I]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Xenakis-Sieve.html#v:buildn"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eBachet De M&#233;ziriac's algorithm.\n\u003c/p\u003e\u003cpre\u003e de_meziriac 15 4 == 3 && euclid 15 4 == 1\n\u003c/pre\u003e",
          "module": "Music.Theory.Xenakis.Sieve",
          "name": "de_meziriac",
          "package": "hmt",
          "signature": "a -\u003e a -\u003e a",
          "source": "src/Music-Theory-Xenakis-Sieve.html#de_meziriac",
          "type": "function"
        },
        "index": {
          "description": "Bachet De ziriac algorithm de meziriac euclid",
          "hierarchy": "Music Theory Xenakis Sieve",
          "module": "Music.Theory.Xenakis.Sieve",
          "name": "de_meziriac",
          "normalized": "a-\u003ea-\u003ea",
          "package": "hmt",
          "signature": "a-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Xenakis-Sieve.html#v:de_meziriac"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eStandard differentiation function.\n\u003c/p\u003e\u003cpre\u003e differentiate [1,3,6,10] == [2,3,4]\n differentiate [0,2,4,5,7,9,11,12] == [2,2,1,2,2,2,1]\n\u003c/pre\u003e",
          "module": "Music.Theory.Xenakis.Sieve",
          "name": "differentiate",
          "package": "hmt",
          "signature": "[a] -\u003e [a]",
          "source": "src/Music-Theory-Xenakis-Sieve.html#differentiate",
          "type": "function"
        },
        "index": {
          "description": "Standard differentiation function differentiate differentiate",
          "hierarchy": "Music Theory Xenakis Sieve",
          "module": "Music.Theory.Xenakis.Sieve",
          "name": "differentiate",
          "normalized": "[a]-\u003e[a]",
          "package": "hmt",
          "signature": "[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Xenakis-Sieve.html#v:differentiate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePredicate to determine if an \u003ccode\u003e\u003ca\u003eI\u003c/a\u003e\u003c/code\u003e is an element of the \u003ccode\u003e\u003ca\u003eSieve\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e map (element (L (3,1))) [1..4] == [True,False,False,True]\n map (element (L (15,4))) [4,19 .. 49] == [True,True,True,True]\n\u003c/pre\u003e",
          "module": "Music.Theory.Xenakis.Sieve",
          "name": "element",
          "package": "hmt",
          "signature": "Sieve -\u003e I -\u003e Bool",
          "source": "src/Music-Theory-Xenakis-Sieve.html#element",
          "type": "function"
        },
        "index": {
          "description": "Predicate to determine if an is an element of the Sieve map element True False False True map element True True True True",
          "hierarchy": "Music Theory Xenakis Sieve",
          "module": "Music.Theory.Xenakis.Sieve",
          "name": "element",
          "normalized": "Sieve-\u003eI-\u003eBool",
          "package": "hmt",
          "signature": "Sieve-\u003eI-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Xenakis-Sieve.html#v:element"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEuclid's algorithm for computing the greatest common divisor.\n\u003c/p\u003e\u003cpre\u003e euclid 1989 867 == 51\n\u003c/pre\u003e",
          "module": "Music.Theory.Xenakis.Sieve",
          "name": "euclid",
          "package": "hmt",
          "signature": "a -\u003e a -\u003e a",
          "source": "src/Music-Theory-Xenakis-Sieve.html#euclid",
          "type": "function"
        },
        "index": {
          "description": "Euclid algorithm for computing the greatest common divisor euclid",
          "hierarchy": "Music Theory Xenakis Sieve",
          "module": "Music.Theory.Xenakis.Sieve",
          "name": "euclid",
          "normalized": "a-\u003ea-\u003ea",
          "package": "hmt",
          "signature": "a-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Xenakis-Sieve.html#v:euclid"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003eIntersection\u003c/a\u003e\u003c/code\u003e of a list of \u003ccode\u003e\u003ca\u003eSieve\u003c/a\u003e\u003c/code\u003es, ie. \u003ccode\u003e\u003ca\u003efoldl1\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eIntersection\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Music.Theory.Xenakis.Sieve",
          "name": "intersection",
          "package": "hmt",
          "signature": "[Sieve] -\u003e Sieve",
          "source": "src/Music-Theory-Xenakis-Sieve.html#intersection",
          "type": "function"
        },
        "index": {
          "description": "The Intersection of list of Sieve ie foldl1 Intersection",
          "hierarchy": "Music Theory Xenakis Sieve",
          "module": "Music.Theory.Xenakis.Sieve",
          "name": "intersection",
          "normalized": "[Sieve]-\u003eSieve",
          "package": "hmt",
          "signature": "[Sieve]-\u003eSieve",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Xenakis-Sieve.html#v:intersection"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePredicate to test if a \u003ccode\u003e\u003ca\u003eSieve\u003c/a\u003e\u003c/code\u003e is \u003cem\u003enormal\u003c/em\u003e.\n\u003c/p\u003e\u003cpre\u003e is_normal (L (15,4)) == True\n\u003c/pre\u003e",
          "module": "Music.Theory.Xenakis.Sieve",
          "name": "is_normal",
          "package": "hmt",
          "signature": "Sieve -\u003e Bool",
          "source": "src/Music-Theory-Xenakis-Sieve.html#is_normal",
          "type": "function"
        },
        "index": {
          "description": "Predicate to test if Sieve is normal is normal True",
          "hierarchy": "Music Theory Xenakis Sieve",
          "module": "Music.Theory.Xenakis.Sieve",
          "name": "is_normal",
          "normalized": "Sieve-\u003eBool",
          "package": "hmt",
          "signature": "Sieve-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Xenakis-Sieve.html#v:is_normal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eVariant of \u003ccode\u003e\u003ca\u003eL\u003c/a\u003e\u003c/code\u003e, ie. \u003ccode\u003e\u003ca\u003ecurry\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eL\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e l 15 19 == L (15,19)\n\u003c/pre\u003e",
          "module": "Music.Theory.Xenakis.Sieve",
          "name": "l",
          "package": "hmt",
          "signature": "I -\u003e I -\u003e Sieve",
          "source": "src/Music-Theory-Xenakis-Sieve.html#l",
          "type": "function"
        },
        "index": {
          "description": "Variant of ie curry",
          "hierarchy": "Music Theory Xenakis Sieve",
          "module": "Music.Theory.Xenakis.Sieve",
          "name": "l",
          "normalized": "I-\u003eI-\u003eSieve",
          "package": "hmt",
          "signature": "I-\u003eI-\u003eSieve",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Xenakis-Sieve.html#v:l"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIn a \u003cem\u003enormal\u003c/em\u003e \u003ccode\u003e\u003ca\u003eSieve\u003c/a\u003e\u003c/code\u003e \u003cem\u003em\u003c/em\u003e is \u003ccode\u003e\u003ca\u003e\u003e\u003c/a\u003e\u003c/code\u003e \u003cem\u003ei\u003c/em\u003e.\n\u003c/p\u003e\u003cpre\u003e normalise (L (15,19)) == L (15,4)\n\u003c/pre\u003e",
          "module": "Music.Theory.Xenakis.Sieve",
          "name": "normalise",
          "package": "hmt",
          "signature": "Sieve -\u003e Sieve",
          "source": "src/Music-Theory-Xenakis-Sieve.html#normalise",
          "type": "function"
        },
        "index": {
          "description": "In normal Sieve is normalise",
          "hierarchy": "Music Theory Xenakis Sieve",
          "module": "Music.Theory.Xenakis.Sieve",
          "name": "normalise",
          "normalized": "Sieve-\u003eSieve",
          "package": "hmt",
          "signature": "Sieve-\u003eSieve",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Xenakis-Sieve.html#v:normalise"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReduce the number of nodes at a \u003ccode\u003e\u003ca\u003eSieve\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e reduce (L (3,2) &#8746; Empty) == L (3,2)\n reduce (L (3,2) &#8745; Empty) == L (3,2)\n reduce (L (3,2) &#8745; L (4,7)) == L (12,11)\n reduce (L (6,9) &#8745; L (15,18)) == L (30,3)\n\u003c/pre\u003e\u003cpre\u003e let s = 3&#8900;2&#8745;4&#8900;7&#8745;6&#8900;11&#8745;8&#8900;7 &#8746; 6&#8900;9&#8745;15&#8900;18 &#8746; 13&#8900;5&#8745;8&#8900;6&#8745;4&#8900;2 &#8746; 6&#8900;9&#8745;15&#8900;19\n in reduce s == (24&#8900;23 &#8746; 30&#8900;3 &#8746; 104&#8900;70)\n\u003c/pre\u003e\u003cpre\u003e let s = 3&#8900;2&#8745;4&#8900;7&#8745;6&#8900;11&#8745;8&#8900;7 &#8746; 6&#8900;9&#8745;15&#8900;18 &#8746; 13&#8900;5&#8745;8&#8900;6&#8745;4&#8900;2 &#8746; 6&#8900;9&#8745;15&#8900;19\n in reduce s == (24&#8900;23 &#8746; 30&#8900;3 &#8746; 104&#8900;70)\n\u003c/pre\u003e",
          "module": "Music.Theory.Xenakis.Sieve",
          "name": "reduce",
          "package": "hmt",
          "signature": "Sieve -\u003e Sieve",
          "source": "src/Music-Theory-Xenakis-Sieve.html#reduce",
          "type": "function"
        },
        "index": {
          "description": "Reduce the number of nodes at Sieve reduce Empty reduce Empty reduce reduce let in reduce let in reduce",
          "hierarchy": "Music Theory Xenakis Sieve",
          "module": "Music.Theory.Xenakis.Sieve",
          "name": "reduce",
          "normalized": "Sieve-\u003eSieve",
          "package": "hmt",
          "signature": "Sieve-\u003eSieve",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Xenakis-Sieve.html#v:reduce"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAttempt to reduce the \u003ccode\u003e\u003ca\u003eIntersection\u003c/a\u003e\u003c/code\u003e of two \u003ccode\u003e\u003ca\u003eL\u003c/a\u003e\u003c/code\u003e nodes to a\n singular \u003ccode\u003e\u003ca\u003eL\u003c/a\u003e\u003c/code\u003e node.\n\u003c/p\u003e\u003cpre\u003e reduce_intersection (3,2) (4,7) == Just (12,11)\n reduce_intersection (12,11) (6,11) == Just (12,11)\n reduce_intersection (12,11) (8,7) == Just (24,23)\n\u003c/pre\u003e",
          "module": "Music.Theory.Xenakis.Sieve",
          "name": "reduce_intersection",
          "package": "hmt",
          "signature": "(t, t) -\u003e (t, t) -\u003e Maybe (t, t)",
          "source": "src/Music-Theory-Xenakis-Sieve.html#reduce_intersection",
          "type": "function"
        },
        "index": {
          "description": "Attempt to reduce the Intersection of two nodes to singular node reduce intersection Just reduce intersection Just reduce intersection Just",
          "hierarchy": "Music Theory Xenakis Sieve",
          "module": "Music.Theory.Xenakis.Sieve",
          "name": "reduce_intersection",
          "normalized": "(a,a)-\u003e(a,a)-\u003eMaybe(a,a)",
          "package": "hmt",
          "signature": "(t,t)-\u003e(t,t)-\u003eMaybe(t,t)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Xenakis-Sieve.html#v:reduce_intersection"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003eUnion\u003c/a\u003e\u003c/code\u003e of a list of \u003ccode\u003e\u003ca\u003eSieve\u003c/a\u003e\u003c/code\u003es, ie. \u003ccode\u003e\u003ca\u003efoldl1\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eUnion\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Music.Theory.Xenakis.Sieve",
          "name": "union",
          "package": "hmt",
          "signature": "[Sieve] -\u003e Sieve",
          "source": "src/Music-Theory-Xenakis-Sieve.html#union",
          "type": "function"
        },
        "index": {
          "description": "The Union of list of Sieve ie foldl1 Union",
          "hierarchy": "Music Theory Xenakis Sieve",
          "module": "Music.Theory.Xenakis.Sieve",
          "name": "union",
          "normalized": "[Sieve]-\u003eSieve",
          "package": "hmt",
          "signature": "[Sieve]-\u003eSieve",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Xenakis-Sieve.html#v:union"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eMarcus Castr&#233;n. \u003cem\u003eRECREL: A Similarity Measure for Set-Classes\u003c/em\u003e. PhD\n thesis, Sibelius Academy, Helsinki, 1994.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Music.Theory.Z12.Castren_1994",
          "name": "Castren_1994",
          "package": "hmt",
          "source": "src/Music-Theory-Z12-Castren_1994.html",
          "type": "module"
        },
        "index": {
          "description": "Marcus Castr RECREL Similarity Measure for Set-Classes PhD thesis Sibelius Academy Helsinki",
          "hierarchy": "Music Theory Z12 Castren_1994",
          "module": "Music.Theory.Z12.Castren_1994",
          "name": "Castren_1994",
          "package": "hmt",
          "partial": "Castren",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Z12-Castren_1994.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eicv\u003c/a\u003e\u003c/code\u003e scaled by sum of \u003cem\u003eicv\u003c/em\u003e.\n\u003c/p\u003e\u003cpre\u003e dyad_class_percentage_vector [0,1,2,3,4] == [40,30,20,10,0,0]\n dyad_class_percentage_vector [0,1,4,5,7] == [20,10,20,20,20,10]\n\u003c/pre\u003e",
          "module": "Music.Theory.Z12.Castren_1994",
          "name": "dyad_class_percentage_vector",
          "package": "hmt",
          "signature": "[Z12] -\u003e [i]",
          "source": "src/Music-Theory-Z12-Castren_1994.html#dyad_class_percentage_vector",
          "type": "function"
        },
        "index": {
          "description": "icv scaled by sum of icv dyad class percentage vector dyad class percentage vector",
          "hierarchy": "Music Theory Z12 Castren_1994",
          "module": "Music.Theory.Z12.Castren_1994",
          "name": "dyad_class_percentage_vector",
          "normalized": "[Z]-\u003e[a]",
          "package": "hmt",
          "signature": "[Z]-\u003e[i]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Z12-Castren_1994.html#v:dyad_class_percentage_vector"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIs \u003cem\u003ep\u003c/em\u003e symmetrical under inversion.\n\u003c/p\u003e\u003cpre\u003e map inv_sym (scs_n 2) == [True,True,True,True,True,True]\n map (fromEnum.inv_sym) (scs_n 3) == [1,0,0,0,0,1,0,0,1,1,0,1]\n\u003c/pre\u003e",
          "module": "Music.Theory.Z12.Castren_1994",
          "name": "inv_sym",
          "package": "hmt",
          "signature": "[Z12] -\u003e Bool",
          "source": "src/Music-Theory-Z12-Castren_1994.html#inv_sym",
          "type": "function"
        },
        "index": {
          "description": "Is symmetrical under inversion map inv sym scs True True True True True True map fromEnum.inv sym scs",
          "hierarchy": "Music Theory Z12 Castren_1994",
          "module": "Music.Theory.Z12.Castren_1994",
          "name": "inv_sym",
          "normalized": "[Z]-\u003eBool",
          "package": "hmt",
          "signature": "[Z]-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Z12-Castren_1994.html#v:inv_sym"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003erel\u003c/em\u003e metric.\n\u003c/p\u003e\u003cpre\u003e rel [0,1,2,3,4] [0,1,4,5,7] == 40\n rel [0,1,2,3,4] [0,2,4,6,8] == 60\n rel [0,1,4,5,7] [0,2,4,6,8] == 60\n\u003c/pre\u003e",
          "module": "Music.Theory.Z12.Castren_1994",
          "name": "rel",
          "package": "hmt",
          "signature": "[Z12] -\u003e [Z12] -\u003e Ratio i",
          "source": "src/Music-Theory-Z12-Castren_1994.html#rel",
          "type": "function"
        },
        "index": {
          "description": "rel metric rel rel rel",
          "hierarchy": "Music Theory Z12 Castren_1994",
          "module": "Music.Theory.Z12.Castren_1994",
          "name": "rel",
          "normalized": "[Z]-\u003e[Z]-\u003eRatio a",
          "package": "hmt",
          "signature": "[Z]-\u003e[Z]-\u003eRatio i",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Z12-Castren_1994.html#v:rel"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTrivial run length encoder.\n\u003c/p\u003e\u003cpre\u003e rle \"abbcccdde\" == [(1,'a'),(2,'b'),(3,'c'),(2,'d'),(1,'e')]\n\u003c/pre\u003e",
          "module": "Music.Theory.Z12.Castren_1994",
          "name": "rle",
          "package": "hmt",
          "signature": "[a] -\u003e [(i, a)]",
          "source": "src/Music-Theory-Z12-Castren_1994.html#rle",
          "type": "function"
        },
        "index": {
          "description": "Trivial run length encoder rle abbcccdde",
          "hierarchy": "Music Theory Z12 Castren_1994",
          "module": "Music.Theory.Z12.Castren_1994",
          "name": "rle",
          "normalized": "[a]-\u003e[(b,a)]",
          "package": "hmt",
          "signature": "[a]-\u003e[(i,a)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Z12-Castren_1994.html#v:rle"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInverse of \u003ccode\u003e\u003ca\u003erle\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e rle_decode [(5,'a'),(4,'b')] == \"aaaaabbbb\"\n\u003c/pre\u003e",
          "module": "Music.Theory.Z12.Castren_1994",
          "name": "rle_decode",
          "package": "hmt",
          "signature": "[(i, a)] -\u003e [a]",
          "source": "src/Music-Theory-Z12-Castren_1994.html#rle_decode",
          "type": "function"
        },
        "index": {
          "description": "Inverse of rle rle decode aaaaabbbb",
          "hierarchy": "Music Theory Z12 Castren_1994",
          "module": "Music.Theory.Z12.Castren_1994",
          "name": "rle_decode",
          "normalized": "[(a,b)]-\u003e[b]",
          "package": "hmt",
          "signature": "[(i,a)]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Z12-Castren_1994.html#v:rle_decode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLength of \u003cem\u003erle\u003c/em\u003e encoded sequence.\n\u003c/p\u003e\u003cpre\u003e rle_length [(5,'a'),(4,'b')] == 9\n\u003c/pre\u003e",
          "module": "Music.Theory.Z12.Castren_1994",
          "name": "rle_length",
          "package": "hmt",
          "signature": "[(i, a)] -\u003e i",
          "source": "src/Music-Theory-Z12-Castren_1994.html#rle_length",
          "type": "function"
        },
        "index": {
          "description": "Length of rle encoded sequence rle length",
          "hierarchy": "Music Theory Z12 Castren_1994",
          "module": "Music.Theory.Z12.Castren_1994",
          "name": "rle_length",
          "normalized": "[(a,b)]-\u003ea",
          "package": "hmt",
          "signature": "[(i,a)]-\u003ei",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Z12-Castren_1994.html#v:rle_length"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIf \u003cem\u003ep\u003c/em\u003e is not \u003ccode\u003e\u003ca\u003einv_sym\u003c/a\u003e\u003c/code\u003e then \u003ccode\u003e(p,invert 0 p)\u003c/code\u003e else \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e sc_t_ti [0,2,4] == Nothing\n sc_t_ti [0,1,3] == Just ([0,1,3],[0,2,3])\n\u003c/pre\u003e",
          "module": "Music.Theory.Z12.Castren_1994",
          "name": "sc_t_ti",
          "package": "hmt",
          "signature": "[Z12] -\u003e Maybe ([Z12], [Z12])",
          "source": "src/Music-Theory-Z12-Castren_1994.html#sc_t_ti",
          "type": "function"
        },
        "index": {
          "description": "If is not inv sym then invert else Nothing sc ti Nothing sc ti Just",
          "hierarchy": "Music Theory Z12 Castren_1994",
          "module": "Music.Theory.Z12.Castren_1994",
          "name": "sc_t_ti",
          "normalized": "[Z]-\u003eMaybe([Z],[Z])",
          "package": "hmt",
          "signature": "[Z]-\u003eMaybe([Z],[Z])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Z12-Castren_1994.html#v:sc_t_ti"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eT-equivalence \u003cem\u003en\u003c/em\u003e-class vector (subset-class vector, nCV).\n\u003c/p\u003e\u003cpre\u003e t_n_class_vector 2 [0..4] == [4,3,2,1,0,0]\n rle (t_n_class_vector 3 [0..4]) == [(1,3),(2,2),(2,1),(4,0),(1,1),(9,0)]\n rle (t_n_class_vector 4 [0..4]) == [(1,2),(3,1),(39,0)]\n\u003c/pre\u003e",
          "module": "Music.Theory.Z12.Castren_1994",
          "name": "t_n_class_vector",
          "package": "hmt",
          "signature": "i -\u003e [Z12] -\u003e [a]",
          "source": "src/Music-Theory-Z12-Castren_1994.html#t_n_class_vector",
          "type": "function"
        },
        "index": {
          "description": "T-equivalence class vector subset-class vector nCV class vector rle class vector rle class vector",
          "hierarchy": "Music Theory Z12 Castren_1994",
          "module": "Music.Theory.Z12.Castren_1994",
          "name": "t_n_class_vector",
          "normalized": "a-\u003e[Z]-\u003e[b]",
          "package": "hmt",
          "signature": "i-\u003e[Z]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Z12-Castren_1994.html#v:t_n_class_vector"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTranspositional equivalence prime form, ie. \u003ccode\u003e\u003ca\u003et_cmp_prime\u003c/a\u003e\u003c/code\u003e of\n \u003ccode\u003e\u003ca\u003eforte_cmp\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e (forte_prime [0,2,3],t_prime [0,2,3]) == ([0,1,3],[0,2,3])\n\u003c/pre\u003e",
          "module": "Music.Theory.Z12.Castren_1994",
          "name": "t_prime",
          "package": "hmt",
          "signature": "[Z12] -\u003e [Z12]",
          "source": "src/Music-Theory-Z12-Castren_1994.html#t_prime",
          "type": "function"
        },
        "index": {
          "description": "Transpositional equivalence prime form ie cmp prime of forte cmp forte prime prime",
          "hierarchy": "Music Theory Z12 Castren_1994",
          "module": "Music.Theory.Z12.Castren_1994",
          "name": "t_prime",
          "normalized": "[Z]-\u003e[Z]",
          "package": "hmt",
          "signature": "[Z]-\u003e[Z]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Z12-Castren_1994.html#v:t_prime"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLookup a set-class given a set-class name.\n\u003c/p\u003e\u003cpre\u003e t_sc \"6-Z17A\" == [0,1,2,4,7,8]\n\u003c/pre\u003e",
          "module": "Music.Theory.Z12.Castren_1994",
          "name": "t_sc",
          "package": "hmt",
          "signature": "SC_Name -\u003e [Z12]",
          "source": "src/Music-Theory-Z12-Castren_1994.html#t_sc",
          "type": "function"
        },
        "index": {
          "description": "Lookup set-class given set-class name sc Z17A",
          "hierarchy": "Music Theory Z12 Castren_1994",
          "module": "Music.Theory.Z12.Castren_1994",
          "name": "t_sc",
          "normalized": "SC_Name-\u003e[Z]",
          "package": "hmt",
          "signature": "SC_Name-\u003e[Z]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Z12-Castren_1994.html#v:t_sc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLookup a set-class name.  The input set is subject to\n \u003ccode\u003e\u003ca\u003et_prime\u003c/a\u003e\u003c/code\u003e before lookup.\n\u003c/p\u003e\u003cpre\u003e t_sc_name [0,2,3,6,7] == \"5-Z18B\"\n t_sc_name [0,1,4,6,7,8] == \"6-Z17B\"\n\u003c/pre\u003e",
          "module": "Music.Theory.Z12.Castren_1994",
          "name": "t_sc_name",
          "package": "hmt",
          "signature": "[Z12] -\u003e SC_Name",
          "source": "src/Music-Theory-Z12-Castren_1994.html#t_sc_name",
          "type": "function"
        },
        "index": {
          "description": "Lookup set-class name The input set is subject to prime before lookup sc name Z18B sc name Z17B",
          "hierarchy": "Music Theory Z12 Castren_1994",
          "module": "Music.Theory.Z12.Castren_1994",
          "name": "t_sc_name",
          "normalized": "[Z]-\u003eSC_Name",
          "package": "hmt",
          "signature": "[Z]-\u003eSC_Name",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Z12-Castren_1994.html#v:t_sc_name"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTranspositional equivalence variant of Forte's \u003ccode\u003e\u003ca\u003esc_table\u003c/a\u003e\u003c/code\u003e.  The\n inversionally related classes are distinguished by labels \u003ccode\u003eA\u003c/code\u003e and\n \u003ccode\u003eB\u003c/code\u003e; the class providing the \u003cem\u003ebest normal order\u003c/em\u003e (Forte 1973) is\n always the \u003ccode\u003eA\u003c/code\u003e class. If neither \u003ccode\u003eA\u003c/code\u003e nor \u003ccode\u003eB\u003c/code\u003e appears in the name of\n a set-class, it is inversionally symmetrical.\n\u003c/p\u003e\u003cpre\u003e (length sc_table,length t_sc_table) == (224,352)\n lookup \"5-Z18B\" t_sc_table == Just [0,2,3,6,7]\n\u003c/pre\u003e",
          "module": "Music.Theory.Z12.Castren_1994",
          "name": "t_sc_table",
          "package": "hmt",
          "signature": "[(SC_Name, [Z12])]",
          "source": "src/Music-Theory-Z12-Castren_1994.html#t_sc_table",
          "type": "function"
        },
        "index": {
          "description": "Transpositional equivalence variant of Forte sc table The inversionally related classes are distinguished by labels and the class providing the best normal order Forte is always the class If neither nor appears in the name of set-class it is inversionally symmetrical length sc table length sc table lookup Z18B sc table Just",
          "hierarchy": "Music Theory Z12 Castren_1994",
          "module": "Music.Theory.Z12.Castren_1994",
          "name": "t_sc_table",
          "normalized": "[(SC_Name,[Z])]",
          "package": "hmt",
          "signature": "[(SC_Name,[Z])]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Z12-Castren_1994.html#v:t_sc_table"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eList of set classes.\n\u003c/p\u003e",
          "module": "Music.Theory.Z12.Castren_1994",
          "name": "t_scs",
          "package": "hmt",
          "signature": "[[Z12]]",
          "source": "src/Music-Theory-Z12-Castren_1994.html#t_scs",
          "type": "function"
        },
        "index": {
          "description": "List of set classes",
          "hierarchy": "Music Theory Z12 Castren_1994",
          "module": "Music.Theory.Z12.Castren_1994",
          "name": "t_scs",
          "normalized": "[[Z]]",
          "package": "hmt",
          "signature": "[[Z]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Z12-Castren_1994.html#v:t_scs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCardinality \u003cem\u003en\u003c/em\u003e subset of \u003ccode\u003e\u003ca\u003et_scs\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e map (length . t_scs_n) [2..10] == [6,19,43,66,80,66,43,19,6]\n\u003c/pre\u003e",
          "module": "Music.Theory.Z12.Castren_1994",
          "name": "t_scs_n",
          "package": "hmt",
          "signature": "i -\u003e [[Z12]]",
          "source": "src/Music-Theory-Z12-Castren_1994.html#t_scs_n",
          "type": "function"
        },
        "index": {
          "description": "Cardinality subset of scs map length scs",
          "hierarchy": "Music Theory Z12 Castren_1994",
          "module": "Music.Theory.Z12.Castren_1994",
          "name": "t_scs_n",
          "normalized": "a-\u003e[[Z]]",
          "package": "hmt",
          "signature": "i-\u003e[[Z]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Z12-Castren_1994.html#v:t_scs_n"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eT-related \u003cem\u003eq\u003c/em\u003e that are subsets of \u003cem\u003ep\u003c/em\u003e.\n\u003c/p\u003e\u003cpre\u003e t_subsets [0,1,2,3,4] [0,1]  == [[0,1],[1,2],[2,3],[3,4]]\n t_subsets [0,1,2,3,4] [0,1,4] == [[0,1,4]]\n t_subsets [0,2,3,6,7] [0,1,4] == [[2,3,6]]\n\u003c/pre\u003e",
          "module": "Music.Theory.Z12.Castren_1994",
          "name": "t_subsets",
          "package": "hmt",
          "signature": "[Z12] -\u003e [Z12] -\u003e [[Z12]]",
          "source": "src/Music-Theory-Z12-Castren_1994.html#t_subsets",
          "type": "function"
        },
        "index": {
          "description": "T-related that are subsets of subsets subsets subsets",
          "hierarchy": "Music Theory Z12 Castren_1994",
          "module": "Music.Theory.Z12.Castren_1994",
          "name": "t_subsets",
          "normalized": "[Z]-\u003e[Z]-\u003e[[Z]]",
          "package": "hmt",
          "signature": "[Z]-\u003e[Z]-\u003e[[Z]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Z12-Castren_1994.html#v:t_subsets"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eT/I-equivalence \u003cem\u003en\u003c/em\u003e-class vector (subset-class vector, nCV).\n\u003c/p\u003e\u003cpre\u003e ti_n_class_vector 2 [0..4] == [4,3,2,1,0,0]\n ti_n_class_vector 3 [0,1,2,3,4] == [3,4,2,0,0,1,0,0,0,0,0,0]\n rle (ti_n_class_vector 4 [0,1,2,3,4]) == [(2,2),(1,1),(26,0)]\n\u003c/pre\u003e",
          "module": "Music.Theory.Z12.Castren_1994",
          "name": "ti_n_class_vector",
          "package": "hmt",
          "signature": "i -\u003e [Z12] -\u003e [b]",
          "source": "src/Music-Theory-Z12-Castren_1994.html#ti_n_class_vector",
          "type": "function"
        },
        "index": {
          "description": "I-equivalence class vector subset-class vector nCV ti class vector ti class vector rle ti class vector",
          "hierarchy": "Music Theory Z12 Castren_1994",
          "module": "Music.Theory.Z12.Castren_1994",
          "name": "ti_n_class_vector",
          "normalized": "a-\u003e[Z]-\u003e[b]",
          "package": "hmt",
          "signature": "i-\u003e[Z]-\u003e[b]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Z12-Castren_1994.html#v:ti_n_class_vector"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eT/I-related \u003cem\u003eq\u003c/em\u003e that are subsets of \u003cem\u003ep\u003c/em\u003e.\n\u003c/p\u003e\u003cpre\u003e ti_subsets [0,1,2,3,4] [0,1]  == [[0,1],[1,2],[2,3],[3,4]]\n ti_subsets [0,1,2,3,4] [0,1,4] == [[0,1,4],[0,3,4]]\n ti_subsets [0,2,3,6,7] [0,1,4] == [[2,3,6],[3,6,7]]\n\u003c/pre\u003e",
          "module": "Music.Theory.Z12.Castren_1994",
          "name": "ti_subsets",
          "package": "hmt",
          "signature": "[Z12] -\u003e [Z12] -\u003e [[Z12]]",
          "source": "src/Music-Theory-Z12-Castren_1994.html#ti_subsets",
          "type": "function"
        },
        "index": {
          "description": "I-related that are subsets of ti subsets ti subsets ti subsets",
          "hierarchy": "Music Theory Z12 Castren_1994",
          "module": "Music.Theory.Z12.Castren_1994",
          "name": "ti_subsets",
          "normalized": "[Z]-\u003e[Z]-\u003e[[Z]]",
          "package": "hmt",
          "signature": "[Z]-\u003e[Z]-\u003e[[Z]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Z12-Castren_1994.html#v:ti_subsets"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eHaskell implementations of \u003ccode\u003epct\u003c/code\u003e operations.\n See \u003ca\u003ehttp://slavepianos.org/rd/?t=pct\u003c/a\u003e.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Music.Theory.Z12.Drape_1999",
          "name": "Drape_1999",
          "package": "hmt",
          "source": "src/Music-Theory-Z12-Drape_1999.html",
          "type": "module"
        },
        "index": {
          "description": "Haskell implementations of pct operations See http slavepianos.org rd pct",
          "hierarchy": "Music Theory Z12 Drape_1999",
          "module": "Music.Theory.Z12.Drape_1999",
          "name": "Drape_1999",
          "package": "hmt",
          "partial": "Drape",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Z12-Drape_1999.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCardinality filter\n\u003c/p\u003e\u003cpre\u003e cf [0,3] (cg [1..4]) == [[1,2,3],[1,2,4],[1,3,4],[2,3,4],[]]\n\u003c/pre\u003e",
          "module": "Music.Theory.Z12.Drape_1999",
          "name": "cf",
          "package": "hmt",
          "signature": "[n] -\u003e [[a]] -\u003e [[a]]",
          "source": "src/Music-Theory-Z12-Drape_1999.html#cf",
          "type": "function"
        },
        "index": {
          "description": "Cardinality filter cf cg",
          "hierarchy": "Music Theory Z12 Drape_1999",
          "module": "Music.Theory.Z12.Drape_1999",
          "name": "cf",
          "normalized": "[a]-\u003e[[b]]-\u003e[[b]]",
          "package": "hmt",
          "signature": "[n]-\u003e[[a]]-\u003e[[a]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Z12-Drape_1999.html#v:cf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCombinations generator, ie. synonym for \u003ccode\u003e\u003ca\u003epowerset\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e sort (cg [0,1,3]) == [[],[0],[0,1],[0,1,3],[0,3],[1],[1,3],[3]]\n\u003c/pre\u003e",
          "module": "Music.Theory.Z12.Drape_1999",
          "name": "cg",
          "package": "hmt",
          "signature": "[a] -\u003e [[a]]",
          "source": "src/Music-Theory-Z12-Drape_1999.html#cg",
          "type": "function"
        },
        "index": {
          "description": "Combinations generator ie synonym for powerset sort cg",
          "hierarchy": "Music Theory Z12 Drape_1999",
          "module": "Music.Theory.Z12.Drape_1999",
          "name": "cg",
          "normalized": "[a]-\u003e[[a]]",
          "package": "hmt",
          "signature": "[a]-\u003e[[a]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Z12-Drape_1999.html#v:cg"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePowerset filtered by cardinality.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003ecg -r3 0159\n\u003c/code\u003e\u003c/strong\u003e015\n019\n059\n159\n\u003c/pre\u003e\u003cpre\u003e cg_r 3 [0,1,5,9] == [[0,1,5],[0,1,9],[0,5,9],[1,5,9]]\n\u003c/pre\u003e",
          "module": "Music.Theory.Z12.Drape_1999",
          "name": "cg_r",
          "package": "hmt",
          "signature": "n -\u003e [a] -\u003e [[a]]",
          "source": "src/Music-Theory-Z12-Drape_1999.html#cg_r",
          "type": "function"
        },
        "index": {
          "description": "Powerset filtered by cardinality cg r3 cg",
          "hierarchy": "Music Theory Z12 Drape_1999",
          "module": "Music.Theory.Z12.Drape_1999",
          "name": "cg_r",
          "normalized": "a-\u003e[b]-\u003e[[b]]",
          "package": "hmt",
          "signature": "n-\u003e[a]-\u003e[[a]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Z12-Drape_1999.html#v:cg_r"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCombinatorial sets formed by considering each set as possible\n values for slot.\n\u003c/p\u003e\u003cpre\u003e cgg [[0,1],[5,7],[3]] == [[0,5,3],[0,7,3],[1,5,3],[1,7,3]]\n\u003c/pre\u003e",
          "module": "Music.Theory.Z12.Drape_1999",
          "name": "cgg",
          "package": "hmt",
          "signature": "[[a]] -\u003e [[a]]",
          "source": "src/Music-Theory-Z12-Drape_1999.html#cgg",
          "type": "function"
        },
        "index": {
          "description": "Combinatorial sets formed by considering each set as possible values for slot cgg",
          "hierarchy": "Music Theory Z12 Drape_1999",
          "module": "Music.Theory.Z12.Drape_1999",
          "name": "cgg",
          "normalized": "[[a]]-\u003e[[a]]",
          "package": "hmt",
          "signature": "[[a]]-\u003e[[a]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Z12-Drape_1999.html#v:cgg"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCyclic interval segment.\n\u003c/p\u003e",
          "module": "Music.Theory.Z12.Drape_1999",
          "name": "ciseg",
          "package": "hmt",
          "signature": "[Z12] -\u003e [Z12]",
          "source": "src/Music-Theory-Z12-Drape_1999.html#ciseg",
          "type": "function"
        },
        "index": {
          "description": "Cyclic interval segment",
          "hierarchy": "Music Theory Z12 Drape_1999",
          "module": "Music.Theory.Z12.Drape_1999",
          "name": "ciseg",
          "normalized": "[Z]-\u003e[Z]",
          "package": "hmt",
          "signature": "[Z]-\u003e[Z]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Z12-Drape_1999.html#v:ciseg"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSynonynm for \u003ccode\u003e\u003ca\u003ecomplement\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003ecmpl 02468t\n\u003c/code\u003e\u003c/strong\u003e13579B\n\u003c/pre\u003e\u003cpre\u003e cmpl [0,2,4,6,8,10] == [1,3,5,7,9,11]\n\u003c/pre\u003e",
          "module": "Music.Theory.Z12.Drape_1999",
          "name": "cmpl",
          "package": "hmt",
          "signature": "[Z12] -\u003e [Z12]",
          "source": "src/Music-Theory-Z12-Drape_1999.html#cmpl",
          "type": "function"
        },
        "index": {
          "description": "Synonynm for complement cmpl cmpl",
          "hierarchy": "Music Theory Z12 Drape_1999",
          "module": "Music.Theory.Z12.Drape_1999",
          "name": "cmpl",
          "normalized": "[Z]-\u003e[Z]",
          "package": "hmt",
          "signature": "[Z]-\u003e[Z]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Z12-Drape_1999.html#v:cmpl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eForm cycle.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003ecyc 056\n\u003c/code\u003e\u003c/strong\u003e0560\n\u003c/pre\u003e\u003cpre\u003e cyc [0,5,6] == [0,5,6,0]\n\u003c/pre\u003e",
          "module": "Music.Theory.Z12.Drape_1999",
          "name": "cyc",
          "package": "hmt",
          "signature": "[a] -\u003e [a]",
          "source": "src/Music-Theory-Z12-Drape_1999.html#cyc",
          "type": "function"
        },
        "index": {
          "description": "Form cycle cyc cyc",
          "hierarchy": "Music Theory Z12 Drape_1999",
          "module": "Music.Theory.Z12.Drape_1999",
          "name": "cyc",
          "normalized": "[a]-\u003e[a]",
          "package": "hmt",
          "signature": "[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Z12-Drape_1999.html#v:cyc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDiatonic set name. \u003ccode\u003ed\u003c/code\u003e for diatonic set, \u003ccode\u003em\u003c/code\u003e for melodic minor\n set, \u003ccode\u003eo\u003c/code\u003e for octotonic set.\n\u003c/p\u003e",
          "module": "Music.Theory.Z12.Drape_1999",
          "name": "d_nm",
          "package": "hmt",
          "signature": "[a] -\u003e Maybe Char",
          "source": "src/Music-Theory-Z12-Drape_1999.html#d_nm",
          "type": "function"
        },
        "index": {
          "description": "Diatonic set name for diatonic set for melodic minor set for octotonic set",
          "hierarchy": "Music Theory Z12 Drape_1999",
          "module": "Music.Theory.Z12.Drape_1999",
          "name": "d_nm",
          "normalized": "[a]-\u003eMaybe Char",
          "package": "hmt",
          "signature": "[a]-\u003eMaybe Char",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Z12-Drape_1999.html#v:d_nm"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDiatonic implications.\n\u003c/p\u003e",
          "module": "Music.Theory.Z12.Drape_1999",
          "name": "dim",
          "package": "hmt",
          "signature": "[Z12] -\u003e [(Z12, [Z12])]",
          "source": "src/Music-Theory-Z12-Drape_1999.html#dim",
          "type": "function"
        },
        "index": {
          "description": "Diatonic implications",
          "hierarchy": "Music Theory Z12 Drape_1999",
          "module": "Music.Theory.Z12.Drape_1999",
          "name": "dim",
          "normalized": "[Z]-\u003e[(Z,[Z])]",
          "package": "hmt",
          "signature": "[Z]-\u003e[(Z,[Z])]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Z12-Drape_1999.html#v:dim"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eVariant of \u003ccode\u003e\u003ca\u003edim\u003c/a\u003e\u003c/code\u003e that is closer to the \u003ccode\u003epct\u003c/code\u003e form.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003edim 016\n\u003c/code\u003e\u003c/strong\u003eT1d\nT1m\nT0o\n\u003c/pre\u003e\u003cpre\u003e dim_nm [0,1,6] == [(1,'d'),(1,'m'),(0,'o')]\n\u003c/pre\u003e",
          "module": "Music.Theory.Z12.Drape_1999",
          "name": "dim_nm",
          "package": "hmt",
          "signature": "[Z12] -\u003e [(Z12, Char)]",
          "source": "src/Music-Theory-Z12-Drape_1999.html#dim_nm",
          "type": "function"
        },
        "index": {
          "description": "Variant of dim that is closer to the pct form dim T1d T1m T0o dim nm",
          "hierarchy": "Music Theory Z12 Drape_1999",
          "module": "Music.Theory.Z12.Drape_1999",
          "name": "dim_nm",
          "normalized": "[Z]-\u003e[(Z,Char)]",
          "package": "hmt",
          "signature": "[Z]-\u003e[(Z,Char)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Z12-Drape_1999.html#v:dim_nm"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDiatonic interval set to interval set.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003edis 24\n\u003c/code\u003e\u003c/strong\u003e1256\n\u003c/pre\u003e\u003cpre\u003e dis [2,4] == [1,2,5,6]\n\u003c/pre\u003e",
          "module": "Music.Theory.Z12.Drape_1999",
          "name": "dis",
          "package": "hmt",
          "signature": "[Int] -\u003e [t]",
          "source": "src/Music-Theory-Z12-Drape_1999.html#dis",
          "type": "function"
        },
        "index": {
          "description": "Diatonic interval set to interval set dis dis",
          "hierarchy": "Music Theory Z12 Drape_1999",
          "module": "Music.Theory.Z12.Drape_1999",
          "name": "dis",
          "normalized": "[Int]-\u003e[a]",
          "package": "hmt",
          "signature": "[Int]-\u003e[t]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Z12-Drape_1999.html#v:dis"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDegree of intersection.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eecho 024579e | doi 6 | sort -u\n\u003c/code\u003e\u003c/strong\u003e024579A\n024679B\n\u003c/pre\u003e\u003cpre\u003e let p = [0,2,4,5,7,9,11]\n in doi 6 p p == [[0,2,4,5,7,9,10],[0,2,4,6,7,9,11]]\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eecho 01234 | doi 2 7-35 | sort -u\n\u003c/code\u003e\u003c/strong\u003e13568AB\n\u003c/pre\u003e\u003cpre\u003e doi 2 (sc \"7-35\") [0,1,2,3,4] == [[1,3,5,6,8,10,11]]\n\u003c/pre\u003e",
          "module": "Music.Theory.Z12.Drape_1999",
          "name": "doi",
          "package": "hmt",
          "signature": "Int -\u003e [Z12] -\u003e [Z12] -\u003e [[Z12]]",
          "source": "src/Music-Theory-Z12-Drape_1999.html#doi",
          "type": "function"
        },
        "index": {
          "description": "Degree of intersection echo doi sort let in doi echo doi sort AB doi sc",
          "hierarchy": "Music Theory Z12 Drape_1999",
          "module": "Music.Theory.Z12.Drape_1999",
          "name": "doi",
          "normalized": "Int-\u003e[Z]-\u003e[Z]-\u003e[[Z]]",
          "package": "hmt",
          "signature": "Int-\u003e[Z]-\u003e[Z]-\u003e[[Z]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Z12-Drape_1999.html#v:doi"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEmbedded segment search.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eecho 23a | ess 0164325\n\u003c/code\u003e\u003c/strong\u003e2B013A9\n923507A\n\u003c/pre\u003e\u003cpre\u003e ess [2,3,10] [0,1,6,4,3,2,5] == [[9,2,3,5,0,7,10],[2,11,0,1,3,10,9]]\n\u003c/pre\u003e",
          "module": "Music.Theory.Z12.Drape_1999",
          "name": "ess",
          "package": "hmt",
          "signature": "[Z12] -\u003e [Z12] -\u003e [[Z12]]",
          "source": "src/Music-Theory-Z12-Drape_1999.html#ess",
          "type": "function"
        },
        "index": {
          "description": "Embedded segment search echo ess B013A9 ess",
          "hierarchy": "Music Theory Z12 Drape_1999",
          "module": "Music.Theory.Z12.Drape_1999",
          "name": "ess",
          "normalized": "[Z]-\u003e[Z]-\u003e[[Z]]",
          "package": "hmt",
          "signature": "[Z]-\u003e[Z]-\u003e[[Z]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Z12-Drape_1999.html#v:ess"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eForte name.\n\u003c/p\u003e",
          "module": "Music.Theory.Z12.Drape_1999",
          "name": "fn",
          "package": "hmt",
          "signature": "[Z12] -\u003e String",
          "source": "src/Music-Theory-Z12-Drape_1999.html#fn",
          "type": "function"
        },
        "index": {
          "description": "Forte name",
          "hierarchy": "Music Theory Z12 Drape_1999",
          "module": "Music.Theory.Z12.Drape_1999",
          "name": "fn",
          "normalized": "[Z]-\u003eString",
          "package": "hmt",
          "signature": "[Z]-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Z12-Drape_1999.html#v:fn"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ep \u003ccode\u003e\u003ca\u003ehas_ess\u003c/a\u003e\u003c/code\u003e q is true iff p can embed q in sequence.\n\u003c/p\u003e",
          "module": "Music.Theory.Z12.Drape_1999",
          "name": "has_ess",
          "package": "hmt",
          "signature": "[Z12] -\u003e [Z12] -\u003e Bool",
          "source": "src/Music-Theory-Z12-Drape_1999.html#has_ess",
          "type": "function"
        },
        "index": {
          "description": "has ess is true iff can embed in sequence",
          "hierarchy": "Music Theory Z12 Drape_1999",
          "module": "Music.Theory.Z12.Drape_1999",
          "name": "has_ess",
          "normalized": "[Z]-\u003e[Z]-\u003eBool",
          "package": "hmt",
          "signature": "[Z]-\u003e[Z]-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Z12-Drape_1999.html#v:has_ess"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCan the set-class q be drawn from the pcset p.\n\u003c/p\u003e",
          "module": "Music.Theory.Z12.Drape_1999",
          "name": "has_sc",
          "package": "hmt",
          "signature": "[Z12] -\u003e [Z12] -\u003e Bool",
          "source": "src/Music-Theory-Z12-Drape_1999.html#has_sc",
          "type": "function"
        },
        "index": {
          "description": "Can the set-class be drawn from the pcset",
          "hierarchy": "Music Theory Z12 Drape_1999",
          "module": "Music.Theory.Z12.Drape_1999",
          "name": "has_sc",
          "normalized": "[Z]-\u003e[Z]-\u003eBool",
          "package": "hmt",
          "signature": "[Z]-\u003e[Z]-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Z12-Drape_1999.html#v:has_sc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCan the set-class q (under prime form algorithm pf) be\n   drawn from the pcset p.\n\u003c/p\u003e",
          "module": "Music.Theory.Z12.Drape_1999",
          "name": "has_sc_pf",
          "package": "hmt",
          "signature": "([a] -\u003e [a]) -\u003e [a] -\u003e [a] -\u003e Bool",
          "source": "src/Music-Theory-Z12-Drape_1999.html#has_sc_pf",
          "type": "function"
        },
        "index": {
          "description": "Can the set-class under prime form algorithm pf be drawn from the pcset",
          "hierarchy": "Music Theory Z12 Drape_1999",
          "module": "Music.Theory.Z12.Drape_1999",
          "name": "has_sc_pf",
          "normalized": "([a]-\u003e[a])-\u003e[a]-\u003e[a]-\u003eBool",
          "package": "hmt",
          "signature": "([a]-\u003e[a])-\u003e[a]-\u003e[a]-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Z12-Drape_1999.html#v:has_sc_pf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInterval cycle filter.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eecho 22341 | icf\n\u003c/code\u003e\u003c/strong\u003e22341\n\u003c/pre\u003e\u003cpre\u003e icf [[2,2,3,4,1]] == [[2,2,3,4,1]]\n\u003c/pre\u003e",
          "module": "Music.Theory.Z12.Drape_1999",
          "name": "icf",
          "package": "hmt",
          "signature": "[[a]] -\u003e [[a]]",
          "source": "src/Music-Theory-Z12-Drape_1999.html#icf",
          "type": "function"
        },
        "index": {
          "description": "Interval cycle filter echo icf icf",
          "hierarchy": "Music Theory Z12 Drape_1999",
          "module": "Music.Theory.Z12.Drape_1999",
          "name": "icf",
          "normalized": "[[a]]-\u003e[[a]]",
          "package": "hmt",
          "signature": "[[a]]-\u003e[[a]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Z12-Drape_1999.html#v:icf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInterval class set to interval sets.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eici -c 123\n\u003c/code\u003e\u003c/strong\u003e123\n129\n1A3\n1A9\n\u003c/pre\u003e\u003cpre\u003e ici_c [1,2,3] == [[1,2,3],[1,2,9],[1,10,3],[1,10,9]]\n\u003c/pre\u003e",
          "module": "Music.Theory.Z12.Drape_1999",
          "name": "ici",
          "package": "hmt",
          "signature": "[Int] -\u003e [[t]]",
          "source": "src/Music-Theory-Z12-Drape_1999.html#ici",
          "type": "function"
        },
        "index": {
          "description": "Interval class set to interval sets ici A3 A9 ici",
          "hierarchy": "Music Theory Z12 Drape_1999",
          "module": "Music.Theory.Z12.Drape_1999",
          "name": "ici",
          "normalized": "[Int]-\u003e[[a]]",
          "package": "hmt",
          "signature": "[Int]-\u003e[[t]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Z12-Drape_1999.html#v:ici"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInterval class set to interval sets, concise variant.\n\u003c/p\u003e\u003cpre\u003e ici_c [1,2,3] == [[1,2,3],[1,2,9],[1,10,3],[1,10,9]]\n\u003c/pre\u003e",
          "module": "Music.Theory.Z12.Drape_1999",
          "name": "ici_c",
          "package": "hmt",
          "signature": "[Int] -\u003e [[Int]]",
          "source": "src/Music-Theory-Z12-Drape_1999.html#ici_c",
          "type": "function"
        },
        "index": {
          "description": "Interval class set to interval sets concise variant ici",
          "hierarchy": "Music Theory Z12 Drape_1999",
          "module": "Music.Theory.Z12.Drape_1999",
          "name": "ici_c",
          "normalized": "[Int]-\u003e[[Int]]",
          "package": "hmt",
          "signature": "[Int]-\u003e[[Int]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Z12-Drape_1999.html#v:ici_c"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInterval-class segment.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eicseg 013265e497t8\n\u003c/code\u003e\u003c/strong\u003e12141655232\n\u003c/pre\u003e\u003cpre\u003e icseg [0,1,3,2,6,5,11,4,9,7,10,8] == [1,2,1,4,1,6,5,5,2,3,2]\n\u003c/pre\u003e",
          "module": "Music.Theory.Z12.Drape_1999",
          "name": "icseg",
          "package": "hmt",
          "signature": "[Z12] -\u003e [Z12]",
          "source": "src/Music-Theory-Z12-Drape_1999.html#icseg",
          "type": "function"
        },
        "index": {
          "description": "Interval-class segment icseg e497t8 icseg",
          "hierarchy": "Music Theory Z12 Drape_1999",
          "module": "Music.Theory.Z12.Drape_1999",
          "name": "icseg",
          "normalized": "[Z]-\u003e[Z]",
          "package": "hmt",
          "signature": "[Z]-\u003e[Z]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Z12-Drape_1999.html#v:icseg"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eImbrications.\n\u003c/p\u003e",
          "module": "Music.Theory.Z12.Drape_1999",
          "name": "imb",
          "package": "hmt",
          "signature": "[n] -\u003e [a] -\u003e [[a]]",
          "source": "src/Music-Theory-Z12-Drape_1999.html#imb",
          "type": "function"
        },
        "index": {
          "description": "Imbrications",
          "hierarchy": "Music Theory Z12 Drape_1999",
          "module": "Music.Theory.Z12.Drape_1999",
          "name": "imb",
          "normalized": "[a]-\u003e[b]-\u003e[[b]]",
          "package": "hmt",
          "signature": "[n]-\u003e[a]-\u003e[[a]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Z12-Drape_1999.html#v:imb"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInterval segment (INT).\n\u003c/p\u003e",
          "module": "Music.Theory.Z12.Drape_1999",
          "name": "iseg",
          "package": "hmt",
          "signature": "[Z12] -\u003e [Z12]",
          "source": "src/Music-Theory-Z12-Drape_1999.html#iseg",
          "type": "function"
        },
        "index": {
          "description": "Interval segment INT",
          "hierarchy": "Music Theory Z12 Drape_1999",
          "module": "Music.Theory.Z12.Drape_1999",
          "name": "iseg",
          "normalized": "[Z]-\u003e[Z]",
          "package": "hmt",
          "signature": "[Z]-\u003e[Z]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Z12-Drape_1999.html#v:iseg"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eissb\u003c/a\u003e\u003c/code\u003e gives the set-classes that can append to \u003ccode\u003ep\u003c/code\u003e to give \u003ccode\u003eq\u003c/code\u003e.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eissb 3-7 6-32\n\u003c/code\u003e\u003c/strong\u003e3-7\n3-2\n3-11\n\u003c/pre\u003e\u003cpre\u003e issb (sc \"3-7\") (sc \"6-32\") == [\"3-2\",\"3-7\",\"3-11\"]\n\u003c/pre\u003e",
          "module": "Music.Theory.Z12.Drape_1999",
          "name": "issb",
          "package": "hmt",
          "signature": "[Z12] -\u003e [Z12] -\u003e [String]",
          "source": "src/Music-Theory-Z12-Drape_1999.html#issb",
          "type": "function"
        },
        "index": {
          "description": "issb gives the set-classes that can append to to give issb issb sc sc",
          "hierarchy": "Music Theory Z12 Drape_1999",
          "module": "Music.Theory.Z12.Drape_1999",
          "name": "issb",
          "normalized": "[Z]-\u003e[Z]-\u003e[String]",
          "package": "hmt",
          "signature": "[Z]-\u003e[Z]-\u003e[String]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Z12-Drape_1999.html#v:issb"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMatrix search.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003emxs 024579 642 | sort -u\n\u003c/code\u003e\u003c/strong\u003e6421B9\nB97642\n\u003c/pre\u003e\u003cpre\u003e S.set (mxs [0,2,4,5,7,9] [6,4,2]) == [[6,4,2,1,11,9],[11,9,7,6,4,2]]\n\u003c/pre\u003e",
          "module": "Music.Theory.Z12.Drape_1999",
          "name": "mxs",
          "package": "hmt",
          "signature": "[Z12] -\u003e [Z12] -\u003e [[Z12]]",
          "source": "src/Music-Theory-Z12-Drape_1999.html#mxs",
          "type": "function"
        },
        "index": {
          "description": "Matrix search mxs sort B9 B97642 S.set mxs",
          "hierarchy": "Music Theory Z12 Drape_1999",
          "module": "Music.Theory.Z12.Drape_1999",
          "name": "mxs",
          "normalized": "[Z]-\u003e[Z]-\u003e[[Z]]",
          "package": "hmt",
          "signature": "[Z]-\u003e[Z]-\u003e[[Z]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Z12-Drape_1999.html#v:mxs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eNormalize.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003enrm 0123456543210\n\u003c/code\u003e\u003c/strong\u003e0123456\n\u003c/pre\u003e\u003cpre\u003e nrm [0,1,2,3,4,5,6,5,4,3,2,1,0] == [0,1,2,3,4,5,6]\n\u003c/pre\u003e",
          "module": "Music.Theory.Z12.Drape_1999",
          "name": "nrm",
          "package": "hmt",
          "signature": "[a] -\u003e [a]",
          "source": "src/Music-Theory-Z12-Drape_1999.html#nrm",
          "type": "function"
        },
        "index": {
          "description": "Normalize nrm nrm",
          "hierarchy": "Music Theory Z12 Drape_1999",
          "module": "Music.Theory.Z12.Drape_1999",
          "name": "nrm",
          "normalized": "[a]-\u003e[a]",
          "package": "hmt",
          "signature": "[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Z12-Drape_1999.html#v:nrm"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eNormalize, retain duplicate elements.\n\u003c/p\u003e",
          "module": "Music.Theory.Z12.Drape_1999",
          "name": "nrm_r",
          "package": "hmt",
          "signature": "[a] -\u003e [a]",
          "source": "src/Music-Theory-Z12-Drape_1999.html#nrm_r",
          "type": "function"
        },
        "index": {
          "description": "Normalize retain duplicate elements",
          "hierarchy": "Music Theory Z12 Drape_1999",
          "module": "Music.Theory.Z12.Drape_1999",
          "name": "nrm_r",
          "normalized": "[a]-\u003e[a]",
          "package": "hmt",
          "signature": "[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Z12-Drape_1999.html#v:nrm_r"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePitch-class invariances (called \u003ccode\u003epi\u003c/code\u003e at \u003ccode\u003epct\u003c/code\u003e).\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003epi 0236 12\n\u003c/code\u003e\u003c/strong\u003e0236\n6320\n532B\nB235\n\u003c/pre\u003e\u003cpre\u003e pci [0,2,3,6] [1,2] == [[0,2,3,6],[5,3,2,11],[6,3,2,0],[11,2,3,5]]\n\u003c/pre\u003e",
          "module": "Music.Theory.Z12.Drape_1999",
          "name": "pci",
          "package": "hmt",
          "signature": "[Z12] -\u003e [Z12] -\u003e [[Z12]]",
          "source": "src/Music-Theory-Z12-Drape_1999.html#pci",
          "type": "function"
        },
        "index": {
          "description": "Pitch-class invariances called pi at pct pi B235 pci",
          "hierarchy": "Music Theory Z12 Drape_1999",
          "module": "Music.Theory.Z12.Drape_1999",
          "name": "pci",
          "normalized": "[Z]-\u003e[Z]-\u003e[[Z]]",
          "package": "hmt",
          "signature": "[Z]-\u003e[Z]-\u003e[[Z]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Z12-Drape_1999.html#v:pci"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRelate sets.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003ers 0123 641e\n\u003c/code\u003e\u003c/strong\u003eT1M\n\u003c/pre\u003e\u003cpre\u003e import Music.Theory.Z12.Morris_1987.Parse\n rs [0,1,2,3] [6,4,1,11] == [(rnrtnmi \"T1M\",[1,6,11,4])\n                            ,(rnrtnmi \"T4MI\",[4,11,6,1])]\n\u003c/pre\u003e",
          "module": "Music.Theory.Z12.Drape_1999",
          "name": "rs",
          "package": "hmt",
          "signature": "[Z12] -\u003e [Z12] -\u003e [(SRO, [Z12])]",
          "source": "src/Music-Theory-Z12-Drape_1999.html#rs",
          "type": "function"
        },
        "index": {
          "description": "Relate sets rs T1M import Music.Theory.Z12.Morris Parse rs rnrtnmi T1M rnrtnmi T4MI",
          "hierarchy": "Music Theory Z12 Drape_1999",
          "module": "Music.Theory.Z12.Drape_1999",
          "name": "rs",
          "normalized": "[Z]-\u003e[Z]-\u003e[(SRO,[Z])]",
          "package": "hmt",
          "signature": "[Z]-\u003e[Z]-\u003e[(SRO,[Z])]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Z12-Drape_1999.html#v:rs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRelate segments.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003ersg 156 3BA\n\u003c/code\u003e\u003c/strong\u003eT4I\n\u003c/pre\u003e\u003cpre\u003e rsg [1,5,6] [3,11,10] == [rnrtnmi \"T4I\",rnrtnmi \"r1RT4MI\"]\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003ersg 0123 05t3\n\u003c/code\u003e\u003c/strong\u003eT0M\n\u003c/pre\u003e\u003cpre\u003e rsg [0,1,2,3] [0,5,10,3] == [rnrtnmi \"T0M\",rnrtnmi \"RT3MI\"]\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003ersg 0123 4e61\n\u003c/code\u003e\u003c/strong\u003eRT1M\n\u003c/pre\u003e\u003cpre\u003e rsg [0,1,2,3] [4,11,6,1] == [rnrtnmi \"T4MI\",rnrtnmi \"RT1M\"]\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eecho e614 | rsg 0123\n\u003c/code\u003e\u003c/strong\u003er3RT1M\n\u003c/pre\u003e\u003cpre\u003e rsg [0,1,2,3] [11,6,1,4] == [rnrtnmi \"r1T4MI\",rnrtnmi \"r1RT1M\"]\n\u003c/pre\u003e",
          "module": "Music.Theory.Z12.Drape_1999",
          "name": "rsg",
          "package": "hmt",
          "signature": "[Z12] -\u003e [Z12] -\u003e [SRO]",
          "source": "src/Music-Theory-Z12-Drape_1999.html#rsg",
          "type": "function"
        },
        "index": {
          "description": "Relate segments rsg BA T4I rsg rnrtnmi T4I rnrtnmi r1RT4MI rsg t3 T0M rsg rnrtnmi T0M rnrtnmi RT3MI rsg e61 RT1M rsg rnrtnmi T4MI rnrtnmi RT1M echo e614 rsg r3RT1M rsg rnrtnmi r1T4MI rnrtnmi r1RT1M",
          "hierarchy": "Music Theory Z12 Drape_1999",
          "module": "Music.Theory.Z12.Drape_1999",
          "name": "rsg",
          "normalized": "[Z]-\u003e[Z]-\u003e[SRO]",
          "package": "hmt",
          "signature": "[Z]-\u003e[Z]-\u003e[SRO]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Z12-Drape_1999.html#v:rsg"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSubsets.\n\u003c/p\u003e",
          "module": "Music.Theory.Z12.Drape_1999",
          "name": "sb",
          "package": "hmt",
          "signature": "[[Z12]] -\u003e [[Z12]]",
          "source": "src/Music-Theory-Z12-Drape_1999.html#sb",
          "type": "function"
        },
        "index": {
          "description": "Subsets",
          "hierarchy": "Music Theory Z12 Drape_1999",
          "module": "Music.Theory.Z12.Drape_1999",
          "name": "sb",
          "normalized": "[[Z]]-\u003e[[Z]]",
          "package": "hmt",
          "signature": "[[Z]]-\u003e[[Z]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Z12-Drape_1999.html#v:sb"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSuper set-class.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003espsc 4-11 4-12\n\u003c/code\u003e\u003c/strong\u003e5-26[02458]\n\u003c/pre\u003e\u003cpre\u003e spsc [sc \"4-11\", sc \"4-12\"] == [\"5-26\"]\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003espsc 3-11 3-8\n\u003c/code\u003e\u003c/strong\u003e4-27[0258]\n4-Z29[0137]\n\u003c/pre\u003e\u003cpre\u003e spsc [sc \"3-11\", sc \"3-8\"] == [\"4-27\",\"4-Z29\"]\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003espsc `fl 3`\n\u003c/code\u003e\u003c/strong\u003e6-Z17[012478]\n\u003c/pre\u003e\u003cpre\u003e spsc (cf [3] scs) == [\"6-Z17\"]\n\u003c/pre\u003e",
          "module": "Music.Theory.Z12.Drape_1999",
          "name": "spsc",
          "package": "hmt",
          "signature": "[[Z12]] -\u003e [String]",
          "source": "src/Music-Theory-Z12-Drape_1999.html#spsc",
          "type": "function"
        },
        "index": {
          "description": "Super set-class spsc spsc sc sc spsc Z29 spsc sc sc Z29 spsc fl Z17 spsc cf scs Z17",
          "hierarchy": "Music Theory Z12 Drape_1999",
          "module": "Music.Theory.Z12.Drape_1999",
          "name": "spsc",
          "normalized": "[[Z]]-\u003e[String]",
          "package": "hmt",
          "signature": "[[Z]]-\u003e[String]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Z12-Drape_1999.html#v:spsc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eAllen Forte. \u003cem\u003eThe Structure of Atonal Music\u003c/em\u003e. Yale University\n Press, New Haven, 1973.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Music.Theory.Z12.Forte_1973",
          "name": "Forte_1973",
          "package": "hmt",
          "source": "src/Music-Theory-Z12-Forte_1973.html",
          "type": "module"
        },
        "index": {
          "description": "Allen Forte The Structure of Atonal Music Yale University Press New Haven",
          "hierarchy": "Music Theory Z12 Forte_1973",
          "module": "Music.Theory.Z12.Forte_1973",
          "name": "Forte_1973",
          "package": "hmt",
          "partial": "Forte",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Z12-Forte_1973.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSynonym for \u003ccode\u003e\u003ca\u003eString\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Music.Theory.Z12.Forte_1973",
          "name": "SC_Name",
          "package": "hmt",
          "source": "src/Music-Theory-Z12-Forte_1973.html#SC_Name",
          "type": "type"
        },
        "index": {
          "description": "Synonym for String",
          "hierarchy": "Music Theory Z12 Forte_1973",
          "module": "Music.Theory.Z12.Forte_1973",
          "name": "SC_Name",
          "package": "hmt",
          "partial": "SC Name",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Z12-Forte_1973.html#t:SC_Name"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eBasic interval pattern, see Allen Forte \"The Basic Interval Patterns\"\n \u003cem\u003eJMT\u003c/em\u003e 17/2 (1973):234-272\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003ebip 0t95728e3416\n\u003c/code\u003e\u003c/strong\u003e11223344556\n\u003c/pre\u003e\u003cpre\u003e bip [0,10,9,5,7,2,8,11,3,4,1,6] == [1,1,2,2,3,3,4,4,5,5,6]\n bip (pco \"0t95728e3416\") == [1,1,2,2,3,3,4,4,5,5,6]\n\u003c/pre\u003e",
          "module": "Music.Theory.Z12.Forte_1973",
          "name": "bip",
          "package": "hmt",
          "signature": "[Z12] -\u003e [Z12]",
          "source": "src/Music-Theory-Z12-Forte_1973.html#bip",
          "type": "function"
        },
        "index": {
          "description": "Basic interval pattern see Allen Forte The Basic Interval Patterns JMT bip t95728e3416 bip bip pco t95728e3416",
          "hierarchy": "Music Theory Z12 Forte_1973",
          "module": "Music.Theory.Z12.Forte_1973",
          "name": "bip",
          "normalized": "[Z]-\u003e[Z]",
          "package": "hmt",
          "signature": "[Z]-\u003e[Z]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Z12-Forte_1973.html#v:bip"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eForte comparison function (rightmost first then leftmost outwards).\n\u003c/p\u003e\u003cpre\u003e forte_cmp [0,1,3,6,8,9] [0,2,3,6,7,9] == LT\n\u003c/pre\u003e",
          "module": "Music.Theory.Z12.Forte_1973",
          "name": "forte_cmp",
          "package": "hmt",
          "signature": "[t] -\u003e [t] -\u003e Ordering",
          "source": "src/Music-Theory-Z12-Forte_1973.html#forte_cmp",
          "type": "function"
        },
        "index": {
          "description": "Forte comparison function rightmost first then leftmost outwards forte cmp LT",
          "hierarchy": "Music Theory Z12 Forte_1973",
          "module": "Music.Theory.Z12.Forte_1973",
          "name": "forte_cmp",
          "normalized": "[a]-\u003e[a]-\u003eOrdering",
          "package": "hmt",
          "signature": "[t]-\u003e[t]-\u003eOrdering",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Z12-Forte_1973.html#v:forte_cmp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eForte prime form, ie. \u003ccode\u003ecmp_prime\u003c/code\u003e of \u003ccode\u003e\u003ca\u003eforte_cmp\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e forte_prime [0,1,3,6,8,9] == [0,1,3,6,8,9]\n\u003c/pre\u003e",
          "module": "Music.Theory.Z12.Forte_1973",
          "name": "forte_prime",
          "package": "hmt",
          "signature": "[Z12] -\u003e [Z12]",
          "source": "src/Music-Theory-Z12-Forte_1973.html#forte_prime",
          "type": "function"
        },
        "index": {
          "description": "Forte prime form ie cmp prime of forte cmp forte prime",
          "hierarchy": "Music Theory Z12 Forte_1973",
          "module": "Music.Theory.Z12.Forte_1973",
          "name": "forte_prime",
          "normalized": "[Z]-\u003e[Z]",
          "package": "hmt",
          "signature": "[Z]-\u003e[Z]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Z12-Forte_1973.html#v:forte_prime"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInterval class of Z12 interval \u003cem\u003ei\u003c/em\u003e.\n\u003c/p\u003e\u003cpre\u003e map ic [5,6,7] == [5,6,5]\n\u003c/pre\u003e",
          "module": "Music.Theory.Z12.Forte_1973",
          "name": "ic",
          "package": "hmt",
          "signature": "Z12 -\u003e Z12",
          "source": "src/Music-Theory-Z12-Forte_1973.html#ic",
          "type": "function"
        },
        "index": {
          "description": "Interval class of Z12 interval map ic",
          "hierarchy": "Music Theory Z12 Forte_1973",
          "module": "Music.Theory.Z12.Forte_1973",
          "name": "ic",
          "normalized": "Z-\u003eZ",
          "package": "hmt",
          "signature": "Z-\u003eZ",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Z12-Forte_1973.html#v:ic"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eForte notation for interval class vector.\n\u003c/p\u003e\u003cpre\u003e icv [0,1,2,4,7,8] == [3,2,2,3,3,2]\n\u003c/pre\u003e",
          "module": "Music.Theory.Z12.Forte_1973",
          "name": "icv",
          "package": "hmt",
          "signature": "[Z12] -\u003e [i]",
          "source": "src/Music-Theory-Z12-Forte_1973.html#icv",
          "type": "function"
        },
        "index": {
          "description": "Forte notation for interval class vector icv",
          "hierarchy": "Music Theory Z12 Forte_1973",
          "module": "Music.Theory.Z12.Forte_1973",
          "name": "icv",
          "normalized": "[Z]-\u003e[a]",
          "package": "hmt",
          "signature": "[Z]-\u003e[i]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Z12-Forte_1973.html#v:icv"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eVariant with default value for empty input list case.\n\u003c/p\u003e",
          "module": "Music.Theory.Z12.Forte_1973",
          "name": "minimumBy_or",
          "package": "hmt",
          "signature": "a -\u003e (a -\u003e a -\u003e Ordering) -\u003e [a] -\u003e a",
          "source": "src/Music-Theory-Z12-Forte_1973.html#minimumBy_or",
          "type": "function"
        },
        "index": {
          "description": "Variant with default value for empty input list case",
          "hierarchy": "Music Theory Z12 Forte_1973",
          "module": "Music.Theory.Z12.Forte_1973",
          "name": "minimumBy_or",
          "normalized": "a-\u003e(a-\u003ea-\u003eOrdering)-\u003e[a]-\u003ea",
          "package": "hmt",
          "partial": "By",
          "signature": "a-\u003e(a-\u003ea-\u003eOrdering)-\u003e[a]-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Z12-Forte_1973.html#v:minimumBy_or"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLookup a set-class given a set-class name.\n\u003c/p\u003e\u003cpre\u003e sc \"6-Z17\" == [0,1,2,4,7,8]\n\u003c/pre\u003e",
          "module": "Music.Theory.Z12.Forte_1973",
          "name": "sc",
          "package": "hmt",
          "signature": "SC_Name -\u003e [Z12]",
          "source": "src/Music-Theory-Z12-Forte_1973.html#sc",
          "type": "function"
        },
        "index": {
          "description": "Lookup set-class given set-class name sc Z17",
          "hierarchy": "Music Theory Z12 Forte_1973",
          "module": "Music.Theory.Z12.Forte_1973",
          "name": "sc",
          "normalized": "SC_Name-\u003e[Z]",
          "package": "hmt",
          "signature": "SC_Name-\u003e[Z]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Z12-Forte_1973.html#v:sc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLookup a set-class name.  The input set is subject to\n \u003ccode\u003e\u003ca\u003eforte_prime\u003c/a\u003e\u003c/code\u003e before lookup.\n\u003c/p\u003e\u003cpre\u003e sc_name [0,2,3,6,7] == \"5-Z18\"\n sc_name [0,1,4,6,7,8] == \"6-Z17\"\n\u003c/pre\u003e",
          "module": "Music.Theory.Z12.Forte_1973",
          "name": "sc_name",
          "package": "hmt",
          "signature": "[Z12] -\u003e SC_Name",
          "source": "src/Music-Theory-Z12-Forte_1973.html#sc_name",
          "type": "function"
        },
        "index": {
          "description": "Lookup set-class name The input set is subject to forte prime before lookup sc name Z18 sc name Z17",
          "hierarchy": "Music Theory Z12 Forte_1973",
          "module": "Music.Theory.Z12.Forte_1973",
          "name": "sc_name",
          "normalized": "[Z]-\u003eSC_Name",
          "package": "hmt",
          "signature": "[Z]-\u003eSC_Name",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Z12-Forte_1973.html#v:sc_name"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe set-class table (Forte prime forms).\n\u003c/p\u003e",
          "module": "Music.Theory.Z12.Forte_1973",
          "name": "sc_table",
          "package": "hmt",
          "signature": "[(SC_Name, [Z12])]",
          "source": "src/Music-Theory-Z12-Forte_1973.html#sc_table",
          "type": "function"
        },
        "index": {
          "description": "The set-class table Forte prime forms",
          "hierarchy": "Music Theory Z12 Forte_1973",
          "module": "Music.Theory.Z12.Forte_1973",
          "name": "sc_table",
          "normalized": "[(SC_Name,[Z])]",
          "package": "hmt",
          "signature": "[(SC_Name,[Z])]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Z12-Forte_1973.html#v:sc_table"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eList of set classes.\n\u003c/p\u003e",
          "module": "Music.Theory.Z12.Forte_1973",
          "name": "scs",
          "package": "hmt",
          "signature": "[[Z12]]",
          "source": "src/Music-Theory-Z12-Forte_1973.html#scs",
          "type": "function"
        },
        "index": {
          "description": "List of set classes",
          "hierarchy": "Music Theory Z12 Forte_1973",
          "module": "Music.Theory.Z12.Forte_1973",
          "name": "scs",
          "normalized": "[[Z]]",
          "package": "hmt",
          "signature": "[[Z]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Z12-Forte_1973.html#v:scs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCardinality \u003cem\u003en\u003c/em\u003e subset of \u003ccode\u003e\u003ca\u003escs\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e map (length . scs_n) [2..10] == [6,12,29,38,50,38,29,12,6]\n\u003c/pre\u003e",
          "module": "Music.Theory.Z12.Forte_1973",
          "name": "scs_n",
          "package": "hmt",
          "signature": "i -\u003e [[Z12]]",
          "source": "src/Music-Theory-Z12-Forte_1973.html#scs_n",
          "type": "function"
        },
        "index": {
          "description": "Cardinality subset of scs map length scs",
          "hierarchy": "Music Theory Z12 Forte_1973",
          "module": "Music.Theory.Z12.Forte_1973",
          "name": "scs_n",
          "normalized": "a-\u003e[[Z]]",
          "package": "hmt",
          "signature": "i-\u003e[[Z]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Z12-Forte_1973.html#v:scs_n"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePrime form rule requiring comparator, considering \u003ccode\u003e\u003ca\u003et_rotations\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Music.Theory.Z12.Forte_1973",
          "name": "t_cmp_prime",
          "package": "hmt",
          "signature": "([Z12] -\u003e [Z12] -\u003e Ordering) -\u003e [Z12] -\u003e [Z12]",
          "source": "src/Music-Theory-Z12-Forte_1973.html#t_cmp_prime",
          "type": "function"
        },
        "index": {
          "description": "Prime form rule requiring comparator considering rotations",
          "hierarchy": "Music Theory Z12 Forte_1973",
          "module": "Music.Theory.Z12.Forte_1973",
          "name": "t_cmp_prime",
          "normalized": "([Z]-\u003e[Z]-\u003eOrdering)-\u003e[Z]-\u003e[Z]",
          "package": "hmt",
          "signature": "([Z]-\u003e[Z]-\u003eOrdering)-\u003e[Z]-\u003e[Z]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Z12-Forte_1973.html#v:t_cmp_prime"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eT-related rotations of \u003cem\u003ep\u003c/em\u003e.\n\u003c/p\u003e\u003cpre\u003e t_rotations [0,1,3] == [[0,1,3],[0,2,11],[0,9,10]]\n\u003c/pre\u003e",
          "module": "Music.Theory.Z12.Forte_1973",
          "name": "t_rotations",
          "package": "hmt",
          "signature": "[Z12] -\u003e [[Z12]]",
          "source": "src/Music-Theory-Z12-Forte_1973.html#t_rotations",
          "type": "function"
        },
        "index": {
          "description": "T-related rotations of rotations",
          "hierarchy": "Music Theory Z12 Forte_1973",
          "module": "Music.Theory.Z12.Forte_1973",
          "name": "t_rotations",
          "normalized": "[Z]-\u003e[[Z]]",
          "package": "hmt",
          "signature": "[Z]-\u003e[[Z]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Z12-Forte_1973.html#v:t_rotations"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePrime form rule requiring comparator, considering \u003ccode\u003e\u003ca\u003eti_rotations\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Music.Theory.Z12.Forte_1973",
          "name": "ti_cmp_prime",
          "package": "hmt",
          "signature": "([Z12] -\u003e [Z12] -\u003e Ordering) -\u003e [Z12] -\u003e [Z12]",
          "source": "src/Music-Theory-Z12-Forte_1973.html#ti_cmp_prime",
          "type": "function"
        },
        "index": {
          "description": "Prime form rule requiring comparator considering ti rotations",
          "hierarchy": "Music Theory Z12 Forte_1973",
          "module": "Music.Theory.Z12.Forte_1973",
          "name": "ti_cmp_prime",
          "normalized": "([Z]-\u003e[Z]-\u003eOrdering)-\u003e[Z]-\u003e[Z]",
          "package": "hmt",
          "signature": "([Z]-\u003e[Z]-\u003eOrdering)-\u003e[Z]-\u003e[Z]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Z12-Forte_1973.html#v:ti_cmp_prime"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eT/I-related rotations of \u003cem\u003ep\u003c/em\u003e.\n\u003c/p\u003e\u003cpre\u003e ti_rotations [0,1,3] == [[0,1,3],[0,2,11],[0,9,10]\n                         ,[0,9,11],[0,2,3],[0,1,10]]\n\u003c/pre\u003e",
          "module": "Music.Theory.Z12.Forte_1973",
          "name": "ti_rotations",
          "package": "hmt",
          "signature": "[Z12] -\u003e [[Z12]]",
          "source": "src/Music-Theory-Z12-Forte_1973.html#ti_rotations",
          "type": "function"
        },
        "index": {
          "description": "I-related rotations of ti rotations",
          "hierarchy": "Music Theory Z12 Forte_1973",
          "module": "Music.Theory.Z12.Forte_1973",
          "name": "ti_rotations",
          "normalized": "[Z]-\u003e[[Z]]",
          "package": "hmt",
          "signature": "[Z]-\u003e[[Z]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Z12-Forte_1973.html#v:ti_rotations"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eDavid Lewin. \"A Response to a Response: On PC Set\n Relatedness\". \u003cem\u003ePerspectives of New Music\u003c/em\u003e, 18(1-2):498-502, 1980.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Music.Theory.Z12.Lewin_1980",
          "name": "Lewin_1980",
          "package": "hmt",
          "source": "src/Music-Theory-Z12-Lewin_1980.html",
          "type": "module"
        },
        "index": {
          "description": "David Lewin Response to Response On PC Set Relatedness Perspectives of New Music",
          "hierarchy": "Music Theory Z12 Lewin_1980",
          "module": "Music.Theory.Z12.Lewin_1980",
          "name": "Lewin_1980",
          "package": "hmt",
          "partial": "Lewin",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Z12-Lewin_1980.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eREL function with given \u003cem\u003encv\u003c/em\u003e function (see \u003ccode\u003e\u003ca\u003et_rel\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003eti_rel\u003c/a\u003e\u003c/code\u003e).\n\u003c/p\u003e",
          "module": "Music.Theory.Z12.Lewin_1980",
          "name": "rel",
          "package": "hmt",
          "signature": "(Int -\u003e [a] -\u003e [n]) -\u003e [a] -\u003e [a] -\u003e n",
          "source": "src/Music-Theory-Z12-Lewin_1980.html#rel",
          "type": "function"
        },
        "index": {
          "description": "REL function with given ncv function see rel and ti rel",
          "hierarchy": "Music Theory Z12 Lewin_1980",
          "module": "Music.Theory.Z12.Lewin_1980",
          "name": "rel",
          "normalized": "(Int-\u003e[a]-\u003e[b])-\u003e[a]-\u003e[a]-\u003eb",
          "package": "hmt",
          "signature": "(Int-\u003e[a]-\u003e[n])-\u003e[a]-\u003e[a]-\u003en",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Z12-Lewin_1980.html#v:rel"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eT-equivalence REL function.\n\u003c/p\u003e\u003cp\u003eKuusi 2001, 7.5.2\n\u003c/p\u003e\u003cpre\u003e let (~=) p q = abs (p - q) \u003c 1e-2\n t_rel [0,1,2,3,4] [0,2,3,6,7] ~= 0.44\n t_rel [0,1,2,3,4] [0,2,4,6,8] ~= 0.28\n t_rel [0,2,3,6,7] [0,2,4,6,8] ~= 0.31\n\u003c/pre\u003e",
          "module": "Music.Theory.Z12.Lewin_1980",
          "name": "t_rel",
          "package": "hmt",
          "signature": "[Z12] -\u003e [Z12] -\u003e n",
          "source": "src/Music-Theory-Z12-Lewin_1980.html#t_rel",
          "type": "function"
        },
        "index": {
          "description": "T-equivalence REL function Kuusi let abs e-2 rel rel rel",
          "hierarchy": "Music Theory Z12 Lewin_1980",
          "module": "Music.Theory.Z12.Lewin_1980",
          "name": "t_rel",
          "normalized": "[Z]-\u003e[Z]-\u003ea",
          "package": "hmt",
          "signature": "[Z]-\u003e[Z]-\u003en",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Z12-Lewin_1980.html#v:t_rel"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eT/I-equivalence REL function.\n\u003c/p\u003e\u003cp\u003eBuchler 1998, Fig. 3.38\n\u003c/p\u003e\u003cpre\u003e let (~=) p q = abs (p - q) \u003c 1e-3\n let a = [0,2,3,5,7]::[Z12]\n let b = [0,2,3,4,5,8]::[Z12]\n let g = [0,1,2,3,5,6,8,10]::[Z12]\n let j = [0,2,3,4,5,6,8]::[Z12]\n ti_rel a b ~= 0.593\n ti_rel a g ~= 0.648\n ti_rel a j ~= 0.509\n ti_rel b g ~= 0.712\n ti_rel b j ~= 0.892\n ti_rel g j ~= 0.707\n\u003c/pre\u003e",
          "module": "Music.Theory.Z12.Lewin_1980",
          "name": "ti_rel",
          "package": "hmt",
          "signature": "[Z12] -\u003e [Z12] -\u003e n",
          "source": "src/Music-Theory-Z12-Lewin_1980.html#ti_rel",
          "type": "function"
        },
        "index": {
          "description": "I-equivalence REL function Buchler Fig let abs e-3 let Z12 let Z12 let Z12 let Z12 ti rel ti rel ti rel ti rel ti rel ti rel",
          "hierarchy": "Music Theory Z12 Lewin_1980",
          "module": "Music.Theory.Z12.Lewin_1980",
          "name": "ti_rel",
          "normalized": "[Z]-\u003e[Z]-\u003ea",
          "package": "hmt",
          "signature": "[Z]-\u003e[Z]-\u003en",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Z12-Lewin_1980.html#v:ti_rel"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eZ12 set class database.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Music.Theory.Z12.Literature",
          "name": "Literature",
          "package": "hmt",
          "source": "src/Music-Theory-Z12-Literature.html",
          "type": "module"
        },
        "index": {
          "description": "Z12 set class database",
          "hierarchy": "Music Theory Z12 Literature",
          "module": "Music.Theory.Z12.Literature",
          "name": "Literature",
          "package": "hmt",
          "partial": "Literature",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Z12-Literature.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSet class database with descriptors for historically and\n theoretically significant set classes, indexed by Forte name.\n\u003c/p\u003e\u003cpre\u003e lookup \"6-Z17\" sc_db == Just \"All-Trichord Hexachord\"\n lookup \"7-35\" sc_db == Just \"diatonic collection (d)\"\n\u003c/pre\u003e",
          "module": "Music.Theory.Z12.Literature",
          "name": "sc_db",
          "package": "hmt",
          "signature": "[(String, String)]",
          "source": "src/Music-Theory-Z12-Literature.html#sc_db",
          "type": "function"
        },
        "index": {
          "description": "Set class database with descriptors for historically and theoretically significant set classes indexed by Forte name lookup Z17 sc db Just All-Trichord Hexachord lookup sc db Just diatonic collection",
          "hierarchy": "Music Theory Z12 Literature",
          "module": "Music.Theory.Z12.Literature",
          "name": "sc_db",
          "normalized": "[(String,String)]",
          "package": "hmt",
          "signature": "[(String,String)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Z12-Literature.html#v:sc_db"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eRobert Morris and D. Starr. \"The Structure of All-Interval Series\".\n \u003cem\u003eJournal of Music Theory\u003c/em\u003e, 18:364-389, 1974.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Music.Theory.Z12.Morris_1974",
          "name": "Morris_1974",
          "package": "hmt",
          "source": "src/Music-Theory-Z12-Morris_1974.html",
          "type": "module"
        },
        "index": {
          "description": "Robert Morris and Starr The Structure of All-Interval Series Journal of Music Theory",
          "hierarchy": "Music Theory Z12 Morris_1974",
          "module": "Music.Theory.Z12.Morris_1974",
          "name": "Morris_1974",
          "package": "hmt",
          "partial": "Morris",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Z12-Morris_1974.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eobserveAll\u003c/a\u003e\u003c/code\u003e of \u003ccode\u003e\u003ca\u003eall_interval_m\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e let r = [[0,1,5,2,4,3],[0,2,1,4,5,3],[0,4,5,2,1,3],[0,5,1,4,2,3]]\n in all_interval 6 == r\n\u003c/pre\u003e",
          "module": "Music.Theory.Z12.Morris_1974",
          "name": "all_interval",
          "package": "hmt",
          "signature": "Int -\u003e [[Int]]",
          "source": "src/Music-Theory-Z12-Morris_1974.html#all_interval",
          "type": "function"
        },
        "index": {
          "description": "observeAll of all interval let in all interval",
          "hierarchy": "Music Theory Z12 Morris_1974",
          "module": "Music.Theory.Z12.Morris_1974",
          "name": "all_interval",
          "normalized": "Int-\u003e[[Int]]",
          "package": "hmt",
          "signature": "Int-\u003e[[Int]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Z12-Morris_1974.html#v:all_interval"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eMonadPlus\u003c/a\u003e\u003c/code\u003e all-interval series.\n\u003c/p\u003e\u003cpre\u003e [0,1,3,2,9,5,10,4,7,11,8,6] `elem` observeAll (all_interval_m 12)\n length (observeAll (all_interval_m 12)) == 3856\n map (length . observeAll . all_interval_m) [4,6,8,10] == [2,4,24,288]\n\u003c/pre\u003e",
          "module": "Music.Theory.Z12.Morris_1974",
          "name": "all_interval_m",
          "package": "hmt",
          "signature": "Int -\u003e m [Int]",
          "source": "src/Music-Theory-Z12-Morris_1974.html#all_interval_m",
          "type": "function"
        },
        "index": {
          "description": "MonadPlus all-interval series elem observeAll all interval length observeAll all interval map length observeAll all interval",
          "hierarchy": "Music Theory Z12 Morris_1974",
          "module": "Music.Theory.Z12.Morris_1974",
          "name": "all_interval_m",
          "normalized": "Int-\u003ea[Int]",
          "package": "hmt",
          "signature": "Int-\u003em[Int]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Z12-Morris_1974.html#v:all_interval_m"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003emsum\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003emap\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003ereturn\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e observeAll (fromList [1..7]) == [1..7]\n\u003c/pre\u003e",
          "module": "Music.Theory.Z12.Morris_1974",
          "name": "fromList",
          "package": "hmt",
          "signature": "[a] -\u003e m a",
          "source": "src/Music-Theory-Z12-Morris_1974.html#fromList",
          "type": "function"
        },
        "index": {
          "description": "msum map return observeAll fromList",
          "hierarchy": "Music Theory Z12 Morris_1974",
          "module": "Music.Theory.Z12.Morris_1974",
          "name": "fromList",
          "normalized": "[a]-\u003eb a",
          "package": "hmt",
          "partial": "List",
          "signature": "[a]-\u003em a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Z12-Morris_1974.html#v:fromList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eParsers for pitch class sets and sequences, and for \u003ccode\u003e\u003ca\u003eSRO\u003c/a\u003e\u003c/code\u003es.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Music.Theory.Z12.Morris_1987.Parse",
          "name": "Parse",
          "package": "hmt",
          "source": "src/Music-Theory-Z12-Morris_1987-Parse.html",
          "type": "module"
        },
        "index": {
          "description": "Parsers for pitch class sets and sequences and for SRO",
          "hierarchy": "Music Theory Z12 Morris_1987 Parse",
          "module": "Music.Theory.Z12.Morris_1987.Parse",
          "name": "Parse",
          "package": "hmt",
          "partial": "Parse",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Z12-Morris_1987-Parse.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eParse a \u003cem\u003epitch class object\u003c/em\u003e string.  Each \u003ccode\u003e\u003ca\u003eChar\u003c/a\u003e\u003c/code\u003e is either a\n number, a space which is ignored, or a letter name for the numbers\n 10 (\u003ccode\u003et\u003c/code\u003e or \u003ccode\u003ea\u003c/code\u003e or \u003ccode\u003eA\u003c/code\u003e) or 11 (\u003ccode\u003ee\u003c/code\u003e or \u003ccode\u003eB\u003c/code\u003e or \u003ccode\u003eb\u003c/code\u003e).\n\u003c/p\u003e\u003cpre\u003e pco \"13te\" == [1,3,10,11]\n pco \"13te\" == pco \"13ab\"\n\u003c/pre\u003e",
          "module": "Music.Theory.Z12.Morris_1987.Parse",
          "name": "pco",
          "package": "hmt",
          "signature": "String -\u003e [Z12]",
          "source": "src/Music-Theory-Z12-Morris_1987-Parse.html#pco",
          "type": "function"
        },
        "index": {
          "description": "Parse pitch class object string Each Char is either number space which is ignored or letter name for the numbers or or or or or pco te pco te pco ab",
          "hierarchy": "Music Theory Z12 Morris_1987 Parse",
          "module": "Music.Theory.Z12.Morris_1987.Parse",
          "name": "pco",
          "normalized": "String-\u003e[Z]",
          "package": "hmt",
          "signature": "String-\u003e[Z]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Z12-Morris_1987-Parse.html#v:pco"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eParse a Morris format serial operator descriptor.\n\u003c/p\u003e\u003cpre\u003e rnrtnmi \"r2RT3MI\" == SRO 2 True 3 True True\n\u003c/pre\u003e",
          "module": "Music.Theory.Z12.Morris_1987.Parse",
          "name": "rnrtnmi",
          "package": "hmt",
          "signature": "String -\u003e SRO",
          "source": "src/Music-Theory-Z12-Morris_1987-Parse.html#rnrtnmi",
          "type": "function"
        },
        "index": {
          "description": "Parse Morris format serial operator descriptor rnrtnmi r2RT3MI SRO True True True",
          "hierarchy": "Music Theory Z12 Morris_1987 Parse",
          "module": "Music.Theory.Z12.Morris_1987.Parse",
          "name": "rnrtnmi",
          "normalized": "String-\u003eSRO",
          "package": "hmt",
          "signature": "String-\u003eSRO",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Z12-Morris_1987-Parse.html#v:rnrtnmi"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eRobert Morris. /Composition with Pitch-Classes: A Theory of\n Compositional Design/. Yale University Press, New Haven, 1987.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Music.Theory.Z12.Morris_1987",
          "name": "Morris_1987",
          "package": "hmt",
          "source": "src/Music-Theory-Z12-Morris_1987.html",
          "type": "module"
        },
        "index": {
          "description": "Robert Morris Composition with Pitch-Classes Theory of Compositional Design Yale University Press New Haven",
          "hierarchy": "Music Theory Z12 Morris_1987",
          "module": "Music.Theory.Z12.Morris_1987",
          "name": "Morris_1987",
          "package": "hmt",
          "partial": "Morris",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Z12-Morris_1987.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSerial Operator,of the form rRTMI.\n\u003c/p\u003e",
          "module": "Music.Theory.Z12.Morris_1987",
          "name": "SRO",
          "package": "hmt",
          "source": "src/Music-Theory-Z12-Morris_1987.html#SRO",
          "type": "data"
        },
        "index": {
          "description": "Serial Operator of the form rRTMI",
          "hierarchy": "Music Theory Z12 Morris_1987",
          "module": "Music.Theory.Z12.Morris_1987",
          "name": "SRO",
          "package": "hmt",
          "partial": "SRO",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Z12-Morris_1987.html#t:SRO"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Z12.Morris_1987",
          "name": "SRO",
          "package": "hmt",
          "signature": "SRO Z12 Bool Z12 Bool Bool",
          "source": "src/Music-Theory-Z12-Morris_1987.html#SRO",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Z12 Morris_1987",
          "module": "Music.Theory.Z12.Morris_1987",
          "name": "SRO",
          "package": "hmt",
          "partial": "SRO",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Z12-Morris_1987.html#v:SRO"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eINT\u003c/code\u003e operator.\n\u003c/p\u003e\u003cpre\u003e int [0,1,3,6,10] == [1,2,3,4]\n\u003c/pre\u003e",
          "module": "Music.Theory.Z12.Morris_1987",
          "name": "int",
          "package": "hmt",
          "signature": "[Z12] -\u003e [Z12]",
          "source": "src/Music-Theory-Z12-Morris_1987.html#int",
          "type": "function"
        },
        "index": {
          "description": "INT operator int",
          "hierarchy": "Music Theory Z12 Morris_1987",
          "module": "Music.Theory.Z12.Morris_1987",
          "name": "int",
          "normalized": "[Z]-\u003e[Z]",
          "package": "hmt",
          "signature": "[Z]-\u003e[Z]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Z12-Morris_1987.html#v:int"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSerial operation.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003esro T4 156\n\u003c/code\u003e\u003c/strong\u003e59A\n\u003c/pre\u003e\u003cpre\u003e sro (rnrtnmi \"T4\") (pco \"156\") == [5,9,10]\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eecho 024579 | sro RT4I\n\u003c/code\u003e\u003c/strong\u003e79B024\n\u003c/pre\u003e\u003cpre\u003e sro (SRO 0 True 4 False True) [0,2,4,5,7,9] == [7,9,11,0,2,4]\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003esro T4I 156\n\u003c/code\u003e\u003c/strong\u003e3BA\n\u003c/pre\u003e\u003cpre\u003e sro (rnrtnmi \"T4I\") (pco \"156\") == [3,11,10]\n sro (SRO 0 False 4 False True) [1,5,6] == [3,11,10]\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eecho 156 | sro T4  | sro T0I\n\u003c/code\u003e\u003c/strong\u003e732\n\u003c/pre\u003e\u003cpre\u003e (sro (rnrtnmi \"T0I\") . sro (rnrtnmi \"T4\")) (pco \"156\") == [7,3,2]\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eecho 024579 | sro RT4I\n\u003c/code\u003e\u003c/strong\u003e79B024\n\u003c/pre\u003e\u003cpre\u003e sro (rnrtnmi \"RT4I\") (pco \"024579\") == [7,9,11,0,2,4]\n\u003c/pre\u003e\u003cpre\u003e sro (SRO 1 True 1 True False) [0,1,2,3] == [11,6,1,4]\n sro (SRO 1 False 4 True True) [0,1,2,3] == [11,6,1,4]\n\u003c/pre\u003e",
          "module": "Music.Theory.Z12.Morris_1987",
          "name": "sro",
          "package": "hmt",
          "signature": "SRO -\u003e [Z12] -\u003e [Z12]",
          "source": "src/Music-Theory-Z12-Morris_1987.html#sro",
          "type": "function"
        },
        "index": {
          "description": "Serial operation sro T4 sro rnrtnmi T4 pco echo sro RT4I B024 sro SRO True False True sro T4I BA sro rnrtnmi T4I pco sro SRO False False True echo sro T4 sro T0I sro rnrtnmi T0I sro rnrtnmi T4 pco echo sro RT4I B024 sro rnrtnmi RT4I pco sro SRO True True False sro SRO False True True",
          "hierarchy": "Music Theory Z12 Morris_1987",
          "module": "Music.Theory.Z12.Morris_1987",
          "name": "sro",
          "normalized": "SRO-\u003e[Z]-\u003e[Z]",
          "package": "hmt",
          "signature": "SRO-\u003e[Z]-\u003e[Z]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Z12-Morris_1987.html#v:sro"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe set of retrograde and transposition and inversion \u003ccode\u003e\u003ca\u003eSRO\u003c/a\u003e\u003c/code\u003es.\n\u003c/p\u003e",
          "module": "Music.Theory.Z12.Morris_1987",
          "name": "sro_RTnI",
          "package": "hmt",
          "signature": "[SRO]",
          "source": "src/Music-Theory-Z12-Morris_1987.html#sro_RTnI",
          "type": "function"
        },
        "index": {
          "description": "The set of retrograde and transposition and inversion SRO",
          "hierarchy": "Music Theory Z12 Morris_1987",
          "module": "Music.Theory.Z12.Morris_1987",
          "name": "sro_RTnI",
          "normalized": "[SRO]",
          "package": "hmt",
          "partial": "RTn",
          "signature": "[SRO]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Z12-Morris_1987.html#v:sro_RTnI"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe set of retrograde,transposition,\u003ccode\u003eM5\u003c/code\u003e and inversion \u003ccode\u003e\u003ca\u003eSRO\u003c/a\u003e\u003c/code\u003es.\n\u003c/p\u003e",
          "module": "Music.Theory.Z12.Morris_1987",
          "name": "sro_RTnMI",
          "package": "hmt",
          "signature": "[SRO]",
          "source": "src/Music-Theory-Z12-Morris_1987.html#sro_RTnMI",
          "type": "function"
        },
        "index": {
          "description": "The set of retrograde transposition M5 and inversion SRO",
          "hierarchy": "Music Theory Z12 Morris_1987",
          "module": "Music.Theory.Z12.Morris_1987",
          "name": "sro_RTnMI",
          "normalized": "[SRO]",
          "package": "hmt",
          "partial": "RTn MI",
          "signature": "[SRO]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Z12-Morris_1987.html#v:sro_RTnMI"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe set of transposition \u003ccode\u003e\u003ca\u003eSRO\u003c/a\u003e\u003c/code\u003es.\n\u003c/p\u003e",
          "module": "Music.Theory.Z12.Morris_1987",
          "name": "sro_Tn",
          "package": "hmt",
          "signature": "[SRO]",
          "source": "src/Music-Theory-Z12-Morris_1987.html#sro_Tn",
          "type": "function"
        },
        "index": {
          "description": "The set of transposition SRO",
          "hierarchy": "Music Theory Z12 Morris_1987",
          "module": "Music.Theory.Z12.Morris_1987",
          "name": "sro_Tn",
          "normalized": "[SRO]",
          "package": "hmt",
          "partial": "Tn",
          "signature": "[SRO]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Z12-Morris_1987.html#v:sro_Tn"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe set of transposition and inversion \u003ccode\u003e\u003ca\u003eSRO\u003c/a\u003e\u003c/code\u003es.\n\u003c/p\u003e",
          "module": "Music.Theory.Z12.Morris_1987",
          "name": "sro_TnI",
          "package": "hmt",
          "signature": "[SRO]",
          "source": "src/Music-Theory-Z12-Morris_1987.html#sro_TnI",
          "type": "function"
        },
        "index": {
          "description": "The set of transposition and inversion SRO",
          "hierarchy": "Music Theory Z12 Morris_1987",
          "module": "Music.Theory.Z12.Morris_1987",
          "name": "sro_TnI",
          "normalized": "[SRO]",
          "package": "hmt",
          "partial": "Tn",
          "signature": "[SRO]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Z12-Morris_1987.html#v:sro_TnI"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe set of transposition,\u003ccode\u003eM5\u003c/code\u003e and inversion \u003ccode\u003e\u003ca\u003eSRO\u003c/a\u003e\u003c/code\u003es.\n\u003c/p\u003e",
          "module": "Music.Theory.Z12.Morris_1987",
          "name": "sro_TnMI",
          "package": "hmt",
          "signature": "[SRO]",
          "source": "src/Music-Theory-Z12-Morris_1987.html#sro_TnMI",
          "type": "function"
        },
        "index": {
          "description": "The set of transposition M5 and inversion SRO",
          "hierarchy": "Music Theory Z12 Morris_1987",
          "module": "Music.Theory.Z12.Morris_1987",
          "name": "sro_TnMI",
          "normalized": "[SRO]",
          "package": "hmt",
          "partial": "Tn MI",
          "signature": "[SRO]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Z12-Morris_1987.html#v:sro_TnMI"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe total set of serial operations.\n\u003c/p\u003e",
          "module": "Music.Theory.Z12.Morris_1987",
          "name": "sros",
          "package": "hmt",
          "signature": "[Z12] -\u003e [(SRO, [Z12])]",
          "source": "src/Music-Theory-Z12-Morris_1987.html#sros",
          "type": "function"
        },
        "index": {
          "description": "The total set of serial operations",
          "hierarchy": "Music Theory Z12 Morris_1987",
          "module": "Music.Theory.Z12.Morris_1987",
          "name": "sros",
          "normalized": "[Z]-\u003e[(SRO,[Z])]",
          "package": "hmt",
          "signature": "[Z]-\u003e[(SRO,[Z])]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Z12-Morris_1987.html#v:sros"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eJohn Rahn. \u003cem\u003eBasic Atonal Theory\u003c/em\u003e. Longman, New York, 1980.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Music.Theory.Z12.Rahn_1980",
          "name": "Rahn_1980",
          "package": "hmt",
          "source": "src/Music-Theory-Z12-Rahn_1980.html",
          "type": "module"
        },
        "index": {
          "description": "John Rahn Basic Atonal Theory Longman New York",
          "hierarchy": "Music Theory Z12 Rahn_1980",
          "module": "Music.Theory.Z12.Rahn_1980",
          "name": "Rahn_1980",
          "package": "hmt",
          "partial": "Rahn",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Z12-Rahn_1980.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRahn prime form (comparison is rightmost inwards).\n\u003c/p\u003e\u003cpre\u003e rahn_cmp [0,1,3,6,8,9] [0,2,3,6,7,9] == GT\n\u003c/pre\u003e",
          "module": "Music.Theory.Z12.Rahn_1980",
          "name": "rahn_cmp",
          "package": "hmt",
          "signature": "[a] -\u003e [a] -\u003e Ordering",
          "source": "src/Music-Theory-Z12-Rahn_1980.html#rahn_cmp",
          "type": "function"
        },
        "index": {
          "description": "Rahn prime form comparison is rightmost inwards rahn cmp GT",
          "hierarchy": "Music Theory Z12 Rahn_1980",
          "module": "Music.Theory.Z12.Rahn_1980",
          "name": "rahn_cmp",
          "normalized": "[a]-\u003e[a]-\u003eOrdering",
          "package": "hmt",
          "signature": "[a]-\u003e[a]-\u003eOrdering",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Z12-Rahn_1980.html#v:rahn_cmp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRahn prime form, ie. \u003ccode\u003e\u003ca\u003eti_cmp_prime\u003c/a\u003e\u003c/code\u003e of \u003ccode\u003e\u003ca\u003erahn_cmp\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e rahn_prime [0,1,3,6,8,9] == [0,2,3,6,7,9]\n\u003c/pre\u003e\u003cpre\u003e let s = [[0,1,3,7,8]\n         ,[0,1,3,6,8,9],[0,1,3,5,8,9]\n         ,[0,1,2,4,7,8,9]\n         ,[0,1,2,4,5,7,9,10]]\n in all (\\p -\u003e forte_prime p /= rahn_prime p) s == True\n\u003c/pre\u003e",
          "module": "Music.Theory.Z12.Rahn_1980",
          "name": "rahn_prime",
          "package": "hmt",
          "signature": "[Z12] -\u003e [Z12]",
          "source": "src/Music-Theory-Z12-Rahn_1980.html#rahn_prime",
          "type": "function"
        },
        "index": {
          "description": "Rahn prime form ie ti cmp prime of rahn cmp rahn prime let in all forte prime rahn prime True",
          "hierarchy": "Music Theory Z12 Rahn_1980",
          "module": "Music.Theory.Z12.Rahn_1980",
          "name": "rahn_prime",
          "normalized": "[Z]-\u003e[Z]",
          "package": "hmt",
          "signature": "[Z]-\u003e[Z]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Z12-Rahn_1980.html#v:rahn_prime"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eRonald C. Read. \"Every one a winner or how to avoid isomorphism\n search when cataloguing combinatorial configurations.\" /Annals of\n Discrete Mathematics/ 2:107&#8211;20, 1978.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Music.Theory.Z12.Read_1978",
          "name": "Read_1978",
          "package": "hmt",
          "source": "src/Music-Theory-Z12-Read_1978.html",
          "type": "module"
        },
        "index": {
          "description": "Ronald Read Every one winner or how to avoid isomorphism search when cataloguing combinatorial configurations Annals of Discrete Mathematics",
          "hierarchy": "Music Theory Z12 Read_1978",
          "module": "Music.Theory.Z12.Read_1978",
          "name": "Read_1978",
          "package": "hmt",
          "partial": "Read",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Z12-Read_1978.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDecoder for \u003ccode\u003e\u003ca\u003eencode_prime\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e decode 843 == [0,1,3,6,8,9]\n\u003c/pre\u003e",
          "module": "Music.Theory.Z12.Read_1978",
          "name": "decode",
          "package": "hmt",
          "signature": "Integer -\u003e [Z12]",
          "source": "src/Music-Theory-Z12-Read_1978.html#decode",
          "type": "function"
        },
        "index": {
          "description": "Decoder for encode prime decode",
          "hierarchy": "Music Theory Z12 Read_1978",
          "module": "Music.Theory.Z12.Read_1978",
          "name": "decode",
          "normalized": "Integer-\u003e[Z]",
          "package": "hmt",
          "signature": "Integer-\u003e[Z]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Z12-Read_1978.html#v:decode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEncoder for \u003ccode\u003e\u003ca\u003eencode_prime\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e encode [0,1,3,6,8,9] == 843\n\u003c/pre\u003e",
          "module": "Music.Theory.Z12.Read_1978",
          "name": "encode",
          "package": "hmt",
          "signature": "[Z12] -\u003e Integer",
          "source": "src/Music-Theory-Z12-Read_1978.html#encode",
          "type": "function"
        },
        "index": {
          "description": "Encoder for encode prime encode",
          "hierarchy": "Music Theory Z12 Read_1978",
          "module": "Music.Theory.Z12.Read_1978",
          "name": "encode",
          "normalized": "[Z]-\u003eInteger",
          "package": "hmt",
          "signature": "[Z]-\u003eInteger",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Z12-Read_1978.html#v:encode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eBinary encoding prime form algorithm, equalivalent to Rahn.\n\u003c/p\u003e\u003cpre\u003e encode_prime [0,1,3,6,8,9] == rahn_prime [0,1,3,6,8,9]\n\u003c/pre\u003e",
          "module": "Music.Theory.Z12.Read_1978",
          "name": "encode_prime",
          "package": "hmt",
          "signature": "[Z12] -\u003e [Z12]",
          "source": "src/Music-Theory-Z12-Read_1978.html#encode_prime",
          "type": "function"
        },
        "index": {
          "description": "Binary encoding prime form algorithm equalivalent to Rahn encode prime rahn prime",
          "hierarchy": "Music Theory Z12 Read_1978",
          "module": "Music.Theory.Z12.Read_1978",
          "name": "encode_prime",
          "normalized": "[Z]-\u003e[Z]",
          "package": "hmt",
          "signature": "[Z]-\u003e[Z]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Z12-Read_1978.html#v:encode_prime"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eSerial (ordered) pitch-class operations on \u003ccode\u003e\u003ca\u003eZ12\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Music.Theory.Z12.SRO",
          "name": "SRO",
          "package": "hmt",
          "source": "src/Music-Theory-Z12-SRO.html",
          "type": "module"
        },
        "index": {
          "description": "Serial ordered pitch-class operations on Z12",
          "hierarchy": "Music Theory Z12 SRO",
          "module": "Music.Theory.Z12.SRO",
          "name": "SRO",
          "package": "hmt",
          "partial": "SRO",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Z12-SRO.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInvert \u003cem\u003ep\u003c/em\u003e about \u003cem\u003en\u003c/em\u003e.\n\u003c/p\u003e\u003cpre\u003e invert 6 [4,5,6] == [8,7,6]\n invert 0 [0,1,3] == [0,11,9]\n\u003c/pre\u003e",
          "module": "Music.Theory.Z12.SRO",
          "name": "invert",
          "package": "hmt",
          "signature": "Z12 -\u003e [Z12] -\u003e [Z12]",
          "source": "src/Music-Theory-Z12-SRO.html#invert",
          "type": "function"
        },
        "index": {
          "description": "Invert about invert invert",
          "hierarchy": "Music Theory Z12 SRO",
          "module": "Music.Theory.Z12.SRO",
          "name": "invert",
          "normalized": "Z-\u003e[Z]-\u003e[Z]",
          "package": "hmt",
          "signature": "Z-\u003e[Z]-\u003e[Z]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Z12-SRO.html#v:invert"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eVariant of \u003ccode\u003e\u003ca\u003einvert\u003c/a\u003e\u003c/code\u003e, inverse about \u003cem\u003en\u003c/em\u003eth element.\n\u003c/p\u003e\u003cpre\u003e map (invert_ix 0) [[0,1,3],[3,4,6]] == [[0,11,9],[3,2,0]]\n map (invert_ix 1) [[0,1,3],[3,4,6]] == [[2,1,11],[5,4,2]]\n\u003c/pre\u003e",
          "module": "Music.Theory.Z12.SRO",
          "name": "invert_ix",
          "package": "hmt",
          "signature": "Int -\u003e [Z12] -\u003e [Z12]",
          "source": "src/Music-Theory-Z12-SRO.html#invert_ix",
          "type": "function"
        },
        "index": {
          "description": "Variant of invert inverse about th element map invert ix map invert ix",
          "hierarchy": "Music Theory Z12 SRO",
          "module": "Music.Theory.Z12.SRO",
          "name": "invert_ix",
          "normalized": "Int-\u003e[Z]-\u003e[Z]",
          "package": "hmt",
          "signature": "Int-\u003e[Z]-\u003e[Z]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Z12-SRO.html#v:invert_ix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eM5, ie. \u003ccode\u003e\u003ca\u003emn\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e5\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e m5 [0,1,3] == [0,5,3]\n\u003c/pre\u003e",
          "module": "Music.Theory.Z12.SRO",
          "name": "m5",
          "package": "hmt",
          "signature": "[Z12] -\u003e [Z12]",
          "source": "src/Music-Theory-Z12-SRO.html#m5",
          "type": "function"
        },
        "index": {
          "description": "M5 ie mn m5",
          "hierarchy": "Music Theory Z12 SRO",
          "module": "Music.Theory.Z12.SRO",
          "name": "m5",
          "normalized": "[Z]-\u003e[Z]",
          "package": "hmt",
          "signature": "[Z]-\u003e[Z]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Z12-SRO.html#v:m5"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eModulo 12 multiplication\n\u003c/p\u003e\u003cpre\u003e mn 11 [0,1,4,9] == tni 0 [0,1,4,9]\n\u003c/pre\u003e",
          "module": "Music.Theory.Z12.SRO",
          "name": "mn",
          "package": "hmt",
          "signature": "Z12 -\u003e [Z12] -\u003e [Z12]",
          "source": "src/Music-Theory-Z12-SRO.html#mn",
          "type": "function"
        },
        "index": {
          "description": "Modulo multiplication mn tni",
          "hierarchy": "Music Theory Z12 SRO",
          "module": "Music.Theory.Z12.SRO",
          "name": "mn",
          "normalized": "Z-\u003e[Z]-\u003e[Z]",
          "package": "hmt",
          "signature": "Z-\u003e[Z]-\u003e[Z]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Z12-SRO.html#v:mn"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003er/R/T/M/I-related sequences of \u003cem\u003ep\u003c/em\u003e.\n\u003c/p\u003e",
          "module": "Music.Theory.Z12.SRO",
          "name": "rrtmi_related",
          "package": "hmt",
          "signature": "[Z12] -\u003e [[Z12]]",
          "source": "src/Music-Theory-Z12-SRO.html#rrtmi_related",
          "type": "function"
        },
        "index": {
          "description": "I-related sequences of",
          "hierarchy": "Music Theory Z12 SRO",
          "module": "Music.Theory.Z12.SRO",
          "name": "rrtmi_related",
          "normalized": "[Z]-\u003e[[Z]]",
          "package": "hmt",
          "signature": "[Z]-\u003e[[Z]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Z12-SRO.html#v:rrtmi_related"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eR/T/I-related sequences of \u003cem\u003ep\u003c/em\u003e.\n\u003c/p\u003e\u003cpre\u003e length (rti_related [0,1,3]) == 48\n length (rti_related [0,3,6,9]) == 24\n\u003c/pre\u003e",
          "module": "Music.Theory.Z12.SRO",
          "name": "rti_related",
          "package": "hmt",
          "signature": "[Z12] -\u003e [[Z12]]",
          "source": "src/Music-Theory-Z12-SRO.html#rti_related",
          "type": "function"
        },
        "index": {
          "description": "I-related sequences of length rti related length rti related",
          "hierarchy": "Music Theory Z12 SRO",
          "module": "Music.Theory.Z12.SRO",
          "name": "rti_related",
          "normalized": "[Z]-\u003e[[Z]]",
          "package": "hmt",
          "signature": "[Z]-\u003e[[Z]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Z12-SRO.html#v:rti_related"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eR/T/M/I-related sequences of \u003cem\u003ep\u003c/em\u003e.\n\u003c/p\u003e",
          "module": "Music.Theory.Z12.SRO",
          "name": "rtmi_related",
          "package": "hmt",
          "signature": "[Z12] -\u003e [[Z12]]",
          "source": "src/Music-Theory-Z12-SRO.html#rtmi_related",
          "type": "function"
        },
        "index": {
          "description": "I-related sequences of",
          "hierarchy": "Music Theory Z12 SRO",
          "module": "Music.Theory.Z12.SRO",
          "name": "rtmi_related",
          "normalized": "[Z]-\u003e[[Z]]",
          "package": "hmt",
          "signature": "[Z]-\u003e[[Z]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Z12-SRO.html#v:rtmi_related"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eT-related sequences of \u003cem\u003ep\u003c/em\u003e.\n\u003c/p\u003e\u003cpre\u003e length (t_related [0,3,6,9]) == 12\n\u003c/pre\u003e",
          "module": "Music.Theory.Z12.SRO",
          "name": "t_related",
          "package": "hmt",
          "signature": "[Z12] -\u003e [[Z12]]",
          "source": "src/Music-Theory-Z12-SRO.html#t_related",
          "type": "function"
        },
        "index": {
          "description": "T-related sequences of length related",
          "hierarchy": "Music Theory Z12 SRO",
          "module": "Music.Theory.Z12.SRO",
          "name": "t_related",
          "normalized": "[Z]-\u003e[[Z]]",
          "package": "hmt",
          "signature": "[Z]-\u003e[[Z]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Z12-SRO.html#v:t_related"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eT/I-related sequences of \u003cem\u003ep\u003c/em\u003e.\n\u003c/p\u003e\u003cpre\u003e length (ti_related [0,1,3]) == 24\n length (ti_related [0,3,6,9]) == 24\n ti_related [0] == map return [0..11]\n\u003c/pre\u003e",
          "module": "Music.Theory.Z12.SRO",
          "name": "ti_related",
          "package": "hmt",
          "signature": "[Z12] -\u003e [[Z12]]",
          "source": "src/Music-Theory-Z12-SRO.html#ti_related",
          "type": "function"
        },
        "index": {
          "description": "I-related sequences of length ti related length ti related ti related map return",
          "hierarchy": "Music Theory Z12 SRO",
          "module": "Music.Theory.Z12.SRO",
          "name": "ti_related",
          "normalized": "[Z]-\u003e[[Z]]",
          "package": "hmt",
          "signature": "[Z]-\u003e[[Z]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Z12-SRO.html#v:ti_related"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe standard t-matrix of \u003cem\u003ep\u003c/em\u003e.\n\u003c/p\u003e\u003cpre\u003e tmatrix [0,1,3] == [[0,1,3]\n                    ,[11,0,2]\n                    ,[9,10,0]]\n\u003c/pre\u003e",
          "module": "Music.Theory.Z12.SRO",
          "name": "tmatrix",
          "package": "hmt",
          "signature": "[Z12] -\u003e [[Z12]]",
          "source": "src/Music-Theory-Z12-SRO.html#tmatrix",
          "type": "function"
        },
        "index": {
          "description": "The standard t-matrix of tmatrix",
          "hierarchy": "Music Theory Z12 SRO",
          "module": "Music.Theory.Z12.SRO",
          "name": "tmatrix",
          "normalized": "[Z]-\u003e[[Z]]",
          "package": "hmt",
          "signature": "[Z]-\u003e[[Z]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Z12-SRO.html#v:tmatrix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eT/M/I-related sequences of \u003cem\u003ep\u003c/em\u003e.\n\u003c/p\u003e",
          "module": "Music.Theory.Z12.SRO",
          "name": "tmi_related",
          "package": "hmt",
          "signature": "[Z12] -\u003e [[Z12]]",
          "source": "src/Music-Theory-Z12-SRO.html#tmi_related",
          "type": "function"
        },
        "index": {
          "description": "I-related sequences of",
          "hierarchy": "Music Theory Z12 SRO",
          "module": "Music.Theory.Z12.SRO",
          "name": "tmi_related",
          "normalized": "[Z]-\u003e[[Z]]",
          "package": "hmt",
          "signature": "[Z]-\u003e[[Z]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Z12-SRO.html#v:tmi_related"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTranspose \u003cem\u003ep\u003c/em\u003e by \u003cem\u003en\u003c/em\u003e.\n\u003c/p\u003e\u003cpre\u003e tn 4 [1,5,6] == [5,9,10]\n\u003c/pre\u003e",
          "module": "Music.Theory.Z12.SRO",
          "name": "tn",
          "package": "hmt",
          "signature": "Z12 -\u003e [Z12] -\u003e [Z12]",
          "source": "src/Music-Theory-Z12-SRO.html#tn",
          "type": "function"
        },
        "index": {
          "description": "Transpose by tn",
          "hierarchy": "Music Theory Z12 SRO",
          "module": "Music.Theory.Z12.SRO",
          "name": "tn",
          "normalized": "Z-\u003e[Z]-\u003e[Z]",
          "package": "hmt",
          "signature": "Z-\u003e[Z]-\u003e[Z]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Z12-SRO.html#v:tn"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eVariant of \u003ccode\u003e\u003ca\u003etn\u003c/a\u003e\u003c/code\u003e, transpose \u003cem\u003ep\u003c/em\u003e so first element is \u003cem\u003en\u003c/em\u003e.\n\u003c/p\u003e\u003cpre\u003e tn_to 5 [0,1,3] == [5,6,8]\n\u003c/pre\u003e",
          "module": "Music.Theory.Z12.SRO",
          "name": "tn_to",
          "package": "hmt",
          "signature": "Z12 -\u003e [Z12] -\u003e [Z12]",
          "source": "src/Music-Theory-Z12-SRO.html#tn_to",
          "type": "function"
        },
        "index": {
          "description": "Variant of tn transpose so first element is tn to",
          "hierarchy": "Music Theory Z12 SRO",
          "module": "Music.Theory.Z12.SRO",
          "name": "tn_to",
          "normalized": "Z-\u003e[Z]-\u003e[Z]",
          "package": "hmt",
          "signature": "Z-\u003e[Z]-\u003e[Z]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Z12-SRO.html#v:tn_to"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eComposition of \u003ccode\u003e\u003ca\u003einvert\u003c/a\u003e\u003c/code\u003e about \u003ccode\u003e0\u003c/code\u003e and \u003ccode\u003e\u003ca\u003etn\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e tni 4 [1,5,6] == [3,11,10]\n (invert 0 . tn  4) [1,5,6] == [7,3,2]\n\u003c/pre\u003e",
          "module": "Music.Theory.Z12.SRO",
          "name": "tni",
          "package": "hmt",
          "signature": "Z12 -\u003e [Z12] -\u003e [Z12]",
          "source": "src/Music-Theory-Z12-SRO.html#tni",
          "type": "function"
        },
        "index": {
          "description": "Composition of invert about and tn tni invert tn",
          "hierarchy": "Music Theory Z12 SRO",
          "module": "Music.Theory.Z12.SRO",
          "name": "tni",
          "normalized": "Z-\u003e[Z]-\u003e[Z]",
          "package": "hmt",
          "signature": "Z-\u003e[Z]-\u003e[Z]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Z12-SRO.html#v:tni"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003ePitch-class set (unordered) operations on \u003ccode\u003e\u003ca\u003eZ12\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Music.Theory.Z12.TTO",
          "name": "TTO",
          "package": "hmt",
          "source": "src/Music-Theory-Z12-TTO.html",
          "type": "module"
        },
        "index": {
          "description": "Pitch-class set unordered operations on Z12",
          "hierarchy": "Music Theory Z12 TTO",
          "module": "Music.Theory.Z12.TTO",
          "name": "TTO",
          "package": "hmt",
          "partial": "TTO",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Z12-TTO.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInvert about n.\n\u003c/p\u003e\u003cpre\u003e invert 6 [4,5,6] == [6,7,8]\n invert 0 [0,1,3] == [0,9,11]\n\u003c/pre\u003e",
          "module": "Music.Theory.Z12.TTO",
          "name": "invert",
          "package": "hmt",
          "signature": "Z12 -\u003e [Z12] -\u003e [Z12]",
          "source": "src/Music-Theory-Z12-TTO.html#invert",
          "type": "function"
        },
        "index": {
          "description": "Invert about invert invert",
          "hierarchy": "Music Theory Z12 TTO",
          "module": "Music.Theory.Z12.TTO",
          "name": "invert",
          "normalized": "Z-\u003e[Z]-\u003e[Z]",
          "package": "hmt",
          "signature": "Z-\u003e[Z]-\u003e[Z]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Z12-TTO.html#v:invert"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eM5, ie. \u003ccode\u003e\u003ca\u003emn\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e5\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e m5 [0,1,3] == [0,3,5]\n\u003c/pre\u003e",
          "module": "Music.Theory.Z12.TTO",
          "name": "m5",
          "package": "hmt",
          "signature": "[Z12] -\u003e [Z12]",
          "source": "src/Music-Theory-Z12-TTO.html#m5",
          "type": "function"
        },
        "index": {
          "description": "M5 ie mn m5",
          "hierarchy": "Music Theory Z12 TTO",
          "module": "Music.Theory.Z12.TTO",
          "name": "m5",
          "normalized": "[Z]-\u003e[Z]",
          "package": "hmt",
          "signature": "[Z]-\u003e[Z]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Z12-TTO.html#v:m5"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eModulo 12 multiplication\n\u003c/p\u003e\u003cpre\u003e mn 11 [0,1,4,9] == invert 0 [0,1,4,9]\n\u003c/pre\u003e",
          "module": "Music.Theory.Z12.TTO",
          "name": "mn",
          "package": "hmt",
          "signature": "Z12 -\u003e [Z12] -\u003e [Z12]",
          "source": "src/Music-Theory-Z12-TTO.html#mn",
          "type": "function"
        },
        "index": {
          "description": "Modulo multiplication mn invert",
          "hierarchy": "Music Theory Z12 TTO",
          "module": "Music.Theory.Z12.TTO",
          "name": "mn",
          "normalized": "Z-\u003e[Z]-\u003e[Z]",
          "package": "hmt",
          "signature": "Z-\u003e[Z]-\u003e[Z]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Z12-TTO.html#v:mn"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMap to pitch-class and reduce to set.\n\u003c/p\u003e\u003cpre\u003e pcset [1,13] == [1]\n\u003c/pre\u003e",
          "module": "Music.Theory.Z12.TTO",
          "name": "pcset",
          "package": "hmt",
          "signature": "[a] -\u003e [Z12]",
          "source": "src/Music-Theory-Z12-TTO.html#pcset",
          "type": "function"
        },
        "index": {
          "description": "Map to pitch-class and reduce to set pcset",
          "hierarchy": "Music Theory Z12 TTO",
          "module": "Music.Theory.Z12.TTO",
          "name": "pcset",
          "normalized": "[a]-\u003e[Z]",
          "package": "hmt",
          "signature": "[a]-\u003e[Z]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Z12-TTO.html#v:pcset"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eT-related sets of \u003cem\u003ep\u003c/em\u003e.\n\u003c/p\u003e\u003cpre\u003e length (t_related [0,1,3]) == 12\n t_related [0,3,6,9] == [[0,3,6,9],[1,4,7,10],[2,5,8,11]]\n\u003c/pre\u003e",
          "module": "Music.Theory.Z12.TTO",
          "name": "t_related",
          "package": "hmt",
          "signature": "[Z12] -\u003e [[Z12]]",
          "source": "src/Music-Theory-Z12-TTO.html#t_related",
          "type": "function"
        },
        "index": {
          "description": "T-related sets of length related related",
          "hierarchy": "Music Theory Z12 TTO",
          "module": "Music.Theory.Z12.TTO",
          "name": "t_related",
          "normalized": "[Z]-\u003e[[Z]]",
          "package": "hmt",
          "signature": "[Z]-\u003e[[Z]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Z12-TTO.html#v:t_related"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eT/I-related set of \u003cem\u003ep\u003c/em\u003e.\n\u003c/p\u003e\u003cpre\u003e length (ti_related [0,1,3]) == 24\n ti_related [0,3,6,9] == [[0,3,6,9],[1,4,7,10],[2,5,8,11]]\n\u003c/pre\u003e",
          "module": "Music.Theory.Z12.TTO",
          "name": "ti_related",
          "package": "hmt",
          "signature": "[Z12] -\u003e [[Z12]]",
          "source": "src/Music-Theory-Z12-TTO.html#ti_related",
          "type": "function"
        },
        "index": {
          "description": "I-related set of length ti related ti related",
          "hierarchy": "Music Theory Z12 TTO",
          "module": "Music.Theory.Z12.TTO",
          "name": "ti_related",
          "normalized": "[Z]-\u003e[[Z]]",
          "package": "hmt",
          "signature": "[Z]-\u003e[[Z]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Z12-TTO.html#v:ti_related"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTranspose by n.\n\u003c/p\u003e\u003cpre\u003e tn 4 [1,5,6] == [5,9,10]\n tn 4 [0,4,8] == [0,4,8]\n\u003c/pre\u003e",
          "module": "Music.Theory.Z12.TTO",
          "name": "tn",
          "package": "hmt",
          "signature": "Z12 -\u003e [Z12] -\u003e [Z12]",
          "source": "src/Music-Theory-Z12-TTO.html#tn",
          "type": "function"
        },
        "index": {
          "description": "Transpose by tn tn",
          "hierarchy": "Music Theory Z12 TTO",
          "module": "Music.Theory.Z12.TTO",
          "name": "tn",
          "normalized": "Z-\u003e[Z]-\u003e[Z]",
          "package": "hmt",
          "signature": "Z-\u003e[Z]-\u003e[Z]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Z12-TTO.html#v:tn"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eComposition of \u003ccode\u003e\u003ca\u003einvert\u003c/a\u003e\u003c/code\u003e about \u003ccode\u003e0\u003c/code\u003e and \u003ccode\u003e\u003ca\u003etn\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e tni 4 [1,5,6] == [3,10,11]\n (invert 0 . tn  4) [1,5,6] == [2,3,7]\n\u003c/pre\u003e",
          "module": "Music.Theory.Z12.TTO",
          "name": "tni",
          "package": "hmt",
          "signature": "Z12 -\u003e [Z12] -\u003e [Z12]",
          "source": "src/Music-Theory-Z12-TTO.html#tni",
          "type": "function"
        },
        "index": {
          "description": "Composition of invert about and tn tni invert tn",
          "hierarchy": "Music Theory Z12 TTO",
          "module": "Music.Theory.Z12.TTO",
          "name": "tni",
          "normalized": "Z-\u003e[Z]-\u003e[Z]",
          "package": "hmt",
          "signature": "Z-\u003e[Z]-\u003e[Z]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Z12-TTO.html#v:tni"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Z12",
          "name": "Z12",
          "package": "hmt",
          "source": "src/Music-Theory-Z12.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Music Theory Z12",
          "module": "Music.Theory.Z12",
          "name": "Z12",
          "package": "hmt",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Z12.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Z12",
          "name": "Z12",
          "package": "hmt",
          "source": "src/Music-Theory-Z12.html#Z12",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "Music Theory Z12",
          "module": "Music.Theory.Z12",
          "name": "Z12",
          "package": "hmt",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Z12.html#t:Z12"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Z12",
          "name": "Z12",
          "package": "hmt",
          "signature": "Z12 Int",
          "source": "src/Music-Theory-Z12.html#Z12",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Z12",
          "module": "Music.Theory.Z12",
          "name": "Z12",
          "package": "hmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Z12.html#v:Z12"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eZ12 not in set.\n\u003c/p\u003e\u003cpre\u003e complement [0,2,4,5,7,9,11] == [1,3,6,8,10]\n\u003c/pre\u003e",
          "module": "Music.Theory.Z12",
          "name": "complement",
          "package": "hmt",
          "signature": "[Z12] -\u003e [Z12]",
          "source": "src/Music-Theory-Z12.html#complement",
          "type": "function"
        },
        "index": {
          "description": "Z12 not in set complement",
          "hierarchy": "Music Theory Z12",
          "module": "Music.Theory.Z12",
          "name": "complement",
          "normalized": "[Z]-\u003e[Z]",
          "package": "hmt",
          "signature": "[Z]-\u003e[Z]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Z12.html#v:complement"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Z12",
          "name": "fromZ12",
          "package": "hmt",
          "signature": "Z12 -\u003e i",
          "source": "src/Music-Theory-Z12.html#fromZ12",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Z12",
          "module": "Music.Theory.Z12",
          "name": "fromZ12",
          "normalized": "Z-\u003ea",
          "package": "hmt",
          "signature": "Z-\u003ei",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Z12.html#v:fromZ12"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Z12",
          "name": "liftBZ12",
          "package": "hmt",
          "signature": "(Int -\u003e Int -\u003e Int) -\u003e Z12 -\u003e Z12 -\u003e Z12",
          "source": "src/Music-Theory-Z12.html#liftBZ12",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Z12",
          "module": "Music.Theory.Z12",
          "name": "liftBZ12",
          "normalized": "(Int-\u003eInt-\u003eInt)-\u003eZ-\u003eZ-\u003eZ",
          "package": "hmt",
          "partial": "BZ",
          "signature": "(Int-\u003eInt-\u003eInt)-\u003eZ-\u003eZ-\u003eZ",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Z12.html#v:liftBZ12"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Z12",
          "name": "liftUZ12",
          "package": "hmt",
          "signature": "(Int -\u003e Int) -\u003e Z12 -\u003e Z12",
          "source": "src/Music-Theory-Z12.html#liftUZ12",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Z12",
          "module": "Music.Theory.Z12",
          "name": "liftUZ12",
          "normalized": "(Int-\u003eInt)-\u003eZ-\u003eZ",
          "package": "hmt",
          "partial": "UZ",
          "signature": "(Int-\u003eInt)-\u003eZ-\u003eZ",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Z12.html#v:liftUZ12"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Music.Theory.Z12",
          "name": "toZ12",
          "package": "hmt",
          "signature": "i -\u003e Z12",
          "source": "src/Music-Theory-Z12.html#toZ12",
          "type": "function"
        },
        "index": {
          "hierarchy": "Music Theory Z12",
          "module": "Music.Theory.Z12",
          "name": "toZ12",
          "normalized": "a-\u003eZ",
          "package": "hmt",
          "signature": "i-\u003eZ",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmt/docs/Music-Theory-Z12.html#v:toZ12"
      }
    }
  ]
]