[
  {
    "cmd": "delete-by-query",
    "query": {
      "contexts": [
        "package"
      ],
      "query": {
        "op": "case",
        "type": "word",
        "word": "type-settheory"
      },
      "type": "context"
    }
  },
  [
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Typeable.Extras",
          "name": "Extras",
          "package": "type-settheory",
          "source": "src/Data-Typeable-Extras.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Data Typeable Extras",
          "module": "Data.Typeable.Extras",
          "name": "Extras",
          "package": "type-settheory",
          "partial": "Extras",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Data-Typeable-Extras.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Typeable.Extras",
          "name": "dynCompare",
          "package": "type-settheory",
          "signature": "a -\u003e b -\u003e Ordering",
          "source": "src/Data-Typeable-Extras.html#dynCompare",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Typeable Extras",
          "module": "Data.Typeable.Extras",
          "name": "dynCompare",
          "normalized": "a-\u003eb-\u003eOrdering",
          "package": "type-settheory",
          "partial": "Compare",
          "signature": "a-\u003eb-\u003eOrdering",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Data-Typeable-Extras.html#v:dynCompare"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Typeable.Extras",
          "name": "dynEq",
          "package": "type-settheory",
          "signature": "a -\u003e b -\u003e Bool",
          "source": "src/Data-Typeable-Extras.html#dynEq",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Typeable Extras",
          "module": "Data.Typeable.Extras",
          "name": "dynEq",
          "normalized": "a-\u003eb-\u003eBool",
          "package": "type-settheory",
          "partial": "Eq",
          "signature": "a-\u003eb-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Data-Typeable-Extras.html#v:dynEq"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Dummies",
          "name": "Dummies",
          "package": "type-settheory",
          "source": "src/Type-Dummies.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Type Dummies",
          "module": "Type.Dummies",
          "name": "Dummies",
          "package": "type-settheory",
          "partial": "Dummies",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Dummies.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Dummies",
          "name": "BOOL",
          "package": "type-settheory",
          "source": "src/Type-Dummies.html#BOOL",
          "type": "data"
        },
        "index": {
          "hierarchy": "Type Dummies",
          "module": "Type.Dummies",
          "name": "BOOL",
          "package": "type-settheory",
          "partial": "BOOL",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Dummies.html#t:BOOL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Dummies",
          "name": "Bool0",
          "package": "type-settheory",
          "source": "src/Type-Dummies.html#Bool0",
          "type": "data"
        },
        "index": {
          "hierarchy": "Type Dummies",
          "module": "Type.Dummies",
          "name": "Bool0",
          "package": "type-settheory",
          "partial": "Bool",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Dummies.html#t:Bool0"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Dummies",
          "name": "Bool1",
          "package": "type-settheory",
          "source": "src/Type-Dummies.html#Bool1",
          "type": "data"
        },
        "index": {
          "hierarchy": "Type Dummies",
          "module": "Type.Dummies",
          "name": "Bool1",
          "package": "type-settheory",
          "partial": "Bool",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Dummies.html#t:Bool1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\"Kind-cast\" \u003ccode\u003e (* -\u003e *) \u003c/code\u003e to \u003ccode\u003e*\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Type.Dummies",
          "name": "Lower",
          "package": "type-settheory",
          "source": "src/Type-Dummies.html#Lower",
          "type": "data"
        },
        "index": {
          "description": "Kind-cast to",
          "hierarchy": "Type Dummies",
          "module": "Type.Dummies",
          "name": "Lower",
          "package": "type-settheory",
          "partial": "Lower",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Dummies.html#t:Lower"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\"Kind-cast\" \u003ccode\u003e ((* -\u003e *) -\u003e *) \u003c/code\u003e to \u003ccode\u003e (* -\u003e *) \u003c/code\u003e. Also lower elements using \u003ccode\u003e\u003ca\u003eLower\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Type.Dummies",
          "name": "Lower1",
          "package": "type-settheory",
          "source": "src/Type-Dummies.html#Lower1",
          "type": "data"
        },
        "index": {
          "description": "Kind-cast to Also lower elements using Lower",
          "hierarchy": "Type Dummies",
          "module": "Type.Dummies",
          "name": "Lower1",
          "package": "type-settheory",
          "partial": "Lower",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Dummies.html#t:Lower1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\"Kind-cast\" \u003ccode\u003e (((* -\u003e *) -\u003e *) -\u003e *) \u003c/code\u003e to \u003ccode\u003e ((* -\u003e *) -\u003e *) \u003c/code\u003e. Also lower elements using \u003ccode\u003e\u003ca\u003eLower1\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Type.Dummies",
          "name": "Lower2",
          "package": "type-settheory",
          "source": "src/Type-Dummies.html#Lower2",
          "type": "data"
        },
        "index": {
          "description": "Kind-cast to Also lower elements using Lower1",
          "hierarchy": "Type Dummies",
          "module": "Type.Dummies",
          "name": "Lower2",
          "package": "type-settheory",
          "partial": "Lower",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Dummies.html#t:Lower2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\"Kind-cast\" \u003ccode\u003e ((((* -\u003e *) -\u003e *) -\u003e *) -\u003e *) \u003c/code\u003e to \u003ccode\u003e (((* -\u003e *) -\u003e *) -\u003e *) \u003c/code\u003e. Also lower elements using \u003ccode\u003e\u003ca\u003eLower2\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Type.Dummies",
          "name": "Lower3",
          "package": "type-settheory",
          "source": "src/Type-Dummies.html#Lower3",
          "type": "data"
        },
        "index": {
          "description": "Kind-cast to Also lower elements using Lower2",
          "hierarchy": "Type Dummies",
          "module": "Type.Dummies",
          "name": "Lower3",
          "package": "type-settheory",
          "partial": "Lower",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Dummies.html#t:Lower3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePair of types of kind \u003ccode\u003e (* -\u003e *) \u003c/code\u003e\n\u003c/p\u003e",
          "module": "Type.Dummies",
          "name": "PAIR",
          "package": "type-settheory",
          "source": "src/Type-Dummies.html#PAIR",
          "type": "data"
        },
        "index": {
          "description": "Pair of types of kind",
          "hierarchy": "Type Dummies",
          "module": "Type.Dummies",
          "name": "PAIR",
          "package": "type-settheory",
          "partial": "PAIR",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Dummies.html#t:PAIR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePair of types of kind \u003ccode\u003e ((* -\u003e *) -\u003e *) \u003c/code\u003e\n\u003c/p\u003e",
          "module": "Type.Dummies",
          "name": "PAIR1",
          "package": "type-settheory",
          "source": "src/Type-Dummies.html#PAIR1",
          "type": "data"
        },
        "index": {
          "description": "Pair of types of kind",
          "hierarchy": "Type Dummies",
          "module": "Type.Dummies",
          "name": "PAIR1",
          "package": "type-settheory",
          "partial": "PAIR",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Dummies.html#t:PAIR1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePair of types of kind \u003ccode\u003e (((* -\u003e *) -\u003e *) -\u003e *) \u003c/code\u003e\n\u003c/p\u003e",
          "module": "Type.Dummies",
          "name": "PAIR2",
          "package": "type-settheory",
          "source": "src/Type-Dummies.html#PAIR2",
          "type": "data"
        },
        "index": {
          "description": "Pair of types of kind",
          "hierarchy": "Type Dummies",
          "module": "Type.Dummies",
          "name": "PAIR2",
          "package": "type-settheory",
          "partial": "PAIR",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Dummies.html#t:PAIR2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePair of types of kind \u003ccode\u003e ((((* -\u003e *) -\u003e *) -\u003e *) -\u003e *) \u003c/code\u003e\n\u003c/p\u003e",
          "module": "Type.Dummies",
          "name": "PAIR3",
          "package": "type-settheory",
          "source": "src/Type-Dummies.html#PAIR3",
          "type": "data"
        },
        "index": {
          "description": "Pair of types of kind",
          "hierarchy": "Type Dummies",
          "module": "Type.Dummies",
          "name": "PAIR3",
          "package": "type-settheory",
          "partial": "PAIR",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Dummies.html#t:PAIR3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Dummies",
          "name": "Bool0",
          "package": "type-settheory",
          "signature": "BOOL Bool0",
          "source": "src/Type-Dummies.html#BOOL",
          "type": "function"
        },
        "index": {
          "hierarchy": "Type Dummies",
          "module": "Type.Dummies",
          "name": "Bool0",
          "package": "type-settheory",
          "partial": "Bool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Dummies.html#v:Bool0"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Dummies",
          "name": "Bool1",
          "package": "type-settheory",
          "signature": "BOOL Bool1",
          "source": "src/Type-Dummies.html#BOOL",
          "type": "function"
        },
        "index": {
          "hierarchy": "Type Dummies",
          "module": "Type.Dummies",
          "name": "Bool1",
          "package": "type-settheory",
          "partial": "Bool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Dummies.html#v:Bool1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Dummies",
          "name": "Lower1Element",
          "package": "type-settheory",
          "signature": "u x -\u003e Lower2 u (Lower1 x)",
          "source": "src/Type-Dummies.html#Lower2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Type Dummies",
          "module": "Type.Dummies",
          "name": "Lower1Element",
          "normalized": "a b-\u003eLower a(Lower b)",
          "package": "type-settheory",
          "partial": "Lower Element",
          "signature": "u x-\u003eLower u(Lower x)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Dummies.html#v:Lower1Element"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Dummies",
          "name": "Lower2Element",
          "package": "type-settheory",
          "signature": "u x -\u003e Lower3 u (Lower2 x)",
          "source": "src/Type-Dummies.html#Lower3",
          "type": "function"
        },
        "index": {
          "hierarchy": "Type Dummies",
          "module": "Type.Dummies",
          "name": "Lower2Element",
          "normalized": "a b-\u003eLower a(Lower b)",
          "package": "type-settheory",
          "partial": "Lower Element",
          "signature": "u x-\u003eLower u(Lower x)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Dummies.html#v:Lower2Element"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Dummies",
          "name": "LowerElement",
          "package": "type-settheory",
          "signature": "u x -\u003e Lower1 u (Lower x)",
          "source": "src/Type-Dummies.html#Lower1",
          "type": "function"
        },
        "index": {
          "hierarchy": "Type Dummies",
          "module": "Type.Dummies",
          "name": "LowerElement",
          "normalized": "a b-\u003eLower a(Lower b)",
          "package": "type-settheory",
          "partial": "Lower Element",
          "signature": "u x-\u003eLower u(Lower x)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Dummies.html#v:LowerElement"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Dummies",
          "name": "elimBOOL",
          "package": "type-settheory",
          "signature": "BOOL a -\u003e r Bool0 -\u003e r Bool1 -\u003e r a",
          "source": "src/Type-Dummies.html#elimBOOL",
          "type": "function"
        },
        "index": {
          "hierarchy": "Type Dummies",
          "module": "Type.Dummies",
          "name": "elimBOOL",
          "normalized": "BOOL a-\u003eb Bool-\u003eb Bool-\u003eb a",
          "package": "type-settheory",
          "partial": "BOOL",
          "signature": "BOOL a-\u003er Bool-\u003er Bool-\u003er a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Dummies.html#v:elimBOOL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Dummies",
          "name": "kelimBOOL",
          "package": "type-settheory",
          "signature": "BOOL a -\u003e r -\u003e r -\u003e r",
          "source": "src/Type-Dummies.html#kelimBOOL",
          "type": "function"
        },
        "index": {
          "hierarchy": "Type Dummies",
          "module": "Type.Dummies",
          "name": "kelimBOOL",
          "normalized": "BOOL a-\u003eb-\u003eb-\u003eb",
          "package": "type-settheory",
          "partial": "BOOL",
          "signature": "BOOL a-\u003er-\u003er-\u003er",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Dummies.html#v:kelimBOOL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eNotes\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e Functions are coded as functional relations (in particular, functions are sets)\n\u003c/li\u003e\u003cli\u003e Extensional equality of functions coincedes with extensional equality of sets.\n\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e",
          "module": "Type.Function",
          "name": "Function",
          "package": "type-settheory",
          "source": "src/Type-Function.html",
          "type": "module"
        },
        "index": {
          "description": "Notes Functions are coded as functional relations in particular functions are sets Extensional equality of functions coincedes with extensional equality of sets",
          "hierarchy": "Type Function",
          "module": "Type.Function",
          "name": "Function",
          "package": "type-settheory",
          "partial": "Function",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eNB: \u003ccode\u003efam\u003c/code\u003e must be a function mapping some set to a set of sets, or the second condition in the constructor is vacuous\n\u003c/p\u003e",
          "module": "Type.Function",
          "name": "Π",
          "package": "type-settheory",
          "source": "src/Type-Function.html#%3A0",
          "type": "data"
        },
        "index": {
          "description": "NB fam must be function mapping some set to set of sets or the second condition in the constructor is vacuous",
          "hierarchy": "Type Function",
          "module": "Type.Function",
          "name": "Π",
          "package": "type-settheory",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#t:-928-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eKind-casted variant (function space as a set)\n\u003c/p\u003e\u003cp\u003eConvention: Instances of \u003ccode\u003e\u003ca\u003eFact\u003c/a\u003e\u003c/code\u003e should always prove \u003ccode\u003e\u003ca\u003e:~\u003e:\u003c/a\u003e\u003c/code\u003e rather than this type.\n\u003c/p\u003e",
          "module": "Type.Function",
          "name": ":~~\u003e:",
          "package": "type-settheory",
          "source": "src/Type-Function.html#%3A~~%3E%3A",
          "type": "type"
        },
        "index": {
          "description": "Kind-casted variant function space as set Convention Instances of Fact should always prove rather than this type",
          "hierarchy": "Type Function",
          "module": "Type.Function",
          "name": ":~~\u003e:",
          "package": "type-settheory",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#t::-126--126--62-:"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFunctions are encoded as functional relations; the three arguments to the construcor are:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e Is a relation\n\u003c/li\u003e\u003cli\u003e Totality\n\u003c/li\u003e\u003cli\u003e Single-valuedness (CPS-encoded; using \u003ccode\u003e\u003ca\u003e:=:\u003c/a\u003e\u003c/code\u003e would work just as well. I hope that the CPS variant makes the optimizer more happy, but this is pure speculation)\n\u003c/li\u003e\u003c/ul\u003e",
          "module": "Type.Function",
          "name": ":~\u003e:",
          "package": "type-settheory",
          "source": "src/Type-Function.html#%3A~%3E%3A",
          "type": "data"
        },
        "index": {
          "description": "Functions are encoded as functional relations the three arguments to the construcor are Is relation Totality Single-valuedness CPS-encoded using would work just as well hope that the CPS variant makes the optimizer more happy but this is pure speculation",
          "hierarchy": "Type Function",
          "module": "Type.Function",
          "name": ":~\u003e:",
          "package": "type-settheory",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#t::-126--62-:"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAnalogous to \u003ccode\u003e\u003ca\u003e***\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Type.Function",
          "name": ":***:",
          "package": "type-settheory",
          "source": "src/Type-Function.html#%3A%2A%2A%2A%3A",
          "type": "data"
        },
        "index": {
          "description": "Analogous to",
          "hierarchy": "Type Function",
          "module": "Type.Function",
          "name": ":***:",
          "package": "type-settheory",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#t::-42--42--42-:"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eComposition\n\u003c/p\u003e",
          "module": "Type.Function",
          "name": ":○:",
          "package": "type-settheory",
          "source": "src/Type-Function.html#%3A%25CB%3A",
          "type": "data"
        },
        "index": {
          "description": "Composition",
          "hierarchy": "Type Function",
          "module": "Type.Function",
          "name": ":○:",
          "package": "type-settheory",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#t::-9675-:"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGraph of a \u003ccode\u003e(* -\u003e * -\u003e *)\u003c/code\u003e type constructor\n\u003c/p\u003e",
          "module": "Type.Function",
          "name": "BiGraph",
          "package": "type-settheory",
          "source": "src/Type-Function.html#BiGraph",
          "type": "data"
        },
        "index": {
          "description": "Graph of type constructor",
          "hierarchy": "Type Function",
          "module": "Type.Function",
          "name": "BiGraph",
          "package": "type-settheory",
          "partial": "Bi Graph",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#t:BiGraph"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Function",
          "name": "Const",
          "package": "type-settheory",
          "source": "src/Type-Function.html#Const",
          "type": "data"
        },
        "index": {
          "hierarchy": "Type Function",
          "module": "Type.Function",
          "name": "Const",
          "package": "type-settheory",
          "partial": "Const",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#t:Const"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEqualisers :D\n\u003c/p\u003e\u003cp\u003eIn our category, the equaliser of two parallel functions \u003ccode\u003ef1\u003c/code\u003e and \u003ccode\u003ef2\u003c/code\u003e is the set of types on which \u003ccode\u003ef1\u003c/code\u003e and \u003ccode\u003ef2\u003c/code\u003e agree; that is:\n\u003c/p\u003e\u003cp\u003e\u003cem\u003eEqualiser f1 f2 = { x | f1 x = f2 x }\u003c/em\u003e\n\u003c/p\u003e",
          "module": "Type.Function",
          "name": "Equaliser",
          "package": "type-settheory",
          "source": "src/Type-Function.html#Equaliser",
          "type": "data"
        },
        "index": {
          "description": "Equalisers In our category the equaliser of two parallel functions f1 and f2 is the set of types on which f1 and f2 agree that is Equaliser f1 f2 f1 f2",
          "hierarchy": "Type Function",
          "module": "Type.Function",
          "name": "Equaliser",
          "package": "type-settheory",
          "partial": "Equaliser",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#t:Equaliser"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInclusion of the equaliser into the domain of the parallel functions\n\u003c/p\u003e",
          "module": "Type.Function",
          "name": "EqualiserIncl",
          "package": "type-settheory",
          "source": "src/Type-Function.html#EqualiserIncl",
          "type": "type"
        },
        "index": {
          "description": "Inclusion of the equaliser into the domain of the parallel functions",
          "hierarchy": "Type Function",
          "module": "Type.Function",
          "name": "EqualiserIncl",
          "package": "type-settheory",
          "partial": "Equaliser Incl",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#t:EqualiserIncl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExistential quantification over the first component of a pair\n\u003c/p\u003e",
          "module": "Type.Function",
          "name": "ExSnd",
          "package": "type-settheory",
          "source": "src/Type-Function.html#ExSnd",
          "type": "data"
        },
        "index": {
          "description": "Existential quantification over the first component of pair",
          "hierarchy": "Type Function",
          "module": "Type.Function",
          "name": "ExSnd",
          "package": "type-settheory",
          "partial": "Ex Snd",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#t:ExSnd"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Function",
          "name": "Fst",
          "package": "type-settheory",
          "source": "src/Type-Function.html#Fst",
          "type": "data"
        },
        "index": {
          "hierarchy": "Type Function",
          "module": "Type.Function",
          "name": "Fst",
          "package": "type-settheory",
          "partial": "Fst",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#t:Fst"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGraph of a \u003ccode\u003e(* -\u003e *)\u003c/code\u003e type constructor\n\u003c/p\u003e",
          "module": "Type.Function",
          "name": "Graph",
          "package": "type-settheory",
          "source": "src/Type-Function.html#Graph",
          "type": "data"
        },
        "index": {
          "description": "Graph of type constructor",
          "hierarchy": "Type Function",
          "module": "Type.Function",
          "name": "Graph",
          "package": "type-settheory",
          "partial": "Graph",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#t:Graph"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe type-level function:\n\u003c/p\u003e\u003cp\u003e\u003cem\u003eHaskFun(a,b) = (a -\u003e b)\u003c/em\u003e\n\u003c/p\u003e",
          "module": "Type.Function",
          "name": "HaskFun",
          "package": "type-settheory",
          "source": "src/Type-Function.html#HaskFun",
          "type": "data"
        },
        "index": {
          "description": "The type-level function HaskFun",
          "hierarchy": "Type Function",
          "module": "Type.Function",
          "name": "HaskFun",
          "package": "type-settheory",
          "partial": "Hask Fun",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#t:HaskFun"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIdentity function on \u003ccode\u003edom\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Type.Function",
          "name": "Id",
          "package": "type-settheory",
          "source": "src/Type-Function.html#Id",
          "type": "type"
        },
        "index": {
          "description": "Identity function on dom",
          "hierarchy": "Type Function",
          "module": "Type.Function",
          "name": "Id",
          "package": "type-settheory",
          "partial": "Id",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#t:Id"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eImage of a set under the function\n\u003c/p\u003e",
          "module": "Type.Function",
          "name": "Image",
          "package": "type-settheory",
          "source": "src/Type-Function.html#Image",
          "type": "data"
        },
        "index": {
          "description": "Image of set under the function",
          "hierarchy": "Type Function",
          "module": "Type.Function",
          "name": "Image",
          "package": "type-settheory",
          "partial": "Image",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#t:Image"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInclusion function of a subset\n\u003c/p\u003e\u003cp\u003eInclusions \u003cem\u003edo\u003c/em\u003e know their codomain (somewhat arbitrary design decision)\n\u003c/p\u003e",
          "module": "Type.Function",
          "name": "Incl",
          "package": "type-settheory",
          "source": "src/Type-Function.html#Incl",
          "type": "data"
        },
        "index": {
          "description": "Inclusion function of subset Inclusions do know their codomain somewhat arbitrary design decision",
          "hierarchy": "Type Function",
          "module": "Type.Function",
          "name": "Incl",
          "package": "type-settheory",
          "partial": "Incl",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#t:Incl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInjective functions\n\u003c/p\u003e\u003cp\u003e(NB: Surjectivity is meaningless here because our functions don't know their codomain, but we have \u003ccode\u003e\u003ca\u003eImage\u003c/a\u003e\u003c/code\u003e)\n\u003c/p\u003e",
          "module": "Type.Function",
          "name": "Injective",
          "package": "type-settheory",
          "source": "src/Type-Function.html#Injective",
          "type": "data"
        },
        "index": {
          "description": "Injective functions NB Surjectivity is meaningless here because our functions don know their codomain but we have Image",
          "hierarchy": "Type Function",
          "module": "Type.Function",
          "name": "Injective",
          "package": "type-settheory",
          "partial": "Injective",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#t:Injective"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Function",
          "name": "Inv",
          "package": "type-settheory",
          "source": "src/Type-Function.html#Inv",
          "type": "data"
        },
        "index": {
          "hierarchy": "Type Function",
          "module": "Type.Function",
          "name": "Inv",
          "package": "type-settheory",
          "partial": "Inv",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#t:Inv"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe type-level function:\n\u003c/p\u003e\u003cp\u003e\u003cem\u003eKleisliHom(a,b) = (a -\u003e m b)\u003c/em\u003e\n\u003c/p\u003e",
          "module": "Type.Function",
          "name": "KleisliHom",
          "package": "type-settheory",
          "source": "src/Type-Function.html#KleisliHom",
          "type": "data"
        },
        "index": {
          "description": "The type-level function KleisliHom",
          "hierarchy": "Type Function",
          "module": "Type.Function",
          "name": "KleisliHom",
          "package": "type-settheory",
          "partial": "Kleisli Hom",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#t:KleisliHom"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Function",
          "name": "Preimage",
          "package": "type-settheory",
          "source": "src/Type-Function.html#Preimage",
          "type": "data"
        },
        "index": {
          "hierarchy": "Type Function",
          "module": "Type.Function",
          "name": "Preimage",
          "package": "type-settheory",
          "partial": "Preimage",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#t:Preimage"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExpresses that \u003ccode\u003ef\u003c/code\u003e is a section of \u003ccode\u003ebundleMap\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Type.Function",
          "name": "Section",
          "package": "type-settheory",
          "source": "src/Type-Function.html#Section",
          "type": "data"
        },
        "index": {
          "description": "Expresses that is section of bundleMap",
          "hierarchy": "Type Function",
          "module": "Type.Function",
          "name": "Section",
          "package": "type-settheory",
          "partial": "Section",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#t:Section"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Function",
          "name": "Snd",
          "package": "type-settheory",
          "source": "src/Type-Function.html#Snd",
          "type": "data"
        },
        "index": {
          "hierarchy": "Type Function",
          "module": "Type.Function",
          "name": "Snd",
          "package": "type-settheory",
          "partial": "Snd",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#t:Snd"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSingle-valuedness (CPS)\n\u003c/p\u003e",
          "module": "Type.Function",
          "name": "Sval",
          "package": "type-settheory",
          "source": "src/Type-Function.html#Sval",
          "type": "type"
        },
        "index": {
          "description": "Single-valuedness CPS",
          "hierarchy": "Type Function",
          "module": "Type.Function",
          "name": "Sval",
          "package": "type-settheory",
          "partial": "Sval",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#t:Sval"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Function",
          "name": "ToTyCon",
          "package": "type-settheory",
          "source": "src/Type-Function.html#ToTyCon",
          "type": "data"
        },
        "index": {
          "hierarchy": "Type Function",
          "module": "Type.Function",
          "name": "ToTyCon",
          "package": "type-settheory",
          "partial": "To Ty Con",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#t:ToTyCon"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTotality\n\u003c/p\u003e",
          "module": "Type.Function",
          "name": "Total",
          "package": "type-settheory",
          "source": "src/Type-Function.html#Total",
          "type": "type"
        },
        "index": {
          "description": "Totality",
          "hierarchy": "Type Function",
          "module": "Type.Function",
          "name": "Total",
          "package": "type-settheory",
          "partial": "Total",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#t:Total"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Function",
          "name": "Π",
          "package": "type-settheory",
          "signature": "(base :~\u003e: Unions fam) f -\u003e (forall x y s.  ((x, y) :∈: f) -\u003e ((x, Lower s) :∈: fam) -\u003e x :∈: s) -\u003e Π fam f",
          "source": "src/Type-Function.html#%3A0",
          "type": "function"
        },
        "index": {
          "hierarchy": "Type Function",
          "module": "Type.Function",
          "name": "Π",
          "normalized": "(a Unions b)c-\u003e(d e f g((e,f)c)-\u003e((e,Lower h)b)-\u003ee h)-\u003eΠ b c",
          "package": "type-settheory",
          "signature": "(base Unions fam)f-\u003e(forall x y s.((x,y)f)-\u003e((x,Lower s)fam)-\u003ex s)-\u003eΠ fam f",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#v:-928-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Function",
          "name": ":***:",
          "package": "type-settheory",
          "signature": "((,) a b1 :∈: f1) -\u003e ((,) a b2 :∈: f2) -\u003e (f1 :***: f2) (a, (,) b1 b2)",
          "source": "src/Type-Function.html#%3A%2A%2A%2A%3A",
          "type": "function"
        },
        "index": {
          "hierarchy": "Type Function",
          "module": "Type.Function",
          "name": ":***:",
          "normalized": "((,)a b c)-\u003e((,)a b c)-\u003e(c***c)(a,(,)b b)",
          "package": "type-settheory",
          "signature": "((,)a b f)-\u003e((,)a b f)-\u003e(f***f)(a,(,)b b)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#v::-42--42--42-:"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Function",
          "name": "BiGraph",
          "package": "type-settheory",
          "signature": "BiGraph f ((a, b), f a b)",
          "source": "src/Type-Function.html#BiGraph",
          "type": "function"
        },
        "index": {
          "hierarchy": "Type Function",
          "module": "Type.Function",
          "name": "BiGraph",
          "normalized": "BiGraph a((b,c),a b c)",
          "package": "type-settheory",
          "partial": "Bi Graph",
          "signature": "BiGraph f((a,b),f a b)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#v:BiGraph"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Function",
          "name": "Compo",
          "package": "type-settheory",
          "signature": "((b, c) :∈: g) -\u003e ((a, b) :∈: f) -\u003e (g :○: f) (a, c)",
          "source": "src/Type-Function.html#%3A%25CB%3A",
          "type": "function"
        },
        "index": {
          "hierarchy": "Type Function",
          "module": "Type.Function",
          "name": "Compo",
          "normalized": "((a,b)c)-\u003e((d,a)e)-\u003e(c e)(d,b)",
          "package": "type-settheory",
          "partial": "Compo",
          "signature": "((b,c)g)-\u003e((a,b)f)-\u003e(g f)(a,c)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#v:Compo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Function",
          "name": "Const",
          "package": "type-settheory",
          "signature": "(a :∈: dom) -\u003e Const dom x (a, x)",
          "source": "src/Type-Function.html#Const",
          "type": "function"
        },
        "index": {
          "hierarchy": "Type Function",
          "module": "Type.Function",
          "name": "Const",
          "normalized": "(a b)-\u003eConst b c(a,c)",
          "package": "type-settheory",
          "partial": "Const",
          "signature": "(a dom)-\u003eConst dom x(a,x)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#v:Const"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Function",
          "name": "Equaliser",
          "package": "type-settheory",
          "signature": "((a, b) :∈: f1) -\u003e ((a, b) :∈: f2) -\u003e Equaliser f1 f2 a",
          "source": "src/Type-Function.html#Equaliser",
          "type": "function"
        },
        "index": {
          "hierarchy": "Type Function",
          "module": "Type.Function",
          "name": "Equaliser",
          "normalized": "((a,b)c)-\u003e((a,b)c)-\u003eEqualiser c c a",
          "package": "type-settheory",
          "partial": "Equaliser",
          "signature": "((a,b)f)-\u003e((a,b)f)-\u003eEqualiser f f a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#v:Equaliser"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Function",
          "name": "ExSnd",
          "package": "type-settheory",
          "signature": "((a, ex) :∈: f) -\u003e ExSnd f a",
          "source": "src/Type-Function.html#ExSnd",
          "type": "function"
        },
        "index": {
          "hierarchy": "Type Function",
          "module": "Type.Function",
          "name": "ExSnd",
          "normalized": "((a,b)c)-\u003eExSnd c a",
          "package": "type-settheory",
          "partial": "Ex Snd",
          "signature": "((a,ex)f)-\u003eExSnd f a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#v:ExSnd"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Function",
          "name": "Fst",
          "package": "type-settheory",
          "signature": "(a :∈: s1) -\u003e (b :∈: s2) -\u003e Fst s1 s2 ((,) ((,) a b) a)",
          "source": "src/Type-Function.html#Fst",
          "type": "function"
        },
        "index": {
          "hierarchy": "Type Function",
          "module": "Type.Function",
          "name": "Fst",
          "normalized": "(a b)-\u003e(c b)-\u003eFst b b((,)((,)a c)a)",
          "package": "type-settheory",
          "partial": "Fst",
          "signature": "(a s)-\u003e(b s)-\u003eFst s s((,)((,)a b)a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#v:Fst"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Function",
          "name": "Graph",
          "package": "type-settheory",
          "signature": "Graph f (a, f a)",
          "source": "src/Type-Function.html#Graph",
          "type": "function"
        },
        "index": {
          "hierarchy": "Type Function",
          "module": "Type.Function",
          "name": "Graph",
          "normalized": "Graph a(b,a b)",
          "package": "type-settheory",
          "partial": "Graph",
          "signature": "Graph f(a,f a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#v:Graph"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Function",
          "name": "HaskFun",
          "package": "type-settheory",
          "signature": "HaskFun ((,) ((,) a b) (a -\u003e b))",
          "source": "src/Type-Function.html#HaskFun",
          "type": "function"
        },
        "index": {
          "hierarchy": "Type Function",
          "module": "Type.Function",
          "name": "HaskFun",
          "normalized": "HaskFun((,)((,)a b)(a-\u003eb))",
          "package": "type-settheory",
          "partial": "Hask Fun",
          "signature": "HaskFun((,)((,)a b)(a-\u003eb))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#v:HaskFun"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Function",
          "name": "Image",
          "package": "type-settheory",
          "signature": "(a :∈: s) -\u003e ((a, b) :∈: f) -\u003e Image f s b",
          "source": "src/Type-Function.html#Image",
          "type": "function"
        },
        "index": {
          "hierarchy": "Type Function",
          "module": "Type.Function",
          "name": "Image",
          "normalized": "(a b)-\u003e((a,c)d)-\u003eImage d b c",
          "package": "type-settheory",
          "partial": "Image",
          "signature": "(a s)-\u003e((a,b)f)-\u003eImage f s b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#v:Image"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Function",
          "name": "Incl",
          "package": "type-settheory",
          "signature": "dom a -\u003e Incl dom cod (a, a)",
          "source": "src/Type-Function.html#Incl",
          "type": "function"
        },
        "index": {
          "hierarchy": "Type Function",
          "module": "Type.Function",
          "name": "Incl",
          "normalized": "a b-\u003eIncl a c(b,b)",
          "package": "type-settheory",
          "partial": "Incl",
          "signature": "dom a-\u003eIncl dom cod(a,a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#v:Incl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Function",
          "name": "Injective",
          "package": "type-settheory",
          "signature": "r) -\u003e r) -\u003e Injective f",
          "source": "src/Type-Function.html#Injective",
          "type": "function"
        },
        "index": {
          "hierarchy": "Type Function",
          "module": "Type.Function",
          "name": "Injective",
          "normalized": "a)-\u003ea)-\u003eInjective b",
          "package": "type-settheory",
          "partial": "Injective",
          "signature": "r)-\u003er)-\u003eInjective f",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#v:Injective"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Function",
          "name": "Inv",
          "package": "type-settheory",
          "signature": "((a, b) :∈: f) -\u003e Inv f (b, a)",
          "source": "src/Type-Function.html#Inv",
          "type": "function"
        },
        "index": {
          "hierarchy": "Type Function",
          "module": "Type.Function",
          "name": "Inv",
          "normalized": "((a,b)c)-\u003eInv c(b,a)",
          "package": "type-settheory",
          "partial": "Inv",
          "signature": "((a,b)f)-\u003eInv f(b,a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#v:Inv"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Function",
          "name": "IsFun",
          "package": "type-settheory",
          "signature": "(f :⊆: (dom :×: cod)) -\u003e Total dom f -\u003e Sval f -\u003e (dom :~\u003e: cod) f",
          "source": "src/Type-Function.html#%3A~%3E%3A",
          "type": "function"
        },
        "index": {
          "hierarchy": "Type Function",
          "module": "Type.Function",
          "name": "IsFun",
          "normalized": "(a(b c))-\u003eTotal b a-\u003eSval a-\u003e(b c)a",
          "package": "type-settheory",
          "partial": "Is Fun",
          "signature": "(f(dom cod))-\u003eTotal dom f-\u003eSval f-\u003e(dom cod)f",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#v:IsFun"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Function",
          "name": "KleisliHom",
          "package": "type-settheory",
          "signature": "KleisliHom m ((,) ((,) a b) (a -\u003e m b))",
          "source": "src/Type-Function.html#KleisliHom",
          "type": "function"
        },
        "index": {
          "hierarchy": "Type Function",
          "module": "Type.Function",
          "name": "KleisliHom",
          "normalized": "KleisliHom a((,)((,)b c)(b-\u003ea c))",
          "package": "type-settheory",
          "partial": "Kleisli Hom",
          "signature": "KleisliHom m((,)((,)a b)(a-\u003em b))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#v:KleisliHom"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Function",
          "name": "Preimage",
          "package": "type-settheory",
          "signature": "((a, b) :∈: f) -\u003e (b :∈: s) -\u003e Preimage f s a",
          "source": "src/Type-Function.html#Preimage",
          "type": "function"
        },
        "index": {
          "hierarchy": "Type Function",
          "module": "Type.Function",
          "name": "Preimage",
          "normalized": "((a,b)c)-\u003e(b d)-\u003ePreimage c d a",
          "package": "type-settheory",
          "partial": "Preimage",
          "signature": "((a,b)f)-\u003e(b s)-\u003ePreimage f s a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#v:Preimage"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Function",
          "name": "Section",
          "package": "type-settheory",
          "signature": "(forall x y.  ((x, y) :∈: f) -\u003e (y, x) :∈: bundleMap) -\u003e Section bundleMap f",
          "source": "src/Type-Function.html#Section",
          "type": "function"
        },
        "index": {
          "hierarchy": "Type Function",
          "module": "Type.Function",
          "name": "Section",
          "normalized": "(a b c((b,d)e)-\u003e(d,b)f)-\u003eSection f e",
          "package": "type-settheory",
          "partial": "Section",
          "signature": "(forall x y.((x,y)f)-\u003e(y,x)bundleMap)-\u003eSection bundleMap f",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#v:Section"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Function",
          "name": "Snd",
          "package": "type-settheory",
          "signature": "(a :∈: s1) -\u003e (b :∈: s2) -\u003e Snd s1 s2 ((,) ((,) a b) b)",
          "source": "src/Type-Function.html#Snd",
          "type": "function"
        },
        "index": {
          "hierarchy": "Type Function",
          "module": "Type.Function",
          "name": "Snd",
          "normalized": "(a b)-\u003e(c b)-\u003eSnd b b((,)((,)a c)c)",
          "package": "type-settheory",
          "partial": "Snd",
          "signature": "(a s)-\u003e(b s)-\u003eSnd s s((,)((,)a b)b)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#v:Snd"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Function",
          "name": "ToTyCon",
          "package": "type-settheory",
          "signature": "forall y . ToTyCon ((x, y) :∈: f) y",
          "source": "src/Type-Function.html#ToTyCon",
          "type": "function"
        },
        "index": {
          "hierarchy": "Type Function",
          "module": "Type.Function",
          "name": "ToTyCon",
          "normalized": "a b ToTyCon((c,b)d)b",
          "package": "type-settheory",
          "partial": "To Ty Con",
          "signature": "forall y ToTyCon((x,y)f)y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#v:ToTyCon"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eChange the codomain by proving that the full image is included in the new codomain\n\u003c/p\u003e",
          "module": "Type.Function",
          "name": "adjustCod",
          "package": "type-settheory",
          "signature": "(dom :~\u003e: cod) f -\u003e (Image f dom :⊆: cod') -\u003e (dom :~\u003e: cod') f",
          "source": "src/Type-Function.html#adjustCod",
          "type": "function"
        },
        "index": {
          "description": "Change the codomain by proving that the full image is included in the new codomain",
          "hierarchy": "Type Function",
          "module": "Type.Function",
          "name": "adjustCod",
          "normalized": "(a b)c-\u003e(Image c a d)-\u003e(a d)c",
          "package": "type-settheory",
          "partial": "Cod",
          "signature": "(dom cod)f-\u003e(Image f dom cod')-\u003e(dom cod')f",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#v:adjustCod"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eType constructors are injective\n\u003c/p\u003e",
          "module": "Type.Function",
          "name": "biGraphInjective",
          "package": "type-settheory",
          "signature": "Injective (BiGraph f)",
          "source": "src/Type-Function.html#biGraphInjective",
          "type": "function"
        },
        "index": {
          "description": "Type constructors are injective",
          "hierarchy": "Type Function",
          "module": "Type.Function",
          "name": "biGraphInjective",
          "package": "type-settheory",
          "partial": "Graph Injective",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#v:biGraphInjective"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Function",
          "name": "biGraphIsFun",
          "package": "type-settheory",
          "signature": "((Univ :×: Univ) :~\u003e: Univ) (BiGraph f)",
          "source": "src/Type-Function.html#biGraphIsFun",
          "type": "function"
        },
        "index": {
          "hierarchy": "Type Function",
          "module": "Type.Function",
          "name": "biGraphIsFun",
          "package": "type-settheory",
          "partial": "Graph Is Fun",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#v:biGraphIsFun"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExample of an extensional equation between functions\n\u003c/p\u003e",
          "module": "Type.Function",
          "name": "biGraph_eq_HaskFun",
          "package": "type-settheory",
          "signature": "BiGraph (-\u003e) :==: HaskFun",
          "source": "src/Type-Function.html#biGraph_eq_HaskFun",
          "type": "function"
        },
        "index": {
          "description": "Example of an extensional equation between functions",
          "hierarchy": "Type Function",
          "module": "Type.Function",
          "name": "biGraph_eq_HaskFun",
          "normalized": "BiGraph(-\u003e)HaskFun",
          "package": "type-settheory",
          "partial": "Graph Hask Fun",
          "signature": "BiGraph(-\u003e)HaskFun",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#v:biGraph_eq_HaskFun"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eComposition is \u003cem\u003eid\u003c/em\u003e ==\u003e is section\n\u003c/p\u003e",
          "module": "Type.Function",
          "name": "compoId_Section",
          "package": "type-settheory",
          "signature": "(total :~\u003e: base) bun -\u003e (base :~\u003e: total) f -\u003e ((bun :○: f) :==: Id base) -\u003e Section bun f",
          "source": "src/Type-Function.html#compoId_Section",
          "type": "function"
        },
        "index": {
          "description": "Composition is id is section",
          "hierarchy": "Type Function",
          "module": "Type.Function",
          "name": "compoId_Section",
          "normalized": "(a b)c-\u003e(b a)d-\u003e((c d)Id b)-\u003eSection c d",
          "package": "type-settheory",
          "partial": "Id Section",
          "signature": "(total base)bun-\u003e(base total)f-\u003e((bun f)Id base)-\u003eSection bun f",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#v:compoId_Section"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe composition is a function\n\u003c/p\u003e",
          "module": "Type.Function",
          "name": "compoIsFun",
          "package": "type-settheory",
          "signature": "(s2 :~\u003e: s3) g -\u003e (s1 :~\u003e: s2) f -\u003e (s1 :~\u003e: s3) (g :○: f)",
          "source": "src/Type-Function.html#compoIsFun",
          "type": "function"
        },
        "index": {
          "description": "The composition is function",
          "hierarchy": "Type Function",
          "module": "Type.Function",
          "name": "compoIsFun",
          "normalized": "(a a)b-\u003e(a a)c-\u003e(a a)(b c)",
          "package": "type-settheory",
          "partial": "Is Fun",
          "signature": "(s s)g-\u003e(s s)f-\u003e(s s)(g f)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#v:compoIsFun"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Function",
          "name": "compo_assoc",
          "package": "type-settheory",
          "signature": ":~\u003e: s2 cod g -\u003e :~\u003e: s21 s2 f -\u003e :~\u003e: dom s21 f1 -\u003e ((g :○: f) :○: f1) :==: (g :○: (f :○: f1))",
          "source": "src/Type-Function.html#compo_assoc",
          "type": "function"
        },
        "index": {
          "hierarchy": "Type Function",
          "module": "Type.Function",
          "name": "compo_assoc",
          "normalized": "a b c-\u003ea a d-\u003ee a d-\u003e((c d)d)(c(d d))",
          "package": "type-settheory",
          "signature": "s cod g-\u003es s f-\u003edom s f-\u003e((g f)f)(g(f f))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#v:compo_assoc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eId\u003c/a\u003e\u003c/code\u003e is a left identity for composition                            \n\u003c/p\u003e",
          "module": "Type.Function",
          "name": "compo_idl",
          "package": "type-settheory",
          "signature": "(d :~\u003e: c) f -\u003e (Id c :○: f) :==: f",
          "source": "src/Type-Function.html#compo_idl",
          "type": "function"
        },
        "index": {
          "description": "Id is left identity for composition",
          "hierarchy": "Type Function",
          "module": "Type.Function",
          "name": "compo_idl",
          "normalized": "(a b)c-\u003e(Id b c)c",
          "package": "type-settheory",
          "signature": "(d c)f-\u003e(Id c f)f",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#v:compo_idl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eId\u003c/a\u003e\u003c/code\u003e is a right identity for composition                       \n\u003c/p\u003e",
          "module": "Type.Function",
          "name": "compo_idr",
          "package": "type-settheory",
          "signature": "(d :~\u003e: c) f -\u003e (f :○: Id d) :==: f",
          "source": "src/Type-Function.html#compo_idr",
          "type": "function"
        },
        "index": {
          "description": "Id is right identity for composition",
          "hierarchy": "Type Function",
          "module": "Type.Function",
          "name": "compo_idr",
          "normalized": "(a b)c-\u003e(c Id a)c",
          "package": "type-settheory",
          "signature": "(d c)f-\u003e(f Id d)f",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#v:compo_idr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Function",
          "name": "constEq",
          "package": "type-settheory",
          "signature": "Ex dom -\u003e (Const dom x :==: Const dom' x') -\u003e x :=: x'",
          "source": "src/Type-Function.html#constEq",
          "type": "function"
        },
        "index": {
          "hierarchy": "Type Function",
          "module": "Type.Function",
          "name": "constEq",
          "normalized": "Ex a-\u003e(Const a b Const c d)-\u003eb d",
          "package": "type-settheory",
          "partial": "Eq",
          "signature": "Ex dom-\u003e(Const dom x Const dom' x')-\u003ex x'",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#v:constEq"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Function",
          "name": "constIsFun",
          "package": "type-settheory",
          "signature": "(x :∈: cod) -\u003e (dom :~\u003e: cod) (Const dom x)",
          "source": "src/Type-Function.html#constIsFun",
          "type": "function"
        },
        "index": {
          "hierarchy": "Type Function",
          "module": "Type.Function",
          "name": "constIsFun",
          "normalized": "(a b)-\u003e(c b)(Const c a)",
          "package": "type-settheory",
          "partial": "Is Fun",
          "signature": "(x cod)-\u003e(dom cod)(Const dom x)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#v:constIsFun"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe domain of a function is uniquely determined\n\u003c/p\u003e",
          "module": "Type.Function",
          "name": "domUniq",
          "package": "type-settheory",
          "signature": "(dom :~\u003e: cod) f -\u003e (dom2 :~\u003e: cod) f -\u003e dom :==: dom2",
          "source": "src/Type-Function.html#domUniq",
          "type": "function"
        },
        "index": {
          "description": "The domain of function is uniquely determined",
          "hierarchy": "Type Function",
          "module": "Type.Function",
          "name": "domUniq",
          "normalized": "(a b)c-\u003e(a b)c-\u003ea a",
          "package": "type-settheory",
          "partial": "Uniq",
          "signature": "(dom cod)f-\u003e(dom cod)f-\u003edom dom",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#v:domUniq"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eNB: this is stronger than the straightforward unpacking function -- we can use the single-valuedness\n\u003c/p\u003e",
          "module": "Type.Function",
          "name": "elimToTyCon",
          "package": "type-settheory",
          "signature": "(dom :~\u003e: cod) f -\u003e ToTyCon f x -\u003e ((x, z) :∈: f) -\u003e z",
          "source": "src/Type-Function.html#elimToTyCon",
          "type": "function"
        },
        "index": {
          "description": "NB this is stronger than the straightforward unpacking function we can use the single-valuedness",
          "hierarchy": "Type Function",
          "module": "Type.Function",
          "name": "elimToTyCon",
          "normalized": "(a b)c-\u003eToTyCon c d-\u003e((d,e)c)-\u003ee",
          "package": "type-settheory",
          "partial": "To Ty Con",
          "signature": "(dom cod)f-\u003eToTyCon f x-\u003e((x,z)f)-\u003ez",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#v:elimToTyCon"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExpresses the fact that \u003cem\u003ef = f' ==\u003e f x = f' x\u003c/em\u003e\n\u003c/p\u003e",
          "module": "Type.Function",
          "name": "equal_f",
          "package": "type-settheory",
          "signature": "(d :~\u003e: c) f' -\u003e (f :==: f') -\u003e ((x, y) :∈: f) -\u003e ((x, y') :∈: f') -\u003e y :=: y'",
          "source": "src/Type-Function.html#equal_f",
          "type": "function"
        },
        "index": {
          "description": "Expresses the fact that",
          "hierarchy": "Type Function",
          "module": "Type.Function",
          "name": "equal_f",
          "normalized": "(a b)c-\u003e(d c)-\u003e((e,f)d)-\u003e((e,g)c)-\u003ef g",
          "package": "type-settheory",
          "signature": "(d c)f'-\u003e(f f')-\u003e((x,y)f)-\u003e((x,y')f')-\u003ey y'",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#v:equal_f"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePerform coercion using a function equality\n\u003c/p\u003e",
          "module": "Type.Function",
          "name": "equal_f_coerce",
          "package": "type-settheory",
          "signature": "(d :~\u003e: c) f' -\u003e (f :==: f') -\u003e ((x, y) :∈: f) -\u003e ((x, y') :∈: f') -\u003e y -\u003e y'",
          "source": "src/Type-Function.html#equal_f_coerce",
          "type": "function"
        },
        "index": {
          "description": "Perform coercion using function equality",
          "hierarchy": "Type Function",
          "module": "Type.Function",
          "name": "equal_f_coerce",
          "normalized": "(a b)c-\u003e(d c)-\u003e((e,f)d)-\u003e((e,g)c)-\u003ef-\u003eg",
          "package": "type-settheory",
          "signature": "(d c)f'-\u003e(f f')-\u003e((x,y)f)-\u003e((x,y')f')-\u003ey-\u003ey'",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#v:equal_f_coerce"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe equaliser inclusion is a function\n\u003c/p\u003e",
          "module": "Type.Function",
          "name": "equaliserIsFun",
          "package": "type-settheory",
          "signature": "(s :~\u003e: t) f1 -\u003e (Equaliser f1 f2 :~\u003e: s) (EqualiserIncl s f1 f2)",
          "source": "src/Type-Function.html#equaliserIsFun",
          "type": "function"
        },
        "index": {
          "description": "The equaliser inclusion is function",
          "hierarchy": "Type Function",
          "module": "Type.Function",
          "name": "equaliserIsFun",
          "normalized": "(a b)c-\u003e(Equaliser c c a)(EqualiserIncl a c c)",
          "package": "type-settheory",
          "partial": "Is Fun",
          "signature": "(s t)f-\u003e(Equaliser f f s)(EqualiserIncl s f f)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#v:equaliserIsFun"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe equaliser is a subset of the domain of the parallel functions \n\u003c/p\u003e",
          "module": "Type.Function",
          "name": "equaliserSubset",
          "package": "type-settheory",
          "signature": "(s :~\u003e: t) f1 -\u003e Equaliser f1 f2 :⊆: s",
          "source": "src/Type-Function.html#equaliserSubset",
          "type": "function"
        },
        "index": {
          "description": "The equaliser is subset of the domain of the parallel functions",
          "hierarchy": "Type Function",
          "module": "Type.Function",
          "name": "equaliserSubset",
          "normalized": "(a b)c-\u003eEqualiser c c a",
          "package": "type-settheory",
          "partial": "Subset",
          "signature": "(s t)f-\u003eEqualiser f f s",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#v:equaliserSubset"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUniversal property of equalisers:\n\u003c/p\u003e\u003cp\u003e\u003ccode\u003ef1 . g = f2 . g\u003c/code\u003e ==\u003e \u003ccode\u003eg\u003c/code\u003e factors uniquely through \u003ccode\u003eEqualiser f1 f2\u003c/code\u003e\n\u003c/p\u003e\u003cp\u003eUniqueness is trivial in our case because the function into the equaliser is\n identical to \u003ccode\u003eg\u003c/code\u003e (our functions don't know their codomain)\n\u003c/p\u003e",
          "module": "Type.Function",
          "name": "equaliserUni",
          "package": "type-settheory",
          "signature": "(s0 :~\u003e: s) g -\u003e (s :~\u003e: t) f1 -\u003e ((f1 :○: g) :==: (f2 :○: g)) -\u003e (s0 :~\u003e: Equaliser f1 f2) g",
          "source": "src/Type-Function.html#equaliserUni",
          "type": "function"
        },
        "index": {
          "description": "Universal property of equalisers f1 f2 factors uniquely through Equaliser f1 f2 Uniqueness is trivial in our case because the function into the equaliser is identical to our functions don know their codomain",
          "hierarchy": "Type Function",
          "module": "Type.Function",
          "name": "equaliserUni",
          "normalized": "(a a)b-\u003e(a c)d-\u003e((d b)(d b))-\u003e(a Equaliser d d)b",
          "package": "type-settheory",
          "partial": "Uni",
          "signature": "(s s)g-\u003e(s t)f-\u003e((f g)(f g))-\u003e(s Equaliser f f)g",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#v:equaliserUni"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEnlargen the codomain\n\u003c/p\u003e",
          "module": "Type.Function",
          "name": "extendCod",
          "package": "type-settheory",
          "signature": "(dom :~\u003e: cod) f -\u003e (cod :⊆: cod') -\u003e (dom :~\u003e: cod') f",
          "source": "src/Type-Function.html#extendCod",
          "type": "function"
        },
        "index": {
          "description": "Enlargen the codomain",
          "hierarchy": "Type Function",
          "module": "Type.Function",
          "name": "extendCod",
          "normalized": "(a b)c-\u003e(b d)-\u003e(a d)c",
          "package": "type-settheory",
          "partial": "Cod",
          "signature": "(dom cod)f-\u003e(cod cod')-\u003e(dom cod')f",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#v:extendCod"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Function",
          "name": "fromTCG",
          "package": "type-settheory",
          "signature": "ToTyCon (Graph f) x -\u003e f x",
          "source": "src/Type-Function.html#fromTCG",
          "type": "function"
        },
        "index": {
          "hierarchy": "Type Function",
          "module": "Type.Function",
          "name": "fromTCG",
          "normalized": "ToTyCon(Graph a)b-\u003ea b",
          "package": "type-settheory",
          "partial": "TCG",
          "signature": "ToTyCon(Graph f)x-\u003ef x",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#v:fromTCG"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Function",
          "name": "fstIsFun",
          "package": "type-settheory",
          "signature": "((s1 :×: s2) :~\u003e: s1) (Fst s1 s2)",
          "source": "src/Type-Function.html#fstIsFun",
          "type": "function"
        },
        "index": {
          "hierarchy": "Type Function",
          "module": "Type.Function",
          "name": "fstIsFun",
          "package": "type-settheory",
          "partial": "Is Fun",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#v:fstIsFun"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Function",
          "name": "fst_tupling",
          "package": "type-settheory",
          "signature": "(dom :~\u003e: cod1) f1 -\u003e (dom :~\u003e: cod2) f2 -\u003e (Fst cod1 cod2 :○: (f1 :***: f2)) :==: f1",
          "source": "src/Type-Function.html#fst_tupling",
          "type": "function"
        },
        "index": {
          "hierarchy": "Type Function",
          "module": "Type.Function",
          "name": "fst_tupling",
          "normalized": "(a b)c-\u003e(a b)c-\u003e(Fst b b(c***c))c",
          "package": "type-settheory",
          "signature": "(dom cod)f-\u003e(dom cod)f-\u003e(Fst cod cod(f***f))f",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#v:fst_tupling"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Function",
          "name": "fullImageOfInclusion",
          "package": "type-settheory",
          "signature": "(dom :⊆: cod) -\u003e Image (Incl dom cod) dom :==: dom",
          "source": "src/Type-Function.html#fullImageOfInclusion",
          "type": "function"
        },
        "index": {
          "hierarchy": "Type Function",
          "module": "Type.Function",
          "name": "fullImageOfInclusion",
          "normalized": "(a b)-\u003eImage(Incl a b)a a",
          "package": "type-settheory",
          "partial": "Image Of Inclusion",
          "signature": "(dom cod)-\u003eImage(Incl dom cod)dom dom",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#v:fullImageOfInclusion"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eVery useful lemma for proving equality of functions.\n\u003c/p\u003e\u003cp\u003eGiven the properties of functions, it is enough to show that \u003ccode\u003ef\u003c/code\u003e is a subset of \u003ccode\u003ef'\u003c/code\u003e to prove \u003ccode\u003ef = f'\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Type.Function",
          "name": "funEq",
          "package": "type-settheory",
          "signature": "forall dom cod cod' f f'.  (dom :~\u003e: cod) f -\u003e (dom :~\u003e: cod') f' -\u003e (f :⊆: f') -\u003e f :==: f'",
          "source": "src/Type-Function.html#funEq",
          "type": "function"
        },
        "index": {
          "description": "Very useful lemma for proving equality of functions Given the properties of functions it is enough to show that is subset of to prove",
          "hierarchy": "Type Function",
          "module": "Type.Function",
          "name": "funEq",
          "normalized": "a b c d e f(b c)e-\u003e(b d)g-\u003e(e g)-\u003ee g",
          "package": "type-settheory",
          "partial": "Eq",
          "signature": "forall dom cod cod' f f'.(dom cod)f-\u003e(dom cod')f'-\u003e(f f')-\u003ef f'",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#v:funEq"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003efunEq\u003c/a\u003e\u003c/code\u003e with the inclusion argument flipped\n\u003c/p\u003e",
          "module": "Type.Function",
          "name": "funEq'",
          "package": "type-settheory",
          "signature": "(dom :~\u003e: cod) f -\u003e (dom :~\u003e: cod') f' -\u003e (f' :⊆: f) -\u003e f :==: f'",
          "source": "src/Type-Function.html#funEq%27",
          "type": "function"
        },
        "index": {
          "description": "funEq with the inclusion argument flipped",
          "hierarchy": "Type Function",
          "module": "Type.Function",
          "name": "funEq'",
          "normalized": "(a b)c-\u003e(a d)e-\u003e(e c)-\u003ec e",
          "package": "type-settheory",
          "partial": "Eq'",
          "signature": "(dom cod)f-\u003e(dom cod')f'-\u003e(f' f)-\u003ef f'",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#v:funEq-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Function",
          "name": "graphCPS",
          "package": "type-settheory",
          "signature": "r) -\u003e r",
          "source": "src/Type-Function.html#graphCPS",
          "type": "function"
        },
        "index": {
          "hierarchy": "Type Function",
          "module": "Type.Function",
          "name": "graphCPS",
          "normalized": "a)-\u003ea",
          "package": "type-settheory",
          "partial": "CPS",
          "signature": "r)-\u003er",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#v:graphCPS"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eType constructors are injective\n\u003c/p\u003e",
          "module": "Type.Function",
          "name": "graphInjective",
          "package": "type-settheory",
          "signature": "Injective (Graph f)",
          "source": "src/Type-Function.html#graphInjective",
          "type": "function"
        },
        "index": {
          "description": "Type constructors are injective",
          "hierarchy": "Type Function",
          "module": "Type.Function",
          "name": "graphInjective",
          "package": "type-settheory",
          "partial": "Injective",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#v:graphInjective"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Function",
          "name": "graphIsFun",
          "package": "type-settheory",
          "signature": "(Univ :~\u003e: Univ) (Graph f)",
          "source": "src/Type-Function.html#graphIsFun",
          "type": "function"
        },
        "index": {
          "hierarchy": "Type Function",
          "module": "Type.Function",
          "name": "graphIsFun",
          "package": "type-settheory",
          "partial": "Is Fun",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#v:graphIsFun"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Function",
          "name": "haskFunInjective",
          "package": "type-settheory",
          "signature": "Injective HaskFun",
          "source": "src/Type-Function.html#haskFunInjective",
          "type": "function"
        },
        "index": {
          "hierarchy": "Type Function",
          "module": "Type.Function",
          "name": "haskFunInjective",
          "package": "type-settheory",
          "partial": "Fun Injective",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#v:haskFunInjective"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Function",
          "name": "haskFunIsFun",
          "package": "type-settheory",
          "signature": "((Univ :×: Univ) :~\u003e: FunctionType) HaskFun",
          "source": "src/Type-Function.html#haskFunIsFun",
          "type": "function"
        },
        "index": {
          "hierarchy": "Type Function",
          "module": "Type.Function",
          "name": "haskFunIsFun",
          "package": "type-settheory",
          "partial": "Fun Is Fun",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#v:haskFunIsFun"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eId is a function\n\u003c/p\u003e",
          "module": "Type.Function",
          "name": "idIsFun",
          "package": "type-settheory",
          "signature": "(dom :~\u003e: dom) (Id dom)",
          "source": "src/Type-Function.html#idIsFun",
          "type": "function"
        },
        "index": {
          "description": "Id is function",
          "hierarchy": "Type Function",
          "module": "Type.Function",
          "name": "idIsFun",
          "package": "type-settheory",
          "partial": "Is Fun",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#v:idIsFun"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLemma for proving a function equal to the identity\n\u003c/p\u003e",
          "module": "Type.Function",
          "name": "idLemma",
          "package": "type-settheory",
          "signature": "(dom :~\u003e: dom) f -\u003e (forall x y.  ((x, y) :∈: f) -\u003e x :=: y) -\u003e Id dom :==: f",
          "source": "src/Type-Function.html#idLemma",
          "type": "function"
        },
        "index": {
          "description": "Lemma for proving function equal to the identity",
          "hierarchy": "Type Function",
          "module": "Type.Function",
          "name": "idLemma",
          "normalized": "(a a)b-\u003e(c d e((d,f)b)-\u003ed f)-\u003eId a b",
          "package": "type-settheory",
          "partial": "Lemma",
          "signature": "(dom dom)f-\u003e(forall x y.((x,y)f)-\u003ex y)-\u003eId dom f",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#v:idLemma"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEvery image is a subset of every possible codomain\n\u003c/p\u003e",
          "module": "Type.Function",
          "name": "imageCod",
          "package": "type-settheory",
          "signature": "(dom :~\u003e: cod) f -\u003e Image f s :⊆: cod",
          "source": "src/Type-Function.html#imageCod",
          "type": "function"
        },
        "index": {
          "description": "Every image is subset of every possible codomain",
          "hierarchy": "Type Function",
          "module": "Type.Function",
          "name": "imageCod",
          "normalized": "(a b)c-\u003eImage c d b",
          "package": "type-settheory",
          "partial": "Cod",
          "signature": "(dom cod)f-\u003eImage f s cod",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#v:imageCod"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Function",
          "name": "imageEmpty",
          "package": "type-settheory",
          "signature": "Image f Empty :==: Empty",
          "source": "src/Type-Function.html#imageEmpty",
          "type": "function"
        },
        "index": {
          "hierarchy": "Type Function",
          "module": "Type.Function",
          "name": "imageEmpty",
          "package": "type-settheory",
          "partial": "Empty",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#v:imageEmpty"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Function",
          "name": "imageGraphList",
          "package": "type-settheory",
          "signature": "[a] :∈: Image (Graph []) Univ",
          "source": "src/Type-Function.html#imageGraphList",
          "type": "function"
        },
        "index": {
          "hierarchy": "Type Function",
          "module": "Type.Function",
          "name": "imageGraphList",
          "normalized": "[a]Image(Graph[])Univ",
          "package": "type-settheory",
          "partial": "Graph List",
          "signature": "[a]Image(Graph[])Univ",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#v:imageGraphList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Function",
          "name": "imageMonotonic",
          "package": "type-settheory",
          "signature": "(s1 :⊆: s2) -\u003e Image f s1 :⊆: Image f s2",
          "source": "src/Type-Function.html#imageMonotonic",
          "type": "function"
        },
        "index": {
          "hierarchy": "Type Function",
          "module": "Type.Function",
          "name": "imageMonotonic",
          "normalized": "(a a)-\u003eImage b a Image b a",
          "package": "type-settheory",
          "partial": "Monotonic",
          "signature": "(s s)-\u003eImage f s Image f s",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#v:imageMonotonic"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Function",
          "name": "imageOfInclusion",
          "package": "type-settheory",
          "signature": "Image (Incl dom cod) s :==: (s :∩: dom)",
          "source": "src/Type-Function.html#imageOfInclusion",
          "type": "function"
        },
        "index": {
          "hierarchy": "Type Function",
          "module": "Type.Function",
          "name": "imageOfInclusion",
          "package": "type-settheory",
          "partial": "Of Inclusion",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#v:imageOfInclusion"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eImage distributes over union (in general not over intersection)\n\u003c/p\u003e",
          "module": "Type.Function",
          "name": "imageUnion",
          "package": "type-settheory",
          "signature": "forall dom cod s1 s2 f.  (dom :~\u003e: cod) f -\u003e Image f (s1 :∪: s2) :==: (Image f s1 :∪: Image f s2)",
          "source": "src/Type-Function.html#imageUnion",
          "type": "function"
        },
        "index": {
          "description": "Image distributes over union in general not over intersection",
          "hierarchy": "Type Function",
          "module": "Type.Function",
          "name": "imageUnion",
          "normalized": "a b c d d e(b c)f-\u003eImage f(d d)(Image f d Image f d)",
          "package": "type-settheory",
          "partial": "Union",
          "signature": "forall dom cod s s f.(dom cod)f-\u003eImage f(s s)(Image f s Image f s)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#v:imageUnion"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Function",
          "name": "image_Preimage",
          "package": "type-settheory",
          "signature": "(dom :~\u003e: cod) f -\u003e Image f (Preimage f set) :⊆: set",
          "source": "src/Type-Function.html#image_Preimage",
          "type": "function"
        },
        "index": {
          "hierarchy": "Type Function",
          "module": "Type.Function",
          "name": "image_Preimage",
          "normalized": "(a b)c-\u003eImage c(Preimage c d)d",
          "package": "type-settheory",
          "partial": "Preimage",
          "signature": "(dom cod)f-\u003eImage f(Preimage f set)set",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#v:image_Preimage"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIf \u003ccode\u003ef a = b\u003c/code\u003e, then \u003ccode\u003eb\u003c/code\u003e is in the codomain of \u003ccode\u003ef\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Type.Function",
          "name": "inCod",
          "package": "type-settheory",
          "signature": "(dom :~\u003e: cod) f -\u003e ((a, b) :∈: f) -\u003e b :∈: cod",
          "source": "src/Type-Function.html#inCod",
          "type": "function"
        },
        "index": {
          "description": "If then is in the codomain of",
          "hierarchy": "Type Function",
          "module": "Type.Function",
          "name": "inCod",
          "normalized": "(a b)c-\u003e((d,e)c)-\u003ee b",
          "package": "type-settheory",
          "partial": "Cod",
          "signature": "(dom cod)f-\u003e((a,b)f)-\u003eb cod",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#v:inCod"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIf \u003ccode\u003ef a = b\u003c/code\u003e, then \u003ccode\u003ea\u003c/code\u003e is in the domain of \u003ccode\u003ef\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Type.Function",
          "name": "inDom",
          "package": "type-settheory",
          "signature": "(dom :~\u003e: cod) f -\u003e ((a, b) :∈: f) -\u003e a :∈: dom",
          "source": "src/Type-Function.html#inDom",
          "type": "function"
        },
        "index": {
          "description": "If then is in the domain of",
          "hierarchy": "Type Function",
          "module": "Type.Function",
          "name": "inDom",
          "normalized": "(a b)c-\u003e((d,e)c)-\u003ed a",
          "package": "type-settheory",
          "partial": "Dom",
          "signature": "(dom cod)f-\u003e((a,b)f)-\u003ea dom",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#v:inDom"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInclusion is a function\n\u003c/p\u003e",
          "module": "Type.Function",
          "name": "inclusionIsFun",
          "package": "type-settheory",
          "signature": "(dom :⊆: cod) -\u003e (dom :~\u003e: cod) (Incl dom cod)",
          "source": "src/Type-Function.html#inclusionIsFun",
          "type": "function"
        },
        "index": {
          "description": "Inclusion is function",
          "hierarchy": "Type Function",
          "module": "Type.Function",
          "name": "inclusionIsFun",
          "normalized": "(a b)-\u003e(a b)(Incl a b)",
          "package": "type-settheory",
          "partial": "Is Fun",
          "signature": "(dom cod)-\u003e(dom cod)(Incl dom cod)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#v:inclusionIsFun"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Function",
          "name": "inclusion_Injective",
          "package": "type-settheory",
          "signature": "Injective (Incl dom cod)",
          "source": "src/Type-Function.html#inclusion_Injective",
          "type": "function"
        },
        "index": {
          "hierarchy": "Type Function",
          "module": "Type.Function",
          "name": "inclusion_Injective",
          "package": "type-settheory",
          "partial": "Injective",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#v:inclusion_Injective"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Function",
          "name": "injective",
          "package": "type-settheory",
          "signature": "forall f a1 a2 b.  Injective f -\u003e ((a1, b) :∈: f) -\u003e ((a2, b) :∈: f) -\u003e a1 :=: a2",
          "source": "src/Type-Function.html#injective",
          "type": "function"
        },
        "index": {
          "hierarchy": "Type Function",
          "module": "Type.Function",
          "name": "injective",
          "normalized": "a b c c d Injective b-\u003e((c,e)b)-\u003e((c,e)b)-\u003ec c",
          "package": "type-settheory",
          "signature": "forall f a a b. Injective f-\u003e((a,b)f)-\u003e((a,b)f)-\u003ea a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#v:injective"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn injective function has an inverse, with domain the image\n\u003c/p\u003e",
          "module": "Type.Function",
          "name": "injective_Inv",
          "package": "type-settheory",
          "signature": "(dom :~\u003e: cod) f -\u003e Injective f -\u003e (Image f dom :~\u003e: dom) (Inv f)",
          "source": "src/Type-Function.html#injective_Inv",
          "type": "function"
        },
        "index": {
          "description": "An injective function has an inverse with domain the image",
          "hierarchy": "Type Function",
          "module": "Type.Function",
          "name": "injective_Inv",
          "normalized": "(a b)c-\u003eInjective c-\u003e(Image c a a)(Inv c)",
          "package": "type-settheory",
          "partial": "Inv",
          "signature": "(dom cod)f-\u003eInjective f-\u003e(Image f dom dom)(Inv f)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#v:injective_Inv"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Function",
          "name": "introToTyCon",
          "package": "type-settheory",
          "signature": "((x, y) :∈: f) -\u003e y -\u003e ToTyCon f x",
          "source": "src/Type-Function.html#introToTyCon",
          "type": "function"
        },
        "index": {
          "hierarchy": "Type Function",
          "module": "Type.Function",
          "name": "introToTyCon",
          "normalized": "((a,b)c)-\u003eb-\u003eToTyCon c a",
          "package": "type-settheory",
          "partial": "To Ty Con",
          "signature": "((x,y)f)-\u003ey-\u003eToTyCon f x",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#v:introToTyCon"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Function",
          "name": "invId",
          "package": "type-settheory",
          "signature": "Inv (Id dom) :==: Id dom",
          "source": "src/Type-Function.html#invId",
          "type": "function"
        },
        "index": {
          "hierarchy": "Type Function",
          "module": "Type.Function",
          "name": "invId",
          "package": "type-settheory",
          "partial": "Id",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#v:invId"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Function",
          "name": "invInv",
          "package": "type-settheory",
          "signature": "(dom :~\u003e: cod) f -\u003e Inv (Inv f) :==: f",
          "source": "src/Type-Function.html#invInv",
          "type": "function"
        },
        "index": {
          "hierarchy": "Type Function",
          "module": "Type.Function",
          "name": "invInv",
          "normalized": "(a b)c-\u003eInv(Inv c)c",
          "package": "type-settheory",
          "partial": "Inv",
          "signature": "(dom cod)f-\u003eInv(Inv f)f",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#v:invInv"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Function",
          "name": "invInv0",
          "package": "type-settheory",
          "signature": "Inv (Inv f) :⊆: f",
          "source": "src/Type-Function.html#invInv0",
          "type": "function"
        },
        "index": {
          "hierarchy": "Type Function",
          "module": "Type.Function",
          "name": "invInv0",
          "package": "type-settheory",
          "partial": "Inv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#v:invInv0"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Function",
          "name": "isFun_congruence",
          "package": "type-settheory",
          "signature": "(d :~\u003e: c) f -\u003e (f :==: f') -\u003e (d :~\u003e: c) f'",
          "source": "src/Type-Function.html#isFun_congruence",
          "type": "function"
        },
        "index": {
          "hierarchy": "Type Function",
          "module": "Type.Function",
          "name": "isFun_congruence",
          "normalized": "(a b)c-\u003e(c d)-\u003e(a b)d",
          "package": "type-settheory",
          "partial": "Fun",
          "signature": "(d c)f-\u003e(f f')-\u003e(d c)f'",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#v:isFun_congruence"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Function",
          "name": "kleisliHomInjective",
          "package": "type-settheory",
          "signature": "Injective (KleisliHom m)",
          "source": "src/Type-Function.html#kleisliHomInjective",
          "type": "function"
        },
        "index": {
          "hierarchy": "Type Function",
          "module": "Type.Function",
          "name": "kleisliHomInjective",
          "package": "type-settheory",
          "partial": "Hom Injective",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#v:kleisliHomInjective"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Function",
          "name": "kleisliHomIsFun",
          "package": "type-settheory",
          "signature": "((Univ :×: Univ) :~\u003e: KleisliType m) (KleisliHom m)",
          "source": "src/Type-Function.html#kleisliHomIsFun",
          "type": "function"
        },
        "index": {
          "hierarchy": "Type Function",
          "module": "Type.Function",
          "name": "kleisliHomIsFun",
          "package": "type-settheory",
          "partial": "Hom Is Fun",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#v:kleisliHomIsFun"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Function",
          "name": "lowerFun",
          "package": "type-settheory",
          "signature": "(dom :~\u003e: cod) f -\u003e (dom :~~\u003e: cod) (Lower f)",
          "source": "src/Type-Function.html#lowerFun",
          "type": "function"
        },
        "index": {
          "hierarchy": "Type Function",
          "module": "Type.Function",
          "name": "lowerFun",
          "normalized": "(a b)c-\u003e(a b)(Lower c)",
          "package": "type-settheory",
          "partial": "Fun",
          "signature": "(dom cod)f-\u003e(dom cod)(Lower f)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#v:lowerFun"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Function",
          "name": "preimage_Image",
          "package": "type-settheory",
          "signature": "(dom :~\u003e: cod) f -\u003e (set :⊆: dom) -\u003e set :⊆: Preimage f (Image f set)",
          "source": "src/Type-Function.html#preimage_Image",
          "type": "function"
        },
        "index": {
          "hierarchy": "Type Function",
          "module": "Type.Function",
          "name": "preimage_Image",
          "normalized": "(a b)c-\u003e(d a)-\u003ed Preimage c(Image c d)",
          "package": "type-settheory",
          "partial": "Image",
          "signature": "(dom cod)f-\u003e(set dom)-\u003eset Preimage f(Image f set)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#v:preimage_Image"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Function",
          "name": "raiseFun",
          "package": "type-settheory",
          "signature": "(dom :~~\u003e: cod) (Lower f) -\u003e (dom :~\u003e: cod) f",
          "source": "src/Type-Function.html#raiseFun",
          "type": "function"
        },
        "index": {
          "hierarchy": "Type Function",
          "module": "Type.Function",
          "name": "raiseFun",
          "normalized": "(a b)(Lower c)-\u003e(a b)c",
          "package": "type-settheory",
          "partial": "Fun",
          "signature": "(dom cod)(Lower f)-\u003e(dom cod)f",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#v:raiseFun"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis is stronger than \u003ccode\u003e\u003ca\u003eraiseFun\u003c/a\u003e\u003c/code\u003e since it introduces the knowledge that \u003ccode\u003elf\u003c/code\u003e is of the form \u003ccode\u003eLower f\u003c/code\u003e, rather than assuming it.\n\u003c/p\u003e",
          "module": "Type.Function",
          "name": "raiseFunCPS",
          "package": "type-settheory",
          "signature": "(dom :~\u003e: cod) f -\u003e r) -\u003e r",
          "source": "src/Type-Function.html#raiseFunCPS",
          "type": "function"
        },
        "index": {
          "description": "This is stronger than raiseFun since it introduces the knowledge that lf is of the form Lower rather than assuming it",
          "hierarchy": "Type Function",
          "module": "Type.Function",
          "name": "raiseFunCPS",
          "normalized": "(a b)c-\u003ed)-\u003ed",
          "package": "type-settheory",
          "partial": "Fun CPS",
          "signature": "(dom cod)f-\u003er)-\u003er",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#v:raiseFunCPS"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eShortcut for unpacking \u003ccode\u003e\u003ca\u003erelation\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Type.Function",
          "name": "rel",
          "package": "type-settheory",
          "signature": "(dom :~\u003e: cod) f -\u003e (pair :∈: f) -\u003e pair :∈: (dom :×: cod)",
          "source": "src/Type-Function.html#rel",
          "type": "function"
        },
        "index": {
          "description": "Shortcut for unpacking relation",
          "hierarchy": "Type Function",
          "module": "Type.Function",
          "name": "rel",
          "normalized": "(a b)c-\u003e(d c)-\u003ed(a b)",
          "package": "type-settheory",
          "signature": "(dom cod)f-\u003e(pair f)-\u003epair(dom cod)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#v:rel"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Function",
          "name": "relCPS",
          "package": "type-settheory",
          "signature": "dom relCPS_x -\u003e cod relCPS_y -\u003e relCPS_return) -\u003e relCPS_return",
          "source": "src/Type-Function.html#relCPS",
          "type": "function"
        },
        "index": {
          "hierarchy": "Type Function",
          "module": "Type.Function",
          "name": "relCPS",
          "normalized": "a b-\u003ec d-\u003ee)-\u003ee",
          "package": "type-settheory",
          "partial": "CPS",
          "signature": "dom relCPS_x-\u003ecod relCPS_y-\u003erelCPS_return)-\u003erelCPS_return",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#v:relCPS"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFunctions are relations\n\u003c/p\u003e",
          "module": "Type.Function",
          "name": "relation",
          "package": "type-settheory",
          "signature": "(dom :~\u003e: cod) f -\u003e f :⊆: (dom :×: cod)",
          "source": "src/Type-Function.html#relation",
          "type": "function"
        },
        "index": {
          "description": "Functions are relations",
          "hierarchy": "Type Function",
          "module": "Type.Function",
          "name": "relation",
          "normalized": "(a b)c-\u003ec(a b)",
          "package": "type-settheory",
          "signature": "(dom cod)f-\u003ef(dom cod)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#v:relation"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIs section ==\u003e composition is \u003cem\u003eid\u003c/em\u003e\n\u003c/p\u003e",
          "module": "Type.Function",
          "name": "section_CompoId",
          "package": "type-settheory",
          "signature": "(total :~\u003e: base) bun -\u003e (base :~\u003e: total) f -\u003e Section bun f -\u003e (bun :○: f) :==: Id base",
          "source": "src/Type-Function.html#section_CompoId",
          "type": "function"
        },
        "index": {
          "description": "Is section composition is id",
          "hierarchy": "Type Function",
          "module": "Type.Function",
          "name": "section_CompoId",
          "normalized": "(a b)c-\u003e(b a)d-\u003eSection c d-\u003e(c d)Id b",
          "package": "type-settheory",
          "partial": "Compo Id",
          "signature": "(total base)bun-\u003e(base total)f-\u003eSection bun f-\u003e(bun f)Id base",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#v:section_CompoId"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe full image is a codomain\n\u003c/p\u003e",
          "module": "Type.Function",
          "name": "setCodToImage",
          "package": "type-settheory",
          "signature": "(dom :~\u003e: cod) f -\u003e (dom :~\u003e: Image f dom) f",
          "source": "src/Type-Function.html#setCodToImage",
          "type": "function"
        },
        "index": {
          "description": "The full image is codomain",
          "hierarchy": "Type Function",
          "module": "Type.Function",
          "name": "setCodToImage",
          "normalized": "(a b)c-\u003e(a Image c a)c",
          "package": "type-settheory",
          "partial": "Cod To Image",
          "signature": "(dom cod)f-\u003e(dom Image f dom)f",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#v:setCodToImage"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Function",
          "name": "sndIsFun",
          "package": "type-settheory",
          "signature": "((s1 :×: s2) :~\u003e: s2) (Snd s1 s2)",
          "source": "src/Type-Function.html#sndIsFun",
          "type": "function"
        },
        "index": {
          "hierarchy": "Type Function",
          "module": "Type.Function",
          "name": "sndIsFun",
          "package": "type-settheory",
          "partial": "Is Fun",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#v:sndIsFun"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Function",
          "name": "snd_tupling",
          "package": "type-settheory",
          "signature": "(dom :~\u003e: cod1) f1 -\u003e (dom :~\u003e: cod2) f2 -\u003e (Snd cod1 cod2 :○: (f1 :***: f2)) :==: f2",
          "source": "src/Type-Function.html#snd_tupling",
          "type": "function"
        },
        "index": {
          "hierarchy": "Type Function",
          "module": "Type.Function",
          "name": "snd_tupling",
          "normalized": "(a b)c-\u003e(a b)c-\u003e(Snd b b(c***c))c",
          "package": "type-settheory",
          "signature": "(dom cod)f-\u003e(dom cod)f-\u003e(Snd cod cod(f***f))f",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#v:snd_tupling"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFunctions are single-valued (reified equality version)\n\u003c/p\u003e",
          "module": "Type.Function",
          "name": "sval",
          "package": "type-settheory",
          "signature": "forall dom cod a b1 b2 f.  (dom :~\u003e: cod) f -\u003e ((a, b1) :∈: f) -\u003e ((a, b2) :∈: f) -\u003e b1 :=: b2",
          "source": "src/Type-Function.html#sval",
          "type": "function"
        },
        "index": {
          "description": "Functions are single-valued reified equality version",
          "hierarchy": "Type Function",
          "module": "Type.Function",
          "name": "sval",
          "normalized": "a b c d e e f(b c)g-\u003e((d,e)g)-\u003e((d,e)g)-\u003ee e",
          "package": "type-settheory",
          "signature": "forall dom cod a b b f.(dom cod)f-\u003e((a,b)f)-\u003e((a,b)f)-\u003eb b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#v:sval"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFunctions are single-valued (CPS version)\n\u003c/p\u003e",
          "module": "Type.Function",
          "name": "svalCPS",
          "package": "type-settheory",
          "signature": "r) -\u003e r",
          "source": "src/Type-Function.html#svalCPS",
          "type": "function"
        },
        "index": {
          "description": "Functions are single-valued CPS version",
          "hierarchy": "Type Function",
          "module": "Type.Function",
          "name": "svalCPS",
          "normalized": "a)-\u003ea",
          "package": "type-settheory",
          "partial": "CPS",
          "signature": "r)-\u003er",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#v:svalCPS"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Function",
          "name": "svalCPS'",
          "package": "type-settheory",
          "signature": "(dom :~\u003e: cod) f -\u003e ((a, b1) :∈: f) -\u003e ((a, b2) :∈: f) -\u003e ((b1 :=: b2) -\u003e r) -\u003e r",
          "source": "src/Type-Function.html#svalCPS%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Type Function",
          "module": "Type.Function",
          "name": "svalCPS'",
          "normalized": "(a b)c-\u003e((d,e)c)-\u003e((d,e)c)-\u003e((e e)-\u003ef)-\u003ef",
          "package": "type-settheory",
          "partial": "CPS'",
          "signature": "(dom cod)f-\u003e((a,b)f)-\u003e((a,b)f)-\u003e((b b)-\u003er)-\u003er",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#v:svalCPS-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePerform coercion using the single-valuedness\n\u003c/p\u003e",
          "module": "Type.Function",
          "name": "svalCoerce",
          "package": "type-settheory",
          "signature": "forall dom cod a b1 b2 f.  (dom :~\u003e: cod) f -\u003e ((a, b1) :∈: f) -\u003e ((a, b2) :∈: f) -\u003e b1 -\u003e b2",
          "source": "src/Type-Function.html#svalCoerce",
          "type": "function"
        },
        "index": {
          "description": "Perform coercion using the single-valuedness",
          "hierarchy": "Type Function",
          "module": "Type.Function",
          "name": "svalCoerce",
          "normalized": "a b c d e e f(b c)g-\u003e((d,e)g)-\u003e((d,e)g)-\u003ee-\u003ee",
          "package": "type-settheory",
          "partial": "Coerce",
          "signature": "forall dom cod a b b f.(dom cod)f-\u003e((a,b)f)-\u003e((a,b)f)-\u003eb-\u003eb",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#v:svalCoerce"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Function",
          "name": "targetTuplingIsFun",
          "package": "type-settheory",
          "signature": "(dom :~\u003e: cod1) f1 -\u003e (dom :~\u003e: cod2) f2 -\u003e (dom :~\u003e: (cod1 :×: cod2)) (f1 :***: f2)",
          "source": "src/Type-Function.html#targetTuplingIsFun",
          "type": "function"
        },
        "index": {
          "hierarchy": "Type Function",
          "module": "Type.Function",
          "name": "targetTuplingIsFun",
          "normalized": "(a b)c-\u003e(a b)c-\u003e(a(b b))(c***c)",
          "package": "type-settheory",
          "partial": "Tupling Is Fun",
          "signature": "(dom cod)f-\u003e(dom cod)f-\u003e(dom(cod cod))(f***f)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#v:targetTuplingIsFun"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Function",
          "name": "toTCG",
          "package": "type-settheory",
          "signature": "f x -\u003e ToTyCon (Graph f) x",
          "source": "src/Type-Function.html#toTCG",
          "type": "function"
        },
        "index": {
          "hierarchy": "Type Function",
          "module": "Type.Function",
          "name": "toTCG",
          "normalized": "a b-\u003eToTyCon(Graph a)b",
          "package": "type-settheory",
          "partial": "TCG",
          "signature": "f x-\u003eToTyCon(Graph f)x",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#v:toTCG"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFunctions are total\n\u003c/p\u003e",
          "module": "Type.Function",
          "name": "total",
          "package": "type-settheory",
          "signature": "(dom :~\u003e: cod) f -\u003e (a :∈: dom) -\u003e ExSnd f a",
          "source": "src/Type-Function.html#total",
          "type": "function"
        },
        "index": {
          "description": "Functions are total",
          "hierarchy": "Type Function",
          "module": "Type.Function",
          "name": "total",
          "normalized": "(a b)c-\u003e(d a)-\u003eExSnd c d",
          "package": "type-settheory",
          "signature": "(dom cod)f-\u003e(a dom)-\u003eExSnd f a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#v:total"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eThe detailed type variable names help debugging proofs\u003c/em\u003e\n\u003c/p\u003e",
          "module": "Type.Function",
          "name": "totalCPS",
          "package": "type-settheory",
          "signature": "(dom :~\u003e: cod) f -\u003e (a :∈: dom) -\u003e (forall totalCPS_y.  ((a, totalCPS_y) :∈: f) -\u003e totalCPS_return) -\u003e totalCPS_return",
          "source": "src/Type-Function.html#totalCPS",
          "type": "function"
        },
        "index": {
          "description": "The detailed type variable names help debugging proofs",
          "hierarchy": "Type Function",
          "module": "Type.Function",
          "name": "totalCPS",
          "normalized": "(a b)c-\u003e(d a)-\u003e(e f((d,g)c)-\u003eh)-\u003eh",
          "package": "type-settheory",
          "partial": "CPS",
          "signature": "(dom cod)f-\u003e(a dom)-\u003e(forall totalCPS_y.((a,totalCPS_y)f)-\u003etotalCPS_return)-\u003etotalCPS_return",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#v:totalCPS"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Function",
          "name": "tupling_eta",
          "package": "type-settheory",
          "signature": "(dom :~\u003e: (cod1 :×: cod2)) f -\u003e ((Fst cod1 cod2 :○: f) :***: (Snd cod1 cod2 :○: f)) :==: f",
          "source": "src/Type-Function.html#tupling_eta",
          "type": "function"
        },
        "index": {
          "hierarchy": "Type Function",
          "module": "Type.Function",
          "name": "tupling_eta",
          "normalized": "(a(b b))c-\u003e((Fst b b c)***(Snd b b c))c",
          "package": "type-settheory",
          "signature": "(dom(cod cod))f-\u003e((Fst cod cod f)***(Snd cod cod f))f",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Function.html#v:tupling_eta"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003ePropositions as types (of kind \u003ccode\u003e*\u003c/code\u003e), proofs as values\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Type.Logic",
          "name": "Logic",
          "package": "type-settheory",
          "source": "src/Type-Logic.html",
          "type": "module"
        },
        "index": {
          "description": "Propositions as types of kind proofs as values",
          "hierarchy": "Type Logic",
          "module": "Type.Logic",
          "name": "Logic",
          "package": "type-settheory",
          "partial": "Logic",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Logic.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUniversal quantification\n\u003c/p\u003e",
          "module": "Type.Logic",
          "name": "All",
          "package": "type-settheory",
          "source": "src/Type-Logic.html#All",
          "type": "newtype"
        },
        "index": {
          "description": "Universal quantification",
          "hierarchy": "Type Logic",
          "module": "Type.Logic",
          "name": "All",
          "package": "type-settheory",
          "partial": "All",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Logic.html#t:All"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Logic",
          "name": "COr",
          "package": "type-settheory",
          "source": "src/Type-Logic.html#COr",
          "type": "type"
        },
        "index": {
          "hierarchy": "Type Logic",
          "module": "Type.Logic",
          "name": "COr",
          "package": "type-settheory",
          "partial": "COr",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Logic.html#t:COr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Logic",
          "name": "Decidable",
          "package": "type-settheory",
          "source": "src/Type-Logic.html#Decidable",
          "type": "class"
        },
        "index": {
          "hierarchy": "Type Logic",
          "module": "Type.Logic",
          "name": "Decidable",
          "package": "type-settheory",
          "partial": "Decidable",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Logic.html#t:Decidable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Logic",
          "name": "Decidable1",
          "package": "type-settheory",
          "source": "src/Type-Logic.html#Decidable1",
          "type": "class"
        },
        "index": {
          "hierarchy": "Type Logic",
          "module": "Type.Logic",
          "name": "Decidable1",
          "package": "type-settheory",
          "partial": "Decidable",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Logic.html#t:Decidable1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExistential quantification                                                         \n\u003c/p\u003e",
          "module": "Type.Logic",
          "name": "Ex",
          "package": "type-settheory",
          "source": "src/Type-Logic.html#Ex",
          "type": "data"
        },
        "index": {
          "description": "Existential quantification",
          "hierarchy": "Type Logic",
          "module": "Type.Logic",
          "name": "Ex",
          "package": "type-settheory",
          "partial": "Ex",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Logic.html#t:Ex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUnique existence\n\u003c/p\u003e",
          "module": "Type.Logic",
          "name": "ExUniq",
          "package": "type-settheory",
          "source": "src/Type-Logic.html#ExUniq",
          "type": "data"
        },
        "index": {
          "description": "Unique existence",
          "hierarchy": "Type Logic",
          "module": "Type.Logic",
          "name": "ExUniq",
          "package": "type-settheory",
          "partial": "Ex Uniq",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Logic.html#t:ExUniq"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis class collects lemmas. It plays no foundational role.\n\u003c/p\u003e",
          "module": "Type.Logic",
          "name": "Fact",
          "package": "type-settheory",
          "source": "src/Type-Logic.html#Fact",
          "type": "class"
        },
        "index": {
          "description": "This class collects lemmas It plays no foundational role",
          "hierarchy": "Type Logic",
          "module": "Type.Logic",
          "name": "Fact",
          "package": "type-settheory",
          "partial": "Fact",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Logic.html#t:Fact"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Logic",
          "name": "Falsity",
          "package": "type-settheory",
          "source": "src/Type-Logic.html#Falsity",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "Type Logic",
          "module": "Type.Logic",
          "name": "Falsity",
          "package": "type-settheory",
          "partial": "Falsity",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Logic.html#t:Falsity"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Logic",
          "name": "Finite",
          "package": "type-settheory",
          "source": "src/Type-Logic.html#Finite",
          "type": "class"
        },
        "index": {
          "hierarchy": "Type Logic",
          "module": "Type.Logic",
          "name": "Finite",
          "package": "type-settheory",
          "partial": "Finite",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Logic.html#t:Finite"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Logic",
          "name": "Not",
          "package": "type-settheory",
          "source": "src/Type-Logic.html#Not",
          "type": "type"
        },
        "index": {
          "hierarchy": "Type Logic",
          "module": "Type.Logic",
          "name": "Not",
          "package": "type-settheory",
          "partial": "Not",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Logic.html#t:Not"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Logic",
          "name": "Truth",
          "package": "type-settheory",
          "source": "src/Type-Logic.html#Truth",
          "type": "data"
        },
        "index": {
          "hierarchy": "Type Logic",
          "module": "Type.Logic",
          "name": "Truth",
          "package": "type-settheory",
          "partial": "Truth",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Logic.html#t:Truth"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Logic",
          "name": "All",
          "package": "type-settheory",
          "signature": "All",
          "source": "src/Type-Logic.html#All",
          "type": "function"
        },
        "index": {
          "hierarchy": "Type Logic",
          "module": "Type.Logic",
          "name": "All",
          "package": "type-settheory",
          "partial": "All",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Logic.html#v:All"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Logic",
          "name": "Ex",
          "package": "type-settheory",
          "signature": "p b -\u003e Ex p",
          "source": "src/Type-Logic.html#Ex",
          "type": "function"
        },
        "index": {
          "hierarchy": "Type Logic",
          "module": "Type.Logic",
          "name": "Ex",
          "normalized": "a b-\u003eEx a",
          "package": "type-settheory",
          "partial": "Ex",
          "signature": "p b-\u003eEx p",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Logic.html#v:Ex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Logic",
          "name": "ExUniq",
          "package": "type-settheory",
          "signature": "p b -\u003e (forall b'.  p b' -\u003e b :=: b') -\u003e ExUniq p",
          "source": "src/Type-Logic.html#ExUniq",
          "type": "function"
        },
        "index": {
          "hierarchy": "Type Logic",
          "module": "Type.Logic",
          "name": "ExUniq",
          "normalized": "a b-\u003e(c d a e-\u003eb e)-\u003eExUniq a",
          "package": "type-settheory",
          "partial": "Ex Uniq",
          "signature": "p b-\u003e(forall b'. p b'-\u003eb b')-\u003eExUniq p",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Logic.html#v:ExUniq"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Logic",
          "name": "Falsity",
          "package": "type-settheory",
          "signature": "Falsity",
          "source": "src/Type-Logic.html#Falsity",
          "type": "function"
        },
        "index": {
          "hierarchy": "Type Logic",
          "module": "Type.Logic",
          "name": "Falsity",
          "package": "type-settheory",
          "partial": "Falsity",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Logic.html#v:Falsity"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Logic",
          "name": "TruthProof",
          "package": "type-settheory",
          "signature": "TruthProof",
          "source": "src/Type-Logic.html#Truth",
          "type": "function"
        },
        "index": {
          "hierarchy": "Type Logic",
          "module": "Type.Logic",
          "name": "TruthProof",
          "package": "type-settheory",
          "partial": "Truth Proof",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Logic.html#v:TruthProof"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Logic",
          "name": "allElim",
          "package": "type-settheory",
          "signature": "forall b.  p b",
          "source": "src/Type-Logic.html#All",
          "type": "function"
        },
        "index": {
          "hierarchy": "Type Logic",
          "module": "Type.Logic",
          "name": "allElim",
          "package": "type-settheory",
          "partial": "Elim",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Logic.html#v:allElim"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Logic",
          "name": "auto",
          "package": "type-settheory",
          "signature": "a",
          "source": "src/Type-Logic.html#auto",
          "type": "method"
        },
        "index": {
          "hierarchy": "Type Logic",
          "module": "Type.Logic",
          "name": "auto",
          "package": "type-settheory",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Logic.html#v:auto"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Logic",
          "name": "decide",
          "package": "type-settheory",
          "signature": "Either (Not a) a",
          "source": "src/Type-Logic.html#decide",
          "type": "method"
        },
        "index": {
          "hierarchy": "Type Logic",
          "module": "Type.Logic",
          "name": "decide",
          "package": "type-settheory",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Logic.html#v:decide"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Logic",
          "name": "decide1",
          "package": "type-settheory",
          "signature": "Either (Not (s a)) (s a)",
          "source": "src/Type-Logic.html#decide1",
          "type": "method"
        },
        "index": {
          "hierarchy": "Type Logic",
          "module": "Type.Logic",
          "name": "decide1",
          "package": "type-settheory",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Logic.html#v:decide1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Logic",
          "name": "elimCor",
          "package": "type-settheory",
          "signature": "COr r a b -\u003e (a -\u003e r) -\u003e (b -\u003e r) -\u003e r",
          "source": "src/Type-Logic.html#elimCor",
          "type": "function"
        },
        "index": {
          "hierarchy": "Type Logic",
          "module": "Type.Logic",
          "name": "elimCor",
          "normalized": "COr a b c-\u003e(b-\u003ea)-\u003e(c-\u003ea)-\u003ea",
          "package": "type-settheory",
          "partial": "Cor",
          "signature": "COr r a b-\u003e(a-\u003er)-\u003e(b-\u003er)-\u003er",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Logic.html#v:elimCor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Logic",
          "name": "elimFalsity",
          "package": "type-settheory",
          "signature": "forall a.  a",
          "source": "src/Type-Logic.html#Falsity",
          "type": "function"
        },
        "index": {
          "hierarchy": "Type Logic",
          "module": "Type.Logic",
          "name": "elimFalsity",
          "package": "type-settheory",
          "partial": "Falsity",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Logic.html#v:elimFalsity"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Logic",
          "name": "enum",
          "package": "type-settheory",
          "signature": "[Ex s]",
          "source": "src/Type-Logic.html#enum",
          "type": "method"
        },
        "index": {
          "hierarchy": "Type Logic",
          "module": "Type.Logic",
          "name": "enum",
          "normalized": "[Ex a]",
          "package": "type-settheory",
          "signature": "[Ex s]",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Logic.html#v:enum"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Logic",
          "name": "exElim",
          "package": "type-settheory",
          "signature": "forall p r.  (forall b.  p b -\u003e r) -\u003e Ex p -\u003e r",
          "source": "src/Type-Logic.html#exElim",
          "type": "function"
        },
        "index": {
          "hierarchy": "Type Logic",
          "module": "Type.Logic",
          "name": "exElim",
          "normalized": "a b c(a d b e-\u003ef)-\u003eEx b-\u003ef",
          "package": "type-settheory",
          "partial": "Elim",
          "signature": "forall p r.(forall b. p b-\u003er)-\u003eEx p-\u003er",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Logic.html#v:exElim"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Logic",
          "name": "lem",
          "package": "type-settheory",
          "signature": "COr r (a -\u003e r) a",
          "source": "src/Type-Logic.html#lem",
          "type": "function"
        },
        "index": {
          "hierarchy": "Type Logic",
          "module": "Type.Logic",
          "name": "lem",
          "normalized": "COr a(b-\u003ea)b",
          "package": "type-settheory",
          "signature": "COr r(a-\u003er)a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Logic.html#v:lem"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eTODO\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e Prove that \u003ccode\u003e\u003ca\u003eInitor\u003c/a\u003e\u003c/code\u003e is an \u003ccode\u003e\u003ca\u003eNMorphism\u003c/a\u003e\u003c/code\u003e\n\u003c/li\u003e\u003cli\u003e Prove that it is uniquely so\n\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e",
          "module": "Type.Nat",
          "name": "Nat",
          "package": "type-settheory",
          "source": "src/Type-Nat.html",
          "type": "module"
        },
        "index": {
          "description": "TODO Prove that Initor is an NMorphism Prove that it is uniquely so",
          "hierarchy": "Type Nat",
          "module": "Type.Nat",
          "name": "Nat",
          "package": "type-settheory",
          "partial": "Nat",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Nat.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe unique morphism from an \u003ccode\u003e\u003ca\u003eTNat\u003c/a\u003e\u003c/code\u003e to any \u003ccode\u003e\u003ca\u003eNStructure\u003c/a\u003e\u003c/code\u003e \n\u003c/p\u003e\u003cp\u003eNB: \u003ccode\u003es\u003c/code\u003e is a type constructor, but \u003ccode\u003esucc2\u003c/code\u003e is a Function (\u003ccode\u003e\u003ca\u003eIsFun\u003c/a\u003e\u003c/code\u003e)\n\u003c/p\u003e",
          "module": "Type.Nat",
          "name": "Initor",
          "package": "type-settheory",
          "source": "src/Type-Nat.html#Initor",
          "type": "data"
        },
        "index": {
          "description": "The unique morphism from an TNat to any NStructure NB is type constructor but succ2 is Function IsFun",
          "hierarchy": "Type Nat",
          "module": "Type.Nat",
          "name": "Initor",
          "package": "type-settheory",
          "partial": "Initor",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Nat.html#t:Initor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExpresses that \u003ccode\u003e(set1,z1,succ1)\u003c/code\u003e is initial in the cat of \u003ccode\u003e\u003ca\u003eNStructure\u003c/a\u003e\u003c/code\u003es, in other words, that it is isomorphic to the natural numbers\n\u003c/p\u003e",
          "module": "Type.Nat",
          "name": "NInitial",
          "package": "type-settheory",
          "source": "src/Type-Nat.html#NInitial",
          "type": "data"
        },
        "index": {
          "description": "Expresses that set1 z1 succ1 is initial in the cat of NStructure in other words that it is isomorphic to the natural numbers",
          "hierarchy": "Type Nat",
          "module": "Type.Nat",
          "name": "NInitial",
          "package": "type-settheory",
          "partial": "NInitial",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Nat.html#t:NInitial"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eStructure-preserving maps of \u003ccode\u003e\u003ca\u003eNStructure\u003c/a\u003e\u003c/code\u003es\n\u003c/p\u003e",
          "module": "Type.Nat",
          "name": "NMorphism",
          "package": "type-settheory",
          "source": "src/Type-Nat.html#NMorphism",
          "type": "data"
        },
        "index": {
          "description": "Structure-preserving maps of NStructure",
          "hierarchy": "Type Nat",
          "module": "Type.Nat",
          "name": "NMorphism",
          "package": "type-settheory",
          "partial": "NMorphism",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Nat.html#t:NMorphism"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSets equipped with a constant and a function to itself\n\u003c/p\u003e",
          "module": "Type.Nat",
          "name": "NStructure",
          "package": "type-settheory",
          "source": "src/Type-Nat.html#NStructure",
          "type": "data"
        },
        "index": {
          "description": "Sets equipped with constant and function to itself",
          "hierarchy": "Type Nat",
          "module": "Type.Nat",
          "name": "NStructure",
          "package": "type-settheory",
          "partial": "NStructure",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Nat.html#t:NStructure"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSuccessor function made from a unary type constructor\n\u003c/p\u003e",
          "module": "Type.Nat",
          "name": "Succ",
          "package": "type-settheory",
          "source": "src/Type-Nat.html#Succ",
          "type": "data"
        },
        "index": {
          "description": "Successor function made from unary type constructor",
          "hierarchy": "Type Nat",
          "module": "Type.Nat",
          "name": "Succ",
          "package": "type-settheory",
          "partial": "Succ",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Nat.html#t:Succ"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eActually any pair of (nullary type, unary type constructor) gives us a copy of the naturals; let's call these \u003cem\u003eTNats\u003c/em\u003e\n\u003c/p\u003e",
          "module": "Type.Nat",
          "name": "TNat",
          "package": "type-settheory",
          "source": "src/Type-Nat.html#TNat",
          "type": "data"
        },
        "index": {
          "description": "Actually any pair of nullary type unary type constructor gives us copy of the naturals let call these TNats",
          "hierarchy": "Type Nat",
          "module": "Type.Nat",
          "name": "TNat",
          "package": "type-settheory",
          "partial": "TNat",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Nat.html#t:TNat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Nat",
          "name": "InitorS",
          "package": "type-settheory",
          "signature": "Initor z s z2 succ2 (n1, n2) -\u003e ((n2, sn2) :∈: succ2) -\u003e Initor z s z2 succ2 (s n1, sn2)",
          "source": "src/Type-Nat.html#Initor",
          "type": "function"
        },
        "index": {
          "hierarchy": "Type Nat",
          "module": "Type.Nat",
          "name": "InitorS",
          "normalized": "Initor a b a c(d,d)-\u003e((d,e)c)-\u003eInitor a b a c(b d,e)",
          "package": "type-settheory",
          "partial": "Initor",
          "signature": "Initor z s z succ(n,n)-\u003e((n,sn)succ)-\u003eInitor z s z succ(s n,sn)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Nat.html#v:InitorS"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Nat",
          "name": "InitorZ",
          "package": "type-settheory",
          "signature": "Initor z s z2 succ2 (z, z2)",
          "source": "src/Type-Nat.html#Initor",
          "type": "function"
        },
        "index": {
          "hierarchy": "Type Nat",
          "module": "Type.Nat",
          "name": "InitorZ",
          "normalized": "Initor a b a c(a,a)",
          "package": "type-settheory",
          "partial": "Initor",
          "signature": "Initor z s z succ(z,z)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Nat.html#v:InitorZ"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Nat",
          "name": "IsS",
          "package": "type-settheory",
          "signature": "TNat z s n -\u003e TNat z s (s n)",
          "source": "src/Type-Nat.html#TNat",
          "type": "function"
        },
        "index": {
          "hierarchy": "Type Nat",
          "module": "Type.Nat",
          "name": "IsS",
          "normalized": "TNat a b c-\u003eTNat a b(b c)",
          "package": "type-settheory",
          "partial": "Is",
          "signature": "TNat z s n-\u003eTNat z s(s n)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Nat.html#v:IsS"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Nat",
          "name": "IsZ",
          "package": "type-settheory",
          "signature": "TNat z s z",
          "source": "src/Type-Nat.html#TNat",
          "type": "function"
        },
        "index": {
          "hierarchy": "Type Nat",
          "module": "Type.Nat",
          "name": "IsZ",
          "package": "type-settheory",
          "partial": "Is",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Nat.html#v:IsZ"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Nat",
          "name": "NInitial",
          "package": "type-settheory",
          "signature": "(forall z2 set2 succ2.  ExUniq1 (NMorphism set1 z1 succ1 z2 set2 succ2)) -\u003e NInitial set1 z1 succ1",
          "source": "src/Type-Nat.html#NInitial",
          "type": "function"
        },
        "index": {
          "hierarchy": "Type Nat",
          "module": "Type.Nat",
          "name": "NInitial",
          "normalized": "(a b c d ExUniq(NMorphism c b d b c d))-\u003eNInitial c b d",
          "package": "type-settheory",
          "partial": "NInitial",
          "signature": "(forall z set succ ExUniq(NMorphism set z succ z set succ))-\u003eNInitial set z succ",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Nat.html#v:NInitial"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Nat",
          "name": "NMorphism",
          "package": "type-settheory",
          "signature": "NStructure set1 z1 succ1 -\u003e NStructure set2 z2 succ2 -\u003e (set1 :~\u003e: set2) f -\u003e (f z1 :=: z2) -\u003e ((f :○: succ1) :==: (succ2 :○: f)) -\u003e NMorphism set1 z1 succ1 z2 set2 succ2 f",
          "source": "src/Type-Nat.html#NMorphism",
          "type": "function"
        },
        "index": {
          "hierarchy": "Type Nat",
          "module": "Type.Nat",
          "name": "NMorphism",
          "normalized": "NStructure a b c-\u003eNStructure a b c-\u003e(a a)d-\u003e(d b b)-\u003e((d c)(c d))-\u003eNMorphism a b c b a c d",
          "package": "type-settheory",
          "partial": "NMorphism",
          "signature": "NStructure set z succ-\u003eNStructure set z succ-\u003e(set set)f-\u003e(f z z)-\u003e((f succ)(succ f))-\u003eNMorphism set z succ z set succ f",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Nat.html#v:NMorphism"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Nat",
          "name": "NStructure",
          "package": "type-settheory",
          "signature": "(z :∈: set) -\u003e (set :~\u003e: set) succ -\u003e NStructure set z succ",
          "source": "src/Type-Nat.html#NStructure",
          "type": "function"
        },
        "index": {
          "hierarchy": "Type Nat",
          "module": "Type.Nat",
          "name": "NStructure",
          "normalized": "(a b)-\u003e(b b)c-\u003eNStructure b a c",
          "package": "type-settheory",
          "partial": "NStructure",
          "signature": "(z set)-\u003e(set set)succ-\u003eNStructure set z succ",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Nat.html#v:NStructure"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Nat",
          "name": "Succ",
          "package": "type-settheory",
          "signature": "(n :∈: TNat z s) -\u003e Succ z s (n, s n)",
          "source": "src/Type-Nat.html#Succ",
          "type": "function"
        },
        "index": {
          "hierarchy": "Type Nat",
          "module": "Type.Nat",
          "name": "Succ",
          "normalized": "(a TNat b c)-\u003eSucc b c(a,c a)",
          "package": "type-settheory",
          "partial": "Succ",
          "signature": "(n TNat z s)-\u003eSucc z s(n,s n)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Nat.html#v:Succ"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Nat",
          "name": "initorFun",
          "package": "type-settheory",
          "signature": "forall z s set2 z2 succ2.  NStructure set2 z2 succ2 -\u003e (TNat z s :~\u003e: set2) (Initor z s z2 succ2)",
          "source": "src/Type-Nat.html#initorFun",
          "type": "function"
        },
        "index": {
          "hierarchy": "Type Nat",
          "module": "Type.Nat",
          "name": "initorFun",
          "normalized": "a b c d b e NStructure d b e-\u003e(TNat b c d)(Initor b c b e)",
          "package": "type-settheory",
          "partial": "Fun",
          "signature": "forall z s set z succ NStructure set z succ-\u003e(TNat z s set)(Initor z s z succ)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Nat.html#v:initorFun"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Nat",
          "name": "succFun",
          "package": "type-settheory",
          "signature": "(TNat z s :~\u003e: TNat z s) (Succ z s)",
          "source": "src/Type-Nat.html#succFun",
          "type": "function"
        },
        "index": {
          "hierarchy": "Type Nat",
          "module": "Type.Nat",
          "name": "succFun",
          "package": "type-settheory",
          "partial": "Fun",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Nat.html#v:succFun"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Nat",
          "name": "tyconNStruct",
          "package": "type-settheory",
          "signature": "NStructure (TNat z s) z (Succ z s)",
          "source": "src/Type-Nat.html#tyconNStruct",
          "type": "function"
        },
        "index": {
          "hierarchy": "Type Nat",
          "module": "Type.Nat",
          "name": "tyconNStruct",
          "package": "type-settheory",
          "partial": "NStruct",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Nat.html#v:tyconNStruct"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Set.Example",
          "name": "Example",
          "package": "type-settheory",
          "source": "src/Type-Set-Example.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Type Set Example",
          "module": "Type.Set.Example",
          "name": "Example",
          "package": "type-settheory",
          "partial": "Example",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set-Example.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEither \u003ccode\u003eTypeable\u003c/code\u003e \u003ccode\u003e\u003ca\u003eIntegral\u003c/a\u003e\u003c/code\u003es, or \u003ccode\u003e\u003ca\u003eString\u003c/a\u003e\u003c/code\u003es\n\u003c/p\u003e",
          "module": "Type.Set.Example",
          "name": "ExampleSet",
          "package": "type-settheory",
          "source": "src/Type-Set-Example.html#ExampleSet",
          "type": "type"
        },
        "index": {
          "description": "Either Typeable Integral or String",
          "hierarchy": "Type Set Example",
          "module": "Type.Set.Example",
          "name": "ExampleSet",
          "package": "type-settheory",
          "partial": "Example Set",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set-Example.html#t:ExampleSet"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA \u003ccode\u003eMap\u003c/code\u003e whose keys are taken from any type which is a member of \u003cem\u003eset\u003c/em\u003e\n\u003c/p\u003e",
          "module": "Type.Set.Example",
          "name": "SMap",
          "package": "type-settheory",
          "source": "src/Type-Set-Example.html#SMap",
          "type": "newtype"
        },
        "index": {
          "description": "Map whose keys are taken from any type which is member of set",
          "hierarchy": "Type Set Example",
          "module": "Type.Set.Example",
          "name": "SMap",
          "package": "type-settheory",
          "partial": "SMap",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set-Example.html#t:SMap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Set.Example",
          "name": "SMap",
          "package": "type-settheory",
          "signature": "SMap (Map (V set) a)",
          "source": "src/Type-Set-Example.html#SMap",
          "type": "function"
        },
        "index": {
          "hierarchy": "Type Set Example",
          "module": "Type.Set.Example",
          "name": "SMap",
          "package": "type-settheory",
          "partial": "SMap",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set-Example.html#v:SMap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Set.Example",
          "name": "insert",
          "package": "type-settheory",
          "signature": "(k :∈: set) -\u003e k -\u003e a -\u003e SMap set a -\u003e SMap set a",
          "source": "src/Type-Set-Example.html#insert",
          "type": "function"
        },
        "index": {
          "hierarchy": "Type Set Example",
          "module": "Type.Set.Example",
          "name": "insert",
          "normalized": "(a b)-\u003ea-\u003ec-\u003eSMap b c-\u003eSMap b c",
          "package": "type-settheory",
          "signature": "(k set)-\u003ek-\u003ea-\u003eSMap set a-\u003eSMap set a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set-Example.html#v:insert"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Set.Example",
          "name": "intInExampleSet",
          "package": "type-settheory",
          "signature": "Int :∈: ExampleSet",
          "source": "src/Type-Set-Example.html#intInExampleSet",
          "type": "function"
        },
        "index": {
          "hierarchy": "Type Set Example",
          "module": "Type.Set.Example",
          "name": "intInExampleSet",
          "package": "type-settheory",
          "partial": "In Example Set",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set-Example.html#v:intInExampleSet"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Set.Example",
          "name": "lookup",
          "package": "type-settheory",
          "signature": "(k :∈: set) -\u003e k -\u003e SMap set a -\u003e Maybe a",
          "source": "src/Type-Set-Example.html#lookup",
          "type": "function"
        },
        "index": {
          "hierarchy": "Type Set Example",
          "module": "Type.Set.Example",
          "name": "lookup",
          "normalized": "(a b)-\u003ea-\u003eSMap b c-\u003eMaybe c",
          "package": "type-settheory",
          "signature": "(k set)-\u003ek-\u003eSMap set a-\u003eMaybe a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set-Example.html#v:lookup"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Set.Example",
          "name": "singleton",
          "package": "type-settheory",
          "signature": "(k :∈: set) -\u003e k -\u003e a -\u003e SMap set a",
          "source": "src/Type-Set-Example.html#singleton",
          "type": "function"
        },
        "index": {
          "hierarchy": "Type Set Example",
          "module": "Type.Set.Example",
          "name": "singleton",
          "normalized": "(a b)-\u003ea-\u003ec-\u003eSMap b c",
          "package": "type-settheory",
          "signature": "(k set)-\u003ek-\u003ea-\u003eSMap set a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set-Example.html#v:singleton"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Set.Example",
          "name": "stringInExampleSet",
          "package": "type-settheory",
          "signature": "String :∈: ExampleSet",
          "source": "src/Type-Set-Example.html#stringInExampleSet",
          "type": "function"
        },
        "index": {
          "hierarchy": "Type Set Example",
          "module": "Type.Set.Example",
          "name": "stringInExampleSet",
          "package": "type-settheory",
          "partial": "In Example Set",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set-Example.html#v:stringInExampleSet"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Set.Example",
          "name": "test",
          "package": "type-settheory",
          "signature": "SMap ExampleSet Integer",
          "source": "src/Type-Set-Example.html#test",
          "type": "function"
        },
        "index": {
          "hierarchy": "Type Set Example",
          "module": "Type.Set.Example",
          "name": "test",
          "package": "type-settheory",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set-Example.html#v:test"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cul\u003e\u003cli\u003e Sets are encoded as certain types of kind \u003ccode\u003e* -\u003e *\u003c/code\u003e\n\u003c/li\u003e\u003cli\u003e A value of type \u003ccode\u003eS X\u003c/code\u003e is a proof that the type \u003ccode\u003eX\u003c/code\u003e is a member of \u003ccode\u003eS\u003c/code\u003e\n\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e",
          "module": "Type.Set",
          "name": "Set",
          "package": "type-settheory",
          "source": "src/Type-Set.html",
          "type": "module"
        },
        "index": {
          "description": "Sets are encoded as certain types of kind value of type is proof that the type is member of",
          "hierarchy": "Type Set",
          "module": "Type.Set",
          "name": "Set",
          "package": "type-settheory",
          "partial": "Set",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDependent sum\n\u003c/p\u003e",
          "module": "Type.Set",
          "name": "Σ",
          "package": "type-settheory",
          "source": "src/Type-Set.html#%3A3",
          "type": "data"
        },
        "index": {
          "description": "Dependent sum",
          "hierarchy": "Type Set",
          "module": "Type.Set",
          "name": "Σ",
          "package": "type-settheory",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#t:-931-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eBinary products\n\u003c/p\u003e",
          "module": "Type.Set",
          "name": ":×:",
          "package": "type-settheory",
          "source": "src/Type-Set.html#%3A%D7%3A",
          "type": "data"
        },
        "index": {
          "description": "Binary products",
          "hierarchy": "Type Set",
          "module": "Type.Set",
          "name": ":×:",
          "package": "type-settheory",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#t::-215-:"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExtensional equality of sets\n\u003c/p\u003e",
          "module": "Type.Set",
          "name": ":==:",
          "package": "type-settheory",
          "source": "src/Type-Set.html#%3A%3D%3D%3A",
          "type": "data"
        },
        "index": {
          "description": "Extensional equality of sets",
          "hierarchy": "Type Set",
          "module": "Type.Set",
          "name": ":==:",
          "package": "type-settheory",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#t::-61--61-:"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Set",
          "name": ":∈:",
          "package": "type-settheory",
          "source": "src/Type-Set.html#%3A%2208%3A",
          "type": "type"
        },
        "index": {
          "hierarchy": "Type Set",
          "module": "Type.Set",
          "name": ":∈:",
          "package": "type-settheory",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#t::-8712-:"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eBinary intersection\n\u003c/p\u003e",
          "module": "Type.Set",
          "name": ":∩:",
          "package": "type-settheory",
          "source": "src/Type-Set.html#%3A%2229%3A",
          "type": "data"
        },
        "index": {
          "description": "Binary intersection",
          "hierarchy": "Type Set",
          "module": "Type.Set",
          "name": ":∩:",
          "package": "type-settheory",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#t::-8745-:"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eBinary union\n\u003c/p\u003e",
          "module": "Type.Set",
          "name": ":∪:",
          "package": "type-settheory",
          "source": "src/Type-Set.html#%3A%222A%3A",
          "type": "data"
        },
        "index": {
          "description": "Binary union",
          "hierarchy": "Type Set",
          "module": "Type.Set",
          "name": ":∪:",
          "package": "type-settheory",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#t::-8746-:"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRepresents a proof that \u003ccode\u003eset1\u003c/code\u003e is a subset of \u003ccode\u003eset2\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Type.Set",
          "name": ":⊆:",
          "package": "type-settheory",
          "source": "src/Type-Set.html#%3A%2286%3A",
          "type": "data"
        },
        "index": {
          "description": "Represents proof that set1 is subset of set2",
          "hierarchy": "Type Set",
          "module": "Type.Set",
          "name": ":⊆:",
          "package": "type-settheory",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#t::-8838-:"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMembership of a set in a set representing a set of sets\n\u003c/p\u003e",
          "module": "Type.Set",
          "name": "::∈:",
          "package": "type-settheory",
          "source": "src/Type-Set.html#%3A%3A%2208%3A",
          "type": "type"
        },
        "index": {
          "description": "Membership of set in set representing set of sets",
          "hierarchy": "Type Set",
          "module": "Type.Set",
          "name": "::∈:",
          "package": "type-settheory",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#t:::-8712-:"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Set",
          "name": "ApplicativeType",
          "package": "type-settheory",
          "source": "src/Type-Set.html#ApplicativeType",
          "type": "data"
        },
        "index": {
          "hierarchy": "Type Set",
          "module": "Type.Set",
          "name": "ApplicativeType",
          "package": "type-settheory",
          "partial": "Applicative Type",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#t:ApplicativeType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Set",
          "name": "BoundedType",
          "package": "type-settheory",
          "source": "src/Type-Set.html#BoundedType",
          "type": "data"
        },
        "index": {
          "hierarchy": "Type Set",
          "module": "Type.Set",
          "name": "BoundedType",
          "package": "type-settheory",
          "partial": "Bounded Type",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#t:BoundedType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Set",
          "name": "CoKleisliType",
          "package": "type-settheory",
          "source": "src/Type-Set.html#CoKleisliType",
          "type": "data"
        },
        "index": {
          "hierarchy": "Type Set",
          "module": "Type.Set",
          "name": "CoKleisliType",
          "package": "type-settheory",
          "partial": "Co Kleisli Type",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#t:CoKleisliType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eComplement\n\u003c/p\u003e",
          "module": "Type.Set",
          "name": "Complement",
          "package": "type-settheory",
          "source": "src/Type-Set.html#Complement",
          "type": "data"
        },
        "index": {
          "description": "Complement",
          "hierarchy": "Type Set",
          "module": "Type.Set",
          "name": "Complement",
          "package": "type-settheory",
          "partial": "Complement",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#t:Complement"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Set",
          "name": "DataType",
          "package": "type-settheory",
          "source": "src/Type-Set.html#DataType",
          "type": "data"
        },
        "index": {
          "hierarchy": "Type Set",
          "module": "Type.Set",
          "name": "DataType",
          "package": "type-settheory",
          "partial": "Data Type",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#t:DataType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Set",
          "name": "DependentSum",
          "package": "type-settheory",
          "source": "src/Type-Set.html#DependentSum",
          "type": "type"
        },
        "index": {
          "hierarchy": "Type Set",
          "module": "Type.Set",
          "name": "DependentSum",
          "package": "type-settheory",
          "partial": "Dependent Sum",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#t:DependentSum"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSet difference\n\u003c/p\u003e",
          "module": "Type.Set",
          "name": "Diff",
          "package": "type-settheory",
          "source": "src/Type-Set.html#Diff",
          "type": "data"
        },
        "index": {
          "description": "Set difference",
          "hierarchy": "Type Set",
          "module": "Type.Set",
          "name": "Diff",
          "package": "type-settheory",
          "partial": "Diff",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#t:Diff"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Set",
          "name": "Disjoint",
          "package": "type-settheory",
          "source": "src/Type-Set.html#Disjoint",
          "type": "type"
        },
        "index": {
          "hierarchy": "Type Set",
          "module": "Type.Set",
          "name": "Disjoint",
          "package": "type-settheory",
          "partial": "Disjoint",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#t:Disjoint"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEmpty set (barring cheating with \u003ccode\u003e\u003ca\u003eundefined\u003c/a\u003e\u003c/code\u003e)\n\u003c/p\u003e",
          "module": "Type.Set",
          "name": "Empty",
          "package": "type-settheory",
          "source": "src/Type-Set.html#Empty",
          "type": "data"
        },
        "index": {
          "description": "Empty set barring cheating with undefined",
          "hierarchy": "Type Set",
          "module": "Type.Set",
          "name": "Empty",
          "package": "type-settheory",
          "partial": "Empty",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#t:Empty"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Set",
          "name": "EnumType",
          "package": "type-settheory",
          "source": "src/Type-Set.html#EnumType",
          "type": "data"
        },
        "index": {
          "hierarchy": "Type Set",
          "module": "Type.Set",
          "name": "EnumType",
          "package": "type-settheory",
          "partial": "Enum Type",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#t:EnumType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Set",
          "name": "EqType",
          "package": "type-settheory",
          "source": "src/Type-Set.html#EqType",
          "type": "data"
        },
        "index": {
          "hierarchy": "Type Set",
          "module": "Type.Set",
          "name": "EqType",
          "package": "type-settheory",
          "partial": "Eq Type",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#t:EqType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUnique existence, unlowered\n\u003c/p\u003e",
          "module": "Type.Set",
          "name": "ExUniq1",
          "package": "type-settheory",
          "source": "src/Type-Set.html#ExUniq1",
          "type": "data"
        },
        "index": {
          "description": "Unique existence unlowered",
          "hierarchy": "Type Set",
          "module": "Type.Set",
          "name": "ExUniq1",
          "package": "type-settheory",
          "partial": "Ex Uniq",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#t:ExUniq1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Set",
          "name": "FractionalType",
          "package": "type-settheory",
          "source": "src/Type-Set.html#FractionalType",
          "type": "data"
        },
        "index": {
          "hierarchy": "Type Set",
          "module": "Type.Set",
          "name": "FractionalType",
          "package": "type-settheory",
          "partial": "Fractional Type",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#t:FractionalType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Set",
          "name": "FunctionType",
          "package": "type-settheory",
          "source": "src/Type-Set.html#FunctionType",
          "type": "data"
        },
        "index": {
          "hierarchy": "Type Set",
          "module": "Type.Set",
          "name": "FunctionType",
          "package": "type-settheory",
          "partial": "Function Type",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#t:FunctionType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Set",
          "name": "FunctorType",
          "package": "type-settheory",
          "source": "src/Type-Set.html#FunctorType",
          "type": "data"
        },
        "index": {
          "hierarchy": "Type Set",
          "module": "Type.Set",
          "name": "FunctorType",
          "package": "type-settheory",
          "partial": "Functor Type",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#t:FunctorType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Set",
          "name": "IntegralType",
          "package": "type-settheory",
          "source": "src/Type-Set.html#IntegralType",
          "type": "data"
        },
        "index": {
          "hierarchy": "Type Set",
          "module": "Type.Set",
          "name": "IntegralType",
          "package": "type-settheory",
          "partial": "Integral Type",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#t:IntegralType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Set",
          "name": "Inter",
          "package": "type-settheory",
          "source": "src/Type-Set.html#Inter",
          "type": "type"
        },
        "index": {
          "hierarchy": "Type Set",
          "module": "Type.Set",
          "name": "Inter",
          "package": "type-settheory",
          "partial": "Inter",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#t:Inter"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIntersection of a family\n\u003c/p\u003e",
          "module": "Type.Set",
          "name": "Inters",
          "package": "type-settheory",
          "source": "src/Type-Set.html#Inters",
          "type": "data"
        },
        "index": {
          "description": "Intersection of family",
          "hierarchy": "Type Set",
          "module": "Type.Set",
          "name": "Inters",
          "package": "type-settheory",
          "partial": "Inters",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#t:Inters"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Set",
          "name": "KleisliType",
          "package": "type-settheory",
          "source": "src/Type-Set.html#KleisliType",
          "type": "data"
        },
        "index": {
          "hierarchy": "Type Set",
          "module": "Type.Set",
          "name": "KleisliType",
          "package": "type-settheory",
          "partial": "Kleisli Type",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#t:KleisliType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Set",
          "name": "MonadPlusType",
          "package": "type-settheory",
          "source": "src/Type-Set.html#MonadPlusType",
          "type": "data"
        },
        "index": {
          "hierarchy": "Type Set",
          "module": "Type.Set",
          "name": "MonadPlusType",
          "package": "type-settheory",
          "partial": "Monad Plus Type",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#t:MonadPlusType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Set",
          "name": "MonadType",
          "package": "type-settheory",
          "source": "src/Type-Set.html#MonadType",
          "type": "data"
        },
        "index": {
          "hierarchy": "Type Set",
          "module": "Type.Set",
          "name": "MonadType",
          "package": "type-settheory",
          "partial": "Monad Type",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#t:MonadType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Set",
          "name": "MonoidType",
          "package": "type-settheory",
          "source": "src/Type-Set.html#MonoidType",
          "type": "data"
        },
        "index": {
          "hierarchy": "Type Set",
          "module": "Type.Set",
          "name": "MonoidType",
          "package": "type-settheory",
          "partial": "Monoid Type",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#t:MonoidType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Set",
          "name": "NumType",
          "package": "type-settheory",
          "source": "src/Type-Set.html#NumType",
          "type": "data"
        },
        "index": {
          "hierarchy": "Type Set",
          "module": "Type.Set",
          "name": "NumType",
          "package": "type-settheory",
          "partial": "Num Type",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#t:NumType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Set",
          "name": "OrdType",
          "package": "type-settheory",
          "source": "src/Type-Set.html#OrdType",
          "type": "data"
        },
        "index": {
          "hierarchy": "Type Set",
          "module": "Type.Set",
          "name": "OrdType",
          "package": "type-settheory",
          "partial": "Ord Type",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#t:OrdType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePowerset\n\u003c/p\u003e",
          "module": "Type.Set",
          "name": "Powerset",
          "package": "type-settheory",
          "source": "src/Type-Set.html#Powerset",
          "type": "data"
        },
        "index": {
          "description": "Powerset",
          "hierarchy": "Type Set",
          "module": "Type.Set",
          "name": "Powerset",
          "package": "type-settheory",
          "partial": "Powerset",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#t:Powerset"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Set",
          "name": "Prod",
          "package": "type-settheory",
          "source": "src/Type-Set.html#Prod",
          "type": "type"
        },
        "index": {
          "hierarchy": "Type Set",
          "module": "Type.Set",
          "name": "Prod",
          "package": "type-settheory",
          "partial": "Prod",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#t:Prod"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Set",
          "name": "ProofSet",
          "package": "type-settheory",
          "source": "src/Type-Set.html#ProofSet",
          "type": "data"
        },
        "index": {
          "hierarchy": "Type Set",
          "module": "Type.Set",
          "name": "ProofSet",
          "package": "type-settheory",
          "partial": "Proof Set",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#t:ProofSet"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Set",
          "name": "ReadType",
          "package": "type-settheory",
          "source": "src/Type-Set.html#ReadType",
          "type": "data"
        },
        "index": {
          "hierarchy": "Type Set",
          "module": "Type.Set",
          "name": "ReadType",
          "package": "type-settheory",
          "partial": "Read Type",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#t:ReadType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Set",
          "name": "ShowType",
          "package": "type-settheory",
          "source": "src/Type-Set.html#ShowType",
          "type": "data"
        },
        "index": {
          "hierarchy": "Type Set",
          "module": "Type.Set",
          "name": "ShowType",
          "package": "type-settheory",
          "partial": "Show Type",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#t:ShowType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Set",
          "name": "Singleton",
          "package": "type-settheory",
          "source": "src/Type-Set.html#Singleton",
          "type": "type"
        },
        "index": {
          "hierarchy": "Type Set",
          "module": "Type.Set",
          "name": "Singleton",
          "package": "type-settheory",
          "partial": "Singleton",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#t:Singleton"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Set",
          "name": "Subset",
          "package": "type-settheory",
          "source": "src/Type-Set.html#Subset",
          "type": "type"
        },
        "index": {
          "hierarchy": "Type Set",
          "module": "Type.Set",
          "name": "Subset",
          "package": "type-settheory",
          "partial": "Subset",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#t:Subset"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Set",
          "name": "TypeableType",
          "package": "type-settheory",
          "source": "src/Type-Set.html#TypeableType",
          "type": "data"
        },
        "index": {
          "hierarchy": "Type Set",
          "module": "Type.Set",
          "name": "TypeableType",
          "package": "type-settheory",
          "partial": "Typeable Type",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#t:TypeableType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Set",
          "name": "Union",
          "package": "type-settheory",
          "source": "src/Type-Set.html#Union",
          "type": "type"
        },
        "index": {
          "hierarchy": "Type Set",
          "module": "Type.Set",
          "name": "Union",
          "package": "type-settheory",
          "partial": "Union",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#t:Union"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUnion of a family\n\u003c/p\u003e",
          "module": "Type.Set",
          "name": "Unions",
          "package": "type-settheory",
          "source": "src/Type-Set.html#Unions",
          "type": "data"
        },
        "index": {
          "description": "Union of family",
          "hierarchy": "Type Set",
          "module": "Type.Set",
          "name": "Unions",
          "package": "type-settheory",
          "partial": "Unions",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#t:Unions"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSet of \u003cem\u003eall\u003c/em\u003e types of kind *\n\u003c/p\u003e",
          "module": "Type.Set",
          "name": "Univ",
          "package": "type-settheory",
          "source": "src/Type-Set.html#Univ",
          "type": "data"
        },
        "index": {
          "description": "Set of all types of kind",
          "hierarchy": "Type Set",
          "module": "Type.Set",
          "name": "Univ",
          "package": "type-settheory",
          "partial": "Univ",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#t:Univ"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eV s\u003c/code\u003e is the sum of all types \u003ccode\u003ex\u003c/code\u003e such that \u003ccode\u003es x\u003c/code\u003e is provable.\n\u003c/p\u003e",
          "module": "Type.Set",
          "name": "V",
          "package": "type-settheory",
          "source": "src/Type-Set.html#V",
          "type": "data"
        },
        "index": {
          "description": "is the sum of all types such that is provable",
          "hierarchy": "Type Set",
          "module": "Type.Set",
          "name": "V",
          "package": "type-settheory",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#t:V"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Set",
          "name": "Σ",
          "package": "type-settheory",
          "signature": "(Lower s :∈: fam) -\u003e (a :∈: s) -\u003e Σ fam (Lower s, a)",
          "source": "src/Type-Set.html#%3A3",
          "type": "function"
        },
        "index": {
          "hierarchy": "Type Set",
          "module": "Type.Set",
          "name": "Σ",
          "normalized": "(Lower a b)-\u003e(c a)-\u003eΣ b(Lower a,c)",
          "package": "type-settheory",
          "signature": "(Lower s fam)-\u003e(a s)-\u003eΣ fam(Lower s,a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#v:-931-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Set",
          "name": ":×:",
          "package": "type-settheory",
          "signature": "(a :∈: s1) -\u003e (b :∈: s2) -\u003e (s1 :×: s2) (a, b)",
          "source": "src/Type-Set.html#%3A%D7%3A",
          "type": "function"
        },
        "index": {
          "hierarchy": "Type Set",
          "module": "Type.Set",
          "name": ":×:",
          "normalized": "(a b)-\u003e(c b)-\u003e(b b)(a,c)",
          "package": "type-settheory",
          "signature": "(a s)-\u003e(b s)-\u003e(s s)(a,b)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#v::-215-:"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Set",
          "name": "ApplicativeType",
          "package": "type-settheory",
          "signature": "ApplicativeType (Lower a)",
          "source": "src/Type-Set.html#ApplicativeType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Type Set",
          "module": "Type.Set",
          "name": "ApplicativeType",
          "package": "type-settheory",
          "partial": "Applicative Type",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#v:ApplicativeType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Set",
          "name": "BoundedType",
          "package": "type-settheory",
          "signature": "BoundedType a",
          "source": "src/Type-Set.html#BoundedType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Type Set",
          "module": "Type.Set",
          "name": "BoundedType",
          "package": "type-settheory",
          "partial": "Bounded Type",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#v:BoundedType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Set",
          "name": "CoKleisliType",
          "package": "type-settheory",
          "signature": "CoKleisliType w (w a -\u003e b)",
          "source": "src/Type-Set.html#CoKleisliType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Type Set",
          "module": "Type.Set",
          "name": "CoKleisliType",
          "normalized": "CoKleisliType a(a b-\u003ec)",
          "package": "type-settheory",
          "partial": "Co Kleisli Type",
          "signature": "CoKleisliType w(w a-\u003eb)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#v:CoKleisliType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Set",
          "name": "Complement",
          "package": "type-settheory",
          "signature": "Not (a :∈: s) -\u003e Complement s a",
          "source": "src/Type-Set.html#Complement",
          "type": "function"
        },
        "index": {
          "hierarchy": "Type Set",
          "module": "Type.Set",
          "name": "Complement",
          "normalized": "Not(a b)-\u003eComplement b a",
          "package": "type-settheory",
          "partial": "Complement",
          "signature": "Not(a s)-\u003eComplement s a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#v:Complement"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Set",
          "name": "DataType",
          "package": "type-settheory",
          "signature": "DataType a",
          "source": "src/Type-Set.html#DataType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Type Set",
          "module": "Type.Set",
          "name": "DataType",
          "package": "type-settheory",
          "partial": "Data Type",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#v:DataType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Set",
          "name": "Diff",
          "package": "type-settheory",
          "signature": "(a :∈: s) -\u003e Not (a :∈: t) -\u003e Diff s t a",
          "source": "src/Type-Set.html#Diff",
          "type": "function"
        },
        "index": {
          "hierarchy": "Type Set",
          "module": "Type.Set",
          "name": "Diff",
          "normalized": "(a b)-\u003eNot(a c)-\u003eDiff b c a",
          "package": "type-settheory",
          "partial": "Diff",
          "signature": "(a s)-\u003eNot(a t)-\u003eDiff s t a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#v:Diff"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Set",
          "name": "Empty",
          "package": "type-settheory",
          "signature": "(forall b.  b) -\u003e Empty a",
          "source": "src/Type-Set.html#Empty",
          "type": "function"
        },
        "index": {
          "hierarchy": "Type Set",
          "module": "Type.Set",
          "name": "Empty",
          "normalized": "(a b c)-\u003eEmpty d",
          "package": "type-settheory",
          "partial": "Empty",
          "signature": "(forall b. b)-\u003eEmpty a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#v:Empty"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Set",
          "name": "EnumType",
          "package": "type-settheory",
          "signature": "EnumType a",
          "source": "src/Type-Set.html#EnumType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Type Set",
          "module": "Type.Set",
          "name": "EnumType",
          "package": "type-settheory",
          "partial": "Enum Type",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#v:EnumType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Set",
          "name": "EqType",
          "package": "type-settheory",
          "signature": "EqType a",
          "source": "src/Type-Set.html#EqType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Type Set",
          "module": "Type.Set",
          "name": "EqType",
          "package": "type-settheory",
          "partial": "Eq Type",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#v:EqType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Set",
          "name": "ExUniq1",
          "package": "type-settheory",
          "signature": "p b -\u003e (forall b'.  p b' -\u003e b :==: b') -\u003e ExUniq1 p",
          "source": "src/Type-Set.html#ExUniq1",
          "type": "function"
        },
        "index": {
          "hierarchy": "Type Set",
          "module": "Type.Set",
          "name": "ExUniq1",
          "normalized": "a b-\u003e(c d a e-\u003eb e)-\u003eExUniq a",
          "package": "type-settheory",
          "partial": "Ex Uniq",
          "signature": "p b-\u003e(forall b'. p b'-\u003eb b')-\u003eExUniq p",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#v:ExUniq1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Set",
          "name": "FractionalType",
          "package": "type-settheory",
          "signature": "FractionalType a",
          "source": "src/Type-Set.html#FractionalType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Type Set",
          "module": "Type.Set",
          "name": "FractionalType",
          "package": "type-settheory",
          "partial": "Fractional Type",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#v:FractionalType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Set",
          "name": "FunctionType",
          "package": "type-settheory",
          "signature": "FunctionType (a -\u003e b)",
          "source": "src/Type-Set.html#FunctionType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Type Set",
          "module": "Type.Set",
          "name": "FunctionType",
          "normalized": "FunctionType(a-\u003eb)",
          "package": "type-settheory",
          "partial": "Function Type",
          "signature": "FunctionType(a-\u003eb)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#v:FunctionType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Set",
          "name": "FunctorType",
          "package": "type-settheory",
          "signature": "FunctorType (Lower a)",
          "source": "src/Type-Set.html#FunctorType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Type Set",
          "module": "Type.Set",
          "name": "FunctorType",
          "package": "type-settheory",
          "partial": "Functor Type",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#v:FunctorType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Set",
          "name": "IntegralType",
          "package": "type-settheory",
          "signature": "IntegralType a",
          "source": "src/Type-Set.html#IntegralType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Type Set",
          "module": "Type.Set",
          "name": "IntegralType",
          "package": "type-settheory",
          "partial": "Integral Type",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#v:IntegralType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Set",
          "name": "Inter",
          "package": "type-settheory",
          "signature": "(a :∈: s1) -\u003e (a :∈: s2) -\u003e (s1 :∩: s2) a",
          "source": "src/Type-Set.html#%3A%2229%3A",
          "type": "function"
        },
        "index": {
          "hierarchy": "Type Set",
          "module": "Type.Set",
          "name": "Inter",
          "normalized": "(a b)-\u003e(a b)-\u003e(b b)a",
          "package": "type-settheory",
          "partial": "Inter",
          "signature": "(a s)-\u003e(a s)-\u003e(s s)a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#v:Inter"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Set",
          "name": "Inters",
          "package": "type-settheory",
          "signature": "(forall s.  (Lower s :∈: fam) -\u003e a :∈: s) -\u003e Inters fam a",
          "source": "src/Type-Set.html#Inters",
          "type": "function"
        },
        "index": {
          "hierarchy": "Type Set",
          "module": "Type.Set",
          "name": "Inters",
          "normalized": "(a b(Lower c d)-\u003ee c)-\u003eInters d e",
          "package": "type-settheory",
          "partial": "Inters",
          "signature": "(forall s.(Lower s fam)-\u003ea s)-\u003eInters fam a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#v:Inters"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Set",
          "name": "KleisliType",
          "package": "type-settheory",
          "signature": "KleisliType m (a -\u003e m b)",
          "source": "src/Type-Set.html#KleisliType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Type Set",
          "module": "Type.Set",
          "name": "KleisliType",
          "normalized": "KleisliType a(b-\u003ea c)",
          "package": "type-settheory",
          "partial": "Kleisli Type",
          "signature": "KleisliType m(a-\u003em b)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#v:KleisliType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Set",
          "name": "MonadPlusType",
          "package": "type-settheory",
          "signature": "MonadPlusType (Lower a)",
          "source": "src/Type-Set.html#MonadPlusType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Type Set",
          "module": "Type.Set",
          "name": "MonadPlusType",
          "package": "type-settheory",
          "partial": "Monad Plus Type",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#v:MonadPlusType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Set",
          "name": "MonadType",
          "package": "type-settheory",
          "signature": "MonadType (Lower a)",
          "source": "src/Type-Set.html#MonadType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Type Set",
          "module": "Type.Set",
          "name": "MonadType",
          "package": "type-settheory",
          "partial": "Monad Type",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#v:MonadType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Set",
          "name": "MonoidType",
          "package": "type-settheory",
          "signature": "MonoidType a",
          "source": "src/Type-Set.html#MonoidType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Type Set",
          "module": "Type.Set",
          "name": "MonoidType",
          "package": "type-settheory",
          "partial": "Monoid Type",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#v:MonoidType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Set",
          "name": "NumType",
          "package": "type-settheory",
          "signature": "NumType a",
          "source": "src/Type-Set.html#NumType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Type Set",
          "module": "Type.Set",
          "name": "NumType",
          "package": "type-settheory",
          "partial": "Num Type",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#v:NumType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Set",
          "name": "OrdType",
          "package": "type-settheory",
          "signature": "OrdType a",
          "source": "src/Type-Set.html#OrdType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Type Set",
          "module": "Type.Set",
          "name": "OrdType",
          "package": "type-settheory",
          "partial": "Ord Type",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#v:OrdType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Set",
          "name": "Powerset",
          "package": "type-settheory",
          "signature": "(s :⊆: u) -\u003e Powerset u (Lower s)",
          "source": "src/Type-Set.html#Powerset",
          "type": "function"
        },
        "index": {
          "hierarchy": "Type Set",
          "module": "Type.Set",
          "name": "Powerset",
          "normalized": "(a b)-\u003ePowerset b(Lower a)",
          "package": "type-settheory",
          "partial": "Powerset",
          "signature": "(s u)-\u003ePowerset u(Lower s)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#v:Powerset"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Set",
          "name": "ProofSet",
          "package": "type-settheory",
          "signature": "s x -\u003e ProofSet s (s x)",
          "source": "src/Type-Set.html#ProofSet",
          "type": "function"
        },
        "index": {
          "hierarchy": "Type Set",
          "module": "Type.Set",
          "name": "ProofSet",
          "normalized": "a b-\u003eProofSet a(a b)",
          "package": "type-settheory",
          "partial": "Proof Set",
          "signature": "s x-\u003eProofSet s(s x)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#v:ProofSet"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Set",
          "name": "ReadType",
          "package": "type-settheory",
          "signature": "ReadType a",
          "source": "src/Type-Set.html#ReadType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Type Set",
          "module": "Type.Set",
          "name": "ReadType",
          "package": "type-settheory",
          "partial": "Read Type",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#v:ReadType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Set",
          "name": "SetEq",
          "package": "type-settheory",
          "signature": "SetEq (set1 :⊆: set2) (set2 :⊆: set1)",
          "source": "src/Type-Set.html#%3A%3D%3D%3A",
          "type": "function"
        },
        "index": {
          "hierarchy": "Type Set",
          "module": "Type.Set",
          "name": "SetEq",
          "package": "type-settheory",
          "partial": "Set Eq",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#v:SetEq"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Set",
          "name": "ShowType",
          "package": "type-settheory",
          "signature": "ShowType a",
          "source": "src/Type-Set.html#ShowType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Type Set",
          "module": "Type.Set",
          "name": "ShowType",
          "package": "type-settheory",
          "partial": "Show Type",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#v:ShowType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Set",
          "name": "Subset",
          "package": "type-settheory",
          "signature": "(forall a.  (a :∈: set1) -\u003e a :∈: set2) -\u003e set1 :⊆: set2",
          "source": "src/Type-Set.html#%3A%2286%3A",
          "type": "function"
        },
        "index": {
          "hierarchy": "Type Set",
          "module": "Type.Set",
          "name": "Subset",
          "normalized": "(a b(c d)-\u003ec d)-\u003ed d",
          "package": "type-settheory",
          "partial": "Subset",
          "signature": "(forall a.(a set)-\u003ea set)-\u003eset set",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#v:Subset"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Set",
          "name": "TypeableType",
          "package": "type-settheory",
          "signature": "TypeableType a",
          "source": "src/Type-Set.html#TypeableType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Type Set",
          "module": "Type.Set",
          "name": "TypeableType",
          "package": "type-settheory",
          "partial": "Typeable Type",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#v:TypeableType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Set",
          "name": "Union",
          "package": "type-settheory",
          "signature": "Either (a :∈: s1) (a :∈: s2) -\u003e (s1 :∪: s2) a",
          "source": "src/Type-Set.html#%3A%222A%3A",
          "type": "function"
        },
        "index": {
          "hierarchy": "Type Set",
          "module": "Type.Set",
          "name": "Union",
          "normalized": "Either(a b)(a b)-\u003e(b b)a",
          "package": "type-settheory",
          "partial": "Union",
          "signature": "Either(a s)(a s)-\u003e(s s)a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#v:Union"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Set",
          "name": "Unions",
          "package": "type-settheory",
          "signature": "(Lower s :∈: fam) -\u003e (a :∈: s) -\u003e Unions fam a",
          "source": "src/Type-Set.html#Unions",
          "type": "function"
        },
        "index": {
          "hierarchy": "Type Set",
          "module": "Type.Set",
          "name": "Unions",
          "normalized": "(Lower a b)-\u003e(c a)-\u003eUnions b c",
          "package": "type-settheory",
          "partial": "Unions",
          "signature": "(Lower s fam)-\u003e(a s)-\u003eUnions fam a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#v:Unions"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Set",
          "name": "Univ",
          "package": "type-settheory",
          "signature": "Univ a",
          "source": "src/Type-Set.html#Univ",
          "type": "function"
        },
        "index": {
          "hierarchy": "Type Set",
          "module": "Type.Set",
          "name": "Univ",
          "package": "type-settheory",
          "partial": "Univ",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#v:Univ"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Set",
          "name": "V",
          "package": "type-settheory",
          "signature": "s x -\u003e x -\u003e V s",
          "source": "src/Type-Set.html#V",
          "type": "function"
        },
        "index": {
          "hierarchy": "Type Set",
          "module": "Type.Set",
          "name": "V",
          "normalized": "a b-\u003eb-\u003eV a",
          "package": "type-settheory",
          "signature": "s x-\u003ex-\u003eV s",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#v:V"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Set",
          "name": "autoequality",
          "package": "type-settheory",
          "signature": "s :==: t",
          "source": "src/Type-Set.html#autoequality",
          "type": "function"
        },
        "index": {
          "hierarchy": "Type Set",
          "module": "Type.Set",
          "name": "autoequality",
          "package": "type-settheory",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#v:autoequality"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Set",
          "name": "autosubset",
          "package": "type-settheory",
          "signature": "s :⊆: t",
          "source": "src/Type-Set.html#autosubset",
          "type": "function"
        },
        "index": {
          "hierarchy": "Type Set",
          "module": "Type.Set",
          "name": "autosubset",
          "package": "type-settheory",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#v:autosubset"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Set",
          "name": "coKleisliType",
          "package": "type-settheory",
          "signature": "(w a -\u003e b) :∈: CoKleisliType w",
          "source": "src/Type-Set.html#coKleisliType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Type Set",
          "module": "Type.Set",
          "name": "coKleisliType",
          "normalized": "(a b-\u003ec)CoKleisliType a",
          "package": "type-settheory",
          "partial": "Kleisli Type",
          "signature": "(w a-\u003eb)CoKleisliType w",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#v:coKleisliType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Set",
          "name": "complContradiction",
          "package": "type-settheory",
          "signature": "Not (s a, Complement s a)",
          "source": "src/Type-Set.html#complContradiction",
          "type": "function"
        },
        "index": {
          "hierarchy": "Type Set",
          "module": "Type.Set",
          "name": "complContradiction",
          "normalized": "Not(a b,Complement a b)",
          "package": "type-settheory",
          "partial": "Contradiction",
          "signature": "Not(s a,Complement s a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#v:complContradiction"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Set",
          "name": "complEmpty",
          "package": "type-settheory",
          "signature": "Disjoint s (Complement s)",
          "source": "src/Type-Set.html#complEmpty",
          "type": "function"
        },
        "index": {
          "hierarchy": "Type Set",
          "module": "Type.Set",
          "name": "complEmpty",
          "package": "type-settheory",
          "partial": "Empty",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#v:complEmpty"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Set",
          "name": "complMaximal",
          "package": "type-settheory",
          "signature": "Disjoint s t -\u003e t :⊆: Complement s",
          "source": "src/Type-Set.html#complMaximal",
          "type": "function"
        },
        "index": {
          "hierarchy": "Type Set",
          "module": "Type.Set",
          "name": "complMaximal",
          "normalized": "Disjoint a b-\u003eb Complement a",
          "package": "type-settheory",
          "partial": "Maximal",
          "signature": "Disjoint s t-\u003et Complement s",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#v:complMaximal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCoercion using a set equality\n\u003c/p\u003e",
          "module": "Type.Set",
          "name": "ecoerce",
          "package": "type-settheory",
          "signature": "(s1 :==: s2) -\u003e (a :∈: s1) -\u003e a :∈: s2",
          "source": "src/Type-Set.html#ecoerce",
          "type": "function"
        },
        "index": {
          "description": "Coercion using set equality",
          "hierarchy": "Type Set",
          "module": "Type.Set",
          "name": "ecoerce",
          "normalized": "(a a)-\u003e(b a)-\u003eb a",
          "package": "type-settheory",
          "signature": "(s s)-\u003e(a s)-\u003ea s",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#v:ecoerce"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCoercion using a set equality (flipped)\n\u003c/p\u003e",
          "module": "Type.Set",
          "name": "ecoerceFlip",
          "package": "type-settheory",
          "signature": "(s1 :==: s2) -\u003e (a :∈: s2) -\u003e a :∈: s1",
          "source": "src/Type-Set.html#ecoerceFlip",
          "type": "function"
        },
        "index": {
          "description": "Coercion using set equality flipped",
          "hierarchy": "Type Set",
          "module": "Type.Set",
          "name": "ecoerceFlip",
          "normalized": "(a a)-\u003e(b a)-\u003eb a",
          "package": "type-settheory",
          "partial": "Flip",
          "signature": "(s s)-\u003e(a s)-\u003ea s",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#v:ecoerceFlip"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Set",
          "name": "elimComplement",
          "package": "type-settheory",
          "signature": "(a :∈: Complement s) -\u003e Not (a :∈: s)",
          "source": "src/Type-Set.html#elimComplement",
          "type": "function"
        },
        "index": {
          "hierarchy": "Type Set",
          "module": "Type.Set",
          "name": "elimComplement",
          "normalized": "(a Complement b)-\u003eNot(a b)",
          "package": "type-settheory",
          "partial": "Complement",
          "signature": "(a Complement s)-\u003eNot(a s)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#v:elimComplement"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Set",
          "name": "elimDiff",
          "package": "type-settheory",
          "signature": "(a :∈: Diff s t) -\u003e (a :∈: s, Not (a :∈: t))",
          "source": "src/Type-Set.html#elimDiff",
          "type": "function"
        },
        "index": {
          "hierarchy": "Type Set",
          "module": "Type.Set",
          "name": "elimDiff",
          "normalized": "(a Diff b c)-\u003e(a b,Not(a c))",
          "package": "type-settheory",
          "partial": "Diff",
          "signature": "(a Diff s t)-\u003e(a s,Not(a t))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#v:elimDiff"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Set",
          "name": "elimEmpty",
          "package": "type-settheory",
          "signature": "Empty a -\u003e b",
          "source": "src/Type-Set.html#elimEmpty",
          "type": "function"
        },
        "index": {
          "hierarchy": "Type Set",
          "module": "Type.Set",
          "name": "elimEmpty",
          "normalized": "Empty a-\u003eb",
          "package": "type-settheory",
          "partial": "Empty",
          "signature": "Empty a-\u003eb",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#v:elimEmpty"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Set",
          "name": "elimInter",
          "package": "type-settheory",
          "signature": "(a :∈: (s1 :∩: s2)) -\u003e (a :∈: s1, a :∈: s2)",
          "source": "src/Type-Set.html#elimInter",
          "type": "function"
        },
        "index": {
          "hierarchy": "Type Set",
          "module": "Type.Set",
          "name": "elimInter",
          "normalized": "(a(b b))-\u003e(a b,a b)",
          "package": "type-settheory",
          "partial": "Inter",
          "signature": "(a(s s))-\u003e(a s,a s)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#v:elimInter"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Set",
          "name": "elimInters",
          "package": "type-settheory",
          "signature": "Inters fam a -\u003e (Lower s :∈: fam) -\u003e s a",
          "source": "src/Type-Set.html#elimInters",
          "type": "function"
        },
        "index": {
          "hierarchy": "Type Set",
          "module": "Type.Set",
          "name": "elimInters",
          "normalized": "Inters a b-\u003e(Lower c a)-\u003ec b",
          "package": "type-settheory",
          "partial": "Inters",
          "signature": "Inters fam a-\u003e(Lower s fam)-\u003es a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#v:elimInters"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Set",
          "name": "elimUnion",
          "package": "type-settheory",
          "signature": "(a :∈: (s1 :∪: s2)) -\u003e Either (a :∈: s1) (a :∈: s2)",
          "source": "src/Type-Set.html#elimUnion",
          "type": "function"
        },
        "index": {
          "hierarchy": "Type Set",
          "module": "Type.Set",
          "name": "elimUnion",
          "normalized": "(a(b b))-\u003eEither(a b)(a b)",
          "package": "type-settheory",
          "partial": "Union",
          "signature": "(a(s s))-\u003eEither(a s)(a s)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#v:elimUnion"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Set",
          "name": "elimUnions",
          "package": "type-settheory",
          "signature": "Unions fam a -\u003e (forall s.  (Lower s :∈: fam) -\u003e (a :∈: s) -\u003e r) -\u003e r",
          "source": "src/Type-Set.html#elimUnions",
          "type": "function"
        },
        "index": {
          "hierarchy": "Type Set",
          "module": "Type.Set",
          "name": "elimUnions",
          "normalized": "Unions a b-\u003e(c d(Lower e a)-\u003e(b e)-\u003ef)-\u003ef",
          "package": "type-settheory",
          "partial": "Unions",
          "signature": "Unions fam a-\u003e(forall s.(Lower s fam)-\u003e(a s)-\u003er)-\u003er",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#v:elimUnions"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Set",
          "name": "emptySubset",
          "package": "type-settheory",
          "signature": "Empty :⊆: s",
          "source": "src/Type-Set.html#emptySubset",
          "type": "function"
        },
        "index": {
          "hierarchy": "Type Set",
          "module": "Type.Set",
          "name": "emptySubset",
          "package": "type-settheory",
          "partial": "Subset",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#v:emptySubset"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Set",
          "name": "fstPrf",
          "package": "type-settheory",
          "signature": "((a, b) :∈: (s1 :×: s2)) -\u003e a :∈: s1",
          "source": "src/Type-Set.html#fstPrf",
          "type": "function"
        },
        "index": {
          "hierarchy": "Type Set",
          "module": "Type.Set",
          "name": "fstPrf",
          "normalized": "((a,b)(c c))-\u003ea c",
          "package": "type-settheory",
          "partial": "Prf",
          "signature": "((a,b)(s s))-\u003ea s",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#v:fstPrf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Set",
          "name": "functionType",
          "package": "type-settheory",
          "signature": "(a -\u003e b) :∈: FunctionType",
          "source": "src/Type-Set.html#functionType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Type Set",
          "module": "Type.Set",
          "name": "functionType",
          "normalized": "(a-\u003eb)FunctionType",
          "package": "type-settheory",
          "partial": "Type",
          "signature": "(a-\u003eb)FunctionType",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#v:functionType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Set",
          "name": "getCompare",
          "package": "type-settheory",
          "signature": "(a :∈: OrdType) -\u003e a -\u003e a -\u003e Ordering",
          "source": "src/Type-Set.html#getCompare",
          "type": "function"
        },
        "index": {
          "hierarchy": "Type Set",
          "module": "Type.Set",
          "name": "getCompare",
          "normalized": "(a OrdType)-\u003ea-\u003ea-\u003eOrdering",
          "package": "type-settheory",
          "partial": "Compare",
          "signature": "(a OrdType)-\u003ea-\u003ea-\u003eOrdering",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#v:getCompare"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Set",
          "name": "getEq",
          "package": "type-settheory",
          "signature": "(a :∈: EqType) -\u003e a -\u003e a -\u003e Bool",
          "source": "src/Type-Set.html#getEq",
          "type": "function"
        },
        "index": {
          "hierarchy": "Type Set",
          "module": "Type.Set",
          "name": "getEq",
          "normalized": "(a EqType)-\u003ea-\u003ea-\u003eBool",
          "package": "type-settheory",
          "partial": "Eq",
          "signature": "(a EqType)-\u003ea-\u003ea-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#v:getEq"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Set",
          "name": "getFmap",
          "package": "type-settheory",
          "signature": "(Lower f :∈: FunctorType) -\u003e (a -\u003e b) -\u003e f a -\u003e f b",
          "source": "src/Type-Set.html#getFmap",
          "type": "function"
        },
        "index": {
          "hierarchy": "Type Set",
          "module": "Type.Set",
          "name": "getFmap",
          "normalized": "(Lower a FunctorType)-\u003e(b-\u003ec)-\u003ea b-\u003ea c",
          "package": "type-settheory",
          "partial": "Fmap",
          "signature": "(Lower f FunctorType)-\u003e(a-\u003eb)-\u003ef a-\u003ef b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#v:getFmap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExample application\n\u003c/p\u003e",
          "module": "Type.Set",
          "name": "getShow",
          "package": "type-settheory",
          "signature": "(a :∈: ShowType) -\u003e a -\u003e String",
          "source": "src/Type-Set.html#getShow",
          "type": "function"
        },
        "index": {
          "description": "Example application",
          "hierarchy": "Type Set",
          "module": "Type.Set",
          "name": "getShow",
          "normalized": "(a ShowType)-\u003ea-\u003eString",
          "package": "type-settheory",
          "partial": "Show",
          "signature": "(a ShowType)-\u003ea-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#v:getShow"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Set",
          "name": "interFst",
          "package": "type-settheory",
          "signature": "(s1 :∩: s2) :⊆: s1",
          "source": "src/Type-Set.html#interFst",
          "type": "function"
        },
        "index": {
          "hierarchy": "Type Set",
          "module": "Type.Set",
          "name": "interFst",
          "package": "type-settheory",
          "partial": "Fst",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#v:interFst"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Set",
          "name": "interIdempotent",
          "package": "type-settheory",
          "signature": "(s :∩: s) :==: s",
          "source": "src/Type-Set.html#interIdempotent",
          "type": "function"
        },
        "index": {
          "hierarchy": "Type Set",
          "module": "Type.Set",
          "name": "interIdempotent",
          "package": "type-settheory",
          "partial": "Idempotent",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#v:interIdempotent"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Set",
          "name": "interMaximal",
          "package": "type-settheory",
          "signature": "(t :⊆: s1) -\u003e (t :⊆: s2) -\u003e t :⊆: (s1 :∩: s2)",
          "source": "src/Type-Set.html#interMaximal",
          "type": "function"
        },
        "index": {
          "hierarchy": "Type Set",
          "module": "Type.Set",
          "name": "interMaximal",
          "normalized": "(a b)-\u003e(a b)-\u003ea(b b)",
          "package": "type-settheory",
          "partial": "Maximal",
          "signature": "(t s)-\u003e(t s)-\u003et(s s)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#v:interMaximal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Set",
          "name": "interSnd",
          "package": "type-settheory",
          "signature": "(s1 :∩: s2) :⊆: s2",
          "source": "src/Type-Set.html#interSnd",
          "type": "function"
        },
        "index": {
          "hierarchy": "Type Set",
          "module": "Type.Set",
          "name": "interSnd",
          "package": "type-settheory",
          "partial": "Snd",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#v:interSnd"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Set",
          "name": "kleisliType",
          "package": "type-settheory",
          "signature": "(a -\u003e m b) :∈: KleisliType m",
          "source": "src/Type-Set.html#kleisliType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Type Set",
          "module": "Type.Set",
          "name": "kleisliType",
          "normalized": "(a-\u003eb c)KleisliType b",
          "package": "type-settheory",
          "partial": "Type",
          "signature": "(a-\u003em b)KleisliType m",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#v:kleisliType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Set",
          "name": "liftCompare",
          "package": "type-settheory",
          "signature": "(s :⊆: OrdType) -\u003e (s :⊆: TypeableType) -\u003e V s -\u003e V s -\u003e Ordering",
          "source": "src/Type-Set.html#liftCompare",
          "type": "function"
        },
        "index": {
          "hierarchy": "Type Set",
          "module": "Type.Set",
          "name": "liftCompare",
          "normalized": "(a OrdType)-\u003e(a TypeableType)-\u003eV a-\u003eV a-\u003eOrdering",
          "package": "type-settheory",
          "partial": "Compare",
          "signature": "(s OrdType)-\u003e(s TypeableType)-\u003eV s-\u003eV s-\u003eOrdering",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#v:liftCompare"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Set",
          "name": "liftEq",
          "package": "type-settheory",
          "signature": "(s :⊆: EqType) -\u003e (s :⊆: TypeableType) -\u003e V s -\u003e V s -\u003e Bool",
          "source": "src/Type-Set.html#liftEq",
          "type": "function"
        },
        "index": {
          "hierarchy": "Type Set",
          "module": "Type.Set",
          "name": "liftEq",
          "normalized": "(a EqType)-\u003e(a TypeableType)-\u003eV a-\u003eV a-\u003eBool",
          "package": "type-settheory",
          "partial": "Eq",
          "signature": "(s EqType)-\u003e(s TypeableType)-\u003eV s-\u003eV s-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#v:liftEq"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Set",
          "name": "liftShowsPrec",
          "package": "type-settheory",
          "signature": "(s :⊆: ShowType) -\u003e (s :⊆: TypeableType) -\u003e Int -\u003e V s -\u003e ShowS",
          "source": "src/Type-Set.html#liftShowsPrec",
          "type": "function"
        },
        "index": {
          "hierarchy": "Type Set",
          "module": "Type.Set",
          "name": "liftShowsPrec",
          "normalized": "(a ShowType)-\u003e(a TypeableType)-\u003eInt-\u003eV a-\u003eShowS",
          "package": "type-settheory",
          "partial": "Shows Prec",
          "signature": "(s ShowType)-\u003e(s TypeableType)-\u003eInt-\u003eV s-\u003eShowS",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#v:liftShowsPrec"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Set",
          "name": "powersetClosedDownwards",
          "package": "type-settheory",
          "signature": "∈: Powerset u",
          "source": "src/Type-Set.html#powersetClosedDownwards",
          "type": "function"
        },
        "index": {
          "hierarchy": "Type Set",
          "module": "Type.Set",
          "name": "powersetClosedDownwards",
          "package": "type-settheory",
          "partial": "Closed Downwards",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#v:powersetClosedDownwards"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Set",
          "name": "powersetEmpty",
          "package": "type-settheory",
          "signature": "∈: Powerset u",
          "source": "src/Type-Set.html#powersetEmpty",
          "type": "function"
        },
        "index": {
          "hierarchy": "Type Set",
          "module": "Type.Set",
          "name": "powersetEmpty",
          "package": "type-settheory",
          "partial": "Empty",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#v:powersetEmpty"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Set",
          "name": "powersetInter",
          "package": "type-settheory",
          "signature": "∈: Powerset u",
          "source": "src/Type-Set.html#powersetInter",
          "type": "function"
        },
        "index": {
          "hierarchy": "Type Set",
          "module": "Type.Set",
          "name": "powersetInter",
          "package": "type-settheory",
          "partial": "Inter",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#v:powersetInter"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Set",
          "name": "powersetMonotonic",
          "package": "type-settheory",
          "signature": "∈: Powerset u2",
          "source": "src/Type-Set.html#powersetMonotonic",
          "type": "function"
        },
        "index": {
          "hierarchy": "Type Set",
          "module": "Type.Set",
          "name": "powersetMonotonic",
          "package": "type-settheory",
          "partial": "Monotonic",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#v:powersetMonotonic"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Set",
          "name": "powersetUnion",
          "package": "type-settheory",
          "signature": "∈: Powerset u",
          "source": "src/Type-Set.html#powersetUnion",
          "type": "function"
        },
        "index": {
          "hierarchy": "Type Set",
          "module": "Type.Set",
          "name": "powersetUnion",
          "package": "type-settheory",
          "partial": "Union",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#v:powersetUnion"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Set",
          "name": "powersetWholeset",
          "package": "type-settheory",
          "signature": "∈: Powerset u",
          "source": "src/Type-Set.html#powersetWholeset",
          "type": "function"
        },
        "index": {
          "hierarchy": "Type Set",
          "module": "Type.Set",
          "name": "powersetWholeset",
          "package": "type-settheory",
          "partial": "Wholeset",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#v:powersetWholeset"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eProduct is monotonic wrt. subset inclusion\n\u003c/p\u003e",
          "module": "Type.Set",
          "name": "prodMonotonic",
          "package": "type-settheory",
          "signature": "(s1 :⊆: t1) -\u003e (s2 :⊆: t2) -\u003e (s1 :×: s2) :⊆: (t1 :×: t2)",
          "source": "src/Type-Set.html#prodMonotonic",
          "type": "function"
        },
        "index": {
          "description": "Product is monotonic wrt subset inclusion",
          "hierarchy": "Type Set",
          "module": "Type.Set",
          "name": "prodMonotonic",
          "normalized": "(a b)-\u003e(a b)-\u003e(a a)(b b)",
          "package": "type-settheory",
          "partial": "Monotonic",
          "signature": "(s t)-\u003e(s t)-\u003e(s s)(t t)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#v:prodMonotonic"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCoercion from subset to superset\n\u003c/p\u003e",
          "module": "Type.Set",
          "name": "scoerce",
          "package": "type-settheory",
          "signature": "(set1 :⊆: set2) -\u003e (a :∈: set1) -\u003e a :∈: set2",
          "source": "src/Type-Set.html#scoerce",
          "type": "function"
        },
        "index": {
          "description": "Coercion from subset to superset",
          "hierarchy": "Type Set",
          "module": "Type.Set",
          "name": "scoerce",
          "normalized": "(a a)-\u003e(b a)-\u003eb a",
          "package": "type-settheory",
          "signature": "(set set)-\u003e(a set)-\u003ea set",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#v:scoerce"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Set",
          "name": "setEqRefl",
          "package": "type-settheory",
          "signature": "s :==: s",
          "source": "src/Type-Set.html#setEqRefl",
          "type": "function"
        },
        "index": {
          "hierarchy": "Type Set",
          "module": "Type.Set",
          "name": "setEqRefl",
          "package": "type-settheory",
          "partial": "Eq Refl",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#v:setEqRefl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Set",
          "name": "setEqSym",
          "package": "type-settheory",
          "signature": "(s1 :==: s2) -\u003e s2 :==: s1",
          "source": "src/Type-Set.html#setEqSym",
          "type": "function"
        },
        "index": {
          "hierarchy": "Type Set",
          "module": "Type.Set",
          "name": "setEqSym",
          "normalized": "(a a)-\u003ea a",
          "package": "type-settheory",
          "partial": "Eq Sym",
          "signature": "(s s)-\u003es s",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#v:setEqSym"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Set",
          "name": "setEqTrans",
          "package": "type-settheory",
          "signature": "(s1 :==: s2) -\u003e (s2 :==: s3) -\u003e s1 :==: s3",
          "source": "src/Type-Set.html#setEqTrans",
          "type": "function"
        },
        "index": {
          "hierarchy": "Type Set",
          "module": "Type.Set",
          "name": "setEqTrans",
          "normalized": "(a a)-\u003e(a a)-\u003ea a",
          "package": "type-settheory",
          "partial": "Eq Trans",
          "signature": "(s s)-\u003e(s s)-\u003es s",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#v:setEqTrans"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Set",
          "name": "sndPrf",
          "package": "type-settheory",
          "signature": "((a, b) :∈: (s1 :×: s2)) -\u003e b :∈: s2",
          "source": "src/Type-Set.html#sndPrf",
          "type": "function"
        },
        "index": {
          "hierarchy": "Type Set",
          "module": "Type.Set",
          "name": "sndPrf",
          "normalized": "((a,b)(c c))-\u003eb c",
          "package": "type-settheory",
          "partial": "Prf",
          "signature": "((a,b)(s s))-\u003eb s",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#v:sndPrf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Set",
          "name": "subsetRefl",
          "package": "type-settheory",
          "signature": "s :⊆: s",
          "source": "src/Type-Set.html#subsetRefl",
          "type": "function"
        },
        "index": {
          "hierarchy": "Type Set",
          "module": "Type.Set",
          "name": "subsetRefl",
          "package": "type-settheory",
          "partial": "Refl",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#v:subsetRefl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Set",
          "name": "subsetTrans",
          "package": "type-settheory",
          "signature": "(s1 :⊆: s2) -\u003e (s2 :⊆: s3) -\u003e s1 :⊆: s3",
          "source": "src/Type-Set.html#subsetTrans",
          "type": "function"
        },
        "index": {
          "hierarchy": "Type Set",
          "module": "Type.Set",
          "name": "subsetTrans",
          "normalized": "(a a)-\u003e(a a)-\u003ea a",
          "package": "type-settheory",
          "partial": "Trans",
          "signature": "(s s)-\u003e(s s)-\u003es s",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#v:subsetTrans"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Set",
          "name": "unionIdempotent",
          "package": "type-settheory",
          "signature": "(s :∪: s) :==: s",
          "source": "src/Type-Set.html#unionIdempotent",
          "type": "function"
        },
        "index": {
          "hierarchy": "Type Set",
          "module": "Type.Set",
          "name": "unionIdempotent",
          "package": "type-settheory",
          "partial": "Idempotent",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#v:unionIdempotent"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Set",
          "name": "unionL",
          "package": "type-settheory",
          "signature": "s1 :⊆: (s1 :∪: s2)",
          "source": "src/Type-Set.html#unionL",
          "type": "function"
        },
        "index": {
          "hierarchy": "Type Set",
          "module": "Type.Set",
          "name": "unionL",
          "package": "type-settheory",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#v:unionL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Set",
          "name": "unionMinimal",
          "package": "type-settheory",
          "signature": "(s1 :⊆: t) -\u003e (s2 :⊆: t) -\u003e (s1 :∪: s2) :⊆: t",
          "source": "src/Type-Set.html#unionMinimal",
          "type": "function"
        },
        "index": {
          "hierarchy": "Type Set",
          "module": "Type.Set",
          "name": "unionMinimal",
          "normalized": "(a b)-\u003e(a b)-\u003e(a a)b",
          "package": "type-settheory",
          "partial": "Minimal",
          "signature": "(s t)-\u003e(s t)-\u003e(s s)t",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#v:unionMinimal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Set",
          "name": "unionR",
          "package": "type-settheory",
          "signature": "s2 :⊆: (s1 :∪: s2)",
          "source": "src/Type-Set.html#unionR",
          "type": "function"
        },
        "index": {
          "hierarchy": "Type Set",
          "module": "Type.Set",
          "name": "unionR",
          "package": "type-settheory",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#v:unionR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Type.Set",
          "name": "univSubset",
          "package": "type-settheory",
          "signature": "s :⊆: Univ",
          "source": "src/Type-Set.html#univSubset",
          "type": "function"
        },
        "index": {
          "hierarchy": "Type Set",
          "module": "Type.Set",
          "name": "univSubset",
          "package": "type-settheory",
          "partial": "Subset",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-settheory/docs/Type-Set.html#v:univSubset"
      }
    }
  ]
]