[
  {
    "cmd": "delete-by-query",
    "query": {
      "contexts": [
        "package"
      ],
      "query": {
        "op": "case",
        "type": "word",
        "word": "derive"
      },
      "type": "context"
    }
  },
  [
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module provides convenience re-exports of all the standard\n Data.Derive derivations.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.Derive.All",
          "name": "All",
          "package": "derive",
          "source": "src/Data-Derive-All.html",
          "type": "module"
        },
        "index": {
          "description": "This module provides convenience re-exports of all the standard Data.Derive derivations",
          "hierarchy": "Data Derive All",
          "module": "Data.Derive.All",
          "name": "All",
          "package": "derive",
          "partial": "All",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-All.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Derive.All",
          "name": "Derivation",
          "package": "derive",
          "source": "src/Data-Derive-Internal-Derivation.html#Derivation",
          "type": "data"
        },
        "index": {
          "hierarchy": "Data Derive All",
          "module": "Data.Derive.All",
          "name": "Derivation",
          "package": "derive",
          "partial": "Derivation",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-All.html#t:Derivation"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Derive.All",
          "name": "derivations",
          "package": "derive",
          "signature": "[Derivation]",
          "source": "src/Data-Derive-All.html#derivations",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Derive All",
          "module": "Data.Derive.All",
          "name": "derivations",
          "normalized": "[Derivation]",
          "package": "derive",
          "signature": "[Derivation]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-All.html#v:derivations"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Derive.Arbitrary",
          "name": "Arbitrary",
          "package": "derive",
          "source": "src/Data-Derive-Arbitrary.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Data Derive Arbitrary",
          "module": "Data.Derive.Arbitrary",
          "name": "Arbitrary",
          "package": "derive",
          "partial": "Arbitrary",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-Arbitrary.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Derive.Arbitrary",
          "name": "makeArbitrary",
          "package": "derive",
          "signature": "Derivation",
          "source": "src/Data-Derive-Arbitrary.html#makeArbitrary",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Derive Arbitrary",
          "module": "Data.Derive.Arbitrary",
          "name": "makeArbitrary",
          "package": "derive",
          "partial": "Arbitrary",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-Arbitrary.html#v:makeArbitrary"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Derive.ArbitraryOld",
          "name": "ArbitraryOld",
          "package": "derive",
          "source": "src/Data-Derive-ArbitraryOld.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Data Derive ArbitraryOld",
          "module": "Data.Derive.ArbitraryOld",
          "name": "ArbitraryOld",
          "package": "derive",
          "partial": "Arbitrary Old",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-ArbitraryOld.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Derive.ArbitraryOld",
          "name": "dslArbitraryOld",
          "package": "derive",
          "signature": "DSL",
          "source": "src/Data-Derive-ArbitraryOld.html#dslArbitraryOld",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Derive ArbitraryOld",
          "module": "Data.Derive.ArbitraryOld",
          "name": "dslArbitraryOld",
          "package": "derive",
          "partial": "Arbitrary Old",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-ArbitraryOld.html#v:dslArbitraryOld"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Derive.ArbitraryOld",
          "name": "makeArbitraryOld",
          "package": "derive",
          "signature": "Derivation",
          "source": "src/Data-Derive-ArbitraryOld.html#makeArbitraryOld",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Derive ArbitraryOld",
          "module": "Data.Derive.ArbitraryOld",
          "name": "makeArbitraryOld",
          "package": "derive",
          "partial": "Arbitrary Old",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-ArbitraryOld.html#v:makeArbitraryOld"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Derive.Arities",
          "name": "Arities",
          "package": "derive",
          "source": "src/Data-Derive-Arities.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Data Derive Arities",
          "module": "Data.Derive.Arities",
          "name": "Arities",
          "package": "derive",
          "partial": "Arities",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-Arities.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Derive.Arities",
          "name": "dslArities",
          "package": "derive",
          "signature": "DSL",
          "source": "src/Data-Derive-Arities.html#dslArities",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Derive Arities",
          "module": "Data.Derive.Arities",
          "name": "dslArities",
          "package": "derive",
          "partial": "Arities",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-Arities.html#v:dslArities"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Derive.Arities",
          "name": "makeArities",
          "package": "derive",
          "signature": "Derivation",
          "source": "src/Data-Derive-Arities.html#makeArities",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Derive Arities",
          "module": "Data.Derive.Arities",
          "name": "makeArities",
          "package": "derive",
          "partial": "Arities",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-Arities.html#v:makeArities"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Derive.Binary",
          "name": "Binary",
          "package": "derive",
          "source": "src/Data-Derive-Binary.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Data Derive Binary",
          "module": "Data.Derive.Binary",
          "name": "Binary",
          "package": "derive",
          "partial": "Binary",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-Binary.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Derive.Binary",
          "name": "dslBinary",
          "package": "derive",
          "signature": "DSL",
          "source": "src/Data-Derive-Binary.html#dslBinary",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Derive Binary",
          "module": "Data.Derive.Binary",
          "name": "dslBinary",
          "package": "derive",
          "partial": "Binary",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-Binary.html#v:dslBinary"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Derive.Binary",
          "name": "makeBinary",
          "package": "derive",
          "signature": "Derivation",
          "source": "src/Data-Derive-Binary.html#makeBinary",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Derive Binary",
          "module": "Data.Derive.Binary",
          "name": "makeBinary",
          "package": "derive",
          "partial": "Binary",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-Binary.html#v:makeBinary"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Derive.BinaryDefer",
          "name": "BinaryDefer",
          "package": "derive",
          "source": "src/Data-Derive-BinaryDefer.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Data Derive BinaryDefer",
          "module": "Data.Derive.BinaryDefer",
          "name": "BinaryDefer",
          "package": "derive",
          "partial": "Binary Defer",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-BinaryDefer.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Derive.BinaryDefer",
          "name": "dslBinaryDefer",
          "package": "derive",
          "signature": "DSL",
          "source": "src/Data-Derive-BinaryDefer.html#dslBinaryDefer",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Derive BinaryDefer",
          "module": "Data.Derive.BinaryDefer",
          "name": "dslBinaryDefer",
          "package": "derive",
          "partial": "Binary Defer",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-BinaryDefer.html#v:dslBinaryDefer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Derive.BinaryDefer",
          "name": "makeBinaryDefer",
          "package": "derive",
          "signature": "Derivation",
          "source": "src/Data-Derive-BinaryDefer.html#makeBinaryDefer",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Derive BinaryDefer",
          "module": "Data.Derive.BinaryDefer",
          "name": "makeBinaryDefer",
          "package": "derive",
          "partial": "Binary Defer",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-BinaryDefer.html#v:makeBinaryDefer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Derive.Bounded",
          "name": "Bounded",
          "package": "derive",
          "source": "src/Data-Derive-Bounded.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Data Derive Bounded",
          "module": "Data.Derive.Bounded",
          "name": "Bounded",
          "package": "derive",
          "partial": "Bounded",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-Bounded.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Derive.Bounded",
          "name": "dslBounded",
          "package": "derive",
          "signature": "DSL",
          "source": "src/Data-Derive-Bounded.html#dslBounded",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Derive Bounded",
          "module": "Data.Derive.Bounded",
          "name": "dslBounded",
          "package": "derive",
          "partial": "Bounded",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-Bounded.html#v:dslBounded"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Derive.Bounded",
          "name": "makeBounded",
          "package": "derive",
          "signature": "Derivation",
          "source": "src/Data-Derive-Bounded.html#makeBounded",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Derive Bounded",
          "module": "Data.Derive.Bounded",
          "name": "makeBounded",
          "package": "derive",
          "partial": "Bounded",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-Bounded.html#v:makeBounded"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Derive.Class.Arities",
          "name": "Arities",
          "package": "derive",
          "source": "src/Data-Derive-Class-Arities.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Data Derive Class Arities",
          "module": "Data.Derive.Class.Arities",
          "name": "Arities",
          "package": "derive",
          "partial": "Arities",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-Class-Arities.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Derive.Class.Arities",
          "name": "Arities",
          "package": "derive",
          "source": "src/Data-Derive-Class-Arities.html#Arities",
          "type": "class"
        },
        "index": {
          "hierarchy": "Data Derive Class Arities",
          "module": "Data.Derive.Class.Arities",
          "name": "Arities",
          "package": "derive",
          "partial": "Arities",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-Class-Arities.html#t:Arities"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Derive.Class.Arities",
          "name": "arities",
          "package": "derive",
          "signature": "a -\u003e [Int]",
          "source": "src/Data-Derive-Class-Arities.html#arities",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Derive Class Arities",
          "module": "Data.Derive.Class.Arities",
          "name": "arities",
          "normalized": "a-\u003e[Int]",
          "package": "derive",
          "signature": "a-\u003e[Int]",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-Class-Arities.html#v:arities"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Derive.Class.Default",
          "name": "Default",
          "package": "derive",
          "source": "src/Data-Derive-Class-Default.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Data Derive Class Default",
          "module": "Data.Derive.Class.Default",
          "name": "Default",
          "package": "derive",
          "partial": "Default",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-Class-Default.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Derive.Class.Default",
          "name": "Default",
          "package": "derive",
          "source": "src/Data-Derive-Class-Default.html#Default",
          "type": "class"
        },
        "index": {
          "hierarchy": "Data Derive Class Default",
          "module": "Data.Derive.Class.Default",
          "name": "Default",
          "package": "derive",
          "partial": "Default",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-Class-Default.html#t:Default"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Derive.Class.Default",
          "name": "def",
          "package": "derive",
          "signature": "a",
          "source": "src/Data-Derive-Class-Default.html#def",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Derive Class Default",
          "module": "Data.Derive.Class.Default",
          "name": "def",
          "package": "derive",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-Class-Default.html#v:def"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Derive.DSL.Apply",
          "name": "Apply",
          "package": "derive",
          "source": "src/Data-Derive-DSL-Apply.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Data Derive DSL Apply",
          "module": "Data.Derive.DSL.Apply",
          "name": "Apply",
          "package": "derive",
          "partial": "Apply",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-DSL-Apply.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Derive.DSL.Apply",
          "name": "Env",
          "package": "derive",
          "source": "src/Data-Derive-DSL-Apply.html#Env",
          "type": "data"
        },
        "index": {
          "hierarchy": "Data Derive DSL Apply",
          "module": "Data.Derive.DSL.Apply",
          "name": "Env",
          "package": "derive",
          "partial": "Env",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-DSL-Apply.html#t:Env"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Derive.DSL.Apply",
          "name": "Env",
          "package": "derive",
          "signature": "Env",
          "source": "src/Data-Derive-DSL-Apply.html#Env",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Derive DSL Apply",
          "module": "Data.Derive.DSL.Apply",
          "name": "Env",
          "package": "derive",
          "partial": "Env",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-DSL-Apply.html#v:Env"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Derive.DSL.Apply",
          "name": "apply",
          "package": "derive",
          "signature": "DSL -\u003e Input -\u003e Out",
          "source": "src/Data-Derive-DSL-Apply.html#apply",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Derive DSL Apply",
          "module": "Data.Derive.DSL.Apply",
          "name": "apply",
          "normalized": "DSL-\u003eInput-\u003eOut",
          "package": "derive",
          "signature": "DSL-\u003eInput-\u003eOut",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-DSL-Apply.html#v:apply"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Derive.DSL.Apply",
          "name": "applyEnv",
          "package": "derive",
          "signature": "DSL -\u003e Env -\u003e Output",
          "source": "src/Data-Derive-DSL-Apply.html#applyEnv",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Derive DSL Apply",
          "module": "Data.Derive.DSL.Apply",
          "name": "applyEnv",
          "normalized": "DSL-\u003eEnv-\u003eOutput",
          "package": "derive",
          "partial": "Env",
          "signature": "DSL-\u003eEnv-\u003eOutput",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-DSL-Apply.html#v:applyEnv"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Derive.DSL.Apply",
          "name": "env",
          "package": "derive",
          "signature": "Env",
          "source": "src/Data-Derive-DSL-Apply.html#env",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Derive DSL Apply",
          "module": "Data.Derive.DSL.Apply",
          "name": "env",
          "package": "derive",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-DSL-Apply.html#v:env"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Derive.DSL.Apply",
          "name": "envCtor",
          "package": "derive",
          "signature": "Ctor",
          "source": "src/Data-Derive-DSL-Apply.html#Env",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Derive DSL Apply",
          "module": "Data.Derive.DSL.Apply",
          "name": "envCtor",
          "package": "derive",
          "partial": "Ctor",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-DSL-Apply.html#v:envCtor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Derive.DSL.Apply",
          "name": "envField",
          "package": "derive",
          "signature": "Integer",
          "source": "src/Data-Derive-DSL-Apply.html#Env",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Derive DSL Apply",
          "module": "Data.Derive.DSL.Apply",
          "name": "envField",
          "package": "derive",
          "partial": "Field",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-DSL-Apply.html#v:envField"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Derive.DSL.Apply",
          "name": "envFold",
          "package": "derive",
          "signature": "(Output, Output)",
          "source": "src/Data-Derive-DSL-Apply.html#Env",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Derive DSL Apply",
          "module": "Data.Derive.DSL.Apply",
          "name": "envFold",
          "normalized": "(Output,Output)",
          "package": "derive",
          "partial": "Fold",
          "signature": "(Output,Output)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-DSL-Apply.html#v:envFold"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Derive.DSL.Apply",
          "name": "envInput",
          "package": "derive",
          "signature": "Input",
          "source": "src/Data-Derive-DSL-Apply.html#Env",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Derive DSL Apply",
          "module": "Data.Derive.DSL.Apply",
          "name": "envInput",
          "package": "derive",
          "partial": "Input",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-DSL-Apply.html#v:envInput"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Derive.DSL.DSL",
          "name": "DSL",
          "package": "derive",
          "source": "src/Data-Derive-DSL-DSL.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Data Derive DSL DSL",
          "module": "Data.Derive.DSL.DSL",
          "name": "DSL",
          "package": "derive",
          "partial": "DSL",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-DSL-DSL.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Derive.DSL.DSL",
          "name": "DSL",
          "package": "derive",
          "source": "src/Data-Derive-DSL-DSL.html#DSL",
          "type": "data"
        },
        "index": {
          "hierarchy": "Data Derive DSL DSL",
          "module": "Data.Derive.DSL.DSL",
          "name": "DSL",
          "package": "derive",
          "partial": "DSL",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-DSL-DSL.html#t:DSL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Derive.DSL.DSL",
          "name": "App",
          "package": "derive",
          "signature": "App String DSL",
          "source": "src/Data-Derive-DSL-DSL.html#DSL",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Derive DSL DSL",
          "module": "Data.Derive.DSL.DSL",
          "name": "App",
          "package": "derive",
          "partial": "App",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-DSL-DSL.html#v:App"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Derive.DSL.DSL",
          "name": "Application",
          "package": "derive",
          "signature": "Application DSL",
          "source": "src/Data-Derive-DSL-DSL.html#DSL",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Derive DSL DSL",
          "module": "Data.Derive.DSL.DSL",
          "name": "Application",
          "package": "derive",
          "partial": "Application",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-DSL-DSL.html#v:Application"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Derive.DSL.DSL",
          "name": "Concat",
          "package": "derive",
          "signature": "Concat DSL",
          "source": "src/Data-Derive-DSL-DSL.html#DSL",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Derive DSL DSL",
          "module": "Data.Derive.DSL.DSL",
          "name": "Concat",
          "package": "derive",
          "partial": "Concat",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-DSL-DSL.html#v:Concat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Derive.DSL.DSL",
          "name": "CtorArity",
          "package": "derive",
          "signature": "CtorArity",
          "source": "src/Data-Derive-DSL-DSL.html#DSL",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Derive DSL DSL",
          "module": "Data.Derive.DSL.DSL",
          "name": "CtorArity",
          "package": "derive",
          "partial": "Ctor Arity",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-DSL-DSL.html#v:CtorArity"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Derive.DSL.DSL",
          "name": "CtorIndex",
          "package": "derive",
          "signature": "CtorIndex",
          "source": "src/Data-Derive-DSL-DSL.html#DSL",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Derive DSL DSL",
          "module": "Data.Derive.DSL.DSL",
          "name": "CtorIndex",
          "package": "derive",
          "partial": "Ctor Index",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-DSL-DSL.html#v:CtorIndex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Derive.DSL.DSL",
          "name": "CtorName",
          "package": "derive",
          "signature": "CtorName",
          "source": "src/Data-Derive-DSL-DSL.html#DSL",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Derive DSL DSL",
          "module": "Data.Derive.DSL.DSL",
          "name": "CtorName",
          "package": "derive",
          "partial": "Ctor Name",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-DSL-DSL.html#v:CtorName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Derive.DSL.DSL",
          "name": "DataName",
          "package": "derive",
          "signature": "DataName",
          "source": "src/Data-Derive-DSL-DSL.html#DSL",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Derive DSL DSL",
          "module": "Data.Derive.DSL.DSL",
          "name": "DataName",
          "package": "derive",
          "partial": "Data Name",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-DSL-DSL.html#v:DataName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Derive.DSL.DSL",
          "name": "FieldIndex",
          "package": "derive",
          "signature": "FieldIndex",
          "source": "src/Data-Derive-DSL-DSL.html#DSL",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Derive DSL DSL",
          "module": "Data.Derive.DSL.DSL",
          "name": "FieldIndex",
          "package": "derive",
          "partial": "Field Index",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-DSL-DSL.html#v:FieldIndex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Derive.DSL.DSL",
          "name": "Fold",
          "package": "derive",
          "signature": "Fold DSL DSL",
          "source": "src/Data-Derive-DSL-DSL.html#DSL",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Derive DSL DSL",
          "module": "Data.Derive.DSL.DSL",
          "name": "Fold",
          "package": "derive",
          "partial": "Fold",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-DSL-DSL.html#v:Fold"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Derive.DSL.DSL",
          "name": "Head",
          "package": "derive",
          "signature": "Head",
          "source": "src/Data-Derive-DSL-DSL.html#DSL",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Derive DSL DSL",
          "module": "Data.Derive.DSL.DSL",
          "name": "Head",
          "package": "derive",
          "partial": "Head",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-DSL-DSL.html#v:Head"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Derive.DSL.DSL",
          "name": "Instance",
          "package": "derive",
          "signature": "Instance [String] String DSL",
          "source": "src/Data-Derive-DSL-DSL.html#DSL",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Derive DSL DSL",
          "module": "Data.Derive.DSL.DSL",
          "name": "Instance",
          "normalized": "Instance[String]String DSL",
          "package": "derive",
          "partial": "Instance",
          "signature": "Instance[String]String DSL",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-DSL-DSL.html#v:Instance"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Derive.DSL.DSL",
          "name": "Int",
          "package": "derive",
          "signature": "Int Integer",
          "source": "src/Data-Derive-DSL-DSL.html#DSL",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Derive DSL DSL",
          "module": "Data.Derive.DSL.DSL",
          "name": "Int",
          "package": "derive",
          "partial": "Int",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-DSL-DSL.html#v:Int"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Derive.DSL.DSL",
          "name": "List",
          "package": "derive",
          "signature": "List [DSL]",
          "source": "src/Data-Derive-DSL-DSL.html#DSL",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Derive DSL DSL",
          "module": "Data.Derive.DSL.DSL",
          "name": "List",
          "normalized": "List[DSL]",
          "package": "derive",
          "partial": "List",
          "signature": "List[DSL]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-DSL-DSL.html#v:List"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Derive.DSL.DSL",
          "name": "MapCtor",
          "package": "derive",
          "signature": "MapCtor DSL",
          "source": "src/Data-Derive-DSL-DSL.html#DSL",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Derive DSL DSL",
          "module": "Data.Derive.DSL.DSL",
          "name": "MapCtor",
          "package": "derive",
          "partial": "Map Ctor",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-DSL-DSL.html#v:MapCtor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Derive.DSL.DSL",
          "name": "MapField",
          "package": "derive",
          "signature": "MapField DSL",
          "source": "src/Data-Derive-DSL-DSL.html#DSL",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Derive DSL DSL",
          "module": "Data.Derive.DSL.DSL",
          "name": "MapField",
          "package": "derive",
          "partial": "Map Field",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-DSL-DSL.html#v:MapField"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Derive.DSL.DSL",
          "name": "Reverse",
          "package": "derive",
          "signature": "Reverse DSL",
          "source": "src/Data-Derive-DSL-DSL.html#DSL",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Derive DSL DSL",
          "module": "Data.Derive.DSL.DSL",
          "name": "Reverse",
          "package": "derive",
          "partial": "Reverse",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-DSL-DSL.html#v:Reverse"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Derive.DSL.DSL",
          "name": "ShowInt",
          "package": "derive",
          "signature": "ShowInt DSL",
          "source": "src/Data-Derive-DSL-DSL.html#DSL",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Derive DSL DSL",
          "module": "Data.Derive.DSL.DSL",
          "name": "ShowInt",
          "package": "derive",
          "partial": "Show Int",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-DSL-DSL.html#v:ShowInt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Derive.DSL.DSL",
          "name": "String",
          "package": "derive",
          "signature": "String String",
          "source": "src/Data-Derive-DSL-DSL.html#DSL",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Derive DSL DSL",
          "module": "Data.Derive.DSL.DSL",
          "name": "String",
          "package": "derive",
          "partial": "String",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-DSL-DSL.html#v:String"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Derive.DSL.DSL",
          "name": "Tail",
          "package": "derive",
          "signature": "Tail",
          "source": "src/Data-Derive-DSL-DSL.html#DSL",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Derive DSL DSL",
          "module": "Data.Derive.DSL.DSL",
          "name": "Tail",
          "package": "derive",
          "partial": "Tail",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-DSL-DSL.html#v:Tail"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Derive.DSL.DSL",
          "name": "append",
          "package": "derive",
          "signature": "DSL -\u003e DSL -\u003e DSL",
          "source": "src/Data-Derive-DSL-DSL.html#append",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Derive DSL DSL",
          "module": "Data.Derive.DSL.DSL",
          "name": "append",
          "normalized": "DSL-\u003eDSL-\u003eDSL",
          "package": "derive",
          "signature": "DSL-\u003eDSL-\u003eDSL",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-DSL-DSL.html#v:append"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Derive.DSL.DSL",
          "name": "box",
          "package": "derive",
          "signature": "DSL -\u003e DSL",
          "source": "src/Data-Derive-DSL-DSL.html#box",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Derive DSL DSL",
          "module": "Data.Derive.DSL.DSL",
          "name": "box",
          "normalized": "DSL-\u003eDSL",
          "package": "derive",
          "signature": "DSL-\u003eDSL",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-DSL-DSL.html#v:box"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Derive.DSL.DSL",
          "name": "fromOut",
          "package": "derive",
          "signature": "Output -\u003e DSL",
          "source": "src/Data-Derive-DSL-DSL.html#fromOut",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Derive DSL DSL",
          "module": "Data.Derive.DSL.DSL",
          "name": "fromOut",
          "normalized": "Output-\u003eDSL",
          "package": "derive",
          "partial": "Out",
          "signature": "Output-\u003eDSL",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-DSL-DSL.html#v:fromOut"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Derive.DSL.DSL",
          "name": "nil",
          "package": "derive",
          "signature": "DSL",
          "source": "src/Data-Derive-DSL-DSL.html#nil",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Derive DSL DSL",
          "module": "Data.Derive.DSL.DSL",
          "name": "nil",
          "package": "derive",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-DSL-DSL.html#v:nil"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Derive.DSL.DSL",
          "name": "prettyTex",
          "package": "derive",
          "signature": "DSL -\u003e String",
          "source": "src/Data-Derive-DSL-DSL.html#prettyTex",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Derive DSL DSL",
          "module": "Data.Derive.DSL.DSL",
          "name": "prettyTex",
          "normalized": "DSL-\u003eString",
          "package": "derive",
          "partial": "Tex",
          "signature": "DSL-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-DSL-DSL.html#v:prettyTex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Derive.DSL.DSL",
          "name": "simplifyDSL",
          "package": "derive",
          "signature": "DSL -\u003e DSL",
          "source": "src/Data-Derive-DSL-DSL.html#simplifyDSL",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Derive DSL DSL",
          "module": "Data.Derive.DSL.DSL",
          "name": "simplifyDSL",
          "normalized": "DSL-\u003eDSL",
          "package": "derive",
          "partial": "DSL",
          "signature": "DSL-\u003eDSL",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-DSL-DSL.html#v:simplifyDSL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Derive.DSL.Derive",
          "name": "Derive",
          "package": "derive",
          "source": "src/Data-Derive-DSL-Derive.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Data Derive DSL Derive",
          "module": "Data.Derive.DSL.Derive",
          "name": "Derive",
          "package": "derive",
          "partial": "Derive",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-DSL-Derive.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Derive.DSL.Derive",
          "name": "derive",
          "package": "derive",
          "signature": "Out -\u003e [DSL]",
          "source": "src/Data-Derive-DSL-Derive.html#derive",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Derive DSL Derive",
          "module": "Data.Derive.DSL.Derive",
          "name": "derive",
          "normalized": "Out-\u003e[DSL]",
          "package": "derive",
          "signature": "Out-\u003e[DSL]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-DSL-Derive.html#v:derive"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Derive.DSL.HSE",
          "name": "HSE",
          "package": "derive",
          "source": "src/Data-Derive-DSL-HSE.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Data Derive DSL HSE",
          "module": "Data.Derive.DSL.HSE",
          "name": "HSE",
          "package": "derive",
          "partial": "HSE",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-DSL-HSE.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Derive.DSL.HSE",
          "name": "Ctor",
          "package": "derive",
          "source": "src/Data-Derive-DSL-HSE.html#Ctor",
          "type": "type"
        },
        "index": {
          "hierarchy": "Data Derive DSL HSE",
          "module": "Data.Derive.DSL.HSE",
          "name": "Ctor",
          "package": "derive",
          "partial": "Ctor",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-DSL-HSE.html#t:Ctor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Derive.DSL.HSE",
          "name": "Input",
          "package": "derive",
          "source": "src/Data-Derive-DSL-HSE.html#Input",
          "type": "type"
        },
        "index": {
          "hierarchy": "Data Derive DSL HSE",
          "module": "Data.Derive.DSL.HSE",
          "name": "Input",
          "package": "derive",
          "partial": "Input",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-DSL-HSE.html#t:Input"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Derive.DSL.HSE",
          "name": "Out",
          "package": "derive",
          "source": "src/Data-Derive-DSL-HSE.html#Out",
          "type": "type"
        },
        "index": {
          "hierarchy": "Data Derive DSL HSE",
          "module": "Data.Derive.DSL.HSE",
          "name": "Out",
          "package": "derive",
          "partial": "Out",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-DSL-HSE.html#t:Out"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Derive.DSL.HSE",
          "name": "Output",
          "package": "derive",
          "source": "src/Data-Derive-DSL-HSE.html#Output",
          "type": "data"
        },
        "index": {
          "hierarchy": "Data Derive DSL HSE",
          "module": "Data.Derive.DSL.HSE",
          "name": "Output",
          "package": "derive",
          "partial": "Output",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-DSL-HSE.html#t:Output"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Derive.DSL.HSE",
          "name": "OApp",
          "package": "derive",
          "signature": "OApp String [Output]",
          "source": "src/Data-Derive-DSL-HSE.html#Output",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Derive DSL HSE",
          "module": "Data.Derive.DSL.HSE",
          "name": "OApp",
          "normalized": "OApp String[Output]",
          "package": "derive",
          "partial": "OApp",
          "signature": "OApp String[Output]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-DSL-HSE.html#v:OApp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Derive.DSL.HSE",
          "name": "OCustom",
          "package": "derive",
          "signature": "OCustom String",
          "source": "src/Data-Derive-DSL-HSE.html#Output",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Derive DSL HSE",
          "module": "Data.Derive.DSL.HSE",
          "name": "OCustom",
          "package": "derive",
          "partial": "OCustom",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-DSL-HSE.html#v:OCustom"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Derive.DSL.HSE",
          "name": "OIgnore",
          "package": "derive",
          "signature": "OIgnore",
          "source": "src/Data-Derive-DSL-HSE.html#Output",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Derive DSL HSE",
          "module": "Data.Derive.DSL.HSE",
          "name": "OIgnore",
          "package": "derive",
          "partial": "OIgnore",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-DSL-HSE.html#v:OIgnore"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Derive.DSL.HSE",
          "name": "OInt",
          "package": "derive",
          "signature": "OInt Integer",
          "source": "src/Data-Derive-DSL-HSE.html#Output",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Derive DSL HSE",
          "module": "Data.Derive.DSL.HSE",
          "name": "OInt",
          "package": "derive",
          "partial": "OInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-DSL-HSE.html#v:OInt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Derive.DSL.HSE",
          "name": "OList",
          "package": "derive",
          "signature": "OList [Output]",
          "source": "src/Data-Derive-DSL-HSE.html#Output",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Derive DSL HSE",
          "module": "Data.Derive.DSL.HSE",
          "name": "OList",
          "normalized": "OList[Output]",
          "package": "derive",
          "partial": "OList",
          "signature": "OList[Output]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-DSL-HSE.html#v:OList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Derive.DSL.HSE",
          "name": "OString",
          "package": "derive",
          "signature": "OString String",
          "source": "src/Data-Derive-DSL-HSE.html#Output",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Derive DSL HSE",
          "module": "Data.Derive.DSL.HSE",
          "name": "OString",
          "package": "derive",
          "partial": "OString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-DSL-HSE.html#v:OString"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Derive.DSL.HSE",
          "name": "coerce",
          "package": "derive",
          "signature": "a1 -\u003e a",
          "source": "src/Data-Derive-DSL-HSE.html#coerce",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Derive DSL HSE",
          "module": "Data.Derive.DSL.HSE",
          "name": "coerce",
          "normalized": "a-\u003ea",
          "package": "derive",
          "signature": "a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-DSL-HSE.html#v:coerce"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Derive.DSL.HSE",
          "name": "ctorArity",
          "package": "derive",
          "signature": "CtorDecl -\u003e Integer",
          "source": "src/Data-Derive-DSL-HSE.html#ctorArity",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Derive DSL HSE",
          "module": "Data.Derive.DSL.HSE",
          "name": "ctorArity",
          "normalized": "CtorDecl-\u003eInteger",
          "package": "derive",
          "partial": "Arity",
          "signature": "CtorDecl-\u003eInteger",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-DSL-HSE.html#v:ctorArity"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Derive.DSL.HSE",
          "name": "ctorIndex",
          "package": "derive",
          "signature": "Input -\u003e Ctor -\u003e Integer",
          "source": "src/Data-Derive-DSL-HSE.html#ctorIndex",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Derive DSL HSE",
          "module": "Data.Derive.DSL.HSE",
          "name": "ctorIndex",
          "normalized": "Input-\u003eCtor-\u003eInteger",
          "package": "derive",
          "partial": "Index",
          "signature": "Input-\u003eCtor-\u003eInteger",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-DSL-HSE.html#v:ctorIndex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Derive.DSL.HSE",
          "name": "ctorName",
          "package": "derive",
          "signature": "CtorDecl -\u003e String",
          "source": "src/Data-Derive-DSL-HSE.html#ctorName",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Derive DSL HSE",
          "module": "Data.Derive.DSL.HSE",
          "name": "ctorName",
          "normalized": "CtorDecl-\u003eString",
          "package": "derive",
          "partial": "Name",
          "signature": "CtorDecl-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-DSL-HSE.html#v:ctorName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Derive.DSL.HSE",
          "name": "dataCtors",
          "package": "derive",
          "signature": "DataDecl -\u003e [CtorDecl]",
          "source": "src/Data-Derive-DSL-HSE.html#dataCtors",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Derive DSL HSE",
          "module": "Data.Derive.DSL.HSE",
          "name": "dataCtors",
          "normalized": "DataDecl-\u003e[CtorDecl]",
          "package": "derive",
          "partial": "Ctors",
          "signature": "DataDecl-\u003e[CtorDecl]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-DSL-HSE.html#v:dataCtors"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Derive.DSL.HSE",
          "name": "dataName",
          "package": "derive",
          "signature": "DataDecl -\u003e String",
          "source": "src/Data-Derive-DSL-HSE.html#dataName",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Derive DSL HSE",
          "module": "Data.Derive.DSL.HSE",
          "name": "dataName",
          "normalized": "DataDecl-\u003eString",
          "package": "derive",
          "partial": "Name",
          "signature": "DataDecl-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-DSL-HSE.html#v:dataName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Derive.DSL.HSE",
          "name": "dataVars",
          "package": "derive",
          "signature": "DataDecl -\u003e Int",
          "source": "src/Data-Derive-DSL-HSE.html#dataVars",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Derive DSL HSE",
          "module": "Data.Derive.DSL.HSE",
          "name": "dataVars",
          "normalized": "DataDecl-\u003eInt",
          "package": "derive",
          "partial": "Vars",
          "signature": "DataDecl-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-DSL-HSE.html#v:dataVars"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Derive.DSL.HSE",
          "name": "fromOutput",
          "package": "derive",
          "signature": "Output -\u003e a",
          "source": "src/Data-Derive-DSL-HSE.html#fromOutput",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Derive DSL HSE",
          "module": "Data.Derive.DSL.HSE",
          "name": "fromOutput",
          "normalized": "Output-\u003ea",
          "package": "derive",
          "partial": "Output",
          "signature": "Output-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-DSL-HSE.html#v:fromOutput"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Derive.DSL.HSE",
          "name": "fromState",
          "package": "derive",
          "signature": "State a x -\u003e x",
          "source": "src/Data-Derive-DSL-HSE.html#fromState",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Derive DSL HSE",
          "module": "Data.Derive.DSL.HSE",
          "name": "fromState",
          "normalized": "State a b-\u003eb",
          "package": "derive",
          "partial": "State",
          "signature": "State a x-\u003ex",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-DSL-HSE.html#v:fromState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Derive.DSL.HSE",
          "name": "out",
          "package": "derive",
          "signature": "a -\u003e Output",
          "source": "src/Data-Derive-DSL-HSE.html#out",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Derive DSL HSE",
          "module": "Data.Derive.DSL.HSE",
          "name": "out",
          "normalized": "a-\u003eOutput",
          "package": "derive",
          "signature": "a-\u003eOutput",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-DSL-HSE.html#v:out"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Derive.DSL.HSE",
          "name": "outEq",
          "package": "derive",
          "signature": "Out -\u003e Out -\u003e Bool",
          "source": "src/Data-Derive-DSL-HSE.html#outEq",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Derive DSL HSE",
          "module": "Data.Derive.DSL.HSE",
          "name": "outEq",
          "normalized": "Out-\u003eOut-\u003eBool",
          "package": "derive",
          "partial": "Eq",
          "signature": "Out-\u003eOut-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-DSL-HSE.html#v:outEq"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Derive.DSL.HSE",
          "name": "readCon",
          "package": "derive",
          "signature": "DataType -\u003e [Char] -\u003e Constr",
          "source": "src/Data-Derive-DSL-HSE.html#readCon",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Derive DSL HSE",
          "module": "Data.Derive.DSL.HSE",
          "name": "readCon",
          "normalized": "DataType-\u003e[Char]-\u003eConstr",
          "package": "derive",
          "partial": "Con",
          "signature": "DataType-\u003e[Char]-\u003eConstr",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-DSL-HSE.html#v:readCon"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Derive.DSL.HSE",
          "name": "sample",
          "package": "derive",
          "signature": "Input",
          "source": "src/Data-Derive-DSL-HSE.html#sample",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Derive DSL HSE",
          "module": "Data.Derive.DSL.HSE",
          "name": "sample",
          "package": "derive",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-DSL-HSE.html#v:sample"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Derive.DSL.HSE",
          "name": "showOut",
          "package": "derive",
          "signature": "[a] -\u003e String",
          "source": "src/Data-Derive-DSL-HSE.html#showOut",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Derive DSL HSE",
          "module": "Data.Derive.DSL.HSE",
          "name": "showOut",
          "normalized": "[a]-\u003eString",
          "package": "derive",
          "partial": "Out",
          "signature": "[a]-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-DSL-HSE.html#v:showOut"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Derive.DSL.HSE",
          "name": "toInput",
          "package": "derive",
          "signature": "DataDecl -\u003e Input",
          "source": "src/Data-Derive-DSL-HSE.html#toInput",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Derive DSL HSE",
          "module": "Data.Derive.DSL.HSE",
          "name": "toInput",
          "normalized": "DataDecl-\u003eInput",
          "package": "derive",
          "partial": "Input",
          "signature": "DataDecl-\u003eInput",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-DSL-HSE.html#v:toInput"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Derive.DSL.HSE",
          "name": "toOutput",
          "package": "derive",
          "signature": "a -\u003e Output",
          "source": "src/Data-Derive-DSL-HSE.html#toOutput",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Derive DSL HSE",
          "module": "Data.Derive.DSL.HSE",
          "name": "toOutput",
          "normalized": "a-\u003eOutput",
          "package": "derive",
          "partial": "Output",
          "signature": "a-\u003eOutput",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-DSL-HSE.html#v:toOutput"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Derive.DSL.SYB",
          "name": "SYB",
          "package": "derive",
          "source": "src/Data-Derive-DSL-SYB.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Data Derive DSL SYB",
          "module": "Data.Derive.DSL.SYB",
          "name": "SYB",
          "package": "derive",
          "partial": "SYB",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-DSL-SYB.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Derive.DSL.SYB",
          "name": "dslSYB",
          "package": "derive",
          "signature": "DSL -\u003e Maybe Out",
          "source": "src/Data-Derive-DSL-SYB.html#dslSYB",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Derive DSL SYB",
          "module": "Data.Derive.DSL.SYB",
          "name": "dslSYB",
          "normalized": "DSL-\u003eMaybe Out",
          "package": "derive",
          "partial": "SYB",
          "signature": "DSL-\u003eMaybe Out",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-DSL-SYB.html#v:dslSYB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Derive.Data",
          "name": "Data",
          "package": "derive",
          "source": "src/Data-Derive-Data.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Data Derive Data",
          "module": "Data.Derive.Data",
          "name": "Data",
          "package": "derive",
          "partial": "Data",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-Data.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Derive.Data",
          "name": "makeData",
          "package": "derive",
          "signature": "Derivation",
          "source": "src/Data-Derive-Data.html#makeData",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Derive Data",
          "module": "Data.Derive.Data",
          "name": "makeData",
          "package": "derive",
          "partial": "Data",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-Data.html#v:makeData"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eFor deriving Data on abstract data types.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.Derive.DataAbstract",
          "name": "DataAbstract",
          "package": "derive",
          "source": "src/Data-Derive-DataAbstract.html",
          "type": "module"
        },
        "index": {
          "description": "For deriving Data on abstract data types",
          "hierarchy": "Data Derive DataAbstract",
          "module": "Data.Derive.DataAbstract",
          "name": "DataAbstract",
          "package": "derive",
          "partial": "Data Abstract",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-DataAbstract.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Derive.DataAbstract",
          "name": "makeDataAbstract",
          "package": "derive",
          "signature": "Derivation",
          "source": "src/Data-Derive-DataAbstract.html#makeDataAbstract",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Derive DataAbstract",
          "module": "Data.Derive.DataAbstract",
          "name": "makeDataAbstract",
          "package": "derive",
          "partial": "Data Abstract",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-DataAbstract.html#v:makeDataAbstract"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Derive.Default",
          "name": "Default",
          "package": "derive",
          "source": "src/Data-Derive-Default.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Data Derive Default",
          "module": "Data.Derive.Default",
          "name": "Default",
          "package": "derive",
          "partial": "Default",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-Default.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Derive.Default",
          "name": "dslDefault",
          "package": "derive",
          "signature": "DSL",
          "source": "src/Data-Derive-Default.html#dslDefault",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Derive Default",
          "module": "Data.Derive.Default",
          "name": "dslDefault",
          "package": "derive",
          "partial": "Default",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-Default.html#v:dslDefault"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Derive.Default",
          "name": "makeDefault",
          "package": "derive",
          "signature": "Derivation",
          "source": "src/Data-Derive-Default.html#makeDefault",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Derive Default",
          "module": "Data.Derive.Default",
          "name": "makeDefault",
          "package": "derive",
          "partial": "Default",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-Default.html#v:makeDefault"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Derive.Enum",
          "name": "Enum",
          "package": "derive",
          "source": "src/Data-Derive-Enum.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Data Derive Enum",
          "module": "Data.Derive.Enum",
          "name": "Enum",
          "package": "derive",
          "partial": "Enum",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-Enum.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Derive.Enum",
          "name": "dslEnum",
          "package": "derive",
          "signature": "DSL",
          "source": "src/Data-Derive-Enum.html#dslEnum",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Derive Enum",
          "module": "Data.Derive.Enum",
          "name": "dslEnum",
          "package": "derive",
          "partial": "Enum",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-Enum.html#v:dslEnum"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Derive.Enum",
          "name": "makeEnum",
          "package": "derive",
          "signature": "Derivation",
          "source": "src/Data-Derive-Enum.html#makeEnum",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Derive Enum",
          "module": "Data.Derive.Enum",
          "name": "makeEnum",
          "package": "derive",
          "partial": "Enum",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-Enum.html#v:makeEnum"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Derive.EnumCyclic",
          "name": "EnumCyclic",
          "package": "derive",
          "source": "src/Data-Derive-EnumCyclic.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Data Derive EnumCyclic",
          "module": "Data.Derive.EnumCyclic",
          "name": "EnumCyclic",
          "package": "derive",
          "partial": "Enum Cyclic",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-EnumCyclic.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Derive.EnumCyclic",
          "name": "dslEnumCyclic",
          "package": "derive",
          "signature": "DSL",
          "source": "src/Data-Derive-EnumCyclic.html#dslEnumCyclic",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Derive EnumCyclic",
          "module": "Data.Derive.EnumCyclic",
          "name": "dslEnumCyclic",
          "package": "derive",
          "partial": "Enum Cyclic",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-EnumCyclic.html#v:dslEnumCyclic"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Derive.EnumCyclic",
          "name": "makeEnumCyclic",
          "package": "derive",
          "signature": "Derivation",
          "source": "src/Data-Derive-EnumCyclic.html#makeEnumCyclic",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Derive EnumCyclic",
          "module": "Data.Derive.EnumCyclic",
          "name": "makeEnumCyclic",
          "package": "derive",
          "partial": "Enum Cyclic",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-EnumCyclic.html#v:makeEnumCyclic"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Derive.Eq",
          "name": "Eq",
          "package": "derive",
          "source": "src/Data-Derive-Eq.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Data Derive Eq",
          "module": "Data.Derive.Eq",
          "name": "Eq",
          "package": "derive",
          "partial": "Eq",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-Eq.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Derive.Eq",
          "name": "dslEq",
          "package": "derive",
          "signature": "DSL",
          "source": "src/Data-Derive-Eq.html#dslEq",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Derive Eq",
          "module": "Data.Derive.Eq",
          "name": "dslEq",
          "package": "derive",
          "partial": "Eq",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-Eq.html#v:dslEq"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Derive.Eq",
          "name": "makeEq",
          "package": "derive",
          "signature": "Derivation",
          "source": "src/Data-Derive-Eq.html#makeEq",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Derive Eq",
          "module": "Data.Derive.Eq",
          "name": "makeEq",
          "package": "derive",
          "partial": "Eq",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-Eq.html#v:makeEq"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eA pseudo derivation.  Derive a (non-recursive) fold function for \n    the type which takes one function per alternative constructor.  Each\n    function takes the same arguments as the constructor and returns\n    a value.  When applied to a value the fold function applies the\n    function for the matching constructor to the constructor fields.\n    This provides a first-class alternative to pattern matching to\n    deconstruct the data type.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.Derive.Fold",
          "name": "Fold",
          "package": "derive",
          "source": "src/Data-Derive-Fold.html",
          "type": "module"
        },
        "index": {
          "description": "pseudo derivation Derive non-recursive fold function for the type which takes one function per alternative constructor Each function takes the same arguments as the constructor and returns value When applied to value the fold function applies the function for the matching constructor to the constructor fields This provides first-class alternative to pattern matching to deconstruct the data type",
          "hierarchy": "Data Derive Fold",
          "module": "Data.Derive.Fold",
          "name": "Fold",
          "package": "derive",
          "partial": "Fold",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-Fold.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Derive.Fold",
          "name": "makeFold",
          "package": "derive",
          "signature": "Derivation",
          "source": "src/Data-Derive-Fold.html#makeFold",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Derive Fold",
          "module": "Data.Derive.Fold",
          "name": "makeFold",
          "package": "derive",
          "partial": "Fold",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-Fold.html#v:makeFold"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Derive.Foldable",
          "name": "Foldable",
          "package": "derive",
          "source": "src/Data-Derive-Foldable.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Data Derive Foldable",
          "module": "Data.Derive.Foldable",
          "name": "Foldable",
          "package": "derive",
          "partial": "Foldable",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-Foldable.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Derive.Foldable",
          "name": "makeFoldable",
          "package": "derive",
          "signature": "Derivation",
          "source": "src/Data-Derive-Foldable.html#makeFoldable",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Derive Foldable",
          "module": "Data.Derive.Foldable",
          "name": "makeFoldable",
          "package": "derive",
          "partial": "Foldable",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-Foldable.html#v:makeFoldable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Derive.Foldable",
          "name": "makeFoldableN",
          "package": "derive",
          "signature": "Int -\u003e Derivation",
          "source": "src/Data-Derive-Foldable.html#makeFoldableN",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Derive Foldable",
          "module": "Data.Derive.Foldable",
          "name": "makeFoldableN",
          "normalized": "Int-\u003eDerivation",
          "package": "derive",
          "partial": "Foldable",
          "signature": "Int-\u003eDerivation",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-Foldable.html#v:makeFoldableN"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eA pseudo derivation.  For each constructor in the data type,\n    deriving \u003ccode\u003eFrom\u003c/code\u003e generates \u003ccode\u003efrom\u003c/code\u003e\u003cem\u003eCtorName\u003c/em\u003e which extracts the\n    components if given the appropriate constructor, and crashes\n    otherwise.  Unlike the DrIFT \u003ccode\u003e\"From\"\u003c/code\u003e derivation, our version\n    works for all constructors - zero-arity constructors always return\n    \u003ccode\u003e()\u003c/code\u003e, arity-one constructors return the contained value, and all\n    others return a tuple with all the components.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.Derive.From",
          "name": "From",
          "package": "derive",
          "source": "src/Data-Derive-From.html",
          "type": "module"
        },
        "index": {
          "description": "pseudo derivation For each constructor in the data type deriving From generates from CtorName which extracts the components if given the appropriate constructor and crashes otherwise Unlike the DrIFT From derivation our version works for all constructors zero-arity constructors always return arity-one constructors return the contained value and all others return tuple with all the components",
          "hierarchy": "Data Derive From",
          "module": "Data.Derive.From",
          "name": "From",
          "package": "derive",
          "partial": "From",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-From.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Derive.From",
          "name": "makeFrom",
          "package": "derive",
          "signature": "Derivation",
          "source": "src/Data-Derive-From.html#makeFrom",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Derive From",
          "module": "Data.Derive.From",
          "name": "makeFrom",
          "package": "derive",
          "partial": "From",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-From.html#v:makeFrom"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eDerives \u003ccode\u003e\u003ca\u003eFunctor\u003c/a\u003e\u003c/code\u003e, as discussed on the Haskell-prime mailing list:\n \u003ca\u003ehttp://www.mail-archive.com/haskell-prime@haskell.org/msg02116.html\u003c/a\u003e.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.Derive.Functor",
          "name": "Functor",
          "package": "derive",
          "source": "src/Data-Derive-Functor.html",
          "type": "module"
        },
        "index": {
          "description": "Derives Functor as discussed on the Haskell-prime mailing list http www.mail-archive.com haskell-prime@haskell.org msg02116.html",
          "hierarchy": "Data Derive Functor",
          "module": "Data.Derive.Functor",
          "name": "Functor",
          "package": "derive",
          "partial": "Functor",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-Functor.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Derive.Functor",
          "name": "makeFunctor",
          "package": "derive",
          "signature": "Derivation",
          "source": "src/Data-Derive-Functor.html#makeFunctor",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Derive Functor",
          "module": "Data.Derive.Functor",
          "name": "makeFunctor",
          "package": "derive",
          "partial": "Functor",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-Functor.html#v:makeFunctor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Derive.Functor",
          "name": "makeFunctorN",
          "package": "derive",
          "signature": "Int -\u003e Derivation",
          "source": "src/Data-Derive-Functor.html#makeFunctorN",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Derive Functor",
          "module": "Data.Derive.Functor",
          "name": "makeFunctorN",
          "normalized": "Int-\u003eDerivation",
          "package": "derive",
          "partial": "Functor",
          "signature": "Int-\u003eDerivation",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-Functor.html#v:makeFunctorN"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eHas is a pseudo derivation.  For each field of any constructor of\n    the data type, Has generates \u003ccode\u003ehas\u003c/code\u003e\u003cem\u003eFieldName\u003c/em\u003e which returns \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e\n    if given the the given field is a member of the constructor of the\n    passed object, and \u003ccode\u003e\u003ca\u003eFalse\u003c/a\u003e\u003c/code\u003e otherwise.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.Derive.Has",
          "name": "Has",
          "package": "derive",
          "source": "src/Data-Derive-Has.html",
          "type": "module"
        },
        "index": {
          "description": "Has is pseudo derivation For each field of any constructor of the data type Has generates has FieldName which returns True if given the the given field is member of the constructor of the passed object and False otherwise",
          "hierarchy": "Data Derive Has",
          "module": "Data.Derive.Has",
          "name": "Has",
          "package": "derive",
          "partial": "Has",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-Has.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Derive.Has",
          "name": "makeHas",
          "package": "derive",
          "signature": "Derivation",
          "source": "src/Data-Derive-Has.html#makeHas",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Derive Has",
          "module": "Data.Derive.Has",
          "name": "makeHas",
          "package": "derive",
          "partial": "Has",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-Has.html#v:makeHas"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Derive.Instance.Arities",
          "name": "Arities",
          "package": "derive",
          "source": "src/Data-Derive-Instance-Arities.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Data Derive Instance Arities",
          "module": "Data.Derive.Instance.Arities",
          "name": "Arities",
          "package": "derive",
          "partial": "Arities",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-Instance-Arities.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Derive.Internal.Derivation",
          "name": "Derivation",
          "package": "derive",
          "source": "src/Data-Derive-Internal-Derivation.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Data Derive Internal Derivation",
          "module": "Data.Derive.Internal.Derivation",
          "name": "Derivation",
          "package": "derive",
          "partial": "Derivation",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-Internal-Derivation.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Derive.Internal.Derivation",
          "name": "Derivation",
          "package": "derive",
          "source": "src/Data-Derive-Internal-Derivation.html#Derivation",
          "type": "data"
        },
        "index": {
          "hierarchy": "Data Derive Internal Derivation",
          "module": "Data.Derive.Internal.Derivation",
          "name": "Derivation",
          "package": "derive",
          "partial": "Derivation",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-Internal-Derivation.html#t:Derivation"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Derive.Internal.Derivation",
          "name": "Derivation",
          "package": "derive",
          "signature": "Derivation",
          "source": "src/Data-Derive-Internal-Derivation.html#Derivation",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Derive Internal Derivation",
          "module": "Data.Derive.Internal.Derivation",
          "name": "Derivation",
          "package": "derive",
          "partial": "Derivation",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-Internal-Derivation.html#v:Derivation"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Derive.Internal.Derivation",
          "name": "customContext",
          "package": "derive",
          "signature": "(FullDataDecl -\u003e Context -\u003e Context) -\u003e FullDataDecl -\u003e [Decl] -\u003e [Decl]",
          "source": "src/Data-Derive-Internal-Derivation.html#customContext",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Derive Internal Derivation",
          "module": "Data.Derive.Internal.Derivation",
          "name": "customContext",
          "normalized": "(FullDataDecl-\u003eContext-\u003eContext)-\u003eFullDataDecl-\u003e[Decl]-\u003e[Decl]",
          "package": "derive",
          "partial": "Context",
          "signature": "(FullDataDecl-\u003eContext-\u003eContext)-\u003eFullDataDecl-\u003e[Decl]-\u003e[Decl]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-Internal-Derivation.html#v:customContext"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Derive.Internal.Derivation",
          "name": "customSplice",
          "package": "derive",
          "signature": "(FullDataDecl -\u003e Exp -\u003e Exp) -\u003e FullDataDecl -\u003e [Decl] -\u003e [Decl]",
          "source": "src/Data-Derive-Internal-Derivation.html#customSplice",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Derive Internal Derivation",
          "module": "Data.Derive.Internal.Derivation",
          "name": "customSplice",
          "normalized": "(FullDataDecl-\u003eExp-\u003eExp)-\u003eFullDataDecl-\u003e[Decl]-\u003e[Decl]",
          "package": "derive",
          "partial": "Splice",
          "signature": "(FullDataDecl-\u003eExp-\u003eExp)-\u003eFullDataDecl-\u003e[Decl]-\u003e[Decl]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-Internal-Derivation.html#v:customSplice"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Derive.Internal.Derivation",
          "name": "derivationCustom",
          "package": "derive",
          "signature": "String -\u003e (FullDataDecl -\u003e Either String [Decl]) -\u003e Derivation",
          "source": "src/Data-Derive-Internal-Derivation.html#derivationCustom",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Derive Internal Derivation",
          "module": "Data.Derive.Internal.Derivation",
          "name": "derivationCustom",
          "normalized": "String-\u003e(FullDataDecl-\u003eEither String[Decl])-\u003eDerivation",
          "package": "derive",
          "partial": "Custom",
          "signature": "String-\u003e(FullDataDecl-\u003eEither String[Decl])-\u003eDerivation",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-Internal-Derivation.html#v:derivationCustom"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Derive.Internal.Derivation",
          "name": "derivationCustomDSL",
          "package": "derive",
          "signature": "String -\u003e (FullDataDecl -\u003e [Decl] -\u003e [Decl]) -\u003e DSL -\u003e Derivation",
          "source": "src/Data-Derive-Internal-Derivation.html#derivationCustomDSL",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Derive Internal Derivation",
          "module": "Data.Derive.Internal.Derivation",
          "name": "derivationCustomDSL",
          "normalized": "String-\u003e(FullDataDecl-\u003e[Decl]-\u003e[Decl])-\u003eDSL-\u003eDerivation",
          "package": "derive",
          "partial": "Custom DSL",
          "signature": "String-\u003e(FullDataDecl-\u003e[Decl]-\u003e[Decl])-\u003eDSL-\u003eDerivation",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-Internal-Derivation.html#v:derivationCustomDSL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Derive.Internal.Derivation",
          "name": "derivationDSL",
          "package": "derive",
          "signature": "String -\u003e DSL -\u003e Derivation",
          "source": "src/Data-Derive-Internal-Derivation.html#derivationDSL",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Derive Internal Derivation",
          "module": "Data.Derive.Internal.Derivation",
          "name": "derivationDSL",
          "normalized": "String-\u003eDSL-\u003eDerivation",
          "package": "derive",
          "partial": "DSL",
          "signature": "String-\u003eDSL-\u003eDerivation",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-Internal-Derivation.html#v:derivationDSL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Derive.Internal.Derivation",
          "name": "derivationName",
          "package": "derive",
          "signature": "String",
          "source": "src/Data-Derive-Internal-Derivation.html#Derivation",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Derive Internal Derivation",
          "module": "Data.Derive.Internal.Derivation",
          "name": "derivationName",
          "package": "derive",
          "partial": "Name",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-Internal-Derivation.html#v:derivationName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Derive.Internal.Derivation",
          "name": "derivationOp",
          "package": "derive",
          "signature": "Type -\u003e (String -\u003e Decl) -\u003e FullDataDecl -\u003e Either String [Decl]",
          "source": "src/Data-Derive-Internal-Derivation.html#Derivation",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Derive Internal Derivation",
          "module": "Data.Derive.Internal.Derivation",
          "name": "derivationOp",
          "normalized": "Type-\u003e(String-\u003eDecl)-\u003eFullDataDecl-\u003eEither String[Decl]",
          "package": "derive",
          "partial": "Op",
          "signature": "Type-\u003e(String-\u003eDecl)-\u003eFullDataDecl-\u003eEither String[Decl]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-Internal-Derivation.html#v:derivationOp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Derive.Internal.Derivation",
          "name": "derivationParams",
          "package": "derive",
          "signature": "String -\u003e ([Type] -\u003e (String -\u003e Decl) -\u003e FullDataDecl -\u003e Either String [Decl]) -\u003e Derivation",
          "source": "src/Data-Derive-Internal-Derivation.html#derivationParams",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Derive Internal Derivation",
          "module": "Data.Derive.Internal.Derivation",
          "name": "derivationParams",
          "normalized": "String-\u003e([Type]-\u003e(String-\u003eDecl)-\u003eFullDataDecl-\u003eEither String[Decl])-\u003eDerivation",
          "package": "derive",
          "partial": "Params",
          "signature": "String-\u003e([Type]-\u003e(String-\u003eDecl)-\u003eFullDataDecl-\u003eEither String[Decl])-\u003eDerivation",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-Internal-Derivation.html#v:derivationParams"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Derive.Is",
          "name": "Is",
          "package": "derive",
          "source": "src/Data-Derive-Is.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Data Derive Is",
          "module": "Data.Derive.Is",
          "name": "Is",
          "package": "derive",
          "partial": "Is",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-Is.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Derive.Is",
          "name": "makeIs",
          "package": "derive",
          "signature": "Derivation",
          "source": "src/Data-Derive-Is.html#makeIs",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Derive Is",
          "module": "Data.Derive.Is",
          "name": "makeIs",
          "package": "derive",
          "partial": "Is",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-Is.html#v:makeIs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eDerive \u003ccode\u003e\u003ca\u003eJSON\u003c/a\u003e\u003c/code\u003e instances.\n\u003c/p\u003e\u003cp\u003eUnlike Text.JSON.Generics, single constructor types are \u003cem\u003enot\u003c/em\u003e handled\n specially. Every value is encoded as an object with a single field,\n with the constructor name as key and the values as its contents.\n\u003c/p\u003e\u003cp\u003eIf the constructor is a record, the contents is an Object with the\n field names as keys. Otherwise, the contents is an array.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.Derive.JSON",
          "name": "JSON",
          "package": "derive",
          "source": "src/Data-Derive-JSON.html",
          "type": "module"
        },
        "index": {
          "description": "Derive JSON instances Unlike Text.JSON.Generics single constructor types are not handled specially Every value is encoded as an object with single field with the constructor name as key and the values as its contents If the constructor is record the contents is an Object with the field names as keys Otherwise the contents is an array",
          "hierarchy": "Data Derive JSON",
          "module": "Data.Derive.JSON",
          "name": "JSON",
          "package": "derive",
          "partial": "JSON",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-JSON.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eDerivation\u003c/a\u003e\u003c/code\u003e for \u003ccode\u003eJSON\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Data.Derive.JSON",
          "name": "makeJSON",
          "package": "derive",
          "signature": "Derivation",
          "source": "src/Data-Derive-JSON.html#makeJSON",
          "type": "function"
        },
        "index": {
          "description": "Derivation for JSON",
          "hierarchy": "Data Derive JSON",
          "module": "Data.Derive.JSON",
          "name": "makeJSON",
          "package": "derive",
          "partial": "JSON",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-JSON.html#v:makeJSON"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eA pseudo derivation.  For each field in the data type, deriving\n    \u003ccode\u003eLazySet\u003c/code\u003e generates a function like a record updator, but lazy where possible.\n    This is very useful in certain situations to improve laziness\n    properties.  A setter is only lazy if that field is present in one constructor.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.Derive.LazySet",
          "name": "LazySet",
          "package": "derive",
          "source": "src/Data-Derive-LazySet.html",
          "type": "module"
        },
        "index": {
          "description": "pseudo derivation For each field in the data type deriving LazySet generates function like record updator but lazy where possible This is very useful in certain situations to improve laziness properties setter is only lazy if that field is present in one constructor",
          "hierarchy": "Data Derive LazySet",
          "module": "Data.Derive.LazySet",
          "name": "LazySet",
          "package": "derive",
          "partial": "Lazy Set",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-LazySet.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Derive.LazySet",
          "name": "makeLazySet",
          "package": "derive",
          "signature": "Derivation",
          "source": "src/Data-Derive-LazySet.html#makeLazySet",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Derive LazySet",
          "module": "Data.Derive.LazySet",
          "name": "makeLazySet",
          "package": "derive",
          "partial": "Lazy Set",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-LazySet.html#v:makeLazySet"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eA pseudo derivation.  For each field in the data type, deriving\n    \u003ccode\u003eLens\u003c/code\u003e generates \u003ccode\u003elens\u003c/code\u003e\u003cem\u003eFieldName\u003c/em\u003e\u003ccode\u003e = lens \u003c/code\u003e\u003cem\u003efieldName\u003c/em\u003e\u003ccode\u003e\n    ( x v -\u003e v { \u003c/code\u003e\u003cem\u003efieldName\u003c/em\u003e\u003ccode\u003e = x })\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eThis works with the \u003ccode\u003edata-lens\u003c/code\u003e package.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.Derive.Lens",
          "name": "Lens",
          "package": "derive",
          "source": "src/Data-Derive-Lens.html",
          "type": "module"
        },
        "index": {
          "description": "pseudo derivation For each field in the data type deriving Lens generates lens FieldName lens fieldName fieldName This works with the data-lens package",
          "hierarchy": "Data Derive Lens",
          "module": "Data.Derive.Lens",
          "name": "Lens",
          "package": "derive",
          "partial": "Lens",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-Lens.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Derive.Lens",
          "name": "makeLens",
          "package": "derive",
          "signature": "Derivation",
          "source": "src/Data-Derive-Lens.html#makeLens",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Derive Lens",
          "module": "Data.Derive.Lens",
          "name": "makeLens",
          "package": "derive",
          "partial": "Lens",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-Lens.html#v:makeLens"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eDerives an instance of \u003ccode\u003eMonoid\u003c/code\u003e. It uses the product\n    construction of monoids. \u003ccode\u003emappend\u003c/code\u003e on two different constructors\n    is undefined.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.Derive.Monoid",
          "name": "Monoid",
          "package": "derive",
          "source": "src/Data-Derive-Monoid.html",
          "type": "module"
        },
        "index": {
          "description": "Derives an instance of Monoid It uses the product construction of monoids mappend on two different constructors is undefined",
          "hierarchy": "Data Derive Monoid",
          "module": "Data.Derive.Monoid",
          "name": "Monoid",
          "package": "derive",
          "partial": "Monoid",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-Monoid.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Derive.Monoid",
          "name": "makeMonoid",
          "package": "derive",
          "signature": "Derivation",
          "source": "src/Data-Derive-Monoid.html#makeMonoid",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Derive Monoid",
          "module": "Data.Derive.Monoid",
          "name": "makeMonoid",
          "package": "derive",
          "partial": "Monoid",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-Monoid.html#v:makeMonoid"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Derive.NFData",
          "name": "NFData",
          "package": "derive",
          "source": "src/Data-Derive-NFData.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Data Derive NFData",
          "module": "Data.Derive.NFData",
          "name": "NFData",
          "package": "derive",
          "partial": "NFData",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-NFData.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Derive.NFData",
          "name": "dslNFData",
          "package": "derive",
          "signature": "DSL",
          "source": "src/Data-Derive-NFData.html#dslNFData",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Derive NFData",
          "module": "Data.Derive.NFData",
          "name": "dslNFData",
          "package": "derive",
          "partial": "NFData",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-NFData.html#v:dslNFData"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Derive.NFData",
          "name": "makeNFData",
          "package": "derive",
          "signature": "Derivation",
          "source": "src/Data-Derive-NFData.html#makeNFData",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Derive NFData",
          "module": "Data.Derive.NFData",
          "name": "makeNFData",
          "package": "derive",
          "partial": "NFData",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-NFData.html#v:makeNFData"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Derive.Ord",
          "name": "Ord",
          "package": "derive",
          "source": "src/Data-Derive-Ord.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Data Derive Ord",
          "module": "Data.Derive.Ord",
          "name": "Ord",
          "package": "derive",
          "partial": "Ord",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-Ord.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Derive.Ord",
          "name": "dslOrd",
          "package": "derive",
          "signature": "DSL",
          "source": "src/Data-Derive-Ord.html#dslOrd",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Derive Ord",
          "module": "Data.Derive.Ord",
          "name": "dslOrd",
          "package": "derive",
          "partial": "Ord",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-Ord.html#v:dslOrd"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Derive.Ord",
          "name": "makeOrd",
          "package": "derive",
          "signature": "Derivation",
          "source": "src/Data-Derive-Ord.html#makeOrd",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Derive Ord",
          "module": "Data.Derive.Ord",
          "name": "makeOrd",
          "package": "derive",
          "partial": "Ord",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-Ord.html#v:makeOrd"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eDerives \u003ccode\u003eRead\u003c/code\u003e.  This is as defined by the Haskell report, except\n    there is no support for infix constructors.  If you attempt to\n    derive \u003ccode\u003eRead\u003c/code\u003e for a data type with infix constructors, the\n    constructors are handled as if they were prefix constructors, using\n    the \u003ccode\u003e(\u003c/code\u003e\u003cem\u003econsym\u003c/em\u003e\u003ccode\u003e)\u003c/code\u003e syntax.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.Derive.Read",
          "name": "Read",
          "package": "derive",
          "source": "src/Data-Derive-Read.html",
          "type": "module"
        },
        "index": {
          "description": "Derives Read This is as defined by the Haskell report except there is no support for infix constructors If you attempt to derive Read for data type with infix constructors the constructors are handled as if they were prefix constructors using the consym syntax",
          "hierarchy": "Data Derive Read",
          "module": "Data.Derive.Read",
          "name": "Read",
          "package": "derive",
          "partial": "Read",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-Read.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Derive.Read",
          "name": "makeRead",
          "package": "derive",
          "signature": "Derivation",
          "source": "src/Data-Derive-Read.html#makeRead",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Derive Read",
          "module": "Data.Derive.Read",
          "name": "makeRead",
          "package": "derive",
          "partial": "Read",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-Read.html#v:makeRead"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eA pseudo derivation.  For each field in the data type, deriving\n    \u003ccode\u003eRef\u003c/code\u003e generates \u003ccode\u003eref\u003c/code\u003e\u003cem\u003eFieldName\u003c/em\u003e\u003ccode\u003e = Ref { select = \u003c/code\u003e\u003cem\u003efieldName\u003c/em\u003e\u003ccode\u003e , update =\n     f v -\u003e v { \u003c/code\u003e\u003cem\u003efieldName\u003c/em\u003e\u003ccode\u003e = f (\u003c/code\u003e\u003cem\u003efieldName\u003c/em\u003e\u003ccode\u003e v) } }\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eThis is intended for use with the compositional functional references\n    described in\n    \u003ca\u003ehttp://www.haskell.org/pipermail/haskell-cafe/2007-June/026477.html\u003c/a\u003e.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.Derive.Ref",
          "name": "Ref",
          "package": "derive",
          "source": "src/Data-Derive-Ref.html",
          "type": "module"
        },
        "index": {
          "description": "pseudo derivation For each field in the data type deriving Ref generates ref FieldName Ref select fieldName update fieldName fieldName This is intended for use with the compositional functional references described in http www.haskell.org pipermail haskell-cafe June html",
          "hierarchy": "Data Derive Ref",
          "module": "Data.Derive.Ref",
          "name": "Ref",
          "package": "derive",
          "partial": "Ref",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-Ref.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Derive.Ref",
          "name": "makeRef",
          "package": "derive",
          "signature": "Derivation",
          "source": "src/Data-Derive-Ref.html#makeRef",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Derive Ref",
          "module": "Data.Derive.Ref",
          "name": "makeRef",
          "package": "derive",
          "partial": "Ref",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-Ref.html#v:makeRef"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Derive.Serial",
          "name": "Serial",
          "package": "derive",
          "source": "src/Data-Derive-Serial.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Data Derive Serial",
          "module": "Data.Derive.Serial",
          "name": "Serial",
          "package": "derive",
          "partial": "Serial",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-Serial.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Derive.Serial",
          "name": "dslSerial",
          "package": "derive",
          "signature": "DSL",
          "source": "src/Data-Derive-Serial.html#dslSerial",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Derive Serial",
          "module": "Data.Derive.Serial",
          "name": "dslSerial",
          "package": "derive",
          "partial": "Serial",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-Serial.html#v:dslSerial"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Derive.Serial",
          "name": "makeSerial",
          "package": "derive",
          "signature": "Derivation",
          "source": "src/Data-Derive-Serial.html#makeSerial",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Derive Serial",
          "module": "Data.Derive.Serial",
          "name": "makeSerial",
          "package": "derive",
          "partial": "Serial",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-Serial.html#v:makeSerial"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Derive.Serialize",
          "name": "Serialize",
          "package": "derive",
          "source": "src/Data-Derive-Serialize.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Data Derive Serialize",
          "module": "Data.Derive.Serialize",
          "name": "Serialize",
          "package": "derive",
          "partial": "Serialize",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-Serialize.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Derive.Serialize",
          "name": "dslSerialize",
          "package": "derive",
          "signature": "DSL",
          "source": "src/Data-Derive-Serialize.html#dslSerialize",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Derive Serialize",
          "module": "Data.Derive.Serialize",
          "name": "dslSerialize",
          "package": "derive",
          "partial": "Serialize",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-Serialize.html#v:dslSerialize"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Derive.Serialize",
          "name": "makeSerialize",
          "package": "derive",
          "signature": "Derivation",
          "source": "src/Data-Derive-Serialize.html#makeSerialize",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Derive Serialize",
          "module": "Data.Derive.Serialize",
          "name": "makeSerialize",
          "package": "derive",
          "partial": "Serialize",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-Serialize.html#v:makeSerialize"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eA pseudo derivation.  For each field in the data type, deriving\n    \u003ccode\u003eSet\u003c/code\u003e generates \u003ccode\u003eset\u003c/code\u003e\u003cem\u003eFieldName\u003c/em\u003e\u003ccode\u003e v x = x{\u003c/code\u003e\u003cem\u003efieldName\u003c/em\u003e\u003ccode\u003e = v}\u003c/code\u003e.\n    This derivation is intended to work around the fact that in Haskell\n    assigning to a field is not a first class object (although\n    extracting from a field is).\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.Derive.Set",
          "name": "Set",
          "package": "derive",
          "source": "src/Data-Derive-Set.html",
          "type": "module"
        },
        "index": {
          "description": "pseudo derivation For each field in the data type deriving Set generates set FieldName fieldName This derivation is intended to work around the fact that in Haskell assigning to field is not first class object although extracting from field is",
          "hierarchy": "Data Derive Set",
          "module": "Data.Derive.Set",
          "name": "Set",
          "package": "derive",
          "partial": "Set",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-Set.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Derive.Set",
          "name": "makeSet",
          "package": "derive",
          "signature": "Derivation",
          "source": "src/Data-Derive-Set.html#makeSet",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Derive Set",
          "module": "Data.Derive.Set",
          "name": "makeSet",
          "package": "derive",
          "partial": "Set",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-Set.html#v:makeSet"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eDerives \u003ccode\u003eShow\u003c/code\u003e.  This is as defined by the Haskell report, except\n there is no support for infix constructors.  If you attempt to\n derive \u003ccode\u003eShow\u003c/code\u003e for a data type with infix constructors, the\n constructors are handled as if they were prefix constructors, using\n the \u003ccode\u003e(\u003c/code\u003e\u003cem\u003econsym\u003c/em\u003e\u003ccode\u003e)\u003c/code\u003e syntax.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.Derive.Show",
          "name": "Show",
          "package": "derive",
          "source": "src/Data-Derive-Show.html",
          "type": "module"
        },
        "index": {
          "description": "Derives Show This is as defined by the Haskell report except there is no support for infix constructors If you attempt to derive Show for data type with infix constructors the constructors are handled as if they were prefix constructors using the consym syntax",
          "hierarchy": "Data Derive Show",
          "module": "Data.Derive.Show",
          "name": "Show",
          "package": "derive",
          "partial": "Show",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-Show.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Derive.Show",
          "name": "makeShow",
          "package": "derive",
          "signature": "Derivation",
          "source": "src/Data-Derive-Show.html#makeShow",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Derive Show",
          "module": "Data.Derive.Show",
          "name": "makeShow",
          "package": "derive",
          "partial": "Show",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-Show.html#v:makeShow"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Derive.Traversable",
          "name": "Traversable",
          "package": "derive",
          "source": "src/Data-Derive-Traversable.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Data Derive Traversable",
          "module": "Data.Derive.Traversable",
          "name": "Traversable",
          "package": "derive",
          "partial": "Traversable",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-Traversable.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Derive.Traversable",
          "name": "makeTraversable",
          "package": "derive",
          "signature": "Derivation",
          "source": "src/Data-Derive-Traversable.html#makeTraversable",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Derive Traversable",
          "module": "Data.Derive.Traversable",
          "name": "makeTraversable",
          "package": "derive",
          "partial": "Traversable",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-Traversable.html#v:makeTraversable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Derive.Traversable",
          "name": "makeTraversableN",
          "package": "derive",
          "signature": "Int -\u003e Derivation",
          "source": "src/Data-Derive-Traversable.html#makeTraversableN",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Derive Traversable",
          "module": "Data.Derive.Traversable",
          "name": "makeTraversableN",
          "normalized": "Int-\u003eDerivation",
          "package": "derive",
          "partial": "Traversable",
          "signature": "Int-\u003eDerivation",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-Traversable.html#v:makeTraversableN"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eDerivation for the \u003ccode\u003eTypeable\u003c/code\u003e class, as described in the Scrap\n    Your Boilerplate papers.  This derivation generates instances for\n    all kinds of TypeableK classes; as such we do NOT require the\n    GHC-specific generic downkinding instances to provide lower kind\n    instances.\n\u003c/p\u003e\u003cp\u003eAlso creates a \u003ccode\u003etypename_\u003cthe type name\u003e\u003c/code\u003e value to hold the\n    \u003ccode\u003eTypeRep\u003c/code\u003e.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.Derive.Typeable",
          "name": "Typeable",
          "package": "derive",
          "source": "src/Data-Derive-Typeable.html",
          "type": "module"
        },
        "index": {
          "description": "Derivation for the Typeable class as described in the Scrap Your Boilerplate papers This derivation generates instances for all kinds of TypeableK classes as such we do NOT require the GHC-specific generic downkinding instances to provide lower kind instances Also creates typename the type name value to hold the TypeRep",
          "hierarchy": "Data Derive Typeable",
          "module": "Data.Derive.Typeable",
          "name": "Typeable",
          "package": "derive",
          "partial": "Typeable",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-Typeable.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Derive.Typeable",
          "name": "makeTypeable",
          "package": "derive",
          "signature": "Derivation",
          "source": "src/Data-Derive-Typeable.html#makeTypeable",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Derive Typeable",
          "module": "Data.Derive.Typeable",
          "name": "makeTypeable",
          "package": "derive",
          "partial": "Typeable",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-Typeable.html#v:makeTypeable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eDerive Uniplate and Biplate using the Direct combinators.\n   You must request monomorphic instances, i.e:\n\u003c/p\u003e\u003cpre\u003e data Foo a = Foo a (Bool, a)\n\n {-!\n deriving instance UniplateDirect (Foo Int)\n deriving instance UniplateDirect (Bool, Int) Int\n deriving instance UniplateDirect (Foo Int) Int\n !-}\n\u003c/pre\u003e\u003cp\u003eThis will generate the instances \u003ccode\u003eUniplate (Foo Int)\u003c/code\u003e,\n   \u003ccode\u003eBiplate (Bool, Int) Int\u003c/code\u003e and \u003ccode\u003eBiplate (Foo Int) Int\u003c/code\u003e.\n   Generally, start with the instance you are after (e.g. \u003ccode\u003eUniplateDirect (Foo Int)\u003c/code\u003e),\n   try to compile and add further instances as necessary. \u003ccode\u003eUniplateDirect\u003c/code\u003e with\n   one argument derives Uniplate, and with two arguments derives Biplate.\n\u003c/p\u003e\u003cp\u003e\u003ccode\u003ederiving UniplateDirect\u003c/code\u003e on a data type with no arguments derives Uniplate\n   with all type parameters defaulting to \u003ccode\u003e()\u003c/code\u003e.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.Derive.UniplateDirect",
          "name": "UniplateDirect",
          "package": "derive",
          "source": "src/Data-Derive-UniplateDirect.html",
          "type": "module"
        },
        "index": {
          "description": "Derive Uniplate and Biplate using the Direct combinators You must request monomorphic instances i.e data Foo Foo Bool deriving instance UniplateDirect Foo Int deriving instance UniplateDirect Bool Int Int deriving instance UniplateDirect Foo Int Int This will generate the instances Uniplate Foo Int Biplate Bool Int Int and Biplate Foo Int Int Generally start with the instance you are after e.g UniplateDirect Foo Int try to compile and add further instances as necessary UniplateDirect with one argument derives Uniplate and with two arguments derives Biplate deriving UniplateDirect on data type with no arguments derives Uniplate with all type parameters defaulting to",
          "hierarchy": "Data Derive UniplateDirect",
          "module": "Data.Derive.UniplateDirect",
          "name": "UniplateDirect",
          "package": "derive",
          "partial": "Uniplate Direct",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-UniplateDirect.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Derive.UniplateDirect",
          "name": "makeUniplateDirect",
          "package": "derive",
          "signature": "Derivation",
          "source": "src/Data-Derive-UniplateDirect.html#makeUniplateDirect",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Derive UniplateDirect",
          "module": "Data.Derive.UniplateDirect",
          "name": "makeUniplateDirect",
          "package": "derive",
          "partial": "Uniplate Direct",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-UniplateDirect.html#v:makeUniplateDirect"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Derive.UniplateTypeable",
          "name": "UniplateTypeable",
          "package": "derive",
          "source": "src/Data-Derive-UniplateTypeable.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Data Derive UniplateTypeable",
          "module": "Data.Derive.UniplateTypeable",
          "name": "UniplateTypeable",
          "package": "derive",
          "partial": "Uniplate Typeable",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-UniplateTypeable.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Derive.UniplateTypeable",
          "name": "custom",
          "package": "derive",
          "signature": "(t, Decl) -\u003e [Decl] -\u003e [Decl]",
          "source": "src/Data-Derive-UniplateTypeable.html#custom",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Derive UniplateTypeable",
          "module": "Data.Derive.UniplateTypeable",
          "name": "custom",
          "normalized": "(a,Decl)-\u003e[Decl]-\u003e[Decl]",
          "package": "derive",
          "signature": "(t,Decl)-\u003e[Decl]-\u003e[Decl]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-UniplateTypeable.html#v:custom"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Derive.UniplateTypeable",
          "name": "makeUniplateTypeable",
          "package": "derive",
          "signature": "Derivation",
          "source": "src/Data-Derive-UniplateTypeable.html#makeUniplateTypeable",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Derive UniplateTypeable",
          "module": "Data.Derive.UniplateTypeable",
          "name": "makeUniplateTypeable",
          "package": "derive",
          "partial": "Uniplate Typeable",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-UniplateTypeable.html#v:makeUniplateTypeable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eA Pseudo derivation. For every label, creates a function\n    foo_u and foo_s which updates and sets the label respectively,\n    e.g. 'foo_u (+1) bar' or 'foo_s 10 baz'\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.Derive.Update",
          "name": "Update",
          "package": "derive",
          "source": "src/Data-Derive-Update.html",
          "type": "module"
        },
        "index": {
          "description": "Pseudo derivation For every label creates function foo and foo which updates and sets the label respectively e.g foo bar or foo baz",
          "hierarchy": "Data Derive Update",
          "module": "Data.Derive.Update",
          "name": "Update",
          "package": "derive",
          "partial": "Update",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-Update.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Derive.Update",
          "name": "makeUpdate",
          "package": "derive",
          "signature": "Derivation",
          "source": "src/Data-Derive-Update.html#makeUpdate",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Derive Update",
          "module": "Data.Derive.Update",
          "name": "makeUpdate",
          "package": "derive",
          "partial": "Update",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Data-Derive-Update.html#v:makeUpdate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.DeriveDSL",
          "name": "DeriveDSL",
          "package": "derive",
          "source": "src/Data-DeriveDSL.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Data DeriveDSL",
          "module": "Data.DeriveDSL",
          "name": "DeriveDSL",
          "package": "derive",
          "partial": "Derive DSL",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Data-DeriveDSL.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.DeriveDSL",
          "name": "DSL",
          "package": "derive",
          "source": "src/Data-Derive-DSL-DSL.html#DSL",
          "type": "data"
        },
        "index": {
          "hierarchy": "Data DeriveDSL",
          "module": "Data.DeriveDSL",
          "name": "DSL",
          "package": "derive",
          "partial": "DSL",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Data-DeriveDSL.html#t:DSL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.DeriveDSL",
          "name": "applyDSL",
          "package": "derive",
          "signature": "DSL -\u003e DataDecl -\u003e Either String [Decl]",
          "source": "src/Data-DeriveDSL.html#applyDSL",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data DeriveDSL",
          "module": "Data.DeriveDSL",
          "name": "applyDSL",
          "normalized": "DSL-\u003eDataDecl-\u003eEither String[Decl]",
          "package": "derive",
          "partial": "DSL",
          "signature": "DSL-\u003eDataDecl-\u003eEither String[Decl]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Data-DeriveDSL.html#v:applyDSL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.DeriveDSL",
          "name": "deriveDSL",
          "package": "derive",
          "signature": "[Decl] -\u003e Maybe DSL",
          "source": "src/Data-DeriveDSL.html#deriveDSL",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data DeriveDSL",
          "module": "Data.DeriveDSL",
          "name": "deriveDSL",
          "normalized": "[Decl]-\u003eMaybe DSL",
          "package": "derive",
          "partial": "DSL",
          "signature": "[Decl]-\u003eMaybe DSL",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Data-DeriveDSL.html#v:deriveDSL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.DeriveDSL",
          "name": "dynamicDSL",
          "package": "derive",
          "signature": "DSL -\u003e Maybe [Decl]",
          "source": "src/Data-DeriveDSL.html#dynamicDSL",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data DeriveDSL",
          "module": "Data.DeriveDSL",
          "name": "dynamicDSL",
          "normalized": "DSL-\u003eMaybe[Decl]",
          "package": "derive",
          "partial": "DSL",
          "signature": "DSL-\u003eMaybe[Decl]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Data-DeriveDSL.html#v:dynamicDSL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eUse this module to create your own derive program, supporting custom derivations.\n   As an example:\n\u003c/p\u003e\u003cpre\u003e\n   import \u003ca\u003eData.DeriveMain\u003c/a\u003e        (\u003ccode\u003e\u003ca\u003ederiveMain\u003c/a\u003e\u003c/code\u003e)\n   import \u003ca\u003eData.Derive.All\u003c/a\u003e        (\u003ccode\u003e\u003ca\u003ederivations\u003c/a\u003e\u003c/code\u003e)\n   import MyProject.MyDerivation (myDerivation)\n\u003c/pre\u003e\u003cpre\u003e\n   main :: IO\n   main = \u003ccode\u003e\u003ca\u003ederiveMain\u003c/a\u003e\u003c/code\u003e $ [myDerivation] ++ \u003ccode\u003e\u003ca\u003ederivations\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e\u003c/div\u003e",
          "module": "Data.DeriveMain",
          "name": "DeriveMain",
          "package": "derive",
          "source": "src/Data-DeriveMain.html",
          "type": "module"
        },
        "index": {
          "description": "Use this module to create your own derive program supporting custom derivations As an example import Data.DeriveMain deriveMain import Data.Derive.All derivations import MyProject.MyDerivation myDerivation main IO main deriveMain myDerivation derivations",
          "hierarchy": "Data DeriveMain",
          "module": "Data.DeriveMain",
          "name": "DeriveMain",
          "package": "derive",
          "partial": "Derive Main",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Data-DeriveMain.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.DeriveMain",
          "name": "deriveMain",
          "package": "derive",
          "signature": "[Derivation] -\u003e IO ()",
          "source": "src/Derive-Main.html#deriveMain",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data DeriveMain",
          "module": "Data.DeriveMain",
          "name": "deriveMain",
          "normalized": "[Derivation]-\u003eIO()",
          "package": "derive",
          "partial": "Main",
          "signature": "[Derivation]-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Data-DeriveMain.html#v:deriveMain"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThe main TH driver module.  It is intended that this need be the\n only module imported by user code; it takes care of all data\n threading issues such that all one needs to do is:\n\u003c/p\u003e\u003cpre\u003e\n   data Foo = Foo ; $( derive makeEq ''Foo )\n\u003c/pre\u003e\u003c/div\u003e",
          "module": "Data.DeriveTH",
          "name": "DeriveTH",
          "package": "derive",
          "source": "src/Data-DeriveTH.html",
          "type": "module"
        },
        "index": {
          "description": "The main TH driver module It is intended that this need be the only module imported by user code it takes care of all data threading issues such that all one needs to do is data Foo Foo derive makeEq Foo",
          "hierarchy": "Data DeriveTH",
          "module": "Data.DeriveTH",
          "name": "DeriveTH",
          "package": "derive",
          "partial": "Derive TH",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Data-DeriveTH.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDerive an instance of some class. \u003ccode\u003ederive\u003c/code\u003e only derives instances\n for the type of the argument.\n\u003c/p\u003e",
          "module": "Data.DeriveTH",
          "name": "derive",
          "package": "derive",
          "signature": "Derivation -\u003e Name -\u003e Q [Dec]",
          "source": "src/Data-DeriveTH.html#derive",
          "type": "function"
        },
        "index": {
          "description": "Derive an instance of some class derive only derives instances for the type of the argument",
          "hierarchy": "Data DeriveTH",
          "module": "Data.DeriveTH",
          "name": "derive",
          "normalized": "Derivation-\u003eName-\u003eQ[Dec]",
          "package": "derive",
          "signature": "Derivation-\u003eName-\u003eQ[Dec]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Data-DeriveTH.html#v:derive"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDerive an instance of some class. \u003ccode\u003ederiveFromDec\u003c/code\u003e only derives instances\n for the type of the argument.\n\u003c/p\u003e",
          "module": "Data.DeriveTH",
          "name": "deriveFromDec",
          "package": "derive",
          "signature": "Derivation -\u003e Dec -\u003e Q [Dec]",
          "source": "src/Data-DeriveTH.html#deriveFromDec",
          "type": "function"
        },
        "index": {
          "description": "Derive an instance of some class deriveFromDec only derives instances for the type of the argument",
          "hierarchy": "Data DeriveTH",
          "module": "Data.DeriveTH",
          "name": "deriveFromDec",
          "normalized": "Derivation-\u003eDec-\u003eQ[Dec]",
          "package": "derive",
          "partial": "From Dec",
          "signature": "Derivation-\u003eDec-\u003eQ[Dec]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Data-DeriveTH.html#v:deriveFromDec"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.DeriveTH",
          "name": "derives",
          "package": "derive",
          "signature": "[Derivation] -\u003e [Name] -\u003e Q [Dec]",
          "source": "src/Data-DeriveTH.html#derives",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data DeriveTH",
          "module": "Data.DeriveTH",
          "name": "derives",
          "normalized": "[Derivation]-\u003e[Name]-\u003eQ[Dec]",
          "package": "derive",
          "signature": "[Derivation]-\u003e[Name]-\u003eQ[Dec]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Data-DeriveTH.html#v:derives"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Convert",
          "name": "Convert",
          "package": "derive",
          "source": "src/Language-Haskell-Convert.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Language Haskell Convert",
          "module": "Language.Haskell.Convert",
          "name": "Convert",
          "package": "derive",
          "partial": "Convert",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-Convert.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Convert",
          "name": "Convert",
          "package": "derive",
          "source": "src/Language-Haskell-Convert.html#Convert",
          "type": "class"
        },
        "index": {
          "hierarchy": "Language Haskell Convert",
          "module": "Language.Haskell.Convert",
          "name": "Convert",
          "package": "derive",
          "partial": "Convert",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-Convert.html#t:Convert"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Convert",
          "name": "convert",
          "package": "derive",
          "signature": "a -\u003e b",
          "source": "src/Language-Haskell-Convert.html#convert",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Convert",
          "module": "Language.Haskell.Convert",
          "name": "convert",
          "normalized": "a-\u003eb",
          "package": "derive",
          "signature": "a-\u003eb",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-Convert.html#v:convert"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.All",
          "name": "All",
          "package": "derive",
          "source": "src/Language-Haskell-TH-All.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Language Haskell TH All",
          "module": "Language.Haskell.TH.All",
          "name": "All",
          "package": "derive",
          "partial": "All",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-All.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe type of ways to derive classes.\n   Should not really be in this module!\n\u003c/p\u003e",
          "module": "Language.Haskell.TH.All",
          "name": "Derivation",
          "package": "derive",
          "source": "src/Language-Haskell-TH-All.html#Derivation",
          "type": "data"
        },
        "index": {
          "description": "The type of ways to derive classes Should not really be in this module",
          "hierarchy": "Language Haskell TH All",
          "module": "Language.Haskell.TH.All",
          "name": "Derivation",
          "package": "derive",
          "partial": "Derivation",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-All.html#t:Derivation"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.All",
          "name": "Derivation",
          "package": "derive",
          "signature": "Derivation",
          "source": "src/Language-Haskell-TH-All.html#Derivation",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH All",
          "module": "Language.Haskell.TH.All",
          "name": "Derivation",
          "package": "derive",
          "partial": "Derivation",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-All.html#v:Derivation"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.All",
          "name": "derivation",
          "package": "derive",
          "signature": "(DataDef -\u003e [Dec]) -\u003e String -\u003e Derivation",
          "source": "src/Language-Haskell-TH-All.html#derivation",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH All",
          "module": "Language.Haskell.TH.All",
          "name": "derivation",
          "normalized": "(DataDef-\u003e[Dec])-\u003eString-\u003eDerivation",
          "package": "derive",
          "signature": "(DataDef-\u003e[Dec])-\u003eString-\u003eDerivation",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-All.html#v:derivation"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe derivation function proper\n\u003c/p\u003e",
          "module": "Language.Haskell.TH.All",
          "name": "derivationDeriver",
          "package": "derive",
          "signature": "DataDef -\u003e Q [Dec]",
          "source": "src/Language-Haskell-TH-All.html#Derivation",
          "type": "function"
        },
        "index": {
          "description": "The derivation function proper",
          "hierarchy": "Language Haskell TH All",
          "module": "Language.Haskell.TH.All",
          "name": "derivationDeriver",
          "normalized": "DataDef-\u003eQ[Dec]",
          "package": "derive",
          "partial": "Deriver",
          "signature": "DataDef-\u003eQ[Dec]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-All.html#v:derivationDeriver"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe name of the derivation\n\u003c/p\u003e",
          "module": "Language.Haskell.TH.All",
          "name": "derivationName",
          "package": "derive",
          "signature": "String",
          "source": "src/Language-Haskell-TH-All.html#Derivation",
          "type": "function"
        },
        "index": {
          "description": "The name of the derivation",
          "hierarchy": "Language Haskell TH All",
          "module": "Language.Haskell.TH.All",
          "name": "derivationName",
          "package": "derive",
          "partial": "Name",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-All.html#v:derivationName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.All",
          "name": "derivationQ",
          "package": "derive",
          "signature": "(DataDef -\u003e Q [Dec]) -\u003e String -\u003e Derivation",
          "source": "src/Language-Haskell-TH-All.html#derivationQ",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH All",
          "module": "Language.Haskell.TH.All",
          "name": "derivationQ",
          "normalized": "(DataDef-\u003eQ[Dec])-\u003eString-\u003eDerivation",
          "package": "derive",
          "signature": "(DataDef-\u003eQ[Dec])-\u003eString-\u003eDerivation",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-All.html#v:derivationQ"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eCompatibility definitions to paper over differences between 6.10 and 6.12.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Language.Haskell.TH.Compat",
          "name": "Compat",
          "package": "derive",
          "source": "src/Language-Haskell-TH-Compat.html",
          "type": "module"
        },
        "index": {
          "description": "Compatibility definitions to paper over differences between and",
          "hierarchy": "Language Haskell TH Compat",
          "module": "Language.Haskell.TH.Compat",
          "name": "Compat",
          "package": "derive",
          "partial": "Compat",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-Compat.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Compat",
          "name": "dataDefinitionTypeArgs",
          "package": "derive",
          "signature": "Dec -\u003e [Name]",
          "source": "src/Language-Haskell-TH-Compat.html#dataDefinitionTypeArgs",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH Compat",
          "module": "Language.Haskell.TH.Compat",
          "name": "dataDefinitionTypeArgs",
          "normalized": "Dec-\u003e[Name]",
          "package": "derive",
          "partial": "Definition Type Args",
          "signature": "Dec-\u003e[Name]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-Compat.html#v:dataDefinitionTypeArgs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Compat",
          "name": "fromTyVar",
          "package": "derive",
          "signature": "TyVarBndr -\u003e Name",
          "source": "src/Language-Haskell-TH-Compat.html#fromTyVar",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH Compat",
          "module": "Language.Haskell.TH.Compat",
          "name": "fromTyVar",
          "normalized": "TyVarBndr-\u003eName",
          "package": "derive",
          "partial": "Ty Var",
          "signature": "TyVarBndr-\u003eName",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-Compat.html#v:fromTyVar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Compat",
          "name": "typeToPred",
          "package": "derive",
          "signature": "Type -\u003e Pred",
          "source": "src/Language-Haskell-TH-Compat.html#typeToPred",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH Compat",
          "module": "Language.Haskell.TH.Compat",
          "name": "typeToPred",
          "normalized": "Type-\u003ePred",
          "package": "derive",
          "partial": "To Pred",
          "signature": "Type-\u003ePred",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-Compat.html#v:typeToPred"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThe core module of the Data.Derive system.  This module contains\n the data types used for communication between the extractors and\n the derivors.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Language.Haskell.TH.Data",
          "name": "Data",
          "package": "derive",
          "source": "src/Language-Haskell-TH-Data.html",
          "type": "module"
        },
        "index": {
          "description": "The core module of the Data.Derive system This module contains the data types used for communication between the extractors and the derivors",
          "hierarchy": "Language Haskell TH Data",
          "module": "Language.Haskell.TH.Data",
          "name": "Data",
          "package": "derive",
          "partial": "Data",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-Data.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Data",
          "name": "CtorDef",
          "package": "derive",
          "source": "src/Language-Haskell-TH-Data.html#CtorDef",
          "type": "type"
        },
        "index": {
          "hierarchy": "Language Haskell TH Data",
          "module": "Language.Haskell.TH.Data",
          "name": "CtorDef",
          "package": "derive",
          "partial": "Ctor Def",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-Data.html#t:CtorDef"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Data",
          "name": "DataDef",
          "package": "derive",
          "source": "src/Language-Haskell-TH-Data.html#DataDef",
          "type": "type"
        },
        "index": {
          "hierarchy": "Language Haskell TH Data",
          "module": "Language.Haskell.TH.Data",
          "name": "DataDef",
          "package": "derive",
          "partial": "Data Def",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-Data.html#t:DataDef"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Data",
          "name": "ctorArity",
          "package": "derive",
          "signature": "CtorDef -\u003e Int",
          "source": "src/Language-Haskell-TH-Data.html#ctorArity",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH Data",
          "module": "Language.Haskell.TH.Data",
          "name": "ctorArity",
          "normalized": "CtorDef-\u003eInt",
          "package": "derive",
          "partial": "Arity",
          "signature": "CtorDef-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-Data.html#v:ctorArity"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Data",
          "name": "ctorFields",
          "package": "derive",
          "signature": "CtorDef -\u003e [String]",
          "source": "src/Language-Haskell-TH-Data.html#ctorFields",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH Data",
          "module": "Language.Haskell.TH.Data",
          "name": "ctorFields",
          "normalized": "CtorDef-\u003e[String]",
          "package": "derive",
          "partial": "Fields",
          "signature": "CtorDef-\u003e[String]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-Data.html#v:ctorFields"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Data",
          "name": "ctorName",
          "package": "derive",
          "signature": "CtorDef -\u003e String",
          "source": "src/Language-Haskell-TH-Data.html#ctorName",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH Data",
          "module": "Language.Haskell.TH.Data",
          "name": "ctorName",
          "normalized": "CtorDef-\u003eString",
          "package": "derive",
          "partial": "Name",
          "signature": "CtorDef-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-Data.html#v:ctorName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Data",
          "name": "ctorStrictTypes",
          "package": "derive",
          "signature": "CtorDef -\u003e [StrictType]",
          "source": "src/Language-Haskell-TH-Data.html#ctorStrictTypes",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH Data",
          "module": "Language.Haskell.TH.Data",
          "name": "ctorStrictTypes",
          "normalized": "CtorDef-\u003e[StrictType]",
          "package": "derive",
          "partial": "Strict Types",
          "signature": "CtorDef-\u003e[StrictType]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-Data.html#v:ctorStrictTypes"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Data",
          "name": "ctorTypes",
          "package": "derive",
          "signature": "CtorDef -\u003e [Type]",
          "source": "src/Language-Haskell-TH-Data.html#ctorTypes",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH Data",
          "module": "Language.Haskell.TH.Data",
          "name": "ctorTypes",
          "normalized": "CtorDef-\u003e[Type]",
          "package": "derive",
          "partial": "Types",
          "signature": "CtorDef-\u003e[Type]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-Data.html#v:ctorTypes"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Data",
          "name": "dataArgs",
          "package": "derive",
          "signature": "DataDef -\u003e [Name]",
          "source": "src/Language-Haskell-TH-Data.html#dataArgs",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH Data",
          "module": "Language.Haskell.TH.Data",
          "name": "dataArgs",
          "normalized": "DataDef-\u003e[Name]",
          "package": "derive",
          "partial": "Args",
          "signature": "DataDef-\u003e[Name]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-Data.html#v:dataArgs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Data",
          "name": "dataArity",
          "package": "derive",
          "signature": "DataDef -\u003e Int",
          "source": "src/Language-Haskell-TH-Data.html#dataArity",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH Data",
          "module": "Language.Haskell.TH.Data",
          "name": "dataArity",
          "normalized": "DataDef-\u003eInt",
          "package": "derive",
          "partial": "Arity",
          "signature": "DataDef-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-Data.html#v:dataArity"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Data",
          "name": "dataCtors",
          "package": "derive",
          "signature": "DataDef -\u003e [CtorDef]",
          "source": "src/Language-Haskell-TH-Data.html#dataCtors",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH Data",
          "module": "Language.Haskell.TH.Data",
          "name": "dataCtors",
          "normalized": "DataDef-\u003e[CtorDef]",
          "package": "derive",
          "partial": "Ctors",
          "signature": "DataDef-\u003e[CtorDef]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-Data.html#v:dataCtors"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Data",
          "name": "dataName",
          "package": "derive",
          "signature": "DataDef -\u003e String",
          "source": "src/Language-Haskell-TH-Data.html#dataName",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH Data",
          "module": "Language.Haskell.TH.Data",
          "name": "dataName",
          "normalized": "DataDef-\u003eString",
          "package": "derive",
          "partial": "Name",
          "signature": "DataDef-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-Data.html#v:dataName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Data",
          "name": "dropModule",
          "package": "derive",
          "signature": "String -\u003e String",
          "source": "src/Language-Haskell-TH-Data.html#dropModule",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH Data",
          "module": "Language.Haskell.TH.Data",
          "name": "dropModule",
          "normalized": "String-\u003eString",
          "package": "derive",
          "partial": "Module",
          "signature": "String-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-Data.html#v:dropModule"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Data",
          "name": "dropNumber",
          "package": "derive",
          "signature": "String -\u003e String",
          "source": "src/Language-Haskell-TH-Data.html#dropNumber",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH Data",
          "module": "Language.Haskell.TH.Data",
          "name": "dropNumber",
          "normalized": "String-\u003eString",
          "package": "derive",
          "partial": "Number",
          "signature": "String-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-Data.html#v:dropNumber"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Data",
          "name": "eqConT",
          "package": "derive",
          "signature": "String -\u003e Type -\u003e Bool",
          "source": "src/Language-Haskell-TH-Data.html#eqConT",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH Data",
          "module": "Language.Haskell.TH.Data",
          "name": "eqConT",
          "normalized": "String-\u003eType-\u003eBool",
          "package": "derive",
          "partial": "Con",
          "signature": "String-\u003eType-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-Data.html#v:eqConT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Data",
          "name": "isTupleT",
          "package": "derive",
          "signature": "Type -\u003e Bool",
          "source": "src/Language-Haskell-TH-Data.html#isTupleT",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH Data",
          "module": "Language.Haskell.TH.Data",
          "name": "isTupleT",
          "normalized": "Type-\u003eBool",
          "package": "derive",
          "partial": "Tuple",
          "signature": "Type-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-Data.html#v:isTupleT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Data",
          "name": "normData",
          "package": "derive",
          "signature": "DataDef -\u003e DataDef",
          "source": "src/Language-Haskell-TH-Data.html#normData",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH Data",
          "module": "Language.Haskell.TH.Data",
          "name": "normData",
          "normalized": "DataDef-\u003eDataDef",
          "package": "derive",
          "partial": "Data",
          "signature": "DataDef-\u003eDataDef",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-Data.html#v:normData"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Data",
          "name": "qualifiedCtorName",
          "package": "derive",
          "signature": "CtorDef -\u003e Name",
          "source": "src/Language-Haskell-TH-Data.html#qualifiedCtorName",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH Data",
          "module": "Language.Haskell.TH.Data",
          "name": "qualifiedCtorName",
          "normalized": "CtorDef-\u003eName",
          "package": "derive",
          "partial": "Ctor Name",
          "signature": "CtorDef-\u003eName",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-Data.html#v:qualifiedCtorName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Data",
          "name": "qualifiedDataName",
          "package": "derive",
          "signature": "DataDef -\u003e Name",
          "source": "src/Language-Haskell-TH-Data.html#qualifiedDataName",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH Data",
          "module": "Language.Haskell.TH.Data",
          "name": "qualifiedDataName",
          "normalized": "DataDef-\u003eName",
          "package": "derive",
          "partial": "Data Name",
          "signature": "DataDef-\u003eName",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-Data.html#v:qualifiedDataName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Data",
          "name": "typeApp",
          "package": "derive",
          "signature": "Type -\u003e (Type, [Type])",
          "source": "src/Language-Haskell-TH-Data.html#typeApp",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH Data",
          "module": "Language.Haskell.TH.Data",
          "name": "typeApp",
          "normalized": "Type-\u003e(Type,[Type])",
          "package": "derive",
          "partial": "App",
          "signature": "Type-\u003e(Type,[Type])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-Data.html#v:typeApp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Data",
          "name": "unqualifiedName",
          "package": "derive",
          "signature": "Name -\u003e String",
          "source": "src/Language-Haskell-TH-Data.html#unqualifiedName",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH Data",
          "module": "Language.Haskell.TH.Data",
          "name": "unqualifiedName",
          "normalized": "Name-\u003eString",
          "package": "derive",
          "partial": "Name",
          "signature": "Name-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-Data.html#v:unqualifiedName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eExpand type synonyms in data declarations.\n\u003c/p\u003e\u003cp\u003eThis is needed for some type based derivations.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Language.Haskell.TH.ExpandSynonym",
          "name": "ExpandSynonym",
          "package": "derive",
          "source": "src/Language-Haskell-TH-ExpandSynonym.html",
          "type": "module"
        },
        "index": {
          "description": "Expand type synonyms in data declarations This is needed for some type based derivations",
          "hierarchy": "Language Haskell TH ExpandSynonym",
          "module": "Language.Haskell.TH.ExpandSynonym",
          "name": "ExpandSynonym",
          "package": "derive",
          "partial": "Expand Synonym",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-ExpandSynonym.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExpand type synonyms in a data declaration\n\u003c/p\u003e",
          "module": "Language.Haskell.TH.ExpandSynonym",
          "name": "expandData",
          "package": "derive",
          "signature": "DataDef -\u003e Q DataDef",
          "source": "src/Language-Haskell-TH-ExpandSynonym.html#expandData",
          "type": "function"
        },
        "index": {
          "description": "Expand type synonyms in data declaration",
          "hierarchy": "Language Haskell TH ExpandSynonym",
          "module": "Language.Haskell.TH.ExpandSynonym",
          "name": "expandData",
          "normalized": "DataDef-\u003eQ DataDef",
          "package": "derive",
          "partial": "Data",
          "signature": "DataDef-\u003eQ DataDef",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-ExpandSynonym.html#v:expandData"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.FixedPpr",
          "name": "FixedPpr",
          "package": "derive",
          "source": "src/Language-Haskell-TH-FixedPpr.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Language Haskell TH FixedPpr",
          "module": "Language.Haskell.TH.FixedPpr",
          "name": "FixedPpr",
          "package": "derive",
          "partial": "Fixed Ppr",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-FixedPpr.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.FixedPpr",
          "name": "Ppr",
          "package": "derive",
          "source": "src/Language-Haskell-TH-FixedPpr.html#Ppr",
          "type": "class"
        },
        "index": {
          "hierarchy": "Language Haskell TH FixedPpr",
          "module": "Language.Haskell.TH.FixedPpr",
          "name": "Ppr",
          "package": "derive",
          "partial": "Ppr",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-FixedPpr.html#t:Ppr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.FixedPpr",
          "name": "Precedence",
          "package": "derive",
          "source": "src/Language-Haskell-TH-FixedPpr.html#Precedence",
          "type": "type"
        },
        "index": {
          "hierarchy": "Language Haskell TH FixedPpr",
          "module": "Language.Haskell.TH.FixedPpr",
          "name": "Precedence",
          "package": "derive",
          "partial": "Precedence",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-FixedPpr.html#t:Precedence"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.FixedPpr",
          "name": "appPrec",
          "package": "derive",
          "signature": "Precedence",
          "source": "src/Language-Haskell-TH-FixedPpr.html#appPrec",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH FixedPpr",
          "module": "Language.Haskell.TH.FixedPpr",
          "name": "appPrec",
          "package": "derive",
          "partial": "Prec",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-FixedPpr.html#v:appPrec"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.FixedPpr",
          "name": "deQualLhsHead",
          "package": "derive",
          "signature": "Dec -\u003e Dec",
          "source": "src/Language-Haskell-TH-FixedPpr.html#deQualLhsHead",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH FixedPpr",
          "module": "Language.Haskell.TH.FixedPpr",
          "name": "deQualLhsHead",
          "normalized": "Dec-\u003eDec",
          "package": "derive",
          "partial": "Qual Lhs Head",
          "signature": "Dec-\u003eDec",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-FixedPpr.html#v:deQualLhsHead"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.FixedPpr",
          "name": "deQualName",
          "package": "derive",
          "signature": "Name -\u003e Name",
          "source": "src/Language-Haskell-TH-FixedPpr.html#deQualName",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH FixedPpr",
          "module": "Language.Haskell.TH.FixedPpr",
          "name": "deQualName",
          "normalized": "Name-\u003eName",
          "package": "derive",
          "partial": "Qual Name",
          "signature": "Name-\u003eName",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-FixedPpr.html#v:deQualName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.FixedPpr",
          "name": "isPrefixName",
          "package": "derive",
          "signature": "Name -\u003e Bool",
          "source": "src/Language-Haskell-TH-FixedPpr.html#isPrefixName",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH FixedPpr",
          "module": "Language.Haskell.TH.FixedPpr",
          "name": "isPrefixName",
          "normalized": "Name-\u003eBool",
          "package": "derive",
          "partial": "Prefix Name",
          "signature": "Name-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-FixedPpr.html#v:isPrefixName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.FixedPpr",
          "name": "nestDepth",
          "package": "derive",
          "signature": "Int",
          "source": "src/Language-Haskell-TH-FixedPpr.html#nestDepth",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH FixedPpr",
          "module": "Language.Haskell.TH.FixedPpr",
          "name": "nestDepth",
          "package": "derive",
          "partial": "Depth",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-FixedPpr.html#v:nestDepth"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.FixedPpr",
          "name": "noPrec",
          "package": "derive",
          "signature": "Precedence",
          "source": "src/Language-Haskell-TH-FixedPpr.html#noPrec",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH FixedPpr",
          "module": "Language.Haskell.TH.FixedPpr",
          "name": "noPrec",
          "package": "derive",
          "partial": "Prec",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-FixedPpr.html#v:noPrec"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.FixedPpr",
          "name": "opPrec",
          "package": "derive",
          "signature": "Precedence",
          "source": "src/Language-Haskell-TH-FixedPpr.html#opPrec",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH FixedPpr",
          "module": "Language.Haskell.TH.FixedPpr",
          "name": "opPrec",
          "package": "derive",
          "partial": "Prec",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-FixedPpr.html#v:opPrec"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.FixedPpr",
          "name": "parensIf",
          "package": "derive",
          "signature": "Bool -\u003e Doc -\u003e Doc",
          "source": "src/Language-Haskell-TH-FixedPpr.html#parensIf",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH FixedPpr",
          "module": "Language.Haskell.TH.FixedPpr",
          "name": "parensIf",
          "normalized": "Bool-\u003eDoc-\u003eDoc",
          "package": "derive",
          "partial": "If",
          "signature": "Bool-\u003eDoc-\u003eDoc",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-FixedPpr.html#v:parensIf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.FixedPpr",
          "name": "ppr",
          "package": "derive",
          "signature": "a -\u003e Doc",
          "source": "src/Language-Haskell-TH-FixedPpr.html#ppr",
          "type": "method"
        },
        "index": {
          "hierarchy": "Language Haskell TH FixedPpr",
          "module": "Language.Haskell.TH.FixedPpr",
          "name": "ppr",
          "normalized": "a-\u003eDoc",
          "package": "derive",
          "signature": "a-\u003eDoc",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-FixedPpr.html#v:ppr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.FixedPpr",
          "name": "pprBody",
          "package": "derive",
          "signature": "Bool -\u003e Body -\u003e Doc",
          "source": "src/Language-Haskell-TH-FixedPpr.html#pprBody",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH FixedPpr",
          "module": "Language.Haskell.TH.FixedPpr",
          "name": "pprBody",
          "normalized": "Bool-\u003eBody-\u003eDoc",
          "package": "derive",
          "partial": "Body",
          "signature": "Bool-\u003eBody-\u003eDoc",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-FixedPpr.html#v:pprBody"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.FixedPpr",
          "name": "pprCxt",
          "package": "derive",
          "signature": "Cxt -\u003e Doc",
          "source": "src/Language-Haskell-TH-FixedPpr.html#pprCxt",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH FixedPpr",
          "module": "Language.Haskell.TH.FixedPpr",
          "name": "pprCxt",
          "normalized": "Cxt-\u003eDoc",
          "package": "derive",
          "partial": "Cxt",
          "signature": "Cxt-\u003eDoc",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-FixedPpr.html#v:pprCxt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.FixedPpr",
          "name": "pprExp",
          "package": "derive",
          "signature": "Precedence -\u003e Exp -\u003e Doc",
          "source": "src/Language-Haskell-TH-FixedPpr.html#pprExp",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH FixedPpr",
          "module": "Language.Haskell.TH.FixedPpr",
          "name": "pprExp",
          "normalized": "Precedence-\u003eExp-\u003eDoc",
          "package": "derive",
          "partial": "Exp",
          "signature": "Precedence-\u003eExp-\u003eDoc",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-FixedPpr.html#v:pprExp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.FixedPpr",
          "name": "pprExpInfix",
          "package": "derive",
          "signature": "Exp -\u003e Doc",
          "source": "src/Language-Haskell-TH-FixedPpr.html#pprExpInfix",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH FixedPpr",
          "module": "Language.Haskell.TH.FixedPpr",
          "name": "pprExpInfix",
          "normalized": "Exp-\u003eDoc",
          "package": "derive",
          "partial": "Exp Infix",
          "signature": "Exp-\u003eDoc",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-FixedPpr.html#v:pprExpInfix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.FixedPpr",
          "name": "pprFields",
          "package": "derive",
          "signature": "[(Name, Exp)] -\u003e Doc",
          "source": "src/Language-Haskell-TH-FixedPpr.html#pprFields",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH FixedPpr",
          "module": "Language.Haskell.TH.FixedPpr",
          "name": "pprFields",
          "normalized": "[(Name,Exp)]-\u003eDoc",
          "package": "derive",
          "partial": "Fields",
          "signature": "[(Name,Exp)]-\u003eDoc",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-FixedPpr.html#v:pprFields"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.FixedPpr",
          "name": "pprFixity",
          "package": "derive",
          "signature": "Name -\u003e Fixity -\u003e Doc",
          "source": "src/Language-Haskell-TH-FixedPpr.html#pprFixity",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH FixedPpr",
          "module": "Language.Haskell.TH.FixedPpr",
          "name": "pprFixity",
          "normalized": "Name-\u003eFixity-\u003eDoc",
          "package": "derive",
          "partial": "Fixity",
          "signature": "Name-\u003eFixity-\u003eDoc",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-FixedPpr.html#v:pprFixity"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.FixedPpr",
          "name": "pprLit",
          "package": "derive",
          "signature": "Precedence -\u003e Lit -\u003e Doc",
          "source": "src/Language-Haskell-TH-FixedPpr.html#pprLit",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH FixedPpr",
          "module": "Language.Haskell.TH.FixedPpr",
          "name": "pprLit",
          "normalized": "Precedence-\u003eLit-\u003eDoc",
          "package": "derive",
          "partial": "Lit",
          "signature": "Precedence-\u003eLit-\u003eDoc",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-FixedPpr.html#v:pprLit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.FixedPpr",
          "name": "pprMaybeExp",
          "package": "derive",
          "signature": "Precedence -\u003e Maybe Exp -\u003e Doc",
          "source": "src/Language-Haskell-TH-FixedPpr.html#pprMaybeExp",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH FixedPpr",
          "module": "Language.Haskell.TH.FixedPpr",
          "name": "pprMaybeExp",
          "normalized": "Precedence-\u003eMaybe Exp-\u003eDoc",
          "package": "derive",
          "partial": "Maybe Exp",
          "signature": "Precedence-\u003eMaybe Exp-\u003eDoc",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-FixedPpr.html#v:pprMaybeExp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.FixedPpr",
          "name": "pprName_",
          "package": "derive",
          "signature": "Bool -\u003e Name -\u003e Doc",
          "source": "src/Language-Haskell-TH-FixedPpr.html#pprName_",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH FixedPpr",
          "module": "Language.Haskell.TH.FixedPpr",
          "name": "pprName_",
          "normalized": "Bool-\u003eName-\u003eDoc",
          "package": "derive",
          "partial": "Name",
          "signature": "Bool-\u003eName-\u003eDoc",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-FixedPpr.html#v:pprName_"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.FixedPpr",
          "name": "pprParendType",
          "package": "derive",
          "signature": "Type -\u003e Doc",
          "source": "src/Language-Haskell-TH-FixedPpr.html#pprParendType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH FixedPpr",
          "module": "Language.Haskell.TH.FixedPpr",
          "name": "pprParendType",
          "normalized": "Type-\u003eDoc",
          "package": "derive",
          "partial": "Parend Type",
          "signature": "Type-\u003eDoc",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-FixedPpr.html#v:pprParendType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.FixedPpr",
          "name": "pprPat",
          "package": "derive",
          "signature": "Precedence -\u003e Pat -\u003e Doc",
          "source": "src/Language-Haskell-TH-FixedPpr.html#pprPat",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH FixedPpr",
          "module": "Language.Haskell.TH.FixedPpr",
          "name": "pprPat",
          "normalized": "Precedence-\u003ePat-\u003eDoc",
          "package": "derive",
          "partial": "Pat",
          "signature": "Precedence-\u003ePat-\u003eDoc",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-FixedPpr.html#v:pprPat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.FixedPpr",
          "name": "pprStrictType",
          "package": "derive",
          "signature": "(Strict, Type) -\u003e Doc",
          "source": "src/Language-Haskell-TH-FixedPpr.html#pprStrictType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH FixedPpr",
          "module": "Language.Haskell.TH.FixedPpr",
          "name": "pprStrictType",
          "normalized": "(Strict,Type)-\u003eDoc",
          "package": "derive",
          "partial": "Strict Type",
          "signature": "(Strict,Type)-\u003eDoc",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-FixedPpr.html#v:pprStrictType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.FixedPpr",
          "name": "pprTyApp",
          "package": "derive",
          "signature": "(Type, [Type]) -\u003e Doc",
          "source": "src/Language-Haskell-TH-FixedPpr.html#pprTyApp",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH FixedPpr",
          "module": "Language.Haskell.TH.FixedPpr",
          "name": "pprTyApp",
          "normalized": "(Type,[Type])-\u003eDoc",
          "package": "derive",
          "partial": "Ty App",
          "signature": "(Type,[Type])-\u003eDoc",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-FixedPpr.html#v:pprTyApp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.FixedPpr",
          "name": "pprVarStrictType",
          "package": "derive",
          "signature": "(Name, Strict, Type) -\u003e Doc",
          "source": "src/Language-Haskell-TH-FixedPpr.html#pprVarStrictType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH FixedPpr",
          "module": "Language.Haskell.TH.FixedPpr",
          "name": "pprVarStrictType",
          "normalized": "(Name,Strict,Type)-\u003eDoc",
          "package": "derive",
          "partial": "Var Strict Type",
          "signature": "(Name,Strict,Type)-\u003eDoc",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-FixedPpr.html#v:pprVarStrictType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.FixedPpr",
          "name": "ppr_list",
          "package": "derive",
          "signature": "[a] -\u003e Doc",
          "source": "src/Language-Haskell-TH-FixedPpr.html#ppr_list",
          "type": "method"
        },
        "index": {
          "hierarchy": "Language Haskell TH FixedPpr",
          "module": "Language.Haskell.TH.FixedPpr",
          "name": "ppr_list",
          "normalized": "[a]-\u003eDoc",
          "package": "derive",
          "signature": "[a]-\u003eDoc",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-FixedPpr.html#v:ppr_list"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.FixedPpr",
          "name": "ppr_sig",
          "package": "derive",
          "signature": "a -\u003e a1 -\u003e Doc",
          "source": "src/Language-Haskell-TH-FixedPpr.html#ppr_sig",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH FixedPpr",
          "module": "Language.Haskell.TH.FixedPpr",
          "name": "ppr_sig",
          "normalized": "a-\u003ea-\u003eDoc",
          "package": "derive",
          "signature": "a-\u003ea-\u003eDoc",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-FixedPpr.html#v:ppr_sig"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.FixedPpr",
          "name": "pprint",
          "package": "derive",
          "signature": "a -\u003e String",
          "source": "src/Language-Haskell-TH-FixedPpr.html#pprint",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH FixedPpr",
          "module": "Language.Haskell.TH.FixedPpr",
          "name": "pprint",
          "normalized": "a-\u003eString",
          "package": "derive",
          "signature": "a-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-FixedPpr.html#v:pprint"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.FixedPpr",
          "name": "showNameRaw",
          "package": "derive",
          "signature": "Name -\u003e String",
          "source": "src/Language-Haskell-TH-FixedPpr.html#showNameRaw",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH FixedPpr",
          "module": "Language.Haskell.TH.FixedPpr",
          "name": "showNameRaw",
          "normalized": "Name-\u003eString",
          "package": "derive",
          "partial": "Name Raw",
          "signature": "Name-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-FixedPpr.html#v:showNameRaw"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.FixedPpr",
          "name": "showtextl",
          "package": "derive",
          "signature": "a -\u003e Doc",
          "source": "src/Language-Haskell-TH-FixedPpr.html#showtextl",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH FixedPpr",
          "module": "Language.Haskell.TH.FixedPpr",
          "name": "showtextl",
          "normalized": "a-\u003eDoc",
          "package": "derive",
          "signature": "a-\u003eDoc",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-FixedPpr.html#v:showtextl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.FixedPpr",
          "name": "split",
          "package": "derive",
          "signature": "Type -\u003e (Type, [Type])",
          "source": "src/Language-Haskell-TH-FixedPpr.html#split",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH FixedPpr",
          "module": "Language.Haskell.TH.FixedPpr",
          "name": "split",
          "normalized": "Type-\u003e(Type,[Type])",
          "package": "derive",
          "signature": "Type-\u003e(Type,[Type])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-FixedPpr.html#v:split"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.FixedPpr",
          "name": "where_clause",
          "package": "derive",
          "signature": "[Dec] -\u003e Doc",
          "source": "src/Language-Haskell-TH-FixedPpr.html#where_clause",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH FixedPpr",
          "module": "Language.Haskell.TH.FixedPpr",
          "name": "where_clause",
          "normalized": "[Dec]-\u003eDoc",
          "package": "derive",
          "signature": "[Dec]-\u003eDoc",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-FixedPpr.html#v:where_clause"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThese small short-named functions are intended to make the\n   construction of abstranct syntax trees less tedious.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Language.Haskell.TH.Helper",
          "name": "Helper",
          "package": "derive",
          "source": "src/Language-Haskell-TH-Helper.html",
          "type": "module"
        },
        "index": {
          "description": "These small short-named functions are intended to make the construction of abstranct syntax trees less tedious",
          "hierarchy": "Language Haskell TH Helper",
          "module": "Language.Haskell.TH.Helper",
          "name": "Helper",
          "package": "derive",
          "partial": "Helper",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-Helper.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis class is used to overload literal construction based on the\n type of the literal.\n\u003c/p\u003e",
          "module": "Language.Haskell.TH.Helper",
          "name": "LitC",
          "package": "derive",
          "source": "src/Language-Haskell-TH-Helper.html#LitC",
          "type": "class"
        },
        "index": {
          "description": "This class is used to overload literal construction based on the type of the literal",
          "hierarchy": "Language Haskell TH Helper",
          "module": "Language.Haskell.TH.Helper",
          "name": "LitC",
          "package": "derive",
          "partial": "Lit",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-Helper.html#t:LitC"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Helper",
          "name": "NameLike",
          "package": "derive",
          "source": "src/Language-Haskell-TH-Helper.html#NameLike",
          "type": "class"
        },
        "index": {
          "hierarchy": "Language Haskell TH Helper",
          "module": "Language.Haskell.TH.Helper",
          "name": "NameLike",
          "package": "derive",
          "partial": "Name Like",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-Helper.html#t:NameLike"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe class used to overload lifting operations.  To reduce code\n duplication, we overload the wrapped constructors (and everything\n else, but that's irrelevant) to work in patterns, expressions, and\n types.\n\u003c/p\u003e",
          "module": "Language.Haskell.TH.Helper",
          "name": "Valcon",
          "package": "derive",
          "source": "src/Language-Haskell-TH-Helper.html#Valcon",
          "type": "class"
        },
        "index": {
          "description": "The class used to overload lifting operations To reduce code duplication we overload the wrapped constructors and everything else but that irrelevant to work in patterns expressions and types",
          "hierarchy": "Language Haskell TH Helper",
          "module": "Language.Haskell.TH.Helper",
          "name": "Valcon",
          "package": "derive",
          "partial": "Valcon",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-Helper.html#t:Valcon"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Helper",
          "name": "(&&:)",
          "package": "derive",
          "signature": "Exp -\u003e Exp -\u003e Exp",
          "source": "src/Language-Haskell-TH-Helper.html#%26%26%3A",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH Helper",
          "module": "Language.Haskell.TH.Helper",
          "name": "(&&:) &&:",
          "normalized": "Exp-\u003eExp-\u003eExp",
          "package": "derive",
          "signature": "Exp-\u003eExp-\u003eExp",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-Helper.html#v:-38--38-:"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eBuild a chain of expressions, with an appropriate terminal\n   sequence__ does not require a unit at the end (all others are optimised automatically)\n\u003c/p\u003e",
          "module": "Language.Haskell.TH.Helper",
          "name": "(&&::)",
          "package": "derive",
          "signature": "[Exp] -\u003e Exp",
          "source": "src/Language-Haskell-TH-Helper.html#%26%26%3A%3A",
          "type": "function"
        },
        "index": {
          "description": "Build chain of expressions with an appropriate terminal sequence does not require unit at the end all others are optimised automatically",
          "hierarchy": "Language Haskell TH Helper",
          "module": "Language.Haskell.TH.Helper",
          "name": "(&&::) &&::",
          "normalized": "[Exp]-\u003eExp",
          "package": "derive",
          "signature": "[Exp]-\u003eExp",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-Helper.html#v:-38--38-::"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Helper",
          "name": "(++:)",
          "package": "derive",
          "signature": "Exp -\u003e Exp -\u003e Exp",
          "source": "src/Language-Haskell-TH-Helper.html#%2B%2B%3A",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH Helper",
          "module": "Language.Haskell.TH.Helper",
          "name": "(++:) ++:",
          "normalized": "Exp-\u003eExp-\u003eExp",
          "package": "derive",
          "signature": "Exp-\u003eExp-\u003eExp",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-Helper.html#v:-43--43-:"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eBuild a chain of expressions, with an appropriate terminal\n   sequence__ does not require a unit at the end (all others are optimised automatically)\n\u003c/p\u003e",
          "module": "Language.Haskell.TH.Helper",
          "name": "(++::)",
          "package": "derive",
          "signature": "[Exp] -\u003e Exp",
          "source": "src/Language-Haskell-TH-Helper.html#%2B%2B%3A%3A",
          "type": "function"
        },
        "index": {
          "description": "Build chain of expressions with an appropriate terminal sequence does not require unit at the end all others are optimised automatically",
          "hierarchy": "Language Haskell TH Helper",
          "module": "Language.Haskell.TH.Helper",
          "name": "(++::) ++::",
          "normalized": "[Exp]-\u003eExp",
          "package": "derive",
          "signature": "[Exp]-\u003eExp",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-Helper.html#v:-43--43-::"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Helper",
          "name": "(-\u003e:)",
          "package": "derive",
          "signature": "String -\u003e Exp -\u003e Exp",
          "source": "src/Language-Haskell-TH-Helper.html#-%3E%3A",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH Helper",
          "module": "Language.Haskell.TH.Helper",
          "name": "(-\u003e:) -\u003e:",
          "normalized": "String-\u003eExp-\u003eExp",
          "package": "derive",
          "signature": "String-\u003eExp-\u003eExp",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-Helper.html#v:-45--62-:"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Helper",
          "name": "(==:)",
          "package": "derive",
          "signature": "Exp -\u003e Exp -\u003e Exp",
          "source": "src/Language-Haskell-TH-Helper.html#%3D%3D%3A",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH Helper",
          "module": "Language.Haskell.TH.Helper",
          "name": "(==:) ==:",
          "normalized": "Exp-\u003eExp-\u003eExp",
          "package": "derive",
          "signature": "Exp-\u003eExp-\u003eExp",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-Helper.html#v:-61--61-:"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Helper",
          "name": "(\u003e\u003e=:)",
          "package": "derive",
          "signature": "Exp -\u003e Exp -\u003e Exp",
          "source": "src/Language-Haskell-TH-Helper.html#%3E%3E%3D%3A",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH Helper",
          "module": "Language.Haskell.TH.Helper",
          "name": "(\u003e\u003e=:) \u003e\u003e=:",
          "normalized": "Exp-\u003eExp-\u003eExp",
          "package": "derive",
          "signature": "Exp-\u003eExp-\u003eExp",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-Helper.html#v:-62--62--61-:"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Helper",
          "name": "(\u003e\u003e:)",
          "package": "derive",
          "signature": "Exp -\u003e Exp -\u003e Exp",
          "source": "src/Language-Haskell-TH-Helper.html#%3E%3E%3A",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH Helper",
          "module": "Language.Haskell.TH.Helper",
          "name": "(\u003e\u003e:) \u003e\u003e:",
          "normalized": "Exp-\u003eExp-\u003eExp",
          "package": "derive",
          "signature": "Exp-\u003eExp-\u003eExp",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-Helper.html#v:-62--62-:"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eBuild a chain of expressions, with an appropriate terminal\n   sequence__ does not require a unit at the end (all others are optimised automatically)\n\u003c/p\u003e",
          "module": "Language.Haskell.TH.Helper",
          "name": "(\u003e\u003e::)",
          "package": "derive",
          "signature": "[Exp] -\u003e Exp",
          "source": "src/Language-Haskell-TH-Helper.html#%3E%3E%3A%3A",
          "type": "function"
        },
        "index": {
          "description": "Build chain of expressions with an appropriate terminal sequence does not require unit at the end all others are optimised automatically",
          "hierarchy": "Language Haskell TH Helper",
          "module": "Language.Haskell.TH.Helper",
          "name": "(\u003e\u003e::) \u003e\u003e::",
          "normalized": "[Exp]-\u003eExp",
          "package": "derive",
          "signature": "[Exp]-\u003eExp",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-Helper.html#v:-62--62-::"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Helper",
          "name": "(\u003e:)",
          "package": "derive",
          "signature": "Exp -\u003e Exp -\u003e Exp",
          "source": "src/Language-Haskell-TH-Helper.html#%3E%3A",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH Helper",
          "module": "Language.Haskell.TH.Helper",
          "name": "(\u003e:) \u003e:",
          "normalized": "Exp-\u003eExp-\u003eExp",
          "package": "derive",
          "signature": "Exp-\u003eExp-\u003eExp",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-Helper.html#v:-62-:"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Helper",
          "name": "(.:)",
          "package": "derive",
          "signature": "Exp -\u003e Exp -\u003e Exp",
          "source": "src/Language-Haskell-TH-Helper.html#.%3A",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH Helper",
          "module": "Language.Haskell.TH.Helper",
          "name": "(.:) .:",
          "normalized": "Exp-\u003eExp-\u003eExp",
          "package": "derive",
          "signature": "Exp-\u003eExp-\u003eExp",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-Helper.html#v:.:"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eBuild a chain of expressions, with an appropriate terminal\n   sequence__ does not require a unit at the end (all others are optimised automatically)\n\u003c/p\u003e",
          "module": "Language.Haskell.TH.Helper",
          "name": "(.::)",
          "package": "derive",
          "signature": "[Exp] -\u003e Exp",
          "source": "src/Language-Haskell-TH-Helper.html#.%3A%3A",
          "type": "function"
        },
        "index": {
          "description": "Build chain of expressions with an appropriate terminal sequence does not require unit at the end all others are optimised automatically",
          "hierarchy": "Language Haskell TH Helper",
          "module": "Language.Haskell.TH.Helper",
          "name": "(.::) .::",
          "normalized": "[Exp]-\u003eExp",
          "package": "derive",
          "signature": "[Exp]-\u003eExp",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-Helper.html#v:.::"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Helper",
          "name": "ap'",
          "package": "derive",
          "signature": "Exp -\u003e Exp -\u003e Exp",
          "source": "src/Language-Haskell-TH-Helper.html#ap%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH Helper",
          "module": "Language.Haskell.TH.Helper",
          "name": "ap'",
          "normalized": "Exp-\u003eExp-\u003eExp",
          "package": "derive",
          "signature": "Exp-\u003eExp-\u003eExp",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-Helper.html#v:ap-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eBuild an application node without a given head\n\u003c/p\u003e",
          "module": "Language.Haskell.TH.Helper",
          "name": "app",
          "package": "derive",
          "signature": "Exp -\u003e [Exp] -\u003e Exp",
          "source": "src/Language-Haskell-TH-Helper.html#app",
          "type": "function"
        },
        "index": {
          "description": "Build an application node without given head",
          "hierarchy": "Language Haskell TH Helper",
          "module": "Language.Haskell.TH.Helper",
          "name": "app",
          "normalized": "Exp-\u003e[Exp]-\u003eExp",
          "package": "derive",
          "signature": "Exp-\u003e[Exp]-\u003eExp",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-Helper.html#v:app"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Helper",
          "name": "applyWith",
          "package": "derive",
          "signature": "Exp -\u003e [Exp] -\u003e Exp",
          "source": "src/Language-Haskell-TH-Helper.html#applyWith",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH Helper",
          "module": "Language.Haskell.TH.Helper",
          "name": "applyWith",
          "normalized": "Exp-\u003e[Exp]-\u003eExp",
          "package": "derive",
          "partial": "With",
          "signature": "Exp-\u003e[Exp]-\u003eExp",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-Helper.html#v:applyWith"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Helper",
          "name": "box",
          "package": "derive",
          "signature": "a -\u003e a",
          "source": "src/Language-Haskell-TH-Helper.html#box",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH Helper",
          "module": "Language.Haskell.TH.Helper",
          "name": "box",
          "normalized": "a-\u003ea",
          "package": "derive",
          "signature": "a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-Helper.html#v:box"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Helper",
          "name": "case'",
          "package": "derive",
          "signature": "Exp -\u003e [(Pat, Exp)] -\u003e Exp",
          "source": "src/Language-Haskell-TH-Helper.html#case%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH Helper",
          "module": "Language.Haskell.TH.Helper",
          "name": "case'",
          "normalized": "Exp-\u003e[(Pat,Exp)]-\u003eExp",
          "package": "derive",
          "signature": "Exp-\u003e[(Pat,Exp)]-\u003eExp",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-Helper.html#v:case-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Helper",
          "name": "cons",
          "package": "derive",
          "signature": "a -\u003e a -\u003e a",
          "source": "src/Language-Haskell-TH-Helper.html#cons",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH Helper",
          "module": "Language.Haskell.TH.Helper",
          "name": "cons",
          "normalized": "a-\u003ea-\u003ea",
          "package": "derive",
          "signature": "a-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-Helper.html#v:cons"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Helper",
          "name": "const'",
          "package": "derive",
          "signature": "Exp -\u003e Exp",
          "source": "src/Language-Haskell-TH-Helper.html#const%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH Helper",
          "module": "Language.Haskell.TH.Helper",
          "name": "const'",
          "normalized": "Exp-\u003eExp",
          "package": "derive",
          "signature": "Exp-\u003eExp",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-Helper.html#v:const-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReference the constructor itself\n\u003c/p\u003e",
          "module": "Language.Haskell.TH.Helper",
          "name": "ctc",
          "package": "derive",
          "signature": "CtorDef -\u003e a",
          "source": "src/Language-Haskell-TH-Helper.html#ctc",
          "type": "function"
        },
        "index": {
          "description": "Reference the constructor itself",
          "hierarchy": "Language Haskell TH Helper",
          "module": "Language.Haskell.TH.Helper",
          "name": "ctc",
          "normalized": "CtorDef-\u003ea",
          "package": "derive",
          "signature": "CtorDef-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-Helper.html#v:ctc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMake a simple pattern to bind a constructor\n\u003c/p\u003e",
          "module": "Language.Haskell.TH.Helper",
          "name": "ctp",
          "package": "derive",
          "signature": "CtorDef -\u003e Char -\u003e a",
          "source": "src/Language-Haskell-TH-Helper.html#ctp",
          "type": "function"
        },
        "index": {
          "description": "Make simple pattern to bind constructor",
          "hierarchy": "Language Haskell TH Helper",
          "module": "Language.Haskell.TH.Helper",
          "name": "ctp",
          "normalized": "CtorDef-\u003eChar-\u003ea",
          "package": "derive",
          "signature": "CtorDef-\u003eChar-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-Helper.html#v:ctp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMake a list of variables, one for each argument to a constructor\n\u003c/p\u003e",
          "module": "Language.Haskell.TH.Helper",
          "name": "ctv",
          "package": "derive",
          "signature": "CtorDef -\u003e Char -\u003e [a]",
          "source": "src/Language-Haskell-TH-Helper.html#ctv",
          "type": "function"
        },
        "index": {
          "description": "Make list of variables one for each argument to constructor",
          "hierarchy": "Language Haskell TH Helper",
          "module": "Language.Haskell.TH.Helper",
          "name": "ctv",
          "normalized": "CtorDef-\u003eChar-\u003e[a]",
          "package": "derive",
          "signature": "CtorDef-\u003eChar-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-Helper.html#v:ctv"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Helper",
          "name": "dataVars",
          "package": "derive",
          "signature": "DataDef -\u003e [Type]",
          "source": "src/Language-Haskell-TH-Helper.html#dataVars",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH Helper",
          "module": "Language.Haskell.TH.Helper",
          "name": "dataVars",
          "normalized": "DataDef-\u003e[Type]",
          "package": "derive",
          "partial": "Vars",
          "signature": "DataDef-\u003e[Type]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-Helper.html#v:dataVars"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA default clause with N arguments.\n\u003c/p\u003e",
          "module": "Language.Haskell.TH.Helper",
          "name": "defclause",
          "package": "derive",
          "signature": "Int -\u003e Exp -\u003e Clause",
          "source": "src/Language-Haskell-TH-Helper.html#defclause",
          "type": "function"
        },
        "index": {
          "description": "default clause with arguments",
          "hierarchy": "Language Haskell TH Helper",
          "module": "Language.Haskell.TH.Helper",
          "name": "defclause",
          "normalized": "Int-\u003eExp-\u003eClause",
          "package": "derive",
          "signature": "Int-\u003eExp-\u003eClause",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-Helper.html#v:defclause"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Helper",
          "name": "false",
          "package": "derive",
          "signature": "a",
          "source": "src/Language-Haskell-TH-Helper.html#false",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH Helper",
          "module": "Language.Haskell.TH.Helper",
          "name": "false",
          "package": "derive",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-Helper.html#v:false"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Helper",
          "name": "foldl1With",
          "package": "derive",
          "signature": "Exp -\u003e [Exp] -\u003e Exp",
          "source": "src/Language-Haskell-TH-Helper.html#foldl1With",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH Helper",
          "module": "Language.Haskell.TH.Helper",
          "name": "foldl1With",
          "normalized": "Exp-\u003e[Exp]-\u003eExp",
          "package": "derive",
          "partial": "With",
          "signature": "Exp-\u003e[Exp]-\u003eExp",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-Helper.html#v:foldl1With"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Helper",
          "name": "foldr1With",
          "package": "derive",
          "signature": "Exp -\u003e [Exp] -\u003e Exp",
          "source": "src/Language-Haskell-TH-Helper.html#foldr1With",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH Helper",
          "module": "Language.Haskell.TH.Helper",
          "name": "foldr1With",
          "normalized": "Exp-\u003e[Exp]-\u003eExp",
          "package": "derive",
          "partial": "With",
          "signature": "Exp-\u003e[Exp]-\u003eExp",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-Helper.html#v:foldr1With"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eBuild a fundecl with a string name\n\u003c/p\u003e",
          "module": "Language.Haskell.TH.Helper",
          "name": "funN",
          "package": "derive",
          "signature": "String -\u003e [Clause] -\u003e Dec",
          "source": "src/Language-Haskell-TH-Helper.html#funN",
          "type": "function"
        },
        "index": {
          "description": "Build fundecl with string name",
          "hierarchy": "Language Haskell TH Helper",
          "module": "Language.Haskell.TH.Helper",
          "name": "funN",
          "normalized": "String-\u003e[Clause]-\u003eDec",
          "package": "derive",
          "signature": "String-\u003e[Clause]-\u003eDec",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-Helper.html#v:funN"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eBuild an instance of a class for a data type, using the class at the given types\n\u003c/p\u003e",
          "module": "Language.Haskell.TH.Helper",
          "name": "generic_instance",
          "package": "derive",
          "signature": "String -\u003e DataDef -\u003e [Type] -\u003e [Dec] -\u003e [Dec]",
          "source": "src/Language-Haskell-TH-Helper.html#generic_instance",
          "type": "function"
        },
        "index": {
          "description": "Build an instance of class for data type using the class at the given types",
          "hierarchy": "Language Haskell TH Helper",
          "module": "Language.Haskell.TH.Helper",
          "name": "generic_instance",
          "normalized": "String-\u003eDataDef-\u003e[Type]-\u003e[Dec]-\u003e[Dec]",
          "package": "derive",
          "signature": "String-\u003eDataDef-\u003e[Type]-\u003e[Dec]-\u003e[Dec]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-Helper.html#v:generic_instance"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Helper",
          "name": "hCons'",
          "package": "derive",
          "signature": "Type -\u003e Type -\u003e Type",
          "source": "src/Language-Haskell-TH-Helper.html#hCons%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH Helper",
          "module": "Language.Haskell.TH.Helper",
          "name": "hCons'",
          "normalized": "Type-\u003eType-\u003eType",
          "package": "derive",
          "partial": "Cons'",
          "signature": "Type-\u003eType-\u003eType",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-Helper.html#v:hCons-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Helper",
          "name": "hNil'",
          "package": "derive",
          "signature": "Type",
          "source": "src/Language-Haskell-TH-Helper.html#hNil%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH Helper",
          "module": "Language.Haskell.TH.Helper",
          "name": "hNil'",
          "package": "derive",
          "partial": "Nil'",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-Helper.html#v:hNil-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Helper",
          "name": "hSucc'",
          "package": "derive",
          "signature": "Type -\u003e Type",
          "source": "src/Language-Haskell-TH-Helper.html#hSucc%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH Helper",
          "module": "Language.Haskell.TH.Helper",
          "name": "hSucc'",
          "normalized": "Type-\u003eType",
          "package": "derive",
          "partial": "Succ'",
          "signature": "Type-\u003eType",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-Helper.html#v:hSucc-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Helper",
          "name": "hZero'",
          "package": "derive",
          "signature": "Type",
          "source": "src/Language-Haskell-TH-Helper.html#hZero%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH Helper",
          "module": "Language.Haskell.TH.Helper",
          "name": "hZero'",
          "package": "derive",
          "partial": "Zero'",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-Helper.html#v:hZero-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Helper",
          "name": "id'",
          "package": "derive",
          "signature": "Exp",
          "source": "src/Language-Haskell-TH-Helper.html#id%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH Helper",
          "module": "Language.Haskell.TH.Helper",
          "name": "id'",
          "package": "derive",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-Helper.html#v:id-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Helper",
          "name": "instance_context",
          "package": "derive",
          "signature": "[String] -\u003e String -\u003e DataDef -\u003e [Dec] -\u003e Dec",
          "source": "src/Language-Haskell-TH-Helper.html#instance_context",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH Helper",
          "module": "Language.Haskell.TH.Helper",
          "name": "instance_context",
          "normalized": "[String]-\u003eString-\u003eDataDef-\u003e[Dec]-\u003eDec",
          "package": "derive",
          "signature": "[String]-\u003eString-\u003eDataDef-\u003e[Dec]-\u003eDec",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-Helper.html#v:instance_context"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Helper",
          "name": "instance_default",
          "package": "derive",
          "signature": "String -\u003e DataDef -\u003e [Dec] -\u003e Dec",
          "source": "src/Language-Haskell-TH-Helper.html#instance_default",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH Helper",
          "module": "Language.Haskell.TH.Helper",
          "name": "instance_default",
          "normalized": "String-\u003eDataDef-\u003e[Dec]-\u003eDec",
          "package": "derive",
          "signature": "String-\u003eDataDef-\u003e[Dec]-\u003eDec",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-Helper.html#v:instance_default"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWe provide 3 standard instance constructors\n   instance_default requires C for each free type variable\n   instance_none requires no context\n   instance_context requires a given context\n\u003c/p\u003e",
          "module": "Language.Haskell.TH.Helper",
          "name": "instance_none",
          "package": "derive",
          "signature": "String -\u003e DataDef -\u003e [Dec] -\u003e Dec",
          "source": "src/Language-Haskell-TH-Helper.html#instance_none",
          "type": "function"
        },
        "index": {
          "description": "We provide standard instance constructors instance default requires for each free type variable instance none requires no context instance context requires given context",
          "hierarchy": "Language Haskell TH Helper",
          "module": "Language.Haskell.TH.Helper",
          "name": "instance_none",
          "normalized": "String-\u003eDataDef-\u003e[Dec]-\u003eDec",
          "package": "derive",
          "signature": "String-\u003eDataDef-\u003e[Dec]-\u003eDec",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-Helper.html#v:instance_none"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Helper",
          "name": "l0",
          "package": "derive",
          "signature": "nm -\u003e a",
          "source": "src/Language-Haskell-TH-Helper.html#l0",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH Helper",
          "module": "Language.Haskell.TH.Helper",
          "name": "l0",
          "normalized": "a-\u003eb",
          "package": "derive",
          "signature": "nm-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-Helper.html#v:l0"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Helper",
          "name": "l1",
          "package": "derive",
          "signature": "nm -\u003e a -\u003e a",
          "source": "src/Language-Haskell-TH-Helper.html#l1",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH Helper",
          "module": "Language.Haskell.TH.Helper",
          "name": "l1",
          "normalized": "a-\u003eb-\u003eb",
          "package": "derive",
          "signature": "nm-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-Helper.html#v:l1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Helper",
          "name": "l2",
          "package": "derive",
          "signature": "nm -\u003e a -\u003e a -\u003e a",
          "source": "src/Language-Haskell-TH-Helper.html#l2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH Helper",
          "module": "Language.Haskell.TH.Helper",
          "name": "l2",
          "normalized": "a-\u003eb-\u003eb-\u003eb",
          "package": "derive",
          "signature": "nm-\u003ea-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-Helper.html#v:l2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eBuild an application node, with a name for a head and a\n provided list of arguments.\n\u003c/p\u003e",
          "module": "Language.Haskell.TH.Helper",
          "name": "lK",
          "package": "derive",
          "signature": "nm -\u003e [a] -\u003e a",
          "source": "src/Language-Haskell-TH-Helper.html#lK",
          "type": "method"
        },
        "index": {
          "description": "Build an application node with name for head and provided list of arguments",
          "hierarchy": "Language Haskell TH Helper",
          "module": "Language.Haskell.TH.Helper",
          "name": "lK",
          "normalized": "a-\u003e[b]-\u003eb",
          "package": "derive",
          "signature": "nm-\u003e[a]-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-Helper.html#v:lK"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eK-way liftM\n\u003c/p\u003e",
          "module": "Language.Haskell.TH.Helper",
          "name": "liftmk",
          "package": "derive",
          "signature": "Exp -\u003e [Exp] -\u003e Exp",
          "source": "src/Language-Haskell-TH-Helper.html#liftmk",
          "type": "function"
        },
        "index": {
          "description": "K-way liftM",
          "hierarchy": "Language Haskell TH Helper",
          "module": "Language.Haskell.TH.Helper",
          "name": "liftmk",
          "normalized": "Exp-\u003e[Exp]-\u003eExp",
          "package": "derive",
          "signature": "Exp-\u003e[Exp]-\u003eExp",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-Helper.html#v:liftmk"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Helper",
          "name": "lit",
          "package": "derive",
          "signature": "a -\u003e p",
          "source": "src/Language-Haskell-TH-Helper.html#lit",
          "type": "method"
        },
        "index": {
          "hierarchy": "Language Haskell TH Helper",
          "module": "Language.Haskell.TH.Helper",
          "name": "lit",
          "normalized": "a-\u003eb",
          "package": "derive",
          "signature": "a-\u003ep",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-Helper.html#v:lit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eListing\n\u003c/p\u003e",
          "module": "Language.Haskell.TH.Helper",
          "name": "lst",
          "package": "derive",
          "signature": "[a] -\u003e a",
          "source": "src/Language-Haskell-TH-Helper.html#lst",
          "type": "method"
        },
        "index": {
          "description": "Listing",
          "hierarchy": "Language Haskell TH Helper",
          "module": "Language.Haskell.TH.Helper",
          "name": "lst",
          "normalized": "[a]-\u003ea",
          "package": "derive",
          "signature": "[a]-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-Helper.html#v:lst"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Helper",
          "name": "nil",
          "package": "derive",
          "signature": "a",
          "source": "src/Language-Haskell-TH-Helper.html#nil",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH Helper",
          "module": "Language.Haskell.TH.Helper",
          "name": "nil",
          "package": "derive",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-Helper.html#v:nil"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLift a TH \u003ccode\u003e\u003ca\u003eLit\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Language.Haskell.TH.Helper",
          "name": "raw_lit",
          "package": "derive",
          "signature": "Lit -\u003e a",
          "source": "src/Language-Haskell-TH-Helper.html#raw_lit",
          "type": "method"
        },
        "index": {
          "description": "Lift TH Lit",
          "hierarchy": "Language Haskell TH Helper",
          "module": "Language.Haskell.TH.Helper",
          "name": "raw_lit",
          "normalized": "Lit-\u003ea",
          "package": "derive",
          "signature": "Lit-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-Helper.html#v:raw_lit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Helper",
          "name": "return'",
          "package": "derive",
          "signature": "Exp -\u003e Exp",
          "source": "src/Language-Haskell-TH-Helper.html#return%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH Helper",
          "module": "Language.Haskell.TH.Helper",
          "name": "return'",
          "normalized": "Exp-\u003eExp",
          "package": "derive",
          "signature": "Exp-\u003eExp",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-Helper.html#v:return-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA simple clause, without where or guards.\n\u003c/p\u003e",
          "module": "Language.Haskell.TH.Helper",
          "name": "sclause",
          "package": "derive",
          "signature": "[Pat] -\u003e Exp -\u003e Clause",
          "source": "src/Language-Haskell-TH-Helper.html#sclause",
          "type": "function"
        },
        "index": {
          "description": "simple clause without where or guards",
          "hierarchy": "Language Haskell TH Helper",
          "module": "Language.Haskell.TH.Helper",
          "name": "sclause",
          "normalized": "[Pat]-\u003eExp-\u003eClause",
          "package": "derive",
          "signature": "[Pat]-\u003eExp-\u003eClause",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-Helper.html#v:sclause"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eBuild a chain of expressions, with an appropriate terminal\n   sequence__ does not require a unit at the end (all others are optimised automatically)\n\u003c/p\u003e",
          "module": "Language.Haskell.TH.Helper",
          "name": "sequence__",
          "package": "derive",
          "signature": "[Exp] -\u003e Exp",
          "source": "src/Language-Haskell-TH-Helper.html#sequence__",
          "type": "function"
        },
        "index": {
          "description": "Build chain of expressions with an appropriate terminal sequence does not require unit at the end all others are optimised automatically",
          "hierarchy": "Language Haskell TH Helper",
          "module": "Language.Haskell.TH.Helper",
          "name": "sequence__",
          "normalized": "[Exp]-\u003eExp",
          "package": "derive",
          "signature": "[Exp]-\u003eExp",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-Helper.html#v:sequence__"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eBuild a type signature declaration with a string name\n\u003c/p\u003e",
          "module": "Language.Haskell.TH.Helper",
          "name": "sigN",
          "package": "derive",
          "signature": "String -\u003e Type -\u003e Dec",
          "source": "src/Language-Haskell-TH-Helper.html#sigN",
          "type": "function"
        },
        "index": {
          "description": "Build type signature declaration with string name",
          "hierarchy": "Language Haskell TH Helper",
          "module": "Language.Haskell.TH.Helper",
          "name": "sigN",
          "normalized": "String-\u003eType-\u003eDec",
          "package": "derive",
          "signature": "String-\u003eType-\u003eDec",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-Helper.html#v:sigN"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eBuild an instance of a class for a data type, using the heuristic\n that the type is itself required on all type arguments.\n\u003c/p\u003e",
          "module": "Language.Haskell.TH.Helper",
          "name": "simple_instance",
          "package": "derive",
          "signature": "String -\u003e DataDef -\u003e [Dec] -\u003e [Dec]",
          "source": "src/Language-Haskell-TH-Helper.html#simple_instance",
          "type": "function"
        },
        "index": {
          "description": "Build an instance of class for data type using the heuristic that the type is itself required on all type arguments",
          "hierarchy": "Language Haskell TH Helper",
          "module": "Language.Haskell.TH.Helper",
          "name": "simple_instance",
          "normalized": "String-\u003eDataDef-\u003e[Dec]-\u003e[Dec]",
          "package": "derive",
          "signature": "String-\u003eDataDef-\u003e[Dec]-\u003e[Dec]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-Helper.html#v:simple_instance"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA simple Val clause\n\u003c/p\u003e",
          "module": "Language.Haskell.TH.Helper",
          "name": "sval",
          "package": "derive",
          "signature": "Pat -\u003e Exp -\u003e Dec",
          "source": "src/Language-Haskell-TH-Helper.html#sval",
          "type": "function"
        },
        "index": {
          "description": "simple Val clause",
          "hierarchy": "Language Haskell TH Helper",
          "module": "Language.Haskell.TH.Helper",
          "name": "sval",
          "normalized": "Pat-\u003eExp-\u003eDec",
          "package": "derive",
          "signature": "Pat-\u003eExp-\u003eDec",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-Helper.html#v:sval"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Helper",
          "name": "toName",
          "package": "derive",
          "signature": "nm -\u003e Name",
          "source": "src/Language-Haskell-TH-Helper.html#toName",
          "type": "method"
        },
        "index": {
          "hierarchy": "Language Haskell TH Helper",
          "module": "Language.Haskell.TH.Helper",
          "name": "toName",
          "normalized": "a-\u003eName",
          "package": "derive",
          "partial": "Name",
          "signature": "nm-\u003eName",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-Helper.html#v:toName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Helper",
          "name": "true",
          "package": "derive",
          "signature": "a",
          "source": "src/Language-Haskell-TH-Helper.html#true",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH Helper",
          "module": "Language.Haskell.TH.Helper",
          "name": "true",
          "package": "derive",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-Helper.html#v:true"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTupling\n\u003c/p\u003e",
          "module": "Language.Haskell.TH.Helper",
          "name": "tup",
          "package": "derive",
          "signature": "[a] -\u003e a",
          "source": "src/Language-Haskell-TH-Helper.html#tup",
          "type": "method"
        },
        "index": {
          "description": "Tupling",
          "hierarchy": "Language Haskell TH Helper",
          "module": "Language.Haskell.TH.Helper",
          "name": "tup",
          "normalized": "[a]-\u003ea",
          "package": "derive",
          "signature": "[a]-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-Helper.html#v:tup"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Helper",
          "name": "unit",
          "package": "derive",
          "signature": "Exp",
          "source": "src/Language-Haskell-TH-Helper.html#unit",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH Helper",
          "module": "Language.Haskell.TH.Helper",
          "name": "unit",
          "package": "derive",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-Helper.html#v:unit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCommon pattern: list of a familiy of variables\n\u003c/p\u003e",
          "module": "Language.Haskell.TH.Helper",
          "name": "vars",
          "package": "derive",
          "signature": "Char -\u003e Int -\u003e [a]",
          "source": "src/Language-Haskell-TH-Helper.html#vars",
          "type": "function"
        },
        "index": {
          "description": "Common pattern list of familiy of variables",
          "hierarchy": "Language Haskell TH Helper",
          "module": "Language.Haskell.TH.Helper",
          "name": "vars",
          "normalized": "Char-\u003eInt-\u003e[a]",
          "package": "derive",
          "signature": "Char-\u003eInt-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-Helper.html#v:vars"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReference a named variable.\n\u003c/p\u003e",
          "module": "Language.Haskell.TH.Helper",
          "name": "vr",
          "package": "derive",
          "signature": "nm -\u003e a",
          "source": "src/Language-Haskell-TH-Helper.html#vr",
          "type": "method"
        },
        "index": {
          "description": "Reference named variable",
          "hierarchy": "Language Haskell TH Helper",
          "module": "Language.Haskell.TH.Helper",
          "name": "vr",
          "normalized": "a-\u003eb",
          "package": "derive",
          "signature": "nm-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-Helper.html#v:vr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eVariable based on a letter + number\n\u003c/p\u003e",
          "module": "Language.Haskell.TH.Helper",
          "name": "vrn",
          "package": "derive",
          "signature": "Char -\u003e Int -\u003e a",
          "source": "src/Language-Haskell-TH-Helper.html#vrn",
          "type": "function"
        },
        "index": {
          "description": "Variable based on letter number",
          "hierarchy": "Language Haskell TH Helper",
          "module": "Language.Haskell.TH.Helper",
          "name": "vrn",
          "normalized": "Char-\u003eInt-\u003ea",
          "package": "derive",
          "signature": "Char-\u003eInt-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-Helper.html#v:vrn"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Peephole",
          "name": "Peephole",
          "package": "derive",
          "source": "src/Language-Haskell-TH-Peephole.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Language Haskell TH Peephole",
          "module": "Language.Haskell.TH.Peephole",
          "name": "Peephole",
          "package": "derive",
          "partial": "Peephole",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-Peephole.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Peephole",
          "name": "peephole",
          "package": "derive",
          "signature": "a -\u003e a",
          "source": "src/Language-Haskell-TH-Peephole.html#peephole",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH Peephole",
          "module": "Language.Haskell.TH.Peephole",
          "name": "peephole",
          "normalized": "a-\u003ea",
          "package": "derive",
          "signature": "a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-Peephole.html#v:peephole"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Peephole",
          "name": "replaceVar",
          "package": "derive",
          "signature": "Name -\u003e Exp -\u003e Exp -\u003e Exp",
          "source": "src/Language-Haskell-TH-Peephole.html#replaceVar",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH Peephole",
          "module": "Language.Haskell.TH.Peephole",
          "name": "replaceVar",
          "normalized": "Name-\u003eExp-\u003eExp-\u003eExp",
          "package": "derive",
          "partial": "Var",
          "signature": "Name-\u003eExp-\u003eExp-\u003eExp",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-Peephole.html#v:replaceVar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Peephole",
          "name": "replaceVars",
          "package": "derive",
          "signature": "[(Name, Exp)] -\u003e Exp -\u003e Exp",
          "source": "src/Language-Haskell-TH-Peephole.html#replaceVars",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH Peephole",
          "module": "Language.Haskell.TH.Peephole",
          "name": "replaceVars",
          "normalized": "[(Name,Exp)]-\u003eExp-\u003eExp",
          "package": "derive",
          "partial": "Vars",
          "signature": "[(Name,Exp)]-\u003eExp-\u003eExp",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell-TH-Peephole.html#v:replaceVars"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell",
          "name": "Haskell",
          "package": "derive",
          "source": "src/Language-Haskell.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Language Haskell",
          "module": "Language.Haskell",
          "name": "Haskell",
          "package": "derive",
          "partial": "Haskell",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell",
          "name": "CtorDecl",
          "package": "derive",
          "source": "src/Language-Haskell.html#CtorDecl",
          "type": "type"
        },
        "index": {
          "hierarchy": "Language Haskell",
          "module": "Language.Haskell",
          "name": "CtorDecl",
          "package": "derive",
          "partial": "Ctor Decl",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell.html#t:CtorDecl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell",
          "name": "DataDecl",
          "package": "derive",
          "source": "src/Language-Haskell.html#DataDecl",
          "type": "type"
        },
        "index": {
          "hierarchy": "Language Haskell",
          "module": "Language.Haskell",
          "name": "DataDecl",
          "package": "derive",
          "partial": "Data Decl",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell.html#t:DataDecl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell",
          "name": "FieldDecl",
          "package": "derive",
          "source": "src/Language-Haskell.html#FieldDecl",
          "type": "type"
        },
        "index": {
          "hierarchy": "Language Haskell",
          "module": "Language.Haskell",
          "name": "FieldDecl",
          "package": "derive",
          "partial": "Field Decl",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell.html#t:FieldDecl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell",
          "name": "FullDataDecl",
          "package": "derive",
          "source": "src/Language-Haskell.html#FullDataDecl",
          "type": "type"
        },
        "index": {
          "hierarchy": "Language Haskell",
          "module": "Language.Haskell",
          "name": "FullDataDecl",
          "package": "derive",
          "partial": "Full Data Decl",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell.html#t:FullDataDecl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell",
          "name": "(~=)",
          "package": "derive",
          "signature": "a -\u003e String -\u003e Bool",
          "source": "src/Language-Haskell.html#~%3D",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell",
          "module": "Language.Haskell",
          "name": "(~=) ~=",
          "normalized": "a-\u003eString-\u003eBool",
          "package": "derive",
          "signature": "a-\u003eString-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell.html#v:-126--61-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell",
          "name": "(?)",
          "package": "derive",
          "signature": "Bool -\u003e a -\u003e a -\u003e a",
          "source": "src/Language-Haskell.html#%3F",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell",
          "module": "Language.Haskell",
          "name": "(?) ?",
          "normalized": "Bool-\u003ea-\u003ea-\u003ea",
          "package": "derive",
          "signature": "Bool-\u003ea-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell.html#v:-63-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell",
          "name": "appP",
          "package": "derive",
          "signature": "Exp -\u003e Exp -\u003e Exp",
          "source": "src/Language-Haskell.html#appP",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell",
          "module": "Language.Haskell",
          "name": "appP",
          "normalized": "Exp-\u003eExp-\u003eExp",
          "package": "derive",
          "signature": "Exp-\u003eExp-\u003eExp",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell.html#v:appP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell",
          "name": "apps",
          "package": "derive",
          "signature": "Exp -\u003e [Exp] -\u003e Exp",
          "source": "src/Language-Haskell.html#apps",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell",
          "module": "Language.Haskell",
          "name": "apps",
          "normalized": "Exp-\u003e[Exp]-\u003eExp",
          "package": "derive",
          "signature": "Exp-\u003e[Exp]-\u003eExp",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell.html#v:apps"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell",
          "name": "bind",
          "package": "derive",
          "signature": "String -\u003e [Pat] -\u003e Exp -\u003e Decl",
          "source": "src/Language-Haskell.html#bind",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell",
          "module": "Language.Haskell",
          "name": "bind",
          "normalized": "String-\u003e[Pat]-\u003eExp-\u003eDecl",
          "package": "derive",
          "signature": "String-\u003e[Pat]-\u003eExp-\u003eDecl",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell.html#v:bind"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell",
          "name": "binds",
          "package": "derive",
          "signature": "String -\u003e [([Pat], Exp)] -\u003e Decl",
          "source": "src/Language-Haskell.html#binds",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell",
          "module": "Language.Haskell",
          "name": "binds",
          "normalized": "String-\u003e[([Pat],Exp)]-\u003eDecl",
          "package": "derive",
          "signature": "String-\u003e[([Pat],Exp)]-\u003eDecl",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell.html#v:binds"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell",
          "name": "con",
          "package": "derive",
          "signature": "String -\u003e Exp",
          "source": "src/Language-Haskell.html#con",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell",
          "module": "Language.Haskell",
          "name": "con",
          "normalized": "String-\u003eExp",
          "package": "derive",
          "signature": "String-\u003eExp",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell.html#v:con"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell",
          "name": "ctorDeclArity",
          "package": "derive",
          "signature": "CtorDecl -\u003e Int",
          "source": "src/Language-Haskell.html#ctorDeclArity",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell",
          "module": "Language.Haskell",
          "name": "ctorDeclArity",
          "normalized": "CtorDecl-\u003eInt",
          "package": "derive",
          "partial": "Decl Arity",
          "signature": "CtorDecl-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell.html#v:ctorDeclArity"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell",
          "name": "ctorDeclFields",
          "package": "derive",
          "signature": "CtorDecl -\u003e FieldDecl",
          "source": "src/Language-Haskell.html#ctorDeclFields",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell",
          "module": "Language.Haskell",
          "name": "ctorDeclFields",
          "normalized": "CtorDecl-\u003eFieldDecl",
          "package": "derive",
          "partial": "Decl Fields",
          "signature": "CtorDecl-\u003eFieldDecl",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell.html#v:ctorDeclFields"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell",
          "name": "ctorDeclName",
          "package": "derive",
          "signature": "CtorDecl -\u003e String",
          "source": "src/Language-Haskell.html#ctorDeclName",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell",
          "module": "Language.Haskell",
          "name": "ctorDeclName",
          "normalized": "CtorDecl-\u003eString",
          "package": "derive",
          "partial": "Decl Name",
          "signature": "CtorDecl-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell.html#v:ctorDeclName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell",
          "name": "ctorDeclName'",
          "package": "derive",
          "signature": "CtorDecl -\u003e Name",
          "source": "src/Language-Haskell.html#ctorDeclName%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell",
          "module": "Language.Haskell",
          "name": "ctorDeclName'",
          "normalized": "CtorDecl-\u003eName",
          "package": "derive",
          "partial": "Decl Name'",
          "signature": "CtorDecl-\u003eName",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell.html#v:ctorDeclName-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell",
          "name": "dataDeclArity",
          "package": "derive",
          "signature": "DataDecl -\u003e Int",
          "source": "src/Language-Haskell.html#dataDeclArity",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell",
          "module": "Language.Haskell",
          "name": "dataDeclArity",
          "normalized": "DataDecl-\u003eInt",
          "package": "derive",
          "partial": "Decl Arity",
          "signature": "DataDecl-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell.html#v:dataDeclArity"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell",
          "name": "dataDeclContext",
          "package": "derive",
          "signature": "DataDecl -\u003e Context",
          "source": "src/Language-Haskell.html#dataDeclContext",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell",
          "module": "Language.Haskell",
          "name": "dataDeclContext",
          "normalized": "DataDecl-\u003eContext",
          "package": "derive",
          "partial": "Decl Context",
          "signature": "DataDecl-\u003eContext",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell.html#v:dataDeclContext"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell",
          "name": "dataDeclCtors",
          "package": "derive",
          "signature": "DataDecl -\u003e [CtorDecl]",
          "source": "src/Language-Haskell.html#dataDeclCtors",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell",
          "module": "Language.Haskell",
          "name": "dataDeclCtors",
          "normalized": "DataDecl-\u003e[CtorDecl]",
          "package": "derive",
          "partial": "Decl Ctors",
          "signature": "DataDecl-\u003e[CtorDecl]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell.html#v:dataDeclCtors"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell",
          "name": "dataDeclFields",
          "package": "derive",
          "signature": "DataDecl -\u003e [String]",
          "source": "src/Language-Haskell.html#dataDeclFields",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell",
          "module": "Language.Haskell",
          "name": "dataDeclFields",
          "normalized": "DataDecl-\u003e[String]",
          "package": "derive",
          "partial": "Decl Fields",
          "signature": "DataDecl-\u003e[String]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell.html#v:dataDeclFields"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell",
          "name": "dataDeclName",
          "package": "derive",
          "signature": "DataDecl -\u003e String",
          "source": "src/Language-Haskell.html#dataDeclName",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell",
          "module": "Language.Haskell",
          "name": "dataDeclName",
          "normalized": "DataDecl-\u003eString",
          "package": "derive",
          "partial": "Decl Name",
          "signature": "DataDecl-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell.html#v:dataDeclName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell",
          "name": "dataDeclSrcLoc",
          "package": "derive",
          "signature": "DataDecl -\u003e SrcLoc",
          "source": "src/Language-Haskell.html#dataDeclSrcLoc",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell",
          "module": "Language.Haskell",
          "name": "dataDeclSrcLoc",
          "normalized": "DataDecl-\u003eSrcLoc",
          "package": "derive",
          "partial": "Decl Src Loc",
          "signature": "DataDecl-\u003eSrcLoc",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell.html#v:dataDeclSrcLoc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell",
          "name": "dataDeclType",
          "package": "derive",
          "signature": "DataDecl -\u003e Type",
          "source": "src/Language-Haskell.html#dataDeclType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell",
          "module": "Language.Haskell",
          "name": "dataDeclType",
          "normalized": "DataDecl-\u003eType",
          "package": "derive",
          "partial": "Decl Type",
          "signature": "DataDecl-\u003eType",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell.html#v:dataDeclType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell",
          "name": "dataDeclVars",
          "package": "derive",
          "signature": "DataDecl -\u003e [String]",
          "source": "src/Language-Haskell.html#dataDeclVars",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell",
          "module": "Language.Haskell",
          "name": "dataDeclVars",
          "normalized": "DataDecl-\u003e[String]",
          "package": "derive",
          "partial": "Decl Vars",
          "signature": "DataDecl-\u003e[String]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell.html#v:dataDeclVars"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell",
          "name": "declName",
          "package": "derive",
          "signature": "Decl -\u003e String",
          "source": "src/Language-Haskell.html#declName",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell",
          "module": "Language.Haskell",
          "name": "declName",
          "normalized": "Decl-\u003eString",
          "package": "derive",
          "partial": "Name",
          "signature": "Decl-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell.html#v:declName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell",
          "name": "foralls",
          "package": "derive",
          "signature": "Type -\u003e Type",
          "source": "src/Language-Haskell.html#foralls",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell",
          "module": "Language.Haskell",
          "name": "foralls",
          "normalized": "Type-\u003eType",
          "package": "derive",
          "signature": "Type-\u003eType",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell.html#v:foralls"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell",
          "name": "fromBangType",
          "package": "derive",
          "signature": "BangType -\u003e Type",
          "source": "src/Language-Haskell.html#fromBangType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell",
          "module": "Language.Haskell",
          "name": "fromBangType",
          "normalized": "BangType-\u003eType",
          "package": "derive",
          "partial": "Bang Type",
          "signature": "BangType-\u003eType",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell.html#v:fromBangType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell",
          "name": "fromTyApps",
          "package": "derive",
          "signature": "Type -\u003e (Type, [Type])",
          "source": "src/Language-Haskell.html#fromTyApps",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell",
          "module": "Language.Haskell",
          "name": "fromTyApps",
          "normalized": "Type-\u003e(Type,[Type])",
          "package": "derive",
          "partial": "Ty Apps",
          "signature": "Type-\u003e(Type,[Type])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell.html#v:fromTyApps"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell",
          "name": "fromTyList",
          "package": "derive",
          "signature": "Type -\u003e Maybe Type",
          "source": "src/Language-Haskell.html#fromTyList",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell",
          "module": "Language.Haskell",
          "name": "fromTyList",
          "normalized": "Type-\u003eMaybe Type",
          "package": "derive",
          "partial": "Ty List",
          "signature": "Type-\u003eMaybe Type",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell.html#v:fromTyList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell",
          "name": "fromTyParen",
          "package": "derive",
          "signature": "Type -\u003e Type",
          "source": "src/Language-Haskell.html#fromTyParen",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell",
          "module": "Language.Haskell",
          "name": "fromTyParen",
          "normalized": "Type-\u003eType",
          "package": "derive",
          "partial": "Ty Paren",
          "signature": "Type-\u003eType",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell.html#v:fromTyParen"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell",
          "name": "fromTyParens",
          "package": "derive",
          "signature": "Type -\u003e Type",
          "source": "src/Language-Haskell.html#fromTyParens",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell",
          "module": "Language.Haskell",
          "name": "fromTyParens",
          "normalized": "Type-\u003eType",
          "package": "derive",
          "partial": "Ty Parens",
          "signature": "Type-\u003eType",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell.html#v:fromTyParens"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell",
          "name": "fromTyTuple",
          "package": "derive",
          "signature": "Type -\u003e [Type]",
          "source": "src/Language-Haskell.html#fromTyTuple",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell",
          "module": "Language.Haskell",
          "name": "fromTyTuple",
          "normalized": "Type-\u003e[Type]",
          "package": "derive",
          "partial": "Ty Tuple",
          "signature": "Type-\u003e[Type]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell.html#v:fromTyTuple"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell",
          "name": "isAtom",
          "package": "derive",
          "signature": "Exp -\u003e Bool",
          "source": "src/Language-Haskell.html#isAtom",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell",
          "module": "Language.Haskell",
          "name": "isAtom",
          "normalized": "Exp-\u003eBool",
          "package": "derive",
          "partial": "Atom",
          "signature": "Exp-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell.html#v:isAtom"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell",
          "name": "isDataDecl",
          "package": "derive",
          "signature": "Decl -\u003e Bool",
          "source": "src/Language-Haskell.html#isDataDecl",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell",
          "module": "Language.Haskell",
          "name": "isDataDecl",
          "normalized": "Decl-\u003eBool",
          "package": "derive",
          "partial": "Data Decl",
          "signature": "Decl-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell.html#v:isDataDecl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell",
          "name": "isGuardFalse",
          "package": "derive",
          "signature": "Match -\u003e Bool",
          "source": "src/Language-Haskell.html#isGuardFalse",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell",
          "module": "Language.Haskell",
          "name": "isGuardFalse",
          "normalized": "Match-\u003eBool",
          "package": "derive",
          "partial": "Guard False",
          "signature": "Match-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell.html#v:isGuardFalse"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell",
          "name": "isTyFun",
          "package": "derive",
          "signature": "Type -\u003e Bool",
          "source": "src/Language-Haskell.html#isTyFun",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell",
          "module": "Language.Haskell",
          "name": "isTyFun",
          "normalized": "Type-\u003eBool",
          "package": "derive",
          "partial": "Ty Fun",
          "signature": "Type-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell.html#v:isTyFun"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell",
          "name": "isTyParen",
          "package": "derive",
          "signature": "Type -\u003e Bool",
          "source": "src/Language-Haskell.html#isTyParen",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell",
          "module": "Language.Haskell",
          "name": "isTyParen",
          "normalized": "Type-\u003eBool",
          "package": "derive",
          "partial": "Ty Paren",
          "signature": "Type-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell.html#v:isTyParen"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell",
          "name": "moduleDecls",
          "package": "derive",
          "signature": "Module -\u003e [Decl]",
          "source": "src/Language-Haskell.html#moduleDecls",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell",
          "module": "Language.Haskell",
          "name": "moduleDecls",
          "normalized": "Module-\u003e[Decl]",
          "package": "derive",
          "partial": "Decls",
          "signature": "Module-\u003e[Decl]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell.html#v:moduleDecls"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell",
          "name": "moduleImports",
          "package": "derive",
          "signature": "Module -\u003e [ImportDecl]",
          "source": "src/Language-Haskell.html#moduleImports",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell",
          "module": "Language.Haskell",
          "name": "moduleImports",
          "normalized": "Module-\u003e[ImportDecl]",
          "package": "derive",
          "partial": "Imports",
          "signature": "Module-\u003e[ImportDecl]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell.html#v:moduleImports"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell",
          "name": "moduleName",
          "package": "derive",
          "signature": "Module -\u003e ModuleName",
          "source": "src/Language-Haskell.html#moduleName",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell",
          "module": "Language.Haskell",
          "name": "moduleName",
          "normalized": "Module-\u003eModuleName",
          "package": "derive",
          "partial": "Name",
          "signature": "Module-\u003eModuleName",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell.html#v:moduleName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell",
          "name": "modulePragmas",
          "package": "derive",
          "signature": "Module -\u003e [ModulePragma]",
          "source": "src/Language-Haskell.html#modulePragmas",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell",
          "module": "Language.Haskell",
          "name": "modulePragmas",
          "normalized": "Module-\u003e[ModulePragma]",
          "package": "derive",
          "partial": "Pragmas",
          "signature": "Module-\u003e[ModulePragma]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell.html#v:modulePragmas"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell",
          "name": "noSl",
          "package": "derive",
          "signature": "from -\u003e from",
          "source": "src/Language-Haskell.html#noSl",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell",
          "module": "Language.Haskell",
          "name": "noSl",
          "normalized": "a-\u003ea",
          "package": "derive",
          "partial": "Sl",
          "signature": "from-\u003efrom",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell.html#v:noSl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell",
          "name": "pVar",
          "package": "derive",
          "signature": "String -\u003e Pat",
          "source": "src/Language-Haskell.html#pVar",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell",
          "module": "Language.Haskell",
          "name": "pVar",
          "normalized": "String-\u003ePat",
          "package": "derive",
          "partial": "Var",
          "signature": "String-\u003ePat",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell.html#v:pVar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell",
          "name": "paren",
          "package": "derive",
          "signature": "Exp -\u003e Exp",
          "source": "src/Language-Haskell.html#paren",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell",
          "module": "Language.Haskell",
          "name": "paren",
          "normalized": "Exp-\u003eExp",
          "package": "derive",
          "signature": "Exp-\u003eExp",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell.html#v:paren"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell",
          "name": "qname",
          "package": "derive",
          "signature": "String -\u003e QName",
          "source": "src/Language-Haskell.html#qname",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell",
          "module": "Language.Haskell",
          "name": "qname",
          "normalized": "String-\u003eQName",
          "package": "derive",
          "signature": "String-\u003eQName",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell.html#v:qname"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell",
          "name": "qvop",
          "package": "derive",
          "signature": "String -\u003e QOp",
          "source": "src/Language-Haskell.html#qvop",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell",
          "module": "Language.Haskell",
          "name": "qvop",
          "normalized": "String-\u003eQOp",
          "package": "derive",
          "signature": "String-\u003eQOp",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell.html#v:qvop"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell",
          "name": "rename",
          "package": "derive",
          "signature": "QName -\u003e QName",
          "source": "src/Language-Haskell.html#rename",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell",
          "module": "Language.Haskell",
          "name": "rename",
          "normalized": "QName-\u003eQName",
          "package": "derive",
          "signature": "QName-\u003eQName",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell.html#v:rename"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell",
          "name": "showDecls",
          "package": "derive",
          "signature": "[a] -\u003e String",
          "source": "src/Language-Haskell.html#showDecls",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell",
          "module": "Language.Haskell",
          "name": "showDecls",
          "normalized": "[a]-\u003eString",
          "package": "derive",
          "partial": "Decls",
          "signature": "[a]-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell.html#v:showDecls"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell",
          "name": "simplify",
          "package": "derive",
          "signature": "a -\u003e a",
          "source": "src/Language-Haskell.html#simplify",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell",
          "module": "Language.Haskell",
          "name": "simplify",
          "normalized": "a-\u003ea",
          "package": "derive",
          "signature": "a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell.html#v:simplify"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell",
          "name": "sl",
          "package": "derive",
          "signature": "SrcLoc",
          "source": "src/Language-Haskell.html#sl",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell",
          "module": "Language.Haskell",
          "name": "sl",
          "package": "derive",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell.html#v:sl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell",
          "name": "title",
          "package": "derive",
          "signature": "[Char] -\u003e [Char]",
          "source": "src/Language-Haskell.html#title",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell",
          "module": "Language.Haskell",
          "name": "title",
          "normalized": "[Char]-\u003e[Char]",
          "package": "derive",
          "signature": "[Char]-\u003e[Char]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell.html#v:title"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell",
          "name": "tyApp",
          "package": "derive",
          "signature": "Type -\u003e [Type] -\u003e Type",
          "source": "src/Language-Haskell.html#tyApp",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell",
          "module": "Language.Haskell",
          "name": "tyApp",
          "normalized": "Type-\u003e[Type]-\u003eType",
          "package": "derive",
          "partial": "App",
          "signature": "Type-\u003e[Type]-\u003eType",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell.html#v:tyApp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell",
          "name": "tyApps",
          "package": "derive",
          "signature": "Type -\u003e [Type] -\u003e Type",
          "source": "src/Language-Haskell.html#tyApps",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell",
          "module": "Language.Haskell",
          "name": "tyApps",
          "normalized": "Type-\u003e[Type]-\u003eType",
          "package": "derive",
          "partial": "Apps",
          "signature": "Type-\u003e[Type]-\u003eType",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell.html#v:tyApps"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell",
          "name": "tyCon",
          "package": "derive",
          "signature": "String -\u003e Type",
          "source": "src/Language-Haskell.html#tyCon",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell",
          "module": "Language.Haskell",
          "name": "tyCon",
          "normalized": "String-\u003eType",
          "package": "derive",
          "partial": "Con",
          "signature": "String-\u003eType",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell.html#v:tyCon"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell",
          "name": "tyFun",
          "package": "derive",
          "signature": "[Type] -\u003e Type",
          "source": "src/Language-Haskell.html#tyFun",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell",
          "module": "Language.Haskell",
          "name": "tyFun",
          "normalized": "[Type]-\u003eType",
          "package": "derive",
          "partial": "Fun",
          "signature": "[Type]-\u003eType",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell.html#v:tyFun"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell",
          "name": "tyRoot",
          "package": "derive",
          "signature": "Type -\u003e String",
          "source": "src/Language-Haskell.html#tyRoot",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell",
          "module": "Language.Haskell",
          "name": "tyRoot",
          "normalized": "Type-\u003eString",
          "package": "derive",
          "partial": "Root",
          "signature": "Type-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell.html#v:tyRoot"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell",
          "name": "tyVar",
          "package": "derive",
          "signature": "String -\u003e Type",
          "source": "src/Language-Haskell.html#tyVar",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell",
          "module": "Language.Haskell",
          "name": "tyVar",
          "normalized": "String-\u003eType",
          "package": "derive",
          "partial": "Var",
          "signature": "String-\u003eType",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell.html#v:tyVar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell",
          "name": "tyVarBind",
          "package": "derive",
          "signature": "String -\u003e TyVarBind",
          "source": "src/Language-Haskell.html#tyVarBind",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell",
          "module": "Language.Haskell",
          "name": "tyVarBind",
          "normalized": "String-\u003eTyVarBind",
          "package": "derive",
          "partial": "Var Bind",
          "signature": "String-\u003eTyVarBind",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell.html#v:tyVarBind"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell",
          "name": "var",
          "package": "derive",
          "signature": "String -\u003e Exp",
          "source": "src/Language-Haskell.html#var",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell",
          "module": "Language.Haskell",
          "name": "var",
          "normalized": "String-\u003eExp",
          "package": "derive",
          "signature": "String-\u003eExp",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/derive/docs/Language-Haskell.html#v:var"
      }
    }
  ]
]