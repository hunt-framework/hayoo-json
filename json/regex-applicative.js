[
  {
    "cmd": "delete-by-query",
    "query": {
      "contexts": [
        "package"
      ],
      "query": {
        "op": "case",
        "type": "word",
        "word": "regex-applicative"
      },
      "type": "context"
    }
  },
  [
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eCollection of commonly used regular expressions.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Text.Regex.Applicative.Common",
          "name": "Common",
          "package": "regex-applicative",
          "source": "src/Text-Regex-Applicative-Common.html",
          "type": "module"
        },
        "index": {
          "description": "Collection of commonly used regular expressions",
          "hierarchy": "Text Regex Applicative Common",
          "module": "Text.Regex.Applicative.Common",
          "name": "Common",
          "package": "regex-applicative",
          "partial": "Common",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/regex-applicative/docs/Text-Regex-Applicative-Common.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eParse decimal number without sign.\n\u003c/p\u003e",
          "module": "Text.Regex.Applicative.Common",
          "name": "decimal",
          "package": "regex-applicative",
          "signature": "RE Char a",
          "source": "src/Text-Regex-Applicative-Common.html#decimal",
          "type": "function"
        },
        "index": {
          "description": "Parse decimal number without sign",
          "hierarchy": "Text Regex Applicative Common",
          "module": "Text.Regex.Applicative.Common",
          "name": "decimal",
          "package": "regex-applicative",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-applicative/docs/Text-Regex-Applicative-Common.html#v:decimal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDecimal digit, i.e. \u003ccode\u003e'0'\u003c/code\u003e..\u003ccode\u003e'9'\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Text.Regex.Applicative.Common",
          "name": "digit",
          "package": "regex-applicative",
          "signature": "RE Char a",
          "source": "src/Text-Regex-Applicative-Common.html#digit",
          "type": "function"
        },
        "index": {
          "description": "Decimal digit i.e",
          "hierarchy": "Text Regex Applicative Common",
          "module": "Text.Regex.Applicative.Common",
          "name": "digit",
          "package": "regex-applicative",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-applicative/docs/Text-Regex-Applicative-Common.html#v:digit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eHexadecimal digit\n i.e. \u003ccode\u003e'0'\u003c/code\u003e..\u003ccode\u003e'9'\u003c/code\u003e, \u003ccode\u003e'a'\u003c/code\u003e..\u003ccode\u003e'f'\u003c/code\u003e, \u003ccode\u003e'A'\u003c/code\u003e..\u003ccode\u003e'F'\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Text.Regex.Applicative.Common",
          "name": "hexDigit",
          "package": "regex-applicative",
          "signature": "RE Char a",
          "source": "src/Text-Regex-Applicative-Common.html#hexDigit",
          "type": "function"
        },
        "index": {
          "description": "Hexadecimal digit i.e",
          "hierarchy": "Text Regex Applicative Common",
          "module": "Text.Regex.Applicative.Common",
          "name": "hexDigit",
          "package": "regex-applicative",
          "partial": "Digit",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-applicative/docs/Text-Regex-Applicative-Common.html#v:hexDigit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eParse decimal number without sign.\n\u003c/p\u003e",
          "module": "Text.Regex.Applicative.Common",
          "name": "hexadecimal",
          "package": "regex-applicative",
          "signature": "RE Char a",
          "source": "src/Text-Regex-Applicative-Common.html#hexadecimal",
          "type": "function"
        },
        "index": {
          "description": "Parse decimal number without sign",
          "hierarchy": "Text Regex Applicative Common",
          "module": "Text.Regex.Applicative.Common",
          "name": "hexadecimal",
          "package": "regex-applicative",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-applicative/docs/Text-Regex-Applicative-Common.html#v:hexadecimal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAdd optional sign\n\u003c/p\u003e",
          "module": "Text.Regex.Applicative.Common",
          "name": "signed",
          "package": "regex-applicative",
          "signature": "RE Char a -\u003e RE Char a",
          "source": "src/Text-Regex-Applicative-Common.html#signed",
          "type": "function"
        },
        "index": {
          "description": "Add optional sign",
          "hierarchy": "Text Regex Applicative Common",
          "module": "Text.Regex.Applicative.Common",
          "name": "signed",
          "normalized": "RE Char a-\u003eRE Char a",
          "package": "regex-applicative",
          "signature": "RE Char a-\u003eRE Char a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-applicative/docs/Text-Regex-Applicative-Common.html#v:signed"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis is a low-level interface to the regex engine.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Text.Regex.Applicative.Object",
          "name": "Object",
          "package": "regex-applicative",
          "source": "src/Text-Regex-Applicative-Object.html",
          "type": "module"
        },
        "index": {
          "description": "This is low-level interface to the regex engine",
          "hierarchy": "Text Regex Applicative Object",
          "module": "Text.Regex.Applicative.Object",
          "name": "Object",
          "package": "regex-applicative",
          "partial": "Object",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/regex-applicative/docs/Text-Regex-Applicative-Object.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe state of the engine is represented as a \"regex object\" of type\n \u003ccode\u003e\u003ccode\u003e\u003ca\u003eReObject\u003c/a\u003e\u003c/code\u003e s r\u003c/code\u003e, where \u003ccode\u003es\u003c/code\u003e is the type of symbols and \u003ccode\u003er\u003c/code\u003e is the\n result type (as in the \u003ccode\u003e\u003ca\u003eRE\u003c/a\u003e\u003c/code\u003e type). Think of \u003ccode\u003e\u003ca\u003eReObject\u003c/a\u003e\u003c/code\u003e as a collection of\n \u003ccode\u003e\u003ca\u003eThread\u003c/a\u003e\u003c/code\u003es ordered by priority. E.g. threads generated by the left part of\n \u003ccode\u003e\u003ca\u003e\u003c|\u003e\u003c/a\u003e\u003c/code\u003e come before the threads generated by the right part.\n\u003c/p\u003e",
          "module": "Text.Regex.Applicative.Object",
          "name": "ReObject",
          "package": "regex-applicative",
          "source": "src/Text-Regex-Applicative-Object.html#ReObject",
          "type": "data"
        },
        "index": {
          "description": "The state of the engine is represented as regex object of type ReObject where is the type of symbols and is the result type as in the RE type Think of ReObject as collection of Thread ordered by priority E.g threads generated by the left part of come before the threads generated by the right part",
          "hierarchy": "Text Regex Applicative Object",
          "module": "Text.Regex.Applicative.Object",
          "name": "ReObject",
          "package": "regex-applicative",
          "partial": "Re Object",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/regex-applicative/docs/Text-Regex-Applicative-Object.html#t:ReObject"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA thread either is a result or corresponds to a symbol in the regular\n expression, which is expected by that thread.\n\u003c/p\u003e",
          "module": "Text.Regex.Applicative.Object",
          "name": "Thread",
          "package": "regex-applicative",
          "source": "src/Text-Regex-Applicative-Types.html#Thread",
          "type": "data"
        },
        "index": {
          "description": "thread either is result or corresponds to symbol in the regular expression which is expected by that thread",
          "hierarchy": "Text Regex Applicative Object",
          "module": "Text.Regex.Applicative.Object",
          "name": "Thread",
          "package": "regex-applicative",
          "partial": "Thread",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/regex-applicative/docs/Text-Regex-Applicative-Object.html#t:Thread"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.Applicative.Object",
          "name": "ThreadId",
          "package": "regex-applicative",
          "source": "src/Text-Regex-Applicative-Types.html#ThreadId",
          "type": "data"
        },
        "index": {
          "hierarchy": "Text Regex Applicative Object",
          "module": "Text.Regex.Applicative.Object",
          "name": "ThreadId",
          "package": "regex-applicative",
          "partial": "Thread Id",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/regex-applicative/docs/Text-Regex-Applicative-Object.html#t:ThreadId"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAdd a thread to an object. The new thread will have lower priority than the\n threads which are already in the object.\n\u003c/p\u003e\u003cp\u003eIf a (non-result) thread with the same id already exists in the object, the\n object is not changed.\n\u003c/p\u003e",
          "module": "Text.Regex.Applicative.Object",
          "name": "addThread",
          "package": "regex-applicative",
          "signature": "Thread s r -\u003e ReObject s r -\u003e ReObject s r",
          "source": "src/Text-Regex-Applicative-Object.html#addThread",
          "type": "function"
        },
        "index": {
          "description": "Add thread to an object The new thread will have lower priority than the threads which are already in the object If non-result thread with the same id already exists in the object the object is not changed",
          "hierarchy": "Text Regex Applicative Object",
          "module": "Text.Regex.Applicative.Object",
          "name": "addThread",
          "normalized": "Thread a b-\u003eReObject a b-\u003eReObject a b",
          "package": "regex-applicative",
          "partial": "Thread",
          "signature": "Thread s r-\u003eReObject s r-\u003eReObject s r",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-applicative/docs/Text-Regex-Applicative-Object.html#v:addThread"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCompile a regular expression into a regular expression object\n\u003c/p\u003e",
          "module": "Text.Regex.Applicative.Object",
          "name": "compile",
          "package": "regex-applicative",
          "signature": "RE s r -\u003e ReObject s r",
          "source": "src/Text-Regex-Applicative-Object.html#compile",
          "type": "function"
        },
        "index": {
          "description": "Compile regular expression into regular expression object",
          "hierarchy": "Text Regex Applicative Object",
          "module": "Text.Regex.Applicative.Object",
          "name": "compile",
          "normalized": "RE a b-\u003eReObject a b",
          "package": "regex-applicative",
          "signature": "RE s r-\u003eReObject s r",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-applicative/docs/Text-Regex-Applicative-Object.html#v:compile"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEmpty object (with no threads)\n\u003c/p\u003e",
          "module": "Text.Regex.Applicative.Object",
          "name": "emptyObject",
          "package": "regex-applicative",
          "signature": "ReObject s r",
          "source": "src/Text-Regex-Applicative-Object.html#emptyObject",
          "type": "function"
        },
        "index": {
          "description": "Empty object with no threads",
          "hierarchy": "Text Regex Applicative Object",
          "module": "Text.Regex.Applicative.Object",
          "name": "emptyObject",
          "package": "regex-applicative",
          "partial": "Object",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-applicative/docs/Text-Regex-Applicative-Object.html#v:emptyObject"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCheck if the object has no threads. In that case it never will\n produce any new threads as a result of \u003ccode\u003e\u003ca\u003estep\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Text.Regex.Applicative.Object",
          "name": "failed",
          "package": "regex-applicative",
          "signature": "ReObject s r -\u003e Bool",
          "source": "src/Text-Regex-Applicative-Object.html#failed",
          "type": "function"
        },
        "index": {
          "description": "Check if the object has no threads In that case it never will produce any new threads as result of step",
          "hierarchy": "Text Regex Applicative Object",
          "module": "Text.Regex.Applicative.Object",
          "name": "failed",
          "normalized": "ReObject a b-\u003eBool",
          "package": "regex-applicative",
          "signature": "ReObject s r-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-applicative/docs/Text-Regex-Applicative-Object.html#v:failed"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreate an object from a list of threads. It is recommended that all\n threads come from the same \u003ccode\u003e\u003ca\u003eReObject\u003c/a\u003e\u003c/code\u003e, unless you know what you're doing.\n However, it should be safe to filter out or rearrange threads.\n\u003c/p\u003e",
          "module": "Text.Regex.Applicative.Object",
          "name": "fromThreads",
          "package": "regex-applicative",
          "signature": "[Thread s r] -\u003e ReObject s r",
          "source": "src/Text-Regex-Applicative-Object.html#fromThreads",
          "type": "function"
        },
        "index": {
          "description": "Create an object from list of threads It is recommended that all threads come from the same ReObject unless you know what you re doing However it should be safe to filter out or rearrange threads",
          "hierarchy": "Text Regex Applicative Object",
          "module": "Text.Regex.Applicative.Object",
          "name": "fromThreads",
          "normalized": "[Thread a b]-\u003eReObject a b",
          "package": "regex-applicative",
          "partial": "Threads",
          "signature": "[Thread s r]-\u003eReObject s r",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-applicative/docs/Text-Regex-Applicative-Object.html#v:fromThreads"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn the result of a result thread, or \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e if it's not a result\n thread\n\u003c/p\u003e",
          "module": "Text.Regex.Applicative.Object",
          "name": "getResult",
          "package": "regex-applicative",
          "signature": "Thread s r -\u003e Maybe r",
          "source": "src/Text-Regex-Applicative-Object.html#getResult",
          "type": "function"
        },
        "index": {
          "description": "Return the result of result thread or Nothing if it not result thread",
          "hierarchy": "Text Regex Applicative Object",
          "module": "Text.Regex.Applicative.Object",
          "name": "getResult",
          "normalized": "Thread a b-\u003eMaybe b",
          "package": "regex-applicative",
          "partial": "Result",
          "signature": "Thread s r-\u003eMaybe r",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-applicative/docs/Text-Regex-Applicative-Object.html#v:getResult"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCheck whether a thread is a result thread\n\u003c/p\u003e",
          "module": "Text.Regex.Applicative.Object",
          "name": "isResult",
          "package": "regex-applicative",
          "signature": "Thread s r -\u003e Bool",
          "source": "src/Text-Regex-Applicative-Object.html#isResult",
          "type": "function"
        },
        "index": {
          "description": "Check whether thread is result thread",
          "hierarchy": "Text Regex Applicative Object",
          "module": "Text.Regex.Applicative.Object",
          "name": "isResult",
          "normalized": "Thread a b-\u003eBool",
          "package": "regex-applicative",
          "partial": "Result",
          "signature": "Thread s r-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-applicative/docs/Text-Regex-Applicative-Object.html#v:isResult"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExtract the result values from all the result threads of an object\n\u003c/p\u003e",
          "module": "Text.Regex.Applicative.Object",
          "name": "results",
          "package": "regex-applicative",
          "signature": "ReObject s r -\u003e [r]",
          "source": "src/Text-Regex-Applicative-Object.html#results",
          "type": "function"
        },
        "index": {
          "description": "Extract the result values from all the result threads of an object",
          "hierarchy": "Text Regex Applicative Object",
          "module": "Text.Regex.Applicative.Object",
          "name": "results",
          "normalized": "ReObject a b-\u003e[b]",
          "package": "regex-applicative",
          "signature": "ReObject s r-\u003e[r]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-applicative/docs/Text-Regex-Applicative-Object.html#v:results"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFeed a symbol into a regex object\n\u003c/p\u003e",
          "module": "Text.Regex.Applicative.Object",
          "name": "step",
          "package": "regex-applicative",
          "signature": "s -\u003e ReObject s r -\u003e ReObject s r",
          "source": "src/Text-Regex-Applicative-Object.html#step",
          "type": "function"
        },
        "index": {
          "description": "Feed symbol into regex object",
          "hierarchy": "Text Regex Applicative Object",
          "module": "Text.Regex.Applicative.Object",
          "name": "step",
          "normalized": "a-\u003eReObject a b-\u003eReObject a b",
          "package": "regex-applicative",
          "signature": "s-\u003eReObject s r-\u003eReObject s r",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-applicative/docs/Text-Regex-Applicative-Object.html#v:step"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFeed a symbol into a non-result thread. It is an error to call \u003ccode\u003e\u003ca\u003estepThread\u003c/a\u003e\u003c/code\u003e\n on a result thread.\n\u003c/p\u003e",
          "module": "Text.Regex.Applicative.Object",
          "name": "stepThread",
          "package": "regex-applicative",
          "signature": "s -\u003e Thread s r -\u003e [Thread s r]",
          "source": "src/Text-Regex-Applicative-Object.html#stepThread",
          "type": "function"
        },
        "index": {
          "description": "Feed symbol into non-result thread It is an error to call stepThread on result thread",
          "hierarchy": "Text Regex Applicative Object",
          "module": "Text.Regex.Applicative.Object",
          "name": "stepThread",
          "normalized": "a-\u003eThread a b-\u003e[Thread a b]",
          "package": "regex-applicative",
          "partial": "Thread",
          "signature": "s-\u003eThread s r-\u003e[Thread s r]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-applicative/docs/Text-Regex-Applicative-Object.html#v:stepThread"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturns thread identifier. This will be \u003ccode\u003e\u003ca\u003eJust\u003c/a\u003e\u003c/code\u003e for ordinary threads and\n \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e for results.\n\u003c/p\u003e",
          "module": "Text.Regex.Applicative.Object",
          "name": "threadId",
          "package": "regex-applicative",
          "signature": "Thread s r -\u003e Maybe ThreadId",
          "source": "src/Text-Regex-Applicative-Types.html#threadId",
          "type": "function"
        },
        "index": {
          "description": "Returns thread identifier This will be Just for ordinary threads and Nothing for results",
          "hierarchy": "Text Regex Applicative Object",
          "module": "Text.Regex.Applicative.Object",
          "name": "threadId",
          "normalized": "Thread a b-\u003eMaybe ThreadId",
          "package": "regex-applicative",
          "partial": "Id",
          "signature": "Thread s r-\u003eMaybe ThreadId",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-applicative/docs/Text-Regex-Applicative-Object.html#v:threadId"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eList of all threads of an object. Each non-result thread has a unique id.\n\u003c/p\u003e",
          "module": "Text.Regex.Applicative.Object",
          "name": "threads",
          "package": "regex-applicative",
          "signature": "ReObject s r -\u003e [Thread s r]",
          "source": "src/Text-Regex-Applicative-Object.html#threads",
          "type": "function"
        },
        "index": {
          "description": "List of all threads of an object Each non-result thread has unique id",
          "hierarchy": "Text Regex Applicative Object",
          "module": "Text.Regex.Applicative.Object",
          "name": "threads",
          "normalized": "ReObject a b-\u003e[Thread a b]",
          "package": "regex-applicative",
          "signature": "ReObject s r-\u003e[Thread s r]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-applicative/docs/Text-Regex-Applicative-Object.html#v:threads"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eReference implementation (using backtracking).\n\u003c/p\u003e\u003cp\u003eThis is exposed for testing purposes only!\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Text.Regex.Applicative.Reference",
          "name": "Reference",
          "package": "regex-applicative",
          "source": "src/Text-Regex-Applicative-Reference.html",
          "type": "module"
        },
        "index": {
          "description": "Reference implementation using backtracking This is exposed for testing purposes only",
          "hierarchy": "Text Regex Applicative Reference",
          "module": "Text.Regex.Applicative.Reference",
          "name": "Reference",
          "package": "regex-applicative",
          "partial": "Reference",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/regex-applicative/docs/Text-Regex-Applicative-Reference.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003ereference\u003c/a\u003e\u003c/code\u003e \u003ccode\u003er\u003c/code\u003e \u003ccode\u003es\u003c/code\u003e should give the same results as \u003ccode\u003es\u003c/code\u003e \u003ccode\u003e=~\u003c/code\u003e \u003ccode\u003er\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eHowever, this is not very efficient implementation and is supposed to be\n used for testing only.\n\u003c/p\u003e",
          "module": "Text.Regex.Applicative.Reference",
          "name": "reference",
          "package": "regex-applicative",
          "signature": "RE s a -\u003e [s] -\u003e Maybe a",
          "source": "src/Text-Regex-Applicative-Reference.html#reference",
          "type": "function"
        },
        "index": {
          "description": "reference should give the same results as However this is not very efficient implementation and is supposed to be used for testing only",
          "hierarchy": "Text Regex Applicative Reference",
          "module": "Text.Regex.Applicative.Reference",
          "name": "reference",
          "normalized": "RE a b-\u003e[a]-\u003eMaybe b",
          "package": "regex-applicative",
          "signature": "RE s a-\u003e[s]-\u003eMaybe a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-applicative/docs/Text-Regex-Applicative-Reference.html#v:reference"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eTo get started, see some examples on the wiki:\n \u003ca\u003ehttps://github.com/feuerbach/regex-applicative/wiki/Examples\u003c/a\u003e\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Text.Regex.Applicative",
          "name": "Applicative",
          "package": "regex-applicative",
          "source": "src/Text-Regex-Applicative.html",
          "type": "module"
        },
        "index": {
          "description": "To get started see some examples on the wiki https github.com feuerbach regex-applicative wiki Examples",
          "hierarchy": "Text Regex Applicative",
          "module": "Text.Regex.Applicative",
          "name": "Applicative",
          "package": "regex-applicative",
          "partial": "Applicative",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/regex-applicative/docs/Text-Regex-Applicative.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.Applicative",
          "name": "Greediness",
          "package": "regex-applicative",
          "source": "src/Text-Regex-Applicative-Types.html#Greediness",
          "type": "data"
        },
        "index": {
          "hierarchy": "Text Regex Applicative",
          "module": "Text.Regex.Applicative",
          "name": "Greediness",
          "package": "regex-applicative",
          "partial": "Greediness",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/regex-applicative/docs/Text-Regex-Applicative.html#t:Greediness"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eType of regular expressions that recognize symbols of type \u003ccode\u003es\u003c/code\u003e and\n produce a result of type \u003ccode\u003ea\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eRegular expressions can be built using \u003ccode\u003e\u003ca\u003eFunctor\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eApplicative\u003c/a\u003e\u003c/code\u003e and\n \u003ccode\u003e\u003ca\u003eAlternative\u003c/a\u003e\u003c/code\u003e instances in the following natural way:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e \u003ccode\u003ef\u003c/code\u003e \u003ccode\u003e\u003ca\u003e\u003c$\u003e\u003c/a\u003e\u003c/code\u003e \u003ccode\u003era\u003c/code\u003e matches iff \u003ccode\u003era\u003c/code\u003e matches, and its return value is the result\n of applying \u003ccode\u003ef\u003c/code\u003e to the return value of \u003ccode\u003era\u003c/code\u003e.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003epure\u003c/a\u003e\u003c/code\u003e \u003ccode\u003ex\u003c/code\u003e matches the empty string (i.e. it does not consume any symbols),\n and its return value is \u003ccode\u003ex\u003c/code\u003e\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003erf\u003c/code\u003e \u003ccode\u003e\u003ca\u003e\u003c*\u003e\u003c/a\u003e\u003c/code\u003e \u003ccode\u003era\u003c/code\u003e matches a string iff it is a concatenation of two\n strings: one matched by \u003ccode\u003erf\u003c/code\u003e and the other matched by \u003ccode\u003era\u003c/code\u003e. The return value\n is \u003ccode\u003ef a\u003c/code\u003e, where \u003ccode\u003ef\u003c/code\u003e and \u003ccode\u003ea\u003c/code\u003e are the return values of \u003ccode\u003erf\u003c/code\u003e and \u003ccode\u003era\u003c/code\u003e\n respectively.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003era\u003c/code\u003e \u003ccode\u003e\u003ca\u003e\u003c|\u003e\u003c/a\u003e\u003c/code\u003e \u003ccode\u003erb\u003c/code\u003e matches a string which is accepted by either \u003ccode\u003era\u003c/code\u003e or \u003ccode\u003erb\u003c/code\u003e.\n It is left-biased, so if both can match, the result of \u003ccode\u003era\u003c/code\u003e is used.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eempty\u003c/a\u003e\u003c/code\u003e is a regular expression which does not match any string.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003emany\u003c/a\u003e\u003c/code\u003e \u003ccode\u003era\u003c/code\u003e matches concatenation of zero or more strings matched by \u003ccode\u003era\u003c/code\u003e\n and returns the list of \u003ccode\u003era\u003c/code\u003e's return values on those strings.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003esome\u003c/a\u003e\u003c/code\u003e \u003ccode\u003era\u003c/code\u003e matches concatenation of one or more strings matched by \u003ccode\u003era\u003c/code\u003e\n and returns the list of \u003ccode\u003era\u003c/code\u003e's return values on those strings.\n\u003c/li\u003e\u003c/ul\u003e",
          "module": "Text.Regex.Applicative",
          "name": "RE",
          "package": "regex-applicative",
          "source": "src/Text-Regex-Applicative-Types.html#RE",
          "type": "data"
        },
        "index": {
          "description": "Type of regular expressions that recognize symbols of type and produce result of type Regular expressions can be built using Functor Applicative and Alternative instances in the following natural way ra matches iff ra matches and its return value is the result of applying to the return value of ra pure matches the empty string i.e it does not consume any symbols and its return value is rf ra matches string iff it is concatenation of two strings one matched by rf and the other matched by ra The return value is where and are the return values of rf and ra respectively ra rb matches string which is accepted by either ra or rb It is left-biased so if both can match the result of ra is used empty is regular expression which does not match any string many ra matches concatenation of zero or more strings matched by ra and returns the list of ra return values on those strings some ra matches concatenation of one or more strings matched by ra and returns the list of ra return values on those strings",
          "hierarchy": "Text Regex Applicative",
          "module": "Text.Regex.Applicative",
          "name": "RE",
          "package": "regex-applicative",
          "partial": "RE",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/regex-applicative/docs/Text-Regex-Applicative.html#t:RE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cpre\u003es =~ a = match a s\u003c/pre\u003e",
          "module": "Text.Regex.Applicative",
          "name": "(=~)",
          "package": "regex-applicative",
          "signature": "[s] -\u003e RE s a -\u003e Maybe a",
          "source": "src/Text-Regex-Applicative-Interface.html#%3D~",
          "type": "function"
        },
        "index": {
          "description": "match",
          "hierarchy": "Text Regex Applicative",
          "module": "Text.Regex.Applicative",
          "name": "(=~) =~",
          "normalized": "[a]-\u003eRE a b-\u003eMaybe b",
          "package": "regex-applicative",
          "signature": "[s]-\u003eRE s a-\u003eMaybe a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-applicative/docs/Text-Regex-Applicative.html#v:-61--126-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.Applicative",
          "name": "Greedy",
          "package": "regex-applicative",
          "signature": "Greedy",
          "source": "src/Text-Regex-Applicative-Types.html#Greediness",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex Applicative",
          "module": "Text.Regex.Applicative",
          "name": "Greedy",
          "package": "regex-applicative",
          "partial": "Greedy",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-applicative/docs/Text-Regex-Applicative.html#v:Greedy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.Applicative",
          "name": "NonGreedy",
          "package": "regex-applicative",
          "signature": "NonGreedy",
          "source": "src/Text-Regex-Applicative-Types.html#Greediness",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex Applicative",
          "module": "Text.Regex.Applicative",
          "name": "NonGreedy",
          "package": "regex-applicative",
          "partial": "Non Greedy",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-applicative/docs/Text-Regex-Applicative.html#v:NonGreedy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMatch and return any single symbol\n\u003c/p\u003e",
          "module": "Text.Regex.Applicative",
          "name": "anySym",
          "package": "regex-applicative",
          "signature": "RE s s",
          "source": "src/Text-Regex-Applicative-Interface.html#anySym",
          "type": "function"
        },
        "index": {
          "description": "Match and return any single symbol",
          "hierarchy": "Text Regex Applicative",
          "module": "Text.Regex.Applicative",
          "name": "anySym",
          "package": "regex-applicative",
          "partial": "Sym",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-applicative/docs/Text-Regex-Applicative.html#v:anySym"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMatch zero or more instances of the given expression, but as\n few of them as possible (i.e. \u003cem\u003enon-greedily\u003c/em\u003e). A greedy equivalent of \u003ccode\u003e\u003ca\u003efew\u003c/a\u003e\u003c/code\u003e\n is \u003ccode\u003e\u003ca\u003emany\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eExamples:\n\u003c/p\u003e\u003cpre\u003eText.Regex.Applicative\u003e findFirstPrefix (few anySym  \u003c* \"b\") \"ababab\"\nJust (\"a\",\"abab\")\nText.Regex.Applicative\u003e findFirstPrefix (many anySym  \u003c* \"b\") \"ababab\"\nJust (\"ababa\",\"\")\n\u003c/pre\u003e",
          "module": "Text.Regex.Applicative",
          "name": "few",
          "package": "regex-applicative",
          "signature": "RE s a -\u003e RE s [a]",
          "source": "src/Text-Regex-Applicative-Interface.html#few",
          "type": "function"
        },
        "index": {
          "description": "Match zero or more instances of the given expression but as few of them as possible i.e non-greedily greedy equivalent of few is many Examples Text.Regex.Applicative findFirstPrefix few anySym ababab Just abab Text.Regex.Applicative findFirstPrefix many anySym ababab Just ababa",
          "hierarchy": "Text Regex Applicative",
          "module": "Text.Regex.Applicative",
          "name": "few",
          "normalized": "RE a b-\u003eRE a[b]",
          "package": "regex-applicative",
          "signature": "RE s a-\u003eRE s[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-applicative/docs/Text-Regex-Applicative.html#v:few"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFind the leftmost substring that is matched by the regular expression.\n Otherwise behaves like \u003ccode\u003e\u003ca\u003efindFirstPrefix\u003c/a\u003e\u003c/code\u003e. Returns the result together with\n the prefix and suffix of the string surrounding the match.\n\u003c/p\u003e",
          "module": "Text.Regex.Applicative",
          "name": "findFirstInfix",
          "package": "regex-applicative",
          "signature": "RE s a -\u003e [s] -\u003e Maybe ([s], a, [s])",
          "source": "src/Text-Regex-Applicative-Interface.html#findFirstInfix",
          "type": "function"
        },
        "index": {
          "description": "Find the leftmost substring that is matched by the regular expression Otherwise behaves like findFirstPrefix Returns the result together with the prefix and suffix of the string surrounding the match",
          "hierarchy": "Text Regex Applicative",
          "module": "Text.Regex.Applicative",
          "name": "findFirstInfix",
          "normalized": "RE a b-\u003e[a]-\u003eMaybe([a],b,[a])",
          "package": "regex-applicative",
          "partial": "First Infix",
          "signature": "RE s a-\u003e[s]-\u003eMaybe([s],a,[s])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-applicative/docs/Text-Regex-Applicative.html#v:findFirstInfix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFind a string prefix which is matched by the regular expression.\n\u003c/p\u003e\u003cp\u003eOf all matching prefixes, pick one using left bias (prefer the left part of\n \u003ccode\u003e\u003ca\u003e\u003c|\u003e\u003c/a\u003e\u003c/code\u003e to the right part) and greediness.\n\u003c/p\u003e\u003cp\u003eThis is the match which a backtracking engine (such as Perl's one) would find\n first.\n\u003c/p\u003e\u003cp\u003eIf match is found, the rest of the input is also returned.\n\u003c/p\u003e\u003cp\u003eExamples:\n\u003c/p\u003e\u003cpre\u003eText.Regex.Applicative\u003e findFirstPrefix (\"a\" \u003c|\u003e \"ab\") \"abc\"\nJust (\"a\",\"bc\")\nText.Regex.Applicative\u003e findFirstPrefix (\"ab\" \u003c|\u003e \"a\") \"abc\"\nJust (\"ab\",\"c\")\nText.Regex.Applicative\u003e findFirstPrefix \"bc\" \"abc\"\nNothing\n\u003c/pre\u003e",
          "module": "Text.Regex.Applicative",
          "name": "findFirstPrefix",
          "package": "regex-applicative",
          "signature": "RE s a -\u003e [s] -\u003e Maybe (a, [s])",
          "source": "src/Text-Regex-Applicative-Interface.html#findFirstPrefix",
          "type": "function"
        },
        "index": {
          "description": "Find string prefix which is matched by the regular expression Of all matching prefixes pick one using left bias prefer the left part of to the right part and greediness This is the match which backtracking engine such as Perl one would find first If match is found the rest of the input is also returned Examples Text.Regex.Applicative findFirstPrefix ab abc Just bc Text.Regex.Applicative findFirstPrefix ab abc Just ab Text.Regex.Applicative findFirstPrefix bc abc Nothing",
          "hierarchy": "Text Regex Applicative",
          "module": "Text.Regex.Applicative",
          "name": "findFirstPrefix",
          "normalized": "RE a b-\u003e[a]-\u003eMaybe(b,[a])",
          "package": "regex-applicative",
          "partial": "First Prefix",
          "signature": "RE s a-\u003e[s]-\u003eMaybe(a,[s])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-applicative/docs/Text-Regex-Applicative.html#v:findFirstPrefix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFind the leftmost substring that is matched by the regular expression.\n Otherwise behaves like \u003ccode\u003e\u003ca\u003efindLongestPrefix\u003c/a\u003e\u003c/code\u003e. Returns the result together with\n the prefix and suffix of the string surrounding the match.\n\u003c/p\u003e",
          "module": "Text.Regex.Applicative",
          "name": "findLongestInfix",
          "package": "regex-applicative",
          "signature": "RE s a -\u003e [s] -\u003e Maybe ([s], a, [s])",
          "source": "src/Text-Regex-Applicative-Interface.html#findLongestInfix",
          "type": "function"
        },
        "index": {
          "description": "Find the leftmost substring that is matched by the regular expression Otherwise behaves like findLongestPrefix Returns the result together with the prefix and suffix of the string surrounding the match",
          "hierarchy": "Text Regex Applicative",
          "module": "Text.Regex.Applicative",
          "name": "findLongestInfix",
          "normalized": "RE a b-\u003e[a]-\u003eMaybe([a],b,[a])",
          "package": "regex-applicative",
          "partial": "Longest Infix",
          "signature": "RE s a-\u003e[s]-\u003eMaybe([s],a,[s])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-applicative/docs/Text-Regex-Applicative.html#v:findLongestInfix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFind the longest string prefix which is matched by the regular expression.\n\u003c/p\u003e\u003cp\u003eSubmatches are still determined using left bias and greediness, so this is\n different from POSIX semantics.\n\u003c/p\u003e\u003cp\u003eIf match is found, the rest of the input is also returned.\n\u003c/p\u003e\u003cp\u003eExamples:\n\u003c/p\u003e\u003cpre\u003eText.Regex.Applicative Data.Char\u003e let keyword = \"if\"\nText.Regex.Applicative Data.Char\u003e let identifier = many $ psym isAlpha\nText.Regex.Applicative Data.Char\u003e let lexeme = (Left \u003c$\u003e keyword) \u003c|\u003e (Right \u003c$\u003e identifier)\nText.Regex.Applicative Data.Char\u003e findLongestPrefix lexeme \"if foo\"\nJust (Left \"if\",\" foo\")\nText.Regex.Applicative Data.Char\u003e findLongestPrefix lexeme \"iffoo\"\nJust (Right \"iffoo\",\"\")\n\u003c/pre\u003e",
          "module": "Text.Regex.Applicative",
          "name": "findLongestPrefix",
          "package": "regex-applicative",
          "signature": "RE s a -\u003e [s] -\u003e Maybe (a, [s])",
          "source": "src/Text-Regex-Applicative-Interface.html#findLongestPrefix",
          "type": "function"
        },
        "index": {
          "description": "Find the longest string prefix which is matched by the regular expression Submatches are still determined using left bias and greediness so this is different from POSIX semantics If match is found the rest of the input is also returned Examples Text.Regex.Applicative Data.Char let keyword if Text.Regex.Applicative Data.Char let identifier many psym isAlpha Text.Regex.Applicative Data.Char let lexeme Left keyword Right identifier Text.Regex.Applicative Data.Char findLongestPrefix lexeme if foo Just Left if foo Text.Regex.Applicative Data.Char findLongestPrefix lexeme iffoo Just Right iffoo",
          "hierarchy": "Text Regex Applicative",
          "module": "Text.Regex.Applicative",
          "name": "findLongestPrefix",
          "normalized": "RE a b-\u003e[a]-\u003eMaybe(b,[a])",
          "package": "regex-applicative",
          "partial": "Longest Prefix",
          "signature": "RE s a-\u003e[s]-\u003eMaybe(a,[s])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-applicative/docs/Text-Regex-Applicative.html#v:findLongestPrefix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFind the leftmost substring that is matched by the regular expression.\n Otherwise behaves like \u003ccode\u003e\u003ca\u003efindShortestPrefix\u003c/a\u003e\u003c/code\u003e. Returns the result together with\n the prefix and suffix of the string surrounding the match.\n\u003c/p\u003e",
          "module": "Text.Regex.Applicative",
          "name": "findShortestInfix",
          "package": "regex-applicative",
          "signature": "RE s a -\u003e [s] -\u003e Maybe ([s], a, [s])",
          "source": "src/Text-Regex-Applicative-Interface.html#findShortestInfix",
          "type": "function"
        },
        "index": {
          "description": "Find the leftmost substring that is matched by the regular expression Otherwise behaves like findShortestPrefix Returns the result together with the prefix and suffix of the string surrounding the match",
          "hierarchy": "Text Regex Applicative",
          "module": "Text.Regex.Applicative",
          "name": "findShortestInfix",
          "normalized": "RE a b-\u003e[a]-\u003eMaybe([a],b,[a])",
          "package": "regex-applicative",
          "partial": "Shortest Infix",
          "signature": "RE s a-\u003e[s]-\u003eMaybe([s],a,[s])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-applicative/docs/Text-Regex-Applicative.html#v:findShortestInfix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFind the shortest prefix (analogous to \u003ccode\u003e\u003ca\u003efindLongestPrefix\u003c/a\u003e\u003c/code\u003e)\n\u003c/p\u003e",
          "module": "Text.Regex.Applicative",
          "name": "findShortestPrefix",
          "package": "regex-applicative",
          "signature": "RE s a -\u003e [s] -\u003e Maybe (a, [s])",
          "source": "src/Text-Regex-Applicative-Interface.html#findShortestPrefix",
          "type": "function"
        },
        "index": {
          "description": "Find the shortest prefix analogous to findLongestPrefix",
          "hierarchy": "Text Regex Applicative",
          "module": "Text.Regex.Applicative",
          "name": "findShortestPrefix",
          "normalized": "RE a b-\u003e[a]-\u003eMaybe(b,[a])",
          "package": "regex-applicative",
          "partial": "Shortest Prefix",
          "signature": "RE s a-\u003e[s]-\u003eMaybe(a,[s])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-applicative/docs/Text-Regex-Applicative.html#v:findShortestPrefix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAttempt to match a string of symbols against the regular expression.\n Note that the whole string (not just some part of it) should be matched.\n\u003c/p\u003e\u003cp\u003eExamples:\n\u003c/p\u003e\u003cpre\u003eText.Regex.Applicative\u003e match (sym 'a' \u003c|\u003e sym 'b') \"a\"\nJust 'a'\nText.Regex.Applicative\u003e match (sym 'a' \u003c|\u003e sym 'b') \"ab\"\nNothing\n\u003c/pre\u003e",
          "module": "Text.Regex.Applicative",
          "name": "match",
          "package": "regex-applicative",
          "signature": "RE s a -\u003e [s] -\u003e Maybe a",
          "source": "src/Text-Regex-Applicative-Interface.html#match",
          "type": "function"
        },
        "index": {
          "description": "Attempt to match string of symbols against the regular expression Note that the whole string not just some part of it should be matched Examples Text.Regex.Applicative match sym sym Just Text.Regex.Applicative match sym sym ab Nothing",
          "hierarchy": "Text Regex Applicative",
          "module": "Text.Regex.Applicative",
          "name": "match",
          "normalized": "RE a b-\u003e[a]-\u003eMaybe b",
          "package": "regex-applicative",
          "signature": "RE s a-\u003e[s]-\u003eMaybe a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-applicative/docs/Text-Regex-Applicative.html#v:match"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMatch and return a single symbol which satisfies the predicate\n\u003c/p\u003e",
          "module": "Text.Regex.Applicative",
          "name": "psym",
          "package": "regex-applicative",
          "signature": "(s -\u003e Bool) -\u003e RE s s",
          "source": "src/Text-Regex-Applicative-Interface.html#psym",
          "type": "function"
        },
        "index": {
          "description": "Match and return single symbol which satisfies the predicate",
          "hierarchy": "Text Regex Applicative",
          "module": "Text.Regex.Applicative",
          "name": "psym",
          "normalized": "(a-\u003eBool)-\u003eRE a a",
          "package": "regex-applicative",
          "signature": "(s-\u003eBool)-\u003eRE s s",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-applicative/docs/Text-Regex-Applicative.html#v:psym"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMatch zero or more instances of the given expression, which are combined using\n the given folding function.\n\u003c/p\u003e\u003cp\u003e\u003ccode\u003e\u003ca\u003eGreediness\u003c/a\u003e\u003c/code\u003e argument controls whether this regular expression should match\n as many as possible (\u003ccode\u003e\u003ca\u003eGreedy\u003c/a\u003e\u003c/code\u003e) or as few as possible (\u003ccode\u003e\u003ca\u003eNonGreedy\u003c/a\u003e\u003c/code\u003e) instances\n of the underlying expression.\n\u003c/p\u003e",
          "module": "Text.Regex.Applicative",
          "name": "reFoldl",
          "package": "regex-applicative",
          "signature": "Greediness -\u003e (b -\u003e a -\u003e b) -\u003e b -\u003e RE s a -\u003e RE s b",
          "source": "src/Text-Regex-Applicative-Interface.html#reFoldl",
          "type": "function"
        },
        "index": {
          "description": "Match zero or more instances of the given expression which are combined using the given folding function Greediness argument controls whether this regular expression should match as many as possible Greedy or as few as possible NonGreedy instances of the underlying expression",
          "hierarchy": "Text Regex Applicative",
          "module": "Text.Regex.Applicative",
          "name": "reFoldl",
          "normalized": "Greediness-\u003e(a-\u003eb-\u003ea)-\u003ea-\u003eRE c b-\u003eRE c a",
          "package": "regex-applicative",
          "partial": "Foldl",
          "signature": "Greediness-\u003e(b-\u003ea-\u003eb)-\u003eb-\u003eRE s a-\u003eRE s b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-applicative/docs/Text-Regex-Applicative.html#v:reFoldl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMatch and return the given sequence of symbols.\n\u003c/p\u003e\u003cp\u003eNote that there is an \u003ccode\u003e\u003ca\u003eIsString\u003c/a\u003e\u003c/code\u003e instance for regular expression, so\n if you enable the \u003ccode\u003eOverloadedStrings\u003c/code\u003e language extension, you can write\n \u003ccode\u003estring \"foo\"\u003c/code\u003e simply as \u003ccode\u003e\"foo\"\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eExample:\n\u003c/p\u003e\u003cpre\u003e{-# LANGUAGE OverloadedStrings #-}\nimport Text.Regex.Applicative\n\nnumber = \"one\" *\u003e pure 1  \u003c|\u003e  \"two\" *\u003e pure 2\n\nmain = print $ \"two\" =~ number\n\u003c/pre\u003e",
          "module": "Text.Regex.Applicative",
          "name": "string",
          "package": "regex-applicative",
          "signature": "[a] -\u003e RE a [a]",
          "source": "src/Text-Regex-Applicative-Interface.html#string",
          "type": "function"
        },
        "index": {
          "description": "Match and return the given sequence of symbols Note that there is an IsString instance for regular expression so if you enable the OverloadedStrings language extension you can write string foo simply as foo Example LANGUAGE OverloadedStrings import Text.Regex.Applicative number one pure two pure main print two number",
          "hierarchy": "Text Regex Applicative",
          "module": "Text.Regex.Applicative",
          "name": "string",
          "normalized": "[a]-\u003eRE a[a]",
          "package": "regex-applicative",
          "signature": "[a]-\u003eRE a[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-applicative/docs/Text-Regex-Applicative.html#v:string"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMatch and return the given symbol\n\u003c/p\u003e",
          "module": "Text.Regex.Applicative",
          "name": "sym",
          "package": "regex-applicative",
          "signature": "s -\u003e RE s s",
          "source": "src/Text-Regex-Applicative-Interface.html#sym",
          "type": "function"
        },
        "index": {
          "description": "Match and return the given symbol",
          "hierarchy": "Text Regex Applicative",
          "module": "Text.Regex.Applicative",
          "name": "sym",
          "normalized": "a-\u003eRE a a",
          "package": "regex-applicative",
          "signature": "s-\u003eRE s s",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-applicative/docs/Text-Regex-Applicative.html#v:sym"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn matched symbols as part of the return value\n\u003c/p\u003e",
          "module": "Text.Regex.Applicative",
          "name": "withMatched",
          "package": "regex-applicative",
          "signature": "RE s a -\u003e RE s (a, [s])",
          "source": "src/Text-Regex-Applicative-Interface.html#withMatched",
          "type": "function"
        },
        "index": {
          "description": "Return matched symbols as part of the return value",
          "hierarchy": "Text Regex Applicative",
          "module": "Text.Regex.Applicative",
          "name": "withMatched",
          "normalized": "RE a b-\u003eRE a(b,[a])",
          "package": "regex-applicative",
          "partial": "Matched",
          "signature": "RE s a-\u003eRE s(a,[s])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-applicative/docs/Text-Regex-Applicative.html#v:withMatched"
      }
    }
  ]
]