[
  {
    "cmd": "delete-by-query",
    "query": {
      "contexts": [
        "package"
      ],
      "query": {
        "op": "case",
        "type": "word",
        "word": "regex-xmlschema"
      },
      "type": "context"
    }
  },
  [
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eChar sets implemeted as sorted lists of intervalls\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Text.Regex.XMLSchema.String.CharSet",
          "name": "CharSet",
          "package": "regex-xmlschema",
          "source": "src/Text-Regex-XMLSchema-String-CharSet.html",
          "type": "module"
        },
        "index": {
          "description": "Char sets implemeted as sorted lists of intervalls",
          "hierarchy": "Text Regex XMLSchema String CharSet",
          "module": "Text.Regex.XMLSchema.String.CharSet",
          "name": "CharSet",
          "package": "regex-xmlschema",
          "partial": "Char Set",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/regex-xmlschema/docs/Text-Regex-XMLSchema-String-CharSet.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.XMLSchema.String.CharSet",
          "name": "CharSet",
          "package": "regex-xmlschema",
          "source": "src/Text-Regex-XMLSchema-String-CharSet.html#CharSet",
          "type": "type"
        },
        "index": {
          "hierarchy": "Text Regex XMLSchema String CharSet",
          "module": "Text.Regex.XMLSchema.String.CharSet",
          "name": "CharSet",
          "package": "regex-xmlschema",
          "partial": "Char Set",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/regex-xmlschema/docs/Text-Regex-XMLSchema-String-CharSet.html#t:CharSet"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.XMLSchema.String.CharSet",
          "name": "allCS",
          "package": "regex-xmlschema",
          "signature": "CharSet",
          "source": "src/Text-Regex-XMLSchema-String-CharSet.html#allCS",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex XMLSchema String CharSet",
          "module": "Text.Regex.XMLSchema.String.CharSet",
          "name": "allCS",
          "package": "regex-xmlschema",
          "partial": "CS",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-xmlschema/docs/Text-Regex-XMLSchema-String-CharSet.html#v:allCS"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.XMLSchema.String.CharSet",
          "name": "compCS",
          "package": "regex-xmlschema",
          "signature": "CharSet -\u003e CharSet",
          "source": "src/Text-Regex-XMLSchema-String-CharSet.html#compCS",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex XMLSchema String CharSet",
          "module": "Text.Regex.XMLSchema.String.CharSet",
          "name": "compCS",
          "normalized": "CharSet-\u003eCharSet",
          "package": "regex-xmlschema",
          "partial": "CS",
          "signature": "CharSet-\u003eCharSet",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-xmlschema/docs/Text-Regex-XMLSchema-String-CharSet.html#v:compCS"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.XMLSchema.String.CharSet",
          "name": "diffCS",
          "package": "regex-xmlschema",
          "signature": "CharSet -\u003e CharSet -\u003e CharSet",
          "source": "src/Text-Regex-XMLSchema-String-CharSet.html#diffCS",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex XMLSchema String CharSet",
          "module": "Text.Regex.XMLSchema.String.CharSet",
          "name": "diffCS",
          "normalized": "CharSet-\u003eCharSet-\u003eCharSet",
          "package": "regex-xmlschema",
          "partial": "CS",
          "signature": "CharSet-\u003eCharSet-\u003eCharSet",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-xmlschema/docs/Text-Regex-XMLSchema-String-CharSet.html#v:diffCS"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.XMLSchema.String.CharSet",
          "name": "elemCS",
          "package": "regex-xmlschema",
          "signature": "Char -\u003e CharSet -\u003e Bool",
          "source": "src/Text-Regex-XMLSchema-String-CharSet.html#elemCS",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex XMLSchema String CharSet",
          "module": "Text.Regex.XMLSchema.String.CharSet",
          "name": "elemCS",
          "normalized": "Char-\u003eCharSet-\u003eBool",
          "package": "regex-xmlschema",
          "partial": "CS",
          "signature": "Char-\u003eCharSet-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-xmlschema/docs/Text-Regex-XMLSchema-String-CharSet.html#v:elemCS"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.XMLSchema.String.CharSet",
          "name": "emptyCS",
          "package": "regex-xmlschema",
          "signature": "CharSet",
          "source": "src/Text-Regex-XMLSchema-String-CharSet.html#emptyCS",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex XMLSchema String CharSet",
          "module": "Text.Regex.XMLSchema.String.CharSet",
          "name": "emptyCS",
          "package": "regex-xmlschema",
          "partial": "CS",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-xmlschema/docs/Text-Regex-XMLSchema-String-CharSet.html#v:emptyCS"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.XMLSchema.String.CharSet",
          "name": "exorCS",
          "package": "regex-xmlschema",
          "signature": "CharSet -\u003e CharSet -\u003e CharSet",
          "source": "src/Text-Regex-XMLSchema-String-CharSet.html#exorCS",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex XMLSchema String CharSet",
          "module": "Text.Regex.XMLSchema.String.CharSet",
          "name": "exorCS",
          "normalized": "CharSet-\u003eCharSet-\u003eCharSet",
          "package": "regex-xmlschema",
          "partial": "CS",
          "signature": "CharSet-\u003eCharSet-\u003eCharSet",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-xmlschema/docs/Text-Regex-XMLSchema-String-CharSet.html#v:exorCS"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.XMLSchema.String.CharSet",
          "name": "fullCS",
          "package": "regex-xmlschema",
          "signature": "CharSet -\u003e Bool",
          "source": "src/Text-Regex-XMLSchema-String-CharSet.html#fullCS",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex XMLSchema String CharSet",
          "module": "Text.Regex.XMLSchema.String.CharSet",
          "name": "fullCS",
          "normalized": "CharSet-\u003eBool",
          "package": "regex-xmlschema",
          "partial": "CS",
          "signature": "CharSet-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-xmlschema/docs/Text-Regex-XMLSchema-String-CharSet.html#v:fullCS"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.XMLSchema.String.CharSet",
          "name": "intersectCS",
          "package": "regex-xmlschema",
          "signature": "CharSet -\u003e CharSet -\u003e CharSet",
          "source": "src/Text-Regex-XMLSchema-String-CharSet.html#intersectCS",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex XMLSchema String CharSet",
          "module": "Text.Regex.XMLSchema.String.CharSet",
          "name": "intersectCS",
          "normalized": "CharSet-\u003eCharSet-\u003eCharSet",
          "package": "regex-xmlschema",
          "partial": "CS",
          "signature": "CharSet-\u003eCharSet-\u003eCharSet",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-xmlschema/docs/Text-Regex-XMLSchema-String-CharSet.html#v:intersectCS"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.XMLSchema.String.CharSet",
          "name": "nullCS",
          "package": "regex-xmlschema",
          "signature": "CharSet -\u003e Bool",
          "source": "src/Text-Regex-XMLSchema-String-CharSet.html#nullCS",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex XMLSchema String CharSet",
          "module": "Text.Regex.XMLSchema.String.CharSet",
          "name": "nullCS",
          "normalized": "CharSet-\u003eBool",
          "package": "regex-xmlschema",
          "partial": "CS",
          "signature": "CharSet-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-xmlschema/docs/Text-Regex-XMLSchema-String-CharSet.html#v:nullCS"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.XMLSchema.String.CharSet",
          "name": "rangeCS",
          "package": "regex-xmlschema",
          "signature": "Char -\u003e Char -\u003e CharSet",
          "source": "src/Text-Regex-XMLSchema-String-CharSet.html#rangeCS",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex XMLSchema String CharSet",
          "module": "Text.Regex.XMLSchema.String.CharSet",
          "name": "rangeCS",
          "normalized": "Char-\u003eChar-\u003eCharSet",
          "package": "regex-xmlschema",
          "partial": "CS",
          "signature": "Char-\u003eChar-\u003eCharSet",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-xmlschema/docs/Text-Regex-XMLSchema-String-CharSet.html#v:rangeCS"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.XMLSchema.String.CharSet",
          "name": "singleCS",
          "package": "regex-xmlschema",
          "signature": "Char -\u003e CharSet",
          "source": "src/Text-Regex-XMLSchema-String-CharSet.html#singleCS",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex XMLSchema String CharSet",
          "module": "Text.Regex.XMLSchema.String.CharSet",
          "name": "singleCS",
          "normalized": "Char-\u003eCharSet",
          "package": "regex-xmlschema",
          "partial": "CS",
          "signature": "Char-\u003eCharSet",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-xmlschema/docs/Text-Regex-XMLSchema-String-CharSet.html#v:singleCS"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.XMLSchema.String.CharSet",
          "name": "stringCS",
          "package": "regex-xmlschema",
          "signature": "String -\u003e CharSet",
          "source": "src/Text-Regex-XMLSchema-String-CharSet.html#stringCS",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex XMLSchema String CharSet",
          "module": "Text.Regex.XMLSchema.String.CharSet",
          "name": "stringCS",
          "normalized": "String-\u003eCharSet",
          "package": "regex-xmlschema",
          "partial": "CS",
          "signature": "String-\u003eCharSet",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-xmlschema/docs/Text-Regex-XMLSchema-String-CharSet.html#v:stringCS"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.XMLSchema.String.CharSet",
          "name": "unionCS",
          "package": "regex-xmlschema",
          "signature": "CharSet -\u003e CharSet -\u003e CharSet",
          "source": "src/Text-Regex-XMLSchema-String-CharSet.html#unionCS",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex XMLSchema String CharSet",
          "module": "Text.Regex.XMLSchema.String.CharSet",
          "name": "unionCS",
          "normalized": "CharSet-\u003eCharSet-\u003eCharSet",
          "package": "regex-xmlschema",
          "partial": "CS",
          "signature": "CharSet-\u003eCharSet-\u003eCharSet",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-xmlschema/docs/Text-Regex-XMLSchema-String-CharSet.html#v:unionCS"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eW3C XML Schema Regular Expression Matcher\n\u003c/p\u003e\u003cp\u003eGrammar can be found under \u003ca\u003ehttp://www.w3.org/TR/xmlschema11-2/#regexs\u003c/a\u003e\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Text.Regex.XMLSchema.String.Regex",
          "name": "Regex",
          "package": "regex-xmlschema",
          "source": "src/Text-Regex-XMLSchema-String-Regex.html",
          "type": "module"
        },
        "index": {
          "description": "W3C XML Schema Regular Expression Matcher Grammar can be found under http www.w3.org TR xmlschema11-2 regexs",
          "hierarchy": "Text Regex XMLSchema String Regex",
          "module": "Text.Regex.XMLSchema.String.Regex",
          "name": "Regex",
          "package": "regex-xmlschema",
          "partial": "Regex",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/regex-xmlschema/docs/Text-Regex-XMLSchema-String-Regex.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.XMLSchema.String.Regex",
          "name": "GenRegex",
          "package": "regex-xmlschema",
          "source": "src/Text-Regex-XMLSchema-String-Regex.html#GenRegex",
          "type": "data"
        },
        "index": {
          "hierarchy": "Text Regex XMLSchema String Regex",
          "module": "Text.Regex.XMLSchema.String.Regex",
          "name": "GenRegex",
          "package": "regex-xmlschema",
          "partial": "Gen Regex",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/regex-xmlschema/docs/Text-Regex-XMLSchema-String-Regex.html#t:GenRegex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.XMLSchema.String.Regex",
          "name": "Regex",
          "package": "regex-xmlschema",
          "source": "src/Text-Regex-XMLSchema-String-Regex.html#Regex",
          "type": "type"
        },
        "index": {
          "hierarchy": "Text Regex XMLSchema String Regex",
          "module": "Text.Regex.XMLSchema.String.Regex",
          "name": "Regex",
          "package": "regex-xmlschema",
          "partial": "Regex",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/regex-xmlschema/docs/Text-Regex-XMLSchema-String-Regex.html#t:Regex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.XMLSchema.String.Regex",
          "name": "delta",
          "package": "regex-xmlschema",
          "signature": "GenRegex l -\u003e String -\u003e GenRegex l",
          "source": "src/Text-Regex-XMLSchema-String-Regex.html#delta",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex XMLSchema String Regex",
          "module": "Text.Regex.XMLSchema.String.Regex",
          "name": "delta",
          "normalized": "GenRegex a-\u003eString-\u003eGenRegex a",
          "package": "regex-xmlschema",
          "signature": "GenRegex l-\u003eString-\u003eGenRegex l",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-xmlschema/docs/Text-Regex-XMLSchema-String-Regex.html#v:delta"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.XMLSchema.String.Regex",
          "name": "delta1",
          "package": "regex-xmlschema",
          "signature": "GenRegex l -\u003e Char -\u003e GenRegex l",
          "source": "src/Text-Regex-XMLSchema-String-Regex.html#delta1",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex XMLSchema String Regex",
          "module": "Text.Regex.XMLSchema.String.Regex",
          "name": "delta1",
          "normalized": "GenRegex a-\u003eChar-\u003eGenRegex a",
          "package": "regex-xmlschema",
          "signature": "GenRegex l-\u003eChar-\u003eGenRegex l",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-xmlschema/docs/Text-Regex-XMLSchema-String-Regex.html#v:delta1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Text.Regex.XMLSchema.String.Regex\",\"Text.Regex.XMLSchema.String\"]",
          "name": "errRegex",
          "package": "regex-xmlschema",
          "signature": "GenRegex l -\u003e String",
          "source": "src/Text-Regex-XMLSchema-String-Regex.html#errRegex",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/regex-xmlschema/docs/Text-Regex-XMLSchema-String-Regex.html#v:errRegex\",\"http://hackage.haskell.org/package/regex-xmlschema/docs/Text-Regex-XMLSchema-String.html#v:errRegex\"]"
        },
        "index": {
          "hierarchy": "Text Regex XMLSchema String Regex",
          "module": "Text.Regex.XMLSchema.String.Regex",
          "name": "errRegex",
          "normalized": "GenRegex a-\u003eString",
          "package": "regex-xmlschema",
          "partial": "Regex",
          "signature": "GenRegex l-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-xmlschema/docs/Text-Regex-XMLSchema-String-Regex.html#v:errRegex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFIRST for regular expressions\n\u003c/p\u003e\u003cp\u003ethis is only an approximation, the real set of char may be smaller,\n when the expression contains intersection, set difference or exor operators\n\u003c/p\u003e",
          "module": "Text.Regex.XMLSchema.String.Regex",
          "name": "firstChars",
          "package": "regex-xmlschema",
          "signature": "GenRegex l -\u003e CharSet",
          "source": "src/Text-Regex-XMLSchema-String-Regex.html#firstChars",
          "type": "function"
        },
        "index": {
          "description": "FIRST for regular expressions this is only an approximation the real set of char may be smaller when the expression contains intersection set difference or exor operators",
          "hierarchy": "Text Regex XMLSchema String Regex",
          "module": "Text.Regex.XMLSchema.String.Regex",
          "name": "firstChars",
          "normalized": "GenRegex a-\u003eCharSet",
          "package": "regex-xmlschema",
          "partial": "Chars",
          "signature": "GenRegex l-\u003eCharSet",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-xmlschema/docs/Text-Regex-XMLSchema-String-Regex.html#v:firstChars"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Text.Regex.XMLSchema.String.Regex\",\"Text.Regex.XMLSchema.String\"]",
          "name": "isZero",
          "package": "regex-xmlschema",
          "signature": "GenRegex l -\u003e Bool",
          "source": "src/Text-Regex-XMLSchema-String-Regex.html#isZero",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/regex-xmlschema/docs/Text-Regex-XMLSchema-String-Regex.html#v:isZero\",\"http://hackage.haskell.org/package/regex-xmlschema/docs/Text-Regex-XMLSchema-String.html#v:isZero\"]"
        },
        "index": {
          "hierarchy": "Text Regex XMLSchema String Regex",
          "module": "Text.Regex.XMLSchema.String.Regex",
          "name": "isZero",
          "normalized": "GenRegex a-\u003eBool",
          "package": "regex-xmlschema",
          "partial": "Zero",
          "signature": "GenRegex l-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-xmlschema/docs/Text-Regex-XMLSchema-String-Regex.html#v:isZero"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.XMLSchema.String.Regex",
          "name": "matchWithRegex",
          "package": "regex-xmlschema",
          "signature": "GenRegex l -\u003e String -\u003e Bool",
          "source": "src/Text-Regex-XMLSchema-String-Regex.html#matchWithRegex",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex XMLSchema String Regex",
          "module": "Text.Regex.XMLSchema.String.Regex",
          "name": "matchWithRegex",
          "normalized": "GenRegex a-\u003eString-\u003eBool",
          "package": "regex-xmlschema",
          "partial": "With Regex",
          "signature": "GenRegex l-\u003eString-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-xmlschema/docs/Text-Regex-XMLSchema-String-Regex.html#v:matchWithRegex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.XMLSchema.String.Regex",
          "name": "matchWithRegex'",
          "package": "regex-xmlschema",
          "signature": "GenRegex l -\u003e String -\u003e Maybe [(Label l, String)]",
          "source": "src/Text-Regex-XMLSchema-String-Regex.html#matchWithRegex%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex XMLSchema String Regex",
          "module": "Text.Regex.XMLSchema.String.Regex",
          "name": "matchWithRegex'",
          "normalized": "GenRegex a-\u003eString-\u003eMaybe[(Label a,String)]",
          "package": "regex-xmlschema",
          "partial": "With Regex'",
          "signature": "GenRegex l-\u003eString-\u003eMaybe[(Label l,String)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-xmlschema/docs/Text-Regex-XMLSchema-String-Regex.html#v:matchWithRegex-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003econstruct an r.e. for the set of all Unicode words\n\u003c/p\u003e",
          "module": "[\"Text.Regex.XMLSchema.String.Regex\",\"Text.Regex.XMLSchema.String\"]",
          "name": "mkAll",
          "package": "regex-xmlschema",
          "signature": "GenRegex l",
          "source": "src/Text-Regex-XMLSchema-String-Regex.html#mkAll",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/regex-xmlschema/docs/Text-Regex-XMLSchema-String-Regex.html#v:mkAll\",\"http://hackage.haskell.org/package/regex-xmlschema/docs/Text-Regex-XMLSchema-String.html#v:mkAll\"]"
        },
        "index": {
          "description": "construct an r.e for the set of all Unicode words",
          "hierarchy": "Text Regex XMLSchema String Regex",
          "module": "Text.Regex.XMLSchema.String.Regex",
          "name": "mkAll",
          "package": "regex-xmlschema",
          "partial": "All",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-xmlschema/docs/Text-Regex-XMLSchema-String-Regex.html#v:mkAll"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003econstruct the r.e for r1|r2\n\u003c/p\u003e",
          "module": "[\"Text.Regex.XMLSchema.String.Regex\",\"Text.Regex.XMLSchema.String\"]",
          "name": "mkAlt",
          "package": "regex-xmlschema",
          "signature": "GenRegex l -\u003e GenRegex l -\u003e GenRegex l",
          "source": "src/Text-Regex-XMLSchema-String-Regex.html#mkAlt",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/regex-xmlschema/docs/Text-Regex-XMLSchema-String-Regex.html#v:mkAlt\",\"http://hackage.haskell.org/package/regex-xmlschema/docs/Text-Regex-XMLSchema-String.html#v:mkAlt\"]"
        },
        "index": {
          "description": "construct the r.e for r1 r2",
          "hierarchy": "Text Regex XMLSchema String Regex",
          "module": "Text.Regex.XMLSchema.String.Regex",
          "name": "mkAlt",
          "normalized": "GenRegex a-\u003eGenRegex a-\u003eGenRegex a",
          "package": "regex-xmlschema",
          "partial": "Alt",
          "signature": "GenRegex l-\u003eGenRegex l-\u003eGenRegex l",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-xmlschema/docs/Text-Regex-XMLSchema-String-Regex.html#v:mkAlt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstruct a labeled subexpression: ({label}r)\n\u003c/p\u003e",
          "module": "[\"Text.Regex.XMLSchema.String.Regex\",\"Text.Regex.XMLSchema.String\"]",
          "name": "mkBr",
          "package": "regex-xmlschema",
          "signature": "l -\u003e GenRegex l -\u003e GenRegex l",
          "source": "src/Text-Regex-XMLSchema-String-Regex.html#mkBr",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/regex-xmlschema/docs/Text-Regex-XMLSchema-String-Regex.html#v:mkBr\",\"http://hackage.haskell.org/package/regex-xmlschema/docs/Text-Regex-XMLSchema-String.html#v:mkBr\"]"
        },
        "index": {
          "description": "Construct labeled subexpression label",
          "hierarchy": "Text Regex XMLSchema String Regex",
          "module": "Text.Regex.XMLSchema.String.Regex",
          "name": "mkBr",
          "normalized": "a-\u003eGenRegex a-\u003eGenRegex a",
          "package": "regex-xmlschema",
          "partial": "Br",
          "signature": "l-\u003eGenRegex l-\u003eGenRegex l",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-xmlschema/docs/Text-Regex-XMLSchema-String-Regex.html#v:mkBr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstruct the Complement of an r.e.: whole set of words - r\n\u003c/p\u003e",
          "module": "[\"Text.Regex.XMLSchema.String.Regex\",\"Text.Regex.XMLSchema.String\"]",
          "name": "mkCompl",
          "package": "regex-xmlschema",
          "signature": "GenRegex l -\u003e GenRegex l",
          "source": "src/Text-Regex-XMLSchema-String-Regex.html#mkCompl",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/regex-xmlschema/docs/Text-Regex-XMLSchema-String-Regex.html#v:mkCompl\",\"http://hackage.haskell.org/package/regex-xmlschema/docs/Text-Regex-XMLSchema-String.html#v:mkCompl\"]"
        },
        "index": {
          "description": "Construct the Complement of an r.e whole set of words",
          "hierarchy": "Text Regex XMLSchema String Regex",
          "module": "Text.Regex.XMLSchema.String.Regex",
          "name": "mkCompl",
          "normalized": "GenRegex a-\u003eGenRegex a",
          "package": "regex-xmlschema",
          "partial": "Compl",
          "signature": "GenRegex l-\u003eGenRegex l",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-xmlschema/docs/Text-Regex-XMLSchema-String-Regex.html#v:mkCompl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstruct difference r.e.: r1 {\\} r2\n\u003c/p\u003e\u003cp\u003eexample\n\u003c/p\u003e\u003cpre\u003e match \"[a-z]+{\\\\}bush\" \"obama\"     = True\n match \"[a-z]+{\\\\}bush\" \"clinton\"   = True\n match \"[a-z]+{\\\\}bush\" \"bush\"      = False     -- not important any more\n\u003c/pre\u003e",
          "module": "[\"Text.Regex.XMLSchema.String.Regex\",\"Text.Regex.XMLSchema.String\"]",
          "name": "mkDiff",
          "package": "regex-xmlschema",
          "signature": "GenRegex l -\u003e GenRegex l -\u003e GenRegex l",
          "source": "src/Text-Regex-XMLSchema-String-Regex.html#mkDiff",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/regex-xmlschema/docs/Text-Regex-XMLSchema-String-Regex.html#v:mkDiff\",\"http://hackage.haskell.org/package/regex-xmlschema/docs/Text-Regex-XMLSchema-String.html#v:mkDiff\"]"
        },
        "index": {
          "description": "Construct difference r.e r1 r2 example match a-z bush obama True match a-z bush clinton True match a-z bush bush False not important any more",
          "hierarchy": "Text Regex XMLSchema String Regex",
          "module": "Text.Regex.XMLSchema.String.Regex",
          "name": "mkDiff",
          "normalized": "GenRegex a-\u003eGenRegex a-\u003eGenRegex a",
          "package": "regex-xmlschema",
          "partial": "Diff",
          "signature": "GenRegex l-\u003eGenRegex l-\u003eGenRegex l",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-xmlschema/docs/Text-Regex-XMLSchema-String-Regex.html#v:mkDiff"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003econstruct an r.e. for the set of all Unicode chars\n\u003c/p\u003e",
          "module": "[\"Text.Regex.XMLSchema.String.Regex\",\"Text.Regex.XMLSchema.String\"]",
          "name": "mkDot",
          "package": "regex-xmlschema",
          "signature": "GenRegex l",
          "source": "src/Text-Regex-XMLSchema-String-Regex.html#mkDot",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/regex-xmlschema/docs/Text-Regex-XMLSchema-String-Regex.html#v:mkDot\",\"http://hackage.haskell.org/package/regex-xmlschema/docs/Text-Regex-XMLSchema-String.html#v:mkDot\"]"
        },
        "index": {
          "description": "construct an r.e for the set of all Unicode chars",
          "hierarchy": "Text Regex XMLSchema String Regex",
          "module": "Text.Regex.XMLSchema.String.Regex",
          "name": "mkDot",
          "package": "regex-xmlschema",
          "partial": "Dot",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-xmlschema/docs/Text-Regex-XMLSchema-String-Regex.html#v:mkDot"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003econstruct the r.e. for r1{|}r2 (r1 orElse r2).\n\u003c/p\u003e\u003cp\u003eThis represents the same r.e. as r1|r2, but when\n collecting the results of subexpressions in (...) and r1 succeeds, the\n subexpressions of r2 are discarded, so r1 matches are prioritized\n\u003c/p\u003e\u003cp\u003eexample\n\u003c/p\u003e\u003cpre\u003e splitSubex \"({1}x)|({2}.)\"   \"x\" = ([(\"1\",\"x\"),(\"2\",\"x\")], \"\")\n\n splitSubex \"({1}x){|}({2}.)\" \"x\" = ([(\"1\",\"x\")], \"\")\n\u003c/pre\u003e",
          "module": "[\"Text.Regex.XMLSchema.String.Regex\",\"Text.Regex.XMLSchema.String\"]",
          "name": "mkElse",
          "package": "regex-xmlschema",
          "signature": "GenRegex l -\u003e GenRegex l -\u003e GenRegex l",
          "source": "src/Text-Regex-XMLSchema-String-Regex.html#mkElse",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/regex-xmlschema/docs/Text-Regex-XMLSchema-String-Regex.html#v:mkElse\",\"http://hackage.haskell.org/package/regex-xmlschema/docs/Text-Regex-XMLSchema-String.html#v:mkElse\"]"
        },
        "index": {
          "description": "construct the r.e for r1 r2 r1 orElse r2 This represents the same r.e as r1 r2 but when collecting the results of subexpressions in and r1 succeeds the subexpressions of r2 are discarded so r1 matches are prioritized example splitSubex splitSubex",
          "hierarchy": "Text Regex XMLSchema String Regex",
          "module": "Text.Regex.XMLSchema.String.Regex",
          "name": "mkElse",
          "normalized": "GenRegex a-\u003eGenRegex a-\u003eGenRegex a",
          "package": "regex-xmlschema",
          "partial": "Else",
          "signature": "GenRegex l-\u003eGenRegex l-\u003eGenRegex l",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-xmlschema/docs/Text-Regex-XMLSchema-String-Regex.html#v:mkElse"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstruct r.e. for exclusive or: r1 {^} r2\n\u003c/p\u003e\u003cp\u003eexample\n\u003c/p\u003e\u003cpre\u003e match \"[a-c]+{^}[c-d]+\" \"abc\"  = True\n match \"[a-c]+{^}[c-d]+\" \"acdc\" = False\n match \"[a-c]+{^}[c-d]+\" \"ccc\"  = False\n match \"[a-c]+{^}[c-d]+\" \"cdc\"  = True\n\u003c/pre\u003e",
          "module": "[\"Text.Regex.XMLSchema.String.Regex\",\"Text.Regex.XMLSchema.String\"]",
          "name": "mkExor",
          "package": "regex-xmlschema",
          "signature": "GenRegex l -\u003e GenRegex l -\u003e GenRegex l",
          "source": "src/Text-Regex-XMLSchema-String-Regex.html#mkExor",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/regex-xmlschema/docs/Text-Regex-XMLSchema-String-Regex.html#v:mkExor\",\"http://hackage.haskell.org/package/regex-xmlschema/docs/Text-Regex-XMLSchema-String.html#v:mkExor\"]"
        },
        "index": {
          "description": "Construct r.e for exclusive or r1 r2 example match a-c c-d abc True match a-c c-d acdc False match a-c c-d ccc False match a-c c-d cdc True",
          "hierarchy": "Text Regex XMLSchema String Regex",
          "module": "Text.Regex.XMLSchema.String.Regex",
          "name": "mkExor",
          "normalized": "GenRegex a-\u003eGenRegex a-\u003eGenRegex a",
          "package": "regex-xmlschema",
          "partial": "Exor",
          "signature": "GenRegex l-\u003eGenRegex l-\u003eGenRegex l",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-xmlschema/docs/Text-Regex-XMLSchema-String-Regex.html#v:mkExor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.XMLSchema.String.Regex",
          "name": "mkInterleave",
          "package": "regex-xmlschema",
          "signature": "GenRegex l -\u003e GenRegex l -\u003e GenRegex l",
          "source": "src/Text-Regex-XMLSchema-String-Regex.html#mkInterleave",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex XMLSchema String Regex",
          "module": "Text.Regex.XMLSchema.String.Regex",
          "name": "mkInterleave",
          "normalized": "GenRegex a-\u003eGenRegex a-\u003eGenRegex a",
          "package": "regex-xmlschema",
          "partial": "Interleave",
          "signature": "GenRegex l-\u003eGenRegex l-\u003eGenRegex l",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-xmlschema/docs/Text-Regex-XMLSchema-String-Regex.html#v:mkInterleave"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstruct r.e. for intersection: r1 {&} r2\n\u003c/p\u003e\u003cp\u003eexample\n\u003c/p\u003e\u003cpre\u003e match \".*a.*{&}.*b.*\" \"-a-b-\"  = True\n match \".*a.*{&}.*b.*\" \"-b-a-\"  = True\n match \".*a.*{&}.*b.*\" \"-a-a-\"  = False\n match \".*a.*{&}.*b.*\" \"---b-\"  = False\n\u003c/pre\u003e",
          "module": "[\"Text.Regex.XMLSchema.String.Regex\",\"Text.Regex.XMLSchema.String\"]",
          "name": "mkIsect",
          "package": "regex-xmlschema",
          "signature": "GenRegex l -\u003e GenRegex l -\u003e GenRegex l",
          "source": "src/Text-Regex-XMLSchema-String-Regex.html#mkIsect",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/regex-xmlschema/docs/Text-Regex-XMLSchema-String-Regex.html#v:mkIsect\",\"http://hackage.haskell.org/package/regex-xmlschema/docs/Text-Regex-XMLSchema-String.html#v:mkIsect\"]"
        },
        "index": {
          "description": "Construct r.e for intersection r1 r2 example match a-b True match b-a True match a-a False match False",
          "hierarchy": "Text Regex XMLSchema String Regex",
          "module": "Text.Regex.XMLSchema.String.Regex",
          "name": "mkIsect",
          "normalized": "GenRegex a-\u003eGenRegex a-\u003eGenRegex a",
          "package": "regex-xmlschema",
          "partial": "Isect",
          "signature": "GenRegex l-\u003eGenRegex l-\u003eGenRegex l",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-xmlschema/docs/Text-Regex-XMLSchema-String-Regex.html#v:mkIsect"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstruct option r?\n\u003c/p\u003e",
          "module": "[\"Text.Regex.XMLSchema.String.Regex\",\"Text.Regex.XMLSchema.String\"]",
          "name": "mkOpt",
          "package": "regex-xmlschema",
          "signature": "GenRegex l -\u003e GenRegex l",
          "source": "src/Text-Regex-XMLSchema-String-Regex.html#mkOpt",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/regex-xmlschema/docs/Text-Regex-XMLSchema-String-Regex.html#v:mkOpt\",\"http://hackage.haskell.org/package/regex-xmlschema/docs/Text-Regex-XMLSchema-String.html#v:mkOpt\"]"
        },
        "index": {
          "description": "Construct option",
          "hierarchy": "Text Regex XMLSchema String Regex",
          "module": "Text.Regex.XMLSchema.String.Regex",
          "name": "mkOpt",
          "normalized": "GenRegex a-\u003eGenRegex a",
          "package": "regex-xmlschema",
          "partial": "Opt",
          "signature": "GenRegex l-\u003eGenRegex l",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-xmlschema/docs/Text-Regex-XMLSchema-String-Regex.html#v:mkOpt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstruct repetition r{i,}\n\u003c/p\u003e",
          "module": "[\"Text.Regex.XMLSchema.String.Regex\",\"Text.Regex.XMLSchema.String\"]",
          "name": "mkRep",
          "package": "regex-xmlschema",
          "signature": "Int -\u003e GenRegex l -\u003e GenRegex l",
          "source": "src/Text-Regex-XMLSchema-String-Regex.html#mkRep",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/regex-xmlschema/docs/Text-Regex-XMLSchema-String-Regex.html#v:mkRep\",\"http://hackage.haskell.org/package/regex-xmlschema/docs/Text-Regex-XMLSchema-String.html#v:mkRep\"]"
        },
        "index": {
          "description": "Construct repetition",
          "hierarchy": "Text Regex XMLSchema String Regex",
          "module": "Text.Regex.XMLSchema.String.Regex",
          "name": "mkRep",
          "normalized": "Int-\u003eGenRegex a-\u003eGenRegex a",
          "package": "regex-xmlschema",
          "partial": "Rep",
          "signature": "Int-\u003eGenRegex l-\u003eGenRegex l",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-xmlschema/docs/Text-Regex-XMLSchema-String-Regex.html#v:mkRep"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstruct range r{i,j}\n\u003c/p\u003e",
          "module": "[\"Text.Regex.XMLSchema.String.Regex\",\"Text.Regex.XMLSchema.String\"]",
          "name": "mkRng",
          "package": "regex-xmlschema",
          "signature": "Int -\u003e Int -\u003e GenRegex l -\u003e GenRegex l",
          "source": "src/Text-Regex-XMLSchema-String-Regex.html#mkRng",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/regex-xmlschema/docs/Text-Regex-XMLSchema-String-Regex.html#v:mkRng\",\"http://hackage.haskell.org/package/regex-xmlschema/docs/Text-Regex-XMLSchema-String.html#v:mkRng\"]"
        },
        "index": {
          "description": "Construct range",
          "hierarchy": "Text Regex XMLSchema String Regex",
          "module": "Text.Regex.XMLSchema.String.Regex",
          "name": "mkRng",
          "normalized": "Int-\u003eInt-\u003eGenRegex a-\u003eGenRegex a",
          "package": "regex-xmlschema",
          "partial": "Rng",
          "signature": "Int-\u003eInt-\u003eGenRegex l-\u003eGenRegex l",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-xmlschema/docs/Text-Regex-XMLSchema-String-Regex.html#v:mkRng"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstruct the sequence r.e. r1.r2\n\u003c/p\u003e",
          "module": "[\"Text.Regex.XMLSchema.String.Regex\",\"Text.Regex.XMLSchema.String\"]",
          "name": "mkSeq",
          "package": "regex-xmlschema",
          "signature": "GenRegex l -\u003e GenRegex l -\u003e GenRegex l",
          "source": "src/Text-Regex-XMLSchema-String-Regex.html#mkSeq",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/regex-xmlschema/docs/Text-Regex-XMLSchema-String-Regex.html#v:mkSeq\",\"http://hackage.haskell.org/package/regex-xmlschema/docs/Text-Regex-XMLSchema-String.html#v:mkSeq\"]"
        },
        "index": {
          "description": "Construct the sequence r.e r1.r2",
          "hierarchy": "Text Regex XMLSchema String Regex",
          "module": "Text.Regex.XMLSchema.String.Regex",
          "name": "mkSeq",
          "normalized": "GenRegex a-\u003eGenRegex a-\u003eGenRegex a",
          "package": "regex-xmlschema",
          "partial": "Seq",
          "signature": "GenRegex l-\u003eGenRegex l-\u003eGenRegex l",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-xmlschema/docs/Text-Regex-XMLSchema-String-Regex.html#v:mkSeq"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003emkSeq extened to lists\n\u003c/p\u003e",
          "module": "[\"Text.Regex.XMLSchema.String.Regex\",\"Text.Regex.XMLSchema.String\"]",
          "name": "mkSeqs",
          "package": "regex-xmlschema",
          "signature": "[GenRegex l] -\u003e GenRegex l",
          "source": "src/Text-Regex-XMLSchema-String-Regex.html#mkSeqs",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/regex-xmlschema/docs/Text-Regex-XMLSchema-String-Regex.html#v:mkSeqs\",\"http://hackage.haskell.org/package/regex-xmlschema/docs/Text-Regex-XMLSchema-String.html#v:mkSeqs\"]"
        },
        "index": {
          "description": "mkSeq extened to lists",
          "hierarchy": "Text Regex XMLSchema String Regex",
          "module": "Text.Regex.XMLSchema.String.Regex",
          "name": "mkSeqs",
          "normalized": "[GenRegex a]-\u003eGenRegex a",
          "package": "regex-xmlschema",
          "partial": "Seqs",
          "signature": "[GenRegex l]-\u003eGenRegex l",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-xmlschema/docs/Text-Regex-XMLSchema-String-Regex.html#v:mkSeqs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003econstruct r.e. for r*\n\u003c/p\u003e",
          "module": "[\"Text.Regex.XMLSchema.String.Regex\",\"Text.Regex.XMLSchema.String\"]",
          "name": "mkStar",
          "package": "regex-xmlschema",
          "signature": "GenRegex l -\u003e GenRegex l",
          "source": "src/Text-Regex-XMLSchema-String-Regex.html#mkStar",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/regex-xmlschema/docs/Text-Regex-XMLSchema-String-Regex.html#v:mkStar\",\"http://hackage.haskell.org/package/regex-xmlschema/docs/Text-Regex-XMLSchema-String.html#v:mkStar\"]"
        },
        "index": {
          "description": "construct r.e for",
          "hierarchy": "Text Regex XMLSchema String Regex",
          "module": "Text.Regex.XMLSchema.String.Regex",
          "name": "mkStar",
          "normalized": "GenRegex a-\u003eGenRegex a",
          "package": "regex-xmlschema",
          "partial": "Star",
          "signature": "GenRegex l-\u003eGenRegex l",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-xmlschema/docs/Text-Regex-XMLSchema-String-Regex.html#v:mkStar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003econstruct the r.e. for a set of chars\n\u003c/p\u003e",
          "module": "Text.Regex.XMLSchema.String.Regex",
          "name": "mkSym",
          "package": "regex-xmlschema",
          "signature": "CharSet -\u003e GenRegex l",
          "source": "src/Text-Regex-XMLSchema-String-Regex.html#mkSym",
          "type": "function"
        },
        "index": {
          "description": "construct the r.e for set of chars",
          "hierarchy": "Text Regex XMLSchema String Regex",
          "module": "Text.Regex.XMLSchema.String.Regex",
          "name": "mkSym",
          "normalized": "CharSet-\u003eGenRegex a",
          "package": "regex-xmlschema",
          "partial": "Sym",
          "signature": "CharSet-\u003eGenRegex l",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-xmlschema/docs/Text-Regex-XMLSchema-String-Regex.html#v:mkSym"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003econstruct an r.e. for a single char set\n\u003c/p\u003e",
          "module": "[\"Text.Regex.XMLSchema.String.Regex\",\"Text.Regex.XMLSchema.String\"]",
          "name": "mkSym1",
          "package": "regex-xmlschema",
          "signature": "Char -\u003e GenRegex l",
          "source": "src/Text-Regex-XMLSchema-String-Regex.html#mkSym1",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/regex-xmlschema/docs/Text-Regex-XMLSchema-String-Regex.html#v:mkSym1\",\"http://hackage.haskell.org/package/regex-xmlschema/docs/Text-Regex-XMLSchema-String.html#v:mkSym1\"]"
        },
        "index": {
          "description": "construct an r.e for single char set",
          "hierarchy": "Text Regex XMLSchema String Regex",
          "module": "Text.Regex.XMLSchema.String.Regex",
          "name": "mkSym1",
          "normalized": "Char-\u003eGenRegex a",
          "package": "regex-xmlschema",
          "partial": "Sym",
          "signature": "Char-\u003eGenRegex l",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-xmlschema/docs/Text-Regex-XMLSchema-String-Regex.html#v:mkSym1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003econstruct an r.e. for an intervall of chars\n\u003c/p\u003e",
          "module": "[\"Text.Regex.XMLSchema.String.Regex\",\"Text.Regex.XMLSchema.String\"]",
          "name": "mkSymRng",
          "package": "regex-xmlschema",
          "signature": "Char -\u003e Char -\u003e GenRegex l",
          "source": "src/Text-Regex-XMLSchema-String-Regex.html#mkSymRng",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/regex-xmlschema/docs/Text-Regex-XMLSchema-String-Regex.html#v:mkSymRng\",\"http://hackage.haskell.org/package/regex-xmlschema/docs/Text-Regex-XMLSchema-String.html#v:mkSymRng\"]"
        },
        "index": {
          "description": "construct an r.e for an intervall of chars",
          "hierarchy": "Text Regex XMLSchema String Regex",
          "module": "Text.Regex.XMLSchema.String.Regex",
          "name": "mkSymRng",
          "normalized": "Char-\u003eChar-\u003eGenRegex a",
          "package": "regex-xmlschema",
          "partial": "Sym Rng",
          "signature": "Char-\u003eChar-\u003eGenRegex l",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-xmlschema/docs/Text-Regex-XMLSchema-String-Regex.html#v:mkSymRng"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003econstruct the r.e. for the set containing the empty word\n\u003c/p\u003e",
          "module": "[\"Text.Regex.XMLSchema.String.Regex\",\"Text.Regex.XMLSchema.String\"]",
          "name": "mkUnit",
          "package": "regex-xmlschema",
          "signature": "GenRegex l",
          "source": "src/Text-Regex-XMLSchema-String-Regex.html#mkUnit",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/regex-xmlschema/docs/Text-Regex-XMLSchema-String-Regex.html#v:mkUnit\",\"http://hackage.haskell.org/package/regex-xmlschema/docs/Text-Regex-XMLSchema-String.html#v:mkUnit\"]"
        },
        "index": {
          "description": "construct the r.e for the set containing the empty word",
          "hierarchy": "Text Regex XMLSchema String Regex",
          "module": "Text.Regex.XMLSchema.String.Regex",
          "name": "mkUnit",
          "package": "regex-xmlschema",
          "partial": "Unit",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-xmlschema/docs/Text-Regex-XMLSchema-String-Regex.html#v:mkUnit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003emkSym generaized for strings\n\u003c/p\u003e",
          "module": "[\"Text.Regex.XMLSchema.String.Regex\",\"Text.Regex.XMLSchema.String\"]",
          "name": "mkWord",
          "package": "regex-xmlschema",
          "signature": "[Char] -\u003e GenRegex l",
          "source": "src/Text-Regex-XMLSchema-String-Regex.html#mkWord",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/regex-xmlschema/docs/Text-Regex-XMLSchema-String-Regex.html#v:mkWord\",\"http://hackage.haskell.org/package/regex-xmlschema/docs/Text-Regex-XMLSchema-String.html#v:mkWord\"]"
        },
        "index": {
          "description": "mkSym generaized for strings",
          "hierarchy": "Text Regex XMLSchema String Regex",
          "module": "Text.Regex.XMLSchema.String.Regex",
          "name": "mkWord",
          "normalized": "[Char]-\u003eGenRegex a",
          "package": "regex-xmlschema",
          "partial": "Word",
          "signature": "[Char]-\u003eGenRegex l",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-xmlschema/docs/Text-Regex-XMLSchema-String-Regex.html#v:mkWord"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003econstruct the r.e. for the empty set.\n An (error-) message may be attached\n\u003c/p\u003e",
          "module": "[\"Text.Regex.XMLSchema.String.Regex\",\"Text.Regex.XMLSchema.String\"]",
          "name": "mkZero",
          "package": "regex-xmlschema",
          "signature": "String -\u003e GenRegex l",
          "source": "src/Text-Regex-XMLSchema-String-Regex.html#mkZero",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/regex-xmlschema/docs/Text-Regex-XMLSchema-String-Regex.html#v:mkZero\",\"http://hackage.haskell.org/package/regex-xmlschema/docs/Text-Regex-XMLSchema-String.html#v:mkZero\"]"
        },
        "index": {
          "description": "construct the r.e for the empty set An error message may be attached",
          "hierarchy": "Text Regex XMLSchema String Regex",
          "module": "Text.Regex.XMLSchema.String.Regex",
          "name": "mkZero",
          "normalized": "String-\u003eGenRegex a",
          "package": "regex-xmlschema",
          "partial": "Zero",
          "signature": "String-\u003eGenRegex l",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-xmlschema/docs/Text-Regex-XMLSchema-String-Regex.html#v:mkZero"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.XMLSchema.String.Regex",
          "name": "nullable",
          "package": "regex-xmlschema",
          "signature": "GenRegex l -\u003e Bool",
          "source": "src/Text-Regex-XMLSchema-String-Regex.html#nullable",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex XMLSchema String Regex",
          "module": "Text.Regex.XMLSchema.String.Regex",
          "name": "nullable",
          "normalized": "GenRegex a-\u003eBool",
          "package": "regex-xmlschema",
          "signature": "GenRegex l-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-xmlschema/docs/Text-Regex-XMLSchema-String-Regex.html#v:nullable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.XMLSchema.String.Regex",
          "name": "nullable'",
          "package": "regex-xmlschema",
          "signature": "GenRegex l -\u003e Nullable l",
          "source": "src/Text-Regex-XMLSchema-String-Regex.html#nullable%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex XMLSchema String Regex",
          "module": "Text.Regex.XMLSchema.String.Regex",
          "name": "nullable'",
          "normalized": "GenRegex a-\u003eNullable a",
          "package": "regex-xmlschema",
          "signature": "GenRegex l-\u003eNullable l",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-xmlschema/docs/Text-Regex-XMLSchema-String-Regex.html#v:nullable-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function wraps the whole regex in a subexpression before starting\n the parse. This is done for getting acces to\n the whole parsed string. Therfore we need one special label, this label\n is the Nothing value, all explicit labels are Just labels.\n\u003c/p\u003e",
          "module": "Text.Regex.XMLSchema.String.Regex",
          "name": "splitWithRegex",
          "package": "regex-xmlschema",
          "signature": "GenRegex l -\u003e String -\u003e Maybe ([(Label l, String)], String)",
          "source": "src/Text-Regex-XMLSchema-String-Regex.html#splitWithRegex",
          "type": "function"
        },
        "index": {
          "description": "This function wraps the whole regex in subexpression before starting the parse This is done for getting acces to the whole parsed string Therfore we need one special label this label is the Nothing value all explicit labels are Just labels",
          "hierarchy": "Text Regex XMLSchema String Regex",
          "module": "Text.Regex.XMLSchema.String.Regex",
          "name": "splitWithRegex",
          "normalized": "GenRegex a-\u003eString-\u003eMaybe([(Label a,String)],String)",
          "package": "regex-xmlschema",
          "partial": "With Regex",
          "signature": "GenRegex l-\u003eString-\u003eMaybe([(Label l,String)],String)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-xmlschema/docs/Text-Regex-XMLSchema-String-Regex.html#v:splitWithRegex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe main scanner function\n\u003c/p\u003e",
          "module": "Text.Regex.XMLSchema.String.Regex",
          "name": "splitWithRegex'",
          "package": "regex-xmlschema",
          "signature": "GenRegex l -\u003e String -\u003e Maybe (GenRegex l, String)",
          "source": "src/Text-Regex-XMLSchema-String-Regex.html#splitWithRegex%27",
          "type": "function"
        },
        "index": {
          "description": "The main scanner function",
          "hierarchy": "Text Regex XMLSchema String Regex",
          "module": "Text.Regex.XMLSchema.String.Regex",
          "name": "splitWithRegex'",
          "normalized": "GenRegex a-\u003eString-\u003eMaybe(GenRegex a,String)",
          "package": "regex-xmlschema",
          "partial": "With Regex'",
          "signature": "GenRegex l-\u003eString-\u003eMaybe(GenRegex l,String)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-xmlschema/docs/Text-Regex-XMLSchema-String-Regex.html#v:splitWithRegex-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.XMLSchema.String.Regex",
          "name": "splitWithRegexCS",
          "package": "regex-xmlschema",
          "signature": "GenRegex l -\u003e CharSet -\u003e String -\u003e Maybe ([(Label l, String)], String)",
          "source": "src/Text-Regex-XMLSchema-String-Regex.html#splitWithRegexCS",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex XMLSchema String Regex",
          "module": "Text.Regex.XMLSchema.String.Regex",
          "name": "splitWithRegexCS",
          "normalized": "GenRegex a-\u003eCharSet-\u003eString-\u003eMaybe([(Label a,String)],String)",
          "package": "regex-xmlschema",
          "partial": "With Regex CS",
          "signature": "GenRegex l-\u003eCharSet-\u003eString-\u003eMaybe([(Label l,String)],String)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-xmlschema/docs/Text-Regex-XMLSchema-String-Regex.html#v:splitWithRegexCS"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003espeedup version for splitWithRegex'\n\u003c/p\u003e\u003cp\u003eThis function checks whether the input starts with a char from FIRST re.\n If this is not the case, the split fails. The FIRST set can be computed once\n for a whole tokenizer and reused by every call of split\n\u003c/p\u003e",
          "module": "Text.Regex.XMLSchema.String.Regex",
          "name": "splitWithRegexCS'",
          "package": "regex-xmlschema",
          "signature": "GenRegex l -\u003e CharSet -\u003e String -\u003e Maybe (GenRegex l, String)",
          "source": "src/Text-Regex-XMLSchema-String-Regex.html#splitWithRegexCS%27",
          "type": "function"
        },
        "index": {
          "description": "speedup version for splitWithRegex This function checks whether the input starts with char from FIRST re If this is not the case the split fails The FIRST set can be computed once for whole tokenizer and reused by every call of split",
          "hierarchy": "Text Regex XMLSchema String Regex",
          "module": "Text.Regex.XMLSchema.String.Regex",
          "name": "splitWithRegexCS'",
          "normalized": "GenRegex a-\u003eCharSet-\u003eString-\u003eMaybe(GenRegex a,String)",
          "package": "regex-xmlschema",
          "partial": "With Regex CS'",
          "signature": "GenRegex l-\u003eCharSet-\u003eString-\u003eMaybe(GenRegex l,String)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-xmlschema/docs/Text-Regex-XMLSchema-String-Regex.html#v:splitWithRegexCS-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eW3C XML Schema Regular Expression Parser\n\u003c/p\u003e\u003cp\u003eThis parser supports the full W3C standard, the\n   complete grammar can be found under \u003ca\u003ehttp://www.w3.org/TR/xmlschema11-2/#regexs\u003c/a\u003e\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Text.Regex.XMLSchema.String.RegexParser",
          "name": "RegexParser",
          "package": "regex-xmlschema",
          "source": "src/Text-Regex-XMLSchema-String-RegexParser.html",
          "type": "module"
        },
        "index": {
          "description": "W3C XML Schema Regular Expression Parser This parser supports the full W3C standard the complete grammar can be found under http www.w3.org TR xmlschema11-2 regexs",
          "hierarchy": "Text Regex XMLSchema String RegexParser",
          "module": "Text.Regex.XMLSchema.String.RegexParser",
          "name": "RegexParser",
          "package": "regex-xmlschema",
          "partial": "Regex Parser",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/regex-xmlschema/docs/Text-Regex-XMLSchema-String-RegexParser.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eparse a W3C XML Schema regular expression\n\u003c/p\u003e\u003cp\u003ethe Syntax of the W3C XML Schema spec is extended by\n further useful set operations, like intersection, difference, exor.\n Subexpression match becomes possible with \"named\" pairs of parentheses.\n The multi char escape sequence \\a represents any Unicode char,\n The multi char escape sequence \\A represents any Unicode word, (\\A = \\a*).\n All syntactically wrong inputs are mapped to the Zero expression representing the\n empty set of words. Zero contains as data field a string for an error message.\n So error checking after parsing becomes possible by checking against Zero (\u003ccode\u003e\u003ca\u003eisZero\u003c/a\u003e\u003c/code\u003e predicate)\n\u003c/p\u003e",
          "module": "[\"Text.Regex.XMLSchema.String.RegexParser\",\"Text.Regex.XMLSchema.String\"]",
          "name": "parseRegex",
          "package": "regex-xmlschema",
          "signature": "String -\u003e Regex",
          "source": "src/Text-Regex-XMLSchema-String-RegexParser.html#parseRegex",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/regex-xmlschema/docs/Text-Regex-XMLSchema-String-RegexParser.html#v:parseRegex\",\"http://hackage.haskell.org/package/regex-xmlschema/docs/Text-Regex-XMLSchema-String.html#v:parseRegex\"]"
        },
        "index": {
          "description": "parse W3C XML Schema regular expression the Syntax of the W3C XML Schema spec is extended by further useful set operations like intersection difference exor Subexpression match becomes possible with named pairs of parentheses The multi char escape sequence represents any Unicode char The multi char escape sequence represents any Unicode word All syntactically wrong inputs are mapped to the Zero expression representing the empty set of words Zero contains as data field string for an error message So error checking after parsing becomes possible by checking against Zero isZero predicate",
          "hierarchy": "Text Regex XMLSchema String RegexParser",
          "module": "Text.Regex.XMLSchema.String.RegexParser",
          "name": "parseRegex",
          "normalized": "String-\u003eRegex",
          "package": "regex-xmlschema",
          "partial": "Regex",
          "signature": "String-\u003eRegex",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-xmlschema/docs/Text-Regex-XMLSchema-String-RegexParser.html#v:parseRegex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eUnicode Code Blocks\n\u003c/p\u003e\u003cp\u003edon't edit this module\n   it's generated from 'http:\\/\\/www.unicode.org\\/Public\\/UNIDATA\\/Blocks.txt'\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Text.Regex.XMLSchema.String.Unicode.Blocks",
          "name": "Blocks",
          "package": "regex-xmlschema",
          "source": "src/Text-Regex-XMLSchema-String-Unicode-Blocks.html",
          "type": "module"
        },
        "index": {
          "description": "Unicode Code Blocks don edit this module it generated from http www.unicode.org Public UNIDATA Blocks.txt",
          "hierarchy": "Text Regex XMLSchema String Unicode Blocks",
          "module": "Text.Regex.XMLSchema.String.Unicode.Blocks",
          "name": "Blocks",
          "package": "regex-xmlschema",
          "partial": "Blocks",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/regex-xmlschema/docs/Text-Regex-XMLSchema-String-Unicode-Blocks.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.XMLSchema.String.Unicode.Blocks",
          "name": "codeBlocks",
          "package": "regex-xmlschema",
          "signature": "[(String, (Char, Char))]",
          "source": "src/Text-Regex-XMLSchema-String-Unicode-Blocks.html#codeBlocks",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex XMLSchema String Unicode Blocks",
          "module": "Text.Regex.XMLSchema.String.Unicode.Blocks",
          "name": "codeBlocks",
          "normalized": "[(String,(Char,Char))]",
          "package": "regex-xmlschema",
          "partial": "Blocks",
          "signature": "[(String,(Char,Char))]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-xmlschema/docs/Text-Regex-XMLSchema-String-Unicode-Blocks.html#v:codeBlocks"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eUnicode character properties\n\u003c/p\u003e\u003cp\u003edon't edit this module\n   it's generated from 'http:\\/\\/www.unicode.org\\/Public\\/UNIDATA\\/UnicodeData.txt'\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Text.Regex.XMLSchema.String.Unicode.CharProps",
          "name": "CharProps",
          "package": "regex-xmlschema",
          "source": "src/Text-Regex-XMLSchema-String-Unicode-CharProps.html",
          "type": "module"
        },
        "index": {
          "description": "Unicode character properties don edit this module it generated from http www.unicode.org Public UNIDATA UnicodeData.txt",
          "hierarchy": "Text Regex XMLSchema String Unicode CharProps",
          "module": "Text.Regex.XMLSchema.String.Unicode.CharProps",
          "name": "CharProps",
          "package": "regex-xmlschema",
          "partial": "Char Props",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/regex-xmlschema/docs/Text-Regex-XMLSchema-String-Unicode-CharProps.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.XMLSchema.String.Unicode.CharProps",
          "name": "isUnicodeC",
          "package": "regex-xmlschema",
          "signature": "CharSet",
          "source": "src/Text-Regex-XMLSchema-String-Unicode-CharProps.html#isUnicodeC",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex XMLSchema String Unicode CharProps",
          "module": "Text.Regex.XMLSchema.String.Unicode.CharProps",
          "name": "isUnicodeC",
          "package": "regex-xmlschema",
          "partial": "Unicode",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-xmlschema/docs/Text-Regex-XMLSchema-String-Unicode-CharProps.html#v:isUnicodeC"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.XMLSchema.String.Unicode.CharProps",
          "name": "isUnicodeCc",
          "package": "regex-xmlschema",
          "signature": "CharSet",
          "source": "src/Text-Regex-XMLSchema-String-Unicode-CharProps.html#isUnicodeCc",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex XMLSchema String Unicode CharProps",
          "module": "Text.Regex.XMLSchema.String.Unicode.CharProps",
          "name": "isUnicodeCc",
          "package": "regex-xmlschema",
          "partial": "Unicode Cc",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-xmlschema/docs/Text-Regex-XMLSchema-String-Unicode-CharProps.html#v:isUnicodeCc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.XMLSchema.String.Unicode.CharProps",
          "name": "isUnicodeCf",
          "package": "regex-xmlschema",
          "signature": "CharSet",
          "source": "src/Text-Regex-XMLSchema-String-Unicode-CharProps.html#isUnicodeCf",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex XMLSchema String Unicode CharProps",
          "module": "Text.Regex.XMLSchema.String.Unicode.CharProps",
          "name": "isUnicodeCf",
          "package": "regex-xmlschema",
          "partial": "Unicode Cf",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-xmlschema/docs/Text-Regex-XMLSchema-String-Unicode-CharProps.html#v:isUnicodeCf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.XMLSchema.String.Unicode.CharProps",
          "name": "isUnicodeCo",
          "package": "regex-xmlschema",
          "signature": "CharSet",
          "source": "src/Text-Regex-XMLSchema-String-Unicode-CharProps.html#isUnicodeCo",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex XMLSchema String Unicode CharProps",
          "module": "Text.Regex.XMLSchema.String.Unicode.CharProps",
          "name": "isUnicodeCo",
          "package": "regex-xmlschema",
          "partial": "Unicode Co",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-xmlschema/docs/Text-Regex-XMLSchema-String-Unicode-CharProps.html#v:isUnicodeCo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.XMLSchema.String.Unicode.CharProps",
          "name": "isUnicodeCs",
          "package": "regex-xmlschema",
          "signature": "CharSet",
          "source": "src/Text-Regex-XMLSchema-String-Unicode-CharProps.html#isUnicodeCs",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex XMLSchema String Unicode CharProps",
          "module": "Text.Regex.XMLSchema.String.Unicode.CharProps",
          "name": "isUnicodeCs",
          "package": "regex-xmlschema",
          "partial": "Unicode Cs",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-xmlschema/docs/Text-Regex-XMLSchema-String-Unicode-CharProps.html#v:isUnicodeCs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.XMLSchema.String.Unicode.CharProps",
          "name": "isUnicodeL",
          "package": "regex-xmlschema",
          "signature": "CharSet",
          "source": "src/Text-Regex-XMLSchema-String-Unicode-CharProps.html#isUnicodeL",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex XMLSchema String Unicode CharProps",
          "module": "Text.Regex.XMLSchema.String.Unicode.CharProps",
          "name": "isUnicodeL",
          "package": "regex-xmlschema",
          "partial": "Unicode",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-xmlschema/docs/Text-Regex-XMLSchema-String-Unicode-CharProps.html#v:isUnicodeL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.XMLSchema.String.Unicode.CharProps",
          "name": "isUnicodeLl",
          "package": "regex-xmlschema",
          "signature": "CharSet",
          "source": "src/Text-Regex-XMLSchema-String-Unicode-CharProps.html#isUnicodeLl",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex XMLSchema String Unicode CharProps",
          "module": "Text.Regex.XMLSchema.String.Unicode.CharProps",
          "name": "isUnicodeLl",
          "package": "regex-xmlschema",
          "partial": "Unicode Ll",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-xmlschema/docs/Text-Regex-XMLSchema-String-Unicode-CharProps.html#v:isUnicodeLl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.XMLSchema.String.Unicode.CharProps",
          "name": "isUnicodeLm",
          "package": "regex-xmlschema",
          "signature": "CharSet",
          "source": "src/Text-Regex-XMLSchema-String-Unicode-CharProps.html#isUnicodeLm",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex XMLSchema String Unicode CharProps",
          "module": "Text.Regex.XMLSchema.String.Unicode.CharProps",
          "name": "isUnicodeLm",
          "package": "regex-xmlschema",
          "partial": "Unicode Lm",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-xmlschema/docs/Text-Regex-XMLSchema-String-Unicode-CharProps.html#v:isUnicodeLm"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.XMLSchema.String.Unicode.CharProps",
          "name": "isUnicodeLo",
          "package": "regex-xmlschema",
          "signature": "CharSet",
          "source": "src/Text-Regex-XMLSchema-String-Unicode-CharProps.html#isUnicodeLo",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex XMLSchema String Unicode CharProps",
          "module": "Text.Regex.XMLSchema.String.Unicode.CharProps",
          "name": "isUnicodeLo",
          "package": "regex-xmlschema",
          "partial": "Unicode Lo",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-xmlschema/docs/Text-Regex-XMLSchema-String-Unicode-CharProps.html#v:isUnicodeLo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.XMLSchema.String.Unicode.CharProps",
          "name": "isUnicodeLt",
          "package": "regex-xmlschema",
          "signature": "CharSet",
          "source": "src/Text-Regex-XMLSchema-String-Unicode-CharProps.html#isUnicodeLt",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex XMLSchema String Unicode CharProps",
          "module": "Text.Regex.XMLSchema.String.Unicode.CharProps",
          "name": "isUnicodeLt",
          "package": "regex-xmlschema",
          "partial": "Unicode Lt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-xmlschema/docs/Text-Regex-XMLSchema-String-Unicode-CharProps.html#v:isUnicodeLt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.XMLSchema.String.Unicode.CharProps",
          "name": "isUnicodeLu",
          "package": "regex-xmlschema",
          "signature": "CharSet",
          "source": "src/Text-Regex-XMLSchema-String-Unicode-CharProps.html#isUnicodeLu",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex XMLSchema String Unicode CharProps",
          "module": "Text.Regex.XMLSchema.String.Unicode.CharProps",
          "name": "isUnicodeLu",
          "package": "regex-xmlschema",
          "partial": "Unicode Lu",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-xmlschema/docs/Text-Regex-XMLSchema-String-Unicode-CharProps.html#v:isUnicodeLu"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.XMLSchema.String.Unicode.CharProps",
          "name": "isUnicodeM",
          "package": "regex-xmlschema",
          "signature": "CharSet",
          "source": "src/Text-Regex-XMLSchema-String-Unicode-CharProps.html#isUnicodeM",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex XMLSchema String Unicode CharProps",
          "module": "Text.Regex.XMLSchema.String.Unicode.CharProps",
          "name": "isUnicodeM",
          "package": "regex-xmlschema",
          "partial": "Unicode",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-xmlschema/docs/Text-Regex-XMLSchema-String-Unicode-CharProps.html#v:isUnicodeM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.XMLSchema.String.Unicode.CharProps",
          "name": "isUnicodeMc",
          "package": "regex-xmlschema",
          "signature": "CharSet",
          "source": "src/Text-Regex-XMLSchema-String-Unicode-CharProps.html#isUnicodeMc",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex XMLSchema String Unicode CharProps",
          "module": "Text.Regex.XMLSchema.String.Unicode.CharProps",
          "name": "isUnicodeMc",
          "package": "regex-xmlschema",
          "partial": "Unicode Mc",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-xmlschema/docs/Text-Regex-XMLSchema-String-Unicode-CharProps.html#v:isUnicodeMc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.XMLSchema.String.Unicode.CharProps",
          "name": "isUnicodeMe",
          "package": "regex-xmlschema",
          "signature": "CharSet",
          "source": "src/Text-Regex-XMLSchema-String-Unicode-CharProps.html#isUnicodeMe",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex XMLSchema String Unicode CharProps",
          "module": "Text.Regex.XMLSchema.String.Unicode.CharProps",
          "name": "isUnicodeMe",
          "package": "regex-xmlschema",
          "partial": "Unicode Me",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-xmlschema/docs/Text-Regex-XMLSchema-String-Unicode-CharProps.html#v:isUnicodeMe"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.XMLSchema.String.Unicode.CharProps",
          "name": "isUnicodeMn",
          "package": "regex-xmlschema",
          "signature": "CharSet",
          "source": "src/Text-Regex-XMLSchema-String-Unicode-CharProps.html#isUnicodeMn",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex XMLSchema String Unicode CharProps",
          "module": "Text.Regex.XMLSchema.String.Unicode.CharProps",
          "name": "isUnicodeMn",
          "package": "regex-xmlschema",
          "partial": "Unicode Mn",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-xmlschema/docs/Text-Regex-XMLSchema-String-Unicode-CharProps.html#v:isUnicodeMn"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.XMLSchema.String.Unicode.CharProps",
          "name": "isUnicodeN",
          "package": "regex-xmlschema",
          "signature": "CharSet",
          "source": "src/Text-Regex-XMLSchema-String-Unicode-CharProps.html#isUnicodeN",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex XMLSchema String Unicode CharProps",
          "module": "Text.Regex.XMLSchema.String.Unicode.CharProps",
          "name": "isUnicodeN",
          "package": "regex-xmlschema",
          "partial": "Unicode",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-xmlschema/docs/Text-Regex-XMLSchema-String-Unicode-CharProps.html#v:isUnicodeN"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.XMLSchema.String.Unicode.CharProps",
          "name": "isUnicodeNd",
          "package": "regex-xmlschema",
          "signature": "CharSet",
          "source": "src/Text-Regex-XMLSchema-String-Unicode-CharProps.html#isUnicodeNd",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex XMLSchema String Unicode CharProps",
          "module": "Text.Regex.XMLSchema.String.Unicode.CharProps",
          "name": "isUnicodeNd",
          "package": "regex-xmlschema",
          "partial": "Unicode Nd",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-xmlschema/docs/Text-Regex-XMLSchema-String-Unicode-CharProps.html#v:isUnicodeNd"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.XMLSchema.String.Unicode.CharProps",
          "name": "isUnicodeNl",
          "package": "regex-xmlschema",
          "signature": "CharSet",
          "source": "src/Text-Regex-XMLSchema-String-Unicode-CharProps.html#isUnicodeNl",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex XMLSchema String Unicode CharProps",
          "module": "Text.Regex.XMLSchema.String.Unicode.CharProps",
          "name": "isUnicodeNl",
          "package": "regex-xmlschema",
          "partial": "Unicode Nl",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-xmlschema/docs/Text-Regex-XMLSchema-String-Unicode-CharProps.html#v:isUnicodeNl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.XMLSchema.String.Unicode.CharProps",
          "name": "isUnicodeNo",
          "package": "regex-xmlschema",
          "signature": "CharSet",
          "source": "src/Text-Regex-XMLSchema-String-Unicode-CharProps.html#isUnicodeNo",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex XMLSchema String Unicode CharProps",
          "module": "Text.Regex.XMLSchema.String.Unicode.CharProps",
          "name": "isUnicodeNo",
          "package": "regex-xmlschema",
          "partial": "Unicode No",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-xmlschema/docs/Text-Regex-XMLSchema-String-Unicode-CharProps.html#v:isUnicodeNo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.XMLSchema.String.Unicode.CharProps",
          "name": "isUnicodeP",
          "package": "regex-xmlschema",
          "signature": "CharSet",
          "source": "src/Text-Regex-XMLSchema-String-Unicode-CharProps.html#isUnicodeP",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex XMLSchema String Unicode CharProps",
          "module": "Text.Regex.XMLSchema.String.Unicode.CharProps",
          "name": "isUnicodeP",
          "package": "regex-xmlschema",
          "partial": "Unicode",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-xmlschema/docs/Text-Regex-XMLSchema-String-Unicode-CharProps.html#v:isUnicodeP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.XMLSchema.String.Unicode.CharProps",
          "name": "isUnicodePc",
          "package": "regex-xmlschema",
          "signature": "CharSet",
          "source": "src/Text-Regex-XMLSchema-String-Unicode-CharProps.html#isUnicodePc",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex XMLSchema String Unicode CharProps",
          "module": "Text.Regex.XMLSchema.String.Unicode.CharProps",
          "name": "isUnicodePc",
          "package": "regex-xmlschema",
          "partial": "Unicode Pc",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-xmlschema/docs/Text-Regex-XMLSchema-String-Unicode-CharProps.html#v:isUnicodePc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.XMLSchema.String.Unicode.CharProps",
          "name": "isUnicodePd",
          "package": "regex-xmlschema",
          "signature": "CharSet",
          "source": "src/Text-Regex-XMLSchema-String-Unicode-CharProps.html#isUnicodePd",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex XMLSchema String Unicode CharProps",
          "module": "Text.Regex.XMLSchema.String.Unicode.CharProps",
          "name": "isUnicodePd",
          "package": "regex-xmlschema",
          "partial": "Unicode Pd",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-xmlschema/docs/Text-Regex-XMLSchema-String-Unicode-CharProps.html#v:isUnicodePd"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.XMLSchema.String.Unicode.CharProps",
          "name": "isUnicodePe",
          "package": "regex-xmlschema",
          "signature": "CharSet",
          "source": "src/Text-Regex-XMLSchema-String-Unicode-CharProps.html#isUnicodePe",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex XMLSchema String Unicode CharProps",
          "module": "Text.Regex.XMLSchema.String.Unicode.CharProps",
          "name": "isUnicodePe",
          "package": "regex-xmlschema",
          "partial": "Unicode Pe",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-xmlschema/docs/Text-Regex-XMLSchema-String-Unicode-CharProps.html#v:isUnicodePe"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.XMLSchema.String.Unicode.CharProps",
          "name": "isUnicodePf",
          "package": "regex-xmlschema",
          "signature": "CharSet",
          "source": "src/Text-Regex-XMLSchema-String-Unicode-CharProps.html#isUnicodePf",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex XMLSchema String Unicode CharProps",
          "module": "Text.Regex.XMLSchema.String.Unicode.CharProps",
          "name": "isUnicodePf",
          "package": "regex-xmlschema",
          "partial": "Unicode Pf",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-xmlschema/docs/Text-Regex-XMLSchema-String-Unicode-CharProps.html#v:isUnicodePf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.XMLSchema.String.Unicode.CharProps",
          "name": "isUnicodePi",
          "package": "regex-xmlschema",
          "signature": "CharSet",
          "source": "src/Text-Regex-XMLSchema-String-Unicode-CharProps.html#isUnicodePi",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex XMLSchema String Unicode CharProps",
          "module": "Text.Regex.XMLSchema.String.Unicode.CharProps",
          "name": "isUnicodePi",
          "package": "regex-xmlschema",
          "partial": "Unicode Pi",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-xmlschema/docs/Text-Regex-XMLSchema-String-Unicode-CharProps.html#v:isUnicodePi"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.XMLSchema.String.Unicode.CharProps",
          "name": "isUnicodePo",
          "package": "regex-xmlschema",
          "signature": "CharSet",
          "source": "src/Text-Regex-XMLSchema-String-Unicode-CharProps.html#isUnicodePo",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex XMLSchema String Unicode CharProps",
          "module": "Text.Regex.XMLSchema.String.Unicode.CharProps",
          "name": "isUnicodePo",
          "package": "regex-xmlschema",
          "partial": "Unicode Po",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-xmlschema/docs/Text-Regex-XMLSchema-String-Unicode-CharProps.html#v:isUnicodePo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.XMLSchema.String.Unicode.CharProps",
          "name": "isUnicodePs",
          "package": "regex-xmlschema",
          "signature": "CharSet",
          "source": "src/Text-Regex-XMLSchema-String-Unicode-CharProps.html#isUnicodePs",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex XMLSchema String Unicode CharProps",
          "module": "Text.Regex.XMLSchema.String.Unicode.CharProps",
          "name": "isUnicodePs",
          "package": "regex-xmlschema",
          "partial": "Unicode Ps",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-xmlschema/docs/Text-Regex-XMLSchema-String-Unicode-CharProps.html#v:isUnicodePs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.XMLSchema.String.Unicode.CharProps",
          "name": "isUnicodeS",
          "package": "regex-xmlschema",
          "signature": "CharSet",
          "source": "src/Text-Regex-XMLSchema-String-Unicode-CharProps.html#isUnicodeS",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex XMLSchema String Unicode CharProps",
          "module": "Text.Regex.XMLSchema.String.Unicode.CharProps",
          "name": "isUnicodeS",
          "package": "regex-xmlschema",
          "partial": "Unicode",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-xmlschema/docs/Text-Regex-XMLSchema-String-Unicode-CharProps.html#v:isUnicodeS"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.XMLSchema.String.Unicode.CharProps",
          "name": "isUnicodeSc",
          "package": "regex-xmlschema",
          "signature": "CharSet",
          "source": "src/Text-Regex-XMLSchema-String-Unicode-CharProps.html#isUnicodeSc",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex XMLSchema String Unicode CharProps",
          "module": "Text.Regex.XMLSchema.String.Unicode.CharProps",
          "name": "isUnicodeSc",
          "package": "regex-xmlschema",
          "partial": "Unicode Sc",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-xmlschema/docs/Text-Regex-XMLSchema-String-Unicode-CharProps.html#v:isUnicodeSc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.XMLSchema.String.Unicode.CharProps",
          "name": "isUnicodeSk",
          "package": "regex-xmlschema",
          "signature": "CharSet",
          "source": "src/Text-Regex-XMLSchema-String-Unicode-CharProps.html#isUnicodeSk",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex XMLSchema String Unicode CharProps",
          "module": "Text.Regex.XMLSchema.String.Unicode.CharProps",
          "name": "isUnicodeSk",
          "package": "regex-xmlschema",
          "partial": "Unicode Sk",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-xmlschema/docs/Text-Regex-XMLSchema-String-Unicode-CharProps.html#v:isUnicodeSk"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.XMLSchema.String.Unicode.CharProps",
          "name": "isUnicodeSm",
          "package": "regex-xmlschema",
          "signature": "CharSet",
          "source": "src/Text-Regex-XMLSchema-String-Unicode-CharProps.html#isUnicodeSm",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex XMLSchema String Unicode CharProps",
          "module": "Text.Regex.XMLSchema.String.Unicode.CharProps",
          "name": "isUnicodeSm",
          "package": "regex-xmlschema",
          "partial": "Unicode Sm",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-xmlschema/docs/Text-Regex-XMLSchema-String-Unicode-CharProps.html#v:isUnicodeSm"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.XMLSchema.String.Unicode.CharProps",
          "name": "isUnicodeSo",
          "package": "regex-xmlschema",
          "signature": "CharSet",
          "source": "src/Text-Regex-XMLSchema-String-Unicode-CharProps.html#isUnicodeSo",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex XMLSchema String Unicode CharProps",
          "module": "Text.Regex.XMLSchema.String.Unicode.CharProps",
          "name": "isUnicodeSo",
          "package": "regex-xmlschema",
          "partial": "Unicode So",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-xmlschema/docs/Text-Regex-XMLSchema-String-Unicode-CharProps.html#v:isUnicodeSo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.XMLSchema.String.Unicode.CharProps",
          "name": "isUnicodeZ",
          "package": "regex-xmlschema",
          "signature": "CharSet",
          "source": "src/Text-Regex-XMLSchema-String-Unicode-CharProps.html#isUnicodeZ",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex XMLSchema String Unicode CharProps",
          "module": "Text.Regex.XMLSchema.String.Unicode.CharProps",
          "name": "isUnicodeZ",
          "package": "regex-xmlschema",
          "partial": "Unicode",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-xmlschema/docs/Text-Regex-XMLSchema-String-Unicode-CharProps.html#v:isUnicodeZ"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.XMLSchema.String.Unicode.CharProps",
          "name": "isUnicodeZl",
          "package": "regex-xmlschema",
          "signature": "CharSet",
          "source": "src/Text-Regex-XMLSchema-String-Unicode-CharProps.html#isUnicodeZl",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex XMLSchema String Unicode CharProps",
          "module": "Text.Regex.XMLSchema.String.Unicode.CharProps",
          "name": "isUnicodeZl",
          "package": "regex-xmlschema",
          "partial": "Unicode Zl",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-xmlschema/docs/Text-Regex-XMLSchema-String-Unicode-CharProps.html#v:isUnicodeZl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.XMLSchema.String.Unicode.CharProps",
          "name": "isUnicodeZp",
          "package": "regex-xmlschema",
          "signature": "CharSet",
          "source": "src/Text-Regex-XMLSchema-String-Unicode-CharProps.html#isUnicodeZp",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex XMLSchema String Unicode CharProps",
          "module": "Text.Regex.XMLSchema.String.Unicode.CharProps",
          "name": "isUnicodeZp",
          "package": "regex-xmlschema",
          "partial": "Unicode Zp",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-xmlschema/docs/Text-Regex-XMLSchema-String-Unicode-CharProps.html#v:isUnicodeZp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.XMLSchema.String.Unicode.CharProps",
          "name": "isUnicodeZs",
          "package": "regex-xmlschema",
          "signature": "CharSet",
          "source": "src/Text-Regex-XMLSchema-String-Unicode-CharProps.html#isUnicodeZs",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex XMLSchema String Unicode CharProps",
          "module": "Text.Regex.XMLSchema.String.Unicode.CharProps",
          "name": "isUnicodeZs",
          "package": "regex-xmlschema",
          "partial": "Unicode Zs",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-xmlschema/docs/Text-Regex-XMLSchema-String-Unicode-CharProps.html#v:isUnicodeZs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eXML character properties\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Text.Regex.XMLSchema.String.XML.CharProps",
          "name": "CharProps",
          "package": "regex-xmlschema",
          "source": "src/Text-Regex-XMLSchema-String-XML-CharProps.html",
          "type": "module"
        },
        "index": {
          "description": "XML character properties",
          "hierarchy": "Text Regex XMLSchema String XML CharProps",
          "module": "Text.Regex.XMLSchema.String.XML.CharProps",
          "name": "CharProps",
          "package": "regex-xmlschema",
          "partial": "Char Props",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/regex-xmlschema/docs/Text-Regex-XMLSchema-String-XML-CharProps.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003echecking for XML1.1 space character: additional space 0x85 and 0x2028\n\u003c/p\u003e\u003cp\u003esee also : \u003ccode\u003e\u003ca\u003eisXmlSpaceChar\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Text.Regex.XMLSchema.String.XML.CharProps",
          "name": "isXml11SpaceChar",
          "package": "regex-xmlschema",
          "signature": "CharSet",
          "source": "src/Text-Regex-XMLSchema-String-XML-CharProps.html#isXml11SpaceChar",
          "type": "function"
        },
        "index": {
          "description": "checking for XML1.1 space character additional space x85 and x2028 see also isXmlSpaceChar",
          "hierarchy": "Text Regex XMLSchema String XML CharProps",
          "module": "Text.Regex.XMLSchema.String.XML.CharProps",
          "name": "isXml11SpaceChar",
          "package": "regex-xmlschema",
          "partial": "Xml Space Char",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-xmlschema/docs/Text-Regex-XMLSchema-String-XML-CharProps.html#v:isXml11SpaceChar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003echecking for XML base charater\n\u003c/p\u003e",
          "module": "Text.Regex.XMLSchema.String.XML.CharProps",
          "name": "isXmlBaseChar",
          "package": "regex-xmlschema",
          "signature": "CharSet",
          "source": "src/Text-Regex-XMLSchema-String-XML-CharProps.html#isXmlBaseChar",
          "type": "function"
        },
        "index": {
          "description": "checking for XML base charater",
          "hierarchy": "Text Regex XMLSchema String XML CharProps",
          "module": "Text.Regex.XMLSchema.String.XML.CharProps",
          "name": "isXmlBaseChar",
          "package": "regex-xmlschema",
          "partial": "Xml Base Char",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-xmlschema/docs/Text-Regex-XMLSchema-String-XML-CharProps.html#v:isXmlBaseChar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003echecking for valid XML characters\n\u003c/p\u003e",
          "module": "Text.Regex.XMLSchema.String.XML.CharProps",
          "name": "isXmlChar",
          "package": "regex-xmlschema",
          "signature": "CharSet",
          "source": "src/Text-Regex-XMLSchema-String-XML-CharProps.html#isXmlChar",
          "type": "function"
        },
        "index": {
          "description": "checking for valid XML characters",
          "hierarchy": "Text Regex XMLSchema String XML CharProps",
          "module": "Text.Regex.XMLSchema.String.XML.CharProps",
          "name": "isXmlChar",
          "package": "regex-xmlschema",
          "partial": "Xml Char",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-xmlschema/docs/Text-Regex-XMLSchema-String-XML-CharProps.html#v:isXmlChar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003echecking for XML combining charater\n\u003c/p\u003e",
          "module": "Text.Regex.XMLSchema.String.XML.CharProps",
          "name": "isXmlCombiningChar",
          "package": "regex-xmlschema",
          "signature": "CharSet",
          "source": "src/Text-Regex-XMLSchema-String-XML-CharProps.html#isXmlCombiningChar",
          "type": "function"
        },
        "index": {
          "description": "checking for XML combining charater",
          "hierarchy": "Text Regex XMLSchema String XML CharProps",
          "module": "Text.Regex.XMLSchema.String.XML.CharProps",
          "name": "isXmlCombiningChar",
          "package": "regex-xmlschema",
          "partial": "Xml Combining Char",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-xmlschema/docs/Text-Regex-XMLSchema-String-XML-CharProps.html#v:isXmlCombiningChar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003echecking for XML control or permanently discouraged char\n\u003c/p\u003e\u003cp\u003esee Errata to XML1.0 (http://www.w3.org/XML/xml-V10-2e-errata) No 46\n\u003c/p\u003e\u003cp\u003eDocument authors are encouraged to avoid \u003ca\u003ecompatibility characters\u003c/a\u003e,\n as defined in section 6.8 of [Unicode] (see also D21 in section 3.6 of [Unicode3]).\n The characters defined in the following ranges are also discouraged.\n They are either control characters or permanently undefined Unicode characters:\n\u003c/p\u003e",
          "module": "Text.Regex.XMLSchema.String.XML.CharProps",
          "name": "isXmlControlOrPermanentlyUndefined",
          "package": "regex-xmlschema",
          "signature": "CharSet",
          "source": "src/Text-Regex-XMLSchema-String-XML-CharProps.html#isXmlControlOrPermanentlyUndefined",
          "type": "function"
        },
        "index": {
          "description": "checking for XML control or permanently discouraged char see Errata to XML1.0 http www.w3.org XML xml-V10-2e-errata No Document authors are encouraged to avoid compatibility characters as defined in section of Unicode see also D21 in section of Unicode3 The characters defined in the following ranges are also discouraged They are either control characters or permanently undefined Unicode characters",
          "hierarchy": "Text Regex XMLSchema String XML CharProps",
          "module": "Text.Regex.XMLSchema.String.XML.CharProps",
          "name": "isXmlControlOrPermanentlyUndefined",
          "package": "regex-xmlschema",
          "partial": "Xml Control Or Permanently Undefined",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-xmlschema/docs/Text-Regex-XMLSchema-String-XML-CharProps.html#v:isXmlControlOrPermanentlyUndefined"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003echecking for XML digit\n\u003c/p\u003e",
          "module": "Text.Regex.XMLSchema.String.XML.CharProps",
          "name": "isXmlDigit",
          "package": "regex-xmlschema",
          "signature": "CharSet",
          "source": "src/Text-Regex-XMLSchema-String-XML-CharProps.html#isXmlDigit",
          "type": "function"
        },
        "index": {
          "description": "checking for XML digit",
          "hierarchy": "Text Regex XMLSchema String XML CharProps",
          "module": "Text.Regex.XMLSchema.String.XML.CharProps",
          "name": "isXmlDigit",
          "package": "regex-xmlschema",
          "partial": "Xml Digit",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-xmlschema/docs/Text-Regex-XMLSchema-String-XML-CharProps.html#v:isXmlDigit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003echecking for XML extender\n\u003c/p\u003e",
          "module": "Text.Regex.XMLSchema.String.XML.CharProps",
          "name": "isXmlExtender",
          "package": "regex-xmlschema",
          "signature": "CharSet",
          "source": "src/Text-Regex-XMLSchema-String-XML-CharProps.html#isXmlExtender",
          "type": "function"
        },
        "index": {
          "description": "checking for XML extender",
          "hierarchy": "Text Regex XMLSchema String XML CharProps",
          "module": "Text.Regex.XMLSchema.String.XML.CharProps",
          "name": "isXmlExtender",
          "package": "regex-xmlschema",
          "partial": "Xml Extender",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-xmlschema/docs/Text-Regex-XMLSchema-String-XML-CharProps.html#v:isXmlExtender"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003echecking for XML ideographic charater\n\u003c/p\u003e",
          "module": "Text.Regex.XMLSchema.String.XML.CharProps",
          "name": "isXmlIdeographicChar",
          "package": "regex-xmlschema",
          "signature": "CharSet",
          "source": "src/Text-Regex-XMLSchema-String-XML-CharProps.html#isXmlIdeographicChar",
          "type": "function"
        },
        "index": {
          "description": "checking for XML ideographic charater",
          "hierarchy": "Text Regex XMLSchema String XML CharProps",
          "module": "Text.Regex.XMLSchema.String.XML.CharProps",
          "name": "isXmlIdeographicChar",
          "package": "regex-xmlschema",
          "partial": "Xml Ideographic Char",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-xmlschema/docs/Text-Regex-XMLSchema-String-XML-CharProps.html#v:isXmlIdeographicChar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003echecking for XML letter\n\u003c/p\u003e",
          "module": "Text.Regex.XMLSchema.String.XML.CharProps",
          "name": "isXmlLetter",
          "package": "regex-xmlschema",
          "signature": "CharSet",
          "source": "src/Text-Regex-XMLSchema-String-XML-CharProps.html#isXmlLetter",
          "type": "function"
        },
        "index": {
          "description": "checking for XML letter",
          "hierarchy": "Text Regex XMLSchema String XML CharProps",
          "module": "Text.Regex.XMLSchema.String.XML.CharProps",
          "name": "isXmlLetter",
          "package": "regex-xmlschema",
          "partial": "Xml Letter",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-xmlschema/docs/Text-Regex-XMLSchema-String-XML-CharProps.html#v:isXmlLetter"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003echecking for XML NCName character: no \":\" allowed\n\u003c/p\u003e\u003cp\u003esee also : \u003ccode\u003e\u003ca\u003eisXmlNameChar\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Text.Regex.XMLSchema.String.XML.CharProps",
          "name": "isXmlNCNameChar",
          "package": "regex-xmlschema",
          "signature": "CharSet",
          "source": "src/Text-Regex-XMLSchema-String-XML-CharProps.html#isXmlNCNameChar",
          "type": "function"
        },
        "index": {
          "description": "checking for XML NCName character no allowed see also isXmlNameChar",
          "hierarchy": "Text Regex XMLSchema String XML CharProps",
          "module": "Text.Regex.XMLSchema.String.XML.CharProps",
          "name": "isXmlNCNameChar",
          "package": "regex-xmlschema",
          "partial": "Xml NCName Char",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-xmlschema/docs/Text-Regex-XMLSchema-String-XML-CharProps.html#v:isXmlNCNameChar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003echecking for XML NCName start character: no \":\" allowed\n\u003c/p\u003e\u003cp\u003esee also : \u003ccode\u003e\u003ca\u003eisXmlNameChar\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eisXmlNCNameChar\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Text.Regex.XMLSchema.String.XML.CharProps",
          "name": "isXmlNCNameStartChar",
          "package": "regex-xmlschema",
          "signature": "CharSet",
          "source": "src/Text-Regex-XMLSchema-String-XML-CharProps.html#isXmlNCNameStartChar",
          "type": "function"
        },
        "index": {
          "description": "checking for XML NCName start character no allowed see also isXmlNameChar isXmlNCNameChar",
          "hierarchy": "Text Regex XMLSchema String XML CharProps",
          "module": "Text.Regex.XMLSchema.String.XML.CharProps",
          "name": "isXmlNCNameStartChar",
          "package": "regex-xmlschema",
          "partial": "Xml NCName Start Char",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-xmlschema/docs/Text-Regex-XMLSchema-String-XML-CharProps.html#v:isXmlNCNameStartChar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003echecking for XML name character\n\u003c/p\u003e",
          "module": "Text.Regex.XMLSchema.String.XML.CharProps",
          "name": "isXmlNameChar",
          "package": "regex-xmlschema",
          "signature": "CharSet",
          "source": "src/Text-Regex-XMLSchema-String-XML-CharProps.html#isXmlNameChar",
          "type": "function"
        },
        "index": {
          "description": "checking for XML name character",
          "hierarchy": "Text Regex XMLSchema String XML CharProps",
          "module": "Text.Regex.XMLSchema.String.XML.CharProps",
          "name": "isXmlNameChar",
          "package": "regex-xmlschema",
          "partial": "Xml Name Char",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-xmlschema/docs/Text-Regex-XMLSchema-String-XML-CharProps.html#v:isXmlNameChar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003echecking for XML name start character\n\u003c/p\u003e\u003cp\u003esee also : \u003ccode\u003e\u003ca\u003eisXmlNameChar\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Text.Regex.XMLSchema.String.XML.CharProps",
          "name": "isXmlNameStartChar",
          "package": "regex-xmlschema",
          "signature": "CharSet",
          "source": "src/Text-Regex-XMLSchema-String-XML-CharProps.html#isXmlNameStartChar",
          "type": "function"
        },
        "index": {
          "description": "checking for XML name start character see also isXmlNameChar",
          "hierarchy": "Text Regex XMLSchema String XML CharProps",
          "module": "Text.Regex.XMLSchema.String.XML.CharProps",
          "name": "isXmlNameStartChar",
          "package": "regex-xmlschema",
          "partial": "Xml Name Start Char",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-xmlschema/docs/Text-Regex-XMLSchema-String-XML-CharProps.html#v:isXmlNameStartChar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003echecking for XML public id character\n\u003c/p\u003e",
          "module": "Text.Regex.XMLSchema.String.XML.CharProps",
          "name": "isXmlPubidChar",
          "package": "regex-xmlschema",
          "signature": "CharSet",
          "source": "src/Text-Regex-XMLSchema-String-XML-CharProps.html#isXmlPubidChar",
          "type": "function"
        },
        "index": {
          "description": "checking for XML public id character",
          "hierarchy": "Text Regex XMLSchema String XML CharProps",
          "module": "Text.Regex.XMLSchema.String.XML.CharProps",
          "name": "isXmlPubidChar",
          "package": "regex-xmlschema",
          "partial": "Xml Pubid Char",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-xmlschema/docs/Text-Regex-XMLSchema-String-XML-CharProps.html#v:isXmlPubidChar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003echecking for XML space character: \\n, \\r, \\t and \" \"\n\u003c/p\u003e",
          "module": "Text.Regex.XMLSchema.String.XML.CharProps",
          "name": "isXmlSpaceChar",
          "package": "regex-xmlschema",
          "signature": "CharSet",
          "source": "src/Text-Regex-XMLSchema-String-XML-CharProps.html#isXmlSpaceChar",
          "type": "function"
        },
        "index": {
          "description": "checking for XML space character and",
          "hierarchy": "Text Regex XMLSchema String XML CharProps",
          "module": "Text.Regex.XMLSchema.String.XML.CharProps",
          "name": "isXmlSpaceChar",
          "package": "regex-xmlschema",
          "partial": "Xml Space Char",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-xmlschema/docs/Text-Regex-XMLSchema-String-XML-CharProps.html#v:isXmlSpaceChar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eConvenient functions for W3C XML Schema Regular Expression Matcher.\n   For internals see \u003ccode\u003eText.Regex.XMLSchema.String.Regex\u003c/code\u003e\n\u003c/p\u003e\u003cp\u003eGrammar can be found under \u003ca\u003ehttp://www.w3.org/TR/xmlschema11-2/#regexs\u003c/a\u003e\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Text.Regex.XMLSchema.String",
          "name": "String",
          "package": "regex-xmlschema",
          "source": "src/Text-Regex-XMLSchema-String.html",
          "type": "module"
        },
        "index": {
          "description": "Convenient functions for W3C XML Schema Regular Expression Matcher For internals see Text.Regex.XMLSchema.String.Regex Grammar can be found under http www.w3.org TR xmlschema11-2 regexs",
          "hierarchy": "Text Regex XMLSchema String",
          "module": "Text.Regex.XMLSchema.String",
          "name": "String",
          "package": "regex-xmlschema",
          "partial": "String",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/regex-xmlschema/docs/Text-Regex-XMLSchema-String.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.XMLSchema.String",
          "name": "GenRegex",
          "package": "regex-xmlschema",
          "source": "src/Text-Regex-XMLSchema-String-Regex.html#GenRegex",
          "type": "data"
        },
        "index": {
          "hierarchy": "Text Regex XMLSchema String",
          "module": "Text.Regex.XMLSchema.String",
          "name": "GenRegex",
          "package": "regex-xmlschema",
          "partial": "Gen Regex",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/regex-xmlschema/docs/Text-Regex-XMLSchema-String.html#t:GenRegex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.XMLSchema.String",
          "name": "Regex",
          "package": "regex-xmlschema",
          "source": "src/Text-Regex-XMLSchema-String-Regex.html#Regex",
          "type": "type"
        },
        "index": {
          "hierarchy": "Text Regex XMLSchema String",
          "module": "Text.Regex.XMLSchema.String",
          "name": "Regex",
          "package": "regex-xmlschema",
          "partial": "Regex",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/regex-xmlschema/docs/Text-Regex-XMLSchema-String.html#t:Regex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003egrep like filter for lists of strings\n\u003c/p\u003e\u003cp\u003eThe regular expression may be prefixed with the usual context spec \"^\" for start of string,\n and \u003ca\u003e\\\u003c\u003c/a\u003e for start of word.\n and suffixed with \"$\" for end of text and \u003ca\u003e\\\u003e\u003c/a\u003e end of word.\n Word chars are defined by the multi char escape sequence \u003ca\u003e\\w\u003c/a\u003e\n\u003c/p\u003e\u003cp\u003eExamples\n\u003c/p\u003e\u003cpre\u003e grep \"a\"    [\"_a_\", \"_a\", \"a_\", \"a\", \"_\"]      =\u003e [\"_a_\", \"_a\", \"a_\", \"a\"]\n grep \"^a\"   [\"_a_\", \"_a\", \"a_\", \"a\", \"_\"]      =\u003e [\"a_\", \"a\"]\n grep \"a$\"   [\"_a_\", \"_a\", \"a_\", \"a\", \"_\"]      =\u003e [\"_a\", \"a\"]\n grep \"^a$\"  [\"_a_\", \"_a\", \"a_\", \"a\", \"_\"]      =\u003e [\"a\"]\n grep \"\\\\\u003ca\" [\"x a b\", \" ax \", \" xa \", \"xab\"]   =\u003e [\"x a b\", \" ax \"]\n grep \"a\\\\\u003e\" [\"x a b\", \" ax \", \" xa \", \"xab\"]   =\u003e [\"x a b\", \" xa \"]\n\u003c/pre\u003e",
          "module": "Text.Regex.XMLSchema.String",
          "name": "grep",
          "package": "regex-xmlschema",
          "signature": "String -\u003e [String] -\u003e [String]",
          "source": "src/Text-Regex-XMLSchema-String.html#grep",
          "type": "function"
        },
        "index": {
          "description": "grep like filter for lists of strings The regular expression may be prefixed with the usual context spec for start of string and for start of word and suffixed with for end of text and end of word Word chars are defined by the multi char escape sequence Examples grep grep grep grep grep ax xa xab ax grep ax xa xab xa",
          "hierarchy": "Text Regex XMLSchema String",
          "module": "Text.Regex.XMLSchema.String",
          "name": "grep",
          "normalized": "String-\u003e[String]-\u003e[String]",
          "package": "regex-xmlschema",
          "signature": "String-\u003e[String]-\u003e[String]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-xmlschema/docs/Text-Regex-XMLSchema-String.html#v:grep"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003econvenient function for \u003ccode\u003e\u003ca\u003ematchRE\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e\u003cp\u003eExamples:\n\u003c/p\u003e\u003cpre\u003e match \"x*\" \"xxx\" = True\n match \"x\" \"xxx\"  = False\n match \"[\" \"xxx\"  = False\n\u003c/pre\u003e",
          "module": "Text.Regex.XMLSchema.String",
          "name": "match",
          "package": "regex-xmlschema",
          "signature": "String -\u003e String -\u003e Bool",
          "source": "src/Text-Regex-XMLSchema-String.html#match",
          "type": "function"
        },
        "index": {
          "description": "convenient function for matchRE Examples match xxx True match xxx False match xxx False",
          "hierarchy": "Text Regex XMLSchema String",
          "module": "Text.Regex.XMLSchema.String",
          "name": "match",
          "normalized": "String-\u003eString-\u003eBool",
          "package": "regex-xmlschema",
          "signature": "String-\u003eString-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-xmlschema/docs/Text-Regex-XMLSchema-String.html#v:match"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ematch a string with a regular expression\n\u003c/p\u003e",
          "module": "Text.Regex.XMLSchema.String",
          "name": "matchRE",
          "package": "regex-xmlschema",
          "signature": "GenRegex l -\u003e String -\u003e Bool",
          "source": "src/Text-Regex-XMLSchema-String.html#matchRE",
          "type": "function"
        },
        "index": {
          "description": "match string with regular expression",
          "hierarchy": "Text Regex XMLSchema String",
          "module": "Text.Regex.XMLSchema.String",
          "name": "matchRE",
          "normalized": "GenRegex a-\u003eString-\u003eBool",
          "package": "regex-xmlschema",
          "partial": "RE",
          "signature": "GenRegex l-\u003eString-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-xmlschema/docs/Text-Regex-XMLSchema-String.html#v:matchRE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003econvenient function for \u003ccode\u003e\u003ca\u003ematchRE\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e\u003cp\u003eExamples:\n\u003c/p\u003e\u003cpre\u003e matchSubex \"({1}x*)\"                 \"xxx\"      = [(\"1\",\"xxx\")]\n matchSubex \"({1}x*)\"                 \"y\"        = []\n matchSubex \"({w}[0-9]+)x({h}[0-9]+)\" \"800x600\"  = [(\"w\",\"800\"),(\"h\",\"600\")]\n matchSubex \"[\" \"xxx\"                            = []\n\u003c/pre\u003e",
          "module": "Text.Regex.XMLSchema.String",
          "name": "matchSubex",
          "package": "regex-xmlschema",
          "signature": "String -\u003e String -\u003e [(String, String)]",
          "source": "src/Text-Regex-XMLSchema-String.html#matchSubex",
          "type": "function"
        },
        "index": {
          "description": "convenient function for matchRE Examples matchSubex xxx xxx matchSubex matchSubex x600 matchSubex xxx",
          "hierarchy": "Text Regex XMLSchema String",
          "module": "Text.Regex.XMLSchema.String",
          "name": "matchSubex",
          "normalized": "String-\u003eString-\u003e[(String,String)]",
          "package": "regex-xmlschema",
          "partial": "Subex",
          "signature": "String-\u003eString-\u003e[(String,String)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-xmlschema/docs/Text-Regex-XMLSchema-String.html#v:matchSubex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ematch a string with a regular expression\n and extract subexpression matches\n\u003c/p\u003e",
          "module": "Text.Regex.XMLSchema.String",
          "name": "matchSubexRE",
          "package": "regex-xmlschema",
          "signature": "GenRegex l -\u003e String -\u003e [(l, String)]",
          "source": "src/Text-Regex-XMLSchema-String.html#matchSubexRE",
          "type": "function"
        },
        "index": {
          "description": "match string with regular expression and extract subexpression matches",
          "hierarchy": "Text Regex XMLSchema String",
          "module": "Text.Regex.XMLSchema.String",
          "name": "matchSubexRE",
          "normalized": "GenRegex a-\u003eString-\u003e[(a,String)]",
          "package": "regex-xmlschema",
          "partial": "Subex RE",
          "signature": "GenRegex l-\u003eString-\u003e[(l,String)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-xmlschema/docs/Text-Regex-XMLSchema-String.html#v:matchSubexRE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003econvenient function for \u003ccode\u003e\u003ca\u003esedRE\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e\u003cp\u003eexamples:\n\u003c/p\u003e\u003cpre\u003e sed (const \"b\") \"a\" \"xaxax\"       = \"xbxbx\"\n sed (\\ x -\u003e x ++ x) \"a\" \"xax\"     = \"xaax\"\n sed undefined       \"[\" \"xxx\"     = \"xxx\"\n\u003c/pre\u003e",
          "module": "Text.Regex.XMLSchema.String",
          "name": "sed",
          "package": "regex-xmlschema",
          "signature": "(String -\u003e String) -\u003e String -\u003e String -\u003e String",
          "source": "src/Text-Regex-XMLSchema-String.html#sed",
          "type": "function"
        },
        "index": {
          "description": "convenient function for sedRE examples sed const xaxax xbxbx sed xax xaax sed undefined xxx xxx",
          "hierarchy": "Text Regex XMLSchema String",
          "module": "Text.Regex.XMLSchema.String",
          "name": "sed",
          "normalized": "(String-\u003eString)-\u003eString-\u003eString-\u003eString",
          "package": "regex-xmlschema",
          "signature": "(String-\u003eString)-\u003eString-\u003eString-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-xmlschema/docs/Text-Regex-XMLSchema-String.html#v:sed"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003esed like editing function\n\u003c/p\u003e\u003cp\u003eAll matching tokens are edited by the 1. argument, the editing function,\n all other chars remain as they are\n\u003c/p\u003e",
          "module": "Text.Regex.XMLSchema.String",
          "name": "sedRE",
          "package": "regex-xmlschema",
          "signature": "(String -\u003e String) -\u003e GenRegex l -\u003e String -\u003e String",
          "source": "src/Text-Regex-XMLSchema-String.html#sedRE",
          "type": "function"
        },
        "index": {
          "description": "sed like editing function All matching tokens are edited by the argument the editing function all other chars remain as they are",
          "hierarchy": "Text Regex XMLSchema String",
          "module": "Text.Regex.XMLSchema.String",
          "name": "sedRE",
          "normalized": "(String-\u003eString)-\u003eGenRegex a-\u003eString-\u003eString",
          "package": "regex-xmlschema",
          "partial": "RE",
          "signature": "(String-\u003eString)-\u003eGenRegex l-\u003eString-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-xmlschema/docs/Text-Regex-XMLSchema-String.html#v:sedRE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003econvenient function for \u003ccode\u003e\u003ca\u003esplitRE\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e\u003cp\u003eexamples:\n\u003c/p\u003e\u003cpre\u003e split \"a*b\" \"abc\" = (\"ab\",\"c\")\n split \"a*\"  \"bc\"  = (\"\", \"bc\")\n split \"a+\"  \"bc\"  = (\"\", \"bc\")\n split \"[\"   \"abc\" = (\"\", \"abc\")\n\u003c/pre\u003e",
          "module": "Text.Regex.XMLSchema.String",
          "name": "split",
          "package": "regex-xmlschema",
          "signature": "String -\u003e String -\u003e (String, String)",
          "source": "src/Text-Regex-XMLSchema-String.html#split",
          "type": "function"
        },
        "index": {
          "description": "convenient function for splitRE examples split abc ab split bc bc split bc bc split abc abc",
          "hierarchy": "Text Regex XMLSchema String",
          "module": "Text.Regex.XMLSchema.String",
          "name": "split",
          "normalized": "String-\u003eString-\u003e(String,String)",
          "package": "regex-xmlschema",
          "signature": "String-\u003eString-\u003e(String,String)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-xmlschema/docs/Text-Regex-XMLSchema-String.html#v:split"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003esplit a string by taking the longest prefix matching a regular expression\n\u003c/p\u003e\u003cp\u003e\u003ccode\u003eNothing\u003c/code\u003e is returned in case there is no matching prefix,\n else the pair of prefix and rest is returned\n\u003c/p\u003e",
          "module": "Text.Regex.XMLSchema.String",
          "name": "splitRE",
          "package": "regex-xmlschema",
          "signature": "GenRegex l -\u003e String -\u003e Maybe (String, String)",
          "source": "src/Text-Regex-XMLSchema-String.html#splitRE",
          "type": "function"
        },
        "index": {
          "description": "split string by taking the longest prefix matching regular expression Nothing is returned in case there is no matching prefix else the pair of prefix and rest is returned",
          "hierarchy": "Text Regex XMLSchema String",
          "module": "Text.Regex.XMLSchema.String",
          "name": "splitRE",
          "normalized": "GenRegex a-\u003eString-\u003eMaybe(String,String)",
          "package": "regex-xmlschema",
          "partial": "RE",
          "signature": "GenRegex l-\u003eString-\u003eMaybe(String,String)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-xmlschema/docs/Text-Regex-XMLSchema-String.html#v:splitRE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003econvenient function for \u003ccode\u003e\u003ca\u003esplitSubex\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e\u003cp\u003eexamples:\n\u003c/p\u003e\u003cpre\u003e splitSubex \"({1}a*)b\"  \"abc\" = ([(\"1\",\"a\")],\"c\")\n splitSubex \"({2}a*)\"   \"bc\"  = ([(\"2\",\"\")], \"bc\")\n splitSubex \"({1}a|b)+\" \"abc\" = ([(\"1\",\"a\"),(\"1\",\"b\")],\"c\")        -- subex 1 matches 2 times\n\n splitSubex \".*({x}a*)\" \"aa\"  = ([(\"x\",\"\"),(\"x\",\"a\"),(\"x\",\"aa\")],\"\")\n                                                                   -- nondeterminism: 3 matches for a*\n\n splitSubex \"({1}do)|({2}[a-z]+)\" \"do you know\"\n                                = ([(\"1\",\"do\"),(\"2\",\"do\")],\" you know\")\n                                                                   -- nondeterminism: 2 matches for do\n\n splitSubex \"({1}do){|}({2}[a-z]+)\" \"do you know\"\n                                = ([(\"1\",\"do\")],\" you know\")\n                                                                   -- no nondeterminism with {|}: 1. match for do\n\n splitSubex \"({1}a+)\"   \"bcd\" = ([], \"bcd\")                        -- no match\n splitSubex \"[\"         \"abc\" = ([], \"abc\")                        -- syntax error\n\u003c/pre\u003e",
          "module": "Text.Regex.XMLSchema.String",
          "name": "splitSubex",
          "package": "regex-xmlschema",
          "signature": "String -\u003e String -\u003e ([(String, String)], String)",
          "source": "src/Text-Regex-XMLSchema-String.html#splitSubex",
          "type": "function"
        },
        "index": {
          "description": "convenient function for splitSubex examples splitSubex abc splitSubex bc bc splitSubex abc subex matches times splitSubex aa aa nondeterminism matches for splitSubex do a-z do you know do do you know nondeterminism matches for do splitSubex do a-z do you know do you know no nondeterminism with match for do splitSubex bcd bcd no match splitSubex abc abc syntax error",
          "hierarchy": "Text Regex XMLSchema String",
          "module": "Text.Regex.XMLSchema.String",
          "name": "splitSubex",
          "normalized": "String-\u003eString-\u003e([(String,String)],String)",
          "package": "regex-xmlschema",
          "partial": "Subex",
          "signature": "String-\u003eString-\u003e([(String,String)],String)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-xmlschema/docs/Text-Regex-XMLSchema-String.html#v:splitSubex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003esplit a string by removing the longest prefix matching a regular expression\n and then return the list of subexpressions found in the matching part\n\u003c/p\u003e\u003cp\u003e\u003ccode\u003eNothing\u003c/code\u003e is returned in case of no matching prefix,\n else the list of pairs of labels and submatches and the\n rest is returned\n\u003c/p\u003e",
          "module": "Text.Regex.XMLSchema.String",
          "name": "splitSubexRE",
          "package": "regex-xmlschema",
          "signature": "GenRegex l -\u003e String -\u003e Maybe ([(l, String)], String)",
          "source": "src/Text-Regex-XMLSchema-String.html#splitSubexRE",
          "type": "function"
        },
        "index": {
          "description": "split string by removing the longest prefix matching regular expression and then return the list of subexpressions found in the matching part Nothing is returned in case of no matching prefix else the list of pairs of labels and submatches and the rest is returned",
          "hierarchy": "Text Regex XMLSchema String",
          "module": "Text.Regex.XMLSchema.String",
          "name": "splitSubexRE",
          "normalized": "GenRegex a-\u003eString-\u003eMaybe([(a,String)],String)",
          "package": "regex-xmlschema",
          "partial": "Subex RE",
          "signature": "GenRegex l-\u003eString-\u003eMaybe([(l,String)],String)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-xmlschema/docs/Text-Regex-XMLSchema-String.html#v:splitSubexRE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003esplit a string into tokens (words) by giving a regular expression\n which all tokens must match.\n\u003c/p\u003e\u003cp\u003eConvenient function for \u003ccode\u003e\u003ca\u003etokenizeRE\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e\u003cp\u003eThis can be used for simple tokenizers.\n It is recommended to use regular expressions where the empty word does not match.\n Else there will appear a lot of probably useless empty tokens in the output.\n All none matching chars are discarded. If the given regex contains syntax errors,\n \u003ccode\u003eNothing\u003c/code\u003e is returned\n\u003c/p\u003e\u003cp\u003eexamples:\n\u003c/p\u003e\u003cpre\u003e tokenize \"a\" \"aabba\"      = [\"a\",\"a\",\"a\"]\n tokenize \"a*\" \"aaaba\"     = [\"aaa\",\"a\"]\n tokenize \"a*\" \"bbb\"       = [\"\",\"\",\"\"]\n tokenize \"a+\" \"bbb\"       = []\n\n tokenize \"a*b\" \"\"         = []\n tokenize \"a*b\" \"abc\"      = [\"ab\"]\n tokenize \"a*b\" \"abaab ab\" = [\"ab\",\"aab\",\"ab\"]\n\n tokenize \"[a-z]{2,}|[0-9]{2,}|[0-9]+[.][0-9]+\" \"ab123 456.7abc\"\n                           = [\"ab\",\"123\",\"456.7\",\"abc\"]\n\n tokenize \"[a-z]*|[0-9]{2,}|[0-9]+[.][0-9]+\" \"cab123 456.7abc\"\n                           = [\"cab\",\"123\",\"456.7\",\"abc\"]\n\n tokenize \"[^ \\t\\n\\r]*\" \"abc def\\t\\n\\rxyz\"\n                           = [\"abc\",\"def\",\"xyz\"]\n\n tokenize \".*\"   \"\\nabc\\n123\\n\\nxyz\\n\"\n                           = [\"\",\"abc\",\"123\",\"\",\"xyz\"]\n\n tokenize \".*\"             = lines\n\n tokenize \"[^ \\t\\n\\r]*\"    = words\n\u003c/pre\u003e",
          "module": "Text.Regex.XMLSchema.String",
          "name": "tokenize",
          "package": "regex-xmlschema",
          "signature": "String -\u003e String -\u003e [String]",
          "source": "src/Text-Regex-XMLSchema-String.html#tokenize",
          "type": "function"
        },
        "index": {
          "description": "split string into tokens words by giving regular expression which all tokens must match Convenient function for tokenizeRE This can be used for simple tokenizers It is recommended to use regular expressions where the empty word does not match Else there will appear lot of probably useless empty tokens in the output All none matching chars are discarded If the given regex contains syntax errors Nothing is returned examples tokenize aabba tokenize aaaba aaa tokenize bbb tokenize bbb tokenize tokenize abc ab tokenize abaab ab ab aab ab tokenize a-z ab123 abc ab abc tokenize a-z cab123 abc cab abc tokenize abc def rxyz abc def xyz tokenize nabc n123 nxyz abc xyz tokenize lines tokenize words",
          "hierarchy": "Text Regex XMLSchema String",
          "module": "Text.Regex.XMLSchema.String",
          "name": "tokenize",
          "normalized": "String-\u003eString-\u003e[String]",
          "package": "regex-xmlschema",
          "signature": "String-\u003eString-\u003e[String]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-xmlschema/docs/Text-Regex-XMLSchema-String.html#v:tokenize"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003econvenient function for \u003ccode\u003e\u003ca\u003etokenizeRE'\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e\u003cp\u003eWhen the regular expression parses as Zero, \u003ccode\u003e[Left input]\u003c/code\u003e is returned, that means no tokens are found\n\u003c/p\u003e",
          "module": "Text.Regex.XMLSchema.String",
          "name": "tokenize'",
          "package": "regex-xmlschema",
          "signature": "String -\u003e String -\u003e [Either String String]",
          "source": "src/Text-Regex-XMLSchema-String.html#tokenize%27",
          "type": "function"
        },
        "index": {
          "description": "convenient function for tokenizeRE When the regular expression parses as Zero Left input is returned that means no tokens are found",
          "hierarchy": "Text Regex XMLSchema String",
          "module": "Text.Regex.XMLSchema.String",
          "name": "tokenize'",
          "normalized": "String-\u003eString-\u003e[Either String String]",
          "package": "regex-xmlschema",
          "signature": "String-\u003eString-\u003e[Either String String]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-xmlschema/docs/Text-Regex-XMLSchema-String.html#v:tokenize-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe function, that does the real work for \u003ccode\u003e\u003ca\u003etokenize\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Text.Regex.XMLSchema.String",
          "name": "tokenizeRE",
          "package": "regex-xmlschema",
          "signature": "GenRegex l -\u003e String -\u003e [String]",
          "source": "src/Text-Regex-XMLSchema-String.html#tokenizeRE",
          "type": "function"
        },
        "index": {
          "description": "The function that does the real work for tokenize",
          "hierarchy": "Text Regex XMLSchema String",
          "module": "Text.Regex.XMLSchema.String",
          "name": "tokenizeRE",
          "normalized": "GenRegex a-\u003eString-\u003e[String]",
          "package": "regex-xmlschema",
          "partial": "RE",
          "signature": "GenRegex l-\u003eString-\u003e[String]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-xmlschema/docs/Text-Regex-XMLSchema-String.html#v:tokenizeRE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003esplit a string into tokens and delimierter by giving a regular expression\n wich all tokens must match\n\u003c/p\u003e\u003cp\u003eThis is a generalisation of the above \u003ccode\u003e\u003ca\u003etokenizeRE\u003c/a\u003e\u003c/code\u003e functions.\n The none matching char sequences are marked with \u003ccode\u003eLeft\u003c/code\u003e, the matching ones are marked with \u003ccode\u003eRight\u003c/code\u003e\n\u003c/p\u003e\u003cp\u003eIf the regular expression contains syntax errors \u003ccode\u003eNothing\u003c/code\u003e is returned\n\u003c/p\u003e\u003cp\u003eThe following Law holds:\n\u003c/p\u003e\u003cpre\u003e concat . map (either id id) . tokenizeRE' re == id\n\u003c/pre\u003e",
          "module": "Text.Regex.XMLSchema.String",
          "name": "tokenizeRE'",
          "package": "regex-xmlschema",
          "signature": "GenRegex l -\u003e String -\u003e [Either String String]",
          "source": "src/Text-Regex-XMLSchema-String.html#tokenizeRE%27",
          "type": "function"
        },
        "index": {
          "description": "split string into tokens and delimierter by giving regular expression wich all tokens must match This is generalisation of the above tokenizeRE functions The none matching char sequences are marked with Left the matching ones are marked with Right If the regular expression contains syntax errors Nothing is returned The following Law holds concat map either id id tokenizeRE re id",
          "hierarchy": "Text Regex XMLSchema String",
          "module": "Text.Regex.XMLSchema.String",
          "name": "tokenizeRE'",
          "normalized": "GenRegex a-\u003eString-\u003e[Either String String]",
          "package": "regex-xmlschema",
          "partial": "RE'",
          "signature": "GenRegex l-\u003eString-\u003e[Either String String]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-xmlschema/docs/Text-Regex-XMLSchema-String.html#v:tokenizeRE-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003econvenient function for \u003ccode\u003e\u003ca\u003etokenizeSubexRE\u003c/a\u003e\u003c/code\u003e a string\n\u003c/p\u003e\u003cp\u003eexamples:\n\u003c/p\u003e\u003cpre\u003e tokenizeSubex \"({name}[a-z]+)|({num}[0-9]{2,})|({real}[0-9]+[.][0-9]+)\"\n                 \"cab123 456.7abc\"\n                                  = [(\"name\",\"cab\")\n                                    ,(\"num\",\"123\")\n                                    ,(\"real\",\"456.7\")\n                                    ,(\"name\",\"abc\")]\n\n tokenizeSubex \"({real}({n}[0-9]+)([.]({f}[0-9]+))?)\"\n                 \"12.34\"          = [(\"real\",\"12.34\")\n                                    ,(\"n\",\"12\")\n                                    ,(\"f\",\"34\")]\n\n tokenizeSubex \"({real}({n}[0-9]+)([.]({f}[0-9]+))?)\"\n                  \"12 34\"         = [(\"real\",\"12\"),(\"n\",\"12\")\n                                    ,(\"real\",\"34\"),(\"n\",\"34\")]\n\n tokenizeSubex \"({real}({n}[0-9]+)(([.]({f}[0-9]+))|({f})))\"\n                  \"12 34.56\"      = [(\"real\",\"12\"),(\"n\",\"12\"),(\"f\",\"\")\n                                    ,(\"real\",\"34.56\"),(\"n\",\"34\"),(\"f\",\"56\")]\n\u003c/pre\u003e",
          "module": "Text.Regex.XMLSchema.String",
          "name": "tokenizeSubex",
          "package": "regex-xmlschema",
          "signature": "String -\u003e String -\u003e [(String, String)]",
          "source": "src/Text-Regex-XMLSchema-String.html#tokenizeSubex",
          "type": "function"
        },
        "index": {
          "description": "convenient function for tokenizeSubexRE string examples tokenizeSubex name a-z num real cab123 abc name cab num real name abc tokenizeSubex real real tokenizeSubex real real real tokenizeSubex real real real",
          "hierarchy": "Text Regex XMLSchema String",
          "module": "Text.Regex.XMLSchema.String",
          "name": "tokenizeSubex",
          "normalized": "String-\u003eString-\u003e[(String,String)]",
          "package": "regex-xmlschema",
          "partial": "Subex",
          "signature": "String-\u003eString-\u003e[(String,String)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-xmlschema/docs/Text-Regex-XMLSchema-String.html#v:tokenizeSubex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003esplit a string into tokens (pair of labels and words) by giving a regular expression\n containing labeled subexpressions.\n\u003c/p\u003e\u003cp\u003eThis function should not be called with regular expressions\n without any labeled subexpressions. This does not make sense, because the result list\n will always be empty.\n\u003c/p\u003e\u003cp\u003eResult is the list of matching subexpressions\n This can be used for simple tokenizers.\n At least one char is consumed by parsing a token.\n The pairs in the result list contain the matching substrings.\n All none matching chars are discarded. If the given regex contains syntax errors,\n \u003ccode\u003eNothing\u003c/code\u003e is returned\n\u003c/p\u003e",
          "module": "Text.Regex.XMLSchema.String",
          "name": "tokenizeSubexRE",
          "package": "regex-xmlschema",
          "signature": "GenRegex l -\u003e String -\u003e [(l, String)]",
          "source": "src/Text-Regex-XMLSchema-String.html#tokenizeSubexRE",
          "type": "function"
        },
        "index": {
          "description": "split string into tokens pair of labels and words by giving regular expression containing labeled subexpressions This function should not be called with regular expressions without any labeled subexpressions This does not make sense because the result list will always be empty Result is the list of matching subexpressions This can be used for simple tokenizers At least one char is consumed by parsing token The pairs in the result list contain the matching substrings All none matching chars are discarded If the given regex contains syntax errors Nothing is returned",
          "hierarchy": "Text Regex XMLSchema String",
          "module": "Text.Regex.XMLSchema.String",
          "name": "tokenizeSubexRE",
          "normalized": "GenRegex a-\u003eString-\u003e[(a,String)]",
          "package": "regex-xmlschema",
          "partial": "Subex RE",
          "signature": "GenRegex l-\u003eString-\u003e[(l,String)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-xmlschema/docs/Text-Regex-XMLSchema-String.html#v:tokenizeSubexRE"
      }
    }
  ]
]