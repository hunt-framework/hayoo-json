[
  {
    "cmd": "delete-by-query",
    "query": {
      "contexts": [
        "package"
      ],
      "query": {
        "op": "case",
        "type": "word",
        "word": "gf"
      },
      "type": "context"
    }
  },
  [
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module is an Application Programming Interface to \n load and interpret grammars compiled in Portable Grammar Format (PGF).\n The PGF format is produced as a final output from the GF compiler.\n The API is meant to be used for embedding GF grammars in Haskell \n programs\n\u003c/p\u003e\u003c/div\u003e",
          "module": "PGF",
          "name": "PGF",
          "package": "gf",
          "source": "src/PGF.html",
          "type": "module"
        },
        "index": {
          "description": "This module is an Application Programming Interface to load and interpret grammars compiled in Portable Grammar Format PGF The PGF format is produced as final output from the GF compiler The API is meant to be used for embedding GF grammars in Haskell programs",
          "hierarchy": "PGF",
          "module": "PGF",
          "name": "PGF",
          "package": "gf",
          "partial": "PGF",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/gf/docs/PGF.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "PGF",
          "name": "Analysis",
          "package": "gf",
          "source": "src/PGF-Morphology.html#Analysis",
          "type": "type"
        },
        "index": {
          "hierarchy": "PGF",
          "module": "PGF",
          "name": "Analysis",
          "package": "gf",
          "partial": "Analysis",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/gf/docs/PGF.html#t:Analysis"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eBracketedString represents a sentence that is linearized\n as usual but we also want to retain the ''brackets'' that\n mark the beginning and the end of each constituent.\n\u003c/p\u003e",
          "module": "PGF",
          "name": "BracketedString",
          "package": "gf",
          "source": "src/PGF-Macros.html#BracketedString",
          "type": "data"
        },
        "index": {
          "description": "BracketedString represents sentence that is linearized as usual but we also want to retain the brackets that mark the beginning and the end of each constituent",
          "hierarchy": "PGF",
          "module": "PGF",
          "name": "BracketedString",
          "package": "gf",
          "partial": "Bracketed String",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/gf/docs/PGF.html#t:BracketedString"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn abstract data type that represents\n identifiers for functions and categories in PGF.\n\u003c/p\u003e",
          "module": "PGF",
          "name": "CId",
          "package": "gf",
          "source": "src/PGF-CId.html#CId",
          "type": "data"
        },
        "index": {
          "description": "An abstract data type that represents identifiers for functions and categories in PGF",
          "hierarchy": "PGF",
          "module": "PGF",
          "name": "CId",
          "package": "gf",
          "partial": "CId",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/gf/docs/PGF.html#t:CId"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn expression in the abstract syntax of the grammar. It could be\n both parameter of a dependent type or an abstract syntax tree for\n for some sentence.\n\u003c/p\u003e",
          "module": "PGF",
          "name": "Expr",
          "package": "gf",
          "source": "src/PGF-Expr.html#Expr",
          "type": "data"
        },
        "index": {
          "description": "An expression in the abstract syntax of the grammar It could be both parameter of dependent type or an abstract syntax tree for for some sentence",
          "hierarchy": "PGF",
          "module": "PGF",
          "name": "Expr",
          "package": "gf",
          "partial": "Expr",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/gf/docs/PGF.html#t:Expr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "PGF",
          "name": "FId",
          "package": "gf",
          "source": "src/PGF-Data.html#FId",
          "type": "type"
        },
        "index": {
          "hierarchy": "PGF",
          "module": "PGF",
          "name": "FId",
          "package": "gf",
          "partial": "FId",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/gf/docs/PGF.html#t:FId"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "PGF",
          "name": "GraphvizOptions",
          "package": "gf",
          "source": "src/PGF-VisualizeTree.html#GraphvizOptions",
          "type": "data"
        },
        "index": {
          "hierarchy": "PGF",
          "module": "PGF",
          "name": "GraphvizOptions",
          "package": "gf",
          "partial": "Graphviz Options",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/gf/docs/PGF.html#t:GraphvizOptions"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eHypo\u003c/a\u003e\u003c/code\u003e represents a hypothesis in a type i.e. in the type A -\u003e B, A is the hypothesis\n\u003c/p\u003e",
          "module": "PGF",
          "name": "Hypo",
          "package": "gf",
          "source": "src/PGF-Type.html#Hypo",
          "type": "type"
        },
        "index": {
          "description": "Hypo represents hypothesis in type i.e in the type is the hypothesis",
          "hierarchy": "PGF",
          "module": "PGF",
          "name": "Hypo",
          "package": "gf",
          "partial": "Hypo",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/gf/docs/PGF.html#t:Hypo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "PGF",
          "name": "LIndex",
          "package": "gf",
          "source": "src/PGF-Data.html#LIndex",
          "type": "type"
        },
        "index": {
          "hierarchy": "PGF",
          "module": "PGF",
          "name": "LIndex",
          "package": "gf",
          "partial": "LIndex",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/gf/docs/PGF.html#t:LIndex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis is just a \u003ccode\u003e\u003ca\u003eCId\u003c/a\u003e\u003c/code\u003e with the language name.\n A language name is the identifier that you write in the \n top concrete or abstract module in GF after the \n concrete/abstract keyword. Example:\n\u003c/p\u003e\u003cpre\u003e abstract Lang = ...\n concrete LangEng of Lang = ...\n\u003c/pre\u003e",
          "module": "PGF",
          "name": "Language",
          "package": "gf",
          "source": "src/PGF-Data.html#Language",
          "type": "type"
        },
        "index": {
          "description": "This is just CId with the language name language name is the identifier that you write in the top concrete or abstract module in GF after the concrete abstract keyword Example abstract Lang concrete LangEng of Lang",
          "hierarchy": "PGF",
          "module": "PGF",
          "name": "Language",
          "package": "gf",
          "partial": "Language",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/gf/docs/PGF.html#t:Language"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "PGF",
          "name": "Lemma",
          "package": "gf",
          "source": "src/PGF-Morphology.html#Lemma",
          "type": "type"
        },
        "index": {
          "hierarchy": "PGF",
          "module": "PGF",
          "name": "Lemma",
          "package": "gf",
          "partial": "Lemma",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/gf/docs/PGF.html#t:Lemma"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "PGF",
          "name": "Morpho",
          "package": "gf",
          "source": "src/PGF-Morphology.html#Morpho",
          "type": "data"
        },
        "index": {
          "hierarchy": "PGF",
          "module": "PGF",
          "name": "Morpho",
          "package": "gf",
          "partial": "Morpho",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/gf/docs/PGF.html#t:Morpho"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn abstract data type representing multilingual grammar\n in Portable Grammar Format.\n\u003c/p\u003e",
          "module": "PGF",
          "name": "PGF",
          "package": "gf",
          "source": "src/PGF-Data.html#PGF",
          "type": "data"
        },
        "index": {
          "description": "An abstract data type representing multilingual grammar in Portable Grammar Format",
          "hierarchy": "PGF",
          "module": "PGF",
          "name": "PGF",
          "package": "gf",
          "partial": "PGF",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/gf/docs/PGF.html#t:PGF"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe input to the parser is a pair of predicates. The first one\n \u003ccode\u003e\u003ca\u003epiToken\u003c/a\u003e\u003c/code\u003e selects a token from a list of suggestions from the grammar,\n actually appears at the current position in the input string.\n The second one \u003ccode\u003e\u003ca\u003epiLiteral\u003c/a\u003e\u003c/code\u003e recognizes whether a literal with forest id \u003ccode\u003e\u003ca\u003eFId\u003c/a\u003e\u003c/code\u003e\n could be matched at the current position.\n\u003c/p\u003e",
          "module": "PGF",
          "name": "ParseInput",
          "package": "gf",
          "source": "src/PGF-Parse.html#ParseInput",
          "type": "data"
        },
        "index": {
          "description": "The input to the parser is pair of predicates The first one piToken selects token from list of suggestions from the grammar actually appears at the current position in the input string The second one piLiteral recognizes whether literal with forest id FId could be matched at the current position",
          "hierarchy": "PGF",
          "module": "PGF",
          "name": "ParseInput",
          "package": "gf",
          "partial": "Parse Input",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/gf/docs/PGF.html#t:ParseInput"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis data type encodes the different outcomes which you could get from the parser.\n\u003c/p\u003e",
          "module": "PGF",
          "name": "ParseOutput",
          "package": "gf",
          "source": "src/PGF-Parse.html#ParseOutput",
          "type": "data"
        },
        "index": {
          "description": "This data type encodes the different outcomes which you could get from the parser",
          "hierarchy": "PGF",
          "module": "PGF",
          "name": "ParseOutput",
          "package": "gf",
          "partial": "Parse Output",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/gf/docs/PGF.html#t:ParseOutput"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn abstract data type whose values represent\n the current state in an incremental parser.\n\u003c/p\u003e",
          "module": "PGF",
          "name": "ParseState",
          "package": "gf",
          "source": "src/PGF-Parse.html#ParseState",
          "type": "data"
        },
        "index": {
          "description": "An abstract data type whose values represent the current state in an incremental parser",
          "hierarchy": "PGF",
          "module": "PGF",
          "name": "ParseState",
          "package": "gf",
          "partial": "Parse State",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/gf/docs/PGF.html#t:ParseState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn abstract data structure which represents\n the probabilities for the different functions in a grammar.\n\u003c/p\u003e",
          "module": "PGF",
          "name": "Probabilities",
          "package": "gf",
          "source": "src/PGF-Probabilistic.html#Probabilities",
          "type": "data"
        },
        "index": {
          "description": "An abstract data structure which represents the probabilities for the different functions in grammar",
          "hierarchy": "PGF",
          "module": "PGF",
          "name": "Probabilities",
          "package": "gf",
          "partial": "Probabilities",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/gf/docs/PGF.html#t:Probabilities"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIf an error occurs in the typechecking phase\n the type checker returns not a plain text error message\n but a \u003ccode\u003e\u003ca\u003eTcError\u003c/a\u003e\u003c/code\u003e structure which describes the error.\n\u003c/p\u003e",
          "module": "PGF",
          "name": "TcError",
          "package": "gf",
          "source": "src/PGF-TypeCheck.html#TcError",
          "type": "data"
        },
        "index": {
          "description": "If an error occurs in the typechecking phase the type checker returns not plain text error message but TcError structure which describes the error",
          "hierarchy": "PGF",
          "module": "PGF",
          "name": "TcError",
          "package": "gf",
          "partial": "Tc Error",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/gf/docs/PGF.html#t:TcError"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "PGF",
          "name": "Token",
          "package": "gf",
          "source": "src/PGF-Data.html#Token",
          "type": "type"
        },
        "index": {
          "hierarchy": "PGF",
          "module": "PGF",
          "name": "Token",
          "package": "gf",
          "partial": "Token",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/gf/docs/PGF.html#t:Token"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTree is the abstract syntax representation of a given sentence\n in some concrete syntax. Technically \u003ccode\u003e\u003ca\u003eTree\u003c/a\u003e\u003c/code\u003e is a type synonym\n of \u003ccode\u003e\u003ca\u003eExpr\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "PGF",
          "name": "Tree",
          "package": "gf",
          "source": "src/PGF-Expr.html#Tree",
          "type": "type"
        },
        "index": {
          "description": "Tree is the abstract syntax representation of given sentence in some concrete syntax Technically Tree is type synonym of Expr",
          "hierarchy": "PGF",
          "module": "PGF",
          "name": "Tree",
          "package": "gf",
          "partial": "Tree",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/gf/docs/PGF.html#t:Tree"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTo read a type from a \u003ccode\u003e\u003ca\u003eString\u003c/a\u003e\u003c/code\u003e, use \u003ccode\u003e\u003ca\u003ereadType\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "PGF",
          "name": "Type",
          "package": "gf",
          "source": "src/PGF-Type.html#Type",
          "type": "data"
        },
        "index": {
          "description": "To read type from String use readType",
          "hierarchy": "PGF",
          "module": "PGF",
          "name": "Type",
          "package": "gf",
          "partial": "Type",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/gf/docs/PGF.html#t:Type"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ethis is a bracket. The \u003ccode\u003e\u003ca\u003eCId\u003c/a\u003e\u003c/code\u003e is the category of\n the phrase. The \u003ccode\u003e\u003ca\u003eFId\u003c/a\u003e\u003c/code\u003e is an unique identifier for\n every phrase in the sentence. For context-free grammars\n i.e. without discontinuous constituents this identifier\n is also unique for every bracket. When there are discontinuous \n phrases then the identifiers are unique for every phrase but\n not for every bracket since the bracket represents a constituent.\n The different constituents could still be distinguished by using\n the constituent index i.e. \u003ccode\u003e\u003ca\u003eLIndex\u003c/a\u003e\u003c/code\u003e. If the grammar is reduplicating\n then the constituent indices will be the same for all brackets\n that represents the same constituent.\n\u003c/p\u003e",
          "module": "PGF",
          "name": "Bracket",
          "package": "gf",
          "signature": "Bracket CId !FId !LIndex CId [Expr] [BracketedString]",
          "source": "src/PGF-Macros.html#BracketedString",
          "type": "function"
        },
        "index": {
          "description": "this is bracket The CId is the category of the phrase The FId is an unique identifier for every phrase in the sentence For context-free grammars i.e without discontinuous constituents this identifier is also unique for every bracket When there are discontinuous phrases then the identifiers are unique for every phrase but not for every bracket since the bracket represents constituent The different constituents could still be distinguished by using the constituent index i.e LIndex If the grammar is reduplicating then the constituent indices will be the same for all brackets that represents the same constituent",
          "hierarchy": "PGF",
          "module": "PGF",
          "name": "Bracket",
          "normalized": "Bracket CId FId LIndex CId[Expr][BracketedString]",
          "package": "gf",
          "partial": "Bracket",
          "signature": "Bracket CId FId LIndex CId[Expr][BracketedString]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/gf/docs/PGF.html#v:Bracket"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIt is not possible to infer the type of an expression.\n\u003c/p\u003e",
          "module": "PGF",
          "name": "CannotInferType",
          "package": "gf",
          "signature": "CannotInferType [CId] Expr",
          "source": "src/PGF-TypeCheck.html#TcError",
          "type": "function"
        },
        "index": {
          "description": "It is not possible to infer the type of an expression",
          "hierarchy": "PGF",
          "module": "PGF",
          "name": "CannotInferType",
          "normalized": "CannotInferType[CId]Expr",
          "package": "gf",
          "partial": "Cannot Infer Type",
          "signature": "CannotInferType[CId]Expr",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/gf/docs/PGF.html#v:CannotInferType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "PGF",
          "name": "GraphvizOptions",
          "package": "gf",
          "signature": "GraphvizOptions",
          "source": "src/PGF-VisualizeTree.html#GraphvizOptions",
          "type": "function"
        },
        "index": {
          "hierarchy": "PGF",
          "module": "PGF",
          "name": "GraphvizOptions",
          "package": "gf",
          "partial": "Graphviz Options",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/gf/docs/PGF.html#v:GraphvizOptions"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ethis is the leaf i.e. a single token\n\u003c/p\u003e",
          "module": "PGF",
          "name": "Leaf",
          "package": "gf",
          "signature": "Leaf Token",
          "source": "src/PGF-Macros.html#BracketedString",
          "type": "function"
        },
        "index": {
          "description": "this is the leaf i.e single token",
          "hierarchy": "PGF",
          "module": "PGF",
          "name": "Leaf",
          "package": "gf",
          "partial": "Leaf",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/gf/docs/PGF.html#v:Leaf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSomething that is not of function type was applied to an argument.\n\u003c/p\u003e",
          "module": "PGF",
          "name": "NotFunType",
          "package": "gf",
          "signature": "NotFunType [CId] Expr Type",
          "source": "src/PGF-TypeCheck.html#TcError",
          "type": "function"
        },
        "index": {
          "description": "Something that is not of function type was applied to an argument",
          "hierarchy": "PGF",
          "module": "PGF",
          "name": "NotFunType",
          "normalized": "NotFunType[CId]Expr Type",
          "package": "gf",
          "partial": "Not Fun Type",
          "signature": "NotFunType[CId]Expr Type",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/gf/docs/PGF.html#v:NotFunType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe integer is the position in number of tokens where the parser failed.\n\u003c/p\u003e",
          "module": "PGF",
          "name": "ParseFailed",
          "package": "gf",
          "signature": "ParseFailed Int",
          "source": "src/PGF-Parse.html#ParseOutput",
          "type": "function"
        },
        "index": {
          "description": "The integer is the position in number of tokens where the parser failed",
          "hierarchy": "PGF",
          "module": "PGF",
          "name": "ParseFailed",
          "package": "gf",
          "partial": "Parse Failed",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/gf/docs/PGF.html#v:ParseFailed"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe sentence is not complete. Only partial output is produced\n\u003c/p\u003e",
          "module": "PGF",
          "name": "ParseIncomplete",
          "package": "gf",
          "signature": "ParseIncomplete",
          "source": "src/PGF-Parse.html#ParseOutput",
          "type": "function"
        },
        "index": {
          "description": "The sentence is not complete Only partial output is produced",
          "hierarchy": "PGF",
          "module": "PGF",
          "name": "ParseIncomplete",
          "package": "gf",
          "partial": "Parse Incomplete",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/gf/docs/PGF.html#v:ParseIncomplete"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "PGF",
          "name": "ParseInput",
          "package": "gf",
          "signature": "ParseInput",
          "source": "src/PGF-Parse.html#ParseInput",
          "type": "function"
        },
        "index": {
          "hierarchy": "PGF",
          "module": "PGF",
          "name": "ParseInput",
          "package": "gf",
          "partial": "Parse Input",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/gf/docs/PGF.html#v:ParseInput"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIf the parsing and the type checking are successful we get a list of abstract syntax trees.\n The list should be non-empty.\n\u003c/p\u003e",
          "module": "PGF",
          "name": "ParseOk",
          "package": "gf",
          "signature": "ParseOk [Tree]",
          "source": "src/PGF-Parse.html#ParseOutput",
          "type": "function"
        },
        "index": {
          "description": "If the parsing and the type checking are successful we get list of abstract syntax trees The list should be non-empty",
          "hierarchy": "PGF",
          "module": "PGF",
          "name": "ParseOk",
          "normalized": "ParseOk[Tree]",
          "package": "gf",
          "partial": "Parse Ok",
          "signature": "ParseOk[Tree]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/gf/docs/PGF.html#v:ParseOk"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe parsing was successful but none of the trees is type correct. \n The forest id (\u003ccode\u003e\u003ca\u003eFId\u003c/a\u003e\u003c/code\u003e) points to the bracketed string from the parser\n where the type checking failed. More than one error is returned\n if there are many analizes for some phrase but they all are not type correct.\n\u003c/p\u003e",
          "module": "PGF",
          "name": "TypeError",
          "package": "gf",
          "signature": "TypeError [(FId, TcError)]",
          "source": "src/PGF-Parse.html#ParseOutput",
          "type": "function"
        },
        "index": {
          "description": "The parsing was successful but none of the trees is type correct The forest id FId points to the bracketed string from the parser where the type checking failed More than one error is returned if there are many analizes for some phrase but they all are not type correct",
          "hierarchy": "PGF",
          "module": "PGF",
          "name": "TypeError",
          "normalized": "TypeError[(FId,TcError)]",
          "package": "gf",
          "partial": "Type Error",
          "signature": "TypeError[(FId,TcError)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/gf/docs/PGF.html#v:TypeError"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe expression is not of the expected type.\n The first type is the expected type, while\n the second is the inferred. The \u003ccode\u003e[CId]\u003c/code\u003e argument is the list\n of free variables in both the expression and the type. \n It should be used for the \u003ccode\u003e\u003ca\u003eshowType\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003eshowExpr\u003c/a\u003e\u003c/code\u003e functions.\n\u003c/p\u003e",
          "module": "PGF",
          "name": "TypeMismatch",
          "package": "gf",
          "signature": "TypeMismatch [CId] Expr Type Type",
          "source": "src/PGF-TypeCheck.html#TcError",
          "type": "function"
        },
        "index": {
          "description": "The expression is not of the expected type The first type is the expected type while the second is the inferred The CId argument is the list of free variables in both the expression and the type It should be used for the showType and showExpr functions",
          "hierarchy": "PGF",
          "module": "PGF",
          "name": "TypeMismatch",
          "normalized": "TypeMismatch[CId]Expr Type Type",
          "package": "gf",
          "partial": "Type Mismatch",
          "signature": "TypeMismatch[CId]Expr Type Type",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/gf/docs/PGF.html#v:TypeMismatch"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eImplicit argument was passed where the type doesn't allow it\n\u003c/p\u003e",
          "module": "PGF",
          "name": "UnexpectedImplArg",
          "package": "gf",
          "signature": "UnexpectedImplArg [CId] Expr",
          "source": "src/PGF-TypeCheck.html#TcError",
          "type": "function"
        },
        "index": {
          "description": "Implicit argument was passed where the type doesn allow it",
          "hierarchy": "PGF",
          "module": "PGF",
          "name": "UnexpectedImplArg",
          "normalized": "UnexpectedImplArg[CId]Expr",
          "package": "gf",
          "partial": "Unexpected Impl Arg",
          "signature": "UnexpectedImplArg[CId]Expr",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/gf/docs/PGF.html#v:UnexpectedImplArg"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUnknown category name was found.\n\u003c/p\u003e",
          "module": "PGF",
          "name": "UnknownCat",
          "package": "gf",
          "signature": "UnknownCat CId",
          "source": "src/PGF-TypeCheck.html#TcError",
          "type": "function"
        },
        "index": {
          "description": "Unknown category name was found",
          "hierarchy": "PGF",
          "module": "PGF",
          "name": "UnknownCat",
          "package": "gf",
          "partial": "Unknown Cat",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/gf/docs/PGF.html#v:UnknownCat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUnknown function name was found.\n\u003c/p\u003e",
          "module": "PGF",
          "name": "UnknownFun",
          "package": "gf",
          "signature": "UnknownFun CId",
          "source": "src/PGF-TypeCheck.html#TcError",
          "type": "function"
        },
        "index": {
          "description": "Unknown function name was found",
          "hierarchy": "PGF",
          "module": "PGF",
          "name": "UnknownFun",
          "package": "gf",
          "partial": "Unknown Fun",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/gf/docs/PGF.html#v:UnknownFun"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSome metavariables have to be instantiated in order to complete the typechecking.\n\u003c/p\u003e",
          "module": "PGF",
          "name": "UnresolvedMetaVars",
          "package": "gf",
          "signature": "UnresolvedMetaVars [CId] Expr [MetaId]",
          "source": "src/PGF-TypeCheck.html#TcError",
          "type": "function"
        },
        "index": {
          "description": "Some metavariables have to be instantiated in order to complete the typechecking",
          "hierarchy": "PGF",
          "module": "PGF",
          "name": "UnresolvedMetaVars",
          "normalized": "UnresolvedMetaVars[CId]Expr[MetaId]",
          "package": "gf",
          "partial": "Unresolved Meta Vars",
          "signature": "UnresolvedMetaVars[CId]Expr[MetaId]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/gf/docs/PGF.html#v:UnresolvedMetaVars"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThere is a goal that cannot be solved\n\u003c/p\u003e",
          "module": "PGF",
          "name": "UnsolvableGoal",
          "package": "gf",
          "signature": "UnsolvableGoal [CId] MetaId Type",
          "source": "src/PGF-TypeCheck.html#TcError",
          "type": "function"
        },
        "index": {
          "description": "There is goal that cannot be solved",
          "hierarchy": "PGF",
          "module": "PGF",
          "name": "UnsolvableGoal",
          "normalized": "UnsolvableGoal[CId]MetaId Type",
          "package": "gf",
          "partial": "Unsolvable Goal",
          "signature": "UnsolvableGoal[CId]MetaId Type",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/gf/docs/PGF.html#v:UnsolvableGoal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA category was applied to wrong number of arguments.\n The first integer is the number of expected arguments and\n the second the number of given arguments.\n The \u003ccode\u003e[CId]\u003c/code\u003e argument is the list of free variables\n in the type. It should be used for the \u003ccode\u003e\u003ca\u003eshowType\u003c/a\u003e\u003c/code\u003e function.\n\u003c/p\u003e",
          "module": "PGF",
          "name": "WrongCatArgs",
          "package": "gf",
          "signature": "WrongCatArgs [CId] Type CId Int Int",
          "source": "src/PGF-TypeCheck.html#TcError",
          "type": "function"
        },
        "index": {
          "description": "category was applied to wrong number of arguments The first integer is the number of expected arguments and the second the number of given arguments The CId argument is the list of free variables in the type It should be used for the showType function",
          "hierarchy": "PGF",
          "module": "PGF",
          "name": "WrongCatArgs",
          "normalized": "WrongCatArgs[CId]Type CId Int Int",
          "package": "gf",
          "partial": "Wrong Cat Args",
          "signature": "WrongCatArgs[CId]Type CId Int Int",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/gf/docs/PGF.html#v:WrongCatArgs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe abstract language name is the name of the top-level\n abstract module\n\u003c/p\u003e",
          "module": "PGF",
          "name": "abstractName",
          "package": "gf",
          "signature": "PGF -\u003e Language",
          "source": "src/PGF.html#abstractName",
          "type": "function"
        },
        "index": {
          "description": "The abstract language name is the name of the top-level abstract module",
          "hierarchy": "PGF",
          "module": "PGF",
          "name": "abstractName",
          "normalized": "PGF-\u003eLanguage",
          "package": "gf",
          "partial": "Name",
          "signature": "PGF-\u003eLanguage",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/gf/docs/PGF.html#v:abstractName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLinearizes given expression as a bracketed string in the language\n\u003c/p\u003e",
          "module": "PGF",
          "name": "bracketedLinearize",
          "package": "gf",
          "signature": "PGF -\u003e Language -\u003e Tree -\u003e BracketedString",
          "source": "src/PGF-Linearize.html#bracketedLinearize",
          "type": "function"
        },
        "index": {
          "description": "Linearizes given expression as bracketed string in the language",
          "hierarchy": "PGF",
          "module": "PGF",
          "name": "bracketedLinearize",
          "normalized": "PGF-\u003eLanguage-\u003eTree-\u003eBracketedString",
          "package": "gf",
          "partial": "Linearize",
          "signature": "PGF-\u003eLanguage-\u003eTree-\u003eBracketedString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/gf/docs/PGF.html#v:bracketedLinearize"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "PGF",
          "name": "browse",
          "package": "gf",
          "signature": "PGF -\u003e CId -\u003e Maybe (String, [CId], [CId])",
          "source": "src/PGF.html#browse",
          "type": "function"
        },
        "index": {
          "hierarchy": "PGF",
          "module": "PGF",
          "name": "browse",
          "normalized": "PGF-\u003eCId-\u003eMaybe(String,[CId],[CId])",
          "package": "gf",
          "signature": "PGF-\u003eCId-\u003eMaybe(String,[CId],[CId])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/gf/docs/PGF.html#v:browse"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "PGF",
          "name": "buildMorpho",
          "package": "gf",
          "signature": "PGF -\u003e Language -\u003e Morpho",
          "source": "src/PGF-Morphology.html#buildMorpho",
          "type": "function"
        },
        "index": {
          "hierarchy": "PGF",
          "module": "PGF",
          "name": "buildMorpho",
          "normalized": "PGF-\u003eLanguage-\u003eMorpho",
          "package": "gf",
          "partial": "Morpho",
          "signature": "PGF-\u003eLanguage-\u003eMorpho",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/gf/docs/PGF.html#v:buildMorpho"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eList of all categories defined in the given grammar.\n The categories are defined in the abstract syntax\n with the 'cat' keyword.\n\u003c/p\u003e",
          "module": "PGF",
          "name": "categories",
          "package": "gf",
          "signature": "PGF -\u003e [CId]",
          "source": "src/PGF.html#categories",
          "type": "function"
        },
        "index": {
          "description": "List of all categories defined in the given grammar The categories are defined in the abstract syntax with the cat keyword",
          "hierarchy": "PGF",
          "module": "PGF",
          "name": "categories",
          "normalized": "PGF-\u003e[CId]",
          "package": "gf",
          "signature": "PGF-\u003e[CId]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/gf/docs/PGF.html#v:categories"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eChecks an expression against a specified type.\n\u003c/p\u003e",
          "module": "PGF",
          "name": "checkExpr",
          "package": "gf",
          "signature": "PGF -\u003e Expr -\u003e Type -\u003e Either TcError Expr",
          "source": "src/PGF-TypeCheck.html#checkExpr",
          "type": "function"
        },
        "index": {
          "description": "Checks an expression against specified type",
          "hierarchy": "PGF",
          "module": "PGF",
          "name": "checkExpr",
          "normalized": "PGF-\u003eExpr-\u003eType-\u003eEither TcError Expr",
          "package": "gf",
          "partial": "Expr",
          "signature": "PGF-\u003eExpr-\u003eType-\u003eEither TcError Expr",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/gf/docs/PGF.html#v:checkExpr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCheck whether a given type is consistent with the abstract\n syntax of the grammar.\n\u003c/p\u003e",
          "module": "PGF",
          "name": "checkType",
          "package": "gf",
          "signature": "PGF -\u003e Type -\u003e Either TcError Type",
          "source": "src/PGF-TypeCheck.html#checkType",
          "type": "function"
        },
        "index": {
          "description": "Check whether given type is consistent with the abstract syntax of the grammar",
          "hierarchy": "PGF",
          "module": "PGF",
          "name": "checkType",
          "normalized": "PGF-\u003eType-\u003eEither TcError Type",
          "package": "gf",
          "partial": "Type",
          "signature": "PGF-\u003eType-\u003eEither TcError Type",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/gf/docs/PGF.html#v:checkType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConverts an expression to normal form\n\u003c/p\u003e",
          "module": "PGF",
          "name": "compute",
          "package": "gf",
          "signature": "PGF -\u003e Expr -\u003e Expr",
          "source": "src/PGF.html#compute",
          "type": "function"
        },
        "index": {
          "description": "Converts an expression to normal form",
          "hierarchy": "PGF",
          "module": "PGF",
          "name": "compute",
          "normalized": "PGF-\u003eExpr-\u003eExpr",
          "package": "gf",
          "signature": "PGF-\u003eExpr-\u003eExpr",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/gf/docs/PGF.html#v:compute"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturns the default even distibution.\n\u003c/p\u003e",
          "module": "PGF",
          "name": "defaultProbabilities",
          "package": "gf",
          "signature": "PGF -\u003e Probabilities",
          "source": "src/PGF-Probabilistic.html#defaultProbabilities",
          "type": "function"
        },
        "index": {
          "description": "Returns the default even distibution",
          "hierarchy": "PGF",
          "module": "PGF",
          "name": "defaultProbabilities",
          "normalized": "PGF-\u003eProbabilities",
          "package": "gf",
          "partial": "Probabilities",
          "signature": "PGF-\u003eProbabilities",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/gf/docs/PGF.html#v:defaultProbabilities"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "PGF",
          "name": "flattenBracketedString",
          "package": "gf",
          "signature": "BracketedString -\u003e [String]",
          "source": "src/PGF-Macros.html#flattenBracketedString",
          "type": "function"
        },
        "index": {
          "hierarchy": "PGF",
          "module": "PGF",
          "name": "flattenBracketedString",
          "normalized": "BracketedString-\u003e[String]",
          "package": "gf",
          "partial": "Bracketed String",
          "signature": "BracketedString-\u003e[String]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/gf/docs/PGF.html#v:flattenBracketedString"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "PGF",
          "name": "fullFormLexicon",
          "package": "gf",
          "signature": "Morpho -\u003e [(String, [(Lemma, Analysis)])]",
          "source": "src/PGF-Morphology.html#fullFormLexicon",
          "type": "function"
        },
        "index": {
          "hierarchy": "PGF",
          "module": "PGF",
          "name": "fullFormLexicon",
          "normalized": "Morpho-\u003e[(String,[(Lemma,Analysis)])]",
          "package": "gf",
          "partial": "Form Lexicon",
          "signature": "Morpho-\u003e[(String,[(Lemma,Analysis)])]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/gf/docs/PGF.html#v:fullFormLexicon"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe type of a given function\n\u003c/p\u003e",
          "module": "PGF",
          "name": "functionType",
          "package": "gf",
          "signature": "PGF -\u003e CId -\u003e Maybe Type",
          "source": "src/PGF.html#functionType",
          "type": "function"
        },
        "index": {
          "description": "The type of given function",
          "hierarchy": "PGF",
          "module": "PGF",
          "name": "functionType",
          "normalized": "PGF-\u003eCId-\u003eMaybe Type",
          "package": "gf",
          "partial": "Type",
          "signature": "PGF-\u003eCId-\u003eMaybe Type",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/gf/docs/PGF.html#v:functionType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eList of all functions defined in the abstract syntax\n\u003c/p\u003e",
          "module": "PGF",
          "name": "functions",
          "package": "gf",
          "signature": "PGF -\u003e [CId]",
          "source": "src/PGF.html#functions",
          "type": "function"
        },
        "index": {
          "description": "List of all functions defined in the abstract syntax",
          "hierarchy": "PGF",
          "module": "PGF",
          "name": "functions",
          "normalized": "PGF-\u003e[CId]",
          "package": "gf",
          "signature": "PGF-\u003e[CId]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/gf/docs/PGF.html#v:functions"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eList of all functions defined for a given category\n\u003c/p\u003e",
          "module": "PGF",
          "name": "functionsByCat",
          "package": "gf",
          "signature": "PGF -\u003e CId -\u003e [CId]",
          "source": "src/PGF.html#functionsByCat",
          "type": "function"
        },
        "index": {
          "description": "List of all functions defined for given category",
          "hierarchy": "PGF",
          "module": "PGF",
          "name": "functionsByCat",
          "normalized": "PGF-\u003eCId-\u003e[CId]",
          "package": "gf",
          "partial": "By Cat",
          "signature": "PGF-\u003eCId-\u003e[CId]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/gf/docs/PGF.html#v:functionsByCat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGenerates an exhaustive possibly infinite list of\n abstract syntax expressions.\n\u003c/p\u003e",
          "module": "PGF",
          "name": "generateAll",
          "package": "gf",
          "signature": "PGF -\u003e Type -\u003e [Expr]",
          "source": "src/PGF-Generate.html#generateAll",
          "type": "function"
        },
        "index": {
          "description": "Generates an exhaustive possibly infinite list of abstract syntax expressions",
          "hierarchy": "PGF",
          "module": "PGF",
          "name": "generateAll",
          "normalized": "PGF-\u003eType-\u003e[Expr]",
          "package": "gf",
          "partial": "All",
          "signature": "PGF-\u003eType-\u003e[Expr]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/gf/docs/PGF.html#v:generateAll"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA variant of \u003ccode\u003e\u003ca\u003egenerateAll\u003c/a\u003e\u003c/code\u003e which also takes as argument\n the upper limit of the depth of the generated expression.\n\u003c/p\u003e",
          "module": "PGF",
          "name": "generateAllDepth",
          "package": "gf",
          "signature": "PGF -\u003e Type -\u003e Maybe Int -\u003e [Expr]",
          "source": "src/PGF-Generate.html#generateAllDepth",
          "type": "function"
        },
        "index": {
          "description": "variant of generateAll which also takes as argument the upper limit of the depth of the generated expression",
          "hierarchy": "PGF",
          "module": "PGF",
          "name": "generateAllDepth",
          "normalized": "PGF-\u003eType-\u003eMaybe Int-\u003e[Expr]",
          "package": "gf",
          "partial": "All Depth",
          "signature": "PGF-\u003eType-\u003eMaybe Int-\u003e[Expr]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/gf/docs/PGF.html#v:generateAllDepth"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGenerates a list of abstract syntax expressions\n in a way similar to \u003ccode\u003e\u003ca\u003egenerateAll\u003c/a\u003e\u003c/code\u003e but instead of\n generating all instances of a given type, this\n function uses a template. \n\u003c/p\u003e",
          "module": "PGF",
          "name": "generateFrom",
          "package": "gf",
          "signature": "PGF -\u003e Expr -\u003e [Expr]",
          "source": "src/PGF-Generate.html#generateFrom",
          "type": "function"
        },
        "index": {
          "description": "Generates list of abstract syntax expressions in way similar to generateAll but instead of generating all instances of given type this function uses template",
          "hierarchy": "PGF",
          "module": "PGF",
          "name": "generateFrom",
          "normalized": "PGF-\u003eExpr-\u003e[Expr]",
          "package": "gf",
          "partial": "From",
          "signature": "PGF-\u003eExpr-\u003e[Expr]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/gf/docs/PGF.html#v:generateFrom"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA variant of \u003ccode\u003e\u003ca\u003egenerateFrom\u003c/a\u003e\u003c/code\u003e which also takes as argument\n the upper limit of the depth of the generated subexpressions.\n\u003c/p\u003e",
          "module": "PGF",
          "name": "generateFromDepth",
          "package": "gf",
          "signature": "PGF -\u003e Expr -\u003e Maybe Int -\u003e [Expr]",
          "source": "src/PGF-Generate.html#generateFromDepth",
          "type": "function"
        },
        "index": {
          "description": "variant of generateFrom which also takes as argument the upper limit of the depth of the generated subexpressions",
          "hierarchy": "PGF",
          "module": "PGF",
          "name": "generateFromDepth",
          "normalized": "PGF-\u003eExpr-\u003eMaybe Int-\u003e[Expr]",
          "package": "gf",
          "partial": "From Depth",
          "signature": "PGF-\u003eExpr-\u003eMaybe Int-\u003e[Expr]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/gf/docs/PGF.html#v:generateFromDepth"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGenerates an infinite list of random abstract syntax expressions.\n This is usefull for tree bank generation which after that can be used\n for grammar testing.\n\u003c/p\u003e",
          "module": "PGF",
          "name": "generateRandom",
          "package": "gf",
          "signature": "g -\u003e PGF -\u003e Type -\u003e [Expr]",
          "source": "src/PGF-Generate.html#generateRandom",
          "type": "function"
        },
        "index": {
          "description": "Generates an infinite list of random abstract syntax expressions This is usefull for tree bank generation which after that can be used for grammar testing",
          "hierarchy": "PGF",
          "module": "PGF",
          "name": "generateRandom",
          "normalized": "a-\u003ePGF-\u003eType-\u003e[Expr]",
          "package": "gf",
          "partial": "Random",
          "signature": "g-\u003ePGF-\u003eType-\u003e[Expr]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/gf/docs/PGF.html#v:generateRandom"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA variant of \u003ccode\u003e\u003ca\u003egenerateRandom\u003c/a\u003e\u003c/code\u003e which also takes as argument\n the upper limit of the depth of the generated expression.\n\u003c/p\u003e",
          "module": "PGF",
          "name": "generateRandomDepth",
          "package": "gf",
          "signature": "g -\u003e PGF -\u003e Type -\u003e Maybe Int -\u003e [Expr]",
          "source": "src/PGF-Generate.html#generateRandomDepth",
          "type": "function"
        },
        "index": {
          "description": "variant of generateRandom which also takes as argument the upper limit of the depth of the generated expression",
          "hierarchy": "PGF",
          "module": "PGF",
          "name": "generateRandomDepth",
          "normalized": "a-\u003ePGF-\u003eType-\u003eMaybe Int-\u003e[Expr]",
          "package": "gf",
          "partial": "Random Depth",
          "signature": "g-\u003ePGF-\u003eType-\u003eMaybe Int-\u003e[Expr]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/gf/docs/PGF.html#v:generateRandomDepth"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRandom generation based on template\n\u003c/p\u003e",
          "module": "PGF",
          "name": "generateRandomFrom",
          "package": "gf",
          "signature": "g -\u003e PGF -\u003e Expr -\u003e [Expr]",
          "source": "src/PGF-Generate.html#generateRandomFrom",
          "type": "function"
        },
        "index": {
          "description": "Random generation based on template",
          "hierarchy": "PGF",
          "module": "PGF",
          "name": "generateRandomFrom",
          "normalized": "a-\u003ePGF-\u003eExpr-\u003e[Expr]",
          "package": "gf",
          "partial": "Random From",
          "signature": "g-\u003ePGF-\u003eExpr-\u003e[Expr]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/gf/docs/PGF.html#v:generateRandomFrom"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRandom generation based on template with a limitation in the depth.\n\u003c/p\u003e",
          "module": "PGF",
          "name": "generateRandomFromDepth",
          "package": "gf",
          "signature": "g -\u003e PGF -\u003e Expr -\u003e Maybe Int -\u003e [Expr]",
          "source": "src/PGF-Generate.html#generateRandomFromDepth",
          "type": "function"
        },
        "index": {
          "description": "Random generation based on template with limitation in the depth",
          "hierarchy": "PGF",
          "module": "PGF",
          "name": "generateRandomFromDepth",
          "normalized": "a-\u003ePGF-\u003eExpr-\u003eMaybe Int-\u003e[Expr]",
          "package": "gf",
          "partial": "Random From Depth",
          "signature": "g-\u003ePGF-\u003eExpr-\u003eMaybe Int-\u003e[Expr]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/gf/docs/PGF.html#v:generateRandomFromDepth"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIf the next token is not known but only its prefix (possible empty prefix)\n then the \u003ccode\u003e\u003ca\u003egetCompletions\u003c/a\u003e\u003c/code\u003e function can be used to calculate the possible\n next words and the consequent states. This is used for word completions in\n the GF interpreter.\n\u003c/p\u003e",
          "module": "PGF",
          "name": "getCompletions",
          "package": "gf",
          "signature": "ParseState -\u003e String -\u003e Map Token ParseState",
          "source": "src/PGF-Parse.html#getCompletions",
          "type": "function"
        },
        "index": {
          "description": "If the next token is not known but only its prefix possible empty prefix then the getCompletions function can be used to calculate the possible next words and the consequent states This is used for word completions in the GF interpreter",
          "hierarchy": "PGF",
          "module": "PGF",
          "name": "getCompletions",
          "normalized": "ParseState-\u003eString-\u003eMap Token ParseState",
          "package": "gf",
          "partial": "Completions",
          "signature": "ParseState-\u003eString-\u003eMap Token ParseState",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/gf/docs/PGF.html#v:getCompletions"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function extracts the list of all completed parse trees\n that spans the whole input consumed so far. The trees are also\n limited by the category specified, which is usually\n the same as the startup category.\n\u003c/p\u003e",
          "module": "PGF",
          "name": "getParseOutput",
          "package": "gf",
          "signature": "ParseState -\u003e Type -\u003e Maybe Int -\u003e (ParseOutput, BracketedString)",
          "source": "src/PGF-Parse.html#getParseOutput",
          "type": "function"
        },
        "index": {
          "description": "This function extracts the list of all completed parse trees that spans the whole input consumed so far The trees are also limited by the category specified which is usually the same as the startup category",
          "hierarchy": "PGF",
          "module": "PGF",
          "name": "getParseOutput",
          "normalized": "ParseState-\u003eType-\u003eMaybe Int-\u003e(ParseOutput,BracketedString)",
          "package": "gf",
          "partial": "Parse Output",
          "signature": "ParseState-\u003eType-\u003eMaybe Int-\u003e(ParseOutput,BracketedString)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/gf/docs/PGF.html#v:getParseOutput"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "PGF",
          "name": "gizaAlignment",
          "package": "gf",
          "signature": "PGF -\u003e (Language, Language) -\u003e Expr -\u003e (String, String, String)",
          "source": "src/PGF-VisualizeTree.html#gizaAlignment",
          "type": "function"
        },
        "index": {
          "hierarchy": "PGF",
          "module": "PGF",
          "name": "gizaAlignment",
          "normalized": "PGF-\u003e(Language,Language)-\u003eExpr-\u003e(String,String,String)",
          "package": "gf",
          "partial": "Alignment",
          "signature": "PGF-\u003e(Language,Language)-\u003eExpr-\u003e(String,String,String)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/gf/docs/PGF.html#v:gizaAlignment"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRenders abstract syntax tree in Graphviz format\n\u003c/p\u003e",
          "module": "PGF",
          "name": "graphvizAbstractTree",
          "package": "gf",
          "signature": "PGF -\u003e (Bool, Bool) -\u003e Tree -\u003e String",
          "source": "src/PGF-VisualizeTree.html#graphvizAbstractTree",
          "type": "function"
        },
        "index": {
          "description": "Renders abstract syntax tree in Graphviz format",
          "hierarchy": "PGF",
          "module": "PGF",
          "name": "graphvizAbstractTree",
          "normalized": "PGF-\u003e(Bool,Bool)-\u003eTree-\u003eString",
          "package": "gf",
          "partial": "Abstract Tree",
          "signature": "PGF-\u003e(Bool,Bool)-\u003eTree-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/gf/docs/PGF.html#v:graphvizAbstractTree"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "PGF",
          "name": "graphvizAlignment",
          "package": "gf",
          "signature": "PGF -\u003e [Language] -\u003e Expr -\u003e String",
          "source": "src/PGF-VisualizeTree.html#graphvizAlignment",
          "type": "function"
        },
        "index": {
          "hierarchy": "PGF",
          "module": "PGF",
          "name": "graphvizAlignment",
          "normalized": "PGF-\u003e[Language]-\u003eExpr-\u003eString",
          "package": "gf",
          "partial": "Alignment",
          "signature": "PGF-\u003e[Language]-\u003eExpr-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/gf/docs/PGF.html#v:graphvizAlignment"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "PGF",
          "name": "graphvizBracketedString",
          "package": "gf",
          "signature": "GraphvizOptions -\u003e BracketedString -\u003e String",
          "source": "src/PGF-VisualizeTree.html#graphvizBracketedString",
          "type": "function"
        },
        "index": {
          "hierarchy": "PGF",
          "module": "PGF",
          "name": "graphvizBracketedString",
          "normalized": "GraphvizOptions-\u003eBracketedString-\u003eString",
          "package": "gf",
          "partial": "Bracketed String",
          "signature": "GraphvizOptions-\u003eBracketedString-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/gf/docs/PGF.html#v:graphvizBracketedString"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "PGF",
          "name": "graphvizDefaults",
          "package": "gf",
          "signature": "GraphvizOptions",
          "source": "src/PGF-VisualizeTree.html#graphvizDefaults",
          "type": "function"
        },
        "index": {
          "hierarchy": "PGF",
          "module": "PGF",
          "name": "graphvizDefaults",
          "package": "gf",
          "partial": "Defaults",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/gf/docs/PGF.html#v:graphvizDefaults"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "PGF",
          "name": "graphvizDependencyTree",
          "package": "gf",
          "signature": "String -\u003e Bool -\u003e Maybe Labels -\u003e Maybe String -\u003e PGF -\u003e CId -\u003e Tree -\u003e String",
          "source": "src/PGF-VisualizeTree.html#graphvizDependencyTree",
          "type": "function"
        },
        "index": {
          "hierarchy": "PGF",
          "module": "PGF",
          "name": "graphvizDependencyTree",
          "normalized": "String-\u003eBool-\u003eMaybe Labels-\u003eMaybe String-\u003ePGF-\u003eCId-\u003eTree-\u003eString",
          "package": "gf",
          "partial": "Dependency Tree",
          "signature": "String-\u003eBool-\u003eMaybe Labels-\u003eMaybe String-\u003ePGF-\u003eCId-\u003eTree-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/gf/docs/PGF.html#v:graphvizDependencyTree"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "PGF",
          "name": "graphvizParseTree",
          "package": "gf",
          "signature": "PGF -\u003e Language -\u003e GraphvizOptions -\u003e Tree -\u003e String",
          "source": "src/PGF-VisualizeTree.html#graphvizParseTree",
          "type": "function"
        },
        "index": {
          "hierarchy": "PGF",
          "module": "PGF",
          "name": "graphvizParseTree",
          "normalized": "PGF-\u003eLanguage-\u003eGraphvizOptions-\u003eTree-\u003eString",
          "package": "gf",
          "partial": "Parse Tree",
          "signature": "PGF-\u003eLanguage-\u003eGraphvizOptions-\u003eTree-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/gf/docs/PGF.html#v:graphvizParseTree"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "PGF",
          "name": "groupResults",
          "package": "gf",
          "signature": "[[(Language, String)]] -\u003e [(Language, [String])]",
          "source": "src/PGF.html#groupResults",
          "type": "function"
        },
        "index": {
          "hierarchy": "PGF",
          "module": "PGF",
          "name": "groupResults",
          "normalized": "[[(Language,String)]]-\u003e[(Language,[String])]",
          "package": "gf",
          "partial": "Results",
          "signature": "[[(Language,String)]]-\u003e[(Language,[String])]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/gf/docs/PGF.html#v:groupResults"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTries to infer the type of a given expression. Note that\n even if the expression is type correct it is not always\n possible to infer its type in the GF type system.\n In this case the function returns the \u003ccode\u003e\u003ca\u003eCannotInferType\u003c/a\u003e\u003c/code\u003e error.\n\u003c/p\u003e",
          "module": "PGF",
          "name": "inferExpr",
          "package": "gf",
          "signature": "PGF -\u003e Expr -\u003e Either TcError (Expr, Type)",
          "source": "src/PGF-TypeCheck.html#inferExpr",
          "type": "function"
        },
        "index": {
          "description": "Tries to infer the type of given expression Note that even if the expression is type correct it is not always possible to infer its type in the GF type system In this case the function returns the CannotInferType error",
          "hierarchy": "PGF",
          "module": "PGF",
          "name": "inferExpr",
          "normalized": "PGF-\u003eExpr-\u003eEither TcError(Expr,Type)",
          "package": "gf",
          "partial": "Expr",
          "signature": "PGF-\u003eExpr-\u003eEither TcError(Expr,Type)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/gf/docs/PGF.html#v:inferExpr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreates an initial parsing state for a given language and\n startup category.\n\u003c/p\u003e",
          "module": "PGF",
          "name": "initState",
          "package": "gf",
          "signature": "PGF -\u003e Language -\u003e Type -\u003e ParseState",
          "source": "src/PGF-Parse.html#initState",
          "type": "function"
        },
        "index": {
          "description": "Creates an initial parsing state for given language and startup category",
          "hierarchy": "PGF",
          "module": "PGF",
          "name": "initState",
          "normalized": "PGF-\u003eLanguage-\u003eType-\u003eParseState",
          "package": "gf",
          "partial": "State",
          "signature": "PGF-\u003eLanguage-\u003eType-\u003eParseState",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/gf/docs/PGF.html#v:initState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGets the RFC 4646 language tag \n of the language which the given concrete syntax implements,\n if this is listed in the source grammar.\n Example language tags include \u003ccode\u003e\"en\"\u003c/code\u003e for English,\n and \u003ccode\u003e\"en-UK\"\u003c/code\u003e for British English.\n\u003c/p\u003e",
          "module": "PGF",
          "name": "languageCode",
          "package": "gf",
          "signature": "PGF -\u003e Language -\u003e Maybe String",
          "source": "src/PGF.html#languageCode",
          "type": "function"
        },
        "index": {
          "description": "Gets the RFC language tag of the language which the given concrete syntax implements if this is listed in the source grammar Example language tags include en for English and en-UK for British English",
          "hierarchy": "PGF",
          "module": "PGF",
          "name": "languageCode",
          "normalized": "PGF-\u003eLanguage-\u003eMaybe String",
          "package": "gf",
          "partial": "Code",
          "signature": "PGF-\u003eLanguage-\u003eMaybe String",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/gf/docs/PGF.html#v:languageCode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eList of all languages available in the given grammar.\n\u003c/p\u003e",
          "module": "PGF",
          "name": "languages",
          "package": "gf",
          "signature": "PGF -\u003e [Language]",
          "source": "src/PGF.html#languages",
          "type": "function"
        },
        "index": {
          "description": "List of all languages available in the given grammar",
          "hierarchy": "PGF",
          "module": "PGF",
          "name": "languages",
          "normalized": "PGF-\u003e[Language]",
          "package": "gf",
          "signature": "PGF-\u003e[Language]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/gf/docs/PGF.html#v:languages"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "PGF",
          "name": "leafColor",
          "package": "gf",
          "signature": "String",
          "source": "src/PGF-VisualizeTree.html#GraphvizOptions",
          "type": "function"
        },
        "index": {
          "hierarchy": "PGF",
          "module": "PGF",
          "name": "leafColor",
          "package": "gf",
          "partial": "Color",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/gf/docs/PGF.html#v:leafColor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "PGF",
          "name": "leafEdgeStyle",
          "package": "gf",
          "signature": "String",
          "source": "src/PGF-VisualizeTree.html#GraphvizOptions",
          "type": "function"
        },
        "index": {
          "hierarchy": "PGF",
          "module": "PGF",
          "name": "leafEdgeStyle",
          "package": "gf",
          "partial": "Edge Style",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/gf/docs/PGF.html#v:leafEdgeStyle"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "PGF",
          "name": "leafFont",
          "package": "gf",
          "signature": "String",
          "source": "src/PGF-VisualizeTree.html#GraphvizOptions",
          "type": "function"
        },
        "index": {
          "hierarchy": "PGF",
          "module": "PGF",
          "name": "leafFont",
          "package": "gf",
          "partial": "Font",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/gf/docs/PGF.html#v:leafFont"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLinearizes given expression as string in the language\n\u003c/p\u003e",
          "module": "PGF",
          "name": "linearize",
          "package": "gf",
          "signature": "PGF -\u003e Language -\u003e Tree -\u003e String",
          "source": "src/PGF-Linearize.html#linearize",
          "type": "function"
        },
        "index": {
          "description": "Linearizes given expression as string in the language",
          "hierarchy": "PGF",
          "module": "PGF",
          "name": "linearize",
          "normalized": "PGF-\u003eLanguage-\u003eTree-\u003eString",
          "package": "gf",
          "signature": "PGF-\u003eLanguage-\u003eTree-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/gf/docs/PGF.html#v:linearize"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe same as \u003ccode\u003e\u003ca\u003elinearizeAllLang\u003c/a\u003e\u003c/code\u003e but does not return\n the language.\n\u003c/p\u003e",
          "module": "PGF",
          "name": "linearizeAll",
          "package": "gf",
          "signature": "PGF -\u003e Tree -\u003e [String]",
          "source": "src/PGF-Linearize.html#linearizeAll",
          "type": "function"
        },
        "index": {
          "description": "The same as linearizeAllLang but does not return the language",
          "hierarchy": "PGF",
          "module": "PGF",
          "name": "linearizeAll",
          "normalized": "PGF-\u003eTree-\u003e[String]",
          "package": "gf",
          "partial": "All",
          "signature": "PGF-\u003eTree-\u003e[String]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/gf/docs/PGF.html#v:linearizeAll"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLinearizes given expression as string in all languages\n available in the grammar.\n\u003c/p\u003e",
          "module": "PGF",
          "name": "linearizeAllLang",
          "package": "gf",
          "signature": "PGF -\u003e Tree -\u003e [(Language, String)]",
          "source": "src/PGF-Linearize.html#linearizeAllLang",
          "type": "function"
        },
        "index": {
          "description": "Linearizes given expression as string in all languages available in the grammar",
          "hierarchy": "PGF",
          "module": "PGF",
          "name": "linearizeAllLang",
          "normalized": "PGF-\u003eTree-\u003e[(Language,String)]",
          "package": "gf",
          "partial": "All Lang",
          "signature": "PGF-\u003eTree-\u003e[(Language,String)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/gf/docs/PGF.html#v:linearizeAllLang"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "PGF",
          "name": "lookupMorpho",
          "package": "gf",
          "signature": "Morpho -\u003e String -\u003e [(Lemma, Analysis)]",
          "source": "src/PGF-Morphology.html#lookupMorpho",
          "type": "function"
        },
        "index": {
          "hierarchy": "PGF",
          "module": "PGF",
          "name": "lookupMorpho",
          "normalized": "Morpho-\u003eString-\u003e[(Lemma,Analysis)]",
          "package": "gf",
          "partial": "Morpho",
          "signature": "Morpho-\u003eString-\u003e[(Lemma,Analysis)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/gf/docs/PGF.html#v:lookupMorpho"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eList of functions that lack linearizations in the given language.\n\u003c/p\u003e",
          "module": "PGF",
          "name": "missingLins",
          "package": "gf",
          "signature": "PGF -\u003e Language -\u003e [CId]",
          "source": "src/PGF-Macros.html#missingLins",
          "type": "function"
        },
        "index": {
          "description": "List of functions that lack linearizations in the given language",
          "hierarchy": "PGF",
          "module": "PGF",
          "name": "missingLins",
          "normalized": "PGF-\u003eLanguage-\u003e[CId]",
          "package": "gf",
          "partial": "Lins",
          "signature": "PGF-\u003eLanguage-\u003e[CId]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/gf/docs/PGF.html#v:missingLins"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "PGF",
          "name": "mkAbs",
          "package": "gf",
          "signature": "BindType -\u003e CId -\u003e Expr -\u003e Expr",
          "source": "src/PGF-Expr.html#mkAbs",
          "type": "function"
        },
        "index": {
          "hierarchy": "PGF",
          "module": "PGF",
          "name": "mkAbs",
          "normalized": "BindType-\u003eCId-\u003eExpr-\u003eExpr",
          "package": "gf",
          "partial": "Abs",
          "signature": "BindType-\u003eCId-\u003eExpr-\u003eExpr",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/gf/docs/PGF.html#v:mkAbs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstructs an expression by applying a function to a list of expressions\n\u003c/p\u003e",
          "module": "PGF",
          "name": "mkApp",
          "package": "gf",
          "signature": "CId -\u003e [Expr] -\u003e Expr",
          "source": "src/PGF-Expr.html#mkApp",
          "type": "function"
        },
        "index": {
          "description": "Constructs an expression by applying function to list of expressions",
          "hierarchy": "PGF",
          "module": "PGF",
          "name": "mkApp",
          "normalized": "CId-\u003e[Expr]-\u003eExpr",
          "package": "gf",
          "partial": "App",
          "signature": "CId-\u003e[Expr]-\u003eExpr",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/gf/docs/PGF.html#v:mkApp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreates a new identifier from \u003ccode\u003e\u003ca\u003eString\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "PGF",
          "name": "mkCId",
          "package": "gf",
          "signature": "String -\u003e CId",
          "source": "src/PGF-CId.html#mkCId",
          "type": "function"
        },
        "index": {
          "description": "Creates new identifier from String",
          "hierarchy": "PGF",
          "module": "PGF",
          "name": "mkCId",
          "normalized": "String-\u003eCId",
          "package": "gf",
          "partial": "CId",
          "signature": "String-\u003eCId",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/gf/docs/PGF.html#v:mkCId"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ecreates hypothesis for dependent type i.e. (x : A)\n\u003c/p\u003e",
          "module": "PGF",
          "name": "mkDepHypo",
          "package": "gf",
          "signature": "CId -\u003e Type -\u003e Hypo",
          "source": "src/PGF-Type.html#mkDepHypo",
          "type": "function"
        },
        "index": {
          "description": "creates hypothesis for dependent type i.e",
          "hierarchy": "PGF",
          "module": "PGF",
          "name": "mkDepHypo",
          "normalized": "CId-\u003eType-\u003eHypo",
          "package": "gf",
          "partial": "Dep Hypo",
          "signature": "CId-\u003eType-\u003eHypo",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/gf/docs/PGF.html#v:mkDepHypo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstructs an expression from real number literal\n\u003c/p\u003e",
          "module": "PGF",
          "name": "mkDouble",
          "package": "gf",
          "signature": "Double -\u003e Expr",
          "source": "src/PGF-Expr.html#mkDouble",
          "type": "function"
        },
        "index": {
          "description": "Constructs an expression from real number literal",
          "hierarchy": "PGF",
          "module": "PGF",
          "name": "mkDouble",
          "normalized": "Double-\u003eExpr",
          "package": "gf",
          "partial": "Double",
          "signature": "Double-\u003eExpr",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/gf/docs/PGF.html#v:mkDouble"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ecreates hypothesis for non-dependent type i.e. A\n\u003c/p\u003e",
          "module": "PGF",
          "name": "mkHypo",
          "package": "gf",
          "signature": "Type -\u003e Hypo",
          "source": "src/PGF-Type.html#mkHypo",
          "type": "function"
        },
        "index": {
          "description": "creates hypothesis for non-dependent type i.e",
          "hierarchy": "PGF",
          "module": "PGF",
          "name": "mkHypo",
          "normalized": "Type-\u003eHypo",
          "package": "gf",
          "partial": "Hypo",
          "signature": "Type-\u003eHypo",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/gf/docs/PGF.html#v:mkHypo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ecreates hypothesis for dependent type with implicit argument i.e. ({x} : A)\n\u003c/p\u003e",
          "module": "PGF",
          "name": "mkImplHypo",
          "package": "gf",
          "signature": "CId -\u003e Type -\u003e Hypo",
          "source": "src/PGF-Type.html#mkImplHypo",
          "type": "function"
        },
        "index": {
          "description": "creates hypothesis for dependent type with implicit argument i.e",
          "hierarchy": "PGF",
          "module": "PGF",
          "name": "mkImplHypo",
          "normalized": "CId-\u003eType-\u003eHypo",
          "package": "gf",
          "partial": "Impl Hypo",
          "signature": "CId-\u003eType-\u003eHypo",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/gf/docs/PGF.html#v:mkImplHypo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstructs an expression from integer literal\n\u003c/p\u003e",
          "module": "PGF",
          "name": "mkInt",
          "package": "gf",
          "signature": "Int -\u003e Expr",
          "source": "src/PGF-Expr.html#mkInt",
          "type": "function"
        },
        "index": {
          "description": "Constructs an expression from integer literal",
          "hierarchy": "PGF",
          "module": "PGF",
          "name": "mkInt",
          "normalized": "Int-\u003eExpr",
          "package": "gf",
          "partial": "Int",
          "signature": "Int-\u003eExpr",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/gf/docs/PGF.html#v:mkInt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstructs an expression which is meta variable\n\u003c/p\u003e",
          "module": "PGF",
          "name": "mkMeta",
          "package": "gf",
          "signature": "Int -\u003e Expr",
          "source": "src/PGF-Expr.html#mkMeta",
          "type": "function"
        },
        "index": {
          "description": "Constructs an expression which is meta variable",
          "hierarchy": "PGF",
          "module": "PGF",
          "name": "mkMeta",
          "normalized": "Int-\u003eExpr",
          "package": "gf",
          "partial": "Meta",
          "signature": "Int-\u003eExpr",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/gf/docs/PGF.html#v:mkMeta"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "PGF",
          "name": "mkParseInput",
          "package": "gf",
          "signature": "PGF -\u003e Language -\u003e (forall a.  b -\u003e Map Token a -\u003e Maybe a) -\u003e [(CId, b -\u003e Maybe (Tree, [Token]))] -\u003e b -\u003e ParseInput",
          "source": "src/PGF-Parse.html#mkParseInput",
          "type": "function"
        },
        "index": {
          "hierarchy": "PGF",
          "module": "PGF",
          "name": "mkParseInput",
          "normalized": "PGF-\u003eLanguage-\u003e(a b c-\u003eMap Token d-\u003eMaybe d)-\u003e[(CId,c-\u003eMaybe(Tree,[Token]))]-\u003ec-\u003eParseInput",
          "package": "gf",
          "partial": "Parse Input",
          "signature": "PGF-\u003eLanguage-\u003e(forall a. b-\u003eMap Token a-\u003eMaybe a)-\u003e[(CId,b-\u003eMaybe(Tree,[Token]))]-\u003eb-\u003eParseInput",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/gf/docs/PGF.html#v:mkParseInput"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eBuilds probability tables. The second argument is a map\n which contains the know probabilities. If some function is\n not in the map then it gets assigned some probability based\n on the even distribution of the unallocated probability mass\n for the result category.\n\u003c/p\u003e",
          "module": "PGF",
          "name": "mkProbabilities",
          "package": "gf",
          "signature": "PGF -\u003e Map CId Double -\u003e Probabilities",
          "source": "src/PGF-Probabilistic.html#mkProbabilities",
          "type": "function"
        },
        "index": {
          "description": "Builds probability tables The second argument is map which contains the know probabilities If some function is not in the map then it gets assigned some probability based on the even distribution of the unallocated probability mass for the result category",
          "hierarchy": "PGF",
          "module": "PGF",
          "name": "mkProbabilities",
          "normalized": "PGF-\u003eMap CId Double-\u003eProbabilities",
          "package": "gf",
          "partial": "Probabilities",
          "signature": "PGF-\u003eMap CId Double-\u003eProbabilities",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/gf/docs/PGF.html#v:mkProbabilities"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstructs an expression from string literal\n\u003c/p\u003e",
          "module": "PGF",
          "name": "mkStr",
          "package": "gf",
          "signature": "String -\u003e Expr",
          "source": "src/PGF-Expr.html#mkStr",
          "type": "function"
        },
        "index": {
          "description": "Constructs an expression from string literal",
          "hierarchy": "PGF",
          "module": "PGF",
          "name": "mkStr",
          "normalized": "String-\u003eExpr",
          "package": "gf",
          "partial": "Str",
          "signature": "String-\u003eExpr",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/gf/docs/PGF.html#v:mkStr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis is the construction function. Given a PGF and a Language, it \n extract the lexicon for this language and build a tokenization fst\n from it.\n\u003c/p\u003e",
          "module": "PGF",
          "name": "mkTokenizer",
          "package": "gf",
          "signature": "PGF -\u003e Language -\u003e String -\u003e Maybe [String]",
          "source": "src/PGF-Tokenizer.html#mkTokenizer",
          "type": "function"
        },
        "index": {
          "description": "This is the construction function Given PGF and Language it extract the lexicon for this language and build tokenization fst from it",
          "hierarchy": "PGF",
          "module": "PGF",
          "name": "mkTokenizer",
          "normalized": "PGF-\u003eLanguage-\u003eString-\u003eMaybe[String]",
          "package": "gf",
          "partial": "Tokenizer",
          "signature": "PGF-\u003eLanguage-\u003eString-\u003eMaybe[String]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/gf/docs/PGF.html#v:mkTokenizer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ecreates a type from list of hypothesises, category and \n list of arguments for the category. The operation \n \u003ccode\u003emkType [h_1,...,h_n] C [e_1,...,e_m]\u003c/code\u003e will create \n \u003ccode\u003eh_1 -\u003e ... -\u003e h_n -\u003e C e_1 ... e_m\u003c/code\u003e\n\u003c/p\u003e",
          "module": "PGF",
          "name": "mkType",
          "package": "gf",
          "signature": "[Hypo] -\u003e CId -\u003e [Expr] -\u003e Type",
          "source": "src/PGF-Type.html#mkType",
          "type": "function"
        },
        "index": {
          "description": "creates type from list of hypothesises category and list of arguments for the category The operation mkType will create",
          "hierarchy": "PGF",
          "module": "PGF",
          "name": "mkType",
          "normalized": "[Hypo]-\u003eCId-\u003e[Expr]-\u003eType",
          "package": "gf",
          "partial": "Type",
          "signature": "[Hypo]-\u003eCId-\u003e[Expr]-\u003eType",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/gf/docs/PGF.html#v:mkType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "PGF",
          "name": "morphoMissing",
          "package": "gf",
          "signature": "Morpho -\u003e [String] -\u003e [String]",
          "source": "src/PGF-Morphology.html#morphoMissing",
          "type": "function"
        },
        "index": {
          "hierarchy": "PGF",
          "module": "PGF",
          "name": "morphoMissing",
          "normalized": "Morpho-\u003e[String]-\u003e[String]",
          "package": "gf",
          "partial": "Missing",
          "signature": "Morpho-\u003e[String]-\u003e[String]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/gf/docs/PGF.html#v:morphoMissing"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFrom the current state and the next token\n \u003ccode\u003e\u003ca\u003enextState\u003c/a\u003e\u003c/code\u003e computes a new state, where the token\n is consumed and the current position is shifted by one.\n If the new token cannot be accepted then an error state \n is returned.\n\u003c/p\u003e",
          "module": "PGF",
          "name": "nextState",
          "package": "gf",
          "signature": "ParseState -\u003e ParseInput -\u003e Either ErrorState ParseState",
          "source": "src/PGF-Parse.html#nextState",
          "type": "function"
        },
        "index": {
          "description": "From the current state and the next token nextState computes new state where the token is consumed and the current position is shifted by one If the new token cannot be accepted then an error state is returned",
          "hierarchy": "PGF",
          "module": "PGF",
          "name": "nextState",
          "normalized": "ParseState-\u003eParseInput-\u003eEither ErrorState ParseState",
          "package": "gf",
          "partial": "State",
          "signature": "ParseState-\u003eParseInput-\u003eEither ErrorState ParseState",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/gf/docs/PGF.html#v:nextState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "PGF",
          "name": "noCat",
          "package": "gf",
          "signature": "Bool",
          "source": "src/PGF-VisualizeTree.html#GraphvizOptions",
          "type": "function"
        },
        "index": {
          "hierarchy": "PGF",
          "module": "PGF",
          "name": "noCat",
          "package": "gf",
          "partial": "Cat",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/gf/docs/PGF.html#v:noCat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "PGF",
          "name": "noFun",
          "package": "gf",
          "signature": "Bool",
          "source": "src/PGF-VisualizeTree.html#GraphvizOptions",
          "type": "function"
        },
        "index": {
          "hierarchy": "PGF",
          "module": "PGF",
          "name": "noFun",
          "package": "gf",
          "partial": "Fun",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/gf/docs/PGF.html#v:noFun"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "PGF",
          "name": "noLeaves",
          "package": "gf",
          "signature": "Bool",
          "source": "src/PGF-VisualizeTree.html#GraphvizOptions",
          "type": "function"
        },
        "index": {
          "hierarchy": "PGF",
          "module": "PGF",
          "name": "noLeaves",
          "package": "gf",
          "partial": "Leaves",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/gf/docs/PGF.html#v:noLeaves"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "PGF",
          "name": "nodeColor",
          "package": "gf",
          "signature": "String",
          "source": "src/PGF-VisualizeTree.html#GraphvizOptions",
          "type": "function"
        },
        "index": {
          "hierarchy": "PGF",
          "module": "PGF",
          "name": "nodeColor",
          "package": "gf",
          "partial": "Color",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/gf/docs/PGF.html#v:nodeColor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "PGF",
          "name": "nodeEdgeStyle",
          "package": "gf",
          "signature": "String",
          "source": "src/PGF-VisualizeTree.html#GraphvizOptions",
          "type": "function"
        },
        "index": {
          "hierarchy": "PGF",
          "module": "PGF",
          "name": "nodeEdgeStyle",
          "package": "gf",
          "partial": "Edge Style",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/gf/docs/PGF.html#v:nodeEdgeStyle"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "PGF",
          "name": "nodeFont",
          "package": "gf",
          "signature": "String",
          "source": "src/PGF-VisualizeTree.html#GraphvizOptions",
          "type": "function"
        },
        "index": {
          "hierarchy": "PGF",
          "module": "PGF",
          "name": "nodeFont",
          "package": "gf",
          "partial": "Font",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/gf/docs/PGF.html#v:nodeFont"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "PGF",
          "name": "paraphrase",
          "package": "gf",
          "signature": "PGF -\u003e Expr -\u003e [Expr]",
          "source": "src/PGF-Paraphrase.html#paraphrase",
          "type": "function"
        },
        "index": {
          "hierarchy": "PGF",
          "module": "PGF",
          "name": "paraphrase",
          "normalized": "PGF-\u003eExpr-\u003e[Expr]",
          "package": "gf",
          "signature": "PGF-\u003eExpr-\u003e[Expr]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/gf/docs/PGF.html#v:paraphrase"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTries to parse the given string in the specified language\n and to produce abstract syntax expression.\n\u003c/p\u003e",
          "module": "PGF",
          "name": "parse",
          "package": "gf",
          "signature": "PGF -\u003e Language -\u003e Type -\u003e String -\u003e [Tree]",
          "source": "src/PGF.html#parse",
          "type": "function"
        },
        "index": {
          "description": "Tries to parse the given string in the specified language and to produce abstract syntax expression",
          "hierarchy": "PGF",
          "module": "PGF",
          "name": "parse",
          "normalized": "PGF-\u003eLanguage-\u003eType-\u003eString-\u003e[Tree]",
          "package": "gf",
          "signature": "PGF-\u003eLanguage-\u003eType-\u003eString-\u003e[Tree]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/gf/docs/PGF.html#v:parse"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe same as \u003ccode\u003e\u003ca\u003eparseAllLang\u003c/a\u003e\u003c/code\u003e but does not return\n the language.\n\u003c/p\u003e",
          "module": "PGF",
          "name": "parseAll",
          "package": "gf",
          "signature": "PGF -\u003e Type -\u003e String -\u003e [[Tree]]",
          "source": "src/PGF.html#parseAll",
          "type": "function"
        },
        "index": {
          "description": "The same as parseAllLang but does not return the language",
          "hierarchy": "PGF",
          "module": "PGF",
          "name": "parseAll",
          "normalized": "PGF-\u003eType-\u003eString-\u003e[[Tree]]",
          "package": "gf",
          "partial": "All",
          "signature": "PGF-\u003eType-\u003eString-\u003e[[Tree]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/gf/docs/PGF.html#v:parseAll"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTries to parse the given string with all available languages.\n The returned list contains pairs of language\n and list of abstract syntax expressions \n (this is a list, since grammars can be ambiguous). \n Only those languages\n for which at least one parsing is possible are listed.\n\u003c/p\u003e",
          "module": "PGF",
          "name": "parseAllLang",
          "package": "gf",
          "signature": "PGF -\u003e Type -\u003e String -\u003e [(Language, [Tree])]",
          "source": "src/PGF.html#parseAllLang",
          "type": "function"
        },
        "index": {
          "description": "Tries to parse the given string with all available languages The returned list contains pairs of language and list of abstract syntax expressions this is list since grammars can be ambiguous Only those languages for which at least one parsing is possible are listed",
          "hierarchy": "PGF",
          "module": "PGF",
          "name": "parseAllLang",
          "normalized": "PGF-\u003eType-\u003eString-\u003e[(Language,[Tree])]",
          "package": "gf",
          "partial": "All Lang",
          "signature": "PGF-\u003eType-\u003eString-\u003e[(Language,[Tree])]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/gf/docs/PGF.html#v:parseAllLang"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis is an experimental function. Use it on your own risk\n\u003c/p\u003e",
          "module": "PGF",
          "name": "parseWithRecovery",
          "package": "gf",
          "signature": "PGF -\u003e Language -\u003e Type -\u003e [Type] -\u003e Maybe Int -\u003e String -\u003e (ParseOutput, BracketedString)",
          "source": "src/PGF.html#parseWithRecovery",
          "type": "function"
        },
        "index": {
          "description": "This is an experimental function Use it on your own risk",
          "hierarchy": "PGF",
          "module": "PGF",
          "name": "parseWithRecovery",
          "normalized": "PGF-\u003eLanguage-\u003eType-\u003e[Type]-\u003eMaybe Int-\u003eString-\u003e(ParseOutput,BracketedString)",
          "package": "gf",
          "partial": "With Recovery",
          "signature": "PGF-\u003eLanguage-\u003eType-\u003e[Type]-\u003eMaybe Int-\u003eString-\u003e(ParseOutput,BracketedString)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/gf/docs/PGF.html#v:parseWithRecovery"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe same as \u003ccode\u003e\u003ca\u003eparse\u003c/a\u003e\u003c/code\u003e but returns more detailed information\n\u003c/p\u003e",
          "module": "PGF",
          "name": "parse_",
          "package": "gf",
          "signature": "PGF -\u003e Language -\u003e Type -\u003e Maybe Int -\u003e String -\u003e (ParseOutput, BracketedString)",
          "source": "src/PGF.html#parse_",
          "type": "function"
        },
        "index": {
          "description": "The same as parse but returns more detailed information",
          "hierarchy": "PGF",
          "module": "PGF",
          "name": "parse_",
          "normalized": "PGF-\u003eLanguage-\u003eType-\u003eMaybe Int-\u003eString-\u003e(ParseOutput,BracketedString)",
          "package": "gf",
          "signature": "PGF-\u003eLanguage-\u003eType-\u003eMaybe Int-\u003eString-\u003e(ParseOutput,BracketedString)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/gf/docs/PGF.html#v:parse_"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "PGF",
          "name": "piLiteral",
          "package": "gf",
          "signature": "FId -\u003e Maybe (CId, Tree, [Token])",
          "source": "src/PGF-Parse.html#ParseInput",
          "type": "function"
        },
        "index": {
          "hierarchy": "PGF",
          "module": "PGF",
          "name": "piLiteral",
          "normalized": "FId-\u003eMaybe(CId,Tree,[Token])",
          "package": "gf",
          "partial": "Literal",
          "signature": "FId-\u003eMaybe(CId,Tree,[Token])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/gf/docs/PGF.html#v:piLiteral"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "PGF",
          "name": "piToken",
          "package": "gf",
          "signature": "forall a.  Map Token a -\u003e Maybe a",
          "source": "src/PGF-Parse.html#ParseInput",
          "type": "function"
        },
        "index": {
          "hierarchy": "PGF",
          "module": "PGF",
          "name": "piToken",
          "normalized": "a b Map Token c-\u003eMaybe c",
          "package": "gf",
          "partial": "Token",
          "signature": "forall a. Map Token a-\u003eMaybe a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/gf/docs/PGF.html#v:piToken"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRenders the type checking error to a document. See \u003ccode\u003e\u003ca\u003ePrettyPrint\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "PGF",
          "name": "ppTcError",
          "package": "gf",
          "signature": "TcError -\u003e Doc",
          "source": "src/PGF-TypeCheck.html#ppTcError",
          "type": "function"
        },
        "index": {
          "description": "Renders the type checking error to document See PrettyPrint",
          "hierarchy": "PGF",
          "module": "PGF",
          "name": "ppTcError",
          "normalized": "TcError-\u003eDoc",
          "package": "gf",
          "partial": "Tc Error",
          "signature": "TcError-\u003eDoc",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/gf/docs/PGF.html#v:ppTcError"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReads an identifier from \u003ccode\u003e\u003ca\u003eString\u003c/a\u003e\u003c/code\u003e. The function returns \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e if the string is not valid identifier.\n\u003c/p\u003e",
          "module": "PGF",
          "name": "readCId",
          "package": "gf",
          "signature": "String -\u003e Maybe CId",
          "source": "src/PGF-CId.html#readCId",
          "type": "function"
        },
        "index": {
          "description": "Reads an identifier from String The function returns Nothing if the string is not valid identifier",
          "hierarchy": "PGF",
          "module": "PGF",
          "name": "readCId",
          "normalized": "String-\u003eMaybe CId",
          "package": "gf",
          "partial": "CId",
          "signature": "String-\u003eMaybe CId",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/gf/docs/PGF.html#v:readCId"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eparses \u003ccode\u003e\u003ca\u003eString\u003c/a\u003e\u003c/code\u003e as an expression\n\u003c/p\u003e",
          "module": "PGF",
          "name": "readExpr",
          "package": "gf",
          "signature": "String -\u003e Maybe Expr",
          "source": "src/PGF-Expr.html#readExpr",
          "type": "function"
        },
        "index": {
          "description": "parses String as an expression",
          "hierarchy": "PGF",
          "module": "PGF",
          "name": "readExpr",
          "normalized": "String-\u003eMaybe Expr",
          "package": "gf",
          "partial": "Expr",
          "signature": "String-\u003eMaybe Expr",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/gf/docs/PGF.html#v:readExpr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "PGF",
          "name": "readLanguage",
          "package": "gf",
          "signature": "String -\u003e Maybe Language",
          "source": "src/PGF-Data.html#readLanguage",
          "type": "function"
        },
        "index": {
          "hierarchy": "PGF",
          "module": "PGF",
          "name": "readLanguage",
          "normalized": "String-\u003eMaybe Language",
          "package": "gf",
          "partial": "Language",
          "signature": "String-\u003eMaybe Language",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/gf/docs/PGF.html#v:readLanguage"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReads file in Portable Grammar Format and produces\n \u003ccode\u003e\u003ca\u003ePGF\u003c/a\u003e\u003c/code\u003e structure. The file is usually produced with:\n\u003c/p\u003e\u003cpre\u003e $ gf -make \u003cgrammar file name\u003e\n\u003c/pre\u003e",
          "module": "PGF",
          "name": "readPGF",
          "package": "gf",
          "signature": "FilePath -\u003e IO PGF",
          "source": "src/PGF.html#readPGF",
          "type": "function"
        },
        "index": {
          "description": "Reads file in Portable Grammar Format and produces PGF structure The file is usually produced with gf make grammar file name",
          "hierarchy": "PGF",
          "module": "PGF",
          "name": "readPGF",
          "normalized": "FilePath-\u003eIO PGF",
          "package": "gf",
          "partial": "PGF",
          "signature": "FilePath-\u003eIO PGF",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/gf/docs/PGF.html#v:readPGF"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReads the probabilities from a file.\n This should be a text file where on every line\n there is a function name followed by a real number.\n The number represents the probability mass allocated for that function.\n The function name and the probability should be separated by a whitespace.\n\u003c/p\u003e",
          "module": "PGF",
          "name": "readProbabilitiesFromFile",
          "package": "gf",
          "signature": "FilePath -\u003e PGF -\u003e IO Probabilities",
          "source": "src/PGF-Probabilistic.html#readProbabilitiesFromFile",
          "type": "function"
        },
        "index": {
          "description": "Reads the probabilities from file This should be text file where on every line there is function name followed by real number The number represents the probability mass allocated for that function The function name and the probability should be separated by whitespace",
          "hierarchy": "PGF",
          "module": "PGF",
          "name": "readProbabilitiesFromFile",
          "normalized": "FilePath-\u003ePGF-\u003eIO Probabilities",
          "package": "gf",
          "partial": "Probabilities From File",
          "signature": "FilePath-\u003ePGF-\u003eIO Probabilities",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/gf/docs/PGF.html#v:readProbabilitiesFromFile"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReads a \u003ccode\u003e\u003ca\u003eType\u003c/a\u003e\u003c/code\u003e from a \u003ccode\u003e\u003ca\u003eString\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "PGF",
          "name": "readType",
          "package": "gf",
          "signature": "String -\u003e Maybe Type",
          "source": "src/PGF-Type.html#readType",
          "type": "function"
        },
        "index": {
          "description": "Reads Type from String",
          "hierarchy": "PGF",
          "module": "PGF",
          "name": "readType",
          "normalized": "String-\u003eMaybe Type",
          "package": "gf",
          "partial": "Type",
          "signature": "String-\u003eMaybe Type",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/gf/docs/PGF.html#v:readType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "PGF",
          "name": "recoveryStates",
          "package": "gf",
          "signature": "[Type] -\u003e ErrorState -\u003e (ParseState, Map Token ParseState)",
          "source": "src/PGF-Parse.html#recoveryStates",
          "type": "function"
        },
        "index": {
          "hierarchy": "PGF",
          "module": "PGF",
          "name": "recoveryStates",
          "normalized": "[Type]-\u003eErrorState-\u003e(ParseState,Map Token ParseState)",
          "package": "gf",
          "partial": "States",
          "signature": "[Type]-\u003eErrorState-\u003e(ParseState,Map Token ParseState)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/gf/docs/PGF.html#v:recoveryStates"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRenders the bracketed string as string where \n the brackets are shown as \u003ccode\u003e(S ...)\u003c/code\u003e where\n \u003ccode\u003eS\u003c/code\u003e is the category.\n\u003c/p\u003e",
          "module": "PGF",
          "name": "showBracketedString",
          "package": "gf",
          "signature": "BracketedString -\u003e String",
          "source": "src/PGF-Macros.html#showBracketedString",
          "type": "function"
        },
        "index": {
          "description": "Renders the bracketed string as string where the brackets are shown as where is the category",
          "hierarchy": "PGF",
          "module": "PGF",
          "name": "showBracketedString",
          "normalized": "BracketedString-\u003eString",
          "package": "gf",
          "partial": "Bracketed String",
          "signature": "BracketedString-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/gf/docs/PGF.html#v:showBracketedString"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRenders the identifier as \u003ccode\u003e\u003ca\u003eString\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "PGF",
          "name": "showCId",
          "package": "gf",
          "signature": "CId -\u003e String",
          "source": "src/PGF-CId.html#showCId",
          "type": "function"
        },
        "index": {
          "description": "Renders the identifier as String",
          "hierarchy": "PGF",
          "module": "PGF",
          "name": "showCId",
          "normalized": "CId-\u003eString",
          "package": "gf",
          "partial": "CId",
          "signature": "CId-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/gf/docs/PGF.html#v:showCId"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003erenders expression as \u003ccode\u003e\u003ca\u003eString\u003c/a\u003e\u003c/code\u003e. The list\n of identifiers is the list of all free variables\n in the expression in order reverse to the order\n of binding.\n\u003c/p\u003e",
          "module": "PGF",
          "name": "showExpr",
          "package": "gf",
          "signature": "[CId] -\u003e Expr -\u003e String",
          "source": "src/PGF-Expr.html#showExpr",
          "type": "function"
        },
        "index": {
          "description": "renders expression as String The list of identifiers is the list of all free variables in the expression in order reverse to the order of binding",
          "hierarchy": "PGF",
          "module": "PGF",
          "name": "showExpr",
          "normalized": "[CId]-\u003eExpr-\u003eString",
          "package": "gf",
          "partial": "Expr",
          "signature": "[CId]-\u003eExpr-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/gf/docs/PGF.html#v:showExpr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "PGF",
          "name": "showLanguage",
          "package": "gf",
          "signature": "Language -\u003e String",
          "source": "src/PGF-Data.html#showLanguage",
          "type": "function"
        },
        "index": {
          "hierarchy": "PGF",
          "module": "PGF",
          "name": "showLanguage",
          "normalized": "Language-\u003eString",
          "package": "gf",
          "partial": "Language",
          "signature": "Language-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/gf/docs/PGF.html#v:showLanguage"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eShow the printname of function or category\n\u003c/p\u003e",
          "module": "PGF",
          "name": "showPrintName",
          "package": "gf",
          "signature": "PGF -\u003e Language -\u003e CId -\u003e String",
          "source": "src/PGF-Macros.html#showPrintName",
          "type": "function"
        },
        "index": {
          "description": "Show the printname of function or category",
          "hierarchy": "PGF",
          "module": "PGF",
          "name": "showPrintName",
          "normalized": "PGF-\u003eLanguage-\u003eCId-\u003eString",
          "package": "gf",
          "partial": "Print Name",
          "signature": "PGF-\u003eLanguage-\u003eCId-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/gf/docs/PGF.html#v:showPrintName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRenders the probability structure as string\n\u003c/p\u003e",
          "module": "PGF",
          "name": "showProbabilities",
          "package": "gf",
          "signature": "Probabilities -\u003e String",
          "source": "src/PGF-Probabilistic.html#showProbabilities",
          "type": "function"
        },
        "index": {
          "description": "Renders the probability structure as string",
          "hierarchy": "PGF",
          "module": "PGF",
          "name": "showProbabilities",
          "normalized": "Probabilities-\u003eString",
          "package": "gf",
          "partial": "Probabilities",
          "signature": "Probabilities-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/gf/docs/PGF.html#v:showProbabilities"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003erenders type as \u003ccode\u003e\u003ca\u003eString\u003c/a\u003e\u003c/code\u003e. The list\n of identifiers is the list of all free variables\n in the expression in order reverse to the order\n of binding.\n\u003c/p\u003e",
          "module": "PGF",
          "name": "showType",
          "package": "gf",
          "signature": "[CId] -\u003e Type -\u003e String",
          "source": "src/PGF-Type.html#showType",
          "type": "function"
        },
        "index": {
          "description": "renders type as String The list of identifiers is the list of all free variables in the expression in order reverse to the order of binding",
          "hierarchy": "PGF",
          "module": "PGF",
          "name": "showType",
          "normalized": "[CId]-\u003eType-\u003eString",
          "package": "gf",
          "partial": "Type",
          "signature": "[CId]-\u003eType-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/gf/docs/PGF.html#v:showType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function constructs the simplest possible parser input. \n It checks the tokens for exact matching and recognizes only \u003ccode\u003eString\u003c/code\u003e, \u003ccode\u003eInt\u003c/code\u003e and \u003ccode\u003eFloat\u003c/code\u003e literals.\n The \u003ccode\u003eInt\u003c/code\u003e and \u003ccode\u003eFloat\u003c/code\u003e literals match only if the token passed is some number.\n The \u003ccode\u003eString\u003c/code\u003e literal always match but the length of the literal could be only one token.\n\u003c/p\u003e",
          "module": "PGF",
          "name": "simpleParseInput",
          "package": "gf",
          "signature": "Token -\u003e ParseInput",
          "source": "src/PGF-Parse.html#simpleParseInput",
          "type": "function"
        },
        "index": {
          "description": "This function constructs the simplest possible parser input It checks the tokens for exact matching and recognizes only String Int and Float literals The Int and Float literals match only if the token passed is some number The String literal always match but the length of the literal could be only one token",
          "hierarchy": "PGF",
          "module": "PGF",
          "name": "simpleParseInput",
          "normalized": "Token-\u003eParseInput",
          "package": "gf",
          "partial": "Parse Input",
          "signature": "Token-\u003eParseInput",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/gf/docs/PGF.html#v:simpleParseInput"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe start category is defined in the grammar with\n the 'startcat' flag. This is usually the sentence category\n but it is not necessary. Despite that there is a start category\n defined you can parse with any category. The start category\n definition is just for convenience.\n\u003c/p\u003e",
          "module": "PGF",
          "name": "startCat",
          "package": "gf",
          "signature": "PGF -\u003e Type",
          "source": "src/PGF.html#startCat",
          "type": "function"
        },
        "index": {
          "description": "The start category is defined in the grammar with the startcat flag This is usually the sentence category but it is not necessary Despite that there is start category defined you can parse with any category The start category definition is just for convenience",
          "hierarchy": "PGF",
          "module": "PGF",
          "name": "startCat",
          "normalized": "PGF-\u003eType",
          "package": "gf",
          "partial": "Cat",
          "signature": "PGF-\u003eType",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/gf/docs/PGF.html#v:startCat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreates a table from feature name to linearization. \n The outher list encodes the variations\n\u003c/p\u003e",
          "module": "PGF",
          "name": "tabularLinearizes",
          "package": "gf",
          "signature": "PGF -\u003e Language -\u003e Expr -\u003e [[(String, String)]]",
          "source": "src/PGF-Linearize.html#tabularLinearizes",
          "type": "function"
        },
        "index": {
          "description": "Creates table from feature name to linearization The outher list encodes the variations",
          "hierarchy": "PGF",
          "module": "PGF",
          "name": "tabularLinearizes",
          "normalized": "PGF-\u003eLanguage-\u003eExpr-\u003e[[(String,String)]]",
          "package": "gf",
          "partial": "Linearizes",
          "signature": "PGF-\u003eLanguage-\u003eExpr-\u003e[[(String,String)]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/gf/docs/PGF.html#v:tabularLinearizes"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "PGF",
          "name": "unAbs",
          "package": "gf",
          "signature": "Expr -\u003e Maybe (BindType, CId, Expr)",
          "source": "src/PGF-Expr.html#unAbs",
          "type": "function"
        },
        "index": {
          "hierarchy": "PGF",
          "module": "PGF",
          "name": "unAbs",
          "normalized": "Expr-\u003eMaybe(BindType,CId,Expr)",
          "package": "gf",
          "partial": "Abs",
          "signature": "Expr-\u003eMaybe(BindType,CId,Expr)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/gf/docs/PGF.html#v:unAbs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDecomposes an expression into application of function\n\u003c/p\u003e",
          "module": "PGF",
          "name": "unApp",
          "package": "gf",
          "signature": "Expr -\u003e Maybe (CId, [Expr])",
          "source": "src/PGF-Expr.html#unApp",
          "type": "function"
        },
        "index": {
          "description": "Decomposes an expression into application of function",
          "hierarchy": "PGF",
          "module": "PGF",
          "name": "unApp",
          "normalized": "Expr-\u003eMaybe(CId,[Expr])",
          "package": "gf",
          "partial": "App",
          "signature": "Expr-\u003eMaybe(CId,[Expr])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/gf/docs/PGF.html#v:unApp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDecomposes an expression into real number literal\n\u003c/p\u003e",
          "module": "PGF",
          "name": "unDouble",
          "package": "gf",
          "signature": "Expr -\u003e Maybe Double",
          "source": "src/PGF-Expr.html#unDouble",
          "type": "function"
        },
        "index": {
          "description": "Decomposes an expression into real number literal",
          "hierarchy": "PGF",
          "module": "PGF",
          "name": "unDouble",
          "normalized": "Expr-\u003eMaybe Double",
          "package": "gf",
          "partial": "Double",
          "signature": "Expr-\u003eMaybe Double",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/gf/docs/PGF.html#v:unDouble"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDecomposes an expression into integer literal\n\u003c/p\u003e",
          "module": "PGF",
          "name": "unInt",
          "package": "gf",
          "signature": "Expr -\u003e Maybe Int",
          "source": "src/PGF-Expr.html#unInt",
          "type": "function"
        },
        "index": {
          "description": "Decomposes an expression into integer literal",
          "hierarchy": "PGF",
          "module": "PGF",
          "name": "unInt",
          "normalized": "Expr-\u003eMaybe Int",
          "package": "gf",
          "partial": "Int",
          "signature": "Expr-\u003eMaybe Int",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/gf/docs/PGF.html#v:unInt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eChecks whether an expression is a meta variable\n\u003c/p\u003e",
          "module": "PGF",
          "name": "unMeta",
          "package": "gf",
          "signature": "Expr -\u003e Maybe Int",
          "source": "src/PGF-Expr.html#unMeta",
          "type": "function"
        },
        "index": {
          "description": "Checks whether an expression is meta variable",
          "hierarchy": "PGF",
          "module": "PGF",
          "name": "unMeta",
          "normalized": "Expr-\u003eMaybe Int",
          "package": "gf",
          "partial": "Meta",
          "signature": "Expr-\u003eMaybe Int",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/gf/docs/PGF.html#v:unMeta"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDecomposes an expression into string literal\n\u003c/p\u003e",
          "module": "PGF",
          "name": "unStr",
          "package": "gf",
          "signature": "Expr -\u003e Maybe String",
          "source": "src/PGF-Expr.html#unStr",
          "type": "function"
        },
        "index": {
          "description": "Decomposes an expression into string literal",
          "hierarchy": "PGF",
          "module": "PGF",
          "name": "unStr",
          "normalized": "Expr-\u003eMaybe String",
          "package": "gf",
          "partial": "Str",
          "signature": "Expr-\u003eMaybe String",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/gf/docs/PGF.html#v:unStr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "PGF",
          "name": "unType",
          "package": "gf",
          "signature": "Type -\u003e ([Hypo], CId, [Expr])",
          "source": "src/PGF-Type.html#unType",
          "type": "function"
        },
        "index": {
          "hierarchy": "PGF",
          "module": "PGF",
          "name": "unType",
          "normalized": "Type-\u003e([Hypo],CId,[Expr])",
          "package": "gf",
          "partial": "Type",
          "signature": "Type-\u003e([Hypo],CId,[Expr])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/gf/docs/PGF.html#v:unType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "PGF",
          "name": "wildCId",
          "package": "gf",
          "signature": "CId",
          "source": "src/PGF-CId.html#wildCId",
          "type": "function"
        },
        "index": {
          "hierarchy": "PGF",
          "module": "PGF",
          "name": "wildCId",
          "package": "gf",
          "partial": "CId",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/gf/docs/PGF.html#v:wildCId"
      }
    }
  ]
]