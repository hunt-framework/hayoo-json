[
  {
    "cmd": "delete-by-query",
    "query": {
      "contexts": [
        "package"
      ],
      "query": {
        "op": "case",
        "type": "word",
        "word": "mix-arrows"
      },
      "type": "context"
    }
  },
  [
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Arrow.Mix.Category",
          "name": "Category",
          "package": "mix-arrows",
          "source": "src/Control-Arrow-Mix-Category.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Control Arrow Mix Category",
          "module": "Control.Arrow.Mix.Category",
          "name": "Category",
          "package": "mix-arrows",
          "partial": "Category",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/mix-arrows/docs/Control-Arrow-Mix-Category.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRefined arrow morphism\n\u003c/p\u003e",
          "module": "Control.Arrow.Mix.Category",
          "name": ":~~\u003e",
          "package": "mix-arrows",
          "source": "src/Control-Arrow-Mix-Category.html#%3A~~%3E",
          "type": "type"
        },
        "index": {
          "description": "Refined arrow morphism",
          "hierarchy": "Control Arrow Mix Category",
          "module": "Control.Arrow.Mix.Category",
          "name": ":~~\u003e",
          "package": "mix-arrows",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/mix-arrows/docs/Control-Arrow-Mix-Category.html#t::-126--126--62-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eArrow morphism\n\u003c/p\u003e",
          "module": "Control.Arrow.Mix.Category",
          "name": ":~\u003e",
          "package": "mix-arrows",
          "source": "src/Control-Arrow-Mix-Category.html#%3A~%3E",
          "type": "type"
        },
        "index": {
          "description": "Arrow morphism",
          "hierarchy": "Control Arrow Mix Category",
          "module": "Control.Arrow.Mix.Category",
          "name": ":~\u003e",
          "package": "mix-arrows",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/mix-arrows/docs/Control-Arrow-Mix-Category.html#t::-126--62-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDeclarations like \u003ccode\u003einstance Monad m =\u003e Functor m\u003c/code\u003e don't work well in Haskell. That's why we need a newtype.\n\u003c/p\u003e",
          "module": "Control.Arrow.Mix.Category",
          "name": ":$~",
          "package": "mix-arrows",
          "source": "src/Control-Arrow-Mix-Category.html#%3A%24~",
          "type": "newtype"
        },
        "index": {
          "description": "Declarations like instance Monad Functor don work well in Haskell That why we need newtype",
          "hierarchy": "Control Arrow Mix Category",
          "module": "Control.Arrow.Mix.Category",
          "name": ":$~",
          "package": "mix-arrows",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/mix-arrows/docs/Control-Arrow-Mix-Category.html#t::-36--126-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSomething like a functor - again, for arrows\n\u003c/p\u003e",
          "module": "Control.Arrow.Mix.Category",
          "name": "AlFunctor",
          "package": "mix-arrows",
          "source": "src/Control-Arrow-Mix-Category.html#AlFunctor",
          "type": "class"
        },
        "index": {
          "description": "Something like functor again for arrows",
          "hierarchy": "Control Arrow Mix Category",
          "module": "Control.Arrow.Mix.Category",
          "name": "AlFunctor",
          "package": "mix-arrows",
          "partial": "Al Functor",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/mix-arrows/docs/Control-Arrow-Mix-Category.html#t:AlFunctor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSomething like a monad - but for arrows\n\u003c/p\u003e",
          "module": "Control.Arrow.Mix.Category",
          "name": "AlMonad",
          "package": "mix-arrows",
          "source": "src/Control-Arrow-Mix-Category.html#AlMonad",
          "type": "class"
        },
        "index": {
          "description": "Something like monad but for arrows",
          "hierarchy": "Control Arrow Mix Category",
          "module": "Control.Arrow.Mix.Category",
          "name": "AlMonad",
          "package": "mix-arrows",
          "partial": "Al Monad",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/mix-arrows/docs/Control-Arrow-Mix-Category.html#t:AlMonad"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSometimes we need to refine our morphism a bit; therefore, we use \u003ccode\u003eAlong f i o\u003c/code\u003e instead of just \u003ccode\u003ef\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Arrow.Mix.Category",
          "name": "Along",
          "package": "mix-arrows",
          "source": "src/Control-Arrow-Mix-Category.html#Along",
          "type": "type"
        },
        "index": {
          "description": "Sometimes we need to refine our morphism bit therefore we use Along instead of just",
          "hierarchy": "Control Arrow Mix Category",
          "module": "Control.Arrow.Mix.Category",
          "name": "Along",
          "package": "mix-arrows",
          "partial": "Along",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/mix-arrows/docs/Control-Arrow-Mix-Category.html#t:Along"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eJust a trick to avoid specifying rank explicitly\n\u003c/p\u003e",
          "module": "Control.Arrow.Mix.Category",
          "name": "OhNo",
          "package": "mix-arrows",
          "source": "src/Control-Arrow-Mix-Category.html#OhNo",
          "type": "type"
        },
        "index": {
          "description": "Just trick to avoid specifying rank explicitly",
          "hierarchy": "Control Arrow Mix Category",
          "module": "Control.Arrow.Mix.Category",
          "name": "OhNo",
          "package": "mix-arrows",
          "partial": "Oh No",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/mix-arrows/docs/Control-Arrow-Mix-Category.html#t:OhNo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMost of time we don't need refined morphisms. That's why we would want a simpler combinator.\n\u003c/p\u003e",
          "module": "Control.Arrow.Mix.Category",
          "name": "(~\u003e\u003e=)",
          "package": "mix-arrows",
          "signature": "m b i1 o1 -\u003e (Along b i1 o1 :~\u003e Along (m c) i2 o2) -\u003e m c i2 o2",
          "source": "src/Control-Arrow-Mix-Category.html#~%3E%3E%3D",
          "type": "function"
        },
        "index": {
          "description": "Most of time we don need refined morphisms That why we would want simpler combinator",
          "hierarchy": "Control Arrow Mix Category",
          "module": "Control.Arrow.Mix.Category",
          "name": "(~\u003e\u003e=) ~\u003e\u003e=",
          "normalized": "a b c d-\u003e(Along b c d Along(a e)c d)-\u003ea e c d",
          "package": "mix-arrows",
          "signature": "m b i o-\u003e(Along b i o Along(m c)i o)-\u003em c i o",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/mix-arrows/docs/Control-Arrow-Mix-Category.html#v:-126--62--62--61-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Arrow.Mix.Category",
          "name": "Apply",
          "package": "mix-arrows",
          "signature": "Apply",
          "source": "src/Control-Arrow-Mix-Category.html#%3A%24~",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Arrow Mix Category",
          "module": "Control.Arrow.Mix.Category",
          "name": "Apply",
          "package": "mix-arrows",
          "partial": "Apply",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/mix-arrows/docs/Control-Arrow-Mix-Category.html#v:Apply"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Arrow.Mix.Category",
          "name": "alLift",
          "package": "mix-arrows",
          "signature": "(Along b i1 o1 :~~\u003e Along (m c) i2 o2) -\u003e m b i1 o1 -\u003e m c i2 o2",
          "source": "src/Control-Arrow-Mix-Category.html#alLift",
          "type": "method"
        },
        "index": {
          "hierarchy": "Control Arrow Mix Category",
          "module": "Control.Arrow.Mix.Category",
          "name": "alLift",
          "normalized": "(Along a b c Along(d e)b c)-\u003ed a b c-\u003ed e b c",
          "package": "mix-arrows",
          "partial": "Lift",
          "signature": "(Along b i o Along(m c)i o)-\u003em b i o-\u003em c i o",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/mix-arrows/docs/Control-Arrow-Mix-Category.html#v:alLift"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Arrow.Mix.Category",
          "name": "alMap",
          "package": "mix-arrows",
          "signature": "(Along b i1 o1 :~\u003e Along c i2 o2) -\u003e f b i1 o1 -\u003e f c i2 o2",
          "source": "src/Control-Arrow-Mix-Category.html#alMap",
          "type": "method"
        },
        "index": {
          "hierarchy": "Control Arrow Mix Category",
          "module": "Control.Arrow.Mix.Category",
          "name": "alMap",
          "normalized": "(Along a b c Along d b c)-\u003ee a b c-\u003ee d b c",
          "package": "mix-arrows",
          "partial": "Map",
          "signature": "(Along b i o Along c i o)-\u003ef b i o-\u003ef c i o",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/mix-arrows/docs/Control-Arrow-Mix-Category.html#v:alMap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Arrow.Mix.Category",
          "name": "alRet",
          "package": "mix-arrows",
          "signature": "b :~\u003e m b",
          "source": "src/Control-Arrow-Mix-Category.html#alRet",
          "type": "method"
        },
        "index": {
          "hierarchy": "Control Arrow Mix Category",
          "module": "Control.Arrow.Mix.Category",
          "name": "alRet",
          "package": "mix-arrows",
          "partial": "Ret",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/mix-arrows/docs/Control-Arrow-Mix-Category.html#v:alRet"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Arrow.Mix.Category",
          "name": "runApply",
          "package": "mix-arrows",
          "signature": "a input output `OhNo` f a input output",
          "source": "src/Control-Arrow-Mix-Category.html#%3A%24~",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Arrow Mix Category",
          "module": "Control.Arrow.Mix.Category",
          "name": "runApply",
          "package": "mix-arrows",
          "partial": "Apply",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/mix-arrows/docs/Control-Arrow-Mix-Category.html#v:runApply"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eVarious ways of shuffling input and output components. Function types are mostly autogenerated.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Control.Arrow.Mix.Utilities",
          "name": "Utilities",
          "package": "mix-arrows",
          "source": "src/Control-Arrow-Mix-Utilities.html",
          "type": "module"
        },
        "index": {
          "description": "Various ways of shuffling input and output components Function types are mostly autogenerated",
          "hierarchy": "Control Arrow Mix Utilities",
          "module": "Control.Arrow.Mix.Utilities",
          "name": "Utilities",
          "package": "mix-arrows",
          "partial": "Utilities",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/mix-arrows/docs/Control-Arrow-Mix-Utilities.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Arrow.Mix.Utilities",
          "name": "(-\u003e\u003e)",
          "package": "mix-arrows",
          "signature": "a (i1, input) (o1, middle) -\u003e a (i2, middle) (o2, output) -\u003e a (i2, (i1, input)) (o2, (o1, output))",
          "source": "src/Control-Arrow-Mix-Utilities.html#-%3E%3E",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Arrow Mix Utilities",
          "module": "Control.Arrow.Mix.Utilities",
          "name": "(-\u003e\u003e) -\u003e\u003e",
          "normalized": "a(b,c)(d,e)-\u003ea(b,e)(d,f)-\u003ea(b,(b,c))(d,(d,f))",
          "package": "mix-arrows",
          "signature": "a(i,input)(o,middle)-\u003ea(i,middle)(o,output)-\u003ea(i,(i,input))(o,(o,output))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/mix-arrows/docs/Control-Arrow-Mix-Utilities.html#v:-45--62--62-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Arrow.Mix.Utilities",
          "name": "arrAssocLtoR",
          "package": "mix-arrows",
          "signature": "a ((t1, t2), t) ((t3, t4), t5) -\u003e a (t1, (t2, t)) (t3, (t4, t5))",
          "source": "src/Control-Arrow-Mix-Utilities.html#arrAssocLtoR",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Arrow Mix Utilities",
          "module": "Control.Arrow.Mix.Utilities",
          "name": "arrAssocLtoR",
          "normalized": "a((b,b),b)((b,b),b)-\u003ea(b,(b,b))(b,(b,b))",
          "package": "mix-arrows",
          "partial": "Assoc Lto",
          "signature": "a((t,t),t)((t,t),t)-\u003ea(t,(t,t))(t,(t,t))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/mix-arrows/docs/Control-Arrow-Mix-Utilities.html#v:arrAssocLtoR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Arrow.Mix.Utilities",
          "name": "arrAssocRtoL",
          "package": "mix-arrows",
          "signature": "a (t, (t1, t2)) (t3, (t4, t5)) -\u003e a ((t, t1), t2) ((t3, t4), t5)",
          "source": "src/Control-Arrow-Mix-Utilities.html#arrAssocRtoL",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Arrow Mix Utilities",
          "module": "Control.Arrow.Mix.Utilities",
          "name": "arrAssocRtoL",
          "normalized": "a(b,(b,b))(b,(b,b))-\u003ea((b,b),b)((b,b),b)",
          "package": "mix-arrows",
          "partial": "Assoc Rto",
          "signature": "a(t,(t,t))(t,(t,t))-\u003ea((t,t),t)((t,t),t)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/mix-arrows/docs/Control-Arrow-Mix-Utilities.html#v:arrAssocRtoL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Arrow.Mix.Utilities",
          "name": "arrCancelUnit",
          "package": "mix-arrows",
          "signature": "a (b, ()) (d, ()) -\u003e a b d",
          "source": "src/Control-Arrow-Mix-Utilities.html#arrCancelUnit",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Arrow Mix Utilities",
          "module": "Control.Arrow.Mix.Utilities",
          "name": "arrCancelUnit",
          "normalized": "a(b,())(c,())-\u003ea b c",
          "package": "mix-arrows",
          "partial": "Cancel Unit",
          "signature": "a(b,())(d,())-\u003ea b d",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/mix-arrows/docs/Control-Arrow-Mix-Utilities.html#v:arrCancelUnit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Arrow.Mix.Utilities",
          "name": "arrSwap",
          "package": "mix-arrows",
          "signature": "a (t, t1) (t2, t3) -\u003e a (t1, t) (t3, t2)",
          "source": "src/Control-Arrow-Mix-Utilities.html#arrSwap",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Arrow Mix Utilities",
          "module": "Control.Arrow.Mix.Utilities",
          "name": "arrSwap",
          "normalized": "a(b,b)(b,b)-\u003ea(b,b)(b,b)",
          "package": "mix-arrows",
          "partial": "Swap",
          "signature": "a(t,t)(t,t)-\u003ea(t,t)(t,t)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/mix-arrows/docs/Control-Arrow-Mix-Utilities.html#v:arrSwap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Arrow.Mix.Utilities",
          "name": "arrTwist",
          "package": "mix-arrows",
          "signature": "a (t, (t1, t2)) (t4, (t3, t5)) -\u003e a (t1, (t, t2)) (t3, (t4, t5))",
          "source": "src/Control-Arrow-Mix-Utilities.html#arrTwist",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Arrow Mix Utilities",
          "module": "Control.Arrow.Mix.Utilities",
          "name": "arrTwist",
          "normalized": "a(b,(b,b))(b,(b,b))-\u003ea(b,(b,b))(b,(b,b))",
          "package": "mix-arrows",
          "partial": "Twist",
          "signature": "a(t,(t,t))(t,(t,t))-\u003ea(t,(t,t))(t,(t,t))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/mix-arrows/docs/Control-Arrow-Mix-Utilities.html#v:arrTwist"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Arrow.Mix.Utilities",
          "name": "arrUnpack",
          "package": "mix-arrows",
          "signature": "a (Either (x, b) (x, d)) (Either (y, c) (y, d)) -\u003e a (x, Either b d) (y, Either c d)",
          "source": "src/Control-Arrow-Mix-Utilities.html#arrUnpack",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Arrow Mix Utilities",
          "module": "Control.Arrow.Mix.Utilities",
          "name": "arrUnpack",
          "normalized": "a(Either(b,c)(b,d))(Either(e,f)(e,d))-\u003ea(b,Either c d)(e,Either f d)",
          "package": "mix-arrows",
          "partial": "Unpack",
          "signature": "a(Either(x,b)(x,d))(Either(y,c)(y,d))-\u003ea(x,Either b d)(y,Either c d)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/mix-arrows/docs/Control-Arrow-Mix-Utilities.html#v:arrUnpack"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Arrow.Mix.Utilities",
          "name": "assocLtoR",
          "package": "mix-arrows",
          "signature": "((t, t1), t2) -\u003e (t, (t1, t2))",
          "source": "src/Control-Arrow-Mix-Utilities.html#assocLtoR",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Arrow Mix Utilities",
          "module": "Control.Arrow.Mix.Utilities",
          "name": "assocLtoR",
          "normalized": "((a,a),a)-\u003e(a,(a,a))",
          "package": "mix-arrows",
          "partial": "Lto",
          "signature": "((t,t),t)-\u003e(t,(t,t))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/mix-arrows/docs/Control-Arrow-Mix-Utilities.html#v:assocLtoR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Arrow.Mix.Utilities",
          "name": "assocRtoL",
          "package": "mix-arrows",
          "signature": "(t1, (t2, t)) -\u003e ((t1, t2), t)",
          "source": "src/Control-Arrow-Mix-Utilities.html#assocRtoL",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Arrow Mix Utilities",
          "module": "Control.Arrow.Mix.Utilities",
          "name": "assocRtoL",
          "normalized": "(a,(a,a))-\u003e((a,a),a)",
          "package": "mix-arrows",
          "partial": "Rto",
          "signature": "(t,(t,t))-\u003e((t,t),t)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/mix-arrows/docs/Control-Arrow-Mix-Utilities.html#v:assocRtoL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Arrow.Mix.Utilities",
          "name": "pack",
          "package": "mix-arrows",
          "signature": "Either (y, c) (y, d) -\u003e (y, Either c d)",
          "source": "src/Control-Arrow-Mix-Utilities.html#pack",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Arrow Mix Utilities",
          "module": "Control.Arrow.Mix.Utilities",
          "name": "pack",
          "normalized": "Either(a,b)(a,c)-\u003e(a,Either b c)",
          "package": "mix-arrows",
          "signature": "Either(y,c)(y,d)-\u003e(y,Either c d)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/mix-arrows/docs/Control-Arrow-Mix-Utilities.html#v:pack"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Arrow.Mix.Utilities",
          "name": "swap",
          "package": "mix-arrows",
          "signature": "(t1, t) -\u003e (t, t1)",
          "source": "src/Control-Arrow-Mix-Utilities.html#swap",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Arrow Mix Utilities",
          "module": "Control.Arrow.Mix.Utilities",
          "name": "swap",
          "normalized": "(a,a)-\u003e(a,a)",
          "package": "mix-arrows",
          "signature": "(t,t)-\u003e(t,t)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/mix-arrows/docs/Control-Arrow-Mix-Utilities.html#v:swap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Arrow.Mix.Utilities",
          "name": "twist",
          "package": "mix-arrows",
          "signature": "(t1, (t, t2)) -\u003e (t, (t1, t2))",
          "source": "src/Control-Arrow-Mix-Utilities.html#twist",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Arrow Mix Utilities",
          "module": "Control.Arrow.Mix.Utilities",
          "name": "twist",
          "normalized": "(a,(a,a))-\u003e(a,(a,a))",
          "package": "mix-arrows",
          "signature": "(t,(t,t))-\u003e(t,(t,t))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/mix-arrows/docs/Control-Arrow-Mix-Utilities.html#v:twist"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Arrow.Mix.Utilities",
          "name": "unpack",
          "package": "mix-arrows",
          "signature": "(x, Either b d) -\u003e Either (x, b) (x, d)",
          "source": "src/Control-Arrow-Mix-Utilities.html#unpack",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Arrow Mix Utilities",
          "module": "Control.Arrow.Mix.Utilities",
          "name": "unpack",
          "normalized": "(a,Either b c)-\u003eEither(a,b)(a,c)",
          "package": "mix-arrows",
          "signature": "(x,Either b d)-\u003eEither(x,b)(x,d)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/mix-arrows/docs/Control-Arrow-Mix-Utilities.html#v:unpack"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eWe try to mix effects of two completely unrelated arrows \u003ccode\u003ea\u003c/code\u003e and \u003ccode\u003eb\u003c/code\u003e, where \u003ccode\u003eb\u003c/code\u003e is considered pure, and \u003ccode\u003ea\u003c/code\u003e &#8212; impure. Probably the most common use case would be \u003ccode\u003ea = Kleisli IO\u003c/code\u003e. We perform all the pure calculations first, and do the impure ones later.\n\u003c/p\u003e\u003cp\u003eUsage example:\n\u003c/p\u003e\u003cpre\u003enewtype Test input output = Test {runTest :: (Kleisli IO :+ Kleisli (State String)) input output}\n    deriving (Category, Arrow, ArrowChoice, ArrowLoop)\n\nrunStateMorphism :: s -\u003e Kleisli (State s) :~\u003e (-\u003e)\nrunStateMorphism s al input = evalState (runKleisli al input) s\nexecTest :: Test input output -\u003e input -\u003e IO output\nexecTest t = runKleisli $ unPlus $ alMap (runStateMorphism \"\") $ runTest t\n\nrd = Test {runTest = liftImpure $ Kleisli $ const getLine}\nwr = Test {runTest = liftImpure $ Kleisli putStrLn}\ngt = Test {runTest = liftPure $ Kleisli $ const get}\npt = Test {runTest = liftPure $ Kleisli put}\n\ntest =\n    proc () -\u003e\n        do line \u003c- rd -\u003c ()  -- effect from IO\n           pt -\u003c line        -- effect from State\n           line' \u003c- gt -\u003c () -- effect from State\n           wr -\u003c line'       -- effect from IO\n\u003c/pre\u003e\u003c/div\u003e",
          "module": "Control.Arrow.Mix",
          "name": "Mix",
          "package": "mix-arrows",
          "source": "src/Control-Arrow-Mix.html",
          "type": "module"
        },
        "index": {
          "description": "We try to mix effects of two completely unrelated arrows and where is considered pure and impure Probably the most common use case would be Kleisli IO We perform all the pure calculations first and do the impure ones later Usage example newtype Test input output Test runTest Kleisli IO Kleisli State String input output deriving Category Arrow ArrowChoice ArrowLoop runStateMorphism Kleisli State runStateMorphism al input evalState runKleisli al input execTest Test input output input IO output execTest runKleisli unPlus alMap runStateMorphism runTest rd Test runTest liftImpure Kleisli const getLine wr Test runTest liftImpure Kleisli putStrLn gt Test runTest liftPure Kleisli const get pt Test runTest liftPure Kleisli put test proc do line rd effect from IO pt line effect from State line gt effect from State wr line effect from IO",
          "hierarchy": "Control Arrow Mix",
          "module": "Control.Arrow.Mix",
          "name": "Mix",
          "package": "mix-arrows",
          "partial": "Mix",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/mix-arrows/docs/Control-Arrow-Mix.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003ea :+ b\u003c/code\u003e is an arrow incapsulating both \u003ccode\u003ea\u003c/code\u003e and \u003ccode\u003eb\u003c/code\u003e effects. It's functorial (and even monadic) in \u003ccode\u003eb\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Arrow.Mix",
          "name": ":+",
          "package": "mix-arrows",
          "source": "src/Control-Arrow-Mix.html#%3A%2B",
          "type": "data"
        },
        "index": {
          "description": "is an arrow incapsulating both and effects It functorial and even monadic in",
          "hierarchy": "Control Arrow Mix",
          "module": "Control.Arrow.Mix",
          "name": ":+",
          "package": "mix-arrows",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/mix-arrows/docs/Control-Arrow-Mix.html#t::-43-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWe can lift impure arrows\n\u003c/p\u003e",
          "module": "Control.Arrow.Mix",
          "name": "liftImpure",
          "package": "mix-arrows",
          "signature": "a :~\u003e (a :+ b)",
          "source": "src/Control-Arrow-Mix.html#liftImpure",
          "type": "function"
        },
        "index": {
          "description": "We can lift impure arrows",
          "hierarchy": "Control Arrow Mix",
          "module": "Control.Arrow.Mix",
          "name": "liftImpure",
          "package": "mix-arrows",
          "partial": "Impure",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/mix-arrows/docs/Control-Arrow-Mix.html#v:liftImpure"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePure arrows can be lifted too\n\u003c/p\u003e",
          "module": "Control.Arrow.Mix",
          "name": "liftPure",
          "package": "mix-arrows",
          "signature": "b :~\u003e (a :+ b)",
          "source": "src/Control-Arrow-Mix.html#liftPure",
          "type": "function"
        },
        "index": {
          "description": "Pure arrows can be lifted too",
          "hierarchy": "Control Arrow Mix",
          "module": "Control.Arrow.Mix",
          "name": "liftPure",
          "package": "mix-arrows",
          "partial": "Pure",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/mix-arrows/docs/Control-Arrow-Mix.html#v:liftPure"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e(:+) is also associative\n\u003c/p\u003e",
          "module": "Control.Arrow.Mix",
          "name": "plusAssoc",
          "package": "mix-arrows",
          "signature": "(a :+ (b :+ c)) :~\u003e ((a :+ b) :+ c)",
          "source": "src/Control-Arrow-Mix.html#plusAssoc",
          "type": "function"
        },
        "index": {
          "description": "is also associative",
          "hierarchy": "Control Arrow Mix",
          "module": "Control.Arrow.Mix",
          "name": "plusAssoc",
          "package": "mix-arrows",
          "partial": "Assoc",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/mix-arrows/docs/Control-Arrow-Mix.html#v:plusAssoc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ethis function is experimental - no idea about how this would interact with other arrow combinators and functions defined in this module\n\u003c/p\u003e",
          "module": "Control.Arrow.Mix",
          "name": "plusCommute",
          "package": "mix-arrows",
          "signature": "(a :+ b) :~\u003e (b :+ a)",
          "source": "src/Control-Arrow-Mix.html#plusCommute",
          "type": "function"
        },
        "index": {
          "description": "this function is experimental no idea about how this would interact with other arrow combinators and functions defined in this module",
          "hierarchy": "Control Arrow Mix",
          "module": "Control.Arrow.Mix",
          "name": "plusCommute",
          "package": "mix-arrows",
          "partial": "Commute",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/mix-arrows/docs/Control-Arrow-Mix.html#v:plusCommute"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e(:+) is right commutative-associative: a :+ (b :+ c) and b :+ (a :+ c) can be reduced to one another with \u003ccode\u003eplusTwist\u003c/code\u003e function\n\u003c/p\u003e",
          "module": "Control.Arrow.Mix",
          "name": "plusTwist",
          "package": "mix-arrows",
          "signature": "(a :+ f c) :~\u003e f (a :+ c)",
          "source": "src/Control-Arrow-Mix.html#plusTwist",
          "type": "function"
        },
        "index": {
          "description": "is right commutative-associative and can be reduced to one another with plusTwist function",
          "hierarchy": "Control Arrow Mix",
          "module": "Control.Arrow.Mix",
          "name": "plusTwist",
          "package": "mix-arrows",
          "partial": "Twist",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/mix-arrows/docs/Control-Arrow-Mix.html#v:plusTwist"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWe need some way to extract the real computation from this \u003ccode\u003e:+\u003c/code\u003e; fortunately, if we manage to reduce the pure arrow to a function (using \u003ccode\u003ealMap\u003c/code\u003e), we can reduce the type \u003ccode\u003ea :+ (-\u003e)\u003c/code\u003e to \u003ccode\u003ea\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Arrow.Mix",
          "name": "unPlus",
          "package": "mix-arrows",
          "signature": "(a :+ (-\u003e)) :~\u003e a",
          "source": "src/Control-Arrow-Mix.html#unPlus",
          "type": "function"
        },
        "index": {
          "description": "We need some way to extract the real computation from this fortunately if we manage to reduce the pure arrow to function using alMap we can reduce the type to",
          "hierarchy": "Control Arrow Mix",
          "module": "Control.Arrow.Mix",
          "name": "unPlus",
          "normalized": "(a(-\u003e))a",
          "package": "mix-arrows",
          "partial": "Plus",
          "signature": "(a(-\u003e))a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/mix-arrows/docs/Control-Arrow-Mix.html#v:unPlus"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIf, for some reason, the \"pure\" arrow is, in fact, as impure as the \"impure\" one, we still can extract the real computation.\n\u003c/p\u003e",
          "module": "Control.Arrow.Mix",
          "name": "unPlus'",
          "package": "mix-arrows",
          "signature": "(a :+ a) :~\u003e a",
          "source": "src/Control-Arrow-Mix.html#unPlus%27",
          "type": "function"
        },
        "index": {
          "description": "If for some reason the pure arrow is in fact as impure as the impure one we still can extract the real computation",
          "hierarchy": "Control Arrow Mix",
          "module": "Control.Arrow.Mix",
          "name": "unPlus'",
          "package": "mix-arrows",
          "partial": "Plus'",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/mix-arrows/docs/Control-Arrow-Mix.html#v:unPlus-39-"
      }
    }
  ]
]