[
  {
    "cmd": "delete-by-query",
    "query": {
      "contexts": [
        "package"
      ],
      "query": {
        "op": "case",
        "type": "word",
        "word": "hbayes"
      },
      "type": "context"
    }
  },
  [
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eModule for building Bayesian Networks\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Bayes.BayesianNetwork",
          "name": "BayesianNetwork",
          "package": "hbayes",
          "source": "src/Bayes-BayesianNetwork.html",
          "type": "module"
        },
        "index": {
          "description": "Module for building Bayesian Networks",
          "hierarchy": "Bayes BayesianNetwork",
          "module": "Bayes.BayesianNetwork",
          "name": "BayesianNetwork",
          "package": "hbayes",
          "partial": "Bayesian Network",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-BayesianNetwork.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe Bayesian monad\n\u003c/p\u003e",
          "module": "Bayes.BayesianNetwork",
          "name": "BNMonad",
          "package": "hbayes",
          "source": "src/Bayes-BayesianNetwork.html#BNMonad",
          "type": "type"
        },
        "index": {
          "description": "The Bayesian monad",
          "hierarchy": "Bayes BayesianNetwork",
          "module": "Bayes.BayesianNetwork",
          "name": "BNMonad",
          "package": "hbayes",
          "partial": "BNMonad",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-BayesianNetwork.html#t:BNMonad"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA distribution which can be used to create a factor\n\u003c/p\u003e",
          "module": "Bayes.BayesianNetwork",
          "name": "Distribution",
          "package": "hbayes",
          "source": "src/Bayes-Factor.html#Distribution",
          "type": "class"
        },
        "index": {
          "description": "distribution which can be used to create factor",
          "hierarchy": "Bayes BayesianNetwork",
          "module": "Bayes.BayesianNetwork",
          "name": "Distribution",
          "package": "hbayes",
          "partial": "Distribution",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-BayesianNetwork.html#t:Distribution"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInitialize the values of a factor\n\u003c/p\u003e",
          "module": "Bayes.BayesianNetwork",
          "name": "(~~)",
          "package": "hbayes",
          "signature": "BNMonad g f v-\u003e d-\u003e BNMonad g f ()",
          "type": "function"
        },
        "index": {
          "description": "Initialize the values of factor",
          "hierarchy": "Bayes BayesianNetwork",
          "module": "Bayes.BayesianNetwork",
          "name": "(~~) ~~",
          "normalized": "BNMonad a b c-\u003ed-\u003eBNMonad a b()",
          "package": "hbayes",
          "signature": "BNMonad g f v-\u003ed-\u003eBNMonad g f()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-BayesianNetwork.html#v:-126--126-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Bayes.BayesianNetwork",
          "name": "(.|.)",
          "package": "hbayes",
          "signature": "LE -\u003e LE -\u003e LE",
          "source": "src/Bayes-BayesianNetwork.html#.%7C.",
          "type": "function"
        },
        "index": {
          "hierarchy": "Bayes BayesianNetwork",
          "module": "Bayes.BayesianNetwork",
          "name": "(.|.) .|.",
          "normalized": "LE-\u003eLE-\u003eLE",
          "package": "hbayes",
          "signature": "LE-\u003eLE-\u003eLE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-BayesianNetwork.html#v:.-124-."
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Bayes.BayesianNetwork",
          "name": "(.!.)",
          "package": "hbayes",
          "signature": "LE -\u003e LE",
          "source": "src/Bayes-BayesianNetwork.html#.%21.",
          "type": "function"
        },
        "index": {
          "hierarchy": "Bayes BayesianNetwork",
          "module": "Bayes.BayesianNetwork",
          "name": "(.!.) .!.",
          "normalized": "LE-\u003eLE",
          "package": "hbayes",
          "signature": "LE-\u003eLE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-BayesianNetwork.html#v:.-33-."
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Bayes.BayesianNetwork",
          "name": "(.&.)",
          "package": "hbayes",
          "signature": "LE -\u003e LE -\u003e LE",
          "source": "src/Bayes-BayesianNetwork.html#.%26.",
          "type": "function"
        },
        "index": {
          "hierarchy": "Bayes BayesianNetwork",
          "module": "Bayes.BayesianNetwork",
          "name": "(.&.) .&.",
          "normalized": "LE-\u003eLE-\u003eLE",
          "package": "hbayes",
          "signature": "LE-\u003eLE-\u003eLE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-BayesianNetwork.html#v:.-38-."
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreate a variable instantiation using values from\n an enumeration\n\u003c/p\u003e",
          "module": "Bayes.BayesianNetwork",
          "name": "(.==.)",
          "package": "hbayes",
          "signature": "d -\u003e v -\u003e LE",
          "source": "src/Bayes-BayesianNetwork.html#.%3D%3D.",
          "type": "function"
        },
        "index": {
          "description": "Create variable instantiation using values from an enumeration",
          "hierarchy": "Bayes BayesianNetwork",
          "module": "Bayes.BayesianNetwork",
          "name": "(.==.) .==.",
          "normalized": "a-\u003eb-\u003eLE",
          "package": "hbayes",
          "signature": "d-\u003ev-\u003eLE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-BayesianNetwork.html#v:.-61--61-."
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDefine a conditional probability between different variables\n Variables are ordered like\n FFF FFT FTF FTT TFF TFT TTF TTT\n and same for other enumeration keeping enumeration order\n Note that the reverse is important. We add the parents in such a way that \u003ccode\u003e\u003ca\u003eingoing\u003c/a\u003e\u003c/code\u003e\n will give a list of parents in the right order.\n This order must correspond to the order of values in the initialization.\n\u003c/p\u003e",
          "module": "Bayes.BayesianNetwork",
          "name": "cpt",
          "package": "hbayes",
          "signature": "v -\u003e [vb] -\u003e BNMonad g f v",
          "source": "src/Bayes-BayesianNetwork.html#cpt",
          "type": "function"
        },
        "index": {
          "description": "Define conditional probability between different variables Variables are ordered like FFF FFT FTF FTT TFF TFT TTF TTT and same for other enumeration keeping enumeration order Note that the reverse is important We add the parents in such way that ingoing will give list of parents in the right order This order must correspond to the order of values in the initialization",
          "hierarchy": "Bayes BayesianNetwork",
          "module": "Bayes.BayesianNetwork",
          "name": "cpt",
          "normalized": "a-\u003e[b]-\u003eBNMonad c d a",
          "package": "hbayes",
          "signature": "v-\u003e[vb]-\u003eBNMonad g f v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-BayesianNetwork.html#v:cpt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreate a factor from variables and a distributions for those variables\n\u003c/p\u003e",
          "module": "Bayes.BayesianNetwork",
          "name": "createFactor",
          "package": "hbayes",
          "signature": "[DV] -\u003e d -\u003e Maybe f",
          "source": "src/Bayes-Factor.html#createFactor",
          "type": "method"
        },
        "index": {
          "description": "Create factor from variables and distributions for those variables",
          "hierarchy": "Bayes BayesianNetwork",
          "module": "Bayes.BayesianNetwork",
          "name": "createFactor",
          "normalized": "[DV]-\u003ea-\u003eMaybe b",
          "package": "hbayes",
          "partial": "Factor",
          "signature": "[DV]-\u003ed-\u003eMaybe f",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-BayesianNetwork.html#v:createFactor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreate a bayesian network but only returns the monad value.\n Mainly used for testing.\n\u003c/p\u003e",
          "module": "Bayes.BayesianNetwork",
          "name": "evalBN",
          "package": "hbayes",
          "signature": "BNMonad DirectedSG f a -\u003e a",
          "source": "src/Bayes-BayesianNetwork.html#evalBN",
          "type": "function"
        },
        "index": {
          "description": "Create bayesian network but only returns the monad value Mainly used for testing",
          "hierarchy": "Bayes BayesianNetwork",
          "module": "Bayes.BayesianNetwork",
          "name": "evalBN",
          "normalized": "BNMonad DirectedSG a b-\u003eb",
          "package": "hbayes",
          "partial": "BN",
          "signature": "BNMonad DirectedSG f a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-BayesianNetwork.html#v:evalBN"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreate a  network but only returns the monad value.\n Mainly used for testing.\n\u003c/p\u003e",
          "module": "Bayes.BayesianNetwork",
          "name": "execBN",
          "package": "hbayes",
          "signature": "BNMonad DirectedSG f a -\u003e SBN f",
          "source": "src/Bayes-BayesianNetwork.html#execBN",
          "type": "function"
        },
        "index": {
          "description": "Create network but only returns the monad value Mainly used for testing",
          "hierarchy": "Bayes BayesianNetwork",
          "module": "Bayes.BayesianNetwork",
          "name": "execBN",
          "normalized": "BNMonad DirectedSG a b-\u003eSBN a",
          "package": "hbayes",
          "partial": "BN",
          "signature": "BNMonad DirectedSG f a-\u003eSBN f",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-BayesianNetwork.html#v:execBN"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Bayes.BayesianNetwork",
          "name": "logical",
          "package": "hbayes",
          "signature": "TDV Bool -\u003e LE -\u003e BNMonad g f ()",
          "source": "src/Bayes-BayesianNetwork.html#logical",
          "type": "function"
        },
        "index": {
          "hierarchy": "Bayes BayesianNetwork",
          "module": "Bayes.BayesianNetwork",
          "name": "logical",
          "normalized": "TDV Bool-\u003eLE-\u003eBNMonad a b()",
          "package": "hbayes",
          "signature": "TDV Bool-\u003eLE-\u003eBNMonad g f()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-BayesianNetwork.html#v:logical"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eNoisy OR. The Noisy-OR with leak can be implemented by using the\n standard Noisy-OR and a leak variable.\n\u003c/p\u003e",
          "module": "Bayes.BayesianNetwork",
          "name": "noisyOR",
          "package": "hbayes",
          "signature": "[(TDV Bool, Double)]-\u003e BNMonad g f (TDV Bool)",
          "type": "function"
        },
        "index": {
          "description": "Noisy OR The Noisy-OR with leak can be implemented by using the standard Noisy-OR and leak variable",
          "hierarchy": "Bayes BayesianNetwork",
          "module": "Bayes.BayesianNetwork",
          "name": "noisyOR",
          "normalized": "[(TDV Bool,Double)]-\u003eBNMonad a b(TDV Bool)",
          "package": "hbayes",
          "partial": "OR",
          "signature": "[(TDV Bool,Double)]-\u003eBNMonad g f(TDV Bool)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-BayesianNetwork.html#v:noisyOR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDefine proba for a variable\n Values are ordered like\n FFF FFT FTF FTT TFF TFT TTF TTT\n and same for other enumeration keeping enumeration order\n\u003c/p\u003e",
          "module": "Bayes.BayesianNetwork",
          "name": "proba",
          "package": "hbayes",
          "signature": "v -\u003e BNMonad g f v",
          "source": "src/Bayes-BayesianNetwork.html#proba",
          "type": "function"
        },
        "index": {
          "description": "Define proba for variable Values are ordered like FFF FFT FTF FTT TFF TFT TTF TTT and same for other enumeration keeping enumeration order",
          "hierarchy": "Bayes BayesianNetwork",
          "module": "Bayes.BayesianNetwork",
          "name": "proba",
          "normalized": "a-\u003eBNMonad b c a",
          "package": "hbayes",
          "signature": "v-\u003eBNMonad g f v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-BayesianNetwork.html#v:proba"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreate a  network using the simple graph implementation\n The initialized nodes are replaced by the value.\n Returns the monad values and the built graph.\n\u003c/p\u003e",
          "module": "Bayes.BayesianNetwork",
          "name": "runBN",
          "package": "hbayes",
          "signature": "BNMonad DirectedSG f a -\u003e (a, SBN f)",
          "source": "src/Bayes-BayesianNetwork.html#runBN",
          "type": "function"
        },
        "index": {
          "description": "Create network using the simple graph implementation The initialized nodes are replaced by the value Returns the monad values and the built graph",
          "hierarchy": "Bayes BayesianNetwork",
          "module": "Bayes.BayesianNetwork",
          "name": "runBN",
          "normalized": "BNMonad DirectedSG a b-\u003e(b,SBN a)",
          "package": "hbayes",
          "partial": "BN",
          "signature": "BNMonad DirectedSG f a-\u003e(a,SBN f)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-BayesianNetwork.html#v:runBN"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSoft evidence factor\n\u003c/p\u003e",
          "module": "Bayes.BayesianNetwork",
          "name": "se",
          "package": "hbayes",
          "signature": "TDV s-\u003e TDV s-\u003e Double-\u003e Maybe f",
          "type": "function"
        },
        "index": {
          "description": "Soft evidence factor",
          "hierarchy": "Bayes BayesianNetwork",
          "module": "Bayes.BayesianNetwork",
          "name": "se",
          "normalized": "TDV a-\u003eTDV a-\u003eDouble-\u003eMaybe b",
          "package": "hbayes",
          "signature": "TDV s-\u003eTDV s-\u003eDouble-\u003eMaybe f",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-BayesianNetwork.html#v:se"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreate an auxiliairy node to force soft evidence\n\u003c/p\u003e",
          "module": "Bayes.BayesianNetwork",
          "name": "softEvidence",
          "package": "hbayes",
          "signature": "TDV Bool-\u003e BNMonad g f (TDV Bool)",
          "type": "function"
        },
        "index": {
          "description": "Create an auxiliairy node to force soft evidence",
          "hierarchy": "Bayes BayesianNetwork",
          "module": "Bayes.BayesianNetwork",
          "name": "softEvidence",
          "normalized": "TDV Bool-\u003eBNMonad a b(TDV Bool)",
          "package": "hbayes",
          "partial": "Evidence",
          "signature": "TDV Bool-\u003eBNMonad g f(TDV Bool)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-BayesianNetwork.html#v:softEvidence"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSynonym for undefined because it is clearer to use t to set the Enum bounds of a variable\n\u003c/p\u003e",
          "module": "Bayes.BayesianNetwork",
          "name": "t",
          "package": "hbayes",
          "signature": "a",
          "source": "src/Bayes-BayesianNetwork.html#t",
          "type": "function"
        },
        "index": {
          "description": "Synonym for undefined because it is clearer to use to set the Enum bounds of variable",
          "hierarchy": "Bayes BayesianNetwork",
          "module": "Bayes.BayesianNetwork",
          "name": "t",
          "package": "hbayes",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-BayesianNetwork.html#v:t"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTyped discrete variable\n\u003c/p\u003e",
          "module": "[\"Bayes.BayesianNetwork\",\"Bayes.Factor\"]",
          "name": "tdv",
          "package": "hbayes",
          "signature": "DV -\u003e TDV s",
          "source": "src/Bayes-PrivateTypes.html#tdv",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hbayes/docs/Bayes-BayesianNetwork.html#v:tdv\",\"http://hackage.haskell.org/package/hbayes/docs/Bayes-Factor.html#v:tdv\"]"
        },
        "index": {
          "description": "Typed discrete variable",
          "hierarchy": "Bayes BayesianNetwork",
          "module": "Bayes.BayesianNetwork",
          "name": "tdv",
          "normalized": "DV-\u003eTDV a",
          "package": "hbayes",
          "signature": "DV-\u003eTDV s",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-BayesianNetwork.html#v:tdv"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreate a new unamed variable\n\u003c/p\u003e",
          "module": "Bayes.BayesianNetwork",
          "name": "unamedVariable",
          "package": "hbayes",
          "signature": "a-\u003e NetworkMonad g e f (TDV a)",
          "type": "function"
        },
        "index": {
          "description": "Create new unamed variable",
          "hierarchy": "Bayes BayesianNetwork",
          "module": "Bayes.BayesianNetwork",
          "name": "unamedVariable",
          "normalized": "a-\u003eNetworkMonad b c d(TDV a)",
          "package": "hbayes",
          "partial": "Variable",
          "signature": "a-\u003eNetworkMonad g e f(TDV a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-BayesianNetwork.html#v:unamedVariable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDefine a Bayesian variable (name and bounds)\n\u003c/p\u003e",
          "module": "Bayes.BayesianNetwork",
          "name": "variable",
          "package": "hbayes",
          "signature": "String-\u003e a-\u003e NetworkMonad g e f (TDV a)",
          "type": "function"
        },
        "index": {
          "description": "Define Bayesian variable name and bounds",
          "hierarchy": "Bayes BayesianNetwork",
          "module": "Bayes.BayesianNetwork",
          "name": "variable",
          "normalized": "String-\u003ea-\u003eNetworkMonad b c d(TDV a)",
          "package": "hbayes",
          "signature": "String-\u003ea-\u003eNetworkMonad g e f(TDV a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-BayesianNetwork.html#v:variable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDefine a Bayesian variable (name and bounds)\n\u003c/p\u003e",
          "module": "Bayes.BayesianNetwork",
          "name": "variableWithSize",
          "package": "hbayes",
          "signature": "String-\u003e Int-\u003e NetworkMonad g e f DV",
          "type": "function"
        },
        "index": {
          "description": "Define Bayesian variable name and bounds",
          "hierarchy": "Bayes BayesianNetwork",
          "module": "Bayes.BayesianNetwork",
          "name": "variableWithSize",
          "normalized": "String-\u003eInt-\u003eNetworkMonad a b c DV",
          "package": "hbayes",
          "partial": "With Size",
          "signature": "String-\u003eInt-\u003eNetworkMonad g e f DV",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-BayesianNetwork.html#v:variableWithSize"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Bayes.Continuous",
          "name": "Continuous",
          "package": "hbayes",
          "source": "src/Bayes-Continuous.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Bayes Continuous",
          "module": "Bayes.Continuous",
          "name": "Continuous",
          "package": "hbayes",
          "partial": "Continuous",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-Continuous.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA Bayesian Variable is a variable part of Bayesian network and so which knows\n its position : the vertex.\n\u003c/p\u003e",
          "module": "Bayes.Continuous",
          "name": "BayesianVariable",
          "package": "hbayes",
          "source": "src/Bayes-PrivateTypes.html#BayesianVariable",
          "type": "class"
        },
        "index": {
          "description": "Bayesian Variable is variable part of Bayesian network and so which knows its position the vertex",
          "hierarchy": "Bayes Continuous",
          "module": "Bayes.Continuous",
          "name": "BayesianVariable",
          "package": "hbayes",
          "partial": "Bayesian Variable",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-Continuous.html#t:BayesianVariable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe Bayesian monad\n\u003c/p\u003e",
          "module": "Bayes.Continuous",
          "name": "CNMonad",
          "package": "hbayes",
          "source": "src/Bayes-Continuous.html#CNMonad",
          "type": "type"
        },
        "index": {
          "description": "The Bayesian monad",
          "hierarchy": "Bayes Continuous",
          "module": "Bayes.Continuous",
          "name": "CNMonad",
          "package": "hbayes",
          "partial": "CNMonad",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-Continuous.html#t:CNMonad"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA continuous variable\n\u003c/p\u003e",
          "module": "Bayes.Continuous",
          "name": "CV",
          "package": "hbayes",
          "source": "src/Bayes-PrivateTypes.html#CV",
          "type": "data"
        },
        "index": {
          "description": "continuous variable",
          "hierarchy": "Bayes Continuous",
          "module": "Bayes.Continuous",
          "name": "CV",
          "package": "hbayes",
          "partial": "CV",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-Continuous.html#t:CV"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA continuous variable instantiation \n\u003c/p\u003e",
          "module": "Bayes.Continuous",
          "name": "CVI",
          "package": "hbayes",
          "source": "src/Bayes-PrivateTypes.html#CVI",
          "type": "data"
        },
        "index": {
          "description": "continuous variable instantiation",
          "hierarchy": "Bayes Continuous",
          "module": "Bayes.Continuous",
          "name": "CVI",
          "package": "hbayes",
          "partial": "CVI",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-Continuous.html#t:CVI"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Bayes.Continuous",
          "name": "ContinuousNetwork",
          "package": "hbayes",
          "source": "src/Bayes-Sampling.html#ContinuousNetwork",
          "type": "type"
        },
        "index": {
          "hierarchy": "Bayes Continuous",
          "module": "Bayes.Continuous",
          "name": "ContinuousNetwork",
          "package": "hbayes",
          "partial": "Continuous Network",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-Continuous.html#t:ContinuousNetwork"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Bayes.Continuous",
          "name": "ContinuousSample",
          "package": "hbayes",
          "source": "src/Bayes-Sampling.html#ContinuousSample",
          "type": "type"
        },
        "index": {
          "hierarchy": "Bayes Continuous",
          "module": "Bayes.Continuous",
          "name": "ContinuousSample",
          "package": "hbayes",
          "partial": "Continuous Sample",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-Continuous.html#t:ContinuousSample"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn expression which can be a constant, variable or formula.\n In case it is a variable, it can be used as a \u003ccode\u003e\u003ca\u003eBayesianVariable\u003c/a\u003e\u003c/code\u003e\n or instantiated as an \u003ccode\u003e\u003ca\u003eInstantiable\u003c/a\u003e\u003c/code\u003e type.\n Otherwise you'll get an error\n\u003c/p\u003e",
          "module": "Bayes.Continuous",
          "name": "DN",
          "package": "hbayes",
          "source": "src/Bayes-Continuous.html#DN",
          "type": "data"
        },
        "index": {
          "description": "An expression which can be constant variable or formula In case it is variable it can be used as BayesianVariable or instantiated as an Instantiable type Otherwise you ll get an error",
          "hierarchy": "Bayes Continuous",
          "module": "Bayes.Continuous",
          "name": "DN",
          "package": "hbayes",
          "partial": "DN",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-Continuous.html#t:DN"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Bayes.Continuous",
          "name": "Distri",
          "package": "hbayes",
          "source": "src/Bayes-Sampling.html#Distri",
          "type": "data"
        },
        "index": {
          "hierarchy": "Bayes Continuous",
          "module": "Bayes.Continuous",
          "name": "Distri",
          "package": "hbayes",
          "partial": "Distri",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-Continuous.html#t:Distri"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Bayes.Continuous",
          "name": "InstantiationValue",
          "package": "hbayes",
          "source": "src/Bayes-PrivateTypes.html#InstantiationValue",
          "type": "class"
        },
        "index": {
          "hierarchy": "Bayes Continuous",
          "module": "Bayes.Continuous",
          "name": "InstantiationValue",
          "package": "hbayes",
          "partial": "Instantiation Value",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-Continuous.html#t:InstantiationValue"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis class is used to simplify the network description. Variable\n names can be optional. In that later case, () must be used instead of a name.\n\u003c/p\u003e",
          "module": "Bayes.Continuous",
          "name": "VariableName",
          "package": "hbayes",
          "source": "src/Bayes-Continuous.html#VariableName",
          "type": "class"
        },
        "index": {
          "description": "This class is used to simplify the network description Variable names can be optional In that later case must be used instead of name",
          "hierarchy": "Bayes Continuous",
          "module": "Bayes.Continuous",
          "name": "VariableName",
          "package": "hbayes",
          "partial": "Variable Name",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-Continuous.html#t:VariableName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreate a variable instantiation using values from\n an enumeration\n\u003c/p\u003e",
          "module": "[\"Bayes.Continuous\",\"Bayes.Factor\"]",
          "name": "(=:)",
          "package": "hbayes",
          "signature": "d -\u003e v -\u003e r",
          "source": "src/Bayes-PrivateTypes.html#%3D%3A",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hbayes/docs/Bayes-Continuous.html#v:-61-:\",\"http://hackage.haskell.org/package/hbayes/docs/Bayes-Factor.html#v:-61-:\"]"
        },
        "index": {
          "description": "Create variable instantiation using values from an enumeration",
          "hierarchy": "Bayes Continuous",
          "module": "Bayes.Continuous",
          "name": "(=:) =:",
          "normalized": "a-\u003eb-\u003ec",
          "package": "hbayes",
          "signature": "d-\u003ev-\u003er",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-Continuous.html#v:-61-:"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eBeta distribution \n\u003c/p\u003e",
          "module": "Bayes.Continuous",
          "name": "beta",
          "package": "hbayes",
          "signature": "s -\u003e DN -\u003e DN -\u003e CNMonad DN",
          "source": "src/Bayes-Continuous.html#beta",
          "type": "function"
        },
        "index": {
          "description": "Beta distribution",
          "hierarchy": "Bayes Continuous",
          "module": "Bayes.Continuous",
          "name": "beta",
          "normalized": "a-\u003eDN-\u003eDN-\u003eCNMonad DN",
          "package": "hbayes",
          "signature": "s-\u003eDN-\u003eDN-\u003eCNMonad DN",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-Continuous.html#v:beta"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eBeta' distribution \n\u003c/p\u003e",
          "module": "Bayes.Continuous",
          "name": "beta'",
          "package": "hbayes",
          "signature": "s -\u003e DN -\u003e DN -\u003e CNMonad DN",
          "source": "src/Bayes-Continuous.html#beta%27",
          "type": "function"
        },
        "index": {
          "description": "Beta distribution",
          "hierarchy": "Bayes Continuous",
          "module": "Bayes.Continuous",
          "name": "beta'",
          "normalized": "a-\u003eDN-\u003eDN-\u003eCNMonad DN",
          "package": "hbayes",
          "signature": "s-\u003eDN-\u003eDN-\u003eCNMonad DN",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-Continuous.html#v:beta-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGibbs sampling for continuous network \n\u003c/p\u003e",
          "module": "[\"Bayes.Continuous\",\"Bayes.Sampling\"]",
          "name": "continuousMCMCSampler",
          "package": "hbayes",
          "signature": "ContinuousNetwork-\u003e [CVI]-\u003e Sampler DirectedSG CVI",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hbayes/docs/Bayes-Continuous.html#v:continuousMCMCSampler\",\"http://hackage.haskell.org/package/hbayes/docs/Bayes-Sampling.html#v:continuousMCMCSampler\"]"
        },
        "index": {
          "description": "Gibbs sampling for continuous network",
          "hierarchy": "Bayes Continuous",
          "module": "Bayes.Continuous",
          "name": "continuousMCMCSampler",
          "normalized": "ContinuousNetwork-\u003e[CVI]-\u003eSampler DirectedSG CVI",
          "package": "hbayes",
          "partial": "MCMCSampler",
          "signature": "ContinuousNetwork-\u003e[CVI]-\u003eSampler DirectedSG CVI",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-Continuous.html#v:continuousMCMCSampler"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreate a bayesian network but only returns the monad value.\n Mainly used for testing.\n\u003c/p\u003e",
          "module": "Bayes.Continuous",
          "name": "evalCN",
          "package": "hbayes",
          "signature": "CNMonad a -\u003e a",
          "source": "src/Bayes-Continuous.html#evalCN",
          "type": "function"
        },
        "index": {
          "description": "Create bayesian network but only returns the monad value Mainly used for testing",
          "hierarchy": "Bayes Continuous",
          "module": "Bayes.Continuous",
          "name": "evalCN",
          "normalized": "CNMonad a-\u003ea",
          "package": "hbayes",
          "partial": "CN",
          "signature": "CNMonad a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-Continuous.html#v:evalCN"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreate a  network but only returns the monad value.\n Mainly used for testing.\n\u003c/p\u003e",
          "module": "Bayes.Continuous",
          "name": "execCN",
          "package": "hbayes",
          "signature": "CNMonad a -\u003e ContinuousNetwork",
          "source": "src/Bayes-Continuous.html#execCN",
          "type": "function"
        },
        "index": {
          "description": "Create network but only returns the monad value Mainly used for testing",
          "hierarchy": "Bayes Continuous",
          "module": "Bayes.Continuous",
          "name": "execCN",
          "normalized": "CNMonad a-\u003eContinuousNetwork",
          "package": "hbayes",
          "partial": "CN",
          "signature": "CNMonad a-\u003eContinuousNetwork",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-Continuous.html#v:execCN"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExponential distribution \n\u003c/p\u003e",
          "module": "Bayes.Continuous",
          "name": "exponential",
          "package": "hbayes",
          "signature": "s -\u003e DN -\u003e CNMonad DN",
          "source": "src/Bayes-Continuous.html#exponential",
          "type": "function"
        },
        "index": {
          "description": "Exponential distribution",
          "hierarchy": "Bayes Continuous",
          "module": "Bayes.Continuous",
          "name": "exponential",
          "normalized": "a-\u003eDN-\u003eCNMonad DN",
          "package": "hbayes",
          "signature": "s-\u003eDN-\u003eCNMonad DN",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-Continuous.html#v:exponential"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCompute the histogram of values\n\u003c/p\u003e",
          "module": "[\"Bayes.Continuous\",\"Bayes.Sampling\"]",
          "name": "histogram",
          "package": "hbayes",
          "signature": "Int-\u003e [Double]-\u003e [(Double, Double, Double)]",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hbayes/docs/Bayes-Continuous.html#v:histogram\",\"http://hackage.haskell.org/package/hbayes/docs/Bayes-Sampling.html#v:histogram\"]"
        },
        "index": {
          "description": "Compute the histogram of values",
          "hierarchy": "Bayes Continuous",
          "module": "Bayes.Continuous",
          "name": "histogram",
          "normalized": "Int-\u003e[Double]-\u003e[(Double,Double,Double)]",
          "package": "hbayes",
          "signature": "Int-\u003e[Double]-\u003e[(Double,Double,Double)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-Continuous.html#v:histogram"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Bayes.Continuous",
          "name": "instantiationValue",
          "package": "hbayes",
          "signature": "i -\u003e v",
          "source": "src/Bayes-PrivateTypes.html#instantiationValue",
          "type": "method"
        },
        "index": {
          "hierarchy": "Bayes Continuous",
          "module": "Bayes.Continuous",
          "name": "instantiationValue",
          "normalized": "a-\u003eb",
          "package": "hbayes",
          "partial": "Value",
          "signature": "i-\u003ev",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-Continuous.html#v:instantiationValue"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Bayes.Continuous",
          "name": "mkVariable",
          "package": "hbayes",
          "signature": "m -\u003e CNMonad CV",
          "source": "src/Bayes-Continuous.html#mkVariable",
          "type": "method"
        },
        "index": {
          "hierarchy": "Bayes Continuous",
          "module": "Bayes.Continuous",
          "name": "mkVariable",
          "normalized": "a-\u003eCNMonad CV",
          "package": "hbayes",
          "partial": "Variable",
          "signature": "m-\u003eCNMonad CV",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-Continuous.html#v:mkVariable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eNormal distribution\n\u003c/p\u003e",
          "module": "Bayes.Continuous",
          "name": "normal",
          "package": "hbayes",
          "signature": "s-\u003e DN-\u003e DN-\u003e CNMonad DN",
          "type": "function"
        },
        "index": {
          "description": "Normal distribution",
          "hierarchy": "Bayes Continuous",
          "module": "Bayes.Continuous",
          "name": "normal",
          "normalized": "a-\u003eDN-\u003eDN-\u003eCNMonad DN",
          "package": "hbayes",
          "signature": "s-\u003eDN-\u003eDN-\u003eCNMonad DN",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-Continuous.html#v:normal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreate a  network using the simple graph implementation\n The initialized nodes are replaced by the value.\n Returns the monad values and the built graph.\n\u003c/p\u003e",
          "module": "Bayes.Continuous",
          "name": "runCN",
          "package": "hbayes",
          "signature": "CNMonad a -\u003e (a, ContinuousNetwork)",
          "source": "src/Bayes-Continuous.html#runCN",
          "type": "function"
        },
        "index": {
          "description": "Create network using the simple graph implementation The initialized nodes are replaced by the value Returns the monad values and the built graph",
          "hierarchy": "Bayes Continuous",
          "module": "Bayes.Continuous",
          "name": "runCN",
          "normalized": "CNMonad a-\u003e(a,ContinuousNetwork)",
          "package": "hbayes",
          "partial": "CN",
          "signature": "CNMonad a-\u003e(a,ContinuousNetwork)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-Continuous.html#v:runCN"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSample a bayesian network using a given sampling scheme\n\u003c/p\u003e",
          "module": "[\"Bayes.Continuous\",\"Bayes.Sampling\"]",
          "name": "runSampling",
          "package": "hbayes",
          "signature": "Int-\u003e Int-\u003e Sampler g a-\u003e IO [Sample g a]",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hbayes/docs/Bayes-Continuous.html#v:runSampling\",\"http://hackage.haskell.org/package/hbayes/docs/Bayes-Sampling.html#v:runSampling\"]"
        },
        "index": {
          "description": "Sample bayesian network using given sampling scheme",
          "hierarchy": "Bayes Continuous",
          "module": "Bayes.Continuous",
          "name": "runSampling",
          "normalized": "Int-\u003eInt-\u003eSampler a b-\u003eIO[Sample a b]",
          "package": "hbayes",
          "partial": "Sampling",
          "signature": "Int-\u003eInt-\u003eSampler g a-\u003eIO[Sample g a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-Continuous.html#v:runSampling"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGenerate a graph of sampling histogram for each variable\n So, for a vertex v we have the posterior values p(v)\n\u003c/p\u003e",
          "module": "[\"Bayes.Continuous\",\"Bayes.Sampling\"]",
          "name": "samplingHistograms",
          "package": "hbayes",
          "signature": "Int-\u003e [Sample g i]-\u003e Sample g [(Double, Double, Double)]",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hbayes/docs/Bayes-Continuous.html#v:samplingHistograms\",\"http://hackage.haskell.org/package/hbayes/docs/Bayes-Sampling.html#v:samplingHistograms\"]"
        },
        "index": {
          "description": "Generate graph of sampling histogram for each variable So for vertex we have the posterior values",
          "hierarchy": "Bayes Continuous",
          "module": "Bayes.Continuous",
          "name": "samplingHistograms",
          "normalized": "Int-\u003e[Sample a b]-\u003eSample a[(Double,Double,Double)]",
          "package": "hbayes",
          "partial": "Histograms",
          "signature": "Int-\u003e[Sample g i]-\u003eSample g[(Double,Double,Double)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-Continuous.html#v:samplingHistograms"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Bayes.Continuous",
          "name": "toDouble",
          "package": "hbayes",
          "signature": "i -\u003e Double",
          "source": "src/Bayes-PrivateTypes.html#toDouble",
          "type": "method"
        },
        "index": {
          "hierarchy": "Bayes Continuous",
          "module": "Bayes.Continuous",
          "name": "toDouble",
          "normalized": "a-\u003eDouble",
          "package": "hbayes",
          "partial": "Double",
          "signature": "i-\u003eDouble",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-Continuous.html#v:toDouble"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUniform dstribution\n\u003c/p\u003e",
          "module": "Bayes.Continuous",
          "name": "uniform",
          "package": "hbayes",
          "signature": "s-\u003e DN-\u003e DN-\u003e CNMonad DN",
          "type": "function"
        },
        "index": {
          "description": "Uniform dstribution",
          "hierarchy": "Bayes Continuous",
          "module": "Bayes.Continuous",
          "name": "uniform",
          "normalized": "a-\u003eDN-\u003eDN-\u003eCNMonad DN",
          "package": "hbayes",
          "signature": "s-\u003eDN-\u003eDN-\u003eCNMonad DN",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-Continuous.html#v:uniform"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Bayes.Continuous",
          "name": "vertex",
          "package": "hbayes",
          "signature": "v -\u003e Vertex",
          "source": "src/Bayes-PrivateTypes.html#vertex",
          "type": "method"
        },
        "index": {
          "hierarchy": "Bayes Continuous",
          "module": "Bayes.Continuous",
          "name": "vertex",
          "normalized": "a-\u003eVertex",
          "package": "hbayes",
          "signature": "v-\u003eVertex",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-Continuous.html#v:vertex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eExpectation / Maximization to learn Bayesian network values\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Bayes.EM",
          "name": "EM",
          "package": "hbayes",
          "source": "src/Bayes-EM.html",
          "type": "module"
        },
        "index": {
          "description": "Expectation Maximization to learn Bayesian network values",
          "hierarchy": "Bayes EM",
          "module": "Bayes.EM",
          "name": "EM",
          "package": "hbayes",
          "partial": "EM",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-EM.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLearn network values from samples using the expectation / maximization algorithm.\n\u003c/p\u003e",
          "module": "Bayes.EM",
          "name": "learnEM",
          "package": "hbayes",
          "signature": "[[DVI]]-\u003e BayesianNetwork g CPT-\u003e BayesianNetwork g CPT",
          "type": "function"
        },
        "index": {
          "description": "Learn network values from samples using the expectation maximization algorithm",
          "hierarchy": "Bayes EM",
          "module": "Bayes.EM",
          "name": "learnEM",
          "normalized": "[[DVI]]-\u003eBayesianNetwork a CPT-\u003eBayesianNetwork a CPT",
          "package": "hbayes",
          "partial": "EM",
          "signature": "[[DVI]]-\u003eBayesianNetwork g CPT-\u003eBayesianNetwork g CPT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-EM.html#v:learnEM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eSampling example with continuous distributions\n\u003c/p\u003e\u003cp\u003eContinuous networks can't be handled by any of the functions defined for the discrete networks.\nSo, instead of using exact inference algorithms like the junction trees, sampling method have to be used.\n\u003c/p\u003e\u003cp\u003eIn this example, we want to estimate a parameter which is measured by noisy sensors.\n\u003c/p\u003e\u003cp\u003eThere are \u003ccode\u003e\u003ca\u003enbSensors\u003c/a\u003e\u003c/code\u003e available. They are described with a \u003ccode\u003e\u003ca\u003enormal\u003c/a\u003e\u003c/code\u003e distribution centered on the value of\nthe unknown parameters and with a standard deviation of 0.1.\n\u003c/p\u003e\u003cp\u003eThe unknown parameter is described with a \u003ccode\u003e\u003ca\u003euniform\u003c/a\u003e\u003c/code\u003e distribution bounded by 1.0 and 2.0.\n\u003c/p\u003e\u003cp\u003eFirst, we describe the sensor:\n\u003c/p\u003e\u003cpre\u003e\nsensor :: \u003ccode\u003e\u003ca\u003eDN\u003c/a\u003e\u003c/code\u003e -\u003e \u003ccode\u003e\u003ca\u003eCNMonad\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eDN\u003c/a\u003e\u003c/code\u003e \nsensor p = do \n    \u003ccode\u003e\u003ca\u003enormal\u003c/a\u003e\u003c/code\u003e () p 0.1 \n\u003c/pre\u003e\u003cp\u003eIt is just a \u003ccode\u003e\u003ca\u003enormal\u003c/a\u003e\u003c/code\u003e distribution. The mean of this distribution is the parameters p. This parameter has special type \u003ccode\u003e\u003ca\u003eDN\u003c/a\u003e\u003c/code\u003e.\nAll expressions used to build the continuous bayesian network are using values of type \u003ccode\u003e\u003ca\u003eDN\u003c/a\u003e\u003c/code\u003e. A value of type \u003ccode\u003e\u003ca\u003eDN\u003c/a\u003e\u003c/code\u003e can either\nrepresent a constant, a variable or an expression.\n\u003c/p\u003e\u003cp\u003eIf the sensor was biased, we could write:\n\u003c/p\u003e\u003cpre\u003e\n    \u003ccode\u003e\u003ca\u003enormal\u003c/a\u003e\u003c/code\u003e ()  (p + 0.2) 0.1\n\u003c/pre\u003e\u003cp\u003eThe Bayesian network describing the measurement process is given by:\n\u003c/p\u003e\u003cpre\u003e\n    test = \u003ccode\u003e\u003ca\u003erunCN\u003c/a\u003e\u003c/code\u003e $ do\n      a \u003c- \u003ccode\u003e\u003ca\u003euniform\u003c/a\u003e\u003c/code\u003e \"a\" 1.0 2.0 -- Unknown parameter\n      sensors \u003c- sequence (replicate \u003ccode\u003e\u003ca\u003enbSensors\u003c/a\u003e\u003c/code\u003e (sensor a))\n      return (a:sensors)\n\u003c/pre\u003e\u003cp\u003eWe are connecting \u003ccode\u003e\u003ca\u003enbSensors\u003c/a\u003e\u003c/code\u003e nodes corresponding to the \u003ccode\u003e\u003ca\u003enbSensors\u003c/a\u003e\u003c/code\u003e measurements.  In real life it can either be different sensors\nor the same one used several times (assuming the value of the parameter is not dependent on time).\n\u003c/p\u003e\u003cp\u003eNow, as usual in all the examples of this package, we get the bayesian graph and a list of variables used\nto compute some posterior or define some evidences\n\u003c/p\u003e\u003cpre\u003e\n    debugcn = do \n        let ((a:sensors), testG) = test\n\u003c/pre\u003e\u003cp\u003eThen, we generate some random measurements and create the evidences\n\u003c/p\u003e\u003cpre\u003e\n    g \u003c- create \n    measurements \u003c- sequence . replicate  nbSensors $ (MWC.normal 1.5 0.1 g)\n    let evidence = zipWith (=:) sensors measurements\n\u003c/pre\u003e\u003cp\u003eEvidence has type \u003ccode\u003e\u003ca\u003eCVI\u003c/a\u003e\u003c/code\u003e and is created with the assigment operator \u003ccode\u003e\u003ca\u003e=:\u003c/a\u003e\u003c/code\u003e .\n\u003c/p\u003e\u003cp\u003eNow, we generate some samples to estimate the posterior distributions.\n\u003c/p\u003e\u003cpre\u003e\n    n \u003c- \u003ccode\u003e\u003ca\u003erunSampling\u003c/a\u003e\u003c/code\u003e 10000 200 (\u003ccode\u003e\u003ca\u003econtinuousMCMCSampler\u003c/a\u003e\u003c/code\u003e testG evidence)\n\u003c/pre\u003e\u003cp\u003eThis function is generating a sequence of graphs ! We are not interested in the sensor values. They are known and fixed\nsince they have been measured. So, we extract the value of the parameter.\n\u003c/p\u003e\u003cpre\u003e\n    let samples = map (g -\u003e \u003ccode\u003e\u003ca\u003einstantiationValue\u003c/a\u003e\u003c/code\u003e . fromJust . \u003ccode\u003e\u003ca\u003evertexValue\u003c/a\u003e\u003c/code\u003e g $ (\u003ccode\u003e\u003ca\u003evertex\u003c/a\u003e\u003c/code\u003e a)) n\n\u003c/pre\u003e\u003cp\u003eAnd with the samples for the parameters we can compute an histogram and get an approximation of the posterior.\n\u003c/p\u003e\u003cpre\u003e\n    let samples = map (g -\u003e \u003ccode\u003e\u003ca\u003einstantiationValue\u003c/a\u003e\u003c/code\u003e . fromJust . \u003ccode\u003e\u003ca\u003evertexValue\u003c/a\u003e\u003c/code\u003e g $ (\u003ccode\u003e\u003ca\u003evertex\u003c/a\u003e\u003c/code\u003e a)) n\n        h = \u003ccode\u003e\u003ca\u003ehistogram\u003c/a\u003e\u003c/code\u003e 6 samples \n    print h\n\u003c/pre\u003e\u003cp\u003eWe see in the histogram that the estimated value is around 1.5.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Bayes.Examples.ContinuousSampling",
          "name": "ContinuousSampling",
          "package": "hbayes",
          "source": "src/Bayes-Examples-ContinuousSampling.html",
          "type": "module"
        },
        "index": {
          "description": "Sampling example with continuous distributions Continuous networks can be handled by any of the functions defined for the discrete networks So instead of using exact inference algorithms like the junction trees sampling method have to be used In this example we want to estimate parameter which is measured by noisy sensors There are nbSensors available They are described with normal distribution centered on the value of the unknown parameters and with standard deviation of The unknown parameter is described with uniform distribution bounded by and First we describe the sensor sensor DN CNMonad DN sensor do normal It is just normal distribution The mean of this distribution is the parameters This parameter has special type DN All expressions used to build the continuous bayesian network are using values of type DN value of type DN can either represent constant variable or an expression If the sensor was biased we could write normal The Bayesian network describing the measurement process is given by test runCN do uniform Unknown parameter sensors sequence replicate nbSensors sensor return sensors We are connecting nbSensors nodes corresponding to the nbSensors measurements In real life it can either be different sensors or the same one used several times assuming the value of the parameter is not dependent on time Now as usual in all the examples of this package we get the bayesian graph and list of variables used to compute some posterior or define some evidences debugcn do let sensors testG test Then we generate some random measurements and create the evidences create measurements sequence replicate nbSensors MWC.normal let evidence zipWith sensors measurements Evidence has type CVI and is created with the assigment operator Now we generate some samples to estimate the posterior distributions runSampling continuousMCMCSampler testG evidence This function is generating sequence of graphs We are not interested in the sensor values They are known and fixed since they have been measured So we extract the value of the parameter let samples map instantiationValue fromJust vertexValue vertex And with the samples for the parameters we can compute an histogram and get an approximation of the posterior let samples map instantiationValue fromJust vertexValue vertex histogram samples print We see in the histogram that the estimated value is around",
          "hierarchy": "Bayes Examples ContinuousSampling",
          "module": "Bayes.Examples.ContinuousSampling",
          "name": "ContinuousSampling",
          "package": "hbayes",
          "partial": "Continuous Sampling",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-Examples-ContinuousSampling.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Bayes.Examples.ContinuousSampling",
          "name": "debugcn",
          "package": "hbayes",
          "signature": "IO ()",
          "source": "src/Bayes-Examples-ContinuousSampling.html#debugcn",
          "type": "function"
        },
        "index": {
          "hierarchy": "Bayes Examples ContinuousSampling",
          "module": "Bayes.Examples.ContinuousSampling",
          "name": "debugcn",
          "normalized": "IO()",
          "package": "hbayes",
          "signature": "IO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-Examples-ContinuousSampling.html#v:debugcn"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Bayes.Examples.ContinuousSampling",
          "name": "nbSensors",
          "package": "hbayes",
          "signature": "Int",
          "source": "src/Bayes-Examples-ContinuousSampling.html#nbSensors",
          "type": "function"
        },
        "index": {
          "hierarchy": "Bayes Examples ContinuousSampling",
          "module": "Bayes.Examples.ContinuousSampling",
          "name": "nbSensors",
          "package": "hbayes",
          "partial": "Sensors",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-Examples-ContinuousSampling.html#v:nbSensors"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Bayes.Examples.ContinuousSampling",
          "name": "sensor",
          "package": "hbayes",
          "signature": "DN -\u003e CNMonad DN",
          "source": "src/Bayes-Examples-ContinuousSampling.html#sensor",
          "type": "function"
        },
        "index": {
          "hierarchy": "Bayes Examples ContinuousSampling",
          "module": "Bayes.Examples.ContinuousSampling",
          "name": "sensor",
          "normalized": "DN-\u003eCNMonad DN",
          "package": "hbayes",
          "signature": "DN-\u003eCNMonad DN",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-Examples-ContinuousSampling.html#v:sensor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Bayes.Examples.ContinuousSampling",
          "name": "test",
          "package": "hbayes",
          "signature": "([DN], ContinuousNetwork)",
          "source": "src/Bayes-Examples-ContinuousSampling.html#test",
          "type": "function"
        },
        "index": {
          "hierarchy": "Bayes Examples ContinuousSampling",
          "module": "Bayes.Examples.ContinuousSampling",
          "name": "test",
          "normalized": "([DN],ContinuousNetwork)",
          "package": "hbayes",
          "signature": "([DN],ContinuousNetwork)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-Examples-ContinuousSampling.html#v:test"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eTest of learning\n\u003c/p\u003e\u003cp\u003eIn this example, two networks are used : \u003ccode\u003esimple\u003c/code\u003e which is the reference and \u003ccode\u003ewrong\u003c/code\u003e which is a wrong start.\nThe goal is to use test patterns to learn the right \u003ccode\u003esimple\u003c/code\u003e network from \u003ccode\u003ewrong\u003c/code\u003e. Only the values are learnt.\nThe topology of both networks is the same.\n\u003c/p\u003e\u003cpre\u003e\nsimple :: ([\u003ccode\u003e\u003ca\u003eTDV\u003c/a\u003e\u003c/code\u003e Bool],\u003ccode\u003e\u003ca\u003eSBN\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eCPT\u003c/a\u003e\u003c/code\u003e)\nsimple = \u003ccode\u003e\u003ca\u003erunBN\u003c/a\u003e\u003c/code\u003e $ do \n    a \u003c- \u003ccode\u003e\u003ca\u003evariable\u003c/a\u003e\u003c/code\u003e \"a\" (\u003ccode\u003e\u003ca\u003et\u003c/a\u003e\u003c/code\u003e :: Bool)\n    b \u003c- \u003ccode\u003e\u003ca\u003evariable\u003c/a\u003e\u003c/code\u003e \"b\" (\u003ccode\u003e\u003ca\u003et\u003c/a\u003e\u003c/code\u003e :: Bool) \n--    \n    \u003ccode\u003e\u003ca\u003eproba\u003c/a\u003e\u003c/code\u003e a \u003ccode\u003e\u003ca\u003e~~\u003c/a\u003e\u003c/code\u003e [0.4,0.6]\n    \u003ccode\u003e\u003ca\u003ecpt\u003c/a\u003e\u003c/code\u003e b [a] \u003ccode\u003e\u003ca\u003e~~\u003c/a\u003e\u003c/code\u003e [0.8,0.2,0.2,0.8]\n--\n    return [a,b]\n\u003c/pre\u003e\u003cp\u003eand \u003ccode\u003ewrong\u003c/code\u003e where the probability for a is wrong.\n\u003c/p\u003e\u003cpre\u003e\nwrong :: ([\u003ccode\u003e\u003ca\u003eTDV\u003c/a\u003e\u003c/code\u003e Bool],\u003ccode\u003e\u003ca\u003eSBN\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eCPT\u003c/a\u003e\u003c/code\u003e)\nwrong = \u003ccode\u003e\u003ca\u003erunBN\u003c/a\u003e\u003c/code\u003e $ do \n    a \u003c- \u003ccode\u003e\u003ca\u003evariable\u003c/a\u003e\u003c/code\u003e \"a\" (\u003ccode\u003e\u003ca\u003et\u003c/a\u003e\u003c/code\u003e :: Bool)\n    b \u003c- \u003ccode\u003e\u003ca\u003evariable\u003c/a\u003e\u003c/code\u003e \"b\" (\u003ccode\u003e\u003ca\u003et\u003c/a\u003e\u003c/code\u003e :: Bool) \n--    \n    \u003ccode\u003e\u003ca\u003eproba\u003c/a\u003e\u003c/code\u003e a \u003ccode\u003e\u003ca\u003e~~\u003c/a\u003e\u003c/code\u003e [0.2,0.8]\n    \u003ccode\u003e\u003ca\u003ecpt\u003c/a\u003e\u003c/code\u003e b [a] \u003ccode\u003e\u003ca\u003e~~\u003c/a\u003e\u003c/code\u003e [0.8,0.2,0.2,0.8]\n--\n    return [a,b]\n\u003c/pre\u003e\u003cp\u003eSo, the first thing to do is generate test patterns. We are using the \u003ccode\u003e\u003ca\u003ediscreteAncestralSampler\u003c/a\u003e\u003c/code\u003e for this. This function is\ngenerating a sequence of graphs. We are just interested in the values. So, we get the values with \u003ccode\u003e\u003ca\u003eallVertexValues\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e\ngeneratePatterns :: IO [[DVI]]\ngeneratePatterns = do \n    let (vars@[a,b],exampleG) = simple\n    r \u003c- \u003ccode\u003e\u003ca\u003erunSampling\u003c/a\u003e\u003c/code\u003e 5000 0 (\u003ccode\u003e\u003ca\u003ediscreteAncestralSampler\u003c/a\u003e\u003c/code\u003e exampleG)\n    return (map \u003ccode\u003e\u003ca\u003eallVertexValues\u003c/a\u003e\u003c/code\u003e r)\n\u003c/pre\u003e\u003cp\u003eOnce we have the data, we can try to learn the network:\n\u003c/p\u003e\u003cpre\u003e\nemTest = do \n  samples \u003c- generatePatterns \n  let (_,simpleG) = simple \n      (_,wrongG) = wrong \n  print simpleG \n  \u003ccode\u003e\u003ca\u003eprintGraphValues\u003c/a\u003e\u003c/code\u003e simpleG\n  \u003ccode\u003e\u003ca\u003eprintGraphValues\u003c/a\u003e\u003c/code\u003e wrongG\n--\n  \u003ccode\u003e\u003ca\u003eprintGraphValues\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003elearnEM\u003c/a\u003e\u003c/code\u003e samples wrongG)\n\u003c/pre\u003e\u003cp\u003eFirst, we display the topology of the graph and the values for the reference graph and the wrong one.\nThen, we use the \u003ccode\u003e\u003ca\u003elearnEM\u003c/a\u003e\u003c/code\u003e function to learn a new network from the samples. And, we print the new values to check.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Bayes.Examples.EMTest",
          "name": "EMTest",
          "package": "hbayes",
          "source": "src/Bayes-Examples-EMTest.html",
          "type": "module"
        },
        "index": {
          "description": "Test of learning In this example two networks are used simple which is the reference and wrong which is wrong start The goal is to use test patterns to learn the right simple network from wrong Only the values are learnt The topology of both networks is the same simple TDV Bool SBN CPT simple runBN do variable Bool variable Bool proba cpt return and wrong where the probability for is wrong wrong TDV Bool SBN CPT wrong runBN do variable Bool variable Bool proba cpt return So the first thing to do is generate test patterns We are using the discreteAncestralSampler for this This function is generating sequence of graphs We are just interested in the values So we get the values with allVertexValues generatePatterns IO DVI generatePatterns do let vars exampleG simple runSampling discreteAncestralSampler exampleG return map allVertexValues Once we have the data we can try to learn the network emTest do samples generatePatterns let simpleG simple wrongG wrong print simpleG printGraphValues simpleG printGraphValues wrongG printGraphValues learnEM samples wrongG First we display the topology of the graph and the values for the reference graph and the wrong one Then we use the learnEM function to learn new network from the samples And we print the new values to check",
          "hierarchy": "Bayes Examples EMTest",
          "module": "Bayes.Examples.EMTest",
          "name": "EMTest",
          "package": "hbayes",
          "partial": "EMTest",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-Examples-EMTest.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Bayes.Examples.EMTest",
          "name": "emTest",
          "package": "hbayes",
          "signature": "IO ()",
          "source": "src/Bayes-Examples-EMTest.html#emTest",
          "type": "function"
        },
        "index": {
          "hierarchy": "Bayes Examples EMTest",
          "module": "Bayes.Examples.EMTest",
          "name": "emTest",
          "normalized": "IO()",
          "package": "hbayes",
          "partial": "Test",
          "signature": "IO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-Examples-EMTest.html#v:emTest"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eExamples of influence diagrams\n\u003c/p\u003e\u003cp\u003eAn influence diagram is an extension of a Bayesian network with can be used to solve some decision problems.\nIn an influence diagram, there are two new kind of nodes : decision nodes and utility nodes.\n\u003c/p\u003e\u003cp\u003eSolving an influence diagram means determining the strategies for each decision variable that will maximize the average utility.\n\u003c/p\u003e\u003cp\u003eThere must be an ordering of the decision variables : a path through all the decisions.\n\u003c/p\u003e\u003cp\u003eA decision variable can depend on other past decisions and probabilistic nodes. In the later case, the variable of \nthe probabilistic node is assumed to be observed before the decision is taken. So, the decision is only trying to \nmaximize the average utility based on what has not been observed (the future and some past probabilistic variables).\n\u003c/p\u003e\u003cp\u003eA probabilistic node can depend on other probabilistic nodes (like in a Bayesian network) and decision nodes.\n\u003c/p\u003e\u003cp\u003eAn utility is a leaf of the graph.\n\u003c/p\u003e\u003cp\u003e\u003cem\u003eExample graph\u003c/em\u003e\n\u003c/p\u003e\u003cp\u003eBuilding an influence diagram is done like for a Bayesian network : by using the right monad.\n\u003c/p\u003e\u003cpre\u003e\nimport Bayes.InfluenceDiagram \nstudentSimple = snd . \u003ccode\u003e\u003ca\u003erunID\u003c/a\u003e\u003c/code\u003e $ do\n\u003c/pre\u003e\u003cp\u003eThen, you create the different nodes of the graph:\n\u003c/p\u003e\u003cpre\u003e\n    e \u003c- \u003ccode\u003e\u003ca\u003edecisionNode\u003c/a\u003e\u003c/code\u003e \"E\" (\u003ccode\u003e\u003ca\u003et\u003c/a\u003e\u003c/code\u003e :: E)\n    uc \u003c- \u003ccode\u003e\u003ca\u003eutilityNode\u003c/a\u003e\u003c/code\u003e \"UC\"\n    ub \u003c- \u003ccode\u003e\u003ca\u003eutilityNode\u003c/a\u003e\u003c/code\u003e \"UB\"\n    i \u003c- \u003ccode\u003e\u003ca\u003echance\u003c/a\u003e\u003c/code\u003e \u003ca\u003eI\u003c/a\u003e (\u003ccode\u003e\u003ca\u003et\u003c/a\u003e\u003c/code\u003e :: I)\n    pr \u003c- \u003ccode\u003e\u003ca\u003echance\u003c/a\u003e\u003c/code\u003e \u003ca\u003eP\u003c/a\u003e (\u003ccode\u003e\u003ca\u003et\u003c/a\u003e\u003c/code\u003e :: Bool)\n\u003c/pre\u003e\u003cp\u003eThe types used above are:\n\u003c/p\u003e\u003cpre\u003e\ndata E = Dont | Do deriving(Eq,Enum,Bounded)\ndata I = Low | Average | High deriving(Eq,Enum,Bounded)\n\u003c/pre\u003e\u003cp\u003eThen, you need to define the dependencies and the numerical values. For probabilistic nodes, it is done like\nfor Bayesian network:\n\u003c/p\u003e\u003cpre\u003e\n    cpt pr [\u003ccode\u003e\u003ca\u003ed\u003c/a\u003e\u003c/code\u003e e] ~~ [1-0.0000001,1 - 0.001,0.0000001, 0.001]\n    cpt i [\u003ccode\u003e\u003ca\u003ep\u003c/a\u003e\u003c/code\u003e pr, \u003ccode\u003e\u003ca\u003ed\u003c/a\u003e\u003c/code\u003e e] ~~ [0.2,0.1,0.01,0.01,0.6,0.5,0.04,0.04,0.2,0.4,0.95,0.95]\n\u003c/pre\u003e\u003cp\u003eThe list may contain decision variables of type \u003ccode\u003e\u003ca\u003eDEV\u003c/a\u003e\u003c/code\u003e and probabilistic variables of type \u003ccode\u003e\u003ca\u003eDV\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eTDV\u003c/a\u003e\u003c/code\u003e. So, the \nfunctions \u003ccode\u003e\u003ca\u003ep\u003c/a\u003e\u003c/code\u003e an \u003ccode\u003e\u003ca\u003ed\u003c/a\u003e\u003c/code\u003e are used for the embedding in the heterogenous list.\n\u003c/p\u003e\u003cp\u003eFor decision nodes, the method is similar but with two differences : The first decision may depend on nothing (just on the assumed future).\nAnd there are no values to define for a decision variable since the goal of the influence diagram is to compute them.\n\u003c/p\u003e\u003cpre\u003e\n    \u003ccode\u003e\u003ca\u003edecision\u003c/a\u003e\u003c/code\u003e e \u003ccode\u003e\u003ca\u003enoDependencies\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e\u003cp\u003eFor the utility nodes, it is similar to probabilistic nodes. You define the dependencies and the numerical values:\n\u003c/p\u003e\u003cpre\u003e\n    \u003ccode\u003e\u003ca\u003eutility\u003c/a\u003e\u003c/code\u003e uc [e] ~~ [0,-50000]\n    \u003ccode\u003e\u003ca\u003eutility\u003c/a\u003e\u003c/code\u003e ub [i] ~~ [100000,200000,500000]\n\u003c/pre\u003e\u003cp\u003eOnce the influence diagram is defined, you can solve it:\n\u003c/p\u003e\u003cpre\u003e\n    \u003ccode\u003e\u003ca\u003esolveInfluenceDiagram\u003c/a\u003e\u003c/code\u003e studentSimple\n\u003c/pre\u003e\u003cp\u003eThe result of this function is the solution : the decision strategies. You may want to display also the original\ngraph to see to which node are corresponding the vertex numbers.\n\u003c/p\u003e\u003cp\u003e\u003cem\u003ePolicy Network\u003c/em\u003e\n\u003c/p\u003e\u003cp\u003eYou can transform a solved influence diagram into a policy network : a Bayesian network where decision variables have been replaced\nwith probabilistic variables where the conditional probability table is containing 1 for a choice of variables corresponding\nto the decision and 0 otherwise.\n\u003c/p\u003e\u003cpre\u003e\n    let l = \u003ccode\u003e\u003ca\u003esolveInfluenceDiagram\u003c/a\u003e\u003c/code\u003e student\n        g = \u003ccode\u003e\u003ca\u003epolicyNetwork\u003c/a\u003e\u003c/code\u003e l student\n    print g \n    \u003ccode\u003e\u003ca\u003eprintGraphValues\u003c/a\u003e\u003c/code\u003e g\n\u003c/pre\u003e\u003c/div\u003e",
          "module": "Bayes.Examples.Influence",
          "name": "Influence",
          "package": "hbayes",
          "source": "src/Bayes-Examples-Influence.html",
          "type": "module"
        },
        "index": {
          "description": "Examples of influence diagrams An influence diagram is an extension of Bayesian network with can be used to solve some decision problems In an influence diagram there are two new kind of nodes decision nodes and utility nodes Solving an influence diagram means determining the strategies for each decision variable that will maximize the average utility There must be an ordering of the decision variables path through all the decisions decision variable can depend on other past decisions and probabilistic nodes In the later case the variable of the probabilistic node is assumed to be observed before the decision is taken So the decision is only trying to maximize the average utility based on what has not been observed the future and some past probabilistic variables probabilistic node can depend on other probabilistic nodes like in Bayesian network and decision nodes An utility is leaf of the graph Example graph Building an influence diagram is done like for Bayesian network by using the right monad import Bayes.InfluenceDiagram studentSimple snd runID do Then you create the different nodes of the graph decisionNode uc utilityNode UC ub utilityNode UB chance pr chance Bool The types used above are data Dont Do deriving Eq Enum Bounded data Low Average High deriving Eq Enum Bounded Then you need to define the dependencies and the numerical values For probabilistic nodes it is done like for Bayesian network cpt pr cpt pr The list may contain decision variables of type DEV and probabilistic variables of type DV or TDV So the functions an are used for the embedding in the heterogenous list For decision nodes the method is similar but with two differences The first decision may depend on nothing just on the assumed future And there are no values to define for decision variable since the goal of the influence diagram is to compute them decision noDependencies For the utility nodes it is similar to probabilistic nodes You define the dependencies and the numerical values utility uc utility ub Once the influence diagram is defined you can solve it solveInfluenceDiagram studentSimple The result of this function is the solution the decision strategies You may want to display also the original graph to see to which node are corresponding the vertex numbers Policy Network You can transform solved influence diagram into policy network Bayesian network where decision variables have been replaced with probabilistic variables where the conditional probability table is containing for choice of variables corresponding to the decision and otherwise let solveInfluenceDiagram student policyNetwork student print printGraphValues",
          "hierarchy": "Bayes Examples Influence",
          "module": "Bayes.Examples.Influence",
          "name": "Influence",
          "package": "hbayes",
          "partial": "Influence",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-Examples-Influence.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eVery simple example with one decision node\n\u003c/p\u003e",
          "module": "Bayes.Examples.Influence",
          "name": "exampleID",
          "package": "hbayes",
          "signature": "InfluenceDiagram",
          "source": "src/Bayes-Examples-Influence.html#exampleID",
          "type": "function"
        },
        "index": {
          "description": "Very simple example with one decision node",
          "hierarchy": "Bayes Examples Influence",
          "module": "Bayes.Examples.Influence",
          "name": "exampleID",
          "package": "hbayes",
          "partial": "ID",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-Examples-Influence.html#v:exampleID"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMarket diagram\n\u003c/p\u003e",
          "module": "Bayes.Examples.Influence",
          "name": "market",
          "package": "hbayes",
          "signature": "InfluenceDiagram",
          "source": "src/Bayes-Examples-Influence.html#market",
          "type": "function"
        },
        "index": {
          "description": "Market diagram",
          "hierarchy": "Bayes Examples Influence",
          "module": "Bayes.Examples.Influence",
          "name": "market",
          "package": "hbayes",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-Examples-Influence.html#v:market"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSolve the \u003ccode\u003e\u003ca\u003emarket\u003c/a\u003e\u003c/code\u003e influence diagram\n\u003c/p\u003e",
          "module": "Bayes.Examples.Influence",
          "name": "marketTest",
          "package": "hbayes",
          "signature": "IO ()",
          "source": "src/Bayes-Examples-Influence.html#marketTest",
          "type": "function"
        },
        "index": {
          "description": "Solve the market influence diagram",
          "hierarchy": "Bayes Examples Influence",
          "module": "Bayes.Examples.Influence",
          "name": "marketTest",
          "normalized": "IO()",
          "package": "hbayes",
          "partial": "Test",
          "signature": "IO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-Examples-Influence.html#v:marketTest"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSolve the influence diagram \u003ccode\u003e\u003ca\u003estudent\u003c/a\u003e\u003c/code\u003e and convert it into\n a policy network\n\u003c/p\u003e",
          "module": "Bayes.Examples.Influence",
          "name": "policyTest",
          "package": "hbayes",
          "signature": "IO ()",
          "source": "src/Bayes-Examples-Influence.html#policyTest",
          "type": "function"
        },
        "index": {
          "description": "Solve the influence diagram student and convert it into policy network",
          "hierarchy": "Bayes Examples Influence",
          "module": "Bayes.Examples.Influence",
          "name": "policyTest",
          "normalized": "IO()",
          "package": "hbayes",
          "partial": "Test",
          "signature": "IO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-Examples-Influence.html#v:policyTest"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eStudent network as found in the book by Barber\n\u003c/p\u003e",
          "module": "Bayes.Examples.Influence",
          "name": "student",
          "package": "hbayes",
          "signature": "InfluenceDiagram",
          "source": "src/Bayes-Examples-Influence.html#student",
          "type": "function"
        },
        "index": {
          "description": "Student network as found in the book by Barber",
          "hierarchy": "Bayes Examples Influence",
          "module": "Bayes.Examples.Influence",
          "name": "student",
          "package": "hbayes",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-Examples-Influence.html#v:student"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Bayes.Examples.Influence",
          "name": "studentDecisionVars",
          "package": "hbayes",
          "signature": "(DEV, TDV Bool, DEV)",
          "source": "src/Bayes-Examples-Influence.html#studentDecisionVars",
          "type": "function"
        },
        "index": {
          "hierarchy": "Bayes Examples Influence",
          "module": "Bayes.Examples.Influence",
          "name": "studentDecisionVars",
          "normalized": "(DEV,TDV Bool,DEV)",
          "package": "hbayes",
          "partial": "Decision Vars",
          "signature": "(DEV,TDV Bool,DEV)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-Examples-Influence.html#v:studentDecisionVars"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eStudent network as found in the book by Barber\n\u003c/p\u003e",
          "module": "Bayes.Examples.Influence",
          "name": "studentSimple",
          "package": "hbayes",
          "signature": "InfluenceDiagram",
          "source": "src/Bayes-Examples-Influence.html#studentSimple",
          "type": "function"
        },
        "index": {
          "description": "Student network as found in the book by Barber",
          "hierarchy": "Bayes Examples Influence",
          "module": "Bayes.Examples.Influence",
          "name": "studentSimple",
          "package": "hbayes",
          "partial": "Simple",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-Examples-Influence.html#v:studentSimple"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Bayes.Examples.Influence",
          "name": "studentSimpleDecisionVar",
          "package": "hbayes",
          "signature": "DEV",
          "source": "src/Bayes-Examples-Influence.html#studentSimpleDecisionVar",
          "type": "function"
        },
        "index": {
          "hierarchy": "Bayes Examples Influence",
          "module": "Bayes.Examples.Influence",
          "name": "studentSimpleDecisionVar",
          "package": "hbayes",
          "partial": "Simple Decision Var",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-Examples-Influence.html#v:studentSimpleDecisionVar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSolve the influences diagrams for the both student network.\n Also displays each network\n\u003c/p\u003e",
          "module": "Bayes.Examples.Influence",
          "name": "theTest",
          "package": "hbayes",
          "signature": "IO ()",
          "source": "src/Bayes-Examples-Influence.html#theTest",
          "type": "function"
        },
        "index": {
          "description": "Solve the influences diagrams for the both student network Also displays each network",
          "hierarchy": "Bayes Examples Influence",
          "module": "Bayes.Examples.Influence",
          "name": "theTest",
          "normalized": "IO()",
          "package": "hbayes",
          "partial": "Test",
          "signature": "IO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-Examples-Influence.html#v:theTest"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eExample of sampling\n\u003c/p\u003e\u003cp\u003eTwo samplers are availables : the \u003ccode\u003e\u003ca\u003ediscreteAncestralSampler\u003c/a\u003e\u003c/code\u003e and the \u003ccode\u003e\u003ca\u003egibbsSampler\u003c/a\u003e\u003c/code\u003e.\nOnly the \u003ccode\u003e\u003ca\u003egibbsSampler\u003c/a\u003e\u003c/code\u003e can be used with evidence.\n\u003c/p\u003e\u003cp\u003eIn this example, we have a very simple network.\n\u003c/p\u003e\u003cpre\u003e\n    simple :: ([\u003ccode\u003e\u003ca\u003eTDV\u003c/a\u003e\u003c/code\u003e Bool],\u003ccode\u003e\u003ca\u003eSBN\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eCPT\u003c/a\u003e\u003c/code\u003e)\n    simple = \u003ccode\u003e\u003ca\u003erunBN\u003c/a\u003e\u003c/code\u003e $ do \n        a \u003c- \u003ccode\u003e\u003ca\u003evariable\u003c/a\u003e\u003c/code\u003e \"a\" (\u003ccode\u003e\u003ca\u003et\u003c/a\u003e\u003c/code\u003e :: Bool)\n        b \u003c- \u003ccode\u003e\u003ca\u003evariable\u003c/a\u003e\u003c/code\u003e \"b\" (\u003ccode\u003e\u003ca\u003et\u003c/a\u003e\u003c/code\u003e :: Bool) \n--        \n        \u003ccode\u003e\u003ca\u003eproba\u003c/a\u003e\u003c/code\u003e a \u003ccode\u003e\u003ca\u003e~~\u003c/a\u003e\u003c/code\u003e [0.4,0.6]\n        \u003ccode\u003e\u003ca\u003ecpt\u003c/a\u003e\u003c/code\u003e b [a] \u003ccode\u003e\u003ca\u003e~~\u003c/a\u003e\u003c/code\u003e [0.8,0.2,0.2,0.8]\n--    \n        return [a,b]\n\u003c/pre\u003e\u003cp\u003eThis network is representing a sensor b. We observe the value of b and we want to infer the value of a.\n\u003c/p\u003e\u003cp\u003eWe use the \u003ccode\u003e\u003ca\u003egibbsSampler\u003c/a\u003e\u003c/code\u003e for this with an initial period of 200 samples which are dropped. The \u003ccode\u003e\u003ca\u003egibbsSampler\u003c/a\u003e\u003c/code\u003e is\ngenerate a stream of samples. From this stream, we need to compute a probability distribution. For this, we use\nthe \u003ccode\u003e\u003ca\u003esamplingHistograms\u003c/a\u003e\u003c/code\u003e histogram function which is generating a list : the probability values of each vertex.\n\u003c/p\u003e\u003cpre\u003e\n    let (vars@[a,b],exampleG) = simple\n    n \u003c- \u003ccode\u003e\u003ca\u003erunSampling\u003c/a\u003e\u003c/code\u003e 5000 200 (\u003ccode\u003e\u003ca\u003egibbsSampler\u003c/a\u003e\u003c/code\u003e exampleG [b \u003ccode\u003e\u003ca\u003e=:\u003c/a\u003e\u003c/code\u003e True])\n    let h = \u003ccode\u003e\u003ca\u003esamplingHistograms\u003c/a\u003e\u003c/code\u003e n\n    print $ h\n\u003c/pre\u003e\u003cp\u003eThen, we compare this result with the exact one we get with a junction tree.\n\u003c/p\u003e\u003cpre\u003e\n    let jt = \u003ccode\u003e\u003ca\u003ecreateJunctionTree\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003enodeComparisonForTriangulation\u003c/a\u003e\u003c/code\u003e exampleG\n        jt' = \u003ccode\u003e\u003ca\u003echangeEvidence\u003c/a\u003e\u003c/code\u003e [b \u003ccode\u003e\u003ca\u003e=:\u003c/a\u003e\u003c/code\u003e True] jt\n    mapM_ (x -\u003e print . \u003ccode\u003e\u003ca\u003eposterior\u003c/a\u003e\u003c/code\u003e jt' $ [x]) vars\n\u003c/pre\u003e\u003cp\u003eWe can also use the \u003ccode\u003e\u003ca\u003ediscreteAncestralSampler\u003c/a\u003e\u003c/code\u003e to compute the posterior but it is not supporting the use of evidence in this\nversion. The syntax is similar.\n\u003c/p\u003e\u003cpre\u003e\n    n \u003c- \u003ccode\u003e\u003ca\u003erunSampling\u003c/a\u003e\u003c/code\u003e 500 (\u003ccode\u003e\u003ca\u003ediscreteAncestralSampler\u003c/a\u003e\u003c/code\u003e exampleG)\n\u003c/pre\u003e\u003c/div\u003e",
          "module": "Bayes.Examples.Sampling",
          "name": "Sampling",
          "package": "hbayes",
          "source": "src/Bayes-Examples-Sampling.html",
          "type": "module"
        },
        "index": {
          "description": "Example of sampling Two samplers are availables the discreteAncestralSampler and the gibbsSampler Only the gibbsSampler can be used with evidence In this example we have very simple network simple TDV Bool SBN CPT simple runBN do variable Bool variable Bool proba cpt return This network is representing sensor We observe the value of and we want to infer the value of We use the gibbsSampler for this with an initial period of samples which are dropped The gibbsSampler is generate stream of samples From this stream we need to compute probability distribution For this we use the samplingHistograms histogram function which is generating list the probability values of each vertex let vars exampleG simple runSampling gibbsSampler exampleG True let samplingHistograms print Then we compare this result with the exact one we get with junction tree let jt createJunctionTree nodeComparisonForTriangulation exampleG jt changeEvidence True jt mapM print posterior jt vars We can also use the discreteAncestralSampler to compute the posterior but it is not supporting the use of evidence in this version The syntax is similar runSampling discreteAncestralSampler exampleG",
          "hierarchy": "Bayes Examples Sampling",
          "module": "Bayes.Examples.Sampling",
          "name": "Sampling",
          "package": "hbayes",
          "partial": "Sampling",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-Examples-Sampling.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Bayes.Examples.Sampling",
          "name": "testSampling",
          "package": "hbayes",
          "signature": "IO ()",
          "source": "src/Bayes-Examples-Sampling.html#testSampling",
          "type": "function"
        },
        "index": {
          "hierarchy": "Bayes Examples Sampling",
          "module": "Bayes.Examples.Sampling",
          "name": "testSampling",
          "normalized": "IO()",
          "package": "hbayes",
          "partial": "Sampling",
          "signature": "IO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-Examples-Sampling.html#v:testSampling"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eTutorial explaining how to make infereces with the library.\n\u003c/p\u003e\u003cp\u003eThus tutorial is using examples from the module \u003ca\u003eBayes.Examples\u003c/a\u003e. Please,\nrefer to this module for documentation about how the example bayesian networks are\ncreated or loaded.\n\u003c/p\u003e\u003cp\u003e\u003cem\u003eInferences\u003c/em\u003e\n\u003c/p\u003e\u003cp\u003eThe function \u003ccode\u003e\u003ca\u003einferencesOnStandardNetwork\u003c/a\u003e\u003c/code\u003e is showing how to use variable elimination\nand factor elimination to make inferences.\n\u003c/p\u003e\u003cp\u003eFirst, the \u003ccode\u003e\u003ca\u003eexample\u003c/a\u003e\u003c/code\u003e is loaded to make its variables and its bayesian network available:\n\u003c/p\u003e\u003cpre\u003e\n    let ([winter,sprinkler,rain,wet,road],exampleG) = example\n\u003c/pre\u003e\u003cp\u003eThen, we compute a prior marginal. Prior means that no evidence is used. A bayesian\nnetwork is a factorisation of a distribution P(A B C ...). If you want to know the\nprobability of only A, you need to sum out the other variables to eliminate them and get\nP(A). To compute this prior marginal using variable elimnation, you need to give an elimination\norder. The complexity of the computation is depending on the elimination order chosen.\n\u003c/p\u003e\u003cp\u003eFor instance, if you want to compute the prior probability of rain, you can write:\n\u003c/p\u003e\u003cpre\u003e\n    \u003ccode\u003e\u003ca\u003epriorMarginal\u003c/a\u003e\u003c/code\u003e exampleG [winter,sprinkler,wet,road] [rain] \n\u003c/pre\u003e\u003cp\u003eNow, if you have observed that the grass is wet and want to take into account thios observation\nto compute the posterior probability of rain (after observation):\n\u003c/p\u003e\u003cpre\u003e\n    \u003ccode\u003e\u003ca\u003eposteriorMarginal\u003c/a\u003e\u003c/code\u003e exampleG [winter,sprinkler,wet,road] [rain]  [wet \u003ccode\u003e\u003ca\u003e=:\u003c/a\u003e\u003c/code\u003e True]\n\u003c/pre\u003e\u003cp\u003eIf you want to combine several observations:\n\u003c/p\u003e\u003cpre\u003e\n    \u003ccode\u003e\u003ca\u003eposteriorMarginal\u003c/a\u003e\u003c/code\u003e exampleG [winter,sprinkler,wet,road] [rain]  [wet \u003ccode\u003e\u003ca\u003e=:\u003c/a\u003e\u003c/code\u003e True, sprinkler \u003ccode\u003e\u003ca\u003e=:\u003c/a\u003e\u003c/code\u003e True]\n\u003c/pre\u003e\u003cp\u003eThere are several problems with variable elimination:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e You have to specify an elimination order \n\u003c/li\u003e\u003cli\u003e If you want to compute another marginal (for instance probability of winter), you have\n to recompute everything.\n\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eBut, there exists another category of elimination algorithms based upon factor elimination. \nThey require the creation of an auxiliary data structure : the junction tree.\n\u003c/p\u003e\u003cp\u003eThis tree is then used for computing all marginals (without having to recompute everything).\nThe junction tree is equivalent to giving an elimination order.\n\u003c/p\u003e\u003cp\u003eSo, the previous examples can also be computed with factor elimination. First, the \njunction tree must created:\n\u003c/p\u003e\u003cpre\u003e\n    let jt = \u003ccode\u003e\u003ca\u003ecreateJunctionTree\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003enodeComparisonForTriangulation\u003c/a\u003e\u003c/code\u003e exampleG\n\u003c/pre\u003e\u003cp\u003eThe junction tree being equivalent to an elimination order, the order chosen will\ndepend on a cost function. In the previous example, the cost function \u003ccode\u003e\u003ca\u003enodeComparisonForTriangulation\u003c/a\u003e\u003c/code\u003e\nis used. Other cost functions may be introduced in a futute version of this library.\n\u003c/p\u003e\u003cp\u003eOnce the junction tree has been computd, it can be used to compute several marginals:\n\u003c/p\u003e\u003cpre\u003e\n    \u003ccode\u003e\u003ca\u003eposterior\u003c/a\u003e\u003c/code\u003e jt [rain]\n\u003c/pre\u003e\u003cp\u003eThe function is called posterior and will compute posterior only when solme evidence has\nbeen introduced into the tree. Otherwise it is computing a prior.\n\u003c/p\u003e\u003cp\u003eTo set evidence, you need to update the junction tree with new evidence:\n\u003c/p\u003e\u003cpre\u003e\n    let jt' = \u003ccode\u003eupdateEvidence\u003c/code\u003e [wet \u003ccode\u003e\u003ca\u003e=:\u003c/a\u003e\u003c/code\u003e True] jt \n    \u003ccode\u003e\u003ca\u003eposterior\u003c/a\u003e\u003c/code\u003e jt' [rain]\n\u003c/pre\u003e\u003cp\u003eIf you want to compute the posterior for a combination of variables, you have two possibilities : either going back to the\nvariable elimination methods. Or, introduce new nodes in the network to represent the query.\n\u003c/p\u003e\u003cp\u003eIt is easily done through the new \u003ccode\u003elogical\u003c/code\u003e function when building the Bayesian graph.\n\u003c/p\u003e\u003cp\u003eOnce you have a node to represent a complex query, you can use it to compute a posterior. For instance, in the rain example,\nthere is a new variable:\n\u003c/p\u003e\u003cpre\u003e\n    roadandrain \u003c- \u003ccode\u003evariable\u003c/code\u003e \"rain and slippery road\" (t :: Bool)\n    \u003ccode\u003elogical\u003c/code\u003e roadandrain ((rain \u003ccode\u003e.==.\u003c/code\u003e True) \u003ccode\u003e.&.\u003c/code\u003e (road \u003ccode\u003e.==.\u003c/code\u003e True))\n\u003c/pre\u003e\u003cp\u003eThis variable is representing the assertion : rain True AND slippery road True. This variable can be used\n to answer different queries, like for instance:\n\u003c/p\u003e\u003cpre\u003e\n    let jt4 = \u003ccode\u003e\u003ca\u003echangeEvidence\u003c/a\u003e\u003c/code\u003e [wet \u003ccode\u003e\u003ca\u003e=:\u003c/a\u003e\u003c/code\u003e True] jt \n    print \"Posterior Marginal : probability of rain and road slippery if grass wet\"\n    let m = \u003ccode\u003e\u003ca\u003eposterior\u003c/a\u003e\u003c/code\u003e jt4 [roadandrain]\n    print m\n--\n    let jt5 = \u003ccode\u003e\u003ca\u003echangeEvidence\u003c/a\u003e\u003c/code\u003e [wet \u003ccode\u003e\u003ca\u003e=:\u003c/a\u003e\u003c/code\u003e True, sprinkler \u003ccode\u003e\u003ca\u003e=:\u003c/a\u003e\u003c/code\u003e False] jt \n    print \"Posterior Marginal : probability of rain and road slippery if grass wet and srinkler not used\"\n    let m = \u003ccode\u003e\u003ca\u003eposterior\u003c/a\u003e\u003c/code\u003e jt5 [roadandrain]\n\u003c/pre\u003e\u003cp\u003e\u003cem\u003eInferences with an imported network\u003c/em\u003e\n\u003c/p\u003e\u003cp\u003eThere is a slight additional difficulty with imported networks : you need\nto create new data type to be able to set evidence.\n\u003c/p\u003e\u003cp\u003eFor instance, in the cancer network there is a Coma variable with levels Present or Absent.\nWhen imported, those levels are imported as number. But, the evidence API in this library is\nrequiring enumerations.\n\u003c/p\u003e\u003cp\u003eSo, you need to create a \u003ccode\u003e\u003ca\u003eComa\u003c/a\u003e\u003c/code\u003e type:\n\u003c/p\u003e\u003cpre\u003e\n    data Coma = Present | Absent deriving(Eq,Enum,Bounded)\n\u003c/pre\u003e\u003cp\u003eand check that \u003ccode\u003e\u003ca\u003ePresent\u003c/a\u003e\u003c/code\u003e is corresponding to the level 0 in the imported network.\n\u003c/p\u003e\u003cp\u003eOnce this datatype is created, you can easily use the cancer network. First we load\nthe network and import the discrete variables of type \u003ccode\u003e\u003ca\u003eDV\u003c/a\u003e\u003c/code\u003e from the names of the nodes in the\nnetwork (not the label of the nodes).\n\u003c/p\u003e\u003cpre\u003e\n    print \"CANCER NETWORK\"\n    (varmap,cancer) \u003c- \u003ccode\u003e\u003ca\u003eexampleImport\u003c/a\u003e\u003c/code\u003e\n    print cancer\n    let [varA,varB,varC,varE] = fromJust $ mapM (flip Map.lookup varmap) [\"A\",\"B\",\"C\",\"E\"]\n\u003c/pre\u003e\u003cp\u003eTo avoid any errors with the future queries, some imported variables can be transformed into typed variables:\n\u003c/p\u003e\u003cpre\u003e\n    varD = \u003ccode\u003e\u003ca\u003etdv\u003c/a\u003e\u003c/code\u003e (fromJust $ Map.lookup \"D\" varmap) :: \u003ccode\u003e\u003ca\u003eTDV\u003c/a\u003e\u003c/code\u003e Coma\n\u003c/pre\u003e\u003cp\u003eOnce the variables are available, you can create the junction tree and start making inferences:\n\u003c/p\u003e\u003cpre\u003e\n    let jtcancer = \u003ccode\u003e\u003ca\u003ecreateJunctionTree\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003enodeComparisonForTriangulation\u003c/a\u003e\u003c/code\u003e cancer\n--\n    mapM_ (x -\u003e putStrLn (show x) \u003e\u003e (print . \u003ccode\u003e\u003ca\u003eposterior\u003c/a\u003e\u003c/code\u003e jtcancer $ [x])) [varA,varB,varC,varE]\n--\n    print \"UPDATED EVIDENCE\"\n    let jtcancer' = \u003ccode\u003eupdateEvidence\u003c/code\u003e [varD \u003ccode\u003e\u003ca\u003e=:\u003c/a\u003e\u003c/code\u003e Present] jtcancer \n    mapM_ (x -\u003e putStrLn (show x) \u003e\u003e (print . \u003ccode\u003e\u003ca\u003eposterior\u003c/a\u003e\u003c/code\u003e jtcancer' $ [x])) [varA,varB,varC,varE]\n\u003c/pre\u003e\u003cp\u003eThe \u003ccode\u003e\u003ca\u003e=:\u003c/a\u003e\u003c/code\u003e operator will check that the assignment is type compatible because varD is a typed discrete variable of type \u003ccode\u003e\u003ca\u003eTDV\u003c/a\u003e\u003c/code\u003e Coma.\n\u003c/p\u003e\u003cp\u003e\u003cem\u003eMPE inferences\u003c/em\u003e\n\u003c/p\u003e\u003cp\u003eIt is possible to compute the Most Probable Explanation for a set of observation. The syntax is very similar to the\nposterior computation with variable elimination:\n\u003c/p\u003e\u003cpre\u003e\n    let m = \u003ccode\u003e\u003ca\u003empe\u003c/a\u003e\u003c/code\u003e exampleG [wet,road] [winter,sprinkler,rain,roadandrain] [wet \u003ccode\u003e\u003ca\u003e=:\u003c/a\u003e\u003c/code\u003e True, road \u003ccode\u003e\u003ca\u003e=:\u003c/a\u003e\u003c/code\u003e True]\n\u003c/pre\u003e\u003cp\u003eThe first list of variables (which should containg the evidence variables) is summed out.\nThe second list of variables is used to maximize the probability.\nBoth lists should contain all variables of the Bayesian network and are defining an elimination order.\n\u003c/p\u003e\u003cp\u003eThe result of the mpe functions is a list of instantiations. The result is easier to read when the type information is\nreintroduced. It can be done with the \u003ccode\u003e\u003ca\u003etdvi\u003c/a\u003e\u003c/code\u003e function:\n\u003c/p\u003e\u003cpre\u003e\n    let typedResult = map (map \u003ccode\u003e\u003ca\u003etdvi\u003c/a\u003e\u003c/code\u003e) m :: [[(\u003ccode\u003e\u003ca\u003eTDV\u003c/a\u003e\u003c/code\u003e Bool,Bool)]]\n\u003c/pre\u003e\u003cp\u003eIn this example, all variables are boolean ones.\n\u003c/p\u003e\u003cp\u003e\u003cem\u003e Soft Evidence \u003c/em\u003e\n\u003c/p\u003e\u003cp\u003eSoft evidence is more complex to handle since new node have to be added to the graph.\nAnd the node factor has to be changed when the node evidence is changed.\n\u003c/p\u003e\u003cp\u003eHere is how you could do it. First you load an example graph containg a soft evidence node created with \u003ccode\u003esoftEvidence\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e\ninferencesWithSoftEvidence = do \n    let ((a,seNode),exampleG) = \u003ccode\u003e\u003ca\u003eexampleSoftEvidence\u003c/a\u003e\u003c/code\u003e \n\u003c/pre\u003e\u003cp\u003eThen, you create the junction tree as usual and force an hard evidence on the soft evidence node.\n\u003c/p\u003e\u003cpre\u003e\n        jt = \u003ccode\u003e\u003ca\u003ecreateJunctionTree\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003enodeComparisonForTriangulation\u003c/a\u003e\u003c/code\u003e exampleG\n        jt' = \u003ccode\u003e\u003ca\u003echangeEvidence\u003c/a\u003e\u003c/code\u003e [seNode \u003ccode\u003e\u003ca\u003e=:\u003c/a\u003e\u003c/code\u003e True] jt\n\u003c/pre\u003e\u003cp\u003eThis junction tree cannot be used because the soft evidence node created in \u003ccode\u003e\u003ca\u003eexampleSoftEvidence\u003c/a\u003e\u003c/code\u003e has a \nprobability table which is meaningless. You need to update the probability table for a given soft evidence.\nYou create a new factor for this:\n\u003c/p\u003e\u003cpre\u003e\n        theNewFactor x = fromJust $ \u003ccode\u003e\u003ca\u003ese\u003c/a\u003e\u003c/code\u003e seNode a x -- x % success for the sensor\n\u003c/pre\u003e\u003cp\u003eThis new factor, can then be used to do inference with different soft evidences.\n\u003c/p\u003e\u003cpre\u003e\n    print \"Sensor 90%\"\n    print $ posterior (\u003ccode\u003e\u003ca\u003echangeFactor\u003c/a\u003e\u003c/code\u003e (theNewFactor 0.9) jt') [a]\n--\n    print \"Sensor 50%\"\n    print $ posterior (\u003ccode\u003e\u003ca\u003echangeFactor\u003c/a\u003e\u003c/code\u003e (theNewFactor 0.5) jt') [a]\n--\n    print \"Sensor 10%\"\n    print $ posterior (\u003ccode\u003e\u003ca\u003echangeFactor\u003c/a\u003e\u003c/code\u003e (theNewFactor 0.1) jt') [a]\n\u003c/pre\u003e\u003c/div\u003e",
          "module": "Bayes.Examples.Tutorial",
          "name": "Tutorial",
          "package": "hbayes",
          "source": "src/Bayes-Examples-Tutorial.html",
          "type": "module"
        },
        "index": {
          "description": "Tutorial explaining how to make infereces with the library Thus tutorial is using examples from the module Bayes.Examples Please refer to this module for documentation about how the example bayesian networks are created or loaded Inferences The function inferencesOnStandardNetwork is showing how to use variable elimination and factor elimination to make inferences First the example is loaded to make its variables and its bayesian network available let winter sprinkler rain wet road exampleG example Then we compute prior marginal Prior means that no evidence is used bayesian network is factorisation of distribution If you want to know the probability of only you need to sum out the other variables to eliminate them and get To compute this prior marginal using variable elimnation you need to give an elimination order The complexity of the computation is depending on the elimination order chosen For instance if you want to compute the prior probability of rain you can write priorMarginal exampleG winter sprinkler wet road rain Now if you have observed that the grass is wet and want to take into account thios observation to compute the posterior probability of rain after observation posteriorMarginal exampleG winter sprinkler wet road rain wet True If you want to combine several observations posteriorMarginal exampleG winter sprinkler wet road rain wet True sprinkler True There are several problems with variable elimination You have to specify an elimination order If you want to compute another marginal for instance probability of winter you have to recompute everything But there exists another category of elimination algorithms based upon factor elimination They require the creation of an auxiliary data structure the junction tree This tree is then used for computing all marginals without having to recompute everything The junction tree is equivalent to giving an elimination order So the previous examples can also be computed with factor elimination First the junction tree must created let jt createJunctionTree nodeComparisonForTriangulation exampleG The junction tree being equivalent to an elimination order the order chosen will depend on cost function In the previous example the cost function nodeComparisonForTriangulation is used Other cost functions may be introduced in futute version of this library Once the junction tree has been computd it can be used to compute several marginals posterior jt rain The function is called posterior and will compute posterior only when solme evidence has been introduced into the tree Otherwise it is computing prior To set evidence you need to update the junction tree with new evidence let jt updateEvidence wet True jt posterior jt rain If you want to compute the posterior for combination of variables you have two possibilities either going back to the variable elimination methods Or introduce new nodes in the network to represent the query It is easily done through the new logical function when building the Bayesian graph Once you have node to represent complex query you can use it to compute posterior For instance in the rain example there is new variable roadandrain variable rain and slippery road Bool logical roadandrain rain True road True This variable is representing the assertion rain True AND slippery road True This variable can be used to answer different queries like for instance let jt4 changeEvidence wet True jt print Posterior Marginal probability of rain and road slippery if grass wet let posterior jt4 roadandrain print let jt5 changeEvidence wet True sprinkler False jt print Posterior Marginal probability of rain and road slippery if grass wet and srinkler not used let posterior jt5 roadandrain Inferences with an imported network There is slight additional difficulty with imported networks you need to create new data type to be able to set evidence For instance in the cancer network there is Coma variable with levels Present or Absent When imported those levels are imported as number But the evidence API in this library is requiring enumerations So you need to create Coma type data Coma Present Absent deriving Eq Enum Bounded and check that Present is corresponding to the level in the imported network Once this datatype is created you can easily use the cancer network First we load the network and import the discrete variables of type DV from the names of the nodes in the network not the label of the nodes print CANCER NETWORK varmap cancer exampleImport print cancer let varA varB varC varE fromJust mapM flip Map.lookup varmap To avoid any errors with the future queries some imported variables can be transformed into typed variables varD tdv fromJust Map.lookup varmap TDV Coma Once the variables are available you can create the junction tree and start making inferences let jtcancer createJunctionTree nodeComparisonForTriangulation cancer mapM putStrLn show print posterior jtcancer varA varB varC varE print UPDATED EVIDENCE let jtcancer updateEvidence varD Present jtcancer mapM putStrLn show print posterior jtcancer varA varB varC varE The operator will check that the assignment is type compatible because varD is typed discrete variable of type TDV Coma MPE inferences It is possible to compute the Most Probable Explanation for set of observation The syntax is very similar to the posterior computation with variable elimination let mpe exampleG wet road winter sprinkler rain roadandrain wet True road True The first list of variables which should containg the evidence variables is summed out The second list of variables is used to maximize the probability Both lists should contain all variables of the Bayesian network and are defining an elimination order The result of the mpe functions is list of instantiations The result is easier to read when the type information is reintroduced It can be done with the tdvi function let typedResult map map tdvi TDV Bool Bool In this example all variables are boolean ones Soft Evidence Soft evidence is more complex to handle since new node have to be added to the graph And the node factor has to be changed when the node evidence is changed Here is how you could do it First you load an example graph containg soft evidence node created with softEvidence inferencesWithSoftEvidence do let seNode exampleG exampleSoftEvidence Then you create the junction tree as usual and force an hard evidence on the soft evidence node jt createJunctionTree nodeComparisonForTriangulation exampleG jt changeEvidence seNode True jt This junction tree cannot be used because the soft evidence node created in exampleSoftEvidence has probability table which is meaningless You need to update the probability table for given soft evidence You create new factor for this theNewFactor fromJust se seNode success for the sensor This new factor can then be used to do inference with different soft evidences print Sensor print posterior changeFactor theNewFactor jt print Sensor print posterior changeFactor theNewFactor jt print Sensor print posterior changeFactor theNewFactor jt",
          "hierarchy": "Bayes Examples Tutorial",
          "module": "Bayes.Examples.Tutorial",
          "name": "Tutorial",
          "package": "hbayes",
          "partial": "Tutorial",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-Examples-Tutorial.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eType defined to set the evidence on the Coma variable\n from the cancer network.\n\u003c/p\u003e",
          "module": "Bayes.Examples.Tutorial",
          "name": "Coma",
          "package": "hbayes",
          "source": "src/Bayes-Examples-Tutorial.html#Coma",
          "type": "data"
        },
        "index": {
          "description": "Type defined to set the evidence on the Coma variable from the cancer network",
          "hierarchy": "Bayes Examples Tutorial",
          "module": "Bayes.Examples.Tutorial",
          "name": "Coma",
          "package": "hbayes",
          "partial": "Coma",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-Examples-Tutorial.html#t:Coma"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Bayes.Examples.Tutorial",
          "name": "Absent",
          "package": "hbayes",
          "signature": "Absent",
          "source": "src/Bayes-Examples-Tutorial.html#Coma",
          "type": "function"
        },
        "index": {
          "hierarchy": "Bayes Examples Tutorial",
          "module": "Bayes.Examples.Tutorial",
          "name": "Absent",
          "package": "hbayes",
          "partial": "Absent",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-Examples-Tutorial.html#v:Absent"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Bayes.Examples.Tutorial",
          "name": "Present",
          "package": "hbayes",
          "signature": "Present",
          "source": "src/Bayes-Examples-Tutorial.html#Coma",
          "type": "function"
        },
        "index": {
          "hierarchy": "Bayes Examples Tutorial",
          "module": "Bayes.Examples.Tutorial",
          "name": "Present",
          "package": "hbayes",
          "partial": "Present",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-Examples-Tutorial.html#v:Present"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInferences with the cancer network\n\u003c/p\u003e",
          "module": "Bayes.Examples.Tutorial",
          "name": "inferencesOnCancerNetwork",
          "package": "hbayes",
          "signature": "IO ()",
          "source": "src/Bayes-Examples-Tutorial.html#inferencesOnCancerNetwork",
          "type": "function"
        },
        "index": {
          "description": "Inferences with the cancer network",
          "hierarchy": "Bayes Examples Tutorial",
          "module": "Bayes.Examples.Tutorial",
          "name": "inferencesOnCancerNetwork",
          "normalized": "IO()",
          "package": "hbayes",
          "partial": "On Cancer Network",
          "signature": "IO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-Examples-Tutorial.html#v:inferencesOnCancerNetwork"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInferences with the standard network\n\u003c/p\u003e",
          "module": "Bayes.Examples.Tutorial",
          "name": "inferencesOnStandardNetwork",
          "package": "hbayes",
          "signature": "IO ()",
          "source": "src/Bayes-Examples-Tutorial.html#inferencesOnStandardNetwork",
          "type": "function"
        },
        "index": {
          "description": "Inferences with the standard network",
          "hierarchy": "Bayes Examples Tutorial",
          "module": "Bayes.Examples.Tutorial",
          "name": "inferencesOnStandardNetwork",
          "normalized": "IO()",
          "package": "hbayes",
          "partial": "On Standard Network",
          "signature": "IO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-Examples-Tutorial.html#v:inferencesOnStandardNetwork"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInferences with soft evidence\n\u003c/p\u003e",
          "module": "Bayes.Examples.Tutorial",
          "name": "inferencesWithSoftEvidence",
          "package": "hbayes",
          "signature": "IO ()",
          "source": "src/Bayes-Examples-Tutorial.html#inferencesWithSoftEvidence",
          "type": "function"
        },
        "index": {
          "description": "Inferences with soft evidence",
          "hierarchy": "Bayes Examples Tutorial",
          "module": "Bayes.Examples.Tutorial",
          "name": "inferencesWithSoftEvidence",
          "normalized": "IO()",
          "package": "hbayes",
          "partial": "With Soft Evidence",
          "signature": "IO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-Examples-Tutorial.html#v:inferencesWithSoftEvidence"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDisplay of factors generated by the logical keyword\n\u003c/p\u003e",
          "module": "Bayes.Examples.Tutorial",
          "name": "logicalTest",
          "package": "hbayes",
          "signature": "IO ()",
          "source": "src/Bayes-Examples-Tutorial.html#logicalTest",
          "type": "function"
        },
        "index": {
          "description": "Display of factors generated by the logical keyword",
          "hierarchy": "Bayes Examples Tutorial",
          "module": "Bayes.Examples.Tutorial",
          "name": "logicalTest",
          "normalized": "IO()",
          "package": "hbayes",
          "partial": "Test",
          "signature": "IO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-Examples-Tutorial.html#v:logicalTest"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Bayes.Examples.Tutorial",
          "name": "miscTest",
          "package": "hbayes",
          "signature": "FilePath -\u003e IO ()",
          "source": "src/Bayes-Examples-Tutorial.html#miscTest",
          "type": "function"
        },
        "index": {
          "hierarchy": "Bayes Examples Tutorial",
          "module": "Bayes.Examples.Tutorial",
          "name": "miscTest",
          "normalized": "FilePath-\u003eIO()",
          "package": "hbayes",
          "partial": "Test",
          "signature": "FilePath-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-Examples-Tutorial.html#v:miscTest"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMost likely explanation on standard network\n\u003c/p\u003e",
          "module": "Bayes.Examples.Tutorial",
          "name": "mpeStandardNetwork",
          "package": "hbayes",
          "signature": "IO ()",
          "source": "src/Bayes-Examples-Tutorial.html#mpeStandardNetwork",
          "type": "function"
        },
        "index": {
          "description": "Most likely explanation on standard network",
          "hierarchy": "Bayes Examples Tutorial",
          "module": "Bayes.Examples.Tutorial",
          "name": "mpeStandardNetwork",
          "normalized": "IO()",
          "package": "hbayes",
          "partial": "Standard Network",
          "signature": "IO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-Examples-Tutorial.html#v:mpeStandardNetwork"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eExamples of networks\n\u003c/p\u003e\u003cp\u003e\u003cem\u003eCreating a simple network\u003c/em\u003e\n\u003c/p\u003e\u003cp\u003eThe \u003ccode\u003e\u003ca\u003eexample\u003c/a\u003e\u003c/code\u003e function is the typical example.\nIt is using the monad \u003ccode\u003e\u003ca\u003eBNMonad\u003c/a\u003e\u003c/code\u003e. The goal of this monad is to offer\na way of describing the network which is natural.\n\u003c/p\u003e\u003cp\u003eThere are only three functions to understand inside the monad:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003evariable\u003c/a\u003e\u003c/code\u003e to create a discrete variable of type \u003ccode\u003e\u003ca\u003eDV\u003c/a\u003e\u003c/code\u003e. Creating a discrete\n  variable is using a \u003ccode\u003e\u003ca\u003eBounded\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003eEnum\u003c/a\u003e\u003c/code\u003e type like for instance \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eproba\u003c/a\u003e\u003c/code\u003e to define the probability P(A) of a variable A\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003ecpt\u003c/a\u003e\u003c/code\u003e  to define the conditional probability table P(A | BC)\n\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eIt is important to understand how the values are organized. If you define\nP( wet | sprinkler road) then you have to give the values in the order:\n\u003c/p\u003e\u003cpre\u003e\nwet=False, sprinkler=False, road=False\nwet=False, sprinkler=False, road=True\nwet=False, sprinkler=True, road=False\nwet=False, sprinkler=True, road=True\n\u003c/pre\u003e\u003cp\u003eFinally, don't forget to return the discrete variables at the end of your network\nconstruction because those variables are used for making inferences.\n\u003c/p\u003e\u003cpre\u003e\nexample :: ([\u003ccode\u003e\u003ca\u003eTDV\u003c/a\u003e\u003c/code\u003e Bool],\u003ccode\u003e\u003ca\u003eSBN\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eCPT\u003c/a\u003e\u003c/code\u003e)\nexample = \u003ccode\u003e\u003ca\u003erunBN\u003c/a\u003e\u003c/code\u003e $ do \n    winter \u003c- \u003ccode\u003e\u003ca\u003evariable\u003c/a\u003e\u003c/code\u003e \"winter\" (t :: Bool)\n    sprinkler \u003c- \u003ccode\u003e\u003ca\u003evariable\u003c/a\u003e\u003c/code\u003e \"sprinkler\" (t :: Bool) \n    wet \u003c- \u003ccode\u003e\u003ca\u003evariable\u003c/a\u003e\u003c/code\u003e \"wet grass\" (t :: Bool) \n    rain \u003c- \u003ccode\u003e\u003ca\u003evariable\u003c/a\u003e\u003c/code\u003e \"rain\" (t :: Bool) \n    road \u003c- \u003ccode\u003e\u003ca\u003evariable\u003c/a\u003e\u003c/code\u003e \"slippery road\" (t :: Bool) \n--\n    \u003ccode\u003e\u003ca\u003eproba\u003c/a\u003e\u003c/code\u003e winter ~~ [0.4,0.6]\n    \u003ccode\u003e\u003ca\u003ecpt\u003c/a\u003e\u003c/code\u003e sprinkler [winter] ~~ [0.25,0.8,0.75,0.2]\n    \u003ccode\u003e\u003ca\u003ecpt\u003c/a\u003e\u003c/code\u003e rain [winter] ~~ [0.9,0.2,0.1,0.8]\n    \u003ccode\u003e\u003ca\u003ecpt\u003c/a\u003e\u003c/code\u003e wet [sprinkler,rain] ~~ [1,0.2,0.1,0.05,0,0.8,0.9,0.95]\n    \u003ccode\u003e\u003ca\u003ecpt\u003c/a\u003e\u003c/code\u003e road [rain] ~~ [1,0.3,0,0.7]\n    return [winter,sprinkler,rain,wet,road]\n\u003c/pre\u003e\u003cp\u003eBy default, all variables are typed (\u003ccode\u003e\u003ca\u003eTDV\u003c/a\u003e\u003c/code\u003e Bool). \u003ccode\u003e\u003ca\u003eTDV\u003c/a\u003e\u003c/code\u003e means Typed Discrete Variable.\n\u003c/p\u003e\u003cp\u003eIn case you are mixing several types, you'll need to remove the type\nto build the \u003ccode\u003e\u003ca\u003ecpt\u003c/a\u003e\u003c/code\u003e since the list can't be heterogeneous. Just use \u003ccode\u003e\u003ca\u003edv\u003c/a\u003e\u003c/code\u003e for this. It will convert the variable into the \ntype \u003ccode\u003e\u003ca\u003eDV\u003c/a\u003e\u003c/code\u003e of untyped discrete variable.\n\u003c/p\u003e\u003cp\u003e\u003cem\u003eCreating truth tables\u003c/em\u003e\n\u003c/p\u003e\u003cp\u003eIn practise, it is easy to compute the posterior of a variable because it is always possible\nto find a cluster containing the variable in the junction tree. But, it is more difficult\nto compute the posterior of a logical assertion or just a conjunction of assertions.\n\u003c/p\u003e\u003cp\u003eIf a query is likely to be done often, then it may be a good idea to add a new node \nto the Bayesian network to represent this query. So, some functions to create truth tables are provided.\n\u003c/p\u003e\u003cpre\u003e\nexampleLogical :: ([\u003ccode\u003e\u003ca\u003eTDV\u003c/a\u003e\u003c/code\u003e Bool], \u003ccode\u003e\u003ca\u003eSBN\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eCPT\u003c/a\u003e\u003c/code\u003e)\nexampleLogical = \u003ccode\u003e\u003ca\u003erunBN\u003c/a\u003e\u003c/code\u003e $ do \n    a \u003c- \u003ccode\u003e\u003ca\u003evariable\u003c/a\u003e\u003c/code\u003e \"a\" (t :: Bool)\n    b \u003c- \u003ccode\u003e\u003ca\u003evariable\u003c/a\u003e\u003c/code\u003e \"b\" (t :: Bool)\n    notV \u003c- \u003ccode\u003e\u003ca\u003evariable\u003c/a\u003e\u003c/code\u003e \"notV\" (t :: Bool)\n    andV \u003c- \u003ccode\u003e\u003ca\u003evariable\u003c/a\u003e\u003c/code\u003e \"andV\" (t :: Bool)\n    orV \u003c- \u003ccode\u003e\u003ca\u003evariable\u003c/a\u003e\u003c/code\u003e \"orV\" (t :: Bool)\n    let ta = a \u003ccode\u003e\u003ca\u003e.==.\u003c/a\u003e\u003c/code\u003e True \n        tb = b \u003ccode\u003e\u003ca\u003e.==.\u003c/a\u003e\u003c/code\u003e True\n    \u003ccode\u003e\u003ca\u003elogical\u003c/a\u003e\u003c/code\u003e notV ((\u003ccode\u003e\u003ca\u003e.!.\u003c/a\u003e\u003c/code\u003e) ta)\n    \u003ccode\u003e\u003ca\u003elogical\u003c/a\u003e\u003c/code\u003e andV (ta \u003ccode\u003e\u003ca\u003e.&.\u003c/a\u003e\u003c/code\u003e tb)\n    \u003ccode\u003e\u003ca\u003elogical\u003c/a\u003e\u003c/code\u003e orV (ta \u003ccode\u003e\u003ca\u003e.|.\u003c/a\u003e\u003c/code\u003e tb)\n    return $ [a,b,notV,andV,orV]\n\u003c/pre\u003e\u003cp\u003eIn the previous example, we force a type on the discrete variables \u003ccode\u003e\u003ca\u003eDV\u003c/a\u003e\u003c/code\u003e to avoid futur errors\nin the instantiations. It is done through the \u003ccode\u003e\u003ca\u003etdv\u003c/a\u003e\u003c/code\u003e function.\n\u003c/p\u003e\u003cp\u003eBut, it is also possible to use the untyped variables and write:\n\u003c/p\u003e\u003cpre\u003e\n    \u003ccode\u003e\u003ca\u003elogical\u003c/a\u003e\u003c/code\u003e andV ((a \u003ccode\u003e\u003ca\u003e.==.\u003c/a\u003e\u003c/code\u003e True) \u003ccode\u003e\u003ca\u003e.&.\u003c/a\u003e\u003c/code\u003e (b \u003ccode\u003e\u003ca\u003e.==.\u003c/a\u003e\u003c/code\u003e True))\n\u003c/pre\u003e\u003cp\u003eThe goal of a Bayesian network is to factorize a big probability table because otherwise the algorithms\ncan't process it. So, of course it is not a good idea to represent a complex logical assertion with a huge\nprobability table. So, the \u003ccode\u003e\u003ca\u003elogical\u003c/a\u003e\u003c/code\u003e keyword should only be used to build small tables.\n\u003c/p\u003e\u003cp\u003eIf you need to encode a complex logical assertion, use \u003ccode\u003e\u003ca\u003elogical\u003c/a\u003e\u003c/code\u003e several times to build a network representing\nthe assertion instead of building just one node to represent it.\n\u003c/p\u003e\u003cp\u003e\u003cem\u003eNoisy OR\u003c/em\u003e\n\u003c/p\u003e\u003cp\u003eThe Noisy OR is a combination of logical tables (OR) and conditional probability tables which is often used\nduring modeling to avoid generating big conditional probability tables.\n\u003c/p\u003e\u003cp\u003eIt is easy to use:\n\u003c/p\u003e\u003cpre\u003e\n    no \u003c- \u003ccode\u003e\u003ca\u003enoisyOR\u003c/a\u003e\u003c/code\u003e [(a,0.1),(b,0.2),(c,0.3)] \n\u003c/pre\u003e\u003cp\u003eEach probability is the probability that a given variable has no effect (so is inhibited in the OR).\n\u003c/p\u003e\u003cp\u003e\u003cem\u003eImporting a network from a Hugin file\u003c/em\u003e\n\u003c/p\u003e\u003cp\u003eThe \u003ccode\u003e\u003ca\u003eexampleImport\u003c/a\u003e\u003c/code\u003e function can be used to import a file in Hugin format.\nOnly a subset of the format is supported.\nThe function will return a mapping from node names to Discrete Variables \u003ccode\u003e\u003ca\u003eDV\u003c/a\u003e\u003c/code\u003e.\nThe node name is used and not the node's label.\nThe function is also returning a simple bayesian network \u003ccode\u003e\u003ca\u003eSBN\u003c/a\u003e\u003c/code\u003e using \u003ccode\u003e\u003ca\u003eCPT\u003c/a\u003e\u003c/code\u003e\nas factors.\n\u003c/p\u003e\u003cp\u003eThe implementation is using \u003ccode\u003egetDataFileName\u003c/code\u003e to find the path of the\ntest pattern installed by cabal.\n\u003c/p\u003e\u003cpre\u003e\nexampleImport :: IO (Map.Map String \u003ccode\u003e\u003ca\u003eDV\u003c/a\u003e\u003c/code\u003e,\u003ccode\u003e\u003ca\u003eSBN\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eCPT\u003c/a\u003e\u003c/code\u003e)\nexampleImport = do \n    path \u003c- \u003ccode\u003egetDataFileName\u003c/code\u003e \"cancer.net\"\n    r \u003c- \u003ccode\u003e\u003ca\u003eimportBayesianGraph\u003c/a\u003e\u003c/code\u003e path\n    return (\u003ccode\u003e\u003ca\u003erunBN\u003c/a\u003e\u003c/code\u003e $ fromJust r)\n\u003c/pre\u003e\u003c/div\u003e",
          "module": "Bayes.Examples",
          "name": "Examples",
          "package": "hbayes",
          "source": "src/Bayes-Examples.html",
          "type": "module"
        },
        "index": {
          "description": "Examples of networks Creating simple network The example function is the typical example It is using the monad BNMonad The goal of this monad is to offer way of describing the network which is natural There are only three functions to understand inside the monad variable to create discrete variable of type DV Creating discrete variable is using Bounded and Enum type like for instance Bool proba to define the probability of variable cpt to define the conditional probability table BC It is important to understand how the values are organized If you define wet sprinkler road then you have to give the values in the order wet False sprinkler False road False wet False sprinkler False road True wet False sprinkler True road False wet False sprinkler True road True Finally don forget to return the discrete variables at the end of your network construction because those variables are used for making inferences example TDV Bool SBN CPT example runBN do winter variable winter Bool sprinkler variable sprinkler Bool wet variable wet grass Bool rain variable rain Bool road variable slippery road Bool proba winter cpt sprinkler winter cpt rain winter cpt wet sprinkler rain cpt road rain return winter sprinkler rain wet road By default all variables are typed TDV Bool TDV means Typed Discrete Variable In case you are mixing several types you ll need to remove the type to build the cpt since the list can be heterogeneous Just use dv for this It will convert the variable into the type DV of untyped discrete variable Creating truth tables In practise it is easy to compute the posterior of variable because it is always possible to find cluster containing the variable in the junction tree But it is more difficult to compute the posterior of logical assertion or just conjunction of assertions If query is likely to be done often then it may be good idea to add new node to the Bayesian network to represent this query So some functions to create truth tables are provided exampleLogical TDV Bool SBN CPT exampleLogical runBN do variable Bool variable Bool notV variable notV Bool andV variable andV Bool orV variable orV Bool let ta True tb True logical notV ta logical andV ta tb logical orV ta tb return notV andV orV In the previous example we force type on the discrete variables DV to avoid futur errors in the instantiations It is done through the tdv function But it is also possible to use the untyped variables and write logical andV True True The goal of Bayesian network is to factorize big probability table because otherwise the algorithms can process it So of course it is not good idea to represent complex logical assertion with huge probability table So the logical keyword should only be used to build small tables If you need to encode complex logical assertion use logical several times to build network representing the assertion instead of building just one node to represent it Noisy OR The Noisy OR is combination of logical tables OR and conditional probability tables which is often used during modeling to avoid generating big conditional probability tables It is easy to use no noisyOR Each probability is the probability that given variable has no effect so is inhibited in the OR Importing network from Hugin file The exampleImport function can be used to import file in Hugin format Only subset of the format is supported The function will return mapping from node names to Discrete Variables DV The node name is used and not the node label The function is also returning simple bayesian network SBN using CPT as factors The implementation is using getDataFileName to find the path of the test pattern installed by cabal exampleImport IO Map.Map String DV SBN CPT exampleImport do path getDataFileName cancer.net importBayesianGraph path return runBN fromJust",
          "hierarchy": "Bayes Examples",
          "module": "Bayes.Examples",
          "name": "Examples",
          "package": "hbayes",
          "partial": "Examples",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-Examples.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Bayes.Examples",
          "name": "anyExample",
          "package": "hbayes",
          "signature": "FilePath -\u003e IO (Map String DV, SBN CPT)",
          "source": "src/Bayes-Examples.html#anyExample",
          "type": "function"
        },
        "index": {
          "hierarchy": "Bayes Examples",
          "module": "Bayes.Examples",
          "name": "anyExample",
          "normalized": "FilePath-\u003eIO(Map String DV,SBN CPT)",
          "package": "hbayes",
          "partial": "Example",
          "signature": "FilePath-\u003eIO(Map String DV,SBN CPT)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-Examples.html#v:anyExample"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eStandard example found in many books about Bayesian Networks.\n\u003c/p\u003e",
          "module": "Bayes.Examples",
          "name": "example",
          "package": "hbayes",
          "signature": "([TDV Bool], SBN CPT)",
          "source": "src/Bayes-Examples.html#example",
          "type": "function"
        },
        "index": {
          "description": "Standard example found in many books about Bayesian Networks",
          "hierarchy": "Bayes Examples",
          "module": "Bayes.Examples",
          "name": "example",
          "normalized": "([TDV Bool],SBN CPT)",
          "package": "hbayes",
          "signature": "([TDV Bool],SBN CPT)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-Examples.html#v:example"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAsia example (not provided with this package)\n\u003c/p\u003e",
          "module": "Bayes.Examples",
          "name": "exampleAsia",
          "package": "hbayes",
          "signature": "IO (Map String DV, SBN CPT)",
          "source": "src/Bayes-Examples.html#exampleAsia",
          "type": "function"
        },
        "index": {
          "description": "Asia example not provided with this package",
          "hierarchy": "Bayes Examples",
          "module": "Bayes.Examples",
          "name": "exampleAsia",
          "normalized": "IO(Map String DV,SBN CPT)",
          "package": "hbayes",
          "partial": "Asia",
          "signature": "IO(Map String DV,SBN CPT)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-Examples.html#v:exampleAsia"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDiabete example (not provided with this package)\n\u003c/p\u003e",
          "module": "Bayes.Examples",
          "name": "exampleDiabete",
          "package": "hbayes",
          "signature": "IO (Map String DV, SBN CPT)",
          "source": "src/Bayes-Examples.html#exampleDiabete",
          "type": "function"
        },
        "index": {
          "description": "Diabete example not provided with this package",
          "hierarchy": "Bayes Examples",
          "module": "Bayes.Examples",
          "name": "exampleDiabete",
          "normalized": "IO(Map String DV,SBN CPT)",
          "package": "hbayes",
          "partial": "Diabete",
          "signature": "IO(Map String DV,SBN CPT)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-Examples.html#v:exampleDiabete"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFarm example (not provided with this package)\n\u003c/p\u003e",
          "module": "Bayes.Examples",
          "name": "exampleFarm",
          "package": "hbayes",
          "signature": "IO (Map String DV, SBN CPT)",
          "source": "src/Bayes-Examples.html#exampleFarm",
          "type": "function"
        },
        "index": {
          "description": "Farm example not provided with this package",
          "hierarchy": "Bayes Examples",
          "module": "Bayes.Examples",
          "name": "exampleFarm",
          "normalized": "IO(Map String DV,SBN CPT)",
          "package": "hbayes",
          "partial": "Farm",
          "signature": "IO(Map String DV,SBN CPT)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-Examples.html#v:exampleFarm"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExample showing how to import a graph described into\n a Hugin file.\n\u003c/p\u003e",
          "module": "Bayes.Examples",
          "name": "exampleImport",
          "package": "hbayes",
          "signature": "IO (Map String DV, SBN CPT)",
          "source": "src/Bayes-Examples.html#exampleImport",
          "type": "function"
        },
        "index": {
          "description": "Example showing how to import graph described into Hugin file",
          "hierarchy": "Bayes Examples",
          "module": "Bayes.Examples",
          "name": "exampleImport",
          "normalized": "IO(Map String DV,SBN CPT)",
          "package": "hbayes",
          "partial": "Import",
          "signature": "IO(Map String DV,SBN CPT)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-Examples.html#v:exampleImport"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Bayes.Examples",
          "name": "exampleJunction",
          "package": "hbayes",
          "signature": "UndirectedSG () Vertex",
          "source": "src/Bayes-Examples.html#exampleJunction",
          "type": "function"
        },
        "index": {
          "hierarchy": "Bayes Examples",
          "module": "Bayes.Examples",
          "name": "exampleJunction",
          "normalized": "UndirectedSG()Vertex",
          "package": "hbayes",
          "partial": "Junction",
          "signature": "UndirectedSG()Vertex",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-Examples.html#v:exampleJunction"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Bayes.Examples",
          "name": "exampleLogical",
          "package": "hbayes",
          "signature": "([TDV Bool], SBN CPT)",
          "source": "src/Bayes-Examples.html#exampleLogical",
          "type": "function"
        },
        "index": {
          "hierarchy": "Bayes Examples",
          "module": "Bayes.Examples",
          "name": "exampleLogical",
          "normalized": "([TDV Bool],SBN CPT)",
          "package": "hbayes",
          "partial": "Logical",
          "signature": "([TDV Bool],SBN CPT)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-Examples.html#v:exampleLogical"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePerso example (not provided with this package)\n\u003c/p\u003e",
          "module": "Bayes.Examples",
          "name": "examplePerso",
          "package": "hbayes",
          "signature": "IO (Map String DV, SBN CPT)",
          "source": "src/Bayes-Examples.html#examplePerso",
          "type": "function"
        },
        "index": {
          "description": "Perso example not provided with this package",
          "hierarchy": "Bayes Examples",
          "module": "Bayes.Examples",
          "name": "examplePerso",
          "normalized": "IO(Map String DV,SBN CPT)",
          "package": "hbayes",
          "partial": "Perso",
          "signature": "IO(Map String DV,SBN CPT)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-Examples.html#v:examplePerso"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePoker example (not provided with this package)\n\u003c/p\u003e",
          "module": "Bayes.Examples",
          "name": "examplePoker",
          "package": "hbayes",
          "signature": "IO (Map String DV, SBN CPT)",
          "source": "src/Bayes-Examples.html#examplePoker",
          "type": "function"
        },
        "index": {
          "description": "Poker example not provided with this package",
          "hierarchy": "Bayes Examples",
          "module": "Bayes.Examples",
          "name": "examplePoker",
          "normalized": "IO(Map String DV,SBN CPT)",
          "package": "hbayes",
          "partial": "Poker",
          "signature": "IO(Map String DV,SBN CPT)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-Examples.html#v:examplePoker"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExample of soft evidence use\n\u003c/p\u003e",
          "module": "Bayes.Examples",
          "name": "exampleSoftEvidence",
          "package": "hbayes",
          "signature": "((TDV Bool, TDV Bool), SBN CPT)",
          "source": "src/Bayes-Examples.html#exampleSoftEvidence",
          "type": "function"
        },
        "index": {
          "description": "Example of soft evidence use",
          "hierarchy": "Bayes Examples",
          "module": "Bayes.Examples",
          "name": "exampleSoftEvidence",
          "normalized": "((TDV Bool,TDV Bool),SBN CPT)",
          "package": "hbayes",
          "partial": "Soft Evidence",
          "signature": "((TDV Bool,TDV Bool),SBN CPT)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-Examples.html#v:exampleSoftEvidence"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eStandard example but with a wrong factor that is changed\n in the tests using factor replacement functions\n\u003c/p\u003e",
          "module": "Bayes.Examples",
          "name": "exampleWithFactorChange",
          "package": "hbayes",
          "signature": "([TDV Bool], SBN CPT)",
          "source": "src/Bayes-Examples.html#exampleWithFactorChange",
          "type": "function"
        },
        "index": {
          "description": "Standard example but with wrong factor that is changed in the tests using factor replacement functions",
          "hierarchy": "Bayes Examples",
          "module": "Bayes.Examples",
          "name": "exampleWithFactorChange",
          "normalized": "([TDV Bool],SBN CPT)",
          "package": "hbayes",
          "partial": "With Factor Change",
          "signature": "([TDV Bool],SBN CPT)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-Examples.html#v:exampleWithFactorChange"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Bayes.Examples",
          "name": "testJunction",
          "package": "hbayes",
          "signature": "DirectedSG () Vertex",
          "source": "src/Bayes-Examples.html#testJunction",
          "type": "function"
        },
        "index": {
          "hierarchy": "Bayes Examples",
          "module": "Bayes.Examples",
          "name": "testJunction",
          "normalized": "DirectedSG()Vertex",
          "package": "hbayes",
          "partial": "Junction",
          "signature": "DirectedSG()Vertex",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-Examples.html#v:testJunction"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eConditional probability table\n\u003c/p\u003e\u003cp\u003eConditional Probability Tables and Probability tables\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Bayes.Factor.CPT",
          "name": "CPT",
          "package": "hbayes",
          "source": "src/Bayes-Factor-CPT.html",
          "type": "module"
        },
        "index": {
          "description": "Conditional probability table Conditional Probability Tables and Probability tables",
          "hierarchy": "Bayes Factor CPT",
          "module": "Bayes.Factor.CPT",
          "name": "CPT",
          "package": "hbayes",
          "partial": "CPT",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-Factor-CPT.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Bayes.Factor.CPT",
          "name": "CPT",
          "package": "hbayes",
          "source": "src/Bayes-Factor-PrivateCPT.html#CPT",
          "type": "type"
        },
        "index": {
          "hierarchy": "Bayes Factor CPT",
          "module": "Bayes.Factor.CPT",
          "name": "CPT",
          "package": "hbayes",
          "partial": "CPT",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-Factor-CPT.html#t:CPT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSoft evidence factor can be used to initialize a factor\ninstance Distribution CPT where \n  createFactor dvs f = factorWithVariables dvs (factorToList f)\n\u003c/p\u003e",
          "module": "Bayes.Factor.CPT",
          "name": "changeVariableOrder",
          "package": "hbayes",
          "signature": "DVSet s-\u003e DVSet s'-\u003e [Double]-\u003e [Double]",
          "type": "function"
        },
        "index": {
          "description": "Soft evidence factor can be used to initialize factor instance Distribution CPT where createFactor dvs factorWithVariables dvs factorToList",
          "hierarchy": "Bayes Factor CPT",
          "module": "Bayes.Factor.CPT",
          "name": "changeVariableOrder",
          "normalized": "DVSet a-\u003eDVSet b-\u003e[Double]-\u003e[Double]",
          "package": "hbayes",
          "partial": "Variable Order",
          "signature": "DVSet s-\u003eDVSet s'-\u003e[Double]-\u003e[Double]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-Factor-CPT.html#v:changeVariableOrder"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Bayes.Factor.CPT",
          "name": "cptDivide",
          "package": "hbayes",
          "signature": "CPT -\u003e CPT -\u003e CPT",
          "source": "src/Bayes-Factor-CPT.html#cptDivide",
          "type": "function"
        },
        "index": {
          "hierarchy": "Bayes Factor CPT",
          "module": "Bayes.Factor.CPT",
          "name": "cptDivide",
          "normalized": "CPT-\u003eCPT-\u003eCPT",
          "package": "hbayes",
          "partial": "Divide",
          "signature": "CPT-\u003eCPT-\u003eCPT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-Factor-CPT.html#v:cptDivide"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Bayes.Factor.CPT",
          "name": "cptSum",
          "package": "hbayes",
          "signature": "[CPT] -\u003e CPT",
          "source": "src/Bayes-Factor-CPT.html#cptSum",
          "type": "function"
        },
        "index": {
          "hierarchy": "Bayes Factor CPT",
          "module": "Bayes.Factor.CPT",
          "name": "cptSum",
          "normalized": "[CPT]-\u003eCPT",
          "package": "hbayes",
          "partial": "Sum",
          "signature": "[CPT]-\u003eCPT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-Factor-CPT.html#v:cptSum"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Bayes.Factor.CPT",
          "name": "debugCPT",
          "package": "hbayes",
          "signature": "PrivateCPT t a -\u003e IO ()",
          "source": "src/Bayes-Factor-PrivateCPT.html#debugCPT",
          "type": "function"
        },
        "index": {
          "hierarchy": "Bayes Factor CPT",
          "module": "Bayes.Factor.CPT",
          "name": "debugCPT",
          "normalized": "PrivateCPT a b-\u003eIO()",
          "package": "hbayes",
          "partial": "CPT",
          "signature": "PrivateCPT t a-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-Factor-CPT.html#v:debugCPT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Bayes.Factor.CPT",
          "name": "testAssocProduct_prop",
          "package": "hbayes",
          "signature": "CPT -\u003e CPT -\u003e CPT -\u003e Bool",
          "source": "src/Bayes-Factor-CPT.html#testAssocProduct_prop",
          "type": "function"
        },
        "index": {
          "hierarchy": "Bayes Factor CPT",
          "module": "Bayes.Factor.CPT",
          "name": "testAssocProduct_prop",
          "normalized": "CPT-\u003eCPT-\u003eCPT-\u003eBool",
          "package": "hbayes",
          "partial": "Assoc Product",
          "signature": "CPT-\u003eCPT-\u003eCPT-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-Factor-CPT.html#v:testAssocProduct_prop"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Bayes.Factor.CPT",
          "name": "testProductProject_prop",
          "package": "hbayes",
          "signature": "CPT -\u003e CPT -\u003e Property",
          "source": "src/Bayes-Factor-CPT.html#testProductProject_prop",
          "type": "function"
        },
        "index": {
          "hierarchy": "Bayes Factor CPT",
          "module": "Bayes.Factor.CPT",
          "name": "testProductProject_prop",
          "normalized": "CPT-\u003eCPT-\u003eProperty",
          "package": "hbayes",
          "partial": "Product Project",
          "signature": "CPT-\u003eCPT-\u003eProperty",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-Factor-CPT.html#v:testProductProject_prop"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Bayes.Factor.CPT",
          "name": "testProjectCommut_prop",
          "package": "hbayes",
          "signature": "CPT -\u003e Property",
          "source": "src/Bayes-Factor-CPT.html#testProjectCommut_prop",
          "type": "function"
        },
        "index": {
          "hierarchy": "Bayes Factor CPT",
          "module": "Bayes.Factor.CPT",
          "name": "testProjectCommut_prop",
          "normalized": "CPT-\u003eProperty",
          "package": "hbayes",
          "partial": "Project Commut",
          "signature": "CPT-\u003eProperty",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-Factor-CPT.html#v:testProjectCommut_prop"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Bayes.Factor.CPT",
          "name": "testProjectionToScalar_prop",
          "package": "hbayes",
          "signature": "CPT -\u003e Bool",
          "source": "src/Bayes-Factor-CPT.html#testProjectionToScalar_prop",
          "type": "function"
        },
        "index": {
          "hierarchy": "Bayes Factor CPT",
          "module": "Bayes.Factor.CPT",
          "name": "testProjectionToScalar_prop",
          "normalized": "CPT-\u003eBool",
          "package": "hbayes",
          "partial": "Projection To Scalar",
          "signature": "CPT-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-Factor-CPT.html#v:testProjectionToScalar_prop"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Bayes.Factor.CPT",
          "name": "testScalarProduct_prop",
          "package": "hbayes",
          "signature": "Double -\u003e CPT -\u003e Bool",
          "source": "src/Bayes-Factor-CPT.html#testScalarProduct_prop",
          "type": "function"
        },
        "index": {
          "hierarchy": "Bayes Factor CPT",
          "module": "Bayes.Factor.CPT",
          "name": "testScalarProduct_prop",
          "normalized": "Double-\u003eCPT-\u003eBool",
          "package": "hbayes",
          "partial": "Scalar Product",
          "signature": "Double-\u003eCPT-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-Factor-CPT.html#v:testScalarProduct_prop"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTest product followed by a projection when the factors have no\n common variables\n\u003c/p\u003e",
          "module": "Bayes.Factor.CPT",
          "name": "testScale_prop",
          "package": "hbayes",
          "signature": "Double -\u003e CPT -\u003e Bool",
          "source": "src/Bayes-Factor-CPT.html#testScale_prop",
          "type": "function"
        },
        "index": {
          "description": "Test product followed by projection when the factors have no common variables",
          "hierarchy": "Bayes Factor CPT",
          "module": "Bayes.Factor.CPT",
          "name": "testScale_prop",
          "normalized": "Double-\u003eCPT-\u003eBool",
          "package": "hbayes",
          "partial": "Scale",
          "signature": "Double-\u003eCPT-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-Factor-CPT.html#v:testScale_prop"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eImplementation of Max-product factors for MAP queries\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Bayes.Factor.MaxCPT",
          "name": "MaxCPT",
          "package": "hbayes",
          "source": "src/Bayes-Factor-MaxCPT.html",
          "type": "module"
        },
        "index": {
          "description": "Implementation of Max-product factors for MAP queries",
          "hierarchy": "Bayes Factor MaxCPT",
          "module": "Bayes.Factor.MaxCPT",
          "name": "MaxCPT",
          "package": "hbayes",
          "partial": "Max CPT",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-Factor-MaxCPT.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Bayes.Factor.MaxCPT",
          "name": "MAXCPT",
          "package": "hbayes",
          "source": "src/Bayes-Factor-PrivateCPT.html#MAXCPT",
          "type": "type"
        },
        "index": {
          "hierarchy": "Bayes Factor MaxCPT",
          "module": "Bayes.Factor.MaxCPT",
          "name": "MAXCPT",
          "package": "hbayes",
          "partial": "MAXCPT",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-Factor-MaxCPT.html#t:MAXCPT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Bayes.Factor.MaxCPT",
          "name": "mpeInstantiations",
          "package": "hbayes",
          "signature": "MAXCPT -\u003e [DVISet]",
          "source": "src/Bayes-Factor-MaxCPT.html#mpeInstantiations",
          "type": "function"
        },
        "index": {
          "hierarchy": "Bayes Factor MaxCPT",
          "module": "Bayes.Factor.MaxCPT",
          "name": "mpeInstantiations",
          "normalized": "MAXCPT-\u003e[DVISet]",
          "package": "hbayes",
          "partial": "Instantiations",
          "signature": "MAXCPT-\u003e[DVISet]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-Factor-MaxCPT.html#v:mpeInstantiations"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eFactors\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Bayes.Factor",
          "name": "Factor",
          "package": "hbayes",
          "source": "src/Bayes-Factor.html",
          "type": "module"
        },
        "index": {
          "description": "Factors",
          "hierarchy": "Bayes Factor",
          "module": "Bayes.Factor",
          "name": "Factor",
          "package": "hbayes",
          "partial": "Factor",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-Factor.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA discrete variable has a number of levels which is required to size the factors\n\u003c/p\u003e",
          "module": "Bayes.Factor",
          "name": "BayesianDiscreteVariable",
          "package": "hbayes",
          "source": "src/Bayes-PrivateTypes.html#BayesianDiscreteVariable",
          "type": "class"
        },
        "index": {
          "description": "discrete variable has number of levels which is required to size the factors",
          "hierarchy": "Bayes Factor",
          "module": "Bayes.Factor",
          "name": "BayesianDiscreteVariable",
          "package": "hbayes",
          "partial": "Bayesian Discrete Variable",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-Factor.html#t:BayesianDiscreteVariable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA Bayesian Variable is a variable part of Bayesian network and so which knows\n its position : the vertex.\n\u003c/p\u003e",
          "module": "Bayes.Factor",
          "name": "BayesianVariable",
          "package": "hbayes",
          "source": "src/Bayes-PrivateTypes.html#BayesianVariable",
          "type": "class"
        },
        "index": {
          "description": "Bayesian Variable is variable part of Bayesian network and so which knows its position the vertex",
          "hierarchy": "Bayes Factor",
          "module": "Bayes.Factor",
          "name": "BayesianVariable",
          "package": "hbayes",
          "partial": "Bayesian Variable",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-Factor.html#t:BayesianVariable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA discrete variable\n\u003c/p\u003e",
          "module": "Bayes.Factor",
          "name": "DV",
          "package": "hbayes",
          "source": "src/Bayes-PrivateTypes.html#DV",
          "type": "data"
        },
        "index": {
          "description": "discrete variable",
          "hierarchy": "Bayes Factor",
          "module": "Bayes.Factor",
          "name": "DV",
          "package": "hbayes",
          "partial": "DV",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-Factor.html#t:DV"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDiscrete Variable instantiation. A variable and its value\n\u003c/p\u003e",
          "module": "Bayes.Factor",
          "name": "DVI",
          "package": "hbayes",
          "source": "src/Bayes-PrivateTypes.html#DVI",
          "type": "data"
        },
        "index": {
          "description": "Discrete Variable instantiation variable and its value",
          "hierarchy": "Bayes Factor",
          "module": "Bayes.Factor",
          "name": "DVI",
          "package": "hbayes",
          "partial": "DVI",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-Factor.html#t:DVI"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Bayes.Factor",
          "name": "DVISet",
          "package": "hbayes",
          "source": "src/Bayes-PrivateTypes.html#DVISet",
          "type": "type"
        },
        "index": {
          "hierarchy": "Bayes Factor",
          "module": "Bayes.Factor",
          "name": "DVISet",
          "package": "hbayes",
          "partial": "DVISet",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-Factor.html#t:DVISet"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA set of discrete variables\n The tag is used to check that an index is used with the right set of DV\n\u003c/p\u003e",
          "module": "Bayes.Factor",
          "name": "DVSet",
          "package": "hbayes",
          "source": "src/Bayes-PrivateTypes.html#DVSet",
          "type": "newtype"
        },
        "index": {
          "description": "set of discrete variables The tag is used to check that an index is used with the right set of DV",
          "hierarchy": "Bayes Factor",
          "module": "Bayes.Factor",
          "name": "DVSet",
          "package": "hbayes",
          "partial": "DVSet",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-Factor.html#t:DVSet"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA distribution which can be used to create a factor\n\u003c/p\u003e",
          "module": "Bayes.Factor",
          "name": "Distribution",
          "package": "hbayes",
          "source": "src/Bayes-Factor.html#Distribution",
          "type": "class"
        },
        "index": {
          "description": "distribution which can be used to create factor",
          "hierarchy": "Bayes Factor",
          "module": "Bayes.Factor",
          "name": "Distribution",
          "package": "hbayes",
          "partial": "Distribution",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-Factor.html#t:Distribution"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA factor as used in graphical model\n It may or not be a probability distribution. So it has no reason to be\n normalized to 1\n\u003c/p\u003e",
          "module": "Bayes.Factor",
          "name": "Factor",
          "package": "hbayes",
          "source": "src/Bayes-Factor.html#Factor",
          "type": "class"
        },
        "index": {
          "description": "factor as used in graphical model It may or not be probability distribution So it has no reason to be normalized to",
          "hierarchy": "Bayes Factor",
          "module": "Bayes.Factor",
          "name": "Factor",
          "package": "hbayes",
          "partial": "Factor",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-Factor.html#t:Factor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eStructure containing factors which can be replaced.\n It is making sense when the factors are related to the nodes of a Bayesian\n network. \n\u003c/p\u003e",
          "module": "Bayes.Factor",
          "name": "FactorContainer",
          "package": "hbayes",
          "source": "src/Bayes-Factor.html#FactorContainer",
          "type": "class"
        },
        "index": {
          "description": "Structure containing factors which can be replaced It is making sense when the factors are related to the nodes of Bayesian network",
          "hierarchy": "Bayes Factor",
          "module": "Bayes.Factor",
          "name": "FactorContainer",
          "package": "hbayes",
          "partial": "Factor Container",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-Factor.html#t:FactorContainer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Bayes.Factor",
          "name": "InstantiationValue",
          "package": "hbayes",
          "source": "src/Bayes-PrivateTypes.html#InstantiationValue",
          "type": "class"
        },
        "index": {
          "hierarchy": "Bayes Factor",
          "module": "Bayes.Factor",
          "name": "InstantiationValue",
          "package": "hbayes",
          "partial": "Instantiation Value",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-Factor.html#t:InstantiationValue"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eClass used to display multidimensional tables\n\u003c/p\u003e",
          "module": "Bayes.Factor",
          "name": "MultiDimTable",
          "package": "hbayes",
          "source": "src/Bayes-Factor.html#MultiDimTable",
          "type": "class"
        },
        "index": {
          "description": "Class used to display multidimensional tables",
          "hierarchy": "Bayes Factor",
          "module": "Bayes.Factor",
          "name": "MultiDimTable",
          "package": "hbayes",
          "partial": "Multi Dim Table",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-Factor.html#t:MultiDimTable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA Set of variables used in a factor. s is the set and a the variable\n\u003c/p\u003e",
          "module": "Bayes.Factor",
          "name": "Set",
          "package": "hbayes",
          "source": "src/Bayes-PrivateTypes.html#Set",
          "type": "class"
        },
        "index": {
          "description": "Set of variables used in factor is the set and the variable",
          "hierarchy": "Bayes Factor",
          "module": "Bayes.Factor",
          "name": "Set",
          "package": "hbayes",
          "partial": "Set",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-Factor.html#t:Set"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA typed discrete variable\n\u003c/p\u003e",
          "module": "Bayes.Factor",
          "name": "TDV",
          "package": "hbayes",
          "source": "src/Bayes-PrivateTypes.html#TDV",
          "type": "data"
        },
        "index": {
          "description": "typed discrete variable",
          "hierarchy": "Bayes Factor",
          "module": "Bayes.Factor",
          "name": "TDV",
          "package": "hbayes",
          "partial": "TDV",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-Factor.html#t:TDV"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eVertex type used to identify a vertex in a graph\n\u003c/p\u003e",
          "module": "Bayes.Factor",
          "name": "Vertex",
          "package": "hbayes",
          "source": "src/Bayes-PrivateTypes.html#Vertex",
          "type": "newtype"
        },
        "index": {
          "description": "Vertex type used to identify vertex in graph",
          "hierarchy": "Bayes Factor",
          "module": "Bayes.Factor",
          "name": "Vertex",
          "package": "hbayes",
          "partial": "Vertex",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-Factor.html#t:Vertex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Bayes.Factor",
          "name": "DV",
          "package": "hbayes",
          "signature": "DV !Vertex !Int",
          "source": "src/Bayes-PrivateTypes.html#DV",
          "type": "function"
        },
        "index": {
          "hierarchy": "Bayes Factor",
          "module": "Bayes.Factor",
          "name": "DV",
          "package": "hbayes",
          "partial": "DV",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-Factor.html#v:DV"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Bayes.Factor",
          "name": "DVSet",
          "package": "hbayes",
          "signature": "DVSet [DV]",
          "source": "src/Bayes-PrivateTypes.html#DVSet",
          "type": "function"
        },
        "index": {
          "hierarchy": "Bayes Factor",
          "module": "Bayes.Factor",
          "name": "DVSet",
          "normalized": "DVSet[DV]",
          "package": "hbayes",
          "partial": "DVSet",
          "signature": "DVSet[DV]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-Factor.html#v:DVSet"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Bayes.Factor",
          "name": "Vertex",
          "package": "hbayes",
          "signature": "Vertex",
          "source": "src/Bayes-PrivateTypes.html#Vertex",
          "type": "function"
        },
        "index": {
          "hierarchy": "Bayes Factor",
          "module": "Bayes.Factor",
          "name": "Vertex",
          "package": "hbayes",
          "partial": "Vertex",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-Factor.html#v:Vertex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAdd an element to the set\n\u003c/p\u003e",
          "module": "Bayes.Factor",
          "name": "addElem",
          "package": "hbayes",
          "signature": "a -\u003e s a -\u003e s a",
          "source": "src/Bayes-PrivateTypes.html#addElem",
          "type": "method"
        },
        "index": {
          "description": "Add an element to the set",
          "hierarchy": "Bayes Factor",
          "module": "Bayes.Factor",
          "name": "addElem",
          "normalized": "a-\u003eb a-\u003eb a",
          "package": "hbayes",
          "partial": "Elem",
          "signature": "a-\u003es a-\u003es a",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-Factor.html#v:addElem"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Bayes.Factor",
          "name": "changeFactor",
          "package": "hbayes",
          "signature": "f -\u003e m f -\u003e m f",
          "source": "src/Bayes-Factor.html#changeFactor",
          "type": "method"
        },
        "index": {
          "hierarchy": "Bayes Factor",
          "module": "Bayes.Factor",
          "name": "changeFactor",
          "normalized": "a-\u003eb a-\u003eb a",
          "package": "hbayes",
          "partial": "Factor",
          "signature": "f-\u003em f-\u003em f",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-Factor.html#v:changeFactor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eChange factor in a functor (only factor values should have been changed)\n It assumes that the variables of a factor are enough to identify it.\n If the functor is containing several factors with same set of variables then it\n won't give a meaningful result.\n So it should be used only on functor derived from a Bayesian Network.\n\u003c/p\u003e",
          "module": "Bayes.Factor",
          "name": "changeFactorInFunctor",
          "package": "hbayes",
          "signature": "f -\u003e m f -\u003e m f",
          "source": "src/Bayes-Factor.html#changeFactorInFunctor",
          "type": "function"
        },
        "index": {
          "description": "Change factor in functor only factor values should have been changed It assumes that the variables of factor are enough to identify it If the functor is containing several factors with same set of variables then it won give meaningful result So it should be used only on functor derived from Bayesian Network",
          "hierarchy": "Bayes Factor",
          "module": "Bayes.Factor",
          "name": "changeFactorInFunctor",
          "normalized": "a-\u003eb a-\u003eb a",
          "package": "hbayes",
          "partial": "Factor In Functor",
          "signature": "f-\u003em f-\u003em f",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-Factor.html#v:changeFactorInFunctor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCheck if a given discrete variable is contained in a factor\n\u003c/p\u003e",
          "module": "Bayes.Factor",
          "name": "containsVariable",
          "package": "hbayes",
          "signature": "f -\u003e DV -\u003e Bool",
          "source": "src/Bayes-Factor.html#containsVariable",
          "type": "method"
        },
        "index": {
          "description": "Check if given discrete variable is contained in factor",
          "hierarchy": "Bayes Factor",
          "module": "Bayes.Factor",
          "name": "containsVariable",
          "normalized": "a-\u003eDV-\u003eBool",
          "package": "hbayes",
          "partial": "Variable",
          "signature": "f-\u003eDV-\u003eBool",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-Factor.html#v:containsVariable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreate a factor from variables and a distributions for those variables\n\u003c/p\u003e",
          "module": "Bayes.Factor",
          "name": "createFactor",
          "package": "hbayes",
          "signature": "[DV] -\u003e d -\u003e Maybe f",
          "source": "src/Bayes-Factor.html#createFactor",
          "type": "method"
        },
        "index": {
          "description": "Create factor from variables and distributions for those variables",
          "hierarchy": "Bayes Factor",
          "module": "Bayes.Factor",
          "name": "createFactor",
          "normalized": "[DV]-\u003ea-\u003eMaybe b",
          "package": "hbayes",
          "partial": "Factor",
          "signature": "[DV]-\u003ed-\u003eMaybe f",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-Factor.html#v:createFactor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDifference of two sets\n\u003c/p\u003e",
          "module": "Bayes.Factor",
          "name": "difference",
          "package": "hbayes",
          "signature": "s a -\u003e s a -\u003e s a",
          "source": "src/Bayes-PrivateTypes.html#difference",
          "type": "method"
        },
        "index": {
          "description": "Difference of two sets",
          "hierarchy": "Bayes Factor",
          "module": "Bayes.Factor",
          "name": "difference",
          "normalized": "a b-\u003ea b-\u003ea b",
          "package": "hbayes",
          "signature": "s a-\u003es a-\u003es a",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-Factor.html#v:difference"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Bayes.Factor",
          "name": "dimension",
          "package": "hbayes",
          "signature": "v -\u003e Int",
          "source": "src/Bayes-PrivateTypes.html#dimension",
          "type": "method"
        },
        "index": {
          "hierarchy": "Bayes Factor",
          "module": "Bayes.Factor",
          "name": "dimension",
          "normalized": "a-\u003eInt",
          "package": "hbayes",
          "signature": "v-\u003eInt",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-Factor.html#v:dimension"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Bayes.Factor",
          "name": "displayFactorBody",
          "package": "hbayes",
          "signature": "f -\u003e String",
          "source": "src/Bayes-Factor.html#displayFactorBody",
          "type": "function"
        },
        "index": {
          "hierarchy": "Bayes Factor",
          "module": "Bayes.Factor",
          "name": "displayFactorBody",
          "normalized": "a-\u003eString",
          "package": "hbayes",
          "partial": "Factor Body",
          "signature": "f-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-Factor.html#v:displayFactorBody"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Bayes.Factor",
          "name": "dv",
          "package": "hbayes",
          "signature": "v -\u003e DV",
          "source": "src/Bayes-PrivateTypes.html#dv",
          "type": "method"
        },
        "index": {
          "hierarchy": "Bayes Factor",
          "module": "Bayes.Factor",
          "name": "dv",
          "normalized": "a-\u003eDV",
          "package": "hbayes",
          "signature": "v-\u003eDV",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-Factor.html#v:dv"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Bayes.Factor",
          "name": "elementStringValue",
          "package": "hbayes",
          "signature": "f -\u003e [DVI] -\u003e String",
          "source": "src/Bayes-Factor.html#elementStringValue",
          "type": "method"
        },
        "index": {
          "hierarchy": "Bayes Factor",
          "module": "Bayes.Factor",
          "name": "elementStringValue",
          "normalized": "a-\u003e[DVI]-\u003eString",
          "package": "hbayes",
          "partial": "String Value",
          "signature": "f-\u003e[DVI]-\u003eString",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-Factor.html#v:elementStringValue"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn empty factor with no variable and no values\n\u003c/p\u003e",
          "module": "Bayes.Factor",
          "name": "emptyFactor",
          "package": "hbayes",
          "signature": "f",
          "source": "src/Bayes-Factor.html#emptyFactor",
          "type": "method"
        },
        "index": {
          "description": "An empty factor with no variable and no values",
          "hierarchy": "Bayes Factor",
          "module": "Bayes.Factor",
          "name": "emptyFactor",
          "package": "hbayes",
          "partial": "Factor",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-Factor.html#v:emptyFactor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEmpty set\n\u003c/p\u003e",
          "module": "Bayes.Factor",
          "name": "emptySet",
          "package": "hbayes",
          "signature": "s a",
          "source": "src/Bayes-PrivateTypes.html#emptySet",
          "type": "method"
        },
        "index": {
          "description": "Empty set",
          "hierarchy": "Bayes Factor",
          "module": "Bayes.Factor",
          "name": "emptySet",
          "package": "hbayes",
          "partial": "Set",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-Factor.html#v:emptySet"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCheck set equality\n\u003c/p\u003e",
          "module": "Bayes.Factor",
          "name": "equal",
          "package": "hbayes",
          "signature": "s a -\u003e s a -\u003e Bool",
          "source": "src/Bayes-PrivateTypes.html#equal",
          "type": "method"
        },
        "index": {
          "description": "Check set equality",
          "hierarchy": "Bayes Factor",
          "module": "Bayes.Factor",
          "name": "equal",
          "normalized": "a b-\u003ea b-\u003eBool",
          "package": "hbayes",
          "signature": "s a-\u003es a-\u003eBool",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-Factor.html#v:equal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreate an evidence factor from an instantiation.\n If the instantiation is empty then we get nothing\n\u003c/p\u003e",
          "module": "Bayes.Factor",
          "name": "evidenceFrom",
          "package": "hbayes",
          "signature": "[DVI] -\u003e Maybe f",
          "source": "src/Bayes-Factor.html#evidenceFrom",
          "type": "method"
        },
        "index": {
          "description": "Create an evidence factor from an instantiation If the instantiation is empty then we get nothing",
          "hierarchy": "Bayes Factor",
          "module": "Bayes.Factor",
          "name": "evidenceFrom",
          "normalized": "[DVI]-\u003eMaybe a",
          "package": "hbayes",
          "partial": "From",
          "signature": "[DVI]-\u003eMaybe f",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-Factor.html#v:evidenceFrom"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDimension of the factor (number of floating point values)\n\u003c/p\u003e",
          "module": "Bayes.Factor",
          "name": "factorDimension",
          "package": "hbayes",
          "signature": "f -\u003e Int",
          "source": "src/Bayes-Factor.html#factorDimension",
          "type": "method"
        },
        "index": {
          "description": "Dimension of the factor number of floating point values",
          "hierarchy": "Bayes Factor",
          "module": "Bayes.Factor",
          "name": "factorDimension",
          "normalized": "a-\u003eInt",
          "package": "hbayes",
          "partial": "Dimension",
          "signature": "f-\u003eInt",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-Factor.html#v:factorDimension"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDivide all the factor values\n\u003c/p\u003e",
          "module": "Bayes.Factor",
          "name": "factorDivide",
          "package": "hbayes",
          "signature": "f -\u003e Double -\u003e f",
          "source": "src/Bayes-Factor.html#factorDivide",
          "type": "method"
        },
        "index": {
          "description": "Divide all the factor values",
          "hierarchy": "Bayes Factor",
          "module": "Bayes.Factor",
          "name": "factorDivide",
          "normalized": "a-\u003eDouble-\u003ea",
          "package": "hbayes",
          "partial": "Divide",
          "signature": "f-\u003eDouble-\u003ef",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-Factor.html#v:factorDivide"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert a variable instantation to a factor\n Useful to create evidence factors\n\u003c/p\u003e",
          "module": "Bayes.Factor",
          "name": "factorFromInstantiation",
          "package": "hbayes",
          "signature": "DVI -\u003e f",
          "source": "src/Bayes-Factor.html#factorFromInstantiation",
          "type": "function"
        },
        "index": {
          "description": "Convert variable instantation to factor Useful to create evidence factors",
          "hierarchy": "Bayes Factor",
          "module": "Bayes.Factor",
          "name": "factorFromInstantiation",
          "normalized": "DVI-\u003ea",
          "package": "hbayes",
          "partial": "From Instantiation",
          "signature": "DVI-\u003ef",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-Factor.html#v:factorFromInstantiation"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreate a scalar factor with no variables\n\u003c/p\u003e",
          "module": "Bayes.Factor",
          "name": "factorFromScalar",
          "package": "hbayes",
          "signature": "Double -\u003e f",
          "source": "src/Bayes-Factor.html#factorFromScalar",
          "type": "method"
        },
        "index": {
          "description": "Create scalar factor with no variables",
          "hierarchy": "Bayes Factor",
          "module": "Bayes.Factor",
          "name": "factorFromScalar",
          "normalized": "Double-\u003ea",
          "package": "hbayes",
          "partial": "From Scalar",
          "signature": "Double-\u003ef",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-Factor.html#v:factorFromScalar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn A in P(A | C D ...). It is making sense only if the factor is a conditional propbability\n table. It must always be in the vertex corresponding to A in the bayesian graph\n\u003c/p\u003e",
          "module": "Bayes.Factor",
          "name": "factorMainVariable",
          "package": "hbayes",
          "signature": "f -\u003e DV",
          "source": "src/Bayes-Factor.html#factorMainVariable",
          "type": "method"
        },
        "index": {
          "description": "Return in It is making sense only if the factor is conditional propbability table It must always be in the vertex corresponding to in the bayesian graph",
          "hierarchy": "Bayes Factor",
          "module": "Bayes.Factor",
          "name": "factorMainVariable",
          "normalized": "a-\u003eDV",
          "package": "hbayes",
          "partial": "Main Variable",
          "signature": "f-\u003eDV",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-Factor.html#v:factorMainVariable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eNorm of the factor = sum of its values\n\u003c/p\u003e",
          "module": "Bayes.Factor",
          "name": "factorNorm",
          "package": "hbayes",
          "signature": "f -\u003e Double",
          "source": "src/Bayes-Factor.html#factorNorm",
          "type": "method"
        },
        "index": {
          "description": "Norm of the factor sum of its values",
          "hierarchy": "Bayes Factor",
          "module": "Bayes.Factor",
          "name": "factorNorm",
          "normalized": "a-\u003eDouble",
          "package": "hbayes",
          "partial": "Norm",
          "signature": "f-\u003eDouble",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-Factor.html#v:factorNorm"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMultiply factors. \n\u003c/p\u003e",
          "module": "Bayes.Factor",
          "name": "factorProduct",
          "package": "hbayes",
          "signature": "[f] -\u003e f",
          "source": "src/Bayes-Factor.html#factorProduct",
          "type": "method"
        },
        "index": {
          "description": "Multiply factors",
          "hierarchy": "Bayes Factor",
          "module": "Bayes.Factor",
          "name": "factorProduct",
          "normalized": "[a]-\u003ea",
          "package": "hbayes",
          "partial": "Product",
          "signature": "[f]-\u003ef",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-Factor.html#v:factorProduct"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eProject out a factor. The variable in the DVSet are summed out\n\u003c/p\u003e",
          "module": "Bayes.Factor",
          "name": "factorProjectOut",
          "package": "hbayes",
          "signature": "[DV] -\u003e f -\u003e f",
          "source": "src/Bayes-Factor.html#factorProjectOut",
          "type": "method"
        },
        "index": {
          "description": "Project out factor The variable in the DVSet are summed out",
          "hierarchy": "Bayes Factor",
          "module": "Bayes.Factor",
          "name": "factorProjectOut",
          "normalized": "[DV]-\u003ea-\u003ea",
          "package": "hbayes",
          "partial": "Project Out",
          "signature": "[DV]-\u003ef-\u003ef",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-Factor.html#v:factorProjectOut"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eProject to. The variable are kept and other variables are removed\n\u003c/p\u003e",
          "module": "Bayes.Factor",
          "name": "factorProjectTo",
          "package": "hbayes",
          "signature": "[DV] -\u003e f -\u003e f",
          "source": "src/Bayes-Factor.html#factorProjectTo",
          "type": "method"
        },
        "index": {
          "description": "Project to The variable are kept and other variables are removed",
          "hierarchy": "Bayes Factor",
          "module": "Bayes.Factor",
          "name": "factorProjectTo",
          "normalized": "[DV]-\u003ea-\u003ea",
          "package": "hbayes",
          "partial": "Project To",
          "signature": "[DV]-\u003ef-\u003ef",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-Factor.html#v:factorProjectTo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eScale the factor values by a given scaling factor\n\u003c/p\u003e",
          "module": "Bayes.Factor",
          "name": "factorScale",
          "package": "hbayes",
          "signature": "Double -\u003e f -\u003e f",
          "source": "src/Bayes-Factor.html#factorScale",
          "type": "method"
        },
        "index": {
          "description": "Scale the factor values by given scaling factor",
          "hierarchy": "Bayes Factor",
          "module": "Bayes.Factor",
          "name": "factorScale",
          "normalized": "Double-\u003ea-\u003ea",
          "package": "hbayes",
          "partial": "Scale",
          "signature": "Double-\u003ef-\u003ef",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-Factor.html#v:factorScale"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eString representation of a factor value \n\u003c/p\u003e",
          "module": "Bayes.Factor",
          "name": "factorStringValue",
          "package": "hbayes",
          "signature": "f -\u003e [DVI] -\u003e String",
          "source": "src/Bayes-Factor.html#factorStringValue",
          "type": "method"
        },
        "index": {
          "description": "String representation of factor value",
          "hierarchy": "Bayes Factor",
          "module": "Bayes.Factor",
          "name": "factorStringValue",
          "normalized": "a-\u003e[DVI]-\u003eString",
          "package": "hbayes",
          "partial": "String Value",
          "signature": "f-\u003e[DVI]-\u003eString",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-Factor.html#v:factorStringValue"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Bayes.Factor",
          "name": "factorToList",
          "package": "hbayes",
          "signature": "f -\u003e [Double]",
          "source": "src/Bayes-Factor.html#factorToList",
          "type": "method"
        },
        "index": {
          "hierarchy": "Bayes Factor",
          "module": "Bayes.Factor",
          "name": "factorToList",
          "normalized": "a-\u003e[Double]",
          "package": "hbayes",
          "partial": "To List",
          "signature": "f-\u003e[Double]",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-Factor.html#v:factorToList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eValue of factor for a given set of variable instantitation.\n The variable instantion is like a multi-dimensional index.\n\u003c/p\u003e",
          "module": "Bayes.Factor",
          "name": "factorValue",
          "package": "hbayes",
          "signature": "f -\u003e [DVI] -\u003e Double",
          "source": "src/Bayes-Factor.html#factorValue",
          "type": "method"
        },
        "index": {
          "description": "Value of factor for given set of variable instantitation The variable instantion is like multi-dimensional index",
          "hierarchy": "Bayes Factor",
          "module": "Bayes.Factor",
          "name": "factorValue",
          "normalized": "a-\u003e[DVI]-\u003eDouble",
          "package": "hbayes",
          "partial": "Value",
          "signature": "f-\u003e[DVI]-\u003eDouble",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-Factor.html#v:factorValue"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGive the set of discrete variables used by the factor\n\u003c/p\u003e",
          "module": "Bayes.Factor",
          "name": "factorVariables",
          "package": "hbayes",
          "signature": "f -\u003e [DV]",
          "source": "src/Bayes-Factor.html#factorVariables",
          "type": "method"
        },
        "index": {
          "description": "Give the set of discrete variables used by the factor",
          "hierarchy": "Bayes Factor",
          "module": "Bayes.Factor",
          "name": "factorVariables",
          "normalized": "a-\u003e[DV]",
          "package": "hbayes",
          "partial": "Variables",
          "signature": "f-\u003e[DV]",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-Factor.html#v:factorVariables"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreate a new factors with given set of variables and a list of value\n for initialization. The creation may fail if the number of values is not\n coherent with the variables and their levels.\n For boolean variables ABC, the value must be given in order\n FFF, FFT, FTF, FTT ...\n\u003c/p\u003e",
          "module": "Bayes.Factor",
          "name": "factorWithVariables",
          "package": "hbayes",
          "signature": "[DV] -\u003e [Double] -\u003e Maybe f",
          "source": "src/Bayes-Factor.html#factorWithVariables",
          "type": "method"
        },
        "index": {
          "description": "Create new factors with given set of variables and list of value for initialization The creation may fail if the number of values is not coherent with the variables and their levels For boolean variables ABC the value must be given in order FFF FFT FTF FTT",
          "hierarchy": "Bayes Factor",
          "module": "Bayes.Factor",
          "name": "factorWithVariables",
          "normalized": "[DV]-\u003e[Double]-\u003eMaybe a",
          "package": "hbayes",
          "partial": "With Variables",
          "signature": "[DV]-\u003e[Double]-\u003eMaybe f",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-Factor.html#v:factorWithVariables"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGenerate all instantiations of variables\n The DVInt can be in any order so the tag s is not used\n\u003c/p\u003e",
          "module": "Bayes.Factor",
          "name": "forAllInstantiations",
          "package": "hbayes",
          "signature": "DVSet s -\u003e [[DVI]]",
          "source": "src/Bayes-PrivateTypes.html#forAllInstantiations",
          "type": "function"
        },
        "index": {
          "description": "Generate all instantiations of variables The DVInt can be in any order so the tag is not used",
          "hierarchy": "Bayes Factor",
          "module": "Bayes.Factor",
          "name": "forAllInstantiations",
          "normalized": "DVSet a-\u003e[[DVI]]",
          "package": "hbayes",
          "partial": "All Instantiations",
          "signature": "DVSet s-\u003e[[DVI]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-Factor.html#v:forAllInstantiations"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Bayes.Factor",
          "name": "instantiationValue",
          "package": "hbayes",
          "signature": "i -\u003e v",
          "source": "src/Bayes-PrivateTypes.html#instantiationValue",
          "type": "method"
        },
        "index": {
          "hierarchy": "Bayes Factor",
          "module": "Bayes.Factor",
          "name": "instantiationValue",
          "normalized": "a-\u003eb",
          "package": "hbayes",
          "partial": "Value",
          "signature": "i-\u003ev",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-Factor.html#v:instantiationValue"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDiscrete variable from the instantiation\n\u003c/p\u003e",
          "module": "Bayes.Factor",
          "name": "instantiationVariable",
          "package": "hbayes",
          "signature": "DVI -\u003e DV",
          "source": "src/Bayes-PrivateTypes.html#instantiationVariable",
          "type": "function"
        },
        "index": {
          "description": "Discrete variable from the instantiation",
          "hierarchy": "Bayes Factor",
          "module": "Bayes.Factor",
          "name": "instantiationVariable",
          "normalized": "DVI-\u003eDV",
          "package": "hbayes",
          "partial": "Variable",
          "signature": "DVI-\u003eDV",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-Factor.html#v:instantiationVariable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIntersection of two sets\n\u003c/p\u003e",
          "module": "Bayes.Factor",
          "name": "intersection",
          "package": "hbayes",
          "signature": "s a -\u003e s a -\u003e s a",
          "source": "src/Bayes-PrivateTypes.html#intersection",
          "type": "method"
        },
        "index": {
          "description": "Intersection of two sets",
          "hierarchy": "Bayes Factor",
          "module": "Bayes.Factor",
          "name": "intersection",
          "normalized": "a b-\u003ea b-\u003ea b",
          "package": "hbayes",
          "signature": "s a-\u003es a-\u003es a",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-Factor.html#v:intersection"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCheck if an element is member of the set\n\u003c/p\u003e",
          "module": "Bayes.Factor",
          "name": "isElem",
          "package": "hbayes",
          "signature": "a -\u003e s a -\u003e Bool",
          "source": "src/Bayes-PrivateTypes.html#isElem",
          "type": "method"
        },
        "index": {
          "description": "Check if an element is member of the set",
          "hierarchy": "Bayes Factor",
          "module": "Bayes.Factor",
          "name": "isElem",
          "normalized": "a-\u003eb a-\u003eBool",
          "package": "hbayes",
          "partial": "Elem",
          "signature": "a-\u003es a-\u003eBool",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-Factor.html#v:isElem"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCheck if the set is empty\n\u003c/p\u003e",
          "module": "Bayes.Factor",
          "name": "isEmpty",
          "package": "hbayes",
          "signature": "s a -\u003e Bool",
          "source": "src/Bayes-PrivateTypes.html#isEmpty",
          "type": "method"
        },
        "index": {
          "description": "Check if the set is empty",
          "hierarchy": "Bayes Factor",
          "module": "Bayes.Factor",
          "name": "isEmpty",
          "normalized": "a b-\u003eBool",
          "package": "hbayes",
          "partial": "Empty",
          "signature": "s a-\u003eBool",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-Factor.html#v:isEmpty"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWhen all variables of a factor have been summed out, we have a scalar\n\u003c/p\u003e",
          "module": "Bayes.Factor",
          "name": "isScalarFactor",
          "package": "hbayes",
          "signature": "f -\u003e Bool",
          "source": "src/Bayes-Factor.html#isScalarFactor",
          "type": "method"
        },
        "index": {
          "description": "When all variables of factor have been summed out we have scalar",
          "hierarchy": "Bayes Factor",
          "module": "Bayes.Factor",
          "name": "isScalarFactor",
          "normalized": "a-\u003eBool",
          "package": "hbayes",
          "partial": "Scalar Factor",
          "signature": "f-\u003eBool",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-Factor.html#v:isScalarFactor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTest if two factors are coding for the same probability dependence.\n It does not test if the factors are equal (same probabilities) but just\n if they involve the same variables so are linked to the same\n node in the Bayesian network\n\u003c/p\u003e",
          "module": "Bayes.Factor",
          "name": "isUsingSameVariablesAs",
          "package": "hbayes",
          "signature": "f -\u003e f -\u003e Bool",
          "source": "src/Bayes-Factor.html#isUsingSameVariablesAs",
          "type": "method"
        },
        "index": {
          "description": "Test if two factors are coding for the same probability dependence It does not test if the factors are equal same probabilities but just if they involve the same variables so are linked to the same node in the Bayesian network",
          "hierarchy": "Bayes Factor",
          "module": "Bayes.Factor",
          "name": "isUsingSameVariablesAs",
          "normalized": "a-\u003ea-\u003eBool",
          "package": "hbayes",
          "partial": "Using Same Variables As",
          "signature": "f-\u003ef-\u003eBool",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-Factor.html#v:isUsingSameVariablesAs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTest equality of two factors taking into account the fact\n that the variables may be in a different order.\n In case there is a distinction between conditionned variable and\n conditionning variables (imposed from the exterior) then this\n comparison may not make sense. It is a comparison of\n function of several variables which no special interpretation of the\n meaning of the variables according to their position.\n\u003c/p\u003e",
          "module": "Bayes.Factor",
          "name": "isomorphicFactor",
          "package": "hbayes",
          "signature": "f -\u003e f -\u003e Bool",
          "source": "src/Bayes-Factor.html#isomorphicFactor",
          "type": "function"
        },
        "index": {
          "description": "Test equality of two factors taking into account the fact that the variables may be in different order In case there is distinction between conditionned variable and conditionning variables imposed from the exterior then this comparison may not make sense It is comparison of function of several variables which no special interpretation of the meaning of the variables according to their position",
          "hierarchy": "Bayes Factor",
          "module": "Bayes.Factor",
          "name": "isomorphicFactor",
          "normalized": "a-\u003ea-\u003eBool",
          "package": "hbayes",
          "partial": "Factor",
          "signature": "f-\u003ef-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-Factor.html#v:isomorphicFactor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eNumber of elements in the set\n\u003c/p\u003e",
          "module": "Bayes.Factor",
          "name": "nbElements",
          "package": "hbayes",
          "signature": "s a -\u003e Int",
          "source": "src/Bayes-PrivateTypes.html#nbElements",
          "type": "method"
        },
        "index": {
          "description": "Number of elements in the set",
          "hierarchy": "Bayes Factor",
          "module": "Bayes.Factor",
          "name": "nbElements",
          "normalized": "a b-\u003eInt",
          "package": "hbayes",
          "partial": "Elements",
          "signature": "s a-\u003eInt",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-Factor.html#v:nbElements"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eNorm the factor\n\u003c/p\u003e",
          "module": "Bayes.Factor",
          "name": "normedFactor",
          "package": "hbayes",
          "signature": "f -\u003e f",
          "source": "src/Bayes-Factor.html#normedFactor",
          "type": "function"
        },
        "index": {
          "description": "Norm the factor",
          "hierarchy": "Bayes Factor",
          "module": "Bayes.Factor",
          "name": "normedFactor",
          "normalized": "a-\u003ea",
          "package": "hbayes",
          "partial": "Factor",
          "signature": "f-\u003ef",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-Factor.html#v:normedFactor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreate a discrete variable instantiation for a given discrete variable\n\u003c/p\u003e",
          "module": "Bayes.Factor",
          "name": "setDVValue",
          "package": "hbayes",
          "signature": "DV -\u003e Int -\u003e DVI",
          "source": "src/Bayes-PrivateTypes.html#setDVValue",
          "type": "function"
        },
        "index": {
          "description": "Create discrete variable instantiation for given discrete variable",
          "hierarchy": "Bayes Factor",
          "module": "Bayes.Factor",
          "name": "setDVValue",
          "normalized": "DV-\u003eInt-\u003eDVI",
          "package": "hbayes",
          "partial": "DVValue",
          "signature": "DV-\u003eInt-\u003eDVI",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-Factor.html#v:setDVValue"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCheck if a set is subset of another one\n\u003c/p\u003e",
          "module": "Bayes.Factor",
          "name": "subset",
          "package": "hbayes",
          "signature": "s a -\u003e s a -\u003e Bool",
          "source": "src/Bayes-PrivateTypes.html#subset",
          "type": "method"
        },
        "index": {
          "description": "Check if set is subset of another one",
          "hierarchy": "Bayes Factor",
          "module": "Bayes.Factor",
          "name": "subset",
          "normalized": "a b-\u003ea b-\u003eBool",
          "package": "hbayes",
          "signature": "s a-\u003es a-\u003eBool",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-Factor.html#v:subset"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Bayes.Factor",
          "name": "tableVariables",
          "package": "hbayes",
          "signature": "f -\u003e [DV]",
          "source": "src/Bayes-Factor.html#tableVariables",
          "type": "method"
        },
        "index": {
          "hierarchy": "Bayes Factor",
          "module": "Bayes.Factor",
          "name": "tableVariables",
          "normalized": "a-\u003e[DV]",
          "package": "hbayes",
          "partial": "Variables",
          "signature": "f-\u003e[DV]",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-Factor.html#v:tableVariables"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTyped instantiation \n\u003c/p\u003e",
          "module": "Bayes.Factor",
          "name": "tdvi",
          "package": "hbayes",
          "signature": "DVI -\u003e (TDV s, s)",
          "source": "src/Bayes-PrivateTypes.html#tdvi",
          "type": "function"
        },
        "index": {
          "description": "Typed instantiation",
          "hierarchy": "Bayes Factor",
          "module": "Bayes.Factor",
          "name": "tdvi",
          "normalized": "DVI-\u003e(TDV a,a)",
          "package": "hbayes",
          "signature": "DVI-\u003e(TDV s,s)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-Factor.html#v:tdvi"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Bayes.Factor",
          "name": "toDouble",
          "package": "hbayes",
          "signature": "i -\u003e Double",
          "source": "src/Bayes-PrivateTypes.html#toDouble",
          "type": "method"
        },
        "index": {
          "hierarchy": "Bayes Factor",
          "module": "Bayes.Factor",
          "name": "toDouble",
          "normalized": "a-\u003eDouble",
          "package": "hbayes",
          "partial": "Double",
          "signature": "i-\u003eDouble",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-Factor.html#v:toDouble"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUnion of two sets\n\u003c/p\u003e",
          "module": "Bayes.Factor",
          "name": "union",
          "package": "hbayes",
          "signature": "s a -\u003e s a -\u003e s a",
          "source": "src/Bayes-PrivateTypes.html#union",
          "type": "method"
        },
        "index": {
          "description": "Union of two sets",
          "hierarchy": "Bayes Factor",
          "module": "Bayes.Factor",
          "name": "union",
          "normalized": "a b-\u003ea b-\u003ea b",
          "package": "hbayes",
          "signature": "s a-\u003es a-\u003es a",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-Factor.html#v:union"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePosition of a discrete variable in te factor (p(AB) is differennt from p(BA) since values\n are not organized in same order in memory)\n\u003c/p\u003e",
          "module": "Bayes.Factor",
          "name": "variablePosition",
          "package": "hbayes",
          "signature": "f -\u003e DV -\u003e Maybe Int",
          "source": "src/Bayes-Factor.html#variablePosition",
          "type": "method"
        },
        "index": {
          "description": "Position of discrete variable in te factor AB is differennt from BA since values are not organized in same order in memory",
          "hierarchy": "Bayes Factor",
          "module": "Bayes.Factor",
          "name": "variablePosition",
          "normalized": "a-\u003eDV-\u003eMaybe Int",
          "package": "hbayes",
          "partial": "Position",
          "signature": "f-\u003eDV-\u003eMaybe Int",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-Factor.html#v:variablePosition"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Bayes.Factor",
          "name": "variableVertex",
          "package": "hbayes",
          "signature": "l -\u003e Vertex",
          "source": "src/Bayes-Factor.html#variableVertex",
          "type": "function"
        },
        "index": {
          "hierarchy": "Bayes Factor",
          "module": "Bayes.Factor",
          "name": "variableVertex",
          "normalized": "a-\u003eVertex",
          "package": "hbayes",
          "partial": "Vertex",
          "signature": "l-\u003eVertex",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-Factor.html#v:variableVertex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Bayes.Factor",
          "name": "vertex",
          "package": "hbayes",
          "signature": "v -\u003e Vertex",
          "source": "src/Bayes-PrivateTypes.html#vertex",
          "type": "method"
        },
        "index": {
          "hierarchy": "Bayes Factor",
          "module": "Bayes.Factor",
          "name": "vertex",
          "normalized": "a-\u003eVertex",
          "package": "hbayes",
          "signature": "v-\u003eVertex",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-Factor.html#v:vertex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Bayes.Factor",
          "name": "vertexId",
          "package": "hbayes",
          "signature": "Int",
          "source": "src/Bayes-PrivateTypes.html#Vertex",
          "type": "function"
        },
        "index": {
          "hierarchy": "Bayes Factor",
          "module": "Bayes.Factor",
          "name": "vertexId",
          "package": "hbayes",
          "partial": "Id",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-Factor.html#v:vertexId"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eAlgorithms for factor elimination\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Bayes.FactorElimination",
          "name": "FactorElimination",
          "package": "hbayes",
          "source": "src/Bayes-FactorElimination.html",
          "type": "module"
        },
        "index": {
          "description": "Algorithms for factor elimination",
          "hierarchy": "Bayes FactorElimination",
          "module": "Bayes.FactorElimination",
          "name": "FactorElimination",
          "package": "hbayes",
          "partial": "Factor Elimination",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-FactorElimination.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCluster of discrete variables.\n Discrete variables instead of vertices are needed because the\n factor are using \u003ccode\u003e\u003ca\u003eDV\u003c/a\u003e\u003c/code\u003e and we need to find\n which factors must be contained in a given cluster.\n\u003c/p\u003e",
          "module": "Bayes.FactorElimination",
          "name": "Cluster",
          "package": "hbayes",
          "source": "src/Bayes-FactorElimination-JTree.html#Cluster",
          "type": "data"
        },
        "index": {
          "description": "Cluster of discrete variables Discrete variables instead of vertices are needed because the factor are using DV and we need to find which factors must be contained in given cluster",
          "hierarchy": "Bayes FactorElimination",
          "module": "Bayes.FactorElimination",
          "name": "Cluster",
          "package": "hbayes",
          "partial": "Cluster",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-FactorElimination.html#t:Cluster"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Bayes.FactorElimination",
          "name": "JunctionTree",
          "package": "hbayes",
          "source": "src/Bayes-FactorElimination-JTree.html#JunctionTree",
          "type": "type"
        },
        "index": {
          "hierarchy": "Bayes FactorElimination",
          "module": "Bayes.FactorElimination",
          "name": "JunctionTree",
          "package": "hbayes",
          "partial": "Junction Tree",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-FactorElimination.html#t:JunctionTree"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA cluster containing only the vertices and not yet the factors\n\u003c/p\u003e",
          "module": "Bayes.FactorElimination",
          "name": "VertexCluster",
          "package": "hbayes",
          "source": "src/Bayes-FactorElimination.html#VertexCluster",
          "type": "data"
        },
        "index": {
          "description": "cluster containing only the vertices and not yet the factors",
          "hierarchy": "Bayes FactorElimination",
          "module": "Bayes.FactorElimination",
          "name": "VertexCluster",
          "package": "hbayes",
          "partial": "Vertex Cluster",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-FactorElimination.html#t:VertexCluster"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eChange evidence in the network\n\u003c/p\u003e",
          "module": "Bayes.FactorElimination",
          "name": "changeEvidence",
          "package": "hbayes",
          "signature": "[DVI]-\u003e JTree c f-\u003e JTree c f",
          "type": "function"
        },
        "index": {
          "description": "Change evidence in the network",
          "hierarchy": "Bayes FactorElimination",
          "module": "Bayes.FactorElimination",
          "name": "changeEvidence",
          "normalized": "[DVI]-\u003eJTree a b-\u003eJTree a b",
          "package": "hbayes",
          "partial": "Evidence",
          "signature": "[DVI]-\u003eJTree c f-\u003eJTree c f",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-FactorElimination.html#v:changeEvidence"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCollect message taking into account that the tree depth may be different for different leaves.\n\u003c/p\u003e",
          "module": "Bayes.FactorElimination",
          "name": "collect",
          "package": "hbayes",
          "signature": "JTree c a -\u003e JTree c a",
          "source": "src/Bayes-FactorElimination-JTree.html#collect",
          "type": "function"
        },
        "index": {
          "description": "Collect message taking into account that the tree depth may be different for different leaves",
          "hierarchy": "Bayes FactorElimination",
          "module": "Bayes.FactorElimination",
          "name": "collect",
          "normalized": "JTree a b-\u003eJTree a b",
          "package": "hbayes",
          "signature": "JTree c a-\u003eJTree c a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-FactorElimination.html#v:collect"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreate the cluster graph\n\u003c/p\u003e",
          "module": "Bayes.FactorElimination",
          "name": "createClusterGraph",
          "package": "hbayes",
          "signature": "g' e f -\u003e [VertexCluster] -\u003e g Int Cluster",
          "source": "src/Bayes-FactorElimination.html#createClusterGraph",
          "type": "function"
        },
        "index": {
          "description": "Create the cluster graph",
          "hierarchy": "Bayes FactorElimination",
          "module": "Bayes.FactorElimination",
          "name": "createClusterGraph",
          "normalized": "a b c-\u003e[VertexCluster]-\u003ed Int Cluster",
          "package": "hbayes",
          "partial": "Cluster Graph",
          "signature": "g' e f-\u003e[VertexCluster]-\u003eg Int Cluster",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-FactorElimination.html#v:createClusterGraph"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreate a function tree\n\u003c/p\u003e",
          "module": "Bayes.FactorElimination",
          "name": "createJunctionTree",
          "package": "hbayes",
          "signature": "(UndirectedSG () f -\u003e Vertex -\u003e Vertex -\u003e Ordering)-\u003e BayesianNetwork g f-\u003e JunctionTree f",
          "type": "function"
        },
        "index": {
          "description": "Create function tree",
          "hierarchy": "Bayes FactorElimination",
          "module": "Bayes.FactorElimination",
          "name": "createJunctionTree",
          "normalized": "(UndirectedSG()a-\u003eVertex-\u003eVertex-\u003eOrdering)-\u003eBayesianNetwork b a-\u003eJunctionTree a",
          "package": "hbayes",
          "partial": "Junction Tree",
          "signature": "(UndirectedSG()f-\u003eVertex-\u003eVertex-\u003eOrdering)-\u003eBayesianNetwork g f-\u003eJunctionTree f",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-FactorElimination.html#v:createJunctionTree"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreate a junction tree with only the clusters and no factors\n\u003c/p\u003e",
          "module": "Bayes.FactorElimination",
          "name": "createUninitializedJunctionTree",
          "package": "hbayes",
          "signature": "(UndirectedSG () f -\u003e Vertex -\u003e Vertex -\u003e Ordering)-\u003e g () f-\u003e JunctionTree f",
          "type": "function"
        },
        "index": {
          "description": "Create junction tree with only the clusters and no factors",
          "hierarchy": "Bayes FactorElimination",
          "module": "Bayes.FactorElimination",
          "name": "createUninitializedJunctionTree",
          "normalized": "(UndirectedSG()a-\u003eVertex-\u003eVertex-\u003eOrdering)-\u003eb()a-\u003eJunctionTree a",
          "package": "hbayes",
          "partial": "Uninitialized Junction Tree",
          "signature": "(UndirectedSG()f-\u003eVertex-\u003eVertex-\u003eOrdering)-\u003eg()f-\u003eJunctionTree f",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-FactorElimination.html#v:createUninitializedJunctionTree"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDisplay the tree values\n\u003c/p\u003e",
          "module": "Bayes.FactorElimination",
          "name": "displayTreeValues",
          "package": "hbayes",
          "signature": "JTree c f -\u003e IO ()",
          "source": "src/Bayes-FactorElimination-JTree.html#displayTreeValues",
          "type": "function"
        },
        "index": {
          "description": "Display the tree values",
          "hierarchy": "Bayes FactorElimination",
          "module": "Bayes.FactorElimination",
          "name": "displayTreeValues",
          "normalized": "JTree a b-\u003eIO()",
          "package": "hbayes",
          "partial": "Tree Values",
          "signature": "JTree c f-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-FactorElimination.html#v:displayTreeValues"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Bayes.FactorElimination",
          "name": "distribute",
          "package": "hbayes",
          "signature": "JTree c a -\u003e JTree c a",
          "source": "src/Bayes-FactorElimination-JTree.html#distribute",
          "type": "function"
        },
        "index": {
          "hierarchy": "Bayes FactorElimination",
          "module": "Bayes.FactorElimination",
          "name": "distribute",
          "normalized": "JTree a b-\u003eJTree a b",
          "package": "hbayes",
          "signature": "JTree c a-\u003eJTree c a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-FactorElimination.html#v:distribute"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Bayes.FactorElimination",
          "name": "fromVertexCluster",
          "package": "hbayes",
          "signature": "VertexCluster -\u003e Set Vertex",
          "source": "src/Bayes-FactorElimination.html#fromVertexCluster",
          "type": "function"
        },
        "index": {
          "hierarchy": "Bayes FactorElimination",
          "module": "Bayes.FactorElimination",
          "name": "fromVertexCluster",
          "normalized": "VertexCluster-\u003eSet Vertex",
          "package": "hbayes",
          "partial": "Vertex Cluster",
          "signature": "VertexCluster-\u003eSet Vertex",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-FactorElimination.html#v:fromVertexCluster"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Bayes.FactorElimination",
          "name": "junctionTreeAllClusters_prop",
          "package": "hbayes",
          "signature": "DirectedSG () CPT -\u003e Property",
          "source": "src/Bayes-FactorElimination.html#junctionTreeAllClusters_prop",
          "type": "function"
        },
        "index": {
          "hierarchy": "Bayes FactorElimination",
          "module": "Bayes.FactorElimination",
          "name": "junctionTreeAllClusters_prop",
          "normalized": "DirectedSG()CPT-\u003eProperty",
          "package": "hbayes",
          "partial": "Tree All Clusters",
          "signature": "DirectedSG()CPT-\u003eProperty",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-FactorElimination.html#v:junctionTreeAllClusters_prop"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Bayes.FactorElimination",
          "name": "junctionTreeProperty",
          "package": "hbayes",
          "signature": "JTree Cluster CPT -\u003e [Cluster] -\u003e Cluster -\u003e Bool",
          "source": "src/Bayes-FactorElimination.html#junctionTreeProperty",
          "type": "function"
        },
        "index": {
          "hierarchy": "Bayes FactorElimination",
          "module": "Bayes.FactorElimination",
          "name": "junctionTreeProperty",
          "normalized": "JTree Cluster CPT-\u003e[Cluster]-\u003eCluster-\u003eBool",
          "package": "hbayes",
          "partial": "Tree Property",
          "signature": "JTree Cluster CPT-\u003e[Cluster]-\u003eCluster-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-FactorElimination.html#v:junctionTreeProperty"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Bayes.FactorElimination",
          "name": "junctionTreeProperty_prop",
          "package": "hbayes",
          "signature": "DirectedSG () CPT -\u003e Property",
          "source": "src/Bayes-FactorElimination.html#junctionTreeProperty_prop",
          "type": "function"
        },
        "index": {
          "hierarchy": "Bayes FactorElimination",
          "module": "Bayes.FactorElimination",
          "name": "junctionTreeProperty_prop",
          "normalized": "DirectedSG()CPT-\u003eProperty",
          "package": "hbayes",
          "partial": "Tree Property",
          "signature": "DirectedSG()CPT-\u003eProperty",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-FactorElimination.html#v:junctionTreeProperty_prop"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eImplementing the Prim's algorithm for minimum spanning tree\n\u003c/p\u003e",
          "module": "Bayes.FactorElimination",
          "name": "maximumSpanningTree",
          "package": "hbayes",
          "signature": "g Int c -\u003e JTree c f",
          "source": "src/Bayes-FactorElimination.html#maximumSpanningTree",
          "type": "function"
        },
        "index": {
          "description": "Implementing the Prim algorithm for minimum spanning tree",
          "hierarchy": "Bayes FactorElimination",
          "module": "Bayes.FactorElimination",
          "name": "maximumSpanningTree",
          "normalized": "a Int b-\u003eJTree b c",
          "package": "hbayes",
          "partial": "Spanning Tree",
          "signature": "g Int c-\u003eJTree c f",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-FactorElimination.html#v:maximumSpanningTree"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFor the junction tree construction, only the vertices are needed during the intermediate steps.\n So, the moral graph is returned without any vertex data.\n\u003c/p\u003e",
          "module": "Bayes.FactorElimination",
          "name": "moralGraph",
          "package": "hbayes",
          "signature": "g () b -\u003e UndirectedSG () b",
          "source": "src/Bayes-FactorElimination.html#moralGraph",
          "type": "function"
        },
        "index": {
          "description": "For the junction tree construction only the vertices are needed during the intermediate steps So the moral graph is returned without any vertex data",
          "hierarchy": "Bayes FactorElimination",
          "module": "Bayes.FactorElimination",
          "name": "moralGraph",
          "normalized": "a()b-\u003eUndirectedSG()b",
          "package": "hbayes",
          "partial": "Graph",
          "signature": "g()b-\u003eUndirectedSG()b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-FactorElimination.html#v:moralGraph"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eNode selection comparison function used for triangulating the graph\n\u003c/p\u003e",
          "module": "Bayes.FactorElimination",
          "name": "nodeComparisonForTriangulation",
          "package": "hbayes",
          "signature": "g a f -\u003e Vertex -\u003e Vertex -\u003e Ordering",
          "source": "src/Bayes-FactorElimination.html#nodeComparisonForTriangulation",
          "type": "function"
        },
        "index": {
          "description": "Node selection comparison function used for triangulating the graph",
          "hierarchy": "Bayes FactorElimination",
          "module": "Bayes.FactorElimination",
          "name": "nodeComparisonForTriangulation",
          "normalized": "a b c-\u003eVertex-\u003eVertex-\u003eOrdering",
          "package": "hbayes",
          "partial": "Comparison For Triangulation",
          "signature": "g a f-\u003eVertex-\u003eVertex-\u003eOrdering",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-FactorElimination.html#v:nodeComparisonForTriangulation"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eNumber of edges added when connecting all neighbors\n\u003c/p\u003e",
          "module": "Bayes.FactorElimination",
          "name": "numberOfAddedEdges",
          "package": "hbayes",
          "signature": "g a b -\u003e Vertex -\u003e Integer",
          "source": "src/Bayes-FactorElimination.html#numberOfAddedEdges",
          "type": "function"
        },
        "index": {
          "description": "Number of edges added when connecting all neighbors",
          "hierarchy": "Bayes FactorElimination",
          "module": "Bayes.FactorElimination",
          "name": "numberOfAddedEdges",
          "normalized": "a b c-\u003eVertex-\u003eInteger",
          "package": "hbayes",
          "partial": "Of Added Edges",
          "signature": "g a b-\u003eVertex-\u003eInteger",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-FactorElimination.html#v:numberOfAddedEdges"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCompute the marginal posterior (if some evidence is set on the junction tree)\n otherwise compute just the marginal prior. The set of variables must be included inside a cluster\n for thr algorithm to work. So, most of the cases, it will be used to compute the posterior of just\n one variable.\n\u003c/p\u003e",
          "module": "Bayes.FactorElimination",
          "name": "posterior",
          "package": "hbayes",
          "signature": "JunctionTree f -\u003e [dv] -\u003e Maybe f",
          "source": "src/Bayes-FactorElimination.html#posterior",
          "type": "function"
        },
        "index": {
          "description": "Compute the marginal posterior if some evidence is set on the junction tree otherwise compute just the marginal prior The set of variables must be included inside cluster for thr algorithm to work So most of the cases it will be used to compute the posterior of just one variable",
          "hierarchy": "Bayes FactorElimination",
          "module": "Bayes.FactorElimination",
          "name": "posterior",
          "normalized": "JunctionTree a-\u003e[b]-\u003eMaybe a",
          "package": "hbayes",
          "signature": "JunctionTree f-\u003e[dv]-\u003eMaybe f",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-FactorElimination.html#v:posterior"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTriangulate a graph using a cost function\n The result is the triangulated graph and the list of clusters\n which may not be maximal.\n\u003c/p\u003e",
          "module": "Bayes.FactorElimination",
          "name": "triangulate",
          "package": "hbayes",
          "signature": "(Vertex -\u003e Vertex -\u003e Ordering)-\u003e g () b-\u003e [VertexCluster]",
          "type": "function"
        },
        "index": {
          "description": "Triangulate graph using cost function The result is the triangulated graph and the list of clusters which may not be maximal",
          "hierarchy": "Bayes FactorElimination",
          "module": "Bayes.FactorElimination",
          "name": "triangulate",
          "normalized": "(Vertex-\u003eVertex-\u003eOrdering)-\u003ea()b-\u003e[VertexCluster]",
          "package": "hbayes",
          "signature": "(Vertex-\u003eVertex-\u003eOrdering)-\u003eg()b-\u003e[VertexCluster]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-FactorElimination.html#v:triangulate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Bayes.FactorElimination",
          "name": "triangulatedebug",
          "package": "hbayes",
          "signature": "(Vertex -\u003e Vertex -\u003e Ordering)-\u003e g () b-\u003e ([VertexCluster], [g () b])",
          "type": "function"
        },
        "index": {
          "hierarchy": "Bayes FactorElimination",
          "module": "Bayes.FactorElimination",
          "name": "triangulatedebug",
          "normalized": "(Vertex-\u003eVertex-\u003eOrdering)-\u003ea()b-\u003e([VertexCluster],[a()b])",
          "package": "hbayes",
          "signature": "(Vertex-\u003eVertex-\u003eOrdering)-\u003eg()b-\u003e([VertexCluster],[g()b])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-FactorElimination.html#v:triangulatedebug"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWeight of a node\n\u003c/p\u003e",
          "module": "Bayes.FactorElimination",
          "name": "weight",
          "package": "hbayes",
          "signature": "g a f -\u003e Vertex -\u003e Integer",
          "source": "src/Bayes-FactorElimination.html#weight",
          "type": "function"
        },
        "index": {
          "description": "Weight of node",
          "hierarchy": "Bayes FactorElimination",
          "module": "Bayes.FactorElimination",
          "name": "weight",
          "normalized": "a b c-\u003eVertex-\u003eInteger",
          "package": "hbayes",
          "signature": "g a f-\u003eVertex-\u003eInteger",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-FactorElimination.html#v:weight"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Bayes.FactorElimination",
          "name": "weightedEdges",
          "package": "hbayes",
          "signature": "g a f -\u003e Vertex -\u003e Integer",
          "source": "src/Bayes-FactorElimination.html#weightedEdges",
          "type": "function"
        },
        "index": {
          "hierarchy": "Bayes FactorElimination",
          "module": "Bayes.FactorElimination",
          "name": "weightedEdges",
          "normalized": "a b c-\u003eVertex-\u003eInteger",
          "package": "hbayes",
          "partial": "Edges",
          "signature": "g a f-\u003eVertex-\u003eInteger",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-FactorElimination.html#v:weightedEdges"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eParser for a subset of the Hugin Net language\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Bayes.ImportExport.HuginNet",
          "name": "HuginNet",
          "package": "hbayes",
          "source": "src/Bayes-ImportExport-HuginNet.html",
          "type": "module"
        },
        "index": {
          "description": "Parser for subset of the Hugin Net language",
          "hierarchy": "Bayes ImportExport HuginNet",
          "module": "Bayes.ImportExport.HuginNet",
          "name": "HuginNet",
          "package": "hbayes",
          "partial": "Hugin Net",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-ImportExport-HuginNet.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eImport a bayesian network form a Hugin file.\n Only a subset of the file format is supported.\n You may have to convert the line endings to be able to parse a file\n When it is succeeding, it is returing a bayesian network monad and\n a mapping from node names to discrete variables.\n\u003c/p\u003e",
          "module": "Bayes.ImportExport.HuginNet",
          "name": "importBayesianGraph",
          "package": "hbayes",
          "signature": "String -\u003e IO (Maybe (BNMonad DirectedSG f (Map String DV)))",
          "source": "src/Bayes-ImportExport-HuginNet.html#importBayesianGraph",
          "type": "function"
        },
        "index": {
          "description": "Import bayesian network form Hugin file Only subset of the file format is supported You may have to convert the line endings to be able to parse file When it is succeeding it is returing bayesian network monad and mapping from node names to discrete variables",
          "hierarchy": "Bayes ImportExport HuginNet",
          "module": "Bayes.ImportExport.HuginNet",
          "name": "importBayesianGraph",
          "normalized": "String-\u003eIO(Maybe(BNMonad DirectedSG a(Map String DV)))",
          "package": "hbayes",
          "partial": "Bayesian Graph",
          "signature": "String-\u003eIO(Maybe(BNMonad DirectedSG f(Map String DV)))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-ImportExport-HuginNet.html#v:importBayesianGraph"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eImport / export Bayesian networks and junction tress\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Bayes.ImportExport",
          "name": "ImportExport",
          "package": "hbayes",
          "source": "src/Bayes-ImportExport.html",
          "type": "module"
        },
        "index": {
          "description": "Import export Bayesian networks and junction tress",
          "hierarchy": "Bayes ImportExport",
          "module": "Bayes.ImportExport",
          "name": "ImportExport",
          "package": "hbayes",
          "partial": "Import Export",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-ImportExport.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRead bayesian network from file \n\u003c/p\u003e",
          "module": "Bayes.ImportExport",
          "name": "readNetworkFromFile",
          "package": "hbayes",
          "signature": "FilePath -\u003e IO (SBN CPT)",
          "source": "src/Bayes-ImportExport.html#readNetworkFromFile",
          "type": "function"
        },
        "index": {
          "description": "Read bayesian network from file",
          "hierarchy": "Bayes ImportExport",
          "module": "Bayes.ImportExport",
          "name": "readNetworkFromFile",
          "normalized": "FilePath-\u003eIO(SBN CPT)",
          "package": "hbayes",
          "partial": "Network From File",
          "signature": "FilePath-\u003eIO(SBN CPT)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-ImportExport.html#v:readNetworkFromFile"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRead variable map and junction tree from file\n\u003c/p\u003e",
          "module": "Bayes.ImportExport",
          "name": "readVariableMapAndJunctionTreeToFile",
          "package": "hbayes",
          "signature": "FilePath -\u003e IO (Map String Vertex, JunctionTree CPT)",
          "source": "src/Bayes-ImportExport.html#readVariableMapAndJunctionTreeToFile",
          "type": "function"
        },
        "index": {
          "description": "Read variable map and junction tree from file",
          "hierarchy": "Bayes ImportExport",
          "module": "Bayes.ImportExport",
          "name": "readVariableMapAndJunctionTreeToFile",
          "normalized": "FilePath-\u003eIO(Map String Vertex,JunctionTree CPT)",
          "package": "hbayes",
          "partial": "Variable Map And Junction Tree To File",
          "signature": "FilePath-\u003eIO(Map String Vertex,JunctionTree CPT)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-ImportExport.html#v:readVariableMapAndJunctionTreeToFile"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWrite a bayesian network to file\n\u003c/p\u003e",
          "module": "Bayes.ImportExport",
          "name": "writeNetworkToFile",
          "package": "hbayes",
          "signature": "FilePath-\u003e SBN CPT-\u003e IO ()",
          "type": "function"
        },
        "index": {
          "description": "Write bayesian network to file",
          "hierarchy": "Bayes ImportExport",
          "module": "Bayes.ImportExport",
          "name": "writeNetworkToFile",
          "normalized": "FilePath-\u003eSBN CPT-\u003eIO()",
          "package": "hbayes",
          "partial": "Network To File",
          "signature": "FilePath-\u003eSBN CPT-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-ImportExport.html#v:writeNetworkToFile"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWrite a junction tree and the variable map to a file \n\u003c/p\u003e",
          "module": "Bayes.ImportExport",
          "name": "writeVariableMapAndJunctionTreeToFile",
          "package": "hbayes",
          "signature": "FilePath -\u003e Map String Vertex -\u003e JunctionTree CPT -\u003e IO ()",
          "source": "src/Bayes-ImportExport.html#writeVariableMapAndJunctionTreeToFile",
          "type": "function"
        },
        "index": {
          "description": "Write junction tree and the variable map to file",
          "hierarchy": "Bayes ImportExport",
          "module": "Bayes.ImportExport",
          "name": "writeVariableMapAndJunctionTreeToFile",
          "normalized": "FilePath-\u003eMap String Vertex-\u003eJunctionTree CPT-\u003eIO()",
          "package": "hbayes",
          "partial": "Variable Map And Junction Tree To File",
          "signature": "FilePath-\u003eMap String Vertex-\u003eJunctionTree CPT-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-ImportExport.html#v:writeVariableMapAndJunctionTreeToFile"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eTools to build influence diagrams\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Bayes.InfluenceDiagram",
          "name": "InfluenceDiagram",
          "package": "hbayes",
          "source": "src/Bayes-InfluenceDiagram.html",
          "type": "module"
        },
        "index": {
          "description": "Tools to build influence diagrams",
          "hierarchy": "Bayes InfluenceDiagram",
          "module": "Bayes.InfluenceDiagram",
          "name": "InfluenceDiagram",
          "package": "hbayes",
          "partial": "Influence Diagram",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-InfluenceDiagram.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDecision variable\n\u003c/p\u003e",
          "module": "Bayes.InfluenceDiagram",
          "name": "DEV",
          "package": "hbayes",
          "source": "src/Bayes-InfluenceDiagram.html#DEV",
          "type": "data"
        },
        "index": {
          "description": "Decision variable",
          "hierarchy": "Bayes InfluenceDiagram",
          "module": "Bayes.InfluenceDiagram",
          "name": "DEV",
          "package": "hbayes",
          "partial": "DEV",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-InfluenceDiagram.html#t:DEV"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA discrete variable\n\u003c/p\u003e",
          "module": "Bayes.InfluenceDiagram",
          "name": "DV",
          "package": "hbayes",
          "source": "src/Bayes-PrivateTypes.html#DV",
          "type": "data"
        },
        "index": {
          "description": "discrete variable",
          "hierarchy": "Bayes InfluenceDiagram",
          "module": "Bayes.InfluenceDiagram",
          "name": "DV",
          "package": "hbayes",
          "partial": "DV",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-InfluenceDiagram.html#t:DV"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDiscrete Variable instantiation. A variable and its value\n\u003c/p\u003e",
          "module": "Bayes.InfluenceDiagram",
          "name": "DVI",
          "package": "hbayes",
          "source": "src/Bayes-PrivateTypes.html#DVI",
          "type": "data"
        },
        "index": {
          "description": "Discrete Variable instantiation variable and its value",
          "hierarchy": "Bayes InfluenceDiagram",
          "module": "Bayes.InfluenceDiagram",
          "name": "DVI",
          "package": "hbayes",
          "partial": "DVI",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-InfluenceDiagram.html#t:DVI"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Bayes.InfluenceDiagram",
          "name": "DVISet",
          "package": "hbayes",
          "source": "src/Bayes-PrivateTypes.html#DVISet",
          "type": "type"
        },
        "index": {
          "hierarchy": "Bayes InfluenceDiagram",
          "module": "Bayes.InfluenceDiagram",
          "name": "DVISet",
          "package": "hbayes",
          "partial": "DVISet",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-InfluenceDiagram.html#t:DVISet"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Bayes.InfluenceDiagram",
          "name": "DecisionFactor",
          "package": "hbayes",
          "source": "src/Bayes-Factor-PrivateCPT.html#DecisionFactor",
          "type": "type"
        },
        "index": {
          "hierarchy": "Bayes InfluenceDiagram",
          "module": "Bayes.InfluenceDiagram",
          "name": "DecisionFactor",
          "package": "hbayes",
          "partial": "Decision Factor",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-InfluenceDiagram.html#t:DecisionFactor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Bayes.InfluenceDiagram",
          "name": "IDMonad",
          "package": "hbayes",
          "source": "src/Bayes-InfluenceDiagram.html#IDMonad",
          "type": "type"
        },
        "index": {
          "hierarchy": "Bayes InfluenceDiagram",
          "module": "Bayes.InfluenceDiagram",
          "name": "IDMonad",
          "package": "hbayes",
          "partial": "IDMonad",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-InfluenceDiagram.html#t:IDMonad"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInfluence diagram\n\u003c/p\u003e",
          "module": "Bayes.InfluenceDiagram",
          "name": "InfluenceDiagram",
          "package": "hbayes",
          "source": "src/Bayes-InfluenceDiagram.html#InfluenceDiagram",
          "type": "type"
        },
        "index": {
          "description": "Influence diagram",
          "hierarchy": "Bayes InfluenceDiagram",
          "module": "Bayes.InfluenceDiagram",
          "name": "InfluenceDiagram",
          "package": "hbayes",
          "partial": "Influence Diagram",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-InfluenceDiagram.html#t:InfluenceDiagram"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Bayes.InfluenceDiagram",
          "name": "Instantiable",
          "package": "hbayes",
          "source": "src/Bayes-PrivateTypes.html#Instantiable",
          "type": "class"
        },
        "index": {
          "hierarchy": "Bayes InfluenceDiagram",
          "module": "Bayes.InfluenceDiagram",
          "name": "Instantiable",
          "package": "hbayes",
          "partial": "Instantiable",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-InfluenceDiagram.html#t:Instantiable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA typed discrete variable\n\u003c/p\u003e",
          "module": "Bayes.InfluenceDiagram",
          "name": "TDV",
          "package": "hbayes",
          "source": "src/Bayes-PrivateTypes.html#TDV",
          "type": "data"
        },
        "index": {
          "description": "typed discrete variable",
          "hierarchy": "Bayes InfluenceDiagram",
          "module": "Bayes.InfluenceDiagram",
          "name": "TDV",
          "package": "hbayes",
          "partial": "TDV",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-InfluenceDiagram.html#t:TDV"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUtility variable\n\u003c/p\u003e",
          "module": "Bayes.InfluenceDiagram",
          "name": "UV",
          "package": "hbayes",
          "source": "src/Bayes-InfluenceDiagram.html#UV",
          "type": "data"
        },
        "index": {
          "description": "Utility variable",
          "hierarchy": "Bayes InfluenceDiagram",
          "module": "Bayes.InfluenceDiagram",
          "name": "UV",
          "package": "hbayes",
          "partial": "UV",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-InfluenceDiagram.html#t:UV"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Bayes.InfluenceDiagram",
          "name": "(~~)",
          "package": "hbayes",
          "signature": "IDMonad g v-\u003e d-\u003e IDMonad g ()",
          "type": "function"
        },
        "index": {
          "hierarchy": "Bayes InfluenceDiagram",
          "module": "Bayes.InfluenceDiagram",
          "name": "(~~) ~~",
          "normalized": "IDMonad a b-\u003ec-\u003eIDMonad a()",
          "package": "hbayes",
          "signature": "IDMonad g v-\u003ed-\u003eIDMonad g()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-InfluenceDiagram.html#v:-126--126-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreate a variable instantiation using values from\n an enumeration\n\u003c/p\u003e",
          "module": "Bayes.InfluenceDiagram",
          "name": "(=:)",
          "package": "hbayes",
          "signature": "d -\u003e v -\u003e r",
          "source": "src/Bayes-PrivateTypes.html#%3D%3A",
          "type": "method"
        },
        "index": {
          "description": "Create variable instantiation using values from an enumeration",
          "hierarchy": "Bayes InfluenceDiagram",
          "module": "Bayes.InfluenceDiagram",
          "name": "(=:) =:",
          "normalized": "a-\u003eb-\u003ec",
          "package": "hbayes",
          "signature": "d-\u003ev-\u003er",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-InfluenceDiagram.html#v:-61-:"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreate a chance node\n\u003c/p\u003e",
          "module": "Bayes.InfluenceDiagram",
          "name": "chance",
          "package": "hbayes",
          "signature": "String -\u003e a -\u003e IDMonad g (TDV a)",
          "source": "src/Bayes-InfluenceDiagram.html#chance",
          "type": "function"
        },
        "index": {
          "description": "Create chance node",
          "hierarchy": "Bayes InfluenceDiagram",
          "module": "Bayes.InfluenceDiagram",
          "name": "chance",
          "normalized": "String-\u003ea-\u003eIDMonad b(TDV a)",
          "package": "hbayes",
          "signature": "String-\u003ea-\u003eIDMonad g(TDV a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-InfluenceDiagram.html#v:chance"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDefine that a chance node is a conditional probability and define the parent variables\n\u003c/p\u003e",
          "module": "Bayes.InfluenceDiagram",
          "name": "cpt",
          "package": "hbayes",
          "signature": "c -\u003e [vb] -\u003e IDMonad g c",
          "source": "src/Bayes-InfluenceDiagram.html#cpt",
          "type": "function"
        },
        "index": {
          "description": "Define that chance node is conditional probability and define the parent variables",
          "hierarchy": "Bayes InfluenceDiagram",
          "module": "Bayes.InfluenceDiagram",
          "name": "cpt",
          "normalized": "a-\u003e[b]-\u003eIDMonad c a",
          "package": "hbayes",
          "signature": "c-\u003e[vb]-\u003eIDMonad g c",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-InfluenceDiagram.html#v:cpt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUsed to mix decision and chance variables and a same list\n\u003c/p\u003e",
          "module": "Bayes.InfluenceDiagram",
          "name": "d",
          "package": "hbayes",
          "signature": "DEV -\u003e PorD",
          "source": "src/Bayes-InfluenceDiagram.html#d",
          "type": "function"
        },
        "index": {
          "description": "Used to mix decision and chance variables and same list",
          "hierarchy": "Bayes InfluenceDiagram",
          "module": "Bayes.InfluenceDiagram",
          "name": "d",
          "normalized": "DEV-\u003ePorD",
          "package": "hbayes",
          "signature": "DEV-\u003ePorD",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-InfluenceDiagram.html#v:d"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDefine a decision dependence\n\u003c/p\u003e",
          "module": "Bayes.InfluenceDiagram",
          "name": "decision",
          "package": "hbayes",
          "signature": "DEV -\u003e [dv] -\u003e IDMonad g DEV",
          "source": "src/Bayes-InfluenceDiagram.html#decision",
          "type": "function"
        },
        "index": {
          "description": "Define decision dependence",
          "hierarchy": "Bayes InfluenceDiagram",
          "module": "Bayes.InfluenceDiagram",
          "name": "decision",
          "normalized": "DEV-\u003e[a]-\u003eIDMonad b DEV",
          "package": "hbayes",
          "signature": "DEV-\u003e[dv]-\u003eIDMonad g DEV",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-InfluenceDiagram.html#v:decision"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreate a decision node\n\u003c/p\u003e",
          "module": "Bayes.InfluenceDiagram",
          "name": "decisionNode",
          "package": "hbayes",
          "signature": "String -\u003e a -\u003e IDMonad g DEV",
          "source": "src/Bayes-InfluenceDiagram.html#decisionNode",
          "type": "function"
        },
        "index": {
          "description": "Create decision node",
          "hierarchy": "Bayes InfluenceDiagram",
          "module": "Bayes.InfluenceDiagram",
          "name": "decisionNode",
          "normalized": "String-\u003ea-\u003eIDMonad b DEV",
          "package": "hbayes",
          "partial": "Node",
          "signature": "String-\u003ea-\u003eIDMonad g DEV",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-InfluenceDiagram.html#v:decisionNode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert a decision policy to a set of possible instantiations\n It is the only way to access to the content of a decision factor.\n\u003c/p\u003e",
          "module": "Bayes.InfluenceDiagram",
          "name": "decisionToInstantiation",
          "package": "hbayes",
          "signature": "DecisionFactor -\u003e [DVISet]",
          "source": "src/Bayes-InfluenceDiagram.html#decisionToInstantiation",
          "type": "function"
        },
        "index": {
          "description": "Convert decision policy to set of possible instantiations It is the only way to access to the content of decision factor",
          "hierarchy": "Bayes InfluenceDiagram",
          "module": "Bayes.InfluenceDiagram",
          "name": "decisionToInstantiation",
          "normalized": "DecisionFactor-\u003e[DVISet]",
          "package": "hbayes",
          "partial": "To Instantiation",
          "signature": "DecisionFactor-\u003e[DVISet]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-InfluenceDiagram.html#v:decisionToInstantiation"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eList of decision vertices in reverse temporal order (corresponding to elimination order)\n\u003c/p\u003e",
          "module": "Bayes.InfluenceDiagram",
          "name": "decisionsOrder",
          "package": "hbayes",
          "signature": "InfluenceDiagram -\u003e [ChancesOrDecision]",
          "source": "src/Bayes-InfluenceDiagram.html#decisionsOrder",
          "type": "function"
        },
        "index": {
          "description": "List of decision vertices in reverse temporal order corresponding to elimination order",
          "hierarchy": "Bayes InfluenceDiagram",
          "module": "Bayes.InfluenceDiagram",
          "name": "decisionsOrder",
          "normalized": "InfluenceDiagram-\u003e[ChancesOrDecision]",
          "package": "hbayes",
          "partial": "Order",
          "signature": "InfluenceDiagram-\u003e[ChancesOrDecision]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-InfluenceDiagram.html#v:decisionsOrder"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUsed to define a root decision which is not dependent on any past node\n\u003c/p\u003e",
          "module": "Bayes.InfluenceDiagram",
          "name": "noDependencies",
          "package": "hbayes",
          "signature": "[DV]",
          "source": "src/Bayes-InfluenceDiagram.html#noDependencies",
          "type": "function"
        },
        "index": {
          "description": "Used to define root decision which is not dependent on any past node",
          "hierarchy": "Bayes InfluenceDiagram",
          "module": "Bayes.InfluenceDiagram",
          "name": "noDependencies",
          "normalized": "[DV]",
          "package": "hbayes",
          "partial": "Dependencies",
          "signature": "[DV]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-InfluenceDiagram.html#v:noDependencies"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUsed to mix decision and chance variables and a same list\n\u003c/p\u003e",
          "module": "Bayes.InfluenceDiagram",
          "name": "p",
          "package": "hbayes",
          "signature": "c -\u003e PorD",
          "source": "src/Bayes-InfluenceDiagram.html#p",
          "type": "function"
        },
        "index": {
          "description": "Used to mix decision and chance variables and same list",
          "hierarchy": "Bayes InfluenceDiagram",
          "module": "Bayes.InfluenceDiagram",
          "name": "p",
          "normalized": "a-\u003ePorD",
          "package": "hbayes",
          "signature": "c-\u003ePorD",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-InfluenceDiagram.html#v:p"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreate a policy network from an influence diagram and its solution.\n A policy network is a Bayesian network where the decision nodes have been replaced\n with probability nodes where the probability is 1 when the configuration is corresponding\n to the decision and 0 otherwise.\n\u003c/p\u003e",
          "module": "Bayes.InfluenceDiagram",
          "name": "policyNetwork",
          "package": "hbayes",
          "signature": "[DecisionFactor] -\u003e InfluenceDiagram -\u003e SBN CPT",
          "source": "src/Bayes-InfluenceDiagram.html#policyNetwork",
          "type": "function"
        },
        "index": {
          "description": "Create policy network from an influence diagram and its solution policy network is Bayesian network where the decision nodes have been replaced with probability nodes where the probability is when the configuration is corresponding to the decision and otherwise",
          "hierarchy": "Bayes InfluenceDiagram",
          "module": "Bayes.InfluenceDiagram",
          "name": "policyNetwork",
          "normalized": "[DecisionFactor]-\u003eInfluenceDiagram-\u003eSBN CPT",
          "package": "hbayes",
          "partial": "Network",
          "signature": "[DecisionFactor]-\u003eInfluenceDiagram-\u003eSBN CPT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-InfluenceDiagram.html#v:policyNetwork"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDefine that a chance node is a probability (not conditional)\n Values are ordered like\n FFF FFT FTF FTT TFF TFT TTF TTT\n and same for other enumeration keeping enumeration order\n\u003c/p\u003e",
          "module": "Bayes.InfluenceDiagram",
          "name": "proba",
          "package": "hbayes",
          "signature": "c -\u003e IDMonad g c",
          "source": "src/Bayes-InfluenceDiagram.html#proba",
          "type": "function"
        },
        "index": {
          "description": "Define that chance node is probability not conditional Values are ordered like FFF FFT FTF FTT TFF TFT TTF TTT and same for other enumeration keeping enumeration order",
          "hierarchy": "Bayes InfluenceDiagram",
          "module": "Bayes.InfluenceDiagram",
          "name": "proba",
          "normalized": "a-\u003eIDMonad b a",
          "package": "hbayes",
          "signature": "c-\u003eIDMonad g c",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-InfluenceDiagram.html#v:proba"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRun an influence monad\n\u003c/p\u003e",
          "module": "Bayes.InfluenceDiagram",
          "name": "runID",
          "package": "hbayes",
          "signature": "IDMonad DirectedSG a -\u003e (a, InfluenceDiagram)",
          "source": "src/Bayes-InfluenceDiagram.html#runID",
          "type": "function"
        },
        "index": {
          "description": "Run an influence monad",
          "hierarchy": "Bayes InfluenceDiagram",
          "module": "Bayes.InfluenceDiagram",
          "name": "runID",
          "normalized": "IDMonad DirectedSG a-\u003e(a,InfluenceDiagram)",
          "package": "hbayes",
          "partial": "ID",
          "signature": "IDMonad DirectedSG a-\u003e(a,InfluenceDiagram)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-InfluenceDiagram.html#v:runID"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSolve an influence diagram. A DecisionFactor is generated for each decision variable.\n A decision factor is containing a variable instantiation instead of a double.\n This instantiation is giving the decision to take for each value of the parents.\n\u003c/p\u003e",
          "module": "Bayes.InfluenceDiagram",
          "name": "solveInfluenceDiagram",
          "package": "hbayes",
          "signature": "InfluenceDiagram -\u003e [DecisionFactor]",
          "source": "src/Bayes-InfluenceDiagram.html#solveInfluenceDiagram",
          "type": "function"
        },
        "index": {
          "description": "Solve an influence diagram DecisionFactor is generated for each decision variable decision factor is containing variable instantiation instead of double This instantiation is giving the decision to take for each value of the parents",
          "hierarchy": "Bayes InfluenceDiagram",
          "module": "Bayes.InfluenceDiagram",
          "name": "solveInfluenceDiagram",
          "normalized": "InfluenceDiagram-\u003e[DecisionFactor]",
          "package": "hbayes",
          "partial": "Influence Diagram",
          "signature": "InfluenceDiagram-\u003e[DecisionFactor]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-InfluenceDiagram.html#v:solveInfluenceDiagram"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSynonym for undefined because it is clearer to use t to set the Enum bounds of a variable\n\u003c/p\u003e",
          "module": "Bayes.InfluenceDiagram",
          "name": "t",
          "package": "hbayes",
          "signature": "a",
          "source": "src/Bayes-InfluenceDiagram.html#t",
          "type": "function"
        },
        "index": {
          "description": "Synonym for undefined because it is clearer to use to set the Enum bounds of variable",
          "hierarchy": "Bayes InfluenceDiagram",
          "module": "Bayes.InfluenceDiagram",
          "name": "t",
          "package": "hbayes",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-InfluenceDiagram.html#v:t"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDefine a utility dependence\n\u003c/p\u003e",
          "module": "Bayes.InfluenceDiagram",
          "name": "utility",
          "package": "hbayes",
          "signature": "UV -\u003e [dv] -\u003e IDMonad g UV",
          "source": "src/Bayes-InfluenceDiagram.html#utility",
          "type": "function"
        },
        "index": {
          "description": "Define utility dependence",
          "hierarchy": "Bayes InfluenceDiagram",
          "module": "Bayes.InfluenceDiagram",
          "name": "utility",
          "normalized": "UV-\u003e[a]-\u003eIDMonad b UV",
          "package": "hbayes",
          "signature": "UV-\u003e[dv]-\u003eIDMonad g UV",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-InfluenceDiagram.html#v:utility"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreate an utility node\n\u003c/p\u003e",
          "module": "Bayes.InfluenceDiagram",
          "name": "utilityNode",
          "package": "hbayes",
          "signature": "String -\u003e IDMonad g UV",
          "source": "src/Bayes-InfluenceDiagram.html#utilityNode",
          "type": "function"
        },
        "index": {
          "description": "Create an utility node",
          "hierarchy": "Bayes InfluenceDiagram",
          "module": "Bayes.InfluenceDiagram",
          "name": "utilityNode",
          "normalized": "String-\u003eIDMonad a UV",
          "package": "hbayes",
          "partial": "Node",
          "signature": "String-\u003eIDMonad g UV",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-InfluenceDiagram.html#v:utilityNode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eSampling\n\u003c/p\u003e\u003cp\u003eSamplers for Bayesian network inferences\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Bayes.Sampling",
          "name": "Sampling",
          "package": "hbayes",
          "source": "src/Bayes-Sampling.html",
          "type": "module"
        },
        "index": {
          "description": "Sampling Samplers for Bayesian network inferences",
          "hierarchy": "Bayes Sampling",
          "module": "Bayes.Sampling",
          "name": "Sampling",
          "package": "hbayes",
          "partial": "Sampling",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-Sampling.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Bayes.Sampling",
          "name": "ContinuousNetwork",
          "package": "hbayes",
          "source": "src/Bayes-Sampling.html#ContinuousNetwork",
          "type": "type"
        },
        "index": {
          "hierarchy": "Bayes Sampling",
          "module": "Bayes.Sampling",
          "name": "ContinuousNetwork",
          "package": "hbayes",
          "partial": "Continuous Network",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-Sampling.html#t:ContinuousNetwork"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Bayes.Sampling",
          "name": "ContinuousSample",
          "package": "hbayes",
          "source": "src/Bayes-Sampling.html#ContinuousSample",
          "type": "type"
        },
        "index": {
          "hierarchy": "Bayes Sampling",
          "module": "Bayes.Sampling",
          "name": "ContinuousSample",
          "package": "hbayes",
          "partial": "Continuous Sample",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-Sampling.html#t:ContinuousSample"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Bayes.Sampling",
          "name": "Distri",
          "package": "hbayes",
          "source": "src/Bayes-Sampling.html#Distri",
          "type": "data"
        },
        "index": {
          "hierarchy": "Bayes Sampling",
          "module": "Bayes.Sampling",
          "name": "Distri",
          "package": "hbayes",
          "partial": "Distri",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-Sampling.html#t:Distri"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA sample (graph of instantiations)\n\u003c/p\u003e",
          "module": "Bayes.Sampling",
          "name": "Sample",
          "package": "hbayes",
          "source": "src/Bayes-PrivateTypes.html#Sample",
          "type": "type"
        },
        "index": {
          "description": "sample graph of instantiations",
          "hierarchy": "Bayes Sampling",
          "module": "Bayes.Sampling",
          "name": "Sample",
          "package": "hbayes",
          "partial": "Sample",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-Sampling.html#t:Sample"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSampler defining the behavior of a sampling algorithms (init value,\n sample generation, how to select nodes in the grapg)\n\u003c/p\u003e",
          "module": "Bayes.Sampling",
          "name": "Sampler",
          "package": "hbayes",
          "source": "src/Bayes-Sampling.html#Sampler",
          "type": "data"
        },
        "index": {
          "description": "Sampler defining the behavior of sampling algorithms init value sample generation how to select nodes in the grapg",
          "hierarchy": "Bayes Sampling",
          "module": "Bayes.Sampling",
          "name": "Sampler",
          "package": "hbayes",
          "partial": "Sampler",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-Sampling.html#t:Sampler"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Bayes.Sampling",
          "name": "D",
          "package": "hbayes",
          "signature": "D !CV !(DistributionF DirectedSG (Double, Double) CVI)",
          "source": "src/Bayes-Sampling.html#Distri",
          "type": "function"
        },
        "index": {
          "hierarchy": "Bayes Sampling",
          "module": "Bayes.Sampling",
          "name": "D",
          "normalized": "D CV(DistributionF DirectedSG(Double,Double)CVI)",
          "package": "hbayes",
          "signature": "D CV(DistributionF DirectedSG(Double,Double)CVI)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-Sampling.html#v:D"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Bayes.Sampling",
          "name": "Sampler",
          "package": "hbayes",
          "signature": "forall b . Sampler !b !(GenIO -\u003e IO (Sample g a)) !(GenIO -\u003e SamplerGraph g a) !(SamplingScheme g b a)",
          "source": "src/Bayes-Sampling.html#Sampler",
          "type": "function"
        },
        "index": {
          "hierarchy": "Bayes Sampling",
          "module": "Bayes.Sampling",
          "name": "Sampler",
          "normalized": "a b Sampler b(GenIO-\u003eIO(Sample c d))(GenIO-\u003eSamplerGraph c d)(SamplingScheme c b d)",
          "package": "hbayes",
          "partial": "Sampler",
          "signature": "forall b Sampler b(GenIO-\u003eIO(Sample g a))(GenIO-\u003eSamplerGraph g a)(SamplingScheme g b a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-Sampling.html#v:Sampler"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAncestral sampler which does not support evidence\n\u003c/p\u003e",
          "module": "Bayes.Sampling",
          "name": "discreteAncestralSampler",
          "package": "hbayes",
          "signature": "BayesianNetwork g f -\u003e Sampler g DVI",
          "source": "src/Bayes-Sampling.html#discreteAncestralSampler",
          "type": "function"
        },
        "index": {
          "description": "Ancestral sampler which does not support evidence",
          "hierarchy": "Bayes Sampling",
          "module": "Bayes.Sampling",
          "name": "discreteAncestralSampler",
          "normalized": "BayesianNetwork a b-\u003eSampler a DVI",
          "package": "hbayes",
          "partial": "Ancestral Sampler",
          "signature": "BayesianNetwork g f-\u003eSampler g DVI",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-Sampling.html#v:discreteAncestralSampler"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGibbs sampling\n\u003c/p\u003e",
          "module": "Bayes.Sampling",
          "name": "gibbsMCMCSampler",
          "package": "hbayes",
          "signature": "BayesianNetwork g f-\u003e [DVI]-\u003e Sampler g DVI",
          "type": "function"
        },
        "index": {
          "description": "Gibbs sampling",
          "hierarchy": "Bayes Sampling",
          "module": "Bayes.Sampling",
          "name": "gibbsMCMCSampler",
          "normalized": "BayesianNetwork a b-\u003e[DVI]-\u003eSampler a DVI",
          "package": "hbayes",
          "partial": "MCMCSampler",
          "signature": "BayesianNetwork g f-\u003e[DVI]-\u003eSampler g DVI",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-Sampling.html#v:gibbsMCMCSampler"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGibbs sampling\n\u003c/p\u003e",
          "module": "Bayes.Sampling",
          "name": "gibbsSampler",
          "package": "hbayes",
          "signature": "BayesianNetwork g f-\u003e [DVI]-\u003e Sampler g DVI",
          "type": "function"
        },
        "index": {
          "description": "Gibbs sampling",
          "hierarchy": "Bayes Sampling",
          "module": "Bayes.Sampling",
          "name": "gibbsSampler",
          "normalized": "BayesianNetwork a b-\u003e[DVI]-\u003eSampler a DVI",
          "package": "hbayes",
          "partial": "Sampler",
          "signature": "BayesianNetwork g f-\u003e[DVI]-\u003eSampler g DVI",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-Sampling.html#v:gibbsSampler"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn the vertices in topological order\n\u003c/p\u003e",
          "module": "Bayes.Sampling",
          "name": "topologicalOrder",
          "package": "hbayes",
          "signature": "g a b -\u003e [Vertex]",
          "source": "src/Bayes-Sampling.html#topologicalOrder",
          "type": "function"
        },
        "index": {
          "description": "Return the vertices in topological order",
          "hierarchy": "Bayes Sampling",
          "module": "Bayes.Sampling",
          "name": "topologicalOrder",
          "normalized": "a b c-\u003e[Vertex]",
          "package": "hbayes",
          "partial": "Order",
          "signature": "g a b-\u003e[Vertex]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-Sampling.html#v:topologicalOrder"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eA comparison of variable elimination and factor elimination on a simple graph.\n\u003c/p\u003e\u003cp\u003eIt is a non regression test.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Bayes.Test.CompareEliminations",
          "name": "CompareEliminations",
          "package": "hbayes",
          "source": "src/Bayes-Test-CompareEliminations.html",
          "type": "module"
        },
        "index": {
          "description": "comparison of variable elimination and factor elimination on simple graph It is non regression test",
          "hierarchy": "Bayes Test CompareEliminations",
          "module": "Bayes.Test.CompareEliminations",
          "name": "CompareEliminations",
          "package": "hbayes",
          "partial": "Compare Eliminations",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-Test-CompareEliminations.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Bayes.Test.CompareEliminations",
          "name": "compareFactorChange",
          "package": "hbayes",
          "signature": "IO ()",
          "source": "src/Bayes-Test-CompareEliminations.html#compareFactorChange",
          "type": "function"
        },
        "index": {
          "hierarchy": "Bayes Test CompareEliminations",
          "module": "Bayes.Test.CompareEliminations",
          "name": "compareFactorChange",
          "normalized": "IO()",
          "package": "hbayes",
          "partial": "Factor Change",
          "signature": "IO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-Test-CompareEliminations.html#v:compareFactorChange"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCompare that variable elemination and factor elimination are giving\n similar results on a simple example\n\u003c/p\u003e",
          "module": "Bayes.Test.CompareEliminations",
          "name": "compareVariableFactor",
          "package": "hbayes",
          "signature": "IO ()",
          "source": "src/Bayes-Test-CompareEliminations.html#compareVariableFactor",
          "type": "function"
        },
        "index": {
          "description": "Compare that variable elemination and factor elimination are giving similar results on simple example",
          "hierarchy": "Bayes Test CompareEliminations",
          "module": "Bayes.Test.CompareEliminations",
          "name": "compareVariableFactor",
          "normalized": "IO()",
          "package": "hbayes",
          "partial": "Variable Factor",
          "signature": "IO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-Test-CompareEliminations.html#v:compareVariableFactor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eA comparison of influence diagram solution with references\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Bayes.Test.InfluencePatterns",
          "name": "InfluencePatterns",
          "package": "hbayes",
          "source": "src/Bayes-Test-InfluencePatterns.html",
          "type": "module"
        },
        "index": {
          "description": "comparison of influence diagram solution with references",
          "hierarchy": "Bayes Test InfluencePatterns",
          "module": "Bayes.Test.InfluencePatterns",
          "name": "InfluencePatterns",
          "package": "hbayes",
          "partial": "Influence Patterns",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-Test-InfluencePatterns.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Bayes.Test.InfluencePatterns",
          "name": "testStudentDecisions",
          "package": "hbayes",
          "signature": "IO ()",
          "source": "src/Bayes-Test-InfluencePatterns.html#testStudentDecisions",
          "type": "function"
        },
        "index": {
          "hierarchy": "Bayes Test InfluencePatterns",
          "module": "Bayes.Test.InfluencePatterns",
          "name": "testStudentDecisions",
          "normalized": "IO()",
          "package": "hbayes",
          "partial": "Student Decisions",
          "signature": "IO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-Test-InfluencePatterns.html#v:testStudentDecisions"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eA comparison of factor elimination with reference values generated with another bayesian network software\n\u003c/p\u003e\u003cp\u003eIt is a non regression test. The test patterns are not provided with this package.\nSo, those tests are disabled by default in the hackage version.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Bayes.Test.ReferencePatterns",
          "name": "ReferencePatterns",
          "package": "hbayes",
          "source": "src/Bayes-Test-ReferencePatterns.html",
          "type": "module"
        },
        "index": {
          "description": "comparison of factor elimination with reference values generated with another bayesian network software It is non regression test The test patterns are not provided with this package So those tests are disabled by default in the hackage version",
          "hierarchy": "Bayes Test ReferencePatterns",
          "module": "Bayes.Test.ReferencePatterns",
          "name": "ReferencePatterns",
          "package": "hbayes",
          "partial": "Reference Patterns",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-Test-ReferencePatterns.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTest that we can import / export the bayesian network, junction tree and variable map\n\u003c/p\u003e",
          "module": "Bayes.Test.ReferencePatterns",
          "name": "testFileExport",
          "package": "hbayes",
          "signature": "IO ()",
          "source": "src/Bayes-Test-ReferencePatterns.html#testFileExport",
          "type": "function"
        },
        "index": {
          "description": "Test that we can import export the bayesian network junction tree and variable map",
          "hierarchy": "Bayes Test ReferencePatterns",
          "module": "Bayes.Test.ReferencePatterns",
          "name": "testFileExport",
          "normalized": "IO()",
          "package": "hbayes",
          "partial": "File Export",
          "signature": "IO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-Test-ReferencePatterns.html#v:testFileExport"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eTesting of the implementation.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Bayes.Test",
          "name": "Test",
          "package": "hbayes",
          "source": "src/Bayes-Test.html",
          "type": "module"
        },
        "index": {
          "description": "Testing of the implementation",
          "hierarchy": "Bayes Test",
          "module": "Bayes.Test",
          "name": "Test",
          "package": "hbayes",
          "partial": "Test",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-Test.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRun all the tests\n\u003c/p\u003e",
          "module": "Bayes.Test",
          "name": "runTests",
          "package": "hbayes",
          "signature": "IO ()",
          "source": "src/Bayes-Test.html#runTests",
          "type": "function"
        },
        "index": {
          "description": "Run all the tests",
          "hierarchy": "Bayes Test",
          "module": "Bayes.Test",
          "name": "runTests",
          "normalized": "IO()",
          "package": "hbayes",
          "partial": "Tests",
          "signature": "IO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-Test.html#v:runTests"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eBucket algorithms for variable elimination with enough flexibility to\nalso work with influence diagrams.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Bayes.VariableElimination.Buckets",
          "name": "Buckets",
          "package": "hbayes",
          "source": "src/Bayes-VariableElimination-Buckets.html",
          "type": "module"
        },
        "index": {
          "description": "Bucket algorithms for variable elimination with enough flexibility to also work with influence diagrams",
          "hierarchy": "Bayes VariableElimination Buckets",
          "module": "Bayes.VariableElimination.Buckets",
          "name": "Buckets",
          "package": "hbayes",
          "partial": "Buckets",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-VariableElimination-Buckets.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUsed for bucket elimination. Factor are organized by their first DV\n\u003c/p\u003e",
          "module": "Bayes.VariableElimination.Buckets",
          "name": "Buckets",
          "package": "hbayes",
          "source": "src/Bayes-VariableElimination-Buckets.html#Buckets",
          "type": "data"
        },
        "index": {
          "description": "Used for bucket elimination Factor are organized by their first DV",
          "hierarchy": "Bayes VariableElimination Buckets",
          "module": "Bayes.VariableElimination.Buckets",
          "name": "Buckets",
          "package": "hbayes",
          "partial": "Buckets",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-VariableElimination-Buckets.html#t:Buckets"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eElimination order\n\u003c/p\u003e",
          "module": "Bayes.VariableElimination.Buckets",
          "name": "EliminationOrder",
          "package": "hbayes",
          "source": "src/Bayes-VariableElimination-Buckets.html#EliminationOrder",
          "type": "type"
        },
        "index": {
          "description": "Elimination order",
          "hierarchy": "Bayes VariableElimination Buckets",
          "module": "Bayes.VariableElimination.Buckets",
          "name": "EliminationOrder",
          "package": "hbayes",
          "partial": "Elimination Order",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-VariableElimination-Buckets.html#t:EliminationOrder"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eOperations needed to process a bucket items\n\u003c/p\u003e",
          "module": "Bayes.VariableElimination.Buckets",
          "name": "IsBucketItem",
          "package": "hbayes",
          "source": "src/Bayes-VariableElimination-Buckets.html#IsBucketItem",
          "type": "class"
        },
        "index": {
          "description": "Operations needed to process bucket items",
          "hierarchy": "Bayes VariableElimination Buckets",
          "module": "Bayes.VariableElimination.Buckets",
          "name": "IsBucketItem",
          "package": "hbayes",
          "partial": "Is Bucket Item",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-VariableElimination-Buckets.html#t:IsBucketItem"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Bayes.VariableElimination.Buckets",
          "name": "Buckets",
          "package": "hbayes",
          "signature": "Buckets !(EliminationOrder DV) !(Map DV [f])",
          "source": "src/Bayes-VariableElimination-Buckets.html#Buckets",
          "type": "function"
        },
        "index": {
          "hierarchy": "Bayes VariableElimination Buckets",
          "module": "Bayes.VariableElimination.Buckets",
          "name": "Buckets",
          "normalized": "Buckets(EliminationOrder DV)(Map DV[a])",
          "package": "hbayes",
          "partial": "Buckets",
          "signature": "Buckets(EliminationOrder DV)(Map DV[f])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-VariableElimination-Buckets.html#v:Buckets"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAdd a factor to the right bucket\n\u003c/p\u003e",
          "module": "Bayes.VariableElimination.Buckets",
          "name": "addBucket",
          "package": "hbayes",
          "signature": "Buckets f -\u003e f -\u003e Buckets f",
          "source": "src/Bayes-VariableElimination-Buckets.html#addBucket",
          "type": "function"
        },
        "index": {
          "description": "Add factor to the right bucket",
          "hierarchy": "Bayes VariableElimination Buckets",
          "module": "Bayes.VariableElimination.Buckets",
          "name": "addBucket",
          "normalized": "Buckets a-\u003ea-\u003eBuckets a",
          "package": "hbayes",
          "partial": "Bucket",
          "signature": "Buckets f-\u003ef-\u003eBuckets f",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-VariableElimination-Buckets.html#v:addBucket"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Bayes.VariableElimination.Buckets",
          "name": "createBuckets",
          "package": "hbayes",
          "signature": "[f]-\u003e EliminationOrder DV-\u003e EliminationOrder DV-\u003e Buckets f",
          "type": "function"
        },
        "index": {
          "hierarchy": "Bayes VariableElimination Buckets",
          "module": "Bayes.VariableElimination.Buckets",
          "name": "createBuckets",
          "normalized": "[a]-\u003eEliminationOrder DV-\u003eEliminationOrder DV-\u003eBuckets a",
          "package": "hbayes",
          "partial": "Buckets",
          "signature": "[f]-\u003eEliminationOrder DV-\u003eEliminationOrder DV-\u003eBuckets f",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-VariableElimination-Buckets.html#v:createBuckets"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGet the factors for a bucket\n\u003c/p\u003e",
          "module": "Bayes.VariableElimination.Buckets",
          "name": "getBucket",
          "package": "hbayes",
          "signature": "DV -\u003e Buckets f -\u003e [f]",
          "source": "src/Bayes-VariableElimination-Buckets.html#getBucket",
          "type": "function"
        },
        "index": {
          "description": "Get the factors for bucket",
          "hierarchy": "Bayes VariableElimination Buckets",
          "module": "Bayes.VariableElimination.Buckets",
          "name": "getBucket",
          "normalized": "DV-\u003eBuckets a-\u003e[a]",
          "package": "hbayes",
          "partial": "Bucket",
          "signature": "DV-\u003eBuckets f-\u003e[f]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-VariableElimination-Buckets.html#v:getBucket"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Bayes.VariableElimination.Buckets",
          "name": "itemContainsVariable",
          "package": "hbayes",
          "signature": "f -\u003e DV -\u003e Bool",
          "source": "src/Bayes-VariableElimination-Buckets.html#itemContainsVariable",
          "type": "method"
        },
        "index": {
          "hierarchy": "Bayes VariableElimination Buckets",
          "module": "Bayes.VariableElimination.Buckets",
          "name": "itemContainsVariable",
          "normalized": "a-\u003eDV-\u003eBool",
          "package": "hbayes",
          "partial": "Contains Variable",
          "signature": "f-\u003eDV-\u003eBool",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-VariableElimination-Buckets.html#v:itemContainsVariable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Bayes.VariableElimination.Buckets",
          "name": "itemProduct",
          "package": "hbayes",
          "signature": "[f] -\u003e f",
          "source": "src/Bayes-VariableElimination-Buckets.html#itemProduct",
          "type": "method"
        },
        "index": {
          "hierarchy": "Bayes VariableElimination Buckets",
          "module": "Bayes.VariableElimination.Buckets",
          "name": "itemProduct",
          "normalized": "[a]-\u003ea",
          "package": "hbayes",
          "partial": "Product",
          "signature": "[f]-\u003ef",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-VariableElimination-Buckets.html#v:itemProduct"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Bayes.VariableElimination.Buckets",
          "name": "itemProjectOut",
          "package": "hbayes",
          "signature": "DV -\u003e f -\u003e f",
          "source": "src/Bayes-VariableElimination-Buckets.html#itemProjectOut",
          "type": "method"
        },
        "index": {
          "hierarchy": "Bayes VariableElimination Buckets",
          "module": "Bayes.VariableElimination.Buckets",
          "name": "itemProjectOut",
          "normalized": "DV-\u003ea-\u003ea",
          "package": "hbayes",
          "partial": "Project Out",
          "signature": "DV-\u003ef-\u003ef",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-VariableElimination-Buckets.html#v:itemProjectOut"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Bayes.VariableElimination.Buckets",
          "name": "marginalizeOneVariable",
          "package": "hbayes",
          "signature": "Buckets f -\u003e DV -\u003e Buckets f",
          "source": "src/Bayes-VariableElimination-Buckets.html#marginalizeOneVariable",
          "type": "function"
        },
        "index": {
          "hierarchy": "Bayes VariableElimination Buckets",
          "module": "Bayes.VariableElimination.Buckets",
          "name": "marginalizeOneVariable",
          "normalized": "Buckets a-\u003eDV-\u003eBuckets a",
          "package": "hbayes",
          "partial": "One Variable",
          "signature": "Buckets f-\u003eDV-\u003eBuckets f",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-VariableElimination-Buckets.html#v:marginalizeOneVariable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRemove a variable from the bucket\n\u003c/p\u003e",
          "module": "Bayes.VariableElimination.Buckets",
          "name": "removeFromBucket",
          "package": "hbayes",
          "signature": "DV -\u003e Buckets f -\u003e Buckets f",
          "source": "src/Bayes-VariableElimination-Buckets.html#removeFromBucket",
          "type": "function"
        },
        "index": {
          "description": "Remove variable from the bucket",
          "hierarchy": "Bayes VariableElimination Buckets",
          "module": "Bayes.VariableElimination.Buckets",
          "name": "removeFromBucket",
          "normalized": "DV-\u003eBuckets a-\u003eBuckets a",
          "package": "hbayes",
          "partial": "From Bucket",
          "signature": "DV-\u003eBuckets f-\u003eBuckets f",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-VariableElimination-Buckets.html#v:removeFromBucket"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Bayes.VariableElimination.Buckets",
          "name": "scalarItem",
          "package": "hbayes",
          "signature": "f -\u003e Bool",
          "source": "src/Bayes-VariableElimination-Buckets.html#scalarItem",
          "type": "method"
        },
        "index": {
          "hierarchy": "Bayes VariableElimination Buckets",
          "module": "Bayes.VariableElimination.Buckets",
          "name": "scalarItem",
          "normalized": "a-\u003eBool",
          "package": "hbayes",
          "partial": "Item",
          "signature": "f-\u003eBool",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-VariableElimination-Buckets.html#v:scalarItem"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUpdate bucket\n\u003c/p\u003e",
          "module": "Bayes.VariableElimination.Buckets",
          "name": "updateBucket",
          "package": "hbayes",
          "signature": "DV-\u003e f-\u003e Buckets f-\u003e Buckets f",
          "type": "function"
        },
        "index": {
          "description": "Update bucket",
          "hierarchy": "Bayes VariableElimination Buckets",
          "module": "Bayes.VariableElimination.Buckets",
          "name": "updateBucket",
          "normalized": "DV-\u003ea-\u003eBuckets a-\u003eBuckets a",
          "package": "hbayes",
          "partial": "Bucket",
          "signature": "DV-\u003ef-\u003eBuckets f-\u003eBuckets f",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-VariableElimination-Buckets.html#v:updateBucket"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eAlgorithms for variable elimination\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Bayes.VariableElimination",
          "name": "VariableElimination",
          "package": "hbayes",
          "source": "src/Bayes-VariableElimination.html",
          "type": "module"
        },
        "index": {
          "description": "Algorithms for variable elimination",
          "hierarchy": "Bayes VariableElimination",
          "module": "Bayes.VariableElimination",
          "name": "VariableElimination",
          "package": "hbayes",
          "partial": "Variable Elimination",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-VariableElimination.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eElimination order\n\u003c/p\u003e",
          "module": "Bayes.VariableElimination",
          "name": "EliminationOrder",
          "package": "hbayes",
          "source": "src/Bayes-VariableElimination-Buckets.html#EliminationOrder",
          "type": "type"
        },
        "index": {
          "description": "Elimination order",
          "hierarchy": "Bayes VariableElimination",
          "module": "Bayes.VariableElimination",
          "name": "EliminationOrder",
          "package": "hbayes",
          "partial": "Elimination Order",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-VariableElimination.html#t:EliminationOrder"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGet all variables from a Bayesian Network\n\u003c/p\u003e",
          "module": "Bayes.VariableElimination",
          "name": "allVariables",
          "package": "hbayes",
          "signature": "BayesianNetwork g f -\u003e [DV]",
          "source": "src/Bayes-VariableElimination.html#allVariables",
          "type": "function"
        },
        "index": {
          "description": "Get all variables from Bayesian Network",
          "hierarchy": "Bayes VariableElimination",
          "module": "Bayes.VariableElimination",
          "name": "allVariables",
          "normalized": "BayesianNetwork a b-\u003e[DV]",
          "package": "hbayes",
          "partial": "Variables",
          "signature": "BayesianNetwork g f-\u003e[DV]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-VariableElimination.html#v:allVariables"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCompute the degree order of an elimination order\n\u003c/p\u003e",
          "module": "Bayes.VariableElimination",
          "name": "degreeOrder",
          "package": "hbayes",
          "signature": "BayesianNetwork g f -\u003e EliminationOrder DV -\u003e Int",
          "source": "src/Bayes-VariableElimination.html#degreeOrder",
          "type": "function"
        },
        "index": {
          "description": "Compute the degree order of an elimination order",
          "hierarchy": "Bayes VariableElimination",
          "module": "Bayes.VariableElimination",
          "name": "degreeOrder",
          "normalized": "BayesianNetwork a b-\u003eEliminationOrder DV-\u003eInt",
          "package": "hbayes",
          "partial": "Order",
          "signature": "BayesianNetwork g f-\u003eEliminationOrder DV-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-VariableElimination.html#v:degreeOrder"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCompute the interaction graph of the BayesianNetwork\n\u003c/p\u003e",
          "module": "Bayes.VariableElimination",
          "name": "interactionGraph",
          "package": "hbayes",
          "signature": "BayesianNetwork g f -\u003e g' () DV",
          "source": "src/Bayes-VariableElimination.html#interactionGraph",
          "type": "function"
        },
        "index": {
          "description": "Compute the interaction graph of the BayesianNetwork",
          "hierarchy": "Bayes VariableElimination",
          "module": "Bayes.VariableElimination",
          "name": "interactionGraph",
          "normalized": "BayesianNetwork a b-\u003ec()DV",
          "package": "hbayes",
          "partial": "Graph",
          "signature": "BayesianNetwork g f-\u003eg'()DV",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-VariableElimination.html#v:interactionGraph"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCompute the prior marginal. All the variables in the\n elimination order are conditionning variables ( p( . | conditionning variables) )\n\u003c/p\u003e",
          "module": "Bayes.VariableElimination",
          "name": "marginal",
          "package": "hbayes",
          "signature": "[f]-\u003e EliminationOrder DV-\u003e EliminationOrder DV-\u003e [DVI]-\u003e f",
          "type": "function"
        },
        "index": {
          "description": "Compute the prior marginal All the variables in the elimination order are conditionning variables conditionning variables",
          "hierarchy": "Bayes VariableElimination",
          "module": "Bayes.VariableElimination",
          "name": "marginal",
          "normalized": "[a]-\u003eEliminationOrder DV-\u003eEliminationOrder DV-\u003e[DVI]-\u003ea",
          "package": "hbayes",
          "signature": "[f]-\u003eEliminationOrder DV-\u003eEliminationOrder DV-\u003e[DVI]-\u003ef",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-VariableElimination.html#v:marginal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eElimination order minimizing the degree\n\u003c/p\u003e",
          "module": "Bayes.VariableElimination",
          "name": "minDegreeOrder",
          "package": "hbayes",
          "signature": "BayesianNetwork g f -\u003e EliminationOrder DV",
          "source": "src/Bayes-VariableElimination.html#minDegreeOrder",
          "type": "function"
        },
        "index": {
          "description": "Elimination order minimizing the degree",
          "hierarchy": "Bayes VariableElimination",
          "module": "Bayes.VariableElimination",
          "name": "minDegreeOrder",
          "normalized": "BayesianNetwork a b-\u003eEliminationOrder DV",
          "package": "hbayes",
          "partial": "Degree Order",
          "signature": "BayesianNetwork g f-\u003eEliminationOrder DV",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-VariableElimination.html#v:minDegreeOrder"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eElimination order minimizing the filling\n\u003c/p\u003e",
          "module": "Bayes.VariableElimination",
          "name": "minFillOrder",
          "package": "hbayes",
          "signature": "BayesianNetwork g f -\u003e EliminationOrder DV",
          "source": "src/Bayes-VariableElimination.html#minFillOrder",
          "type": "function"
        },
        "index": {
          "description": "Elimination order minimizing the filling",
          "hierarchy": "Bayes VariableElimination",
          "module": "Bayes.VariableElimination",
          "name": "minFillOrder",
          "normalized": "BayesianNetwork a b-\u003eEliminationOrder DV",
          "package": "hbayes",
          "partial": "Fill Order",
          "signature": "BayesianNetwork g f-\u003eEliminationOrder DV",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-VariableElimination.html#v:minFillOrder"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMost Probable Explanation (or Maximum A Posteriori estimator)\n when restricted to a subest of variables in output\n\u003c/p\u003e",
          "module": "Bayes.VariableElimination",
          "name": "mpe",
          "package": "hbayes",
          "signature": "BayesianNetwork g CPT-\u003e EliminationOrder dva-\u003e EliminationOrder dvb-\u003e [DVI]-\u003e [DVISet]",
          "type": "function"
        },
        "index": {
          "description": "Most Probable Explanation or Maximum Posteriori estimator when restricted to subest of variables in output",
          "hierarchy": "Bayes VariableElimination",
          "module": "Bayes.VariableElimination",
          "name": "mpe",
          "normalized": "BayesianNetwork a CPT-\u003eEliminationOrder b-\u003eEliminationOrder c-\u003e[DVI]-\u003e[DVISet]",
          "package": "hbayes",
          "signature": "BayesianNetwork g CPT-\u003eEliminationOrder dva-\u003eEliminationOrder dvb-\u003e[DVI]-\u003e[DVISet]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-VariableElimination.html#v:mpe"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCompute the prior marginal. All the variables in the\n elimination order are conditionning variables ( p( . | conditionning variables) )\n First we sum, then we maximize for the remaining variables\n\u003c/p\u003e",
          "module": "Bayes.VariableElimination",
          "name": "mpemarginal",
          "package": "hbayes",
          "signature": "[CPT]-\u003e EliminationOrder DV-\u003e EliminationOrder DV-\u003e [DVI]-\u003e MAXCPT",
          "type": "function"
        },
        "index": {
          "description": "Compute the prior marginal All the variables in the elimination order are conditionning variables conditionning variables First we sum then we maximize for the remaining variables",
          "hierarchy": "Bayes VariableElimination",
          "module": "Bayes.VariableElimination",
          "name": "mpemarginal",
          "normalized": "[CPT]-\u003eEliminationOrder DV-\u003eEliminationOrder DV-\u003e[DVI]-\u003eMAXCPT",
          "package": "hbayes",
          "signature": "[CPT]-\u003eEliminationOrder DV-\u003eEliminationOrder DV-\u003e[DVI]-\u003eMAXCPT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-VariableElimination.html#v:mpemarginal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Bayes.VariableElimination",
          "name": "posteriorMarginal",
          "package": "hbayes",
          "signature": "BayesianNetwork g f-\u003e EliminationOrder dva-\u003e EliminationOrder dvb-\u003e [DVI]-\u003e f",
          "type": "function"
        },
        "index": {
          "hierarchy": "Bayes VariableElimination",
          "module": "Bayes.VariableElimination",
          "name": "posteriorMarginal",
          "normalized": "BayesianNetwork a b-\u003eEliminationOrder c-\u003eEliminationOrder d-\u003e[DVI]-\u003eb",
          "package": "hbayes",
          "partial": "Marginal",
          "signature": "BayesianNetwork g f-\u003eEliminationOrder dva-\u003eEliminationOrder dvb-\u003e[DVI]-\u003ef",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-VariableElimination.html#v:posteriorMarginal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCompute the prior marginal. All the variables in the\n elimination order are conditionning variables ( p( . | conditionning variables) )\n\u003c/p\u003e",
          "module": "Bayes.VariableElimination",
          "name": "priorMarginal",
          "package": "hbayes",
          "signature": "BayesianNetwork g f-\u003e EliminationOrder dva-\u003e EliminationOrder dvb-\u003e f",
          "type": "function"
        },
        "index": {
          "description": "Compute the prior marginal All the variables in the elimination order are conditionning variables conditionning variables",
          "hierarchy": "Bayes VariableElimination",
          "module": "Bayes.VariableElimination",
          "name": "priorMarginal",
          "normalized": "BayesianNetwork a b-\u003eEliminationOrder c-\u003eEliminationOrder d-\u003eb",
          "package": "hbayes",
          "partial": "Marginal",
          "signature": "BayesianNetwork g f-\u003eEliminationOrder dva-\u003eEliminationOrder dvb-\u003ef",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes-VariableElimination.html#v:priorMarginal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eBayesian Network Library.\n\u003c/p\u003e\u003cp\u003eIt is a very preliminary version. It has only been tested on very simple\nexamples where it worked. It should be considered as experimental and not used\nin any production work.\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e Look at the \u003ca\u003eBayes.Examples\u003c/a\u003e and \u003ca\u003eBayes.Examples.Tutorial\u003c/a\u003e in this package \nto see how to use the library.\n\u003c/li\u003e\u003cli\u003e In \u003ca\u003eBayes.Examples.Influence\u003c/a\u003e you'll find additional examples about influence diagrams.\n\u003c/li\u003e\u003cli\u003e In \u003ca\u003eBayes.Examples.Sampling\u003c/a\u003e there are some explanations about the samplers for discrete networks.\n\u003c/li\u003e\u003cli\u003e \u003ca\u003eBayes.Examples.EMTest\u003c/a\u003e is explaining learning with expectation / maximization.\n\u003c/li\u003e\u003cli\u003e \u003ca\u003eBayes.Examples.ContinuousSampling\u003c/a\u003e is showing an example of sampling with a continuous network.\n\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e",
          "module": "Bayes",
          "name": "Bayes",
          "package": "hbayes",
          "source": "src/Bayes.html",
          "type": "module"
        },
        "index": {
          "description": "Bayesian Network Library It is very preliminary version It has only been tested on very simple examples where it worked It should be considered as experimental and not used in any production work Look at the Bayes.Examples and Bayes.Examples.Tutorial in this package to see how to use the library In Bayes.Examples.Influence you ll find additional examples about influence diagrams In Bayes.Examples.Sampling there are some explanations about the samplers for discrete networks Bayes.Examples.EMTest is explaining learning with expectation maximization Bayes.Examples.ContinuousSampling is showing an example of sampling with continuous network",
          "hierarchy": "Bayes",
          "module": "Bayes",
          "name": "Bayes",
          "package": "hbayes",
          "partial": "Bayes",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eBayesian network. g must be a directed graph and f a factor\n\u003c/p\u003e",
          "module": "Bayes",
          "name": "BayesianNetwork",
          "package": "hbayes",
          "source": "src/Bayes-PrivateTypes.html#BayesianNetwork",
          "type": "type"
        },
        "index": {
          "description": "Bayesian network must be directed graph and factor",
          "hierarchy": "Bayes",
          "module": "Bayes",
          "name": "BayesianNetwork",
          "package": "hbayes",
          "partial": "Bayesian Network",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes.html#t:BayesianNetwork"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDirected graph\n\u003c/p\u003e",
          "module": "Bayes",
          "name": "DirectedGraph",
          "package": "hbayes",
          "source": "src/Bayes.html#DirectedGraph",
          "type": "class"
        },
        "index": {
          "description": "Directed graph",
          "hierarchy": "Bayes",
          "module": "Bayes",
          "name": "DirectedGraph",
          "package": "hbayes",
          "partial": "Directed Graph",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes.html#t:DirectedGraph"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDirected simple graph\n\u003c/p\u003e",
          "module": "Bayes",
          "name": "DirectedSG",
          "package": "hbayes",
          "source": "src/Bayes.html#DirectedSG",
          "type": "type"
        },
        "index": {
          "description": "Directed simple graph",
          "hierarchy": "Bayes",
          "module": "Bayes",
          "name": "DirectedSG",
          "package": "hbayes",
          "partial": "Directed SG",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes.html#t:DirectedSG"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEdge type used to identify and edge in a graph\n\u003c/p\u003e",
          "module": "Bayes",
          "name": "Edge",
          "package": "hbayes",
          "source": "src/Bayes-PrivateTypes.html#Edge",
          "type": "data"
        },
        "index": {
          "description": "Edge type used to identify and edge in graph",
          "hierarchy": "Bayes",
          "module": "Bayes",
          "name": "Edge",
          "package": "hbayes",
          "partial": "Edge",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes.html#t:Edge"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe foldable class is limited. For a graph g we may need the vertex in addition to the value\n\u003c/p\u003e",
          "module": "Bayes",
          "name": "FoldableWithVertex",
          "package": "hbayes",
          "source": "src/Bayes.html#FoldableWithVertex",
          "type": "class"
        },
        "index": {
          "description": "The foldable class is limited For graph we may need the vertex in addition to the value",
          "hierarchy": "Bayes",
          "module": "Bayes",
          "name": "FoldableWithVertex",
          "package": "hbayes",
          "partial": "Foldable With Vertex",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes.html#t:FoldableWithVertex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Bayes",
          "name": "FunctorWithVertex",
          "package": "hbayes",
          "source": "src/Bayes.html#FunctorWithVertex",
          "type": "class"
        },
        "index": {
          "hierarchy": "Bayes",
          "module": "Bayes",
          "name": "FunctorWithVertex",
          "package": "hbayes",
          "partial": "Functor With Vertex",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes.html#t:FunctorWithVertex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe state of the graph monad : the graph and auxiliary data\n useful during the construction\n\u003c/p\u003e",
          "module": "Bayes",
          "name": "GMState",
          "package": "hbayes",
          "source": "src/Bayes.html#GMState",
          "type": "type"
        },
        "index": {
          "description": "The state of the graph monad the graph and auxiliary data useful during the construction",
          "hierarchy": "Bayes",
          "module": "Bayes",
          "name": "GMState",
          "package": "hbayes",
          "partial": "GMState",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes.html#t:GMState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGraph class used for graph processing algorithms.\n A graph processing algorithm does not have to know how the graph is implemented nor if it is\n directed or undirected\n\u003c/p\u003e",
          "module": "Bayes",
          "name": "Graph",
          "package": "hbayes",
          "source": "src/Bayes.html#Graph",
          "type": "class"
        },
        "index": {
          "description": "Graph class used for graph processing algorithms graph processing algorithm does not have to know how the graph is implemented nor if it is directed or undirected",
          "hierarchy": "Bayes",
          "module": "Bayes",
          "name": "Graph",
          "package": "hbayes",
          "partial": "Graph",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes.html#t:Graph"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGraph monad.\n The monad used to simplify the description of a new graph\n g is the graph type. e the edge type. f the node type (generally a \u003ccode\u003e\u003ca\u003eFactor\u003c/a\u003e\u003c/code\u003e)\n\u003c/p\u003e",
          "module": "Bayes",
          "name": "GraphMonad",
          "package": "hbayes",
          "source": "src/Bayes.html#GraphMonad",
          "type": "data"
        },
        "index": {
          "description": "Graph monad The monad used to simplify the description of new graph is the graph type the edge type the node type generally Factor",
          "hierarchy": "Bayes",
          "module": "Bayes",
          "name": "GraphMonad",
          "package": "hbayes",
          "partial": "Graph Monad",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes.html#t:GraphMonad"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA named graph is a graph where the vertices have a name.\n This name is not a vertex value. Putting this name in the vertex value\n would make algorithm less readable.\n A vertex name is only useful to display the graph.\n Labeled graph has a different meaning in graph theory.\n\u003c/p\u003e",
          "module": "Bayes",
          "name": "NamedGraph",
          "package": "hbayes",
          "source": "src/Bayes.html#NamedGraph",
          "type": "class"
        },
        "index": {
          "description": "named graph is graph where the vertices have name This name is not vertex value Putting this name in the vertex value would make algorithm less readable vertex name is only useful to display the graph Labeled graph has different meaning in graph theory",
          "hierarchy": "Bayes",
          "module": "Bayes",
          "name": "NamedGraph",
          "package": "hbayes",
          "partial": "Named Graph",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes.html#t:NamedGraph"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn implementation of the BayesianNetwork using the simple graph and no value for the edges\n\u003c/p\u003e",
          "module": "Bayes",
          "name": "SBN",
          "package": "hbayes",
          "source": "src/Bayes.html#SBN",
          "type": "type"
        },
        "index": {
          "description": "An implementation of the BayesianNetwork using the simple graph and no value for the edges",
          "hierarchy": "Bayes",
          "module": "Bayes",
          "name": "SBN",
          "package": "hbayes",
          "partial": "SBN",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes.html#t:SBN"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUndirected graph\n\u003c/p\u003e",
          "module": "Bayes",
          "name": "UndirectedGraph",
          "package": "hbayes",
          "source": "src/Bayes.html#UndirectedGraph",
          "type": "class"
        },
        "index": {
          "description": "Undirected graph",
          "hierarchy": "Bayes",
          "module": "Bayes",
          "name": "UndirectedGraph",
          "package": "hbayes",
          "partial": "Undirected Graph",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes.html#t:UndirectedGraph"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUndirected simple graph\n\u003c/p\u003e",
          "module": "Bayes",
          "name": "UndirectedSG",
          "package": "hbayes",
          "source": "src/Bayes.html#UndirectedSG",
          "type": "type"
        },
        "index": {
          "description": "Undirected simple graph",
          "hierarchy": "Bayes",
          "module": "Bayes",
          "name": "UndirectedSG",
          "package": "hbayes",
          "partial": "Undirected SG",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes.html#t:UndirectedSG"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eVertex type used to identify a vertex in a graph\n\u003c/p\u003e",
          "module": "Bayes",
          "name": "Vertex",
          "package": "hbayes",
          "source": "src/Bayes-PrivateTypes.html#Vertex",
          "type": "data"
        },
        "index": {
          "description": "Vertex type used to identify vertex in graph",
          "hierarchy": "Bayes",
          "module": "Bayes",
          "name": "Vertex",
          "package": "hbayes",
          "partial": "Vertex",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes.html#t:Vertex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAdd an edge\n\u003c/p\u003e",
          "module": "Bayes",
          "name": "addEdge",
          "package": "hbayes",
          "signature": "Edge -\u003e a -\u003e g a b -\u003e g a b",
          "source": "src/Bayes.html#addEdge",
          "type": "method"
        },
        "index": {
          "description": "Add an edge",
          "hierarchy": "Bayes",
          "module": "Bayes",
          "name": "addEdge",
          "normalized": "Edge-\u003ea-\u003eb a c-\u003eb a c",
          "package": "hbayes",
          "partial": "Edge",
          "signature": "Edge-\u003ea-\u003eg a b-\u003eg a b",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes.html#v:addEdge"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAdd a vertex with a vertex name in addition to the value\n\u003c/p\u003e",
          "module": "Bayes",
          "name": "addLabeledVertex",
          "package": "hbayes",
          "signature": "String -\u003e Vertex -\u003e b -\u003e g a b -\u003e g a b",
          "source": "src/Bayes.html#addLabeledVertex",
          "type": "method"
        },
        "index": {
          "description": "Add vertex with vertex name in addition to the value",
          "hierarchy": "Bayes",
          "module": "Bayes",
          "name": "addLabeledVertex",
          "normalized": "String-\u003eVertex-\u003ea-\u003eb c a-\u003eb c a",
          "package": "hbayes",
          "partial": "Labeled Vertex",
          "signature": "String-\u003eVertex-\u003eb-\u003eg a b-\u003eg a b",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes.html#v:addLabeledVertex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAdd a new vertex\n\u003c/p\u003e",
          "module": "Bayes",
          "name": "addVertex",
          "package": "hbayes",
          "signature": "Vertex -\u003e b -\u003e g a b -\u003e g a b",
          "source": "src/Bayes.html#addVertex",
          "type": "method"
        },
        "index": {
          "description": "Add new vertex",
          "hierarchy": "Bayes",
          "module": "Bayes",
          "name": "addVertex",
          "normalized": "Vertex-\u003ea-\u003eb c a-\u003eb c a",
          "package": "hbayes",
          "partial": "Vertex",
          "signature": "Vertex-\u003eb-\u003eg a b-\u003eg a b",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes.html#v:addVertex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAll values of the graph\n\u003c/p\u003e",
          "module": "Bayes",
          "name": "allEdgeValues",
          "package": "hbayes",
          "signature": "g a b -\u003e [a]",
          "source": "src/Bayes.html#allEdgeValues",
          "type": "method"
        },
        "index": {
          "description": "All values of the graph",
          "hierarchy": "Bayes",
          "module": "Bayes",
          "name": "allEdgeValues",
          "normalized": "a b c-\u003e[b]",
          "package": "hbayes",
          "partial": "Edge Values",
          "signature": "g a b-\u003e[a]",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes.html#v:allEdgeValues"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAll edges of the graph\n\u003c/p\u003e",
          "module": "Bayes",
          "name": "allEdges",
          "package": "hbayes",
          "signature": "g a b -\u003e [Edge]",
          "source": "src/Bayes.html#allEdges",
          "type": "method"
        },
        "index": {
          "description": "All edges of the graph",
          "hierarchy": "Bayes",
          "module": "Bayes",
          "name": "allEdges",
          "normalized": "a b c-\u003e[Edge]",
          "package": "hbayes",
          "partial": "Edges",
          "signature": "g a b-\u003e[Edge]",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes.html#v:allEdges"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGet all nodes\n\u003c/p\u003e",
          "module": "Bayes",
          "name": "allNodes",
          "package": "hbayes",
          "signature": "g a b -\u003e [(Vertex, b)]",
          "source": "src/Bayes.html#allNodes",
          "type": "method"
        },
        "index": {
          "description": "Get all nodes",
          "hierarchy": "Bayes",
          "module": "Bayes",
          "name": "allNodes",
          "normalized": "a b c-\u003e[(Vertex,c)]",
          "package": "hbayes",
          "partial": "Nodes",
          "signature": "g a b-\u003e[(Vertex,b)]",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes.html#v:allNodes"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGet all the values\n\u003c/p\u003e",
          "module": "Bayes",
          "name": "allVertexValues",
          "package": "hbayes",
          "signature": "g a b -\u003e [b]",
          "source": "src/Bayes.html#allVertexValues",
          "type": "method"
        },
        "index": {
          "description": "Get all the values",
          "hierarchy": "Bayes",
          "module": "Bayes",
          "name": "allVertexValues",
          "normalized": "a b c-\u003e[c]",
          "package": "hbayes",
          "partial": "Vertex Values",
          "signature": "g a b-\u003e[b]",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes.html#v:allVertexValues"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGenerate all vertices\n\u003c/p\u003e",
          "module": "Bayes",
          "name": "allVertices",
          "package": "hbayes",
          "signature": "g a b -\u003e [Vertex]",
          "source": "src/Bayes.html#allVertices",
          "type": "method"
        },
        "index": {
          "description": "Generate all vertices",
          "hierarchy": "Bayes",
          "module": "Bayes",
          "name": "allVertices",
          "normalized": "a b c-\u003e[Vertex]",
          "package": "hbayes",
          "partial": "Vertices",
          "signature": "g a b-\u003e[Vertex]",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes.html#v:allVertices"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eChange the vertex value if the vertex is found in the graph\n\u003c/p\u003e",
          "module": "Bayes",
          "name": "changeVertexValue",
          "package": "hbayes",
          "signature": "Vertex -\u003e b -\u003e g a b -\u003e Maybe (g a b)",
          "source": "src/Bayes.html#changeVertexValue",
          "type": "method"
        },
        "index": {
          "description": "Change the vertex value if the vertex is found in the graph",
          "hierarchy": "Bayes",
          "module": "Bayes",
          "name": "changeVertexValue",
          "normalized": "Vertex-\u003ea-\u003eb c a-\u003eMaybe(b c a)",
          "package": "hbayes",
          "partial": "Vertex Value",
          "signature": "Vertex-\u003eb-\u003eg a b-\u003eMaybe(g a b)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes.html#v:changeVertexValue"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn the children of a node\n\u003c/p\u003e",
          "module": "Bayes",
          "name": "childrenNodes",
          "package": "hbayes",
          "signature": "g a b -\u003e Vertex -\u003e [Vertex]",
          "source": "src/Bayes.html#childrenNodes",
          "type": "function"
        },
        "index": {
          "description": "Return the children of node",
          "hierarchy": "Bayes",
          "module": "Bayes",
          "name": "childrenNodes",
          "normalized": "a b c-\u003eVertex-\u003e[Vertex]",
          "package": "hbayes",
          "partial": "Nodes",
          "signature": "g a b-\u003eVertex-\u003e[Vertex]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes.html#v:childrenNodes"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCheck if the graph is connected\n\u003c/p\u003e",
          "module": "Bayes",
          "name": "connectedGraph",
          "package": "hbayes",
          "signature": "g a b -\u003e Bool",
          "source": "src/Bayes.html#connectedGraph",
          "type": "function"
        },
        "index": {
          "description": "Check if the graph is connected",
          "hierarchy": "Bayes",
          "module": "Bayes",
          "name": "connectedGraph",
          "normalized": "a b c-\u003eBool",
          "package": "hbayes",
          "partial": "Graph",
          "signature": "g a b-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes.html#v:connectedGraph"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCheck if the graph is a directed Acyclic graph\n\u003c/p\u003e",
          "module": "Bayes",
          "name": "dag",
          "package": "hbayes",
          "signature": "g a b -\u003e Bool",
          "source": "src/Bayes.html#dag",
          "type": "function"
        },
        "index": {
          "description": "Check if the graph is directed Acyclic graph",
          "hierarchy": "Bayes",
          "module": "Bayes",
          "name": "dag",
          "normalized": "a b c-\u003eBool",
          "package": "hbayes",
          "signature": "g a b-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes.html#v:dag"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Bayes",
          "name": "displaySimpleGraph",
          "package": "hbayes",
          "signature": "(Vertex -\u003e n -\u003e Maybe String) -\u003e (Vertex -\u003e n -\u003e Maybe String) -\u003e (Edge -\u003e e -\u003e Maybe String) -\u003e (Edge -\u003e e -\u003e Maybe String) -\u003e SimpleGraph local e n -\u003e String",
          "source": "src/Bayes.html#displaySimpleGraph",
          "type": "function"
        },
        "index": {
          "hierarchy": "Bayes",
          "module": "Bayes",
          "name": "displaySimpleGraph",
          "normalized": "(Vertex-\u003ea-\u003eMaybe String)-\u003e(Vertex-\u003ea-\u003eMaybe String)-\u003e(Edge-\u003eb-\u003eMaybe String)-\u003e(Edge-\u003eb-\u003eMaybe String)-\u003eSimpleGraph c b a-\u003eString",
          "package": "hbayes",
          "partial": "Simple Graph",
          "signature": "(Vertex-\u003en-\u003eMaybe String)-\u003e(Vertex-\u003en-\u003eMaybe String)-\u003e(Edge-\u003ee-\u003eMaybe String)-\u003e(Edge-\u003ee-\u003eMaybe String)-\u003eSimpleGraph local e n-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes.html#v:displaySimpleGraph"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreate an edge description\n\u003c/p\u003e",
          "module": "Bayes",
          "name": "edge",
          "package": "hbayes",
          "signature": "Vertex -\u003e Vertex -\u003e Edge",
          "source": "src/Bayes.html#edge",
          "type": "function"
        },
        "index": {
          "description": "Create an edge description",
          "hierarchy": "Bayes",
          "module": "Bayes",
          "name": "edge",
          "normalized": "Vertex-\u003eVertex-\u003eEdge",
          "package": "hbayes",
          "signature": "Vertex-\u003eVertex-\u003eEdge",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes.html#v:edge"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEndpoints of an edge\n\u003c/p\u003e",
          "module": "Bayes",
          "name": "edgeEndPoints",
          "package": "hbayes",
          "signature": "Edge -\u003e (Vertex, Vertex)",
          "source": "src/Bayes.html#edgeEndPoints",
          "type": "function"
        },
        "index": {
          "description": "Endpoints of an edge",
          "hierarchy": "Bayes",
          "module": "Bayes",
          "name": "edgeEndPoints",
          "normalized": "Edge-\u003e(Vertex,Vertex)",
          "package": "hbayes",
          "partial": "End Points",
          "signature": "Edge-\u003e(Vertex,Vertex)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes.html#v:edgeEndPoints"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEdge value if the edge is found in the graph\n\u003c/p\u003e",
          "module": "Bayes",
          "name": "edgeValue",
          "package": "hbayes",
          "signature": "g a b -\u003e Edge -\u003e Maybe a",
          "source": "src/Bayes.html#edgeValue",
          "type": "method"
        },
        "index": {
          "description": "Edge value if the edge is found in the graph",
          "hierarchy": "Bayes",
          "module": "Bayes",
          "name": "edgeValue",
          "normalized": "a b c-\u003eEdge-\u003eMaybe b",
          "package": "hbayes",
          "partial": "Value",
          "signature": "g a b-\u003eEdge-\u003eMaybe a",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes.html#v:edgeValue"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eVertices for an edge\n\u003c/p\u003e",
          "module": "Bayes",
          "name": "edgeVertices",
          "package": "hbayes",
          "signature": "g a b -\u003e Edge -\u003e Maybe (Vertex, Vertex)",
          "source": "src/Bayes.html#edgeVertices",
          "type": "method"
        },
        "index": {
          "description": "Vertices for an edge",
          "hierarchy": "Bayes",
          "module": "Bayes",
          "name": "edgeVertices",
          "normalized": "a b c-\u003eEdge-\u003eMaybe(Vertex,Vertex)",
          "package": "hbayes",
          "partial": "Vertices",
          "signature": "g a b-\u003eEdge-\u003eMaybe(Vertex,Vertex)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes.html#v:edgeVertices"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Bayes",
          "name": "edges",
          "package": "hbayes",
          "signature": "g a b -\u003e Vertex -\u003e Maybe [Edge]",
          "source": "src/Bayes.html#edges",
          "type": "method"
        },
        "index": {
          "hierarchy": "Bayes",
          "module": "Bayes",
          "name": "edges",
          "normalized": "a b c-\u003eVertex-\u003eMaybe[Edge]",
          "package": "hbayes",
          "signature": "g a b-\u003eVertex-\u003eMaybe[Edge]",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes.html#v:edges"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Bayes",
          "name": "emptyAuxiliaryState",
          "package": "hbayes",
          "signature": "(Map k a, Int)",
          "source": "src/Bayes.html#emptyAuxiliaryState",
          "type": "function"
        },
        "index": {
          "hierarchy": "Bayes",
          "module": "Bayes",
          "name": "emptyAuxiliaryState",
          "normalized": "(Map a b,Int)",
          "package": "hbayes",
          "partial": "Auxiliary State",
          "signature": "(Map k a,Int)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes.html#v:emptyAuxiliaryState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturns an empty graph\n\u003c/p\u003e",
          "module": "Bayes",
          "name": "emptyGraph",
          "package": "hbayes",
          "signature": "g a b",
          "source": "src/Bayes.html#emptyGraph",
          "type": "method"
        },
        "index": {
          "description": "Returns an empty graph",
          "hierarchy": "Bayes",
          "module": "Bayes",
          "name": "emptyGraph",
          "package": "hbayes",
          "partial": "Graph",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes.html#v:emptyGraph"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eOne extremity of the edge (which is the end only for directed edge)\n\u003c/p\u003e",
          "module": "Bayes",
          "name": "endVertex",
          "package": "hbayes",
          "signature": "g a b -\u003e Edge -\u003e Maybe Vertex",
          "source": "src/Bayes.html#endVertex",
          "type": "method"
        },
        "index": {
          "description": "One extremity of the edge which is the end only for directed edge",
          "hierarchy": "Bayes",
          "module": "Bayes",
          "name": "endVertex",
          "normalized": "a b c-\u003eEdge-\u003eMaybe Vertex",
          "package": "hbayes",
          "partial": "Vertex",
          "signature": "g a b-\u003eEdge-\u003eMaybe Vertex",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes.html#v:endVertex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Bayes",
          "name": "evalGraph",
          "package": "hbayes",
          "signature": "GraphMonad g e f a -\u003e a",
          "source": "src/Bayes.html#evalGraph",
          "type": "function"
        },
        "index": {
          "hierarchy": "Bayes",
          "module": "Bayes",
          "name": "evalGraph",
          "normalized": "GraphMonad a b c d-\u003ed",
          "package": "hbayes",
          "partial": "Graph",
          "signature": "GraphMonad g e f a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes.html#v:evalGraph"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Bayes",
          "name": "execGraph",
          "package": "hbayes",
          "signature": "GraphMonad g e f a -\u003e g e f",
          "source": "src/Bayes.html#execGraph",
          "type": "function"
        },
        "index": {
          "hierarchy": "Bayes",
          "module": "Bayes",
          "name": "execGraph",
          "normalized": "GraphMonad a b c d-\u003ea b c",
          "package": "hbayes",
          "partial": "Graph",
          "signature": "GraphMonad g e f a-\u003eg e f",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes.html#v:execGraph"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Bayes",
          "name": "fmapWithVertex",
          "package": "hbayes",
          "signature": "(Vertex -\u003e a -\u003e b) -\u003e g c a -\u003e g c b",
          "source": "src/Bayes.html#fmapWithVertex",
          "type": "method"
        },
        "index": {
          "hierarchy": "Bayes",
          "module": "Bayes",
          "name": "fmapWithVertex",
          "normalized": "(Vertex-\u003ea-\u003eb)-\u003ec d a-\u003ec d b",
          "package": "hbayes",
          "partial": "With Vertex",
          "signature": "(Vertex-\u003ea-\u003eb)-\u003eg c a-\u003eg c b",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes.html#v:fmapWithVertex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Bayes",
          "name": "fmapWithVertexM",
          "package": "hbayes",
          "signature": "(Vertex -\u003e a -\u003e m b) -\u003e g c a -\u003e m (g c b)",
          "source": "src/Bayes.html#fmapWithVertexM",
          "type": "method"
        },
        "index": {
          "hierarchy": "Bayes",
          "module": "Bayes",
          "name": "fmapWithVertexM",
          "normalized": "(Vertex-\u003ea-\u003eb c)-\u003ed e a-\u003eb(d e c)",
          "package": "hbayes",
          "partial": "With Vertex",
          "signature": "(Vertex-\u003ea-\u003em b)-\u003eg c a-\u003em(g c b)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes.html#v:fmapWithVertexM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Bayes",
          "name": "foldlWithVertex'",
          "package": "hbayes",
          "signature": "(b -\u003e Vertex -\u003e a -\u003e b) -\u003e b -\u003e g c a -\u003e b",
          "source": "src/Bayes.html#foldlWithVertex%27",
          "type": "method"
        },
        "index": {
          "hierarchy": "Bayes",
          "module": "Bayes",
          "name": "foldlWithVertex'",
          "normalized": "(a-\u003eVertex-\u003eb-\u003ea)-\u003ea-\u003ec d b-\u003ea",
          "package": "hbayes",
          "partial": "With Vertex'",
          "signature": "(b-\u003eVertex-\u003ea-\u003eb)-\u003eb-\u003eg c a-\u003eb",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes.html#v:foldlWithVertex-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFold with vertex \n\u003c/p\u003e",
          "module": "Bayes",
          "name": "foldrWithVertex",
          "package": "hbayes",
          "signature": "(Vertex -\u003e a -\u003e b -\u003e b) -\u003e b -\u003e g c a -\u003e b",
          "source": "src/Bayes.html#foldrWithVertex",
          "type": "method"
        },
        "index": {
          "description": "Fold with vertex",
          "hierarchy": "Bayes",
          "module": "Bayes",
          "name": "foldrWithVertex",
          "normalized": "(Vertex-\u003ea-\u003eb-\u003eb)-\u003eb-\u003ec d a-\u003eb",
          "package": "hbayes",
          "partial": "With Vertex",
          "signature": "(Vertex-\u003ea-\u003eb-\u003eb)-\u003eb-\u003eg c a-\u003eb",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes.html#v:foldrWithVertex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGenerate a new unique unamed empty variable\n\u003c/p\u003e",
          "module": "Bayes",
          "name": "getNewEmptyVariable",
          "package": "hbayes",
          "signature": "Maybe String -\u003e f -\u003e GraphMonad g e f Vertex",
          "source": "src/Bayes.html#getNewEmptyVariable",
          "type": "function"
        },
        "index": {
          "description": "Generate new unique unamed empty variable",
          "hierarchy": "Bayes",
          "module": "Bayes",
          "name": "getNewEmptyVariable",
          "normalized": "Maybe String-\u003ea-\u003eGraphMonad b c a Vertex",
          "package": "hbayes",
          "partial": "New Empty Variable",
          "signature": "Maybe String-\u003ef-\u003eGraphMonad g e f Vertex",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes.html#v:getNewEmptyVariable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGet a named vertex from the graph monad\n\u003c/p\u003e",
          "module": "Bayes",
          "name": "getVertex",
          "package": "hbayes",
          "signature": "String -\u003e GraphMonad g e f (Maybe Vertex)",
          "source": "src/Bayes.html#getVertex",
          "type": "function"
        },
        "index": {
          "description": "Get named vertex from the graph monad",
          "hierarchy": "Bayes",
          "module": "Bayes",
          "name": "getVertex",
          "normalized": "String-\u003eGraphMonad a b c(Maybe Vertex)",
          "package": "hbayes",
          "partial": "Vertex",
          "signature": "String-\u003eGraphMonad g e f(Maybe Vertex)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes.html#v:getVertex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAdd a node in the graph using the graph monad\n\u003c/p\u003e",
          "module": "Bayes",
          "name": "graphNode",
          "package": "hbayes",
          "signature": "String -\u003e f -\u003e GraphMonad g e f Vertex",
          "source": "src/Bayes.html#graphNode",
          "type": "function"
        },
        "index": {
          "description": "Add node in the graph using the graph monad",
          "hierarchy": "Bayes",
          "module": "Bayes",
          "name": "graphNode",
          "normalized": "String-\u003ea-\u003eGraphMonad b c a Vertex",
          "package": "hbayes",
          "partial": "Node",
          "signature": "String-\u003ef-\u003eGraphMonad g e f Vertex",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes.html#v:graphNode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCheck if the graph has no edges\n\u003c/p\u003e",
          "module": "Bayes",
          "name": "hasNoEdges",
          "package": "hbayes",
          "signature": "g a b -\u003e Bool",
          "source": "src/Bayes.html#hasNoEdges",
          "type": "method"
        },
        "index": {
          "description": "Check if the graph has no edges",
          "hierarchy": "Bayes",
          "module": "Bayes",
          "name": "hasNoEdges",
          "normalized": "a b c-\u003eBool",
          "package": "hbayes",
          "partial": "No Edges",
          "signature": "g a b-\u003eBool",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes.html#v:hasNoEdges"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCheck is the graph has no vertrex\n\u003c/p\u003e",
          "module": "Bayes",
          "name": "hasNoVertices",
          "package": "hbayes",
          "signature": "g a b -\u003e Bool",
          "source": "src/Bayes.html#hasNoVertices",
          "type": "method"
        },
        "index": {
          "description": "Check is the graph has no vertrex",
          "hierarchy": "Bayes",
          "module": "Bayes",
          "name": "hasNoVertices",
          "normalized": "a b c-\u003eBool",
          "package": "hbayes",
          "partial": "No Vertices",
          "signature": "g a b-\u003eBool",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes.html#v:hasNoVertices"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Bayes",
          "name": "ingoing",
          "package": "hbayes",
          "signature": "g a b -\u003e Vertex -\u003e Maybe [Edge]",
          "source": "src/Bayes.html#ingoing",
          "type": "method"
        },
        "index": {
          "hierarchy": "Bayes",
          "module": "Bayes",
          "name": "ingoing",
          "normalized": "a b c-\u003eVertex-\u003eMaybe[Edge]",
          "package": "hbayes",
          "signature": "g a b-\u003eVertex-\u003eMaybe[Edge]",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes.html#v:ingoing"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCheck if the graph is empty\n\u003c/p\u003e",
          "module": "Bayes",
          "name": "isEmpty",
          "package": "hbayes",
          "signature": "g a b -\u003e Bool",
          "source": "src/Bayes.html#isEmpty",
          "type": "method"
        },
        "index": {
          "description": "Check if the graph is empty",
          "hierarchy": "Bayes",
          "module": "Bayes",
          "name": "isEmpty",
          "normalized": "a b c-\u003eBool",
          "package": "hbayes",
          "partial": "Empty",
          "signature": "g a b-\u003eBool",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes.html#v:isEmpty"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCheck if two vertices are linked by a vertex\n\u003c/p\u003e",
          "module": "Bayes",
          "name": "isLinkedWithAnEdge",
          "package": "hbayes",
          "signature": "g a b -\u003e Vertex -\u003e Vertex -\u003e Bool",
          "source": "src/Bayes.html#isLinkedWithAnEdge",
          "type": "method"
        },
        "index": {
          "description": "Check if two vertices are linked by vertex",
          "hierarchy": "Bayes",
          "module": "Bayes",
          "name": "isLinkedWithAnEdge",
          "normalized": "a b c-\u003eVertex-\u003eVertex-\u003eBool",
          "package": "hbayes",
          "partial": "Linked With An Edge",
          "signature": "g a b-\u003eVertex-\u003eVertex-\u003eBool",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes.html#v:isLinkedWithAnEdge"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Bayes",
          "name": "isRoot",
          "package": "hbayes",
          "signature": "g a b -\u003e Vertex -\u003e Bool",
          "source": "src/Bayes.html#isRoot",
          "type": "function"
        },
        "index": {
          "hierarchy": "Bayes",
          "module": "Bayes",
          "name": "isRoot",
          "normalized": "a b c-\u003eVertex-\u003eBool",
          "package": "hbayes",
          "partial": "Root",
          "signature": "g a b-\u003eVertex-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes.html#v:isRoot"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn the Markov blanket of a node \n\u003c/p\u003e",
          "module": "Bayes",
          "name": "markovBlanket",
          "package": "hbayes",
          "signature": "g a b -\u003e Vertex -\u003e [Vertex]",
          "source": "src/Bayes.html#markovBlanket",
          "type": "function"
        },
        "index": {
          "description": "Return the Markov blanket of node",
          "hierarchy": "Bayes",
          "module": "Bayes",
          "name": "markovBlanket",
          "normalized": "a b c-\u003eVertex-\u003e[Vertex]",
          "package": "hbayes",
          "partial": "Blanket",
          "signature": "g a b-\u003eVertex-\u003e[Vertex]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes.html#v:markovBlanket"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAll the neighbors of a vertex\n\u003c/p\u003e",
          "module": "Bayes",
          "name": "neighbors",
          "package": "hbayes",
          "signature": "g a b -\u003e Vertex -\u003e Maybe [Vertex]",
          "source": "src/Bayes.html#neighbors",
          "type": "method"
        },
        "index": {
          "description": "All the neighbors of vertex",
          "hierarchy": "Bayes",
          "module": "Bayes",
          "name": "neighbors",
          "normalized": "a b c-\u003eVertex-\u003eMaybe[Vertex]",
          "package": "hbayes",
          "signature": "g a b-\u003eVertex-\u003eMaybe[Vertex]",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes.html#v:neighbors"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAdd a new labeled edge to the graph\n\u003c/p\u003e",
          "module": "Bayes",
          "name": "newEdge",
          "package": "hbayes",
          "signature": "Vertex -\u003e Vertex -\u003e e -\u003e GraphMonad g e f ()",
          "source": "src/Bayes.html#newEdge",
          "type": "function"
        },
        "index": {
          "description": "Add new labeled edge to the graph",
          "hierarchy": "Bayes",
          "module": "Bayes",
          "name": "newEdge",
          "normalized": "Vertex-\u003eVertex-\u003ea-\u003eGraphMonad b a c()",
          "package": "hbayes",
          "partial": "Edge",
          "signature": "Vertex-\u003eVertex-\u003ee-\u003eGraphMonad g e f()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes.html#v:newEdge"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCheck if the graph is oriented\n\u003c/p\u003e",
          "module": "Bayes",
          "name": "oriented",
          "package": "hbayes",
          "signature": "g a b -\u003e Bool",
          "source": "src/Bayes.html#oriented",
          "type": "method"
        },
        "index": {
          "description": "Check if the graph is oriented",
          "hierarchy": "Bayes",
          "module": "Bayes",
          "name": "oriented",
          "normalized": "a b c-\u003eBool",
          "package": "hbayes",
          "signature": "g a b-\u003eBool",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes.html#v:oriented"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Bayes",
          "name": "outgoing",
          "package": "hbayes",
          "signature": "g a b -\u003e Vertex -\u003e Maybe [Edge]",
          "source": "src/Bayes.html#outgoing",
          "type": "method"
        },
        "index": {
          "hierarchy": "Bayes",
          "module": "Bayes",
          "name": "outgoing",
          "normalized": "a b c-\u003eVertex-\u003eMaybe[Edge]",
          "package": "hbayes",
          "signature": "g a b-\u003eVertex-\u003eMaybe[Edge]",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes.html#v:outgoing"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn the parents of a node\n\u003c/p\u003e",
          "module": "Bayes",
          "name": "parentNodes",
          "package": "hbayes",
          "signature": "g a b -\u003e Vertex -\u003e [Vertex]",
          "source": "src/Bayes.html#parentNodes",
          "type": "function"
        },
        "index": {
          "description": "Return the parents of node",
          "hierarchy": "Bayes",
          "module": "Bayes",
          "name": "parentNodes",
          "normalized": "a b c-\u003eVertex-\u003e[Vertex]",
          "package": "hbayes",
          "partial": "Nodes",
          "signature": "g a b-\u003eVertex-\u003e[Vertex]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes.html#v:parentNodes"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePrint the values of the graph vertices\n\u003c/p\u003e",
          "module": "Bayes",
          "name": "printGraphValues",
          "package": "hbayes",
          "signature": "SimpleGraph n e b -\u003e IO ()",
          "source": "src/Bayes.html#printGraphValues",
          "type": "function"
        },
        "index": {
          "description": "Print the values of the graph vertices",
          "hierarchy": "Bayes",
          "module": "Bayes",
          "name": "printGraphValues",
          "normalized": "SimpleGraph a b c-\u003eIO()",
          "package": "hbayes",
          "partial": "Graph Values",
          "signature": "SimpleGraph n e b-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes.html#v:printGraphValues"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRemove an dedge\n\u003c/p\u003e",
          "module": "Bayes",
          "name": "removeEdge",
          "package": "hbayes",
          "signature": "Edge -\u003e g a b -\u003e g a b",
          "source": "src/Bayes.html#removeEdge",
          "type": "method"
        },
        "index": {
          "description": "Remove an dedge",
          "hierarchy": "Bayes",
          "module": "Bayes",
          "name": "removeEdge",
          "normalized": "Edge-\u003ea b c-\u003ea b c",
          "package": "hbayes",
          "partial": "Edge",
          "signature": "Edge-\u003eg a b-\u003eg a b",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes.html#v:removeEdge"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRemove a vertex\n\u003c/p\u003e",
          "module": "Bayes",
          "name": "removeVertex",
          "package": "hbayes",
          "signature": "Vertex -\u003e g a b -\u003e g a b",
          "source": "src/Bayes.html#removeVertex",
          "type": "method"
        },
        "index": {
          "description": "Remove vertex",
          "hierarchy": "Bayes",
          "module": "Bayes",
          "name": "removeVertex",
          "normalized": "Vertex-\u003ea b c-\u003ea b c",
          "package": "hbayes",
          "partial": "Vertex",
          "signature": "Vertex-\u003eg a b-\u003eg a b",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes.html#v:removeVertex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGet the root node for the graph\n\u003c/p\u003e",
          "module": "Bayes",
          "name": "rootNode",
          "package": "hbayes",
          "signature": "g a b -\u003e Maybe Vertex",
          "source": "src/Bayes.html#rootNode",
          "type": "function"
        },
        "index": {
          "description": "Get the root node for the graph",
          "hierarchy": "Bayes",
          "module": "Bayes",
          "name": "rootNode",
          "normalized": "a b c-\u003eMaybe Vertex",
          "package": "hbayes",
          "partial": "Node",
          "signature": "g a b-\u003eMaybe Vertex",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes.html#v:rootNode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Bayes",
          "name": "runGraph",
          "package": "hbayes",
          "signature": "GraphMonad g e f a -\u003e (a, g e f)",
          "source": "src/Bayes.html#runGraph",
          "type": "function"
        },
        "index": {
          "hierarchy": "Bayes",
          "module": "Bayes",
          "name": "runGraph",
          "normalized": "GraphMonad a b c d-\u003e(d,a b c)",
          "package": "hbayes",
          "partial": "Graph",
          "signature": "GraphMonad g e f a-\u003e(a,g e f)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes.html#v:runGraph"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn a \"random\" edge\n\u003c/p\u003e",
          "module": "Bayes",
          "name": "someEdge",
          "package": "hbayes",
          "signature": "g a b -\u003e Maybe Edge",
          "source": "src/Bayes.html#someEdge",
          "type": "method"
        },
        "index": {
          "description": "Return random edge",
          "hierarchy": "Bayes",
          "module": "Bayes",
          "name": "someEdge",
          "normalized": "a b c-\u003eMaybe Edge",
          "package": "hbayes",
          "partial": "Edge",
          "signature": "g a b-\u003eMaybe Edge",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes.html#v:someEdge"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGenerate a \"random\" vertex\n\u003c/p\u003e",
          "module": "Bayes",
          "name": "someVertex",
          "package": "hbayes",
          "signature": "g a b -\u003e Maybe Vertex",
          "source": "src/Bayes.html#someVertex",
          "type": "method"
        },
        "index": {
          "description": "Generate random vertex",
          "hierarchy": "Bayes",
          "module": "Bayes",
          "name": "someVertex",
          "normalized": "a b c-\u003eMaybe Vertex",
          "package": "hbayes",
          "partial": "Vertex",
          "signature": "g a b-\u003eMaybe Vertex",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes.html#v:someVertex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eOne extremity of the edge (which is the start only for directed edge)\n\u003c/p\u003e",
          "module": "Bayes",
          "name": "startVertex",
          "package": "hbayes",
          "signature": "g a b -\u003e Edge -\u003e Maybe Vertex",
          "source": "src/Bayes.html#startVertex",
          "type": "method"
        },
        "index": {
          "description": "One extremity of the edge which is the start only for directed edge",
          "hierarchy": "Bayes",
          "module": "Bayes",
          "name": "startVertex",
          "normalized": "a b c-\u003eEdge-\u003eMaybe Vertex",
          "package": "hbayes",
          "partial": "Vertex",
          "signature": "g a b-\u003eEdge-\u003eMaybe Vertex",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes.html#v:startVertex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Bayes",
          "name": "testEdgeRemoval_prop",
          "package": "hbayes",
          "signature": "DirectedSG String String -\u003e Property",
          "source": "src/Bayes.html#testEdgeRemoval_prop",
          "type": "function"
        },
        "index": {
          "hierarchy": "Bayes",
          "module": "Bayes",
          "name": "testEdgeRemoval_prop",
          "normalized": "DirectedSG String String-\u003eProperty",
          "package": "hbayes",
          "partial": "Edge Removal",
          "signature": "DirectedSG String String-\u003eProperty",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes.html#v:testEdgeRemoval_prop"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Bayes",
          "name": "testVertexRemoval_prop",
          "package": "hbayes",
          "signature": "DirectedSG String String -\u003e Property",
          "source": "src/Bayes.html#testVertexRemoval_prop",
          "type": "function"
        },
        "index": {
          "hierarchy": "Bayes",
          "module": "Bayes",
          "name": "testVertexRemoval_prop",
          "normalized": "DirectedSG String String-\u003eProperty",
          "package": "hbayes",
          "partial": "Vertex Removal",
          "signature": "DirectedSG String String-\u003eProperty",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes.html#v:testVertexRemoval_prop"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGet the variable name mapping\n\u003c/p\u003e",
          "module": "Bayes",
          "name": "varMap",
          "package": "hbayes",
          "signature": "SimpleGraph n e v -\u003e Map String Vertex",
          "source": "src/Bayes.html#varMap",
          "type": "function"
        },
        "index": {
          "description": "Get the variable name mapping",
          "hierarchy": "Bayes",
          "module": "Bayes",
          "name": "varMap",
          "normalized": "SimpleGraph a b c-\u003eMap String Vertex",
          "package": "hbayes",
          "partial": "Map",
          "signature": "SimpleGraph n e v-\u003eMap String Vertex",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes.html#v:varMap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturns the vertex label\n\u003c/p\u003e",
          "module": "Bayes",
          "name": "vertexLabel",
          "package": "hbayes",
          "signature": "g a b -\u003e Vertex -\u003e Maybe String",
          "source": "src/Bayes.html#vertexLabel",
          "type": "method"
        },
        "index": {
          "description": "Returns the vertex label",
          "hierarchy": "Bayes",
          "module": "Bayes",
          "name": "vertexLabel",
          "normalized": "a b c-\u003eVertex-\u003eMaybe String",
          "package": "hbayes",
          "partial": "Label",
          "signature": "g a b-\u003eVertex-\u003eMaybe String",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes.html#v:vertexLabel"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGet the vertex value if the vertex is found in the graph\n\u003c/p\u003e",
          "module": "Bayes",
          "name": "vertexValue",
          "package": "hbayes",
          "signature": "g a b -\u003e Vertex -\u003e Maybe b",
          "source": "src/Bayes.html#vertexValue",
          "type": "method"
        },
        "index": {
          "description": "Get the vertex value if the vertex is found in the graph",
          "hierarchy": "Bayes",
          "module": "Bayes",
          "name": "vertexValue",
          "normalized": "a b c-\u003eVertex-\u003eMaybe c",
          "package": "hbayes",
          "partial": "Value",
          "signature": "g a b-\u003eVertex-\u003eMaybe b",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hbayes/docs/Bayes.html#v:vertexValue"
      }
    }
  ]
]