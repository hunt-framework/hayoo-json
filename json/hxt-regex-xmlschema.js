[
  {
    "cmd": "delete-by-query",
    "query": {
      "contexts": [
        "package"
      ],
      "query": {
        "op": "case",
        "type": "word",
        "word": "hxt-regex-xmlschema"
      },
      "type": "context"
    }
  },
  [
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003ecsh style Glob Pattern Parser for Regular Expressions\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Text.Regex.Glob.String.RegexParser",
          "name": "RegexParser",
          "package": "hxt-regex-xmlschema",
          "source": "src/Text-Regex-Glob-String-RegexParser.html",
          "type": "module"
        },
        "index": {
          "description": "csh style Glob Pattern Parser for Regular Expressions",
          "hierarchy": "Text Regex Glob String RegexParser",
          "module": "Text.Regex.Glob.String.RegexParser",
          "name": "RegexParser",
          "package": "hxt-regex-xmlschema",
          "partial": "Regex Parser",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hxt-regex-xmlschema/docs/Text-Regex-Glob-String-RegexParser.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eparse a glob pattern\n\u003c/p\u003e",
          "module": "[\"Text.Regex.Glob.String.RegexParser\",\"Text.Regex.Glob.String\"]",
          "name": "parseRegex",
          "package": "hxt-regex-xmlschema",
          "signature": "String -\u003e Regex",
          "source": "src/Text-Regex-Glob-String-RegexParser.html#parseRegex",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt-regex-xmlschema/docs/Text-Regex-Glob-String-RegexParser.html#v:parseRegex\",\"http://hackage.haskell.org/package/hxt-regex-xmlschema/docs/Text-Regex-Glob-String.html#v:parseRegex\"]"
        },
        "index": {
          "description": "parse glob pattern",
          "hierarchy": "Text Regex Glob String RegexParser",
          "module": "Text.Regex.Glob.String.RegexParser",
          "name": "parseRegex",
          "normalized": "String-\u003eRegex",
          "package": "hxt-regex-xmlschema",
          "partial": "Regex",
          "signature": "String-\u003eRegex",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt-regex-xmlschema/docs/Text-Regex-Glob-String-RegexParser.html#v:parseRegex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Text.Regex.Glob.String.RegexParser\",\"Text.Regex.Glob.String\"]",
          "name": "parseRegexNoCase",
          "package": "hxt-regex-xmlschema",
          "signature": "String -\u003e Regex",
          "source": "src/Text-Regex-Glob-String-RegexParser.html#parseRegexNoCase",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt-regex-xmlschema/docs/Text-Regex-Glob-String-RegexParser.html#v:parseRegexNoCase\",\"http://hackage.haskell.org/package/hxt-regex-xmlschema/docs/Text-Regex-Glob-String.html#v:parseRegexNoCase\"]"
        },
        "index": {
          "hierarchy": "Text Regex Glob String RegexParser",
          "module": "Text.Regex.Glob.String.RegexParser",
          "name": "parseRegexNoCase",
          "normalized": "String-\u003eRegex",
          "package": "hxt-regex-xmlschema",
          "partial": "Regex No Case",
          "signature": "String-\u003eRegex",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt-regex-xmlschema/docs/Text-Regex-Glob-String-RegexParser.html#v:parseRegexNoCase"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003ecsh glob style pattern matcher\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Text.Regex.Glob.String",
          "name": "String",
          "package": "hxt-regex-xmlschema",
          "source": "src/Text-Regex-Glob-String.html",
          "type": "module"
        },
        "index": {
          "description": "csh glob style pattern matcher",
          "hierarchy": "Text Regex Glob String",
          "module": "Text.Regex.Glob.String",
          "name": "String",
          "package": "hxt-regex-xmlschema",
          "partial": "String",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hxt-regex-xmlschema/docs/Text-Regex-Glob-String.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.Glob.String",
          "name": "Regex",
          "package": "hxt-regex-xmlschema",
          "source": "src/Text-Regex-XMLSchema-String-Regex.html#Regex",
          "type": "type"
        },
        "index": {
          "hierarchy": "Text Regex Glob String",
          "module": "Text.Regex.Glob.String",
          "name": "Regex",
          "package": "hxt-regex-xmlschema",
          "partial": "Regex",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/hxt-regex-xmlschema/docs/Text-Regex-Glob-String.html#t:Regex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.Glob.String",
          "name": "match",
          "package": "hxt-regex-xmlschema",
          "signature": "String -\u003e String -\u003e Bool",
          "source": "src/Text-Regex-Glob-String.html#match",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex Glob String",
          "module": "Text.Regex.Glob.String",
          "name": "match",
          "normalized": "String-\u003eString-\u003eBool",
          "package": "hxt-regex-xmlschema",
          "signature": "String-\u003eString-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt-regex-xmlschema/docs/Text-Regex-Glob-String.html#v:match"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.Glob.String",
          "name": "matchNoCase",
          "package": "hxt-regex-xmlschema",
          "signature": "String -\u003e String -\u003e Bool",
          "source": "src/Text-Regex-Glob-String.html#matchNoCase",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex Glob String",
          "module": "Text.Regex.Glob.String",
          "name": "matchNoCase",
          "normalized": "String-\u003eString-\u003eBool",
          "package": "hxt-regex-xmlschema",
          "partial": "No Case",
          "signature": "String-\u003eString-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt-regex-xmlschema/docs/Text-Regex-Glob-String.html#v:matchNoCase"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eW3C XML Schema Regular Expression Matcher\n\u003c/p\u003e\u003cp\u003eGrammar can be found under \u003ca\u003ehttp://www.w3.org/TR/xmlschema11-2/#regexs\u003c/a\u003e\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Text.Regex.XMLSchema.String.Regex",
          "name": "Regex",
          "package": "hxt-regex-xmlschema",
          "source": "src/Text-Regex-XMLSchema-String-Regex.html",
          "type": "module"
        },
        "index": {
          "description": "W3C XML Schema Regular Expression Matcher Grammar can be found under http www.w3.org TR xmlschema11-2 regexs",
          "hierarchy": "Text Regex XMLSchema String Regex",
          "module": "Text.Regex.XMLSchema.String.Regex",
          "name": "Regex",
          "package": "hxt-regex-xmlschema",
          "partial": "Regex",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hxt-regex-xmlschema/docs/Text-Regex-XMLSchema-String-Regex.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.XMLSchema.String.Regex",
          "name": "GenRegex",
          "package": "hxt-regex-xmlschema",
          "source": "src/Text-Regex-XMLSchema-String-Regex.html#GenRegex",
          "type": "data"
        },
        "index": {
          "hierarchy": "Text Regex XMLSchema String Regex",
          "module": "Text.Regex.XMLSchema.String.Regex",
          "name": "GenRegex",
          "package": "hxt-regex-xmlschema",
          "partial": "Gen Regex",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/hxt-regex-xmlschema/docs/Text-Regex-XMLSchema-String-Regex.html#t:GenRegex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.XMLSchema.String.Regex",
          "name": "Regex",
          "package": "hxt-regex-xmlschema",
          "source": "src/Text-Regex-XMLSchema-String-Regex.html#Regex",
          "type": "type"
        },
        "index": {
          "hierarchy": "Text Regex XMLSchema String Regex",
          "module": "Text.Regex.XMLSchema.String.Regex",
          "name": "Regex",
          "package": "hxt-regex-xmlschema",
          "partial": "Regex",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/hxt-regex-xmlschema/docs/Text-Regex-XMLSchema-String-Regex.html#t:Regex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.XMLSchema.String.Regex",
          "name": "delta",
          "package": "hxt-regex-xmlschema",
          "signature": "GenRegex l -\u003e String -\u003e GenRegex l",
          "source": "src/Text-Regex-XMLSchema-String-Regex.html#delta",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex XMLSchema String Regex",
          "module": "Text.Regex.XMLSchema.String.Regex",
          "name": "delta",
          "normalized": "GenRegex a-\u003eString-\u003eGenRegex a",
          "package": "hxt-regex-xmlschema",
          "signature": "GenRegex l-\u003eString-\u003eGenRegex l",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt-regex-xmlschema/docs/Text-Regex-XMLSchema-String-Regex.html#v:delta"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.XMLSchema.String.Regex",
          "name": "delta1",
          "package": "hxt-regex-xmlschema",
          "signature": "GenRegex l -\u003e Char -\u003e GenRegex l",
          "source": "src/Text-Regex-XMLSchema-String-Regex.html#delta1",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex XMLSchema String Regex",
          "module": "Text.Regex.XMLSchema.String.Regex",
          "name": "delta1",
          "normalized": "GenRegex a-\u003eChar-\u003eGenRegex a",
          "package": "hxt-regex-xmlschema",
          "signature": "GenRegex l-\u003eChar-\u003eGenRegex l",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt-regex-xmlschema/docs/Text-Regex-XMLSchema-String-Regex.html#v:delta1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Text.Regex.XMLSchema.String.Regex\",\"Text.Regex.XMLSchema.String\"]",
          "name": "errRegex",
          "package": "hxt-regex-xmlschema",
          "signature": "GenRegex l -\u003e String",
          "source": "src/Text-Regex-XMLSchema-String-Regex.html#errRegex",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt-regex-xmlschema/docs/Text-Regex-XMLSchema-String-Regex.html#v:errRegex\",\"http://hackage.haskell.org/package/hxt-regex-xmlschema/docs/Text-Regex-XMLSchema-String.html#v:errRegex\"]"
        },
        "index": {
          "hierarchy": "Text Regex XMLSchema String Regex",
          "module": "Text.Regex.XMLSchema.String.Regex",
          "name": "errRegex",
          "normalized": "GenRegex a-\u003eString",
          "package": "hxt-regex-xmlschema",
          "partial": "Regex",
          "signature": "GenRegex l-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt-regex-xmlschema/docs/Text-Regex-XMLSchema-String-Regex.html#v:errRegex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFIRST for regular expressions\n\u003c/p\u003e\u003cp\u003ethis is only an approximation, the real set of char may be smaller,\n when the expression contains intersection, set difference or exor operators\n\u003c/p\u003e",
          "module": "Text.Regex.XMLSchema.String.Regex",
          "name": "firstChars",
          "package": "hxt-regex-xmlschema",
          "signature": "GenRegex l -\u003e CharSet",
          "source": "src/Text-Regex-XMLSchema-String-Regex.html#firstChars",
          "type": "function"
        },
        "index": {
          "description": "FIRST for regular expressions this is only an approximation the real set of char may be smaller when the expression contains intersection set difference or exor operators",
          "hierarchy": "Text Regex XMLSchema String Regex",
          "module": "Text.Regex.XMLSchema.String.Regex",
          "name": "firstChars",
          "normalized": "GenRegex a-\u003eCharSet",
          "package": "hxt-regex-xmlschema",
          "partial": "Chars",
          "signature": "GenRegex l-\u003eCharSet",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt-regex-xmlschema/docs/Text-Regex-XMLSchema-String-Regex.html#v:firstChars"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Text.Regex.XMLSchema.String.Regex\",\"Text.Regex.XMLSchema.String\"]",
          "name": "isZero",
          "package": "hxt-regex-xmlschema",
          "signature": "GenRegex l -\u003e Bool",
          "source": "src/Text-Regex-XMLSchema-String-Regex.html#isZero",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt-regex-xmlschema/docs/Text-Regex-XMLSchema-String-Regex.html#v:isZero\",\"http://hackage.haskell.org/package/hxt-regex-xmlschema/docs/Text-Regex-XMLSchema-String.html#v:isZero\"]"
        },
        "index": {
          "hierarchy": "Text Regex XMLSchema String Regex",
          "module": "Text.Regex.XMLSchema.String.Regex",
          "name": "isZero",
          "normalized": "GenRegex a-\u003eBool",
          "package": "hxt-regex-xmlschema",
          "partial": "Zero",
          "signature": "GenRegex l-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt-regex-xmlschema/docs/Text-Regex-XMLSchema-String-Regex.html#v:isZero"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.XMLSchema.String.Regex",
          "name": "matchWithRegex",
          "package": "hxt-regex-xmlschema",
          "signature": "GenRegex l -\u003e String -\u003e Bool",
          "source": "src/Text-Regex-XMLSchema-String-Regex.html#matchWithRegex",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex XMLSchema String Regex",
          "module": "Text.Regex.XMLSchema.String.Regex",
          "name": "matchWithRegex",
          "normalized": "GenRegex a-\u003eString-\u003eBool",
          "package": "hxt-regex-xmlschema",
          "partial": "With Regex",
          "signature": "GenRegex l-\u003eString-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt-regex-xmlschema/docs/Text-Regex-XMLSchema-String-Regex.html#v:matchWithRegex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.XMLSchema.String.Regex",
          "name": "matchWithRegex'",
          "package": "hxt-regex-xmlschema",
          "signature": "GenRegex l -\u003e String -\u003e Maybe [(Label l, String)]",
          "source": "src/Text-Regex-XMLSchema-String-Regex.html#matchWithRegex%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex XMLSchema String Regex",
          "module": "Text.Regex.XMLSchema.String.Regex",
          "name": "matchWithRegex'",
          "normalized": "GenRegex a-\u003eString-\u003eMaybe[(Label a,String)]",
          "package": "hxt-regex-xmlschema",
          "partial": "With Regex'",
          "signature": "GenRegex l-\u003eString-\u003eMaybe[(Label l,String)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt-regex-xmlschema/docs/Text-Regex-XMLSchema-String-Regex.html#v:matchWithRegex-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003econstruct an r.e. for the set of all Unicode words\n\u003c/p\u003e",
          "module": "[\"Text.Regex.XMLSchema.String.Regex\",\"Text.Regex.XMLSchema.String\"]",
          "name": "mkAll",
          "package": "hxt-regex-xmlschema",
          "signature": "GenRegex l",
          "source": "src/Text-Regex-XMLSchema-String-Regex.html#mkAll",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt-regex-xmlschema/docs/Text-Regex-XMLSchema-String-Regex.html#v:mkAll\",\"http://hackage.haskell.org/package/hxt-regex-xmlschema/docs/Text-Regex-XMLSchema-String.html#v:mkAll\"]"
        },
        "index": {
          "description": "construct an r.e for the set of all Unicode words",
          "hierarchy": "Text Regex XMLSchema String Regex",
          "module": "Text.Regex.XMLSchema.String.Regex",
          "name": "mkAll",
          "package": "hxt-regex-xmlschema",
          "partial": "All",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt-regex-xmlschema/docs/Text-Regex-XMLSchema-String-Regex.html#v:mkAll"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003econstruct the r.e for r1|r2\n\u003c/p\u003e",
          "module": "[\"Text.Regex.XMLSchema.String.Regex\",\"Text.Regex.XMLSchema.String\"]",
          "name": "mkAlt",
          "package": "hxt-regex-xmlschema",
          "signature": "GenRegex l -\u003e GenRegex l -\u003e GenRegex l",
          "source": "src/Text-Regex-XMLSchema-String-Regex.html#mkAlt",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt-regex-xmlschema/docs/Text-Regex-XMLSchema-String-Regex.html#v:mkAlt\",\"http://hackage.haskell.org/package/hxt-regex-xmlschema/docs/Text-Regex-XMLSchema-String.html#v:mkAlt\"]"
        },
        "index": {
          "description": "construct the r.e for r1 r2",
          "hierarchy": "Text Regex XMLSchema String Regex",
          "module": "Text.Regex.XMLSchema.String.Regex",
          "name": "mkAlt",
          "normalized": "GenRegex a-\u003eGenRegex a-\u003eGenRegex a",
          "package": "hxt-regex-xmlschema",
          "partial": "Alt",
          "signature": "GenRegex l-\u003eGenRegex l-\u003eGenRegex l",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt-regex-xmlschema/docs/Text-Regex-XMLSchema-String-Regex.html#v:mkAlt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstruct a labeled subexpression: ({label}r)\n\u003c/p\u003e",
          "module": "[\"Text.Regex.XMLSchema.String.Regex\",\"Text.Regex.XMLSchema.String\"]",
          "name": "mkBr",
          "package": "hxt-regex-xmlschema",
          "signature": "l -\u003e GenRegex l -\u003e GenRegex l",
          "source": "src/Text-Regex-XMLSchema-String-Regex.html#mkBr",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt-regex-xmlschema/docs/Text-Regex-XMLSchema-String-Regex.html#v:mkBr\",\"http://hackage.haskell.org/package/hxt-regex-xmlschema/docs/Text-Regex-XMLSchema-String.html#v:mkBr\"]"
        },
        "index": {
          "description": "Construct labeled subexpression label",
          "hierarchy": "Text Regex XMLSchema String Regex",
          "module": "Text.Regex.XMLSchema.String.Regex",
          "name": "mkBr",
          "normalized": "a-\u003eGenRegex a-\u003eGenRegex a",
          "package": "hxt-regex-xmlschema",
          "partial": "Br",
          "signature": "l-\u003eGenRegex l-\u003eGenRegex l",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt-regex-xmlschema/docs/Text-Regex-XMLSchema-String-Regex.html#v:mkBr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstruct the Complement of an r.e.: whole set of words - r\n\u003c/p\u003e",
          "module": "[\"Text.Regex.XMLSchema.String.Regex\",\"Text.Regex.XMLSchema.String\"]",
          "name": "mkCompl",
          "package": "hxt-regex-xmlschema",
          "signature": "GenRegex l -\u003e GenRegex l",
          "source": "src/Text-Regex-XMLSchema-String-Regex.html#mkCompl",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt-regex-xmlschema/docs/Text-Regex-XMLSchema-String-Regex.html#v:mkCompl\",\"http://hackage.haskell.org/package/hxt-regex-xmlschema/docs/Text-Regex-XMLSchema-String.html#v:mkCompl\"]"
        },
        "index": {
          "description": "Construct the Complement of an r.e whole set of words",
          "hierarchy": "Text Regex XMLSchema String Regex",
          "module": "Text.Regex.XMLSchema.String.Regex",
          "name": "mkCompl",
          "normalized": "GenRegex a-\u003eGenRegex a",
          "package": "hxt-regex-xmlschema",
          "partial": "Compl",
          "signature": "GenRegex l-\u003eGenRegex l",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt-regex-xmlschema/docs/Text-Regex-XMLSchema-String-Regex.html#v:mkCompl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstruct difference r.e.: r1 {\\} r2\n\u003c/p\u003e\u003cp\u003eexample\n\u003c/p\u003e\u003cpre\u003e match \"[a-z]+{\\\\}bush\" \"obama\"     = True\n match \"[a-z]+{\\\\}bush\" \"clinton\"   = True\n match \"[a-z]+{\\\\}bush\" \"bush\"      = False     -- not important any more\n\u003c/pre\u003e",
          "module": "[\"Text.Regex.XMLSchema.String.Regex\",\"Text.Regex.XMLSchema.String\"]",
          "name": "mkDiff",
          "package": "hxt-regex-xmlschema",
          "signature": "GenRegex l -\u003e GenRegex l -\u003e GenRegex l",
          "source": "src/Text-Regex-XMLSchema-String-Regex.html#mkDiff",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt-regex-xmlschema/docs/Text-Regex-XMLSchema-String-Regex.html#v:mkDiff\",\"http://hackage.haskell.org/package/hxt-regex-xmlschema/docs/Text-Regex-XMLSchema-String.html#v:mkDiff\"]"
        },
        "index": {
          "description": "Construct difference r.e r1 r2 example match a-z bush obama True match a-z bush clinton True match a-z bush bush False not important any more",
          "hierarchy": "Text Regex XMLSchema String Regex",
          "module": "Text.Regex.XMLSchema.String.Regex",
          "name": "mkDiff",
          "normalized": "GenRegex a-\u003eGenRegex a-\u003eGenRegex a",
          "package": "hxt-regex-xmlschema",
          "partial": "Diff",
          "signature": "GenRegex l-\u003eGenRegex l-\u003eGenRegex l",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt-regex-xmlschema/docs/Text-Regex-XMLSchema-String-Regex.html#v:mkDiff"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003econstruct an r.e. for the set of all Unicode chars\n\u003c/p\u003e",
          "module": "[\"Text.Regex.XMLSchema.String.Regex\",\"Text.Regex.XMLSchema.String\"]",
          "name": "mkDot",
          "package": "hxt-regex-xmlschema",
          "signature": "GenRegex l",
          "source": "src/Text-Regex-XMLSchema-String-Regex.html#mkDot",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt-regex-xmlschema/docs/Text-Regex-XMLSchema-String-Regex.html#v:mkDot\",\"http://hackage.haskell.org/package/hxt-regex-xmlschema/docs/Text-Regex-XMLSchema-String.html#v:mkDot\"]"
        },
        "index": {
          "description": "construct an r.e for the set of all Unicode chars",
          "hierarchy": "Text Regex XMLSchema String Regex",
          "module": "Text.Regex.XMLSchema.String.Regex",
          "name": "mkDot",
          "package": "hxt-regex-xmlschema",
          "partial": "Dot",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt-regex-xmlschema/docs/Text-Regex-XMLSchema-String-Regex.html#v:mkDot"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003econstruct the r.e. for r1{|}r2 (r1 orElse r2).\n\u003c/p\u003e\u003cp\u003eThis represents the same r.e. as r1|r2, but when\n collecting the results of subexpressions in (...) and r1 succeeds, the\n subexpressions of r2 are discarded, so r1 matches are prioritized\n\u003c/p\u003e\u003cp\u003eexample\n\u003c/p\u003e\u003cpre\u003e splitSubex \"({1}x)|({2}.)\"   \"x\" = ([(\"1\",\"x\"),(\"2\",\"x\")], \"\")\n\n splitSubex \"({1}x){|}({2}.)\" \"x\" = ([(\"1\",\"x\")], \"\")\n\u003c/pre\u003e",
          "module": "[\"Text.Regex.XMLSchema.String.Regex\",\"Text.Regex.XMLSchema.String\"]",
          "name": "mkElse",
          "package": "hxt-regex-xmlschema",
          "signature": "GenRegex l -\u003e GenRegex l -\u003e GenRegex l",
          "source": "src/Text-Regex-XMLSchema-String-Regex.html#mkElse",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt-regex-xmlschema/docs/Text-Regex-XMLSchema-String-Regex.html#v:mkElse\",\"http://hackage.haskell.org/package/hxt-regex-xmlschema/docs/Text-Regex-XMLSchema-String.html#v:mkElse\"]"
        },
        "index": {
          "description": "construct the r.e for r1 r2 r1 orElse r2 This represents the same r.e as r1 r2 but when collecting the results of subexpressions in and r1 succeeds the subexpressions of r2 are discarded so r1 matches are prioritized example splitSubex splitSubex",
          "hierarchy": "Text Regex XMLSchema String Regex",
          "module": "Text.Regex.XMLSchema.String.Regex",
          "name": "mkElse",
          "normalized": "GenRegex a-\u003eGenRegex a-\u003eGenRegex a",
          "package": "hxt-regex-xmlschema",
          "partial": "Else",
          "signature": "GenRegex l-\u003eGenRegex l-\u003eGenRegex l",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt-regex-xmlschema/docs/Text-Regex-XMLSchema-String-Regex.html#v:mkElse"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstruct r.e. for exclusive or: r1 {^} r2\n\u003c/p\u003e\u003cp\u003eexample\n\u003c/p\u003e\u003cpre\u003e match \"[a-c]+{^}[c-d]+\" \"abc\"  = True\n match \"[a-c]+{^}[c-d]+\" \"acdc\" = False\n match \"[a-c]+{^}[c-d]+\" \"ccc\"  = False\n match \"[a-c]+{^}[c-d]+\" \"cdc\"  = True\n\u003c/pre\u003e",
          "module": "[\"Text.Regex.XMLSchema.String.Regex\",\"Text.Regex.XMLSchema.String\"]",
          "name": "mkExor",
          "package": "hxt-regex-xmlschema",
          "signature": "GenRegex l -\u003e GenRegex l -\u003e GenRegex l",
          "source": "src/Text-Regex-XMLSchema-String-Regex.html#mkExor",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt-regex-xmlschema/docs/Text-Regex-XMLSchema-String-Regex.html#v:mkExor\",\"http://hackage.haskell.org/package/hxt-regex-xmlschema/docs/Text-Regex-XMLSchema-String.html#v:mkExor\"]"
        },
        "index": {
          "description": "Construct r.e for exclusive or r1 r2 example match a-c c-d abc True match a-c c-d acdc False match a-c c-d ccc False match a-c c-d cdc True",
          "hierarchy": "Text Regex XMLSchema String Regex",
          "module": "Text.Regex.XMLSchema.String.Regex",
          "name": "mkExor",
          "normalized": "GenRegex a-\u003eGenRegex a-\u003eGenRegex a",
          "package": "hxt-regex-xmlschema",
          "partial": "Exor",
          "signature": "GenRegex l-\u003eGenRegex l-\u003eGenRegex l",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt-regex-xmlschema/docs/Text-Regex-XMLSchema-String-Regex.html#v:mkExor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.XMLSchema.String.Regex",
          "name": "mkInterleave",
          "package": "hxt-regex-xmlschema",
          "signature": "GenRegex l -\u003e GenRegex l -\u003e GenRegex l",
          "source": "src/Text-Regex-XMLSchema-String-Regex.html#mkInterleave",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex XMLSchema String Regex",
          "module": "Text.Regex.XMLSchema.String.Regex",
          "name": "mkInterleave",
          "normalized": "GenRegex a-\u003eGenRegex a-\u003eGenRegex a",
          "package": "hxt-regex-xmlschema",
          "partial": "Interleave",
          "signature": "GenRegex l-\u003eGenRegex l-\u003eGenRegex l",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt-regex-xmlschema/docs/Text-Regex-XMLSchema-String-Regex.html#v:mkInterleave"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstruct r.e. for intersection: r1 {&} r2\n\u003c/p\u003e\u003cp\u003eexample\n\u003c/p\u003e\u003cpre\u003e match \".*a.*{&}.*b.*\" \"-a-b-\"  = True\n match \".*a.*{&}.*b.*\" \"-b-a-\"  = True\n match \".*a.*{&}.*b.*\" \"-a-a-\"  = False\n match \".*a.*{&}.*b.*\" \"---b-\"  = False\n\u003c/pre\u003e",
          "module": "[\"Text.Regex.XMLSchema.String.Regex\",\"Text.Regex.XMLSchema.String\"]",
          "name": "mkIsect",
          "package": "hxt-regex-xmlschema",
          "signature": "GenRegex l -\u003e GenRegex l -\u003e GenRegex l",
          "source": "src/Text-Regex-XMLSchema-String-Regex.html#mkIsect",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt-regex-xmlschema/docs/Text-Regex-XMLSchema-String-Regex.html#v:mkIsect\",\"http://hackage.haskell.org/package/hxt-regex-xmlschema/docs/Text-Regex-XMLSchema-String.html#v:mkIsect\"]"
        },
        "index": {
          "description": "Construct r.e for intersection r1 r2 example match a-b True match b-a True match a-a False match False",
          "hierarchy": "Text Regex XMLSchema String Regex",
          "module": "Text.Regex.XMLSchema.String.Regex",
          "name": "mkIsect",
          "normalized": "GenRegex a-\u003eGenRegex a-\u003eGenRegex a",
          "package": "hxt-regex-xmlschema",
          "partial": "Isect",
          "signature": "GenRegex l-\u003eGenRegex l-\u003eGenRegex l",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt-regex-xmlschema/docs/Text-Regex-XMLSchema-String-Regex.html#v:mkIsect"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstruct option r?\n\u003c/p\u003e",
          "module": "[\"Text.Regex.XMLSchema.String.Regex\",\"Text.Regex.XMLSchema.String\"]",
          "name": "mkOpt",
          "package": "hxt-regex-xmlschema",
          "signature": "GenRegex l -\u003e GenRegex l",
          "source": "src/Text-Regex-XMLSchema-String-Regex.html#mkOpt",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt-regex-xmlschema/docs/Text-Regex-XMLSchema-String-Regex.html#v:mkOpt\",\"http://hackage.haskell.org/package/hxt-regex-xmlschema/docs/Text-Regex-XMLSchema-String.html#v:mkOpt\"]"
        },
        "index": {
          "description": "Construct option",
          "hierarchy": "Text Regex XMLSchema String Regex",
          "module": "Text.Regex.XMLSchema.String.Regex",
          "name": "mkOpt",
          "normalized": "GenRegex a-\u003eGenRegex a",
          "package": "hxt-regex-xmlschema",
          "partial": "Opt",
          "signature": "GenRegex l-\u003eGenRegex l",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt-regex-xmlschema/docs/Text-Regex-XMLSchema-String-Regex.html#v:mkOpt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstruct repetition r{i,}\n\u003c/p\u003e",
          "module": "[\"Text.Regex.XMLSchema.String.Regex\",\"Text.Regex.XMLSchema.String\"]",
          "name": "mkRep",
          "package": "hxt-regex-xmlschema",
          "signature": "Int -\u003e GenRegex l -\u003e GenRegex l",
          "source": "src/Text-Regex-XMLSchema-String-Regex.html#mkRep",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt-regex-xmlschema/docs/Text-Regex-XMLSchema-String-Regex.html#v:mkRep\",\"http://hackage.haskell.org/package/hxt-regex-xmlschema/docs/Text-Regex-XMLSchema-String.html#v:mkRep\"]"
        },
        "index": {
          "description": "Construct repetition",
          "hierarchy": "Text Regex XMLSchema String Regex",
          "module": "Text.Regex.XMLSchema.String.Regex",
          "name": "mkRep",
          "normalized": "Int-\u003eGenRegex a-\u003eGenRegex a",
          "package": "hxt-regex-xmlschema",
          "partial": "Rep",
          "signature": "Int-\u003eGenRegex l-\u003eGenRegex l",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt-regex-xmlschema/docs/Text-Regex-XMLSchema-String-Regex.html#v:mkRep"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstruct range r{i,j}\n\u003c/p\u003e",
          "module": "[\"Text.Regex.XMLSchema.String.Regex\",\"Text.Regex.XMLSchema.String\"]",
          "name": "mkRng",
          "package": "hxt-regex-xmlschema",
          "signature": "Int -\u003e Int -\u003e GenRegex l -\u003e GenRegex l",
          "source": "src/Text-Regex-XMLSchema-String-Regex.html#mkRng",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt-regex-xmlschema/docs/Text-Regex-XMLSchema-String-Regex.html#v:mkRng\",\"http://hackage.haskell.org/package/hxt-regex-xmlschema/docs/Text-Regex-XMLSchema-String.html#v:mkRng\"]"
        },
        "index": {
          "description": "Construct range",
          "hierarchy": "Text Regex XMLSchema String Regex",
          "module": "Text.Regex.XMLSchema.String.Regex",
          "name": "mkRng",
          "normalized": "Int-\u003eInt-\u003eGenRegex a-\u003eGenRegex a",
          "package": "hxt-regex-xmlschema",
          "partial": "Rng",
          "signature": "Int-\u003eInt-\u003eGenRegex l-\u003eGenRegex l",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt-regex-xmlschema/docs/Text-Regex-XMLSchema-String-Regex.html#v:mkRng"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstruct the sequence r.e. r1.r2\n\u003c/p\u003e",
          "module": "[\"Text.Regex.XMLSchema.String.Regex\",\"Text.Regex.XMLSchema.String\"]",
          "name": "mkSeq",
          "package": "hxt-regex-xmlschema",
          "signature": "GenRegex l -\u003e GenRegex l -\u003e GenRegex l",
          "source": "src/Text-Regex-XMLSchema-String-Regex.html#mkSeq",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt-regex-xmlschema/docs/Text-Regex-XMLSchema-String-Regex.html#v:mkSeq\",\"http://hackage.haskell.org/package/hxt-regex-xmlschema/docs/Text-Regex-XMLSchema-String.html#v:mkSeq\"]"
        },
        "index": {
          "description": "Construct the sequence r.e r1.r2",
          "hierarchy": "Text Regex XMLSchema String Regex",
          "module": "Text.Regex.XMLSchema.String.Regex",
          "name": "mkSeq",
          "normalized": "GenRegex a-\u003eGenRegex a-\u003eGenRegex a",
          "package": "hxt-regex-xmlschema",
          "partial": "Seq",
          "signature": "GenRegex l-\u003eGenRegex l-\u003eGenRegex l",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt-regex-xmlschema/docs/Text-Regex-XMLSchema-String-Regex.html#v:mkSeq"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003emkSeq extened to lists\n\u003c/p\u003e",
          "module": "[\"Text.Regex.XMLSchema.String.Regex\",\"Text.Regex.XMLSchema.String\"]",
          "name": "mkSeqs",
          "package": "hxt-regex-xmlschema",
          "signature": "[GenRegex l] -\u003e GenRegex l",
          "source": "src/Text-Regex-XMLSchema-String-Regex.html#mkSeqs",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt-regex-xmlschema/docs/Text-Regex-XMLSchema-String-Regex.html#v:mkSeqs\",\"http://hackage.haskell.org/package/hxt-regex-xmlschema/docs/Text-Regex-XMLSchema-String.html#v:mkSeqs\"]"
        },
        "index": {
          "description": "mkSeq extened to lists",
          "hierarchy": "Text Regex XMLSchema String Regex",
          "module": "Text.Regex.XMLSchema.String.Regex",
          "name": "mkSeqs",
          "normalized": "[GenRegex a]-\u003eGenRegex a",
          "package": "hxt-regex-xmlschema",
          "partial": "Seqs",
          "signature": "[GenRegex l]-\u003eGenRegex l",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt-regex-xmlschema/docs/Text-Regex-XMLSchema-String-Regex.html#v:mkSeqs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003econstruct r.e. for r*\n\u003c/p\u003e",
          "module": "[\"Text.Regex.XMLSchema.String.Regex\",\"Text.Regex.XMLSchema.String\"]",
          "name": "mkStar",
          "package": "hxt-regex-xmlschema",
          "signature": "GenRegex l -\u003e GenRegex l",
          "source": "src/Text-Regex-XMLSchema-String-Regex.html#mkStar",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt-regex-xmlschema/docs/Text-Regex-XMLSchema-String-Regex.html#v:mkStar\",\"http://hackage.haskell.org/package/hxt-regex-xmlschema/docs/Text-Regex-XMLSchema-String.html#v:mkStar\"]"
        },
        "index": {
          "description": "construct r.e for",
          "hierarchy": "Text Regex XMLSchema String Regex",
          "module": "Text.Regex.XMLSchema.String.Regex",
          "name": "mkStar",
          "normalized": "GenRegex a-\u003eGenRegex a",
          "package": "hxt-regex-xmlschema",
          "partial": "Star",
          "signature": "GenRegex l-\u003eGenRegex l",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt-regex-xmlschema/docs/Text-Regex-XMLSchema-String-Regex.html#v:mkStar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003econstruct the r.e. for a set of chars\n\u003c/p\u003e",
          "module": "Text.Regex.XMLSchema.String.Regex",
          "name": "mkSym",
          "package": "hxt-regex-xmlschema",
          "signature": "CharSet -\u003e GenRegex l",
          "source": "src/Text-Regex-XMLSchema-String-Regex.html#mkSym",
          "type": "function"
        },
        "index": {
          "description": "construct the r.e for set of chars",
          "hierarchy": "Text Regex XMLSchema String Regex",
          "module": "Text.Regex.XMLSchema.String.Regex",
          "name": "mkSym",
          "normalized": "CharSet-\u003eGenRegex a",
          "package": "hxt-regex-xmlschema",
          "partial": "Sym",
          "signature": "CharSet-\u003eGenRegex l",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt-regex-xmlschema/docs/Text-Regex-XMLSchema-String-Regex.html#v:mkSym"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003econstruct an r.e. for a single char set\n\u003c/p\u003e",
          "module": "[\"Text.Regex.XMLSchema.String.Regex\",\"Text.Regex.XMLSchema.String\"]",
          "name": "mkSym1",
          "package": "hxt-regex-xmlschema",
          "signature": "Char -\u003e GenRegex l",
          "source": "src/Text-Regex-XMLSchema-String-Regex.html#mkSym1",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt-regex-xmlschema/docs/Text-Regex-XMLSchema-String-Regex.html#v:mkSym1\",\"http://hackage.haskell.org/package/hxt-regex-xmlschema/docs/Text-Regex-XMLSchema-String.html#v:mkSym1\"]"
        },
        "index": {
          "description": "construct an r.e for single char set",
          "hierarchy": "Text Regex XMLSchema String Regex",
          "module": "Text.Regex.XMLSchema.String.Regex",
          "name": "mkSym1",
          "normalized": "Char-\u003eGenRegex a",
          "package": "hxt-regex-xmlschema",
          "partial": "Sym",
          "signature": "Char-\u003eGenRegex l",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt-regex-xmlschema/docs/Text-Regex-XMLSchema-String-Regex.html#v:mkSym1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003econstruct an r.e. for an intervall of chars\n\u003c/p\u003e",
          "module": "[\"Text.Regex.XMLSchema.String.Regex\",\"Text.Regex.XMLSchema.String\"]",
          "name": "mkSymRng",
          "package": "hxt-regex-xmlschema",
          "signature": "Char -\u003e Char -\u003e GenRegex l",
          "source": "src/Text-Regex-XMLSchema-String-Regex.html#mkSymRng",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt-regex-xmlschema/docs/Text-Regex-XMLSchema-String-Regex.html#v:mkSymRng\",\"http://hackage.haskell.org/package/hxt-regex-xmlschema/docs/Text-Regex-XMLSchema-String.html#v:mkSymRng\"]"
        },
        "index": {
          "description": "construct an r.e for an intervall of chars",
          "hierarchy": "Text Regex XMLSchema String Regex",
          "module": "Text.Regex.XMLSchema.String.Regex",
          "name": "mkSymRng",
          "normalized": "Char-\u003eChar-\u003eGenRegex a",
          "package": "hxt-regex-xmlschema",
          "partial": "Sym Rng",
          "signature": "Char-\u003eChar-\u003eGenRegex l",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt-regex-xmlschema/docs/Text-Regex-XMLSchema-String-Regex.html#v:mkSymRng"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003econstruct the r.e. for the set containing the empty word\n\u003c/p\u003e",
          "module": "[\"Text.Regex.XMLSchema.String.Regex\",\"Text.Regex.XMLSchema.String\"]",
          "name": "mkUnit",
          "package": "hxt-regex-xmlschema",
          "signature": "GenRegex l",
          "source": "src/Text-Regex-XMLSchema-String-Regex.html#mkUnit",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt-regex-xmlschema/docs/Text-Regex-XMLSchema-String-Regex.html#v:mkUnit\",\"http://hackage.haskell.org/package/hxt-regex-xmlschema/docs/Text-Regex-XMLSchema-String.html#v:mkUnit\"]"
        },
        "index": {
          "description": "construct the r.e for the set containing the empty word",
          "hierarchy": "Text Regex XMLSchema String Regex",
          "module": "Text.Regex.XMLSchema.String.Regex",
          "name": "mkUnit",
          "package": "hxt-regex-xmlschema",
          "partial": "Unit",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt-regex-xmlschema/docs/Text-Regex-XMLSchema-String-Regex.html#v:mkUnit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003emkSym generaized for strings\n\u003c/p\u003e",
          "module": "[\"Text.Regex.XMLSchema.String.Regex\",\"Text.Regex.XMLSchema.String\"]",
          "name": "mkWord",
          "package": "hxt-regex-xmlschema",
          "signature": "[Char] -\u003e GenRegex l",
          "source": "src/Text-Regex-XMLSchema-String-Regex.html#mkWord",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt-regex-xmlschema/docs/Text-Regex-XMLSchema-String-Regex.html#v:mkWord\",\"http://hackage.haskell.org/package/hxt-regex-xmlschema/docs/Text-Regex-XMLSchema-String.html#v:mkWord\"]"
        },
        "index": {
          "description": "mkSym generaized for strings",
          "hierarchy": "Text Regex XMLSchema String Regex",
          "module": "Text.Regex.XMLSchema.String.Regex",
          "name": "mkWord",
          "normalized": "[Char]-\u003eGenRegex a",
          "package": "hxt-regex-xmlschema",
          "partial": "Word",
          "signature": "[Char]-\u003eGenRegex l",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt-regex-xmlschema/docs/Text-Regex-XMLSchema-String-Regex.html#v:mkWord"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003econstruct the r.e. for the empty set.\n An (error-) message may be attached\n\u003c/p\u003e",
          "module": "[\"Text.Regex.XMLSchema.String.Regex\",\"Text.Regex.XMLSchema.String\"]",
          "name": "mkZero",
          "package": "hxt-regex-xmlschema",
          "signature": "String -\u003e GenRegex l",
          "source": "src/Text-Regex-XMLSchema-String-Regex.html#mkZero",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt-regex-xmlschema/docs/Text-Regex-XMLSchema-String-Regex.html#v:mkZero\",\"http://hackage.haskell.org/package/hxt-regex-xmlschema/docs/Text-Regex-XMLSchema-String.html#v:mkZero\"]"
        },
        "index": {
          "description": "construct the r.e for the empty set An error message may be attached",
          "hierarchy": "Text Regex XMLSchema String Regex",
          "module": "Text.Regex.XMLSchema.String.Regex",
          "name": "mkZero",
          "normalized": "String-\u003eGenRegex a",
          "package": "hxt-regex-xmlschema",
          "partial": "Zero",
          "signature": "String-\u003eGenRegex l",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt-regex-xmlschema/docs/Text-Regex-XMLSchema-String-Regex.html#v:mkZero"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.XMLSchema.String.Regex",
          "name": "nullable",
          "package": "hxt-regex-xmlschema",
          "signature": "GenRegex l -\u003e Bool",
          "source": "src/Text-Regex-XMLSchema-String-Regex.html#nullable",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex XMLSchema String Regex",
          "module": "Text.Regex.XMLSchema.String.Regex",
          "name": "nullable",
          "normalized": "GenRegex a-\u003eBool",
          "package": "hxt-regex-xmlschema",
          "signature": "GenRegex l-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt-regex-xmlschema/docs/Text-Regex-XMLSchema-String-Regex.html#v:nullable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.XMLSchema.String.Regex",
          "name": "nullable'",
          "package": "hxt-regex-xmlschema",
          "signature": "GenRegex l -\u003e Nullable l",
          "source": "src/Text-Regex-XMLSchema-String-Regex.html#nullable%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex XMLSchema String Regex",
          "module": "Text.Regex.XMLSchema.String.Regex",
          "name": "nullable'",
          "normalized": "GenRegex a-\u003eNullable a",
          "package": "hxt-regex-xmlschema",
          "signature": "GenRegex l-\u003eNullable l",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt-regex-xmlschema/docs/Text-Regex-XMLSchema-String-Regex.html#v:nullable-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function wraps the whole regex in a subexpression before starting\n the parse. This is done for getting acces to\n the whole parsed string. Therfore we need one special label, this label\n is the Nothing value, all explicit labels are Just labels.\n\u003c/p\u003e",
          "module": "Text.Regex.XMLSchema.String.Regex",
          "name": "splitWithRegex",
          "package": "hxt-regex-xmlschema",
          "signature": "GenRegex l -\u003e String -\u003e Maybe ([(Label l, String)], String)",
          "source": "src/Text-Regex-XMLSchema-String-Regex.html#splitWithRegex",
          "type": "function"
        },
        "index": {
          "description": "This function wraps the whole regex in subexpression before starting the parse This is done for getting acces to the whole parsed string Therfore we need one special label this label is the Nothing value all explicit labels are Just labels",
          "hierarchy": "Text Regex XMLSchema String Regex",
          "module": "Text.Regex.XMLSchema.String.Regex",
          "name": "splitWithRegex",
          "normalized": "GenRegex a-\u003eString-\u003eMaybe([(Label a,String)],String)",
          "package": "hxt-regex-xmlschema",
          "partial": "With Regex",
          "signature": "GenRegex l-\u003eString-\u003eMaybe([(Label l,String)],String)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt-regex-xmlschema/docs/Text-Regex-XMLSchema-String-Regex.html#v:splitWithRegex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe main scanner function\n\u003c/p\u003e",
          "module": "Text.Regex.XMLSchema.String.Regex",
          "name": "splitWithRegex'",
          "package": "hxt-regex-xmlschema",
          "signature": "GenRegex l -\u003e String -\u003e Maybe (GenRegex l, String)",
          "source": "src/Text-Regex-XMLSchema-String-Regex.html#splitWithRegex%27",
          "type": "function"
        },
        "index": {
          "description": "The main scanner function",
          "hierarchy": "Text Regex XMLSchema String Regex",
          "module": "Text.Regex.XMLSchema.String.Regex",
          "name": "splitWithRegex'",
          "normalized": "GenRegex a-\u003eString-\u003eMaybe(GenRegex a,String)",
          "package": "hxt-regex-xmlschema",
          "partial": "With Regex'",
          "signature": "GenRegex l-\u003eString-\u003eMaybe(GenRegex l,String)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt-regex-xmlschema/docs/Text-Regex-XMLSchema-String-Regex.html#v:splitWithRegex-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.XMLSchema.String.Regex",
          "name": "splitWithRegexCS",
          "package": "hxt-regex-xmlschema",
          "signature": "GenRegex l -\u003e CharSet -\u003e String -\u003e Maybe ([(Label l, String)], String)",
          "source": "src/Text-Regex-XMLSchema-String-Regex.html#splitWithRegexCS",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex XMLSchema String Regex",
          "module": "Text.Regex.XMLSchema.String.Regex",
          "name": "splitWithRegexCS",
          "normalized": "GenRegex a-\u003eCharSet-\u003eString-\u003eMaybe([(Label a,String)],String)",
          "package": "hxt-regex-xmlschema",
          "partial": "With Regex CS",
          "signature": "GenRegex l-\u003eCharSet-\u003eString-\u003eMaybe([(Label l,String)],String)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt-regex-xmlschema/docs/Text-Regex-XMLSchema-String-Regex.html#v:splitWithRegexCS"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003espeedup version for splitWithRegex'\n\u003c/p\u003e\u003cp\u003eThis function checks whether the input starts with a char from FIRST re.\n If this is not the case, the split fails. The FIRST set can be computed once\n for a whole tokenizer and reused by every call of split\n\u003c/p\u003e",
          "module": "Text.Regex.XMLSchema.String.Regex",
          "name": "splitWithRegexCS'",
          "package": "hxt-regex-xmlschema",
          "signature": "GenRegex l -\u003e CharSet -\u003e String -\u003e Maybe (GenRegex l, String)",
          "source": "src/Text-Regex-XMLSchema-String-Regex.html#splitWithRegexCS%27",
          "type": "function"
        },
        "index": {
          "description": "speedup version for splitWithRegex This function checks whether the input starts with char from FIRST re If this is not the case the split fails The FIRST set can be computed once for whole tokenizer and reused by every call of split",
          "hierarchy": "Text Regex XMLSchema String Regex",
          "module": "Text.Regex.XMLSchema.String.Regex",
          "name": "splitWithRegexCS'",
          "normalized": "GenRegex a-\u003eCharSet-\u003eString-\u003eMaybe(GenRegex a,String)",
          "package": "hxt-regex-xmlschema",
          "partial": "With Regex CS'",
          "signature": "GenRegex l-\u003eCharSet-\u003eString-\u003eMaybe(GenRegex l,String)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt-regex-xmlschema/docs/Text-Regex-XMLSchema-String-Regex.html#v:splitWithRegexCS-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eW3C XML Schema Regular Expression Parser\n\u003c/p\u003e\u003cp\u003eThis parser supports the full W3C standard, the\n   complete grammar can be found under \u003ca\u003ehttp://www.w3.org/TR/xmlschema11-2/#regexs\u003c/a\u003e\n   and extensions for all missing set operations, intersection, difference, exclusive or, interleave, complement\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Text.Regex.XMLSchema.String.RegexParser",
          "name": "RegexParser",
          "package": "hxt-regex-xmlschema",
          "source": "src/Text-Regex-XMLSchema-String-RegexParser.html",
          "type": "module"
        },
        "index": {
          "description": "W3C XML Schema Regular Expression Parser This parser supports the full W3C standard the complete grammar can be found under http www.w3.org TR xmlschema11-2 regexs and extensions for all missing set operations intersection difference exclusive or interleave complement",
          "hierarchy": "Text Regex XMLSchema String RegexParser",
          "module": "Text.Regex.XMLSchema.String.RegexParser",
          "name": "RegexParser",
          "package": "hxt-regex-xmlschema",
          "partial": "Regex Parser",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hxt-regex-xmlschema/docs/Text-Regex-XMLSchema-String-RegexParser.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eparse a regular expression surrounded by contenxt spec\n\u003c/p\u003e\u003cp\u003ea leading \u003ccode\u003e^\u003c/code\u003e denotes start of text,\n a trailing \u003ccode\u003e$\u003c/code\u003e denotes end of text,\n a leading \u003ccode\u003e\\\u003c\u003c/code\u003e denotes word start,\n a trailing \u003ccode\u003e\\\u003e\u003c/code\u003e denotes word end.\n\u003c/p\u003e\u003cp\u003eThe 1. param ist the regex parser (\u003ccode\u003e\u003ca\u003eparseRegex\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eparseRegexExt\u003c/a\u003e\u003c/code\u003e)\n\u003c/p\u003e",
          "module": "[\"Text.Regex.XMLSchema.String.RegexParser\",\"Text.Regex.XMLSchema.String\"]",
          "name": "parseContextRegex",
          "package": "hxt-regex-xmlschema",
          "signature": "(String -\u003e Regex) -\u003e String -\u003e Regex",
          "source": "src/Text-Regex-XMLSchema-String-RegexParser.html#parseContextRegex",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt-regex-xmlschema/docs/Text-Regex-XMLSchema-String-RegexParser.html#v:parseContextRegex\",\"http://hackage.haskell.org/package/hxt-regex-xmlschema/docs/Text-Regex-XMLSchema-String.html#v:parseContextRegex\"]"
        },
        "index": {
          "description": "parse regular expression surrounded by contenxt spec leading denotes start of text trailing denotes end of text leading denotes word start trailing denotes word end The param ist the regex parser parseRegex or parseRegexExt",
          "hierarchy": "Text Regex XMLSchema String RegexParser",
          "module": "Text.Regex.XMLSchema.String.RegexParser",
          "name": "parseContextRegex",
          "normalized": "(String-\u003eRegex)-\u003eString-\u003eRegex",
          "package": "hxt-regex-xmlschema",
          "partial": "Context Regex",
          "signature": "(String-\u003eRegex)-\u003eString-\u003eRegex",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt-regex-xmlschema/docs/Text-Regex-XMLSchema-String-RegexParser.html#v:parseContextRegex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eparse a standard W3C XML Schema regular expression\n\u003c/p\u003e",
          "module": "[\"Text.Regex.XMLSchema.String.RegexParser\",\"Text.Regex.XMLSchema.String\"]",
          "name": "parseRegex",
          "package": "hxt-regex-xmlschema",
          "signature": "String -\u003e Regex",
          "source": "src/Text-Regex-XMLSchema-String-RegexParser.html#parseRegex",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt-regex-xmlschema/docs/Text-Regex-XMLSchema-String-RegexParser.html#v:parseRegex\",\"http://hackage.haskell.org/package/hxt-regex-xmlschema/docs/Text-Regex-XMLSchema-String.html#v:parseRegex\"]"
        },
        "index": {
          "description": "parse standard W3C XML Schema regular expression",
          "hierarchy": "Text Regex XMLSchema String RegexParser",
          "module": "Text.Regex.XMLSchema.String.RegexParser",
          "name": "parseRegex",
          "normalized": "String-\u003eRegex",
          "package": "hxt-regex-xmlschema",
          "partial": "Regex",
          "signature": "String-\u003eRegex",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt-regex-xmlschema/docs/Text-Regex-XMLSchema-String-RegexParser.html#v:parseRegex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eparse an extended syntax W3C XML Schema regular expression\n\u003c/p\u003e\u003cp\u003eThe Syntax of the W3C XML Schema spec is extended by\n further useful set operations, like intersection, difference, exor.\n Subexpression match becomes possible with \"named\" pairs of parentheses.\n The multi char escape sequence \\a represents any Unicode char,\n The multi char escape sequence \\A represents any Unicode word, (\\A = \\a*).\n All syntactically wrong inputs are mapped to the Zero expression representing the\n empty set of words. Zero contains as data field a string for an error message.\n So error checking after parsing becomes possible by checking against Zero (\u003ccode\u003e\u003ca\u003eisZero\u003c/a\u003e\u003c/code\u003e predicate)\n\u003c/p\u003e",
          "module": "[\"Text.Regex.XMLSchema.String.RegexParser\",\"Text.Regex.XMLSchema.String\"]",
          "name": "parseRegexExt",
          "package": "hxt-regex-xmlschema",
          "signature": "String -\u003e Regex",
          "source": "src/Text-Regex-XMLSchema-String-RegexParser.html#parseRegexExt",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt-regex-xmlschema/docs/Text-Regex-XMLSchema-String-RegexParser.html#v:parseRegexExt\",\"http://hackage.haskell.org/package/hxt-regex-xmlschema/docs/Text-Regex-XMLSchema-String.html#v:parseRegexExt\"]"
        },
        "index": {
          "description": "parse an extended syntax W3C XML Schema regular expression The Syntax of the W3C XML Schema spec is extended by further useful set operations like intersection difference exor Subexpression match becomes possible with named pairs of parentheses The multi char escape sequence represents any Unicode char The multi char escape sequence represents any Unicode word All syntactically wrong inputs are mapped to the Zero expression representing the empty set of words Zero contains as data field string for an error message So error checking after parsing becomes possible by checking against Zero isZero predicate",
          "hierarchy": "Text Regex XMLSchema String RegexParser",
          "module": "Text.Regex.XMLSchema.String.RegexParser",
          "name": "parseRegexExt",
          "normalized": "String-\u003eRegex",
          "package": "hxt-regex-xmlschema",
          "partial": "Regex Ext",
          "signature": "String-\u003eRegex",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt-regex-xmlschema/docs/Text-Regex-XMLSchema-String-RegexParser.html#v:parseRegexExt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eConvenient functions for W3C XML Schema Regular Expression Matcher.\n   For internals see \u003ccode\u003e\u003ca\u003eRegex\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e\u003cp\u003eGrammar can be found under \u003ca\u003ehttp://www.w3.org/TR/xmlschema11-2/#regexs\u003c/a\u003e\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Text.Regex.XMLSchema.String",
          "name": "String",
          "package": "hxt-regex-xmlschema",
          "source": "src/Text-Regex-XMLSchema-String.html",
          "type": "module"
        },
        "index": {
          "description": "Convenient functions for W3C XML Schema Regular Expression Matcher For internals see Regex Grammar can be found under http www.w3.org TR xmlschema11-2 regexs",
          "hierarchy": "Text Regex XMLSchema String",
          "module": "Text.Regex.XMLSchema.String",
          "name": "String",
          "package": "hxt-regex-xmlschema",
          "partial": "String",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hxt-regex-xmlschema/docs/Text-Regex-XMLSchema-String.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.XMLSchema.String",
          "name": "GenRegex",
          "package": "hxt-regex-xmlschema",
          "source": "src/Text-Regex-XMLSchema-String-Regex.html#GenRegex",
          "type": "data"
        },
        "index": {
          "hierarchy": "Text Regex XMLSchema String",
          "module": "Text.Regex.XMLSchema.String",
          "name": "GenRegex",
          "package": "hxt-regex-xmlschema",
          "partial": "Gen Regex",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/hxt-regex-xmlschema/docs/Text-Regex-XMLSchema-String.html#t:GenRegex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.XMLSchema.String",
          "name": "Regex",
          "package": "hxt-regex-xmlschema",
          "source": "src/Text-Regex-XMLSchema-String-Regex.html#Regex",
          "type": "type"
        },
        "index": {
          "hierarchy": "Text Regex XMLSchema String",
          "module": "Text.Regex.XMLSchema.String",
          "name": "Regex",
          "package": "hxt-regex-xmlschema",
          "partial": "Regex",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/hxt-regex-xmlschema/docs/Text-Regex-XMLSchema-String.html#t:Regex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003egrep like filter for lists of strings\n\u003c/p\u003e\u003cp\u003eThe regular expression may be prefixed with the usual context spec \"^\" for start of string,\n and \u003ca\u003e\\\u003c\u003c/a\u003e for start of word.\n and suffixed with \"$\" for end of text and \u003ca\u003e\\\u003e\u003c/a\u003e end of word.\n Word chars are defined by the multi char escape sequence \u003ca\u003e\\w\u003c/a\u003e\n\u003c/p\u003e\u003cp\u003eExamples\n\u003c/p\u003e\u003cpre\u003e grep \"a\"    [\"_a_\", \"_a\", \"a_\", \"a\", \"_\"]      =\u003e [\"_a_\", \"_a\", \"a_\", \"a\"]\n grep \"^a\"   [\"_a_\", \"_a\", \"a_\", \"a\", \"_\"]      =\u003e [\"a_\", \"a\"]\n grep \"a$\"   [\"_a_\", \"_a\", \"a_\", \"a\", \"_\"]      =\u003e [\"_a\", \"a\"]\n grep \"^a$\"  [\"_a_\", \"_a\", \"a_\", \"a\", \"_\"]      =\u003e [\"a\"]\n grep \"\\\\\u003ca\" [\"x a b\", \" ax \", \" xa \", \"xab\"]   =\u003e [\"x a b\", \" ax \"]\n grep \"a\\\\\u003e\" [\"x a b\", \" ax \", \" xa \", \"xab\"]   =\u003e [\"x a b\", \" xa \"]\n\u003c/pre\u003e",
          "module": "Text.Regex.XMLSchema.String",
          "name": "grep",
          "package": "hxt-regex-xmlschema",
          "signature": "String -\u003e [String] -\u003e [String]",
          "source": "src/Text-Regex-XMLSchema-String.html#grep",
          "type": "function"
        },
        "index": {
          "description": "grep like filter for lists of strings The regular expression may be prefixed with the usual context spec for start of string and for start of word and suffixed with for end of text and end of word Word chars are defined by the multi char escape sequence Examples grep grep grep grep grep ax xa xab ax grep ax xa xab xa",
          "hierarchy": "Text Regex XMLSchema String",
          "module": "Text.Regex.XMLSchema.String",
          "name": "grep",
          "normalized": "String-\u003e[String]-\u003e[String]",
          "package": "hxt-regex-xmlschema",
          "signature": "String-\u003e[String]-\u003e[String]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt-regex-xmlschema/docs/Text-Regex-XMLSchema-String.html#v:grep"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003egrep with extended regular expressions\n\u003c/p\u003e",
          "module": "Text.Regex.XMLSchema.String",
          "name": "grepExt",
          "package": "hxt-regex-xmlschema",
          "signature": "String -\u003e [String] -\u003e [String]",
          "source": "src/Text-Regex-XMLSchema-String.html#grepExt",
          "type": "function"
        },
        "index": {
          "description": "grep with extended regular expressions",
          "hierarchy": "Text Regex XMLSchema String",
          "module": "Text.Regex.XMLSchema.String",
          "name": "grepExt",
          "normalized": "String-\u003e[String]-\u003e[String]",
          "package": "hxt-regex-xmlschema",
          "partial": "Ext",
          "signature": "String-\u003e[String]-\u003e[String]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt-regex-xmlschema/docs/Text-Regex-XMLSchema-String.html#v:grepExt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003egrep with already prepared Regex (ususally with \u003ccode\u003e\u003ca\u003eparseContextRegex\u003c/a\u003e\u003c/code\u003e)\n\u003c/p\u003e",
          "module": "Text.Regex.XMLSchema.String",
          "name": "grepRE",
          "package": "hxt-regex-xmlschema",
          "signature": "Regex -\u003e [String] -\u003e [String]",
          "source": "src/Text-Regex-XMLSchema-String.html#grepRE",
          "type": "function"
        },
        "index": {
          "description": "grep with already prepared Regex ususally with parseContextRegex",
          "hierarchy": "Text Regex XMLSchema String",
          "module": "Text.Regex.XMLSchema.String",
          "name": "grepRE",
          "normalized": "Regex-\u003e[String]-\u003e[String]",
          "package": "hxt-regex-xmlschema",
          "partial": "RE",
          "signature": "Regex-\u003e[String]-\u003e[String]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt-regex-xmlschema/docs/Text-Regex-XMLSchema-String.html#v:grepRE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003egrep with Regex and line numbers\n\u003c/p\u003e",
          "module": "Text.Regex.XMLSchema.String",
          "name": "grepREwithLineNum",
          "package": "hxt-regex-xmlschema",
          "signature": "Regex -\u003e [String] -\u003e [(Int, String)]",
          "source": "src/Text-Regex-XMLSchema-String.html#grepREwithLineNum",
          "type": "function"
        },
        "index": {
          "description": "grep with Regex and line numbers",
          "hierarchy": "Text Regex XMLSchema String",
          "module": "Text.Regex.XMLSchema.String",
          "name": "grepREwithLineNum",
          "normalized": "Regex-\u003e[String]-\u003e[(Int,String)]",
          "package": "hxt-regex-xmlschema",
          "partial": "REwith Line Num",
          "signature": "Regex-\u003e[String]-\u003e[(Int,String)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt-regex-xmlschema/docs/Text-Regex-XMLSchema-String.html#v:grepREwithLineNum"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003econvenient function for \u003ccode\u003e\u003ca\u003ematchRE\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e\u003cp\u003eExamples:\n\u003c/p\u003e\u003cpre\u003e match \"x*\" \"xxx\" = True\n match \"x\" \"xxx\"  = False\n match \"[\" \"xxx\"  = False\n\u003c/pre\u003e",
          "module": "Text.Regex.XMLSchema.String",
          "name": "match",
          "package": "hxt-regex-xmlschema",
          "signature": "String -\u003e String -\u003e Bool",
          "source": "src/Text-Regex-XMLSchema-String.html#match",
          "type": "function"
        },
        "index": {
          "description": "convenient function for matchRE Examples match xxx True match xxx False match xxx False",
          "hierarchy": "Text Regex XMLSchema String",
          "module": "Text.Regex.XMLSchema.String",
          "name": "match",
          "normalized": "String-\u003eString-\u003eBool",
          "package": "hxt-regex-xmlschema",
          "signature": "String-\u003eString-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt-regex-xmlschema/docs/Text-Regex-XMLSchema-String.html#v:match"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ematch with extended regular expressions\n\u003c/p\u003e",
          "module": "Text.Regex.XMLSchema.String",
          "name": "matchExt",
          "package": "hxt-regex-xmlschema",
          "signature": "String -\u003e String -\u003e Bool",
          "source": "src/Text-Regex-XMLSchema-String.html#matchExt",
          "type": "function"
        },
        "index": {
          "description": "match with extended regular expressions",
          "hierarchy": "Text Regex XMLSchema String",
          "module": "Text.Regex.XMLSchema.String",
          "name": "matchExt",
          "normalized": "String-\u003eString-\u003eBool",
          "package": "hxt-regex-xmlschema",
          "partial": "Ext",
          "signature": "String-\u003eString-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt-regex-xmlschema/docs/Text-Regex-XMLSchema-String.html#v:matchExt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ematch a string with a regular expression\n\u003c/p\u003e",
          "module": "Text.Regex.XMLSchema.String",
          "name": "matchRE",
          "package": "hxt-regex-xmlschema",
          "signature": "GenRegex l -\u003e String -\u003e Bool",
          "source": "src/Text-Regex-XMLSchema-String.html#matchRE",
          "type": "function"
        },
        "index": {
          "description": "match string with regular expression",
          "hierarchy": "Text Regex XMLSchema String",
          "module": "Text.Regex.XMLSchema.String",
          "name": "matchRE",
          "normalized": "GenRegex a-\u003eString-\u003eBool",
          "package": "hxt-regex-xmlschema",
          "partial": "RE",
          "signature": "GenRegex l-\u003eString-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt-regex-xmlschema/docs/Text-Regex-XMLSchema-String.html#v:matchRE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003econvenient function for \u003ccode\u003e\u003ca\u003ematchRE\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e\u003cp\u003eExamples:\n\u003c/p\u003e\u003cpre\u003e matchSubex \"({1}x*)\"                 \"xxx\"      = [(\"1\",\"xxx\")]\n matchSubex \"({1}x*)\"                 \"y\"        = []\n matchSubex \"({w}[0-9]+)x({h}[0-9]+)\" \"800x600\"  = [(\"w\",\"800\"),(\"h\",\"600\")]\n matchSubex \"[\" \"xxx\"                            = []\n\u003c/pre\u003e",
          "module": "Text.Regex.XMLSchema.String",
          "name": "matchSubex",
          "package": "hxt-regex-xmlschema",
          "signature": "String -\u003e String -\u003e [(String, String)]",
          "source": "src/Text-Regex-XMLSchema-String.html#matchSubex",
          "type": "function"
        },
        "index": {
          "description": "convenient function for matchRE Examples matchSubex xxx xxx matchSubex matchSubex x600 matchSubex xxx",
          "hierarchy": "Text Regex XMLSchema String",
          "module": "Text.Regex.XMLSchema.String",
          "name": "matchSubex",
          "normalized": "String-\u003eString-\u003e[(String,String)]",
          "package": "hxt-regex-xmlschema",
          "partial": "Subex",
          "signature": "String-\u003eString-\u003e[(String,String)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt-regex-xmlschema/docs/Text-Regex-XMLSchema-String.html#v:matchSubex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ematch a string with a regular expression\n and extract subexpression matches\n\u003c/p\u003e",
          "module": "Text.Regex.XMLSchema.String",
          "name": "matchSubexRE",
          "package": "hxt-regex-xmlschema",
          "signature": "GenRegex l -\u003e String -\u003e [(l, String)]",
          "source": "src/Text-Regex-XMLSchema-String.html#matchSubexRE",
          "type": "function"
        },
        "index": {
          "description": "match string with regular expression and extract subexpression matches",
          "hierarchy": "Text Regex XMLSchema String",
          "module": "Text.Regex.XMLSchema.String",
          "name": "matchSubexRE",
          "normalized": "GenRegex a-\u003eString-\u003e[(a,String)]",
          "package": "hxt-regex-xmlschema",
          "partial": "Subex RE",
          "signature": "GenRegex l-\u003eString-\u003e[(l,String)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt-regex-xmlschema/docs/Text-Regex-XMLSchema-String.html#v:matchSubexRE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003econvenient function for \u003ccode\u003e\u003ca\u003esedRE\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e\u003cp\u003eexamples:\n\u003c/p\u003e\u003cpre\u003e sed (const \"b\") \"a\" \"xaxax\"       = \"xbxbx\"\n sed (\\ x -\u003e x ++ x) \"a\" \"xax\"     = \"xaax\"\n sed undefined       \"[\" \"xxx\"     = \"xxx\"\n\u003c/pre\u003e",
          "module": "Text.Regex.XMLSchema.String",
          "name": "sed",
          "package": "hxt-regex-xmlschema",
          "signature": "(String -\u003e String) -\u003e String -\u003e String -\u003e String",
          "source": "src/Text-Regex-XMLSchema-String.html#sed",
          "type": "function"
        },
        "index": {
          "description": "convenient function for sedRE examples sed const xaxax xbxbx sed xax xaax sed undefined xxx xxx",
          "hierarchy": "Text Regex XMLSchema String",
          "module": "Text.Regex.XMLSchema.String",
          "name": "sed",
          "normalized": "(String-\u003eString)-\u003eString-\u003eString-\u003eString",
          "package": "hxt-regex-xmlschema",
          "signature": "(String-\u003eString)-\u003eString-\u003eString-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt-regex-xmlschema/docs/Text-Regex-XMLSchema-String.html#v:sed"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.XMLSchema.String",
          "name": "sedExt",
          "package": "hxt-regex-xmlschema",
          "signature": "(String -\u003e String) -\u003e String -\u003e String -\u003e String",
          "source": "src/Text-Regex-XMLSchema-String.html#sedExt",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex XMLSchema String",
          "module": "Text.Regex.XMLSchema.String",
          "name": "sedExt",
          "normalized": "(String-\u003eString)-\u003eString-\u003eString-\u003eString",
          "package": "hxt-regex-xmlschema",
          "partial": "Ext",
          "signature": "(String-\u003eString)-\u003eString-\u003eString-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt-regex-xmlschema/docs/Text-Regex-XMLSchema-String.html#v:sedExt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003esed like editing function\n\u003c/p\u003e\u003cp\u003eAll matching tokens are edited by the 1. argument, the editing function,\n all other chars remain as they are\n\u003c/p\u003e",
          "module": "Text.Regex.XMLSchema.String",
          "name": "sedRE",
          "package": "hxt-regex-xmlschema",
          "signature": "(String -\u003e String) -\u003e GenRegex l -\u003e String -\u003e String",
          "source": "src/Text-Regex-XMLSchema-String.html#sedRE",
          "type": "function"
        },
        "index": {
          "description": "sed like editing function All matching tokens are edited by the argument the editing function all other chars remain as they are",
          "hierarchy": "Text Regex XMLSchema String",
          "module": "Text.Regex.XMLSchema.String",
          "name": "sedRE",
          "normalized": "(String-\u003eString)-\u003eGenRegex a-\u003eString-\u003eString",
          "package": "hxt-regex-xmlschema",
          "partial": "RE",
          "signature": "(String-\u003eString)-\u003eGenRegex l-\u003eString-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt-regex-xmlschema/docs/Text-Regex-XMLSchema-String.html#v:sedRE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003econvenient function for \u003ccode\u003e\u003ca\u003esplitRE\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e\u003cp\u003eexamples:\n\u003c/p\u003e\u003cpre\u003e split \"a*b\" \"abc\" = (\"ab\",\"c\")\n split \"a*\"  \"bc\"  = (\"\", \"bc\")    -- \"a*\" matches \"\"\n split \"a+\"  \"bc\"  = (\"\", \"bc\")    -- \"a+\" does not match, no split\n split \"[\"   \"abc\" = (\"\", \"abc\")   -- \"[\"  syntax error, no split\n\u003c/pre\u003e",
          "module": "Text.Regex.XMLSchema.String",
          "name": "split",
          "package": "hxt-regex-xmlschema",
          "signature": "String -\u003e String -\u003e (String, String)",
          "source": "src/Text-Regex-XMLSchema-String.html#split",
          "type": "function"
        },
        "index": {
          "description": "convenient function for splitRE examples split abc ab split bc bc matches split bc bc does not match no split split abc abc syntax error no split",
          "hierarchy": "Text Regex XMLSchema String",
          "module": "Text.Regex.XMLSchema.String",
          "name": "split",
          "normalized": "String-\u003eString-\u003e(String,String)",
          "package": "hxt-regex-xmlschema",
          "signature": "String-\u003eString-\u003e(String,String)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt-regex-xmlschema/docs/Text-Regex-XMLSchema-String.html#v:split"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003esplit with extended syntax\n\u003c/p\u003e",
          "module": "Text.Regex.XMLSchema.String",
          "name": "splitExt",
          "package": "hxt-regex-xmlschema",
          "signature": "String -\u003e String -\u003e (String, String)",
          "source": "src/Text-Regex-XMLSchema-String.html#splitExt",
          "type": "function"
        },
        "index": {
          "description": "split with extended syntax",
          "hierarchy": "Text Regex XMLSchema String",
          "module": "Text.Regex.XMLSchema.String",
          "name": "splitExt",
          "normalized": "String-\u003eString-\u003e(String,String)",
          "package": "hxt-regex-xmlschema",
          "partial": "Ext",
          "signature": "String-\u003eString-\u003e(String,String)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt-regex-xmlschema/docs/Text-Regex-XMLSchema-String.html#v:splitExt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003esplit a string by taking the longest prefix matching a regular expression\n\u003c/p\u003e\u003cp\u003e\u003ccode\u003eNothing\u003c/code\u003e is returned in case there is no matching prefix,\n else the pair of prefix and rest is returned\n\u003c/p\u003e",
          "module": "Text.Regex.XMLSchema.String",
          "name": "splitRE",
          "package": "hxt-regex-xmlschema",
          "signature": "GenRegex l -\u003e String -\u003e Maybe (String, String)",
          "source": "src/Text-Regex-XMLSchema-String.html#splitRE",
          "type": "function"
        },
        "index": {
          "description": "split string by taking the longest prefix matching regular expression Nothing is returned in case there is no matching prefix else the pair of prefix and rest is returned",
          "hierarchy": "Text Regex XMLSchema String",
          "module": "Text.Regex.XMLSchema.String",
          "name": "splitRE",
          "normalized": "GenRegex a-\u003eString-\u003eMaybe(String,String)",
          "package": "hxt-regex-xmlschema",
          "partial": "RE",
          "signature": "GenRegex l-\u003eString-\u003eMaybe(String,String)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt-regex-xmlschema/docs/Text-Regex-XMLSchema-String.html#v:splitRE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003econvenient function for \u003ccode\u003e\u003ca\u003esplitSubex\u003c/a\u003e\u003c/code\u003e, uses extended syntax\n\u003c/p\u003e\u003cp\u003eexamples:\n\u003c/p\u003e\u003cpre\u003e splitSubex \"({1}a*)b\"  \"abc\" = ([(\"1\",\"a\")],\"c\")\n splitSubex \"({2}a*)\"   \"bc\"  = ([(\"2\",\"\")], \"bc\")\n splitSubex \"({1}a|b)+\" \"abc\" = ([(\"1\",\"a\"),(\"1\",\"b\")],\"c\")        -- subex 1 matches 2 times\n\n splitSubex \".*({x}a*)\" \"aa\"  = ([(\"x\",\"\"),(\"x\",\"a\"),(\"x\",\"aa\")],\"\")\n                                                                   -- nondeterminism: 3 matches for a*\n\n splitSubex \"({1}do)|({2}[a-z]+)\" \"do you know\"\n                                = ([(\"1\",\"do\"),(\"2\",\"do\")],\" you know\")\n                                                                   -- nondeterminism: 2 matches for do\n\n splitSubex \"({1}do){|}({2}[a-z]+)\" \"do you know\"\n                                = ([(\"1\",\"do\")],\" you know\")\n                                                                   -- no nondeterminism with {|}: 1. match for do\n\n splitSubex \"({1}a+)\"   \"bcd\" = ([], \"bcd\")                        -- no match\n splitSubex \"[\"         \"abc\" = ([], \"abc\")                        -- syntax error\n\u003c/pre\u003e",
          "module": "Text.Regex.XMLSchema.String",
          "name": "splitSubex",
          "package": "hxt-regex-xmlschema",
          "signature": "String -\u003e String -\u003e ([(String, String)], String)",
          "source": "src/Text-Regex-XMLSchema-String.html#splitSubex",
          "type": "function"
        },
        "index": {
          "description": "convenient function for splitSubex uses extended syntax examples splitSubex abc splitSubex bc bc splitSubex abc subex matches times splitSubex aa aa nondeterminism matches for splitSubex do a-z do you know do do you know nondeterminism matches for do splitSubex do a-z do you know do you know no nondeterminism with match for do splitSubex bcd bcd no match splitSubex abc abc syntax error",
          "hierarchy": "Text Regex XMLSchema String",
          "module": "Text.Regex.XMLSchema.String",
          "name": "splitSubex",
          "normalized": "String-\u003eString-\u003e([(String,String)],String)",
          "package": "hxt-regex-xmlschema",
          "partial": "Subex",
          "signature": "String-\u003eString-\u003e([(String,String)],String)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt-regex-xmlschema/docs/Text-Regex-XMLSchema-String.html#v:splitSubex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003esplit a string by removing the longest prefix matching a regular expression\n and then return the list of subexpressions found in the matching part\n\u003c/p\u003e\u003cp\u003e\u003ccode\u003eNothing\u003c/code\u003e is returned in case of no matching prefix,\n else the list of pairs of labels and submatches and the\n rest is returned\n\u003c/p\u003e",
          "module": "Text.Regex.XMLSchema.String",
          "name": "splitSubexRE",
          "package": "hxt-regex-xmlschema",
          "signature": "GenRegex l -\u003e String -\u003e Maybe ([(l, String)], String)",
          "source": "src/Text-Regex-XMLSchema-String.html#splitSubexRE",
          "type": "function"
        },
        "index": {
          "description": "split string by removing the longest prefix matching regular expression and then return the list of subexpressions found in the matching part Nothing is returned in case of no matching prefix else the list of pairs of labels and submatches and the rest is returned",
          "hierarchy": "Text Regex XMLSchema String",
          "module": "Text.Regex.XMLSchema.String",
          "name": "splitSubexRE",
          "normalized": "GenRegex a-\u003eString-\u003eMaybe([(a,String)],String)",
          "package": "hxt-regex-xmlschema",
          "partial": "Subex RE",
          "signature": "GenRegex l-\u003eString-\u003eMaybe([(l,String)],String)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt-regex-xmlschema/docs/Text-Regex-XMLSchema-String.html#v:splitSubexRE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003esplit a string into tokens (words) by giving a regular expression\n which all tokens must match.\n\u003c/p\u003e\u003cp\u003eConvenient function for \u003ccode\u003e\u003ca\u003etokenizeRE\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e\u003cp\u003eThis can be used for simple tokenizers.\n It is recommended to use regular expressions where the empty word does not match.\n Else there will appear a lot of probably useless empty tokens in the output.\n All none matching chars are discarded. If the given regex contains syntax errors,\n \u003ccode\u003eNothing\u003c/code\u003e is returned\n\u003c/p\u003e\u003cp\u003eexamples:\n\u003c/p\u003e\u003cpre\u003e tokenize \"a\" \"aabba\"      = [\"a\",\"a\",\"a\"]\n tokenize \"a*\" \"aaaba\"     = [\"aaa\",\"a\"]\n tokenize \"a*\" \"bbb\"       = [\"\",\"\",\"\"]\n tokenize \"a+\" \"bbb\"       = []\n\n tokenize \"a*b\" \"\"         = []\n tokenize \"a*b\" \"abc\"      = [\"ab\"]\n tokenize \"a*b\" \"abaab ab\" = [\"ab\",\"aab\",\"ab\"]\n\n tokenize \"[a-z]{2,}|[0-9]{2,}|[0-9]+[.][0-9]+\" \"ab123 456.7abc\"\n                           = [\"ab\",\"123\",\"456.7\",\"abc\"]\n\n tokenize \"[a-z]*|[0-9]{2,}|[0-9]+[.][0-9]+\" \"cab123 456.7abc\"\n                           = [\"cab\",\"123\",\"456.7\",\"abc\"]\n\n tokenize \"[^ \\t\\n\\r]*\" \"abc def\\t\\n\\rxyz\"\n                           = [\"abc\",\"def\",\"xyz\"]\n\n tokenize \".*\"   \"\\nabc\\n123\\n\\nxyz\\n\"\n                           = [\"\",\"abc\",\"123\",\"\",\"xyz\"]\n\n tokenize \".*\"             = lines\n\n tokenize \"[^ \\t\\n\\r]*\"    = words\n\u003c/pre\u003e",
          "module": "Text.Regex.XMLSchema.String",
          "name": "tokenize",
          "package": "hxt-regex-xmlschema",
          "signature": "String -\u003e String -\u003e [String]",
          "source": "src/Text-Regex-XMLSchema-String.html#tokenize",
          "type": "function"
        },
        "index": {
          "description": "split string into tokens words by giving regular expression which all tokens must match Convenient function for tokenizeRE This can be used for simple tokenizers It is recommended to use regular expressions where the empty word does not match Else there will appear lot of probably useless empty tokens in the output All none matching chars are discarded If the given regex contains syntax errors Nothing is returned examples tokenize aabba tokenize aaaba aaa tokenize bbb tokenize bbb tokenize tokenize abc ab tokenize abaab ab ab aab ab tokenize a-z ab123 abc ab abc tokenize a-z cab123 abc cab abc tokenize abc def rxyz abc def xyz tokenize nabc n123 nxyz abc xyz tokenize lines tokenize words",
          "hierarchy": "Text Regex XMLSchema String",
          "module": "Text.Regex.XMLSchema.String",
          "name": "tokenize",
          "normalized": "String-\u003eString-\u003e[String]",
          "package": "hxt-regex-xmlschema",
          "signature": "String-\u003eString-\u003e[String]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt-regex-xmlschema/docs/Text-Regex-XMLSchema-String.html#v:tokenize"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003econvenient function for \u003ccode\u003e\u003ca\u003etokenizeRE'\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e\u003cp\u003eWhen the regular expression parses as Zero, \u003ccode\u003e[Left input]\u003c/code\u003e is returned, that means no tokens are found\n\u003c/p\u003e",
          "module": "Text.Regex.XMLSchema.String",
          "name": "tokenize'",
          "package": "hxt-regex-xmlschema",
          "signature": "String -\u003e String -\u003e [Either String String]",
          "source": "src/Text-Regex-XMLSchema-String.html#tokenize%27",
          "type": "function"
        },
        "index": {
          "description": "convenient function for tokenizeRE When the regular expression parses as Zero Left input is returned that means no tokens are found",
          "hierarchy": "Text Regex XMLSchema String",
          "module": "Text.Regex.XMLSchema.String",
          "name": "tokenize'",
          "normalized": "String-\u003eString-\u003e[Either String String]",
          "package": "hxt-regex-xmlschema",
          "signature": "String-\u003eString-\u003e[Either String String]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt-regex-xmlschema/docs/Text-Regex-XMLSchema-String.html#v:tokenize-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003etokenize with extended syntax\n\u003c/p\u003e",
          "module": "Text.Regex.XMLSchema.String",
          "name": "tokenizeExt",
          "package": "hxt-regex-xmlschema",
          "signature": "String -\u003e String -\u003e [String]",
          "source": "src/Text-Regex-XMLSchema-String.html#tokenizeExt",
          "type": "function"
        },
        "index": {
          "description": "tokenize with extended syntax",
          "hierarchy": "Text Regex XMLSchema String",
          "module": "Text.Regex.XMLSchema.String",
          "name": "tokenizeExt",
          "normalized": "String-\u003eString-\u003e[String]",
          "package": "hxt-regex-xmlschema",
          "partial": "Ext",
          "signature": "String-\u003eString-\u003e[String]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt-regex-xmlschema/docs/Text-Regex-XMLSchema-String.html#v:tokenizeExt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.XMLSchema.String",
          "name": "tokenizeExt'",
          "package": "hxt-regex-xmlschema",
          "signature": "String -\u003e String -\u003e [Either String String]",
          "source": "src/Text-Regex-XMLSchema-String.html#tokenizeExt%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex XMLSchema String",
          "module": "Text.Regex.XMLSchema.String",
          "name": "tokenizeExt'",
          "normalized": "String-\u003eString-\u003e[Either String String]",
          "package": "hxt-regex-xmlschema",
          "partial": "Ext'",
          "signature": "String-\u003eString-\u003e[Either String String]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt-regex-xmlschema/docs/Text-Regex-XMLSchema-String.html#v:tokenizeExt-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe function, that does the real work for \u003ccode\u003e\u003ca\u003etokenize\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Text.Regex.XMLSchema.String",
          "name": "tokenizeRE",
          "package": "hxt-regex-xmlschema",
          "signature": "GenRegex l -\u003e String -\u003e [String]",
          "source": "src/Text-Regex-XMLSchema-String.html#tokenizeRE",
          "type": "function"
        },
        "index": {
          "description": "The function that does the real work for tokenize",
          "hierarchy": "Text Regex XMLSchema String",
          "module": "Text.Regex.XMLSchema.String",
          "name": "tokenizeRE",
          "normalized": "GenRegex a-\u003eString-\u003e[String]",
          "package": "hxt-regex-xmlschema",
          "partial": "RE",
          "signature": "GenRegex l-\u003eString-\u003e[String]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt-regex-xmlschema/docs/Text-Regex-XMLSchema-String.html#v:tokenizeRE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003esplit a string into tokens and delimierter by giving a regular expression\n wich all tokens must match\n\u003c/p\u003e\u003cp\u003eThis is a generalisation of the above \u003ccode\u003e\u003ca\u003etokenizeRE\u003c/a\u003e\u003c/code\u003e functions.\n The none matching char sequences are marked with \u003ccode\u003eLeft\u003c/code\u003e, the matching ones are marked with \u003ccode\u003eRight\u003c/code\u003e\n\u003c/p\u003e\u003cp\u003eIf the regular expression contains syntax errors \u003ccode\u003eNothing\u003c/code\u003e is returned\n\u003c/p\u003e\u003cp\u003eThe following Law holds:\n\u003c/p\u003e\u003cpre\u003e concat . map (either id id) . tokenizeRE' re == id\n\u003c/pre\u003e",
          "module": "Text.Regex.XMLSchema.String",
          "name": "tokenizeRE'",
          "package": "hxt-regex-xmlschema",
          "signature": "GenRegex l -\u003e String -\u003e [Either String String]",
          "source": "src/Text-Regex-XMLSchema-String.html#tokenizeRE%27",
          "type": "function"
        },
        "index": {
          "description": "split string into tokens and delimierter by giving regular expression wich all tokens must match This is generalisation of the above tokenizeRE functions The none matching char sequences are marked with Left the matching ones are marked with Right If the regular expression contains syntax errors Nothing is returned The following Law holds concat map either id id tokenizeRE re id",
          "hierarchy": "Text Regex XMLSchema String",
          "module": "Text.Regex.XMLSchema.String",
          "name": "tokenizeRE'",
          "normalized": "GenRegex a-\u003eString-\u003e[Either String String]",
          "package": "hxt-regex-xmlschema",
          "partial": "RE'",
          "signature": "GenRegex l-\u003eString-\u003e[Either String String]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt-regex-xmlschema/docs/Text-Regex-XMLSchema-String.html#v:tokenizeRE-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003econvenient function for \u003ccode\u003e\u003ca\u003etokenizeSubexRE\u003c/a\u003e\u003c/code\u003e a string\n\u003c/p\u003e\u003cp\u003eexamples:\n\u003c/p\u003e\u003cpre\u003e tokenizeSubex \"({name}[a-z]+)|({num}[0-9]{2,})|({real}[0-9]+[.][0-9]+)\"\n                 \"cab123 456.7abc\"\n                                  = [(\"name\",\"cab\")\n                                    ,(\"num\",\"123\")\n                                    ,(\"real\",\"456.7\")\n                                    ,(\"name\",\"abc\")]\n\n tokenizeSubex \"({real}({n}[0-9]+)([.]({f}[0-9]+))?)\"\n                 \"12.34\"          = [(\"real\",\"12.34\")\n                                    ,(\"n\",\"12\")\n                                    ,(\"f\",\"34\")]\n\n tokenizeSubex \"({real}({n}[0-9]+)([.]({f}[0-9]+))?)\"\n                  \"12 34\"         = [(\"real\",\"12\"),(\"n\",\"12\")\n                                    ,(\"real\",\"34\"),(\"n\",\"34\")]\n\n tokenizeSubex \"({real}({n}[0-9]+)(([.]({f}[0-9]+))|({f})))\"\n                  \"12 34.56\"      = [(\"real\",\"12\"),(\"n\",\"12\"),(\"f\",\"\")\n                                    ,(\"real\",\"34.56\"),(\"n\",\"34\"),(\"f\",\"56\")]\n\u003c/pre\u003e",
          "module": "Text.Regex.XMLSchema.String",
          "name": "tokenizeSubex",
          "package": "hxt-regex-xmlschema",
          "signature": "String -\u003e String -\u003e [(String, String)]",
          "source": "src/Text-Regex-XMLSchema-String.html#tokenizeSubex",
          "type": "function"
        },
        "index": {
          "description": "convenient function for tokenizeSubexRE string examples tokenizeSubex name a-z num real cab123 abc name cab num real name abc tokenizeSubex real real tokenizeSubex real real real tokenizeSubex real real real",
          "hierarchy": "Text Regex XMLSchema String",
          "module": "Text.Regex.XMLSchema.String",
          "name": "tokenizeSubex",
          "normalized": "String-\u003eString-\u003e[(String,String)]",
          "package": "hxt-regex-xmlschema",
          "partial": "Subex",
          "signature": "String-\u003eString-\u003e[(String,String)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt-regex-xmlschema/docs/Text-Regex-XMLSchema-String.html#v:tokenizeSubex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003esplit a string into tokens (pair of labels and words) by giving a regular expression\n containing labeled subexpressions.\n\u003c/p\u003e\u003cp\u003eThis function should not be called with regular expressions\n without any labeled subexpressions. This does not make sense, because the result list\n will always be empty.\n\u003c/p\u003e\u003cp\u003eResult is the list of matching subexpressions\n This can be used for simple tokenizers.\n At least one char is consumed by parsing a token.\n The pairs in the result list contain the matching substrings.\n All none matching chars are discarded. If the given regex contains syntax errors,\n \u003ccode\u003eNothing\u003c/code\u003e is returned\n\u003c/p\u003e",
          "module": "Text.Regex.XMLSchema.String",
          "name": "tokenizeSubexRE",
          "package": "hxt-regex-xmlschema",
          "signature": "GenRegex l -\u003e String -\u003e [(l, String)]",
          "source": "src/Text-Regex-XMLSchema-String.html#tokenizeSubexRE",
          "type": "function"
        },
        "index": {
          "description": "split string into tokens pair of labels and words by giving regular expression containing labeled subexpressions This function should not be called with regular expressions without any labeled subexpressions This does not make sense because the result list will always be empty Result is the list of matching subexpressions This can be used for simple tokenizers At least one char is consumed by parsing token The pairs in the result list contain the matching substrings All none matching chars are discarded If the given regex contains syntax errors Nothing is returned",
          "hierarchy": "Text Regex XMLSchema String",
          "module": "Text.Regex.XMLSchema.String",
          "name": "tokenizeSubexRE",
          "normalized": "GenRegex a-\u003eString-\u003e[(a,String)]",
          "package": "hxt-regex-xmlschema",
          "partial": "Subex RE",
          "signature": "GenRegex l-\u003eString-\u003e[(l,String)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt-regex-xmlschema/docs/Text-Regex-XMLSchema-String.html#v:tokenizeSubexRE"
      }
    }
  ]
]