[
  {
    "cmd": "delete-by-query",
    "query": {
      "contexts": [
        "package"
      ],
      "query": {
        "op": "case",
        "type": "word",
        "word": "combinat"
      },
      "type": "context"
    }
  },
  [
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eCombinations.\n This module is depracated; it is equivalent to the module \u003ca\u003eCompositions\u003c/a\u003e, \n but it turns out that \"compositions\" is the accepted name. I will\n remove this module in the future.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Math.Combinat.Combinations",
          "name": "Combinations",
          "package": "combinat",
          "source": "src/Math-Combinat-Combinations.html",
          "type": "module"
        },
        "index": {
          "description": "Combinations This module is depracated it is equivalent to the module Compositions but it turns out that compositions is the accepted name will remove this module in the future",
          "hierarchy": "Math Combinat Combinations",
          "module": "Math.Combinat.Combinations",
          "name": "Combinations",
          "package": "combinat",
          "partial": "Combinations",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Combinations.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAll combinations fitting into a given shape.\n\u003c/p\u003e",
          "module": "Math.Combinat.Combinations",
          "name": "allCombinations'",
          "package": "combinat",
          "signature": "[Int] -\u003e [[[Int]]]",
          "source": "src/Math-Combinat-Combinations.html#allCombinations%27",
          "type": "function"
        },
        "index": {
          "description": "All combinations fitting into given shape",
          "hierarchy": "Math Combinat Combinations",
          "module": "Math.Combinat.Combinations",
          "name": "allCombinations'",
          "normalized": "[Int]-\u003e[[[Int]]]",
          "package": "combinat",
          "partial": "Combinations'",
          "signature": "[Int]-\u003e[[[Int]]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Combinations.html#v:allCombinations-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCombinations of a given length.\n\u003c/p\u003e",
          "module": "Math.Combinat.Combinations",
          "name": "combinations",
          "package": "combinat",
          "signature": "Int-\u003e Int-\u003e [[Int]]",
          "type": "function"
        },
        "index": {
          "description": "Combinations of given length",
          "hierarchy": "Math Combinat Combinations",
          "module": "Math.Combinat.Combinations",
          "name": "combinations",
          "normalized": "Int-\u003eInt-\u003e[[Int]]",
          "package": "combinat",
          "signature": "Int-\u003eInt-\u003e[[Int]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Combinations.html#v:combinations"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCombinations fitting into a given shape and having a given degree.\n   The order is lexicographic, that is, \n\u003c/p\u003e\u003cpre\u003e sort cs == cs where cs = combinations' shape k\n\u003c/pre\u003e",
          "module": "Math.Combinat.Combinations",
          "name": "combinations'",
          "package": "combinat",
          "signature": "[Int]-\u003e Int-\u003e [[Int]]",
          "type": "function"
        },
        "index": {
          "description": "Combinations fitting into given shape and having given degree The order is lexicographic that is sort cs cs where cs combinations shape",
          "hierarchy": "Math Combinat Combinations",
          "module": "Math.Combinat.Combinations",
          "name": "combinations'",
          "normalized": "[Int]-\u003eInt-\u003e[[Int]]",
          "package": "combinat",
          "signature": "[Int]-\u003eInt-\u003e[[Int]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Combinations.html#v:combinations-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePositive combinations of a given length.\n\u003c/p\u003e",
          "module": "Math.Combinat.Combinations",
          "name": "combinations1",
          "package": "combinat",
          "signature": "Int-\u003e Int-\u003e [[Int]]",
          "type": "function"
        },
        "index": {
          "description": "Positive combinations of given length",
          "hierarchy": "Math Combinat Combinations",
          "module": "Math.Combinat.Combinations",
          "name": "combinations1",
          "normalized": "Int-\u003eInt-\u003e[[Int]]",
          "package": "combinat",
          "signature": "Int-\u003eInt-\u003e[[Int]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Combinations.html#v:combinations1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e# = \\binom { len+d-1 } { len-1 }\n\u003c/p\u003e",
          "module": "Math.Combinat.Combinations",
          "name": "countCombinations",
          "package": "combinat",
          "signature": "Int -\u003e Int -\u003e Integer",
          "source": "src/Math-Combinat-Combinations.html#countCombinations",
          "type": "function"
        },
        "index": {
          "description": "binom len d-1 len-1",
          "hierarchy": "Math Combinat Combinations",
          "module": "Math.Combinat.Combinations",
          "name": "countCombinations",
          "normalized": "Int-\u003eInt-\u003eInteger",
          "package": "combinat",
          "partial": "Combinations",
          "signature": "Int-\u003eInt-\u003eInteger",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Combinations.html#v:countCombinations"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinat.Combinations",
          "name": "countCombinations'",
          "package": "combinat",
          "signature": "[Int] -\u003e Int -\u003e Integer",
          "source": "src/Math-Combinat-Combinations.html#countCombinations%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinat Combinations",
          "module": "Math.Combinat.Combinations",
          "name": "countCombinations'",
          "normalized": "[Int]-\u003eInt-\u003eInteger",
          "package": "combinat",
          "partial": "Combinations'",
          "signature": "[Int]-\u003eInt-\u003eInteger",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Combinations.html#v:countCombinations-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinat.Combinations",
          "name": "countCombinations1",
          "package": "combinat",
          "signature": "Int -\u003e Int -\u003e Integer",
          "source": "src/Math-Combinat-Combinations.html#countCombinations1",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinat Combinations",
          "module": "Math.Combinat.Combinations",
          "name": "countCombinations1",
          "normalized": "Int-\u003eInt-\u003eInteger",
          "package": "combinat",
          "partial": "Combinations",
          "signature": "Int-\u003eInt-\u003eInteger",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Combinations.html#v:countCombinations1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eCompositions. \n This module is equivalent to the module \u003ca\u003eCombinations\u003c/a\u003e, \n but it turns out that \"compositions\" is the accepted name. I will\n remove the \u003ca\u003eCombinations\u003c/a\u003e module in the future.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Math.Combinat.Compositions",
          "name": "Compositions",
          "package": "combinat",
          "source": "src/Math-Combinat-Compositions.html",
          "type": "module"
        },
        "index": {
          "description": "Compositions This module is equivalent to the module Combinations but it turns out that compositions is the accepted name will remove the Combinations module in the future",
          "hierarchy": "Math Combinat Compositions",
          "module": "Math.Combinat.Compositions",
          "name": "Compositions",
          "package": "combinat",
          "partial": "Compositions",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Compositions.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAll compositions fitting into a given shape.\n\u003c/p\u003e",
          "module": "Math.Combinat.Compositions",
          "name": "allCompositions'",
          "package": "combinat",
          "signature": "[Int] -\u003e [[[Int]]]",
          "source": "src/Math-Combinat-Compositions.html#allCompositions%27",
          "type": "function"
        },
        "index": {
          "description": "All compositions fitting into given shape",
          "hierarchy": "Math Combinat Compositions",
          "module": "Math.Combinat.Compositions",
          "name": "allCompositions'",
          "normalized": "[Int]-\u003e[[[Int]]]",
          "package": "combinat",
          "partial": "Compositions'",
          "signature": "[Int]-\u003e[[[Int]]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Compositions.html#v:allCompositions-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCompositions of a given length.\n\u003c/p\u003e",
          "module": "Math.Combinat.Compositions",
          "name": "compositions",
          "package": "combinat",
          "signature": "a-\u003e a-\u003e [[Int]]",
          "type": "function"
        },
        "index": {
          "description": "Compositions of given length",
          "hierarchy": "Math Combinat Compositions",
          "module": "Math.Combinat.Compositions",
          "name": "compositions",
          "normalized": "a-\u003ea-\u003e[[Int]]",
          "package": "combinat",
          "signature": "a-\u003ea-\u003e[[Int]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Compositions.html#v:compositions"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCompositions fitting into a given shape and having a given degree.\n   The order is lexicographic, that is, \n\u003c/p\u003e\u003cpre\u003e sort cs == cs where cs = compositions' shape k\n\u003c/pre\u003e",
          "module": "Math.Combinat.Compositions",
          "name": "compositions'",
          "package": "combinat",
          "signature": "[Int]-\u003e Int-\u003e [[Int]]",
          "type": "function"
        },
        "index": {
          "description": "Compositions fitting into given shape and having given degree The order is lexicographic that is sort cs cs where cs compositions shape",
          "hierarchy": "Math Combinat Compositions",
          "module": "Math.Combinat.Compositions",
          "name": "compositions'",
          "normalized": "[Int]-\u003eInt-\u003e[[Int]]",
          "package": "combinat",
          "signature": "[Int]-\u003eInt-\u003e[[Int]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Compositions.html#v:compositions-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePositive compositions of a given length.\n\u003c/p\u003e",
          "module": "Math.Combinat.Compositions",
          "name": "compositions1",
          "package": "combinat",
          "signature": "a-\u003e a-\u003e [[Int]]",
          "type": "function"
        },
        "index": {
          "description": "Positive compositions of given length",
          "hierarchy": "Math Combinat Compositions",
          "module": "Math.Combinat.Compositions",
          "name": "compositions1",
          "normalized": "a-\u003ea-\u003e[[Int]]",
          "package": "combinat",
          "signature": "a-\u003ea-\u003e[[Int]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Compositions.html#v:compositions1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e# = \\binom { len+d-1 } { len-1 }\n\u003c/p\u003e",
          "module": "Math.Combinat.Compositions",
          "name": "countCompositions",
          "package": "combinat",
          "signature": "a -\u003e a -\u003e Integer",
          "source": "src/Math-Combinat-Compositions.html#countCompositions",
          "type": "function"
        },
        "index": {
          "description": "binom len d-1 len-1",
          "hierarchy": "Math Combinat Compositions",
          "module": "Math.Combinat.Compositions",
          "name": "countCompositions",
          "normalized": "a-\u003ea-\u003eInteger",
          "package": "combinat",
          "partial": "Compositions",
          "signature": "a-\u003ea-\u003eInteger",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Compositions.html#v:countCompositions"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinat.Compositions",
          "name": "countCompositions'",
          "package": "combinat",
          "signature": "[Int] -\u003e Int -\u003e Integer",
          "source": "src/Math-Combinat-Compositions.html#countCompositions%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinat Compositions",
          "module": "Math.Combinat.Compositions",
          "name": "countCompositions'",
          "normalized": "[Int]-\u003eInt-\u003eInteger",
          "package": "combinat",
          "partial": "Compositions'",
          "signature": "[Int]-\u003eInt-\u003eInteger",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Compositions.html#v:countCompositions-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinat.Compositions",
          "name": "countCompositions1",
          "package": "combinat",
          "signature": "a -\u003e a -\u003e Integer",
          "source": "src/Math-Combinat-Compositions.html#countCompositions1",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinat Compositions",
          "module": "Math.Combinat.Compositions",
          "name": "countCompositions1",
          "normalized": "a-\u003ea-\u003eInteger",
          "package": "combinat",
          "partial": "Compositions",
          "signature": "a-\u003ea-\u003eInteger",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Compositions.html#v:countCompositions1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eCreates graphviz \u003ccode\u003e.dot\u003c/code\u003e files from various structures, for example trees.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Math.Combinat.Graphviz",
          "name": "Graphviz",
          "package": "combinat",
          "source": "src/Math-Combinat-Graphviz.html",
          "type": "module"
        },
        "index": {
          "description": "Creates graphviz dot files from various structures for example trees",
          "hierarchy": "Math Combinat Graphviz",
          "module": "Math.Combinat.Graphviz",
          "name": "Graphviz",
          "package": "combinat",
          "partial": "Graphviz",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Graphviz.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinat.Graphviz",
          "name": "Dot",
          "package": "combinat",
          "source": "src/Math-Combinat-Graphviz.html#Dot",
          "type": "type"
        },
        "index": {
          "hierarchy": "Math Combinat Graphviz",
          "module": "Math.Combinat.Graphviz",
          "name": "Dot",
          "package": "combinat",
          "partial": "Dot",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Graphviz.html#t:Dot"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinat.Graphviz",
          "name": "binTree'Dot",
          "package": "combinat",
          "signature": "String -\u003e BinTree' a b -\u003e Dot",
          "source": "src/Math-Combinat-Graphviz.html#binTree%27Dot",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinat Graphviz",
          "module": "Math.Combinat.Graphviz",
          "name": "binTree'Dot",
          "normalized": "String-\u003eBinTree' a b-\u003eDot",
          "package": "combinat",
          "partial": "Tree' Dot",
          "signature": "String-\u003eBinTree' a b-\u003eDot",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Graphviz.html#v:binTree-39-Dot"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinat.Graphviz",
          "name": "binTreeDot",
          "package": "combinat",
          "signature": "String -\u003e BinTree a -\u003e Dot",
          "source": "src/Math-Combinat-Graphviz.html#binTreeDot",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinat Graphviz",
          "module": "Math.Combinat.Graphviz",
          "name": "binTreeDot",
          "normalized": "String-\u003eBinTree a-\u003eDot",
          "package": "combinat",
          "partial": "Tree Dot",
          "signature": "String-\u003eBinTree a-\u003eDot",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Graphviz.html#v:binTreeDot"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGenerates graphviz \u003ccode\u003e.dot\u003c/code\u003e file from a forest. The first argument tells whether\n to make the individual trees clustered subgraphs; the second is the name of the\n graph.\n\u003c/p\u003e",
          "module": "Math.Combinat.Graphviz",
          "name": "forestDot",
          "package": "combinat",
          "signature": "Bool-\u003e Bool-\u003e String-\u003e Forest a-\u003e Dot",
          "type": "function"
        },
        "index": {
          "description": "Generates graphviz dot file from forest The first argument tells whether to make the individual trees clustered subgraphs the second is the name of the graph",
          "hierarchy": "Math Combinat Graphviz",
          "module": "Math.Combinat.Graphviz",
          "name": "forestDot",
          "normalized": "Bool-\u003eBool-\u003eString-\u003eForest a-\u003eDot",
          "package": "combinat",
          "partial": "Dot",
          "signature": "Bool-\u003eBool-\u003eString-\u003eForest a-\u003eDot",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Graphviz.html#v:forestDot"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGenerates graphviz \u003ccode\u003e.dot\u003c/code\u003e file from a tree. The first argument is\n the name of the graph.\n\u003c/p\u003e",
          "module": "Math.Combinat.Graphviz",
          "name": "treeDot",
          "package": "combinat",
          "signature": "Bool-\u003e String-\u003e Tree a-\u003e Dot",
          "type": "function"
        },
        "index": {
          "description": "Generates graphviz dot file from tree The first argument is the name of the graph",
          "hierarchy": "Math Combinat Graphviz",
          "module": "Math.Combinat.Graphviz",
          "name": "treeDot",
          "normalized": "Bool-\u003eString-\u003eTree a-\u003eDot",
          "package": "combinat",
          "partial": "Dot",
          "signature": "Bool-\u003eString-\u003eTree a-\u003eDot",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Graphviz.html#v:treeDot"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003ePrime numbers and related number theoretical stuff.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Math.Combinat.Numbers.Primes",
          "name": "Primes",
          "package": "combinat",
          "source": "src/Math-Combinat-Numbers-Primes.html",
          "type": "module"
        },
        "index": {
          "description": "Prime numbers and related number theoretical stuff",
          "hierarchy": "Math Combinat Numbers Primes",
          "module": "Math.Combinat.Numbers.Primes",
          "name": "Primes",
          "package": "combinat",
          "partial": "Primes",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Numbers-Primes.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSmallest integer \u003ccode\u003ek\u003c/code\u003e such that \u003ccode\u003e2^k\u003c/code\u003e is larger or equal to \u003ccode\u003en\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Math.Combinat.Numbers.Primes",
          "name": "ceilingLog2",
          "package": "combinat",
          "signature": "Integer -\u003e Integer",
          "source": "src/Math-Combinat-Numbers-Primes.html#ceilingLog2",
          "type": "function"
        },
        "index": {
          "description": "Smallest integer such that is larger or equal to",
          "hierarchy": "Math Combinat Numbers Primes",
          "module": "Math.Combinat.Numbers.Primes",
          "name": "ceilingLog2",
          "normalized": "Integer-\u003eInteger",
          "package": "combinat",
          "partial": "Log",
          "signature": "Integer-\u003eInteger",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Numbers-Primes.html#v:ceilingLog2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSmallest integer whose square is larger or equal to the input\n\u003c/p\u003e",
          "module": "Math.Combinat.Numbers.Primes",
          "name": "ceilingSquareRoot",
          "package": "combinat",
          "signature": "Integer -\u003e Integer",
          "source": "src/Math-Combinat-Numbers-Primes.html#ceilingSquareRoot",
          "type": "function"
        },
        "index": {
          "description": "Smallest integer whose square is larger or equal to the input",
          "hierarchy": "Math Combinat Numbers Primes",
          "module": "Math.Combinat.Numbers.Primes",
          "name": "ceilingSquareRoot",
          "normalized": "Integer-\u003eInteger",
          "package": "combinat",
          "partial": "Square Root",
          "signature": "Integer-\u003eInteger",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Numbers-Primes.html#v:ceilingSquareRoot"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGroups integer factors. Example: from [2,2,2,3,3,5] we produce [(2,3),(3,2),(5,1)]  \n\u003c/p\u003e",
          "module": "Math.Combinat.Numbers.Primes",
          "name": "groupIntegerFactors",
          "package": "combinat",
          "signature": "[Integer] -\u003e [(Integer, Int)]",
          "source": "src/Math-Combinat-Numbers-Primes.html#groupIntegerFactors",
          "type": "function"
        },
        "index": {
          "description": "Groups integer factors Example from we produce",
          "hierarchy": "Math Combinat Numbers Primes",
          "module": "Math.Combinat.Numbers.Primes",
          "name": "groupIntegerFactors",
          "normalized": "[Integer]-\u003e[(Integer,Int)]",
          "package": "combinat",
          "partial": "Integer Factors",
          "signature": "[Integer]-\u003e[(Integer,Int)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Numbers-Primes.html#v:groupIntegerFactors"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe naive trial division algorithm.\n\u003c/p\u003e",
          "module": "Math.Combinat.Numbers.Primes",
          "name": "integerFactorsTrialDivision",
          "package": "combinat",
          "signature": "Integer -\u003e [Integer]",
          "source": "src/Math-Combinat-Numbers-Primes.html#integerFactorsTrialDivision",
          "type": "function"
        },
        "index": {
          "description": "The naive trial division algorithm",
          "hierarchy": "Math Combinat Numbers Primes",
          "module": "Math.Combinat.Numbers.Primes",
          "name": "integerFactorsTrialDivision",
          "normalized": "Integer-\u003e[Integer]",
          "package": "combinat",
          "partial": "Factors Trial Division",
          "signature": "Integer-\u003e[Integer]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Numbers-Primes.html#v:integerFactorsTrialDivision"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLargest integer \u003ccode\u003ek\u003c/code\u003e such that \u003ccode\u003e2^k\u003c/code\u003e is smaller or equal to \u003ccode\u003en\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Math.Combinat.Numbers.Primes",
          "name": "integerLog2",
          "package": "combinat",
          "signature": "Integer -\u003e Integer",
          "source": "src/Math-Combinat-Numbers-Primes.html#integerLog2",
          "type": "function"
        },
        "index": {
          "description": "Largest integer such that is smaller or equal to",
          "hierarchy": "Math Combinat Numbers Primes",
          "module": "Math.Combinat.Numbers.Primes",
          "name": "integerLog2",
          "normalized": "Integer-\u003eInteger",
          "package": "combinat",
          "partial": "Log",
          "signature": "Integer-\u003eInteger",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Numbers-Primes.html#v:integerLog2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInteger square root (largest integer whose square is smaller or equal to the input)\n using Newton's method, with a faster (for large numbers) inital guess based on bit shifts.\n\u003c/p\u003e",
          "module": "Math.Combinat.Numbers.Primes",
          "name": "integerSquareRoot",
          "package": "combinat",
          "signature": "Integer -\u003e Integer",
          "source": "src/Math-Combinat-Numbers-Primes.html#integerSquareRoot",
          "type": "function"
        },
        "index": {
          "description": "Integer square root largest integer whose square is smaller or equal to the input using Newton method with faster for large numbers inital guess based on bit shifts",
          "hierarchy": "Math Combinat Numbers Primes",
          "module": "Math.Combinat.Numbers.Primes",
          "name": "integerSquareRoot",
          "normalized": "Integer-\u003eInteger",
          "package": "combinat",
          "partial": "Square Root",
          "signature": "Integer-\u003eInteger",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Numbers-Primes.html#v:integerSquareRoot"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWe also return the excess residue; that is\n\u003c/p\u003e\u003cpre\u003e (a,r) = integerSquareRoot' n\n\u003c/pre\u003e\u003cp\u003emeans that\n\u003c/p\u003e\u003cpre\u003e a*a + r = n\n a*a \u003c= n \u003c (a+1)*(a+1)\n\u003c/pre\u003e",
          "module": "Math.Combinat.Numbers.Primes",
          "name": "integerSquareRoot'",
          "package": "combinat",
          "signature": "Integer -\u003e (Integer, Integer)",
          "source": "src/Math-Combinat-Numbers-Primes.html#integerSquareRoot%27",
          "type": "function"
        },
        "index": {
          "description": "We also return the excess residue that is integerSquareRoot means that",
          "hierarchy": "Math Combinat Numbers Primes",
          "module": "Math.Combinat.Numbers.Primes",
          "name": "integerSquareRoot'",
          "normalized": "Integer-\u003e(Integer,Integer)",
          "package": "combinat",
          "partial": "Square Root'",
          "signature": "Integer-\u003e(Integer,Integer)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Numbers-Primes.html#v:integerSquareRoot-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eNewton's method without an initial guess. For very small numbers (\u003c10^10) it\n is somewhat faster than the above version.\n\u003c/p\u003e",
          "module": "Math.Combinat.Numbers.Primes",
          "name": "integerSquareRootNewton'",
          "package": "combinat",
          "signature": "Integer -\u003e (Integer, Integer)",
          "source": "src/Math-Combinat-Numbers-Primes.html#integerSquareRootNewton%27",
          "type": "function"
        },
        "index": {
          "description": "Newton method without an initial guess For very small numbers it is somewhat faster than the above version",
          "hierarchy": "Math Combinat Numbers Primes",
          "module": "Math.Combinat.Numbers.Primes",
          "name": "integerSquareRootNewton'",
          "normalized": "Integer-\u003e(Integer,Integer)",
          "package": "combinat",
          "partial": "Square Root Newton'",
          "signature": "Integer-\u003e(Integer,Integer)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Numbers-Primes.html#v:integerSquareRootNewton-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinat.Numbers.Primes",
          "name": "isSquare",
          "package": "combinat",
          "signature": "Integer -\u003e Bool",
          "source": "src/Math-Combinat-Numbers-Primes.html#isSquare",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinat Numbers Primes",
          "module": "Math.Combinat.Numbers.Primes",
          "name": "isSquare",
          "normalized": "Integer-\u003eBool",
          "package": "combinat",
          "partial": "Square",
          "signature": "Integer-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Numbers-Primes.html#v:isSquare"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMiller-Rabin Primality Test (taken from Haskell wiki). \n We test the primality of the first argument \u003ccode\u003en\u003c/code\u003e by using the second argument \u003ccode\u003ea\u003c/code\u003e as a candidate witness.\n If it returs \u003ccode\u003eFalse\u003c/code\u003e, then \u003ccode\u003en\u003c/code\u003e is composite. If it returns \u003ccode\u003eTrue\u003c/code\u003e, then \u003ccode\u003en\u003c/code\u003e is either prime or composite.\n\u003c/p\u003e\u003cp\u003eA random choice between \u003ccode\u003e2\u003c/code\u003e and \u003ccode\u003e(n-2)\u003c/code\u003e is a good choice for \u003ccode\u003ea\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Math.Combinat.Numbers.Primes",
          "name": "millerRabinPrimalityTest",
          "package": "combinat",
          "signature": "Integer -\u003e Integer -\u003e Bool",
          "source": "src/Math-Combinat-Numbers-Primes.html#millerRabinPrimalityTest",
          "type": "function"
        },
        "index": {
          "description": "Miller-Rabin Primality Test taken from Haskell wiki We test the primality of the first argument by using the second argument as candidate witness If it returs False then is composite If it returns True then is either prime or composite random choice between and n-2 is good choice for",
          "hierarchy": "Math Combinat Numbers Primes",
          "module": "Math.Combinat.Numbers.Primes",
          "name": "millerRabinPrimalityTest",
          "normalized": "Integer-\u003eInteger-\u003eBool",
          "package": "combinat",
          "partial": "Rabin Primality Test",
          "signature": "Integer-\u003eInteger-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Numbers-Primes.html#v:millerRabinPrimalityTest"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEfficient powers modulo m.\n\u003c/p\u003e\u003cpre\u003e powerMod a k m == (a^k) `mod` m\n\u003c/pre\u003e",
          "module": "Math.Combinat.Numbers.Primes",
          "name": "powerMod",
          "package": "combinat",
          "signature": "Integer -\u003e Integer -\u003e Integer -\u003e Integer",
          "source": "src/Math-Combinat-Numbers-Primes.html#powerMod",
          "type": "function"
        },
        "index": {
          "description": "Efficient powers modulo powerMod mod",
          "hierarchy": "Math Combinat Numbers Primes",
          "module": "Math.Combinat.Numbers.Primes",
          "name": "powerMod",
          "normalized": "Integer-\u003eInteger-\u003eInteger-\u003eInteger",
          "package": "combinat",
          "partial": "Mod",
          "signature": "Integer-\u003eInteger-\u003eInteger-\u003eInteger",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Numbers-Primes.html#v:powerMod"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInfinite list of primes, using the TMWE algorithm.\n\u003c/p\u003e",
          "module": "Math.Combinat.Numbers.Primes",
          "name": "primes",
          "package": "combinat",
          "signature": "[Integer]",
          "source": "src/Math-Combinat-Numbers-Primes.html#primes",
          "type": "function"
        },
        "index": {
          "description": "Infinite list of primes using the TMWE algorithm",
          "hierarchy": "Math Combinat Numbers Primes",
          "module": "Math.Combinat.Numbers.Primes",
          "name": "primes",
          "normalized": "[Integer]",
          "package": "combinat",
          "signature": "[Integer]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Numbers-Primes.html#v:primes"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA relatively simple but still quite fast implementation of list of primes.\n By Will Ness \u003ca\u003ehttp://www.haskell.org/pipermail/haskell-cafe/2009-November/068441.html\u003c/a\u003e\n\u003c/p\u003e",
          "module": "Math.Combinat.Numbers.Primes",
          "name": "primesSimple",
          "package": "combinat",
          "signature": "[Integer]",
          "source": "src/Math-Combinat-Numbers-Primes.html#primesSimple",
          "type": "function"
        },
        "index": {
          "description": "relatively simple but still quite fast implementation of list of primes By Will Ness http www.haskell.org pipermail haskell-cafe November html",
          "hierarchy": "Math Combinat Numbers Primes",
          "module": "Math.Combinat.Numbers.Primes",
          "name": "primesSimple",
          "normalized": "[Integer]",
          "package": "combinat",
          "partial": "Simple",
          "signature": "[Integer]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Numbers-Primes.html#v:primesSimple"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eList of primes, using tree merge with wheel. Code by Will Ness.\n\u003c/p\u003e",
          "module": "Math.Combinat.Numbers.Primes",
          "name": "primesTMWE",
          "package": "combinat",
          "signature": "[Integer]",
          "source": "src/Math-Combinat-Numbers-Primes.html#primesTMWE",
          "type": "function"
        },
        "index": {
          "description": "List of primes using tree merge with wheel Code by Will Ness",
          "hierarchy": "Math Combinat Numbers Primes",
          "module": "Math.Combinat.Numbers.Primes",
          "name": "primesTMWE",
          "normalized": "[Integer]",
          "package": "combinat",
          "partial": "TMWE",
          "signature": "[Integer]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Numbers-Primes.html#v:primesTMWE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eSome basic power series expansions.\n This module is not re-exported by \u003ca\u003eMath.Combinat\u003c/a\u003e.\n\u003c/p\u003e\u003cp\u003eNote: the \"\u003ccode\u003econvolveWithXXX\u003c/code\u003e\" functions are much faster than the equivalent\n \u003ccode\u003e(XXX `convolve`)\u003c/code\u003e!\n\u003c/p\u003e\u003cp\u003eTODO: better names for these functions.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Math.Combinat.Numbers.Series",
          "name": "Series",
          "package": "combinat",
          "source": "src/Math-Combinat-Numbers-Series.html",
          "type": "module"
        },
        "index": {
          "description": "Some basic power series expansions This module is not re-exported by Math.Combinat Note the convolveWithXXX functions are much faster than the equivalent XXX convolve TODO better names for these functions",
          "hierarchy": "Math Combinat Numbers Series",
          "module": "Math.Combinat.Numbers.Series",
          "name": "Series",
          "package": "combinat",
          "partial": "Series",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Numbers-Series.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinat.Numbers.Series",
          "name": "Sign",
          "package": "combinat",
          "source": "src/Math-Combinat-Numbers-Series.html#Sign",
          "type": "data"
        },
        "index": {
          "hierarchy": "Math Combinat Numbers Series",
          "module": "Math.Combinat.Numbers.Series",
          "name": "Sign",
          "package": "combinat",
          "partial": "Sign",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Numbers-Series.html#t:Sign"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinat.Numbers.Series",
          "name": "Minus",
          "package": "combinat",
          "signature": "Minus",
          "source": "src/Math-Combinat-Numbers-Series.html#Sign",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinat Numbers Series",
          "module": "Math.Combinat.Numbers.Series",
          "name": "Minus",
          "package": "combinat",
          "partial": "Minus",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Numbers-Series.html#v:Minus"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinat.Numbers.Series",
          "name": "Plus",
          "package": "combinat",
          "signature": "Plus",
          "source": "src/Math-Combinat-Numbers-Series.html#Sign",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinat Numbers Series",
          "module": "Math.Combinat.Numbers.Series",
          "name": "Plus",
          "package": "combinat",
          "partial": "Plus",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Numbers-Series.html#v:Plus"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePower series expansion of \n\u003c/p\u003e\u003cpre\u003e 1 / ( (1-x^k_1) * (1-x^k_2) * ... * (1-x^k_n) )\n\u003c/pre\u003e\u003cp\u003eExample:\n\u003c/p\u003e\u003cp\u003e\u003ccode\u003e(coinSeries [2,3,5])!!k\u003c/code\u003e is the number of ways \n to pay \u003ccode\u003ek\u003c/code\u003e dollars with coins of two, three and five dollars.\n\u003c/p\u003e\u003cp\u003eTODO: better name?\n\u003c/p\u003e",
          "module": "Math.Combinat.Numbers.Series",
          "name": "coinSeries",
          "package": "combinat",
          "signature": "[Int] -\u003e [Integer]",
          "source": "src/Math-Combinat-Numbers-Series.html#coinSeries",
          "type": "function"
        },
        "index": {
          "description": "Power series expansion of Example coinSeries is the number of ways to pay dollars with coins of two three and five dollars TODO better name",
          "hierarchy": "Math Combinat Numbers Series",
          "module": "Math.Combinat.Numbers.Series",
          "name": "coinSeries",
          "normalized": "[Int]-\u003e[Integer]",
          "package": "combinat",
          "partial": "Series",
          "signature": "[Int]-\u003e[Integer]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Numbers-Series.html#v:coinSeries"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGeneralization of the above to include coefficients: expansion of \n\u003c/p\u003e\u003cpre\u003e 1 / ( (1-a_1*x^k_1) * (1-a_2*x^k_2) * ... * (1-a_n*x^k_n) ) \n\u003c/pre\u003e",
          "module": "Math.Combinat.Numbers.Series",
          "name": "coinSeries'",
          "package": "combinat",
          "signature": "[(a, Int)] -\u003e [a]",
          "source": "src/Math-Combinat-Numbers-Series.html#coinSeries%27",
          "type": "function"
        },
        "index": {
          "description": "Generalization of the above to include coefficients expansion of",
          "hierarchy": "Math Combinat Numbers Series",
          "module": "Math.Combinat.Numbers.Series",
          "name": "coinSeries'",
          "normalized": "[(a,Int)]-\u003e[a]",
          "package": "combinat",
          "partial": "Series'",
          "signature": "[(a,Int)]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Numbers-Series.html#v:coinSeries-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvolution of series. The result is always an infinite list. Warning: This is slow!\n\u003c/p\u003e",
          "module": "Math.Combinat.Numbers.Series",
          "name": "convolve",
          "package": "combinat",
          "signature": "[a] -\u003e [a] -\u003e [a]",
          "source": "src/Math-Combinat-Numbers-Series.html#convolve",
          "type": "function"
        },
        "index": {
          "description": "Convolution of series The result is always an infinite list Warning This is slow",
          "hierarchy": "Math Combinat Numbers Series",
          "module": "Math.Combinat.Numbers.Series",
          "name": "convolve",
          "normalized": "[a]-\u003e[a]-\u003e[a]",
          "package": "combinat",
          "signature": "[a]-\u003e[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Numbers-Series.html#v:convolve"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvolution of many series. Still slow!\n\u003c/p\u003e",
          "module": "Math.Combinat.Numbers.Series",
          "name": "convolveMany",
          "package": "combinat",
          "signature": "[[a]] -\u003e [a]",
          "source": "src/Math-Combinat-Numbers-Series.html#convolveMany",
          "type": "function"
        },
        "index": {
          "description": "Convolution of many series Still slow",
          "hierarchy": "Math Combinat Numbers Series",
          "module": "Math.Combinat.Numbers.Series",
          "name": "convolveMany",
          "normalized": "[[a]]-\u003e[a]",
          "package": "combinat",
          "partial": "Many",
          "signature": "[[a]]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Numbers-Series.html#v:convolveMany"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinat.Numbers.Series",
          "name": "convolveWithCoinSeries",
          "package": "combinat",
          "signature": "[Int] -\u003e [Integer] -\u003e [Integer]",
          "source": "src/Math-Combinat-Numbers-Series.html#convolveWithCoinSeries",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinat Numbers Series",
          "module": "Math.Combinat.Numbers.Series",
          "name": "convolveWithCoinSeries",
          "normalized": "[Int]-\u003e[Integer]-\u003e[Integer]",
          "package": "combinat",
          "partial": "With Coin Series",
          "signature": "[Int]-\u003e[Integer]-\u003e[Integer]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Numbers-Series.html#v:convolveWithCoinSeries"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinat.Numbers.Series",
          "name": "convolveWithCoinSeries'",
          "package": "combinat",
          "signature": "[(a, Int)] -\u003e [a] -\u003e [a]",
          "source": "src/Math-Combinat-Numbers-Series.html#convolveWithCoinSeries%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinat Numbers Series",
          "module": "Math.Combinat.Numbers.Series",
          "name": "convolveWithCoinSeries'",
          "normalized": "[(a,Int)]-\u003e[a]-\u003e[a]",
          "package": "combinat",
          "partial": "With Coin Series'",
          "signature": "[(a,Int)]-\u003e[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Numbers-Series.html#v:convolveWithCoinSeries-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvolve with (the expansion of) \n\u003c/p\u003e\u003cpre\u003e 1 / (1 - x^k_1 - x^k_2 - x^k_3 - ... - x^k_n)\n\u003c/pre\u003e",
          "module": "Math.Combinat.Numbers.Series",
          "name": "convolveWithPSeries",
          "package": "combinat",
          "signature": "[Int] -\u003e [Integer] -\u003e [Integer]",
          "source": "src/Math-Combinat-Numbers-Series.html#convolveWithPSeries",
          "type": "function"
        },
        "index": {
          "description": "Convolve with the expansion of",
          "hierarchy": "Math Combinat Numbers Series",
          "module": "Math.Combinat.Numbers.Series",
          "name": "convolveWithPSeries",
          "normalized": "[Int]-\u003e[Integer]-\u003e[Integer]",
          "package": "combinat",
          "partial": "With PSeries",
          "signature": "[Int]-\u003e[Integer]-\u003e[Integer]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Numbers-Series.html#v:convolveWithPSeries"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvolve with (the expansion of) \n\u003c/p\u003e\u003cpre\u003e 1 / (1 - a_1*x^k_1 - a_2*x^k_2 - a_3*x^k_3 - ... - a_n*x^k_n)\n\u003c/pre\u003e",
          "module": "Math.Combinat.Numbers.Series",
          "name": "convolveWithPSeries'",
          "package": "combinat",
          "signature": "[(a, Int)] -\u003e [a] -\u003e [a]",
          "source": "src/Math-Combinat-Numbers-Series.html#convolveWithPSeries%27",
          "type": "function"
        },
        "index": {
          "description": "Convolve with the expansion of",
          "hierarchy": "Math Combinat Numbers Series",
          "module": "Math.Combinat.Numbers.Series",
          "name": "convolveWithPSeries'",
          "normalized": "[(a,Int)]-\u003e[a]-\u003e[a]",
          "package": "combinat",
          "partial": "With PSeries'",
          "signature": "[(a,Int)]-\u003e[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Numbers-Series.html#v:convolveWithPSeries-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinat.Numbers.Series",
          "name": "convolveWithProductPSeries",
          "package": "combinat",
          "signature": "[[Int]] -\u003e [Integer] -\u003e [Integer]",
          "source": "src/Math-Combinat-Numbers-Series.html#convolveWithProductPSeries",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinat Numbers Series",
          "module": "Math.Combinat.Numbers.Series",
          "name": "convolveWithProductPSeries",
          "normalized": "[[Int]]-\u003e[Integer]-\u003e[Integer]",
          "package": "combinat",
          "partial": "With Product PSeries",
          "signature": "[[Int]]-\u003e[Integer]-\u003e[Integer]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Numbers-Series.html#v:convolveWithProductPSeries"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis is the most general function in this module; all the others\n are special cases of this one.  \n\u003c/p\u003e",
          "module": "Math.Combinat.Numbers.Series",
          "name": "convolveWithProductPSeries'",
          "package": "combinat",
          "signature": "[[(a, Int)]] -\u003e [a] -\u003e [a]",
          "source": "src/Math-Combinat-Numbers-Series.html#convolveWithProductPSeries%27",
          "type": "function"
        },
        "index": {
          "description": "This is the most general function in this module all the others are special cases of this one",
          "hierarchy": "Math Combinat Numbers Series",
          "module": "Math.Combinat.Numbers.Series",
          "name": "convolveWithProductPSeries'",
          "normalized": "[[(a,Int)]]-\u003e[a]-\u003e[a]",
          "package": "combinat",
          "partial": "With Product PSeries'",
          "signature": "[[(a,Int)]]-\u003e[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Numbers-Series.html#v:convolveWithProductPSeries-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvolve with (the expansion of) \n\u003c/p\u003e\u003cpre\u003e 1 / (1 +- x^k_1 +- x^k_2 +- x^k_3 +- ... +- x^k_n)\n\u003c/pre\u003e\u003cp\u003eShould be faster than using \u003ccode\u003e\u003ca\u003econvolveWithPSeries'\u003c/a\u003e\u003c/code\u003e.\n Note: \u003ccode\u003e\u003ca\u003ePlus\u003c/a\u003e\u003c/code\u003e corresponds to the coefficient \u003ccode\u003e-1\u003c/code\u003e in \u003ccode\u003e\u003ca\u003epseries'\u003c/a\u003e\u003c/code\u003e (since\n there is a minus sign in the definition there)!\n\u003c/p\u003e",
          "module": "Math.Combinat.Numbers.Series",
          "name": "convolveWithSignedPSeries",
          "package": "combinat",
          "signature": "[(Sign, Int)] -\u003e [Integer] -\u003e [Integer]",
          "source": "src/Math-Combinat-Numbers-Series.html#convolveWithSignedPSeries",
          "type": "function"
        },
        "index": {
          "description": "Convolve with the expansion of Should be faster than using convolveWithPSeries Note Plus corresponds to the coefficient in pseries since there is minus sign in the definition there",
          "hierarchy": "Math Combinat Numbers Series",
          "module": "Math.Combinat.Numbers.Series",
          "name": "convolveWithSignedPSeries",
          "normalized": "[(Sign,Int)]-\u003e[Integer]-\u003e[Integer]",
          "package": "combinat",
          "partial": "With Signed PSeries",
          "signature": "[(Sign,Int)]-\u003e[Integer]-\u003e[Integer]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Numbers-Series.html#v:convolveWithSignedPSeries"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvolution of many \u003ccode\u003e\u003ca\u003epseries\u003c/a\u003e\u003c/code\u003e, that is, the expansion of the reciprocal\n of a product of polynomials\n\u003c/p\u003e",
          "module": "Math.Combinat.Numbers.Series",
          "name": "productPSeries",
          "package": "combinat",
          "signature": "[[Int]] -\u003e [Integer]",
          "source": "src/Math-Combinat-Numbers-Series.html#productPSeries",
          "type": "function"
        },
        "index": {
          "description": "Convolution of many pseries that is the expansion of the reciprocal of product of polynomials",
          "hierarchy": "Math Combinat Numbers Series",
          "module": "Math.Combinat.Numbers.Series",
          "name": "productPSeries",
          "normalized": "[[Int]]-\u003e[Integer]",
          "package": "combinat",
          "partial": "PSeries",
          "signature": "[[Int]]-\u003e[Integer]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Numbers-Series.html#v:productPSeries"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe same, with coefficients.\n\u003c/p\u003e",
          "module": "Math.Combinat.Numbers.Series",
          "name": "productPSeries'",
          "package": "combinat",
          "signature": "[[(a, Int)]] -\u003e [a]",
          "source": "src/Math-Combinat-Numbers-Series.html#productPSeries%27",
          "type": "function"
        },
        "index": {
          "description": "The same with coefficients",
          "hierarchy": "Math Combinat Numbers Series",
          "module": "Math.Combinat.Numbers.Series",
          "name": "productPSeries'",
          "normalized": "[[(a,Int)]]-\u003e[a]",
          "package": "combinat",
          "partial": "PSeries'",
          "signature": "[[(a,Int)]]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Numbers-Series.html#v:productPSeries-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe power series expansion of \n\u003c/p\u003e\u003cpre\u003e 1 / (1 - x^k_1 - x^k_2 - x^k_3 - ... - x^k_n)\n\u003c/pre\u003e",
          "module": "Math.Combinat.Numbers.Series",
          "name": "pseries",
          "package": "combinat",
          "signature": "[Int] -\u003e [Integer]",
          "source": "src/Math-Combinat-Numbers-Series.html#pseries",
          "type": "function"
        },
        "index": {
          "description": "The power series expansion of",
          "hierarchy": "Math Combinat Numbers Series",
          "module": "Math.Combinat.Numbers.Series",
          "name": "pseries",
          "normalized": "[Int]-\u003e[Integer]",
          "package": "combinat",
          "signature": "[Int]-\u003e[Integer]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Numbers-Series.html#v:pseries"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe expansion of \n\u003c/p\u003e\u003cpre\u003e 1 / (1 - a_1*x^k_1 - a_2*x^k_2 - a_3*x^k_3 - ... - a_n*x^k_n)\n\u003c/pre\u003e",
          "module": "Math.Combinat.Numbers.Series",
          "name": "pseries'",
          "package": "combinat",
          "signature": "[(a, Int)] -\u003e [a]",
          "source": "src/Math-Combinat-Numbers-Series.html#pseries%27",
          "type": "function"
        },
        "index": {
          "description": "The expansion of",
          "hierarchy": "Math Combinat Numbers Series",
          "module": "Math.Combinat.Numbers.Series",
          "name": "pseries'",
          "normalized": "[(a,Int)]-\u003e[a]",
          "package": "combinat",
          "signature": "[(a,Int)]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Numbers-Series.html#v:pseries-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinat.Numbers.Series",
          "name": "signValue",
          "package": "combinat",
          "signature": "Sign -\u003e a",
          "source": "src/Math-Combinat-Numbers-Series.html#signValue",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinat Numbers Series",
          "module": "Math.Combinat.Numbers.Series",
          "name": "signValue",
          "normalized": "Sign-\u003ea",
          "package": "combinat",
          "partial": "Value",
          "signature": "Sign-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Numbers-Series.html#v:signValue"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinat.Numbers.Series",
          "name": "signedPSeries",
          "package": "combinat",
          "signature": "[(Sign, Int)] -\u003e [Integer]",
          "source": "src/Math-Combinat-Numbers-Series.html#signedPSeries",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinat Numbers Series",
          "module": "Math.Combinat.Numbers.Series",
          "name": "signedPSeries",
          "normalized": "[(Sign,Int)]-\u003e[Integer]",
          "package": "combinat",
          "partial": "PSeries",
          "signature": "[(Sign,Int)]-\u003e[Integer]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Numbers-Series.html#v:signedPSeries"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe series [1,0,0,0,0,...], which is the neutral element for the convolution.\n\u003c/p\u003e",
          "module": "Math.Combinat.Numbers.Series",
          "name": "unitSeries",
          "package": "combinat",
          "signature": "[a]",
          "source": "src/Math-Combinat-Numbers-Series.html#unitSeries",
          "type": "function"
        },
        "index": {
          "description": "The series which is the neutral element for the convolution",
          "hierarchy": "Math Combinat Numbers Series",
          "module": "Math.Combinat.Numbers.Series",
          "name": "unitSeries",
          "normalized": "[a]",
          "package": "combinat",
          "partial": "Series",
          "signature": "[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Numbers-Series.html#v:unitSeries"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eA few important number sequences. \n\u003c/p\u003e\u003cp\u003eSee the \"On-Line Encyclopedia of Integer Sequences\",\n \u003ca\u003ehttp://www.research.att.com/~njas/sequences/\u003c/a\u003e .\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Math.Combinat.Numbers",
          "name": "Numbers",
          "package": "combinat",
          "source": "src/Math-Combinat-Numbers.html",
          "type": "module"
        },
        "index": {
          "description": "few important number sequences See the On-Line Encyclopedia of Integer Sequences http www.research.att.com njas sequences",
          "hierarchy": "Math Combinat Numbers",
          "module": "Math.Combinat.Numbers",
          "name": "Numbers",
          "package": "combinat",
          "partial": "Numbers",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Numbers.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eBernoulli numbers. \u003ccode\u003ebernoulli 1 == -1%2\u003c/code\u003e and \u003ccode\u003ebernoulli k == 0\u003c/code\u003e for\n k\u003e2 and \u003cem\u003eodd\u003c/em\u003e. This function uses the formula involving Stirling numbers\n of the second kind. Numerators: A027641, denominators: A027642.\n\u003c/p\u003e",
          "module": "Math.Combinat.Numbers",
          "name": "bernoulli",
          "package": "combinat",
          "signature": "a -\u003e Rational",
          "source": "src/Math-Combinat-Numbers.html#bernoulli",
          "type": "function"
        },
        "index": {
          "description": "Bernoulli numbers bernoulli and bernoulli for and odd This function uses the formula involving Stirling numbers of the second kind Numerators A027641 denominators A027642",
          "hierarchy": "Math Combinat Numbers",
          "module": "Math.Combinat.Numbers",
          "name": "bernoulli",
          "normalized": "a-\u003eRational",
          "package": "combinat",
          "signature": "a-\u003eRational",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Numbers.html#v:bernoulli"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA007318.\n\u003c/p\u003e",
          "module": "Math.Combinat.Numbers",
          "name": "binomial",
          "package": "combinat",
          "signature": "a -\u003e a -\u003e Integer",
          "source": "src/Math-Combinat-Numbers.html#binomial",
          "type": "function"
        },
        "index": {
          "description": "A007318",
          "hierarchy": "Math Combinat Numbers",
          "module": "Math.Combinat.Numbers",
          "name": "binomial",
          "normalized": "a-\u003ea-\u003eInteger",
          "package": "combinat",
          "signature": "a-\u003ea-\u003eInteger",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Numbers.html#v:binomial"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCatalan numbers. OEIS:A000108.\n\u003c/p\u003e",
          "module": "Math.Combinat.Numbers",
          "name": "catalan",
          "package": "combinat",
          "signature": "a -\u003e Integer",
          "source": "src/Math-Combinat-Numbers.html#catalan",
          "type": "function"
        },
        "index": {
          "description": "Catalan numbers OEIS A000108",
          "hierarchy": "Math Combinat Numbers",
          "module": "Math.Combinat.Numbers",
          "name": "catalan",
          "normalized": "a-\u003eInteger",
          "package": "combinat",
          "signature": "a-\u003eInteger",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Numbers.html#v:catalan"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCatalan's triangle. OEIS:A009766.\n Note:\n\u003c/p\u003e\u003cpre\u003e catalanTriangle n n == catalan n\n catalanTriangle n k == countStandardYoungTableaux (toPartition [n,k])\n\u003c/pre\u003e",
          "module": "Math.Combinat.Numbers",
          "name": "catalanTriangle",
          "package": "combinat",
          "signature": "a -\u003e a -\u003e Integer",
          "source": "src/Math-Combinat-Numbers.html#catalanTriangle",
          "type": "function"
        },
        "index": {
          "description": "Catalan triangle OEIS A009766 Note catalanTriangle catalan catalanTriangle countStandardYoungTableaux toPartition",
          "hierarchy": "Math Combinat Numbers",
          "module": "Math.Combinat.Numbers",
          "name": "catalanTriangle",
          "normalized": "a-\u003ea-\u003eInteger",
          "package": "combinat",
          "partial": "Triangle",
          "signature": "a-\u003ea-\u003eInteger",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Numbers.html#v:catalanTriangle"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA006882.\n\u003c/p\u003e",
          "module": "Math.Combinat.Numbers",
          "name": "doubleFactorial",
          "package": "combinat",
          "signature": "a -\u003e Integer",
          "source": "src/Math-Combinat-Numbers.html#doubleFactorial",
          "type": "function"
        },
        "index": {
          "description": "A006882",
          "hierarchy": "Math Combinat Numbers",
          "module": "Math.Combinat.Numbers",
          "name": "doubleFactorial",
          "normalized": "a-\u003eInteger",
          "package": "combinat",
          "partial": "Factorial",
          "signature": "a-\u003eInteger",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Numbers.html#v:doubleFactorial"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA000142.\n\u003c/p\u003e",
          "module": "Math.Combinat.Numbers",
          "name": "factorial",
          "package": "combinat",
          "signature": "a -\u003e Integer",
          "source": "src/Math-Combinat-Numbers.html#factorial",
          "type": "function"
        },
        "index": {
          "description": "A000142",
          "hierarchy": "Math Combinat Numbers",
          "module": "Math.Combinat.Numbers",
          "name": "factorial",
          "normalized": "a-\u003eInteger",
          "package": "combinat",
          "signature": "a-\u003eInteger",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Numbers.html#v:factorial"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinat.Numbers",
          "name": "multinomial",
          "package": "combinat",
          "signature": "[a] -\u003e Integer",
          "source": "src/Math-Combinat-Numbers.html#multinomial",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinat Numbers",
          "module": "Math.Combinat.Numbers",
          "name": "multinomial",
          "normalized": "[a]-\u003eInteger",
          "package": "combinat",
          "signature": "[a]-\u003eInteger",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Numbers.html#v:multinomial"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cpre\u003e(-1)^k\u003c/pre\u003e",
          "module": "Math.Combinat.Numbers",
          "name": "paritySign",
          "package": "combinat",
          "signature": "a -\u003e Integer",
          "source": "src/Math-Combinat-Numbers.html#paritySign",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinat Numbers",
          "module": "Math.Combinat.Numbers",
          "name": "paritySign",
          "normalized": "a-\u003eInteger",
          "package": "combinat",
          "partial": "Sign",
          "signature": "a-\u003eInteger",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Numbers.html#v:paritySign"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA given row of the Pascal triangle; equivalent to a sequence of binomial \n numbers, but much more efficient. You can also left-fold over it.\n\u003c/p\u003e\u003cpre\u003e pascalRow n == [ binomial n k | k\u003c-[0..n] ]\n\u003c/pre\u003e",
          "module": "Math.Combinat.Numbers",
          "name": "pascalRow",
          "package": "combinat",
          "signature": "a -\u003e [Integer]",
          "source": "src/Math-Combinat-Numbers.html#pascalRow",
          "type": "function"
        },
        "index": {
          "description": "given row of the Pascal triangle equivalent to sequence of binomial numbers but much more efficient You can also left-fold over it pascalRow binomial",
          "hierarchy": "Math Combinat Numbers",
          "module": "Math.Combinat.Numbers",
          "name": "pascalRow",
          "normalized": "a-\u003e[Integer]",
          "package": "combinat",
          "partial": "Row",
          "signature": "a-\u003e[Integer]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Numbers.html#v:pascalRow"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e(Signed) Stirling numbers of the first kind. OEIS:A008275.\n This function uses \u003ccode\u003e\u003ca\u003esignedStirling1stArray\u003c/a\u003e\u003c/code\u003e, so it shouldn't be used\n to compute \u003cem\u003emany\u003c/em\u003e Stirling numbers.\n\u003c/p\u003e",
          "module": "Math.Combinat.Numbers",
          "name": "signedStirling1st",
          "package": "combinat",
          "signature": "a -\u003e a -\u003e Integer",
          "source": "src/Math-Combinat-Numbers.html#signedStirling1st",
          "type": "function"
        },
        "index": {
          "description": "Signed Stirling numbers of the first kind OEIS A008275 This function uses signedStirling1stArray so it shouldn be used to compute many Stirling numbers",
          "hierarchy": "Math Combinat Numbers",
          "module": "Math.Combinat.Numbers",
          "name": "signedStirling1st",
          "normalized": "a-\u003ea-\u003eInteger",
          "package": "combinat",
          "partial": "Stirling",
          "signature": "a-\u003ea-\u003eInteger",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Numbers.html#v:signedStirling1st"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRows of (signed) Stirling numbers of the first kind. OEIS:A008275.\n Coefficients of the polinomial \u003ccode\u003e(x-1)*(x-2)*...*(x-n+1)\u003c/code\u003e.\n This function uses the recursion formula.\n\u003c/p\u003e",
          "module": "Math.Combinat.Numbers",
          "name": "signedStirling1stArray",
          "package": "combinat",
          "signature": "a -\u003e Array Int Integer",
          "source": "src/Math-Combinat-Numbers.html#signedStirling1stArray",
          "type": "function"
        },
        "index": {
          "description": "Rows of signed Stirling numbers of the first kind OEIS A008275 Coefficients of the polinomial x-1 x-2 x-n This function uses the recursion formula",
          "hierarchy": "Math Combinat Numbers",
          "module": "Math.Combinat.Numbers",
          "name": "signedStirling1stArray",
          "normalized": "a-\u003eArray Int Integer",
          "package": "combinat",
          "partial": "Stirling Array",
          "signature": "a-\u003eArray Int Integer",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Numbers.html#v:signedStirling1stArray"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eStirling numbers of the second kind. OEIS:A008277.\n This function uses an explicit formula.\n\u003c/p\u003e",
          "module": "Math.Combinat.Numbers",
          "name": "stirling2nd",
          "package": "combinat",
          "signature": "a -\u003e a -\u003e Integer",
          "source": "src/Math-Combinat-Numbers.html#stirling2nd",
          "type": "function"
        },
        "index": {
          "description": "Stirling numbers of the second kind OEIS A008277 This function uses an explicit formula",
          "hierarchy": "Math Combinat Numbers",
          "module": "Math.Combinat.Numbers",
          "name": "stirling2nd",
          "normalized": "a-\u003ea-\u003eInteger",
          "package": "combinat",
          "signature": "a-\u003ea-\u003eInteger",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Numbers.html#v:stirling2nd"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e(Unsigned) Stirling numbers of the first kind. See \u003ccode\u003e\u003ca\u003esignedStirling1st\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Math.Combinat.Numbers",
          "name": "unsignedStirling1st",
          "package": "combinat",
          "signature": "a -\u003e a -\u003e Integer",
          "source": "src/Math-Combinat-Numbers.html#unsignedStirling1st",
          "type": "function"
        },
        "index": {
          "description": "Unsigned Stirling numbers of the first kind See signedStirling1st",
          "hierarchy": "Math Combinat Numbers",
          "module": "Math.Combinat.Numbers",
          "name": "unsignedStirling1st",
          "normalized": "a-\u003ea-\u003eInteger",
          "package": "combinat",
          "partial": "Stirling",
          "signature": "a-\u003ea-\u003eInteger",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Numbers.html#v:unsignedStirling1st"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003ePartitions. Partitions are nonincreasing sequences of positive integers.\n\u003c/p\u003e\u003cp\u003eSee also \n   Donald E. Knuth: The Art of Computer Programming, vol 4, pre-fascicle 3B.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Math.Combinat.Partitions",
          "name": "Partitions",
          "package": "combinat",
          "source": "src/Math-Combinat-Partitions.html",
          "type": "module"
        },
        "index": {
          "description": "Partitions Partitions are nonincreasing sequences of positive integers See also Donald Knuth The Art of Computer Programming vol pre-fascicle",
          "hierarchy": "Math Combinat Partitions",
          "module": "Math.Combinat.Partitions",
          "name": "Partitions",
          "package": "combinat",
          "partial": "Partitions",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Partitions.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInteger vectors. The indexing starts from 1.\n\u003c/p\u003e",
          "module": "Math.Combinat.Partitions",
          "name": "IntVector",
          "package": "combinat",
          "source": "src/Math-Combinat-Partitions.html#IntVector",
          "type": "type"
        },
        "index": {
          "description": "Integer vectors The indexing starts from",
          "hierarchy": "Math Combinat Partitions",
          "module": "Math.Combinat.Partitions",
          "name": "IntVector",
          "package": "combinat",
          "partial": "Int Vector",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Partitions.html#t:IntVector"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe additional invariant enforced here is that partitions \n   are monotone decreasing sequences of positive integers.\n\u003c/p\u003e",
          "module": "Math.Combinat.Partitions",
          "name": "Partition",
          "package": "combinat",
          "source": "src/Math-Combinat-Partitions.html#Partition",
          "type": "data"
        },
        "index": {
          "description": "The additional invariant enforced here is that partitions are monotone decreasing sequences of positive integers",
          "hierarchy": "Math Combinat Partitions",
          "module": "Math.Combinat.Partitions",
          "name": "Partition",
          "package": "combinat",
          "partial": "Partition",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Partitions.html#t:Partition"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinat.Partitions",
          "name": "_countAutomorphisms",
          "package": "combinat",
          "signature": "[Int] -\u003e Integer",
          "source": "src/Math-Combinat-Partitions.html#_countAutomorphisms",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinat Partitions",
          "module": "Math.Combinat.Partitions",
          "name": "_countAutomorphisms",
          "normalized": "[Int]-\u003eInteger",
          "package": "combinat",
          "partial": "Automorphisms",
          "signature": "[Int]-\u003eInteger",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Partitions.html#v:_countAutomorphisms"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinat.Partitions",
          "name": "_dualPartition",
          "package": "combinat",
          "signature": "[Int] -\u003e [Int]",
          "source": "src/Math-Combinat-Partitions.html#_dualPartition",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinat Partitions",
          "module": "Math.Combinat.Partitions",
          "name": "_dualPartition",
          "normalized": "[Int]-\u003e[Int]",
          "package": "combinat",
          "partial": "Partition",
          "signature": "[Int]-\u003e[Int]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Partitions.html#v:_dualPartition"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinat.Partitions",
          "name": "_elements",
          "package": "combinat",
          "signature": "[Int] -\u003e [(Int, Int)]",
          "source": "src/Math-Combinat-Partitions.html#_elements",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinat Partitions",
          "module": "Math.Combinat.Partitions",
          "name": "_elements",
          "normalized": "[Int]-\u003e[(Int,Int)]",
          "package": "combinat",
          "signature": "[Int]-\u003e[(Int,Int)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Partitions.html#v:_elements"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePartitions of d, as lists\n\u003c/p\u003e",
          "module": "Math.Combinat.Partitions",
          "name": "_partitions",
          "package": "combinat",
          "signature": "Int -\u003e [[Int]]",
          "source": "src/Math-Combinat-Partitions.html#_partitions",
          "type": "function"
        },
        "index": {
          "description": "Partitions of as lists",
          "hierarchy": "Math Combinat Partitions",
          "module": "Math.Combinat.Partitions",
          "name": "_partitions",
          "normalized": "Int-\u003e[[Int]]",
          "package": "combinat",
          "signature": "Int-\u003e[[Int]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Partitions.html#v:_partitions"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePartitions of d, fitting into a given rectangle, as lists.\n\u003c/p\u003e",
          "module": "Math.Combinat.Partitions",
          "name": "_partitions'",
          "package": "combinat",
          "signature": "(Int, Int)-\u003e Int-\u003e [[Int]]",
          "type": "function"
        },
        "index": {
          "description": "Partitions of fitting into given rectangle as lists",
          "hierarchy": "Math Combinat Partitions",
          "module": "Math.Combinat.Partitions",
          "name": "_partitions'",
          "normalized": "(Int,Int)-\u003eInt-\u003e[[Int]]",
          "package": "combinat",
          "signature": "(Int,Int)-\u003eInt-\u003e[[Int]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Partitions.html#v:_partitions-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinat.Partitions",
          "name": "_vectorPartitions",
          "package": "combinat",
          "signature": "[Int] -\u003e [[[Int]]]",
          "source": "src/Math-Combinat-Partitions.html#_vectorPartitions",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinat Partitions",
          "module": "Math.Combinat.Partitions",
          "name": "_vectorPartitions",
          "normalized": "[Int]-\u003e[[[Int]]]",
          "package": "combinat",
          "partial": "Partitions",
          "signature": "[Int]-\u003e[[[Int]]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Partitions.html#v:_vectorPartitions"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAll partitions up to a given degree.\n\u003c/p\u003e",
          "module": "Math.Combinat.Partitions",
          "name": "allPartitions",
          "package": "combinat",
          "signature": "Int -\u003e [[Partition]]",
          "source": "src/Math-Combinat-Partitions.html#allPartitions",
          "type": "function"
        },
        "index": {
          "description": "All partitions up to given degree",
          "hierarchy": "Math Combinat Partitions",
          "module": "Math.Combinat.Partitions",
          "name": "allPartitions",
          "normalized": "Int-\u003e[[Partition]]",
          "package": "combinat",
          "partial": "Partitions",
          "signature": "Int-\u003e[[Partition]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Partitions.html#v:allPartitions"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAll partitions fitting into a given rectangle.\n\u003c/p\u003e",
          "module": "Math.Combinat.Partitions",
          "name": "allPartitions'",
          "package": "combinat",
          "signature": "(Int, Int)-\u003e [[Partition]]",
          "type": "function"
        },
        "index": {
          "description": "All partitions fitting into given rectangle",
          "hierarchy": "Math Combinat Partitions",
          "module": "Math.Combinat.Partitions",
          "name": "allPartitions'",
          "normalized": "(Int,Int)-\u003e[[Partition]]",
          "package": "combinat",
          "partial": "Partitions'",
          "signature": "(Int,Int)-\u003e[[Partition]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Partitions.html#v:allPartitions-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinat.Partitions",
          "name": "countAllPartitions",
          "package": "combinat",
          "signature": "Int -\u003e Integer",
          "source": "src/Math-Combinat-Partitions.html#countAllPartitions",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinat Partitions",
          "module": "Math.Combinat.Partitions",
          "name": "countAllPartitions",
          "normalized": "Int-\u003eInteger",
          "package": "combinat",
          "partial": "All Partitions",
          "signature": "Int-\u003eInteger",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Partitions.html#v:countAllPartitions"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e# = \\binom { h+w } { h }\n\u003c/p\u003e",
          "module": "Math.Combinat.Partitions",
          "name": "countAllPartitions'",
          "package": "combinat",
          "signature": "(Int, Int) -\u003e Integer",
          "source": "src/Math-Combinat-Partitions.html#countAllPartitions%27",
          "type": "function"
        },
        "index": {
          "description": "binom",
          "hierarchy": "Math Combinat Partitions",
          "module": "Math.Combinat.Partitions",
          "name": "countAllPartitions'",
          "normalized": "(Int,Int)-\u003eInteger",
          "package": "combinat",
          "partial": "All Partitions'",
          "signature": "(Int,Int)-\u003eInteger",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Partitions.html#v:countAllPartitions-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eComputes the number of \"automorphisms\" of a given partition.\n\u003c/p\u003e",
          "module": "Math.Combinat.Partitions",
          "name": "countAutomorphisms",
          "package": "combinat",
          "signature": "Partition -\u003e Integer",
          "source": "src/Math-Combinat-Partitions.html#countAutomorphisms",
          "type": "function"
        },
        "index": {
          "description": "Computes the number of automorphisms of given partition",
          "hierarchy": "Math Combinat Partitions",
          "module": "Math.Combinat.Partitions",
          "name": "countAutomorphisms",
          "normalized": "Partition-\u003eInteger",
          "package": "combinat",
          "partial": "Automorphisms",
          "signature": "Partition-\u003eInteger",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Partitions.html#v:countAutomorphisms"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinat.Partitions",
          "name": "countPartitions",
          "package": "combinat",
          "signature": "Int -\u003e Integer",
          "source": "src/Math-Combinat-Partitions.html#countPartitions",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinat Partitions",
          "module": "Math.Combinat.Partitions",
          "name": "countPartitions",
          "normalized": "Int-\u003eInteger",
          "package": "combinat",
          "partial": "Partitions",
          "signature": "Int-\u003eInteger",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Partitions.html#v:countPartitions"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinat.Partitions",
          "name": "countPartitions'",
          "package": "combinat",
          "signature": "(Int, Int) -\u003e Int -\u003e Integer",
          "source": "src/Math-Combinat-Partitions.html#countPartitions%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinat Partitions",
          "module": "Math.Combinat.Partitions",
          "name": "countPartitions'",
          "normalized": "(Int,Int)-\u003eInt-\u003eInteger",
          "package": "combinat",
          "partial": "Partitions'",
          "signature": "(Int,Int)-\u003eInt-\u003eInteger",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Partitions.html#v:countPartitions-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe dual (or conjugate) partition.\n\u003c/p\u003e",
          "module": "Math.Combinat.Partitions",
          "name": "dualPartition",
          "package": "combinat",
          "signature": "Partition -\u003e Partition",
          "source": "src/Math-Combinat-Partitions.html#dualPartition",
          "type": "function"
        },
        "index": {
          "description": "The dual or conjugate partition",
          "hierarchy": "Math Combinat Partitions",
          "module": "Math.Combinat.Partitions",
          "name": "dualPartition",
          "normalized": "Partition-\u003ePartition",
          "package": "combinat",
          "partial": "Partition",
          "signature": "Partition-\u003ePartition",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Partitions.html#v:dualPartition"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExample:\n\u003c/p\u003e\u003cpre\u003e elements (toPartition [5,2,1]) ==\n [ (1,1), (1,2), (1,3), (1,4), (1,5)\n , (2,1), (2,2), (2,3), (2,4)\n , (3,1)\n ]\n\u003c/pre\u003e",
          "module": "Math.Combinat.Partitions",
          "name": "elements",
          "package": "combinat",
          "signature": "Partition -\u003e [(Int, Int)]",
          "source": "src/Math-Combinat-Partitions.html#elements",
          "type": "function"
        },
        "index": {
          "description": "Example elements toPartition",
          "hierarchy": "Math Combinat Partitions",
          "module": "Math.Combinat.Partitions",
          "name": "elements",
          "normalized": "Partition-\u003e[(Int,Int)]",
          "package": "combinat",
          "signature": "Partition-\u003e[(Int,Int)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Partitions.html#v:elements"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGenerates all vector partitions \n   (\"algorithm M\" in Knuth). \n   The order is decreasing lexicographic.  \n\u003c/p\u003e",
          "module": "Math.Combinat.Partitions",
          "name": "fasc3B_algorithm_M",
          "package": "combinat",
          "signature": "[Int] -\u003e [[IntVector]]",
          "source": "src/Math-Combinat-Partitions.html#fasc3B_algorithm_M",
          "type": "function"
        },
        "index": {
          "description": "Generates all vector partitions algorithm in Knuth The order is decreasing lexicographic",
          "hierarchy": "Math Combinat Partitions",
          "module": "Math.Combinat.Partitions",
          "name": "fasc3B_algorithm_M",
          "normalized": "[Int]-\u003e[[IntVector]]",
          "package": "combinat",
          "signature": "[Int]-\u003e[[IntVector]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Partitions.html#v:fasc3B_algorithm_M"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinat.Partitions",
          "name": "fromPartition",
          "package": "combinat",
          "signature": "Partition -\u003e [Int]",
          "source": "src/Math-Combinat-Partitions.html#fromPartition",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinat Partitions",
          "module": "Math.Combinat.Partitions",
          "name": "fromPartition",
          "normalized": "Partition-\u003e[Int]",
          "package": "combinat",
          "partial": "Partition",
          "signature": "Partition-\u003e[Int]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Partitions.html#v:fromPartition"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe first element of the sequence.\n\u003c/p\u003e",
          "module": "Math.Combinat.Partitions",
          "name": "height",
          "package": "combinat",
          "signature": "Partition -\u003e Int",
          "source": "src/Math-Combinat-Partitions.html#height",
          "type": "function"
        },
        "index": {
          "description": "The first element of the sequence",
          "hierarchy": "Math Combinat Partitions",
          "module": "Math.Combinat.Partitions",
          "name": "height",
          "normalized": "Partition-\u003eInt",
          "package": "combinat",
          "signature": "Partition-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Partitions.html#v:height"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinat.Partitions",
          "name": "heightWidth",
          "package": "combinat",
          "signature": "Partition -\u003e (Int, Int)",
          "source": "src/Math-Combinat-Partitions.html#heightWidth",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinat Partitions",
          "module": "Math.Combinat.Partitions",
          "name": "heightWidth",
          "normalized": "Partition-\u003e(Int,Int)",
          "package": "combinat",
          "partial": "Width",
          "signature": "Partition-\u003e(Int,Int)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Partitions.html#v:heightWidth"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eNote: we only check that the sequence is ordered, but we \u003cem\u003edo not\u003c/em\u003e check for\n negative elements. This can be useful when working with symmetric functions.\n It may also change in the future...\n\u003c/p\u003e",
          "module": "Math.Combinat.Partitions",
          "name": "isPartition",
          "package": "combinat",
          "signature": "[Int] -\u003e Bool",
          "source": "src/Math-Combinat-Partitions.html#isPartition",
          "type": "function"
        },
        "index": {
          "description": "Note we only check that the sequence is ordered but we do not check for negative elements This can be useful when working with symmetric functions It may also change in the future",
          "hierarchy": "Math Combinat Partitions",
          "module": "Math.Combinat.Partitions",
          "name": "isPartition",
          "normalized": "[Int]-\u003eBool",
          "package": "combinat",
          "partial": "Partition",
          "signature": "[Int]-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Partitions.html#v:isPartition"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSorts the input, and cuts the nonpositive elements.\n\u003c/p\u003e",
          "module": "Math.Combinat.Partitions",
          "name": "mkPartition",
          "package": "combinat",
          "signature": "[Int] -\u003e Partition",
          "source": "src/Math-Combinat-Partitions.html#mkPartition",
          "type": "function"
        },
        "index": {
          "description": "Sorts the input and cuts the nonpositive elements",
          "hierarchy": "Math Combinat Partitions",
          "module": "Math.Combinat.Partitions",
          "name": "mkPartition",
          "normalized": "[Int]-\u003ePartition",
          "package": "combinat",
          "partial": "Partition",
          "signature": "[Int]-\u003ePartition",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Partitions.html#v:mkPartition"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePartitions of a multiset.\n\u003c/p\u003e",
          "module": "Math.Combinat.Partitions",
          "name": "partitionMultiset",
          "package": "combinat",
          "signature": "[a] -\u003e [[[a]]]",
          "source": "src/Math-Combinat-Partitions.html#partitionMultiset",
          "type": "function"
        },
        "index": {
          "description": "Partitions of multiset",
          "hierarchy": "Math Combinat Partitions",
          "module": "Math.Combinat.Partitions",
          "name": "partitionMultiset",
          "normalized": "[a]-\u003e[[[a]]]",
          "package": "combinat",
          "partial": "Multiset",
          "signature": "[a]-\u003e[[[a]]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Partitions.html#v:partitionMultiset"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePartitions of d.\n\u003c/p\u003e",
          "module": "Math.Combinat.Partitions",
          "name": "partitions",
          "package": "combinat",
          "signature": "Int -\u003e [Partition]",
          "source": "src/Math-Combinat-Partitions.html#partitions",
          "type": "function"
        },
        "index": {
          "description": "Partitions of",
          "hierarchy": "Math Combinat Partitions",
          "module": "Math.Combinat.Partitions",
          "name": "partitions",
          "normalized": "Int-\u003e[Partition]",
          "package": "combinat",
          "signature": "Int-\u003e[Partition]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Partitions.html#v:partitions"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePartitions of d, fitting into a given rectangle. The order is again lexicographic.\n\u003c/p\u003e",
          "module": "Math.Combinat.Partitions",
          "name": "partitions'",
          "package": "combinat",
          "signature": "(Int, Int)-\u003e Int-\u003e [Partition]",
          "type": "function"
        },
        "index": {
          "description": "Partitions of fitting into given rectangle The order is again lexicographic",
          "hierarchy": "Math Combinat Partitions",
          "module": "Math.Combinat.Partitions",
          "name": "partitions'",
          "normalized": "(Int,Int)-\u003eInt-\u003e[Partition]",
          "package": "combinat",
          "signature": "(Int,Int)-\u003eInt-\u003e[Partition]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Partitions.html#v:partitions-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eChecks whether the input is a partition. See the note at \u003ccode\u003e\u003ca\u003eisPartition\u003c/a\u003e\u003c/code\u003e!\n\u003c/p\u003e",
          "module": "Math.Combinat.Partitions",
          "name": "toPartition",
          "package": "combinat",
          "signature": "[Int] -\u003e Partition",
          "source": "src/Math-Combinat-Partitions.html#toPartition",
          "type": "function"
        },
        "index": {
          "description": "Checks whether the input is partition See the note at isPartition",
          "hierarchy": "Math Combinat Partitions",
          "module": "Math.Combinat.Partitions",
          "name": "toPartition",
          "normalized": "[Int]-\u003ePartition",
          "package": "combinat",
          "partial": "Partition",
          "signature": "[Int]-\u003ePartition",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Partitions.html#v:toPartition"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAssumes that the input is decreasing.\n\u003c/p\u003e",
          "module": "Math.Combinat.Partitions",
          "name": "toPartitionUnsafe",
          "package": "combinat",
          "signature": "[Int] -\u003e Partition",
          "source": "src/Math-Combinat-Partitions.html#toPartitionUnsafe",
          "type": "function"
        },
        "index": {
          "description": "Assumes that the input is decreasing",
          "hierarchy": "Math Combinat Partitions",
          "module": "Math.Combinat.Partitions",
          "name": "toPartitionUnsafe",
          "normalized": "[Int]-\u003ePartition",
          "package": "combinat",
          "partial": "Partition Unsafe",
          "signature": "[Int]-\u003ePartition",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Partitions.html#v:toPartitionUnsafe"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eVector partitions. Basically a synonym for \u003ccode\u003e\u003ca\u003efasc3B_algorithm_M\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Math.Combinat.Partitions",
          "name": "vectorPartitions",
          "package": "combinat",
          "signature": "IntVector -\u003e [[IntVector]]",
          "source": "src/Math-Combinat-Partitions.html#vectorPartitions",
          "type": "function"
        },
        "index": {
          "description": "Vector partitions Basically synonym for fasc3B algorithm",
          "hierarchy": "Math Combinat Partitions",
          "module": "Math.Combinat.Partitions",
          "name": "vectorPartitions",
          "normalized": "IntVector-\u003e[[IntVector]]",
          "package": "combinat",
          "partial": "Partitions",
          "signature": "IntVector-\u003e[[IntVector]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Partitions.html#v:vectorPartitions"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe weight of the partition \n   (that is, the sum of the corresponding sequence).\n\u003c/p\u003e",
          "module": "Math.Combinat.Partitions",
          "name": "weight",
          "package": "combinat",
          "signature": "Partition -\u003e Int",
          "source": "src/Math-Combinat-Partitions.html#weight",
          "type": "function"
        },
        "index": {
          "description": "The weight of the partition that is the sum of the corresponding sequence",
          "hierarchy": "Math Combinat Partitions",
          "module": "Math.Combinat.Partitions",
          "name": "weight",
          "normalized": "Partition-\u003eInt",
          "package": "combinat",
          "signature": "Partition-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Partitions.html#v:weight"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe length of the sequence.\n\u003c/p\u003e",
          "module": "Math.Combinat.Partitions",
          "name": "width",
          "package": "combinat",
          "signature": "Partition -\u003e Int",
          "source": "src/Math-Combinat-Partitions.html#width",
          "type": "function"
        },
        "index": {
          "description": "The length of the sequence",
          "hierarchy": "Math Combinat Partitions",
          "module": "Math.Combinat.Partitions",
          "name": "width",
          "normalized": "Partition-\u003eInt",
          "package": "combinat",
          "signature": "Partition-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Partitions.html#v:width"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003ePermutations. See:\n   Donald E. Knuth: The Art of Computer Programming, vol 4, pre-fascicle 2B.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Math.Combinat.Permutations",
          "name": "Permutations",
          "package": "combinat",
          "source": "src/Math-Combinat-Permutations.html",
          "type": "module"
        },
        "index": {
          "description": "Permutations See Donald Knuth The Art of Computer Programming vol pre-fascicle",
          "hierarchy": "Math Combinat Permutations",
          "module": "Math.Combinat.Permutations",
          "name": "Permutations",
          "package": "combinat",
          "partial": "Permutations",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Permutations.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDisjoint cycle notation for permutations. Internally it is \u003ccode\u003e[[Int]]\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Math.Combinat.Permutations",
          "name": "DisjointCycles",
          "package": "combinat",
          "source": "src/Math-Combinat-Permutations.html#DisjointCycles",
          "type": "data"
        },
        "index": {
          "description": "Disjoint cycle notation for permutations Internally it is Int",
          "hierarchy": "Math Combinat Permutations",
          "module": "Math.Combinat.Permutations",
          "name": "DisjointCycles",
          "package": "combinat",
          "partial": "Disjoint Cycles",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Permutations.html#t:DisjointCycles"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eStandard notation for permutations. Internally it is an array of the integers \u003ccode\u003e[1..n]\u003c/code\u003e. \n\u003c/p\u003e",
          "module": "Math.Combinat.Permutations",
          "name": "Permutation",
          "package": "combinat",
          "source": "src/Math-Combinat-Permutations.html#Permutation",
          "type": "data"
        },
        "index": {
          "description": "Standard notation for permutations Internally it is an array of the integers",
          "hierarchy": "Math Combinat Permutations",
          "module": "Math.Combinat.Permutations",
          "name": "Permutation",
          "package": "combinat",
          "partial": "Permutation",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Permutations.html#t:Permutation"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinat.Permutations",
          "name": "_permutations",
          "package": "combinat",
          "signature": "Int -\u003e [[Int]]",
          "source": "src/Math-Combinat-Permutations.html#_permutations",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinat Permutations",
          "module": "Math.Combinat.Permutations",
          "name": "_permutations",
          "normalized": "Int-\u003e[[Int]]",
          "package": "combinat",
          "signature": "Int-\u003e[[Int]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Permutations.html#v:_permutations"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinat.Permutations",
          "name": "_permutationsNaive",
          "package": "combinat",
          "signature": "Int -\u003e [[Int]]",
          "source": "src/Math-Combinat-Permutations.html#_permutationsNaive",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinat Permutations",
          "module": "Math.Combinat.Permutations",
          "name": "_permutationsNaive",
          "normalized": "Int-\u003e[[Int]]",
          "package": "combinat",
          "partial": "Naive",
          "signature": "Int-\u003e[[Int]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Permutations.html#v:_permutationsNaive"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinat.Permutations",
          "name": "_randomCyclicPermutation",
          "package": "combinat",
          "signature": "Int -\u003e g -\u003e ([Int], g)",
          "source": "src/Math-Combinat-Permutations.html#_randomCyclicPermutation",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinat Permutations",
          "module": "Math.Combinat.Permutations",
          "name": "_randomCyclicPermutation",
          "normalized": "Int-\u003ea-\u003e([Int],a)",
          "package": "combinat",
          "partial": "Cyclic Permutation",
          "signature": "Int-\u003eg-\u003e([Int],g)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Permutations.html#v:_randomCyclicPermutation"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinat.Permutations",
          "name": "_randomPermutation",
          "package": "combinat",
          "signature": "Int -\u003e g -\u003e ([Int], g)",
          "source": "src/Math-Combinat-Permutations.html#_randomPermutation",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinat Permutations",
          "module": "Math.Combinat.Permutations",
          "name": "_randomPermutation",
          "normalized": "Int-\u003ea-\u003e([Int],a)",
          "package": "combinat",
          "partial": "Permutation",
          "signature": "Int-\u003eg-\u003e([Int],g)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Permutations.html#v:_randomPermutation"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinat.Permutations",
          "name": "arrayToPermutationUnsafe",
          "package": "combinat",
          "signature": "Array Int Int -\u003e Permutation",
          "source": "src/Math-Combinat-Permutations.html#arrayToPermutationUnsafe",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinat Permutations",
          "module": "Math.Combinat.Permutations",
          "name": "arrayToPermutationUnsafe",
          "normalized": "Array Int Int-\u003ePermutation",
          "package": "combinat",
          "partial": "To Permutation Unsafe",
          "signature": "Array Int Int-\u003ePermutation",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Permutations.html#v:arrayToPermutationUnsafe"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e# = n!\n\u003c/p\u003e",
          "module": "Math.Combinat.Permutations",
          "name": "countPermutations",
          "package": "combinat",
          "signature": "Int -\u003e Integer",
          "source": "src/Math-Combinat-Permutations.html#countPermutations",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinat Permutations",
          "module": "Math.Combinat.Permutations",
          "name": "countPermutations",
          "normalized": "Int-\u003eInteger",
          "package": "combinat",
          "partial": "Permutations",
          "signature": "Int-\u003eInteger",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Permutations.html#v:countPermutations"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e# = \\frac { (sum_i n_i) ! } { \\prod_i (n_i !) }    \n\u003c/p\u003e",
          "module": "Math.Combinat.Permutations",
          "name": "countPermuteMultiset",
          "package": "combinat",
          "signature": "[a] -\u003e Integer",
          "source": "src/Math-Combinat-Permutations.html#countPermuteMultiset",
          "type": "function"
        },
        "index": {
          "description": "frac sum prod",
          "hierarchy": "Math Combinat Permutations",
          "module": "Math.Combinat.Permutations",
          "name": "countPermuteMultiset",
          "normalized": "[a]-\u003eInteger",
          "package": "combinat",
          "partial": "Permute Multiset",
          "signature": "[a]-\u003eInteger",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Permutations.html#v:countPermuteMultiset"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinat.Permutations",
          "name": "disjointCyclesToPermutation",
          "package": "combinat",
          "signature": "Int -\u003e DisjointCycles -\u003e Permutation",
          "source": "src/Math-Combinat-Permutations.html#disjointCyclesToPermutation",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinat Permutations",
          "module": "Math.Combinat.Permutations",
          "name": "disjointCyclesToPermutation",
          "normalized": "Int-\u003eDisjointCycles-\u003ePermutation",
          "package": "combinat",
          "partial": "Cycles To Permutation",
          "signature": "Int-\u003eDisjointCycles-\u003ePermutation",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Permutations.html#v:disjointCyclesToPermutation"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinat.Permutations",
          "name": "disjointCyclesUnsafe",
          "package": "combinat",
          "signature": "[[Int]] -\u003e DisjointCycles",
          "source": "src/Math-Combinat-Permutations.html#disjointCyclesUnsafe",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinat Permutations",
          "module": "Math.Combinat.Permutations",
          "name": "disjointCyclesUnsafe",
          "normalized": "[[Int]]-\u003eDisjointCycles",
          "package": "combinat",
          "partial": "Cycles Unsafe",
          "signature": "[[Int]]-\u003eDisjointCycles",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Permutations.html#v:disjointCyclesUnsafe"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGenerates all permutations of a multiset \n   (based on \"algorithm L\" in Knuth; somewhat less efficient). \n   The order is lexicographic.  \n\u003c/p\u003e",
          "module": "Math.Combinat.Permutations",
          "name": "fasc2B_algorithm_L",
          "package": "combinat",
          "signature": "[a] -\u003e [[a]]",
          "source": "src/Math-Combinat-Permutations.html#fasc2B_algorithm_L",
          "type": "function"
        },
        "index": {
          "description": "Generates all permutations of multiset based on algorithm in Knuth somewhat less efficient The order is lexicographic",
          "hierarchy": "Math Combinat Permutations",
          "module": "Math.Combinat.Permutations",
          "name": "fasc2B_algorithm_L",
          "normalized": "[a]-\u003e[[a]]",
          "package": "combinat",
          "signature": "[a]-\u003e[[a]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Permutations.html#v:fasc2B_algorithm_L"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinat.Permutations",
          "name": "fromDisjointCycles",
          "package": "combinat",
          "signature": "DisjointCycles -\u003e [[Int]]",
          "source": "src/Math-Combinat-Permutations.html#fromDisjointCycles",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinat Permutations",
          "module": "Math.Combinat.Permutations",
          "name": "fromDisjointCycles",
          "normalized": "DisjointCycles-\u003e[[Int]]",
          "package": "combinat",
          "partial": "Disjoint Cycles",
          "signature": "DisjointCycles-\u003e[[Int]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Permutations.html#v:fromDisjointCycles"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinat.Permutations",
          "name": "fromPermutation",
          "package": "combinat",
          "signature": "Permutation -\u003e [Int]",
          "source": "src/Math-Combinat-Permutations.html#fromPermutation",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinat Permutations",
          "module": "Math.Combinat.Permutations",
          "name": "fromPermutation",
          "normalized": "Permutation-\u003e[Int]",
          "package": "combinat",
          "partial": "Permutation",
          "signature": "Permutation-\u003e[Int]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Permutations.html#v:fromPermutation"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe trivial permutation.\n\u003c/p\u003e",
          "module": "Math.Combinat.Permutations",
          "name": "identity",
          "package": "combinat",
          "signature": "Int -\u003e Permutation",
          "source": "src/Math-Combinat-Permutations.html#identity",
          "type": "function"
        },
        "index": {
          "description": "The trivial permutation",
          "hierarchy": "Math Combinat Permutations",
          "module": "Math.Combinat.Permutations",
          "name": "identity",
          "normalized": "Int-\u003ePermutation",
          "package": "combinat",
          "signature": "Int-\u003ePermutation",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Permutations.html#v:identity"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe inverse permutation.\n\u003c/p\u003e",
          "module": "Math.Combinat.Permutations",
          "name": "inverse",
          "package": "combinat",
          "signature": "Permutation -\u003e Permutation",
          "source": "src/Math-Combinat-Permutations.html#inverse",
          "type": "function"
        },
        "index": {
          "description": "The inverse permutation",
          "hierarchy": "Math Combinat Permutations",
          "module": "Math.Combinat.Permutations",
          "name": "inverse",
          "normalized": "Permutation-\u003ePermutation",
          "package": "combinat",
          "signature": "Permutation-\u003ePermutation",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Permutations.html#v:inverse"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinat.Permutations",
          "name": "isCyclicPermutation",
          "package": "combinat",
          "signature": "Permutation -\u003e Bool",
          "source": "src/Math-Combinat-Permutations.html#isCyclicPermutation",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinat Permutations",
          "module": "Math.Combinat.Permutations",
          "name": "isCyclicPermutation",
          "normalized": "Permutation-\u003eBool",
          "package": "combinat",
          "partial": "Cyclic Permutation",
          "signature": "Permutation-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Permutations.html#v:isCyclicPermutation"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinat.Permutations",
          "name": "isEvenPermutation",
          "package": "combinat",
          "signature": "Permutation -\u003e Bool",
          "source": "src/Math-Combinat-Permutations.html#isEvenPermutation",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinat Permutations",
          "module": "Math.Combinat.Permutations",
          "name": "isEvenPermutation",
          "normalized": "Permutation-\u003eBool",
          "package": "combinat",
          "partial": "Even Permutation",
          "signature": "Permutation-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Permutations.html#v:isEvenPermutation"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinat.Permutations",
          "name": "isOddPermutation",
          "package": "combinat",
          "signature": "Permutation -\u003e Bool",
          "source": "src/Math-Combinat-Permutations.html#isOddPermutation",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinat Permutations",
          "module": "Math.Combinat.Permutations",
          "name": "isOddPermutation",
          "normalized": "Permutation-\u003eBool",
          "package": "combinat",
          "partial": "Odd Permutation",
          "signature": "Permutation-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Permutations.html#v:isOddPermutation"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eChecks whether the input is a permutation of the numbers \u003ccode\u003e[1..n]\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Math.Combinat.Permutations",
          "name": "isPermutation",
          "package": "combinat",
          "signature": "[Int] -\u003e Bool",
          "source": "src/Math-Combinat-Permutations.html#isPermutation",
          "type": "function"
        },
        "index": {
          "description": "Checks whether the input is permutation of the numbers",
          "hierarchy": "Math Combinat Permutations",
          "module": "Math.Combinat.Permutations",
          "name": "isPermutation",
          "normalized": "[Int]-\u003eBool",
          "package": "combinat",
          "partial": "Permutation",
          "signature": "[Int]-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Permutations.html#v:isPermutation"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMultiplies two permutations together. See \u003ccode\u003e\u003ca\u003epermute\u003c/a\u003e\u003c/code\u003e for our\n conventions.  \n\u003c/p\u003e",
          "module": "Math.Combinat.Permutations",
          "name": "multiply",
          "package": "combinat",
          "signature": "Permutation -\u003e Permutation -\u003e Permutation",
          "source": "src/Math-Combinat-Permutations.html#multiply",
          "type": "function"
        },
        "index": {
          "description": "Multiplies two permutations together See permute for our conventions",
          "hierarchy": "Math Combinat Permutations",
          "module": "Math.Combinat.Permutations",
          "name": "multiply",
          "normalized": "Permutation-\u003ePermutation-\u003ePermutation",
          "package": "combinat",
          "signature": "Permutation-\u003ePermutation-\u003ePermutation",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Permutations.html#v:multiply"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinat.Permutations",
          "name": "permutationArray",
          "package": "combinat",
          "signature": "Permutation -\u003e Array Int Int",
          "source": "src/Math-Combinat-Permutations.html#permutationArray",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinat Permutations",
          "module": "Math.Combinat.Permutations",
          "name": "permutationArray",
          "normalized": "Permutation-\u003eArray Int Int",
          "package": "combinat",
          "partial": "Array",
          "signature": "Permutation-\u003eArray Int Int",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Permutations.html#v:permutationArray"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturns \u003ccode\u003en\u003c/code\u003e, where the input is a permutation of the numbers \u003ccode\u003e[1..n]\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Math.Combinat.Permutations",
          "name": "permutationSize",
          "package": "combinat",
          "signature": "Permutation -\u003e Int",
          "source": "src/Math-Combinat-Permutations.html#permutationSize",
          "type": "function"
        },
        "index": {
          "description": "Returns where the input is permutation of the numbers",
          "hierarchy": "Math Combinat Permutations",
          "module": "Math.Combinat.Permutations",
          "name": "permutationSize",
          "normalized": "Permutation-\u003eInt",
          "package": "combinat",
          "partial": "Size",
          "signature": "Permutation-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Permutations.html#v:permutationSize"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis is compatible with Maple's \u003ccode\u003econvert(perm,'disjcyc')\u003c/code\u003e.  \n\u003c/p\u003e",
          "module": "Math.Combinat.Permutations",
          "name": "permutationToDisjointCycles",
          "package": "combinat",
          "signature": "Permutation -\u003e DisjointCycles",
          "source": "src/Math-Combinat-Permutations.html#permutationToDisjointCycles",
          "type": "function"
        },
        "index": {
          "description": "This is compatible with Maple convert perm disjcyc",
          "hierarchy": "Math Combinat Permutations",
          "module": "Math.Combinat.Permutations",
          "name": "permutationToDisjointCycles",
          "normalized": "Permutation-\u003eDisjointCycles",
          "package": "combinat",
          "partial": "To Disjoint Cycles",
          "signature": "Permutation-\u003eDisjointCycles",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Permutations.html#v:permutationToDisjointCycles"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA synonym for \u003ccode\u003e\u003ca\u003epermutationsNaive\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Math.Combinat.Permutations",
          "name": "permutations",
          "package": "combinat",
          "signature": "Int -\u003e [Permutation]",
          "source": "src/Math-Combinat-Permutations.html#permutations",
          "type": "function"
        },
        "index": {
          "description": "synonym for permutationsNaive",
          "hierarchy": "Math Combinat Permutations",
          "module": "Math.Combinat.Permutations",
          "name": "permutations",
          "normalized": "Int-\u003e[Permutation]",
          "package": "combinat",
          "signature": "Int-\u003e[Permutation]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Permutations.html#v:permutations"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePermutations of \u003ccode\u003e[1..n]\u003c/code\u003e in lexicographic order, naive algorithm.\n\u003c/p\u003e",
          "module": "Math.Combinat.Permutations",
          "name": "permutationsNaive",
          "package": "combinat",
          "signature": "Int -\u003e [Permutation]",
          "source": "src/Math-Combinat-Permutations.html#permutationsNaive",
          "type": "function"
        },
        "index": {
          "description": "Permutations of in lexicographic order naive algorithm",
          "hierarchy": "Math Combinat Permutations",
          "module": "Math.Combinat.Permutations",
          "name": "permutationsNaive",
          "normalized": "Int-\u003e[Permutation]",
          "package": "combinat",
          "partial": "Naive",
          "signature": "Int-\u003e[Permutation]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Permutations.html#v:permutationsNaive"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAction of a permutation on a set. If our permutation is \n encoded with the sequence \u003ccode\u003e[p1,p2,...,pn]\u003c/code\u003e, then in the\n two-line notation we have\n\u003c/p\u003e\u003cpre\u003e ( 1  2  3  ... n  )\n ( p1 p2 p3 ... pn )\n\u003c/pre\u003e\u003cp\u003eWe adopt the convention that permutations act \u003cem\u003eon the left\u003c/em\u003e \n (as opposed to Knuth, where they act on the right).\n Thus, \n\u003c/p\u003e\u003cpre\u003e permute pi1 (permute pi2 set) == permute (pi1 `multiply` pi2) set\n\u003c/pre\u003e\u003cp\u003eThe second argument should be an array with bounds \u003ccode\u003e(1,n)\u003c/code\u003e.\n The function checks the array bounds.\n\u003c/p\u003e",
          "module": "Math.Combinat.Permutations",
          "name": "permute",
          "package": "combinat",
          "signature": "Permutation -\u003e Array Int a -\u003e Array Int a",
          "source": "src/Math-Combinat-Permutations.html#permute",
          "type": "function"
        },
        "index": {
          "description": "Action of permutation on set If our permutation is encoded with the sequence p1 p2 pn then in the two-line notation we have p1 p2 p3 pn We adopt the convention that permutations act on the left as opposed to Knuth where they act on the right Thus permute pi1 permute pi2 set permute pi1 multiply pi2 set The second argument should be an array with bounds The function checks the array bounds",
          "hierarchy": "Math Combinat Permutations",
          "module": "Math.Combinat.Permutations",
          "name": "permute",
          "normalized": "Permutation-\u003eArray Int a-\u003eArray Int a",
          "package": "combinat",
          "signature": "Permutation-\u003eArray Int a-\u003eArray Int a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Permutations.html#v:permute"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe list should be of length \u003ccode\u003en\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Math.Combinat.Permutations",
          "name": "permuteList",
          "package": "combinat",
          "signature": "Permutation -\u003e [a] -\u003e [a]",
          "source": "src/Math-Combinat-Permutations.html#permuteList",
          "type": "function"
        },
        "index": {
          "description": "The list should be of length",
          "hierarchy": "Math Combinat Permutations",
          "module": "Math.Combinat.Permutations",
          "name": "permuteList",
          "normalized": "Permutation-\u003e[a]-\u003e[a]",
          "package": "combinat",
          "partial": "List",
          "signature": "Permutation-\u003e[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Permutations.html#v:permuteList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGenerates all permutations of a multiset.  \n   The order is lexicographic. A synonym for \u003ccode\u003e\u003ca\u003efasc2B_algorithm_L\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Math.Combinat.Permutations",
          "name": "permuteMultiset",
          "package": "combinat",
          "signature": "[a] -\u003e [[a]]",
          "source": "src/Math-Combinat-Permutations.html#permuteMultiset",
          "type": "function"
        },
        "index": {
          "description": "Generates all permutations of multiset The order is lexicographic synonym for fasc2B algorithm",
          "hierarchy": "Math Combinat Permutations",
          "module": "Math.Combinat.Permutations",
          "name": "permuteMultiset",
          "normalized": "[a]-\u003e[[a]]",
          "package": "combinat",
          "partial": "Multiset",
          "signature": "[a]-\u003e[[a]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Permutations.html#v:permuteMultiset"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA synonym for \u003ccode\u003e\u003ca\u003erandomCyclicPermutationSattolo\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Math.Combinat.Permutations",
          "name": "randomCyclicPermutation",
          "package": "combinat",
          "signature": "Int -\u003e g -\u003e (Permutation, g)",
          "source": "src/Math-Combinat-Permutations.html#randomCyclicPermutation",
          "type": "function"
        },
        "index": {
          "description": "synonym for randomCyclicPermutationSattolo",
          "hierarchy": "Math Combinat Permutations",
          "module": "Math.Combinat.Permutations",
          "name": "randomCyclicPermutation",
          "normalized": "Int-\u003ea-\u003e(Permutation,a)",
          "package": "combinat",
          "partial": "Cyclic Permutation",
          "signature": "Int-\u003eg-\u003e(Permutation,g)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Permutations.html#v:randomCyclicPermutation"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGenerates a uniformly random \u003cem\u003ecyclic\u003c/em\u003e permutation of \u003ccode\u003e[1..n]\u003c/code\u003e.\n Sattolo's algorithm (see \u003ca\u003ehttp://en.wikipedia.org/wiki/Knuth_shuffle\u003c/a\u003e).\n\u003c/p\u003e",
          "module": "Math.Combinat.Permutations",
          "name": "randomCyclicPermutationSattolo",
          "package": "combinat",
          "signature": "Int -\u003e g -\u003e (Permutation, g)",
          "source": "src/Math-Combinat-Permutations.html#randomCyclicPermutationSattolo",
          "type": "function"
        },
        "index": {
          "description": "Generates uniformly random cyclic permutation of Sattolo algorithm see http en.wikipedia.org wiki Knuth shuffle",
          "hierarchy": "Math Combinat Permutations",
          "module": "Math.Combinat.Permutations",
          "name": "randomCyclicPermutationSattolo",
          "normalized": "Int-\u003ea-\u003e(Permutation,a)",
          "package": "combinat",
          "partial": "Cyclic Permutation Sattolo",
          "signature": "Int-\u003eg-\u003e(Permutation,g)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Permutations.html#v:randomCyclicPermutationSattolo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA synonym for \u003ccode\u003e\u003ca\u003erandomPermutationDurstenfeld\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Math.Combinat.Permutations",
          "name": "randomPermutation",
          "package": "combinat",
          "signature": "Int -\u003e g -\u003e (Permutation, g)",
          "source": "src/Math-Combinat-Permutations.html#randomPermutation",
          "type": "function"
        },
        "index": {
          "description": "synonym for randomPermutationDurstenfeld",
          "hierarchy": "Math Combinat Permutations",
          "module": "Math.Combinat.Permutations",
          "name": "randomPermutation",
          "normalized": "Int-\u003ea-\u003e(Permutation,a)",
          "package": "combinat",
          "partial": "Permutation",
          "signature": "Int-\u003eg-\u003e(Permutation,g)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Permutations.html#v:randomPermutation"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGenerates a uniformly random permutation of \u003ccode\u003e[1..n]\u003c/code\u003e.\n Durstenfeld's algorithm (see \u003ca\u003ehttp://en.wikipedia.org/wiki/Knuth_shuffle\u003c/a\u003e).\n\u003c/p\u003e",
          "module": "Math.Combinat.Permutations",
          "name": "randomPermutationDurstenfeld",
          "package": "combinat",
          "signature": "Int -\u003e g -\u003e (Permutation, g)",
          "source": "src/Math-Combinat-Permutations.html#randomPermutationDurstenfeld",
          "type": "function"
        },
        "index": {
          "description": "Generates uniformly random permutation of Durstenfeld algorithm see http en.wikipedia.org wiki Knuth shuffle",
          "hierarchy": "Math Combinat Permutations",
          "module": "Math.Combinat.Permutations",
          "name": "randomPermutationDurstenfeld",
          "normalized": "Int-\u003ea-\u003e(Permutation,a)",
          "package": "combinat",
          "partial": "Permutation Durstenfeld",
          "signature": "Int-\u003eg-\u003e(Permutation,g)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Permutations.html#v:randomPermutationDurstenfeld"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePlus 1 or minus 1.\n\u003c/p\u003e",
          "module": "Math.Combinat.Permutations",
          "name": "signOfPermutation",
          "package": "combinat",
          "signature": "Permutation -\u003e a",
          "source": "src/Math-Combinat-Permutations.html#signOfPermutation",
          "type": "function"
        },
        "index": {
          "description": "Plus or minus",
          "hierarchy": "Math Combinat Permutations",
          "module": "Math.Combinat.Permutations",
          "name": "signOfPermutation",
          "normalized": "Permutation-\u003ea",
          "package": "combinat",
          "partial": "Of Permutation",
          "signature": "Permutation-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Permutations.html#v:signOfPermutation"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eChecks the input.\n\u003c/p\u003e",
          "module": "Math.Combinat.Permutations",
          "name": "toPermutation",
          "package": "combinat",
          "signature": "[Int] -\u003e Permutation",
          "source": "src/Math-Combinat-Permutations.html#toPermutation",
          "type": "function"
        },
        "index": {
          "description": "Checks the input",
          "hierarchy": "Math Combinat Permutations",
          "module": "Math.Combinat.Permutations",
          "name": "toPermutation",
          "normalized": "[Int]-\u003ePermutation",
          "package": "combinat",
          "partial": "Permutation",
          "signature": "[Int]-\u003ePermutation",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Permutations.html#v:toPermutation"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAssumes that the input is a permutation of the numbers \u003ccode\u003e[1..n]\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Math.Combinat.Permutations",
          "name": "toPermutationUnsafe",
          "package": "combinat",
          "signature": "[Int] -\u003e Permutation",
          "source": "src/Math-Combinat-Permutations.html#toPermutationUnsafe",
          "type": "function"
        },
        "index": {
          "description": "Assumes that the input is permutation of the numbers",
          "hierarchy": "Math Combinat Permutations",
          "module": "Math.Combinat.Permutations",
          "name": "toPermutationUnsafe",
          "normalized": "[Int]-\u003ePermutation",
          "package": "combinat",
          "partial": "Permutation Unsafe",
          "signature": "[Int]-\u003ePermutation",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Permutations.html#v:toPermutationUnsafe"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eSubsets. \n\u003c/p\u003e\u003c/div\u003e",
          "module": "Math.Combinat.Sets",
          "name": "Sets",
          "package": "combinat",
          "source": "src/Math-Combinat-Sets.html",
          "type": "module"
        },
        "index": {
          "description": "Subsets",
          "hierarchy": "Math Combinat Sets",
          "module": "Math.Combinat.Sets",
          "name": "Sets",
          "package": "combinat",
          "partial": "Sets",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Sets.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAll possible ways to choose \u003ccode\u003ek\u003c/code\u003e elements from a list, without\n repetitions. \"Antisymmetric power\" for lists. Synonym for \u003ca\u003ekSublists\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Math.Combinat.Sets",
          "name": "choose",
          "package": "combinat",
          "signature": "Int -\u003e [a] -\u003e [[a]]",
          "source": "src/Math-Combinat-Sets.html#choose",
          "type": "function"
        },
        "index": {
          "description": "All possible ways to choose elements from list without repetitions Antisymmetric power for lists Synonym for kSublists",
          "hierarchy": "Math Combinat Sets",
          "module": "Math.Combinat.Sets",
          "name": "choose",
          "normalized": "Int-\u003e[a]-\u003e[[a]]",
          "package": "combinat",
          "signature": "Int-\u003e[a]-\u003e[[a]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Sets.html#v:choose"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAll possible ways to choose \u003ccode\u003ek\u003c/code\u003e elements from a list, \u003cem\u003ewith repetitions\u003c/em\u003e. \n \"Symmetric power\" for lists. See also \u003ca\u003eMath.Combinat.Combinations\u003c/a\u003e.\n TODO: better name?\n\u003c/p\u003e",
          "module": "Math.Combinat.Sets",
          "name": "combine",
          "package": "combinat",
          "signature": "Int -\u003e [a] -\u003e [[a]]",
          "source": "src/Math-Combinat-Sets.html#combine",
          "type": "function"
        },
        "index": {
          "description": "All possible ways to choose elements from list with repetitions Symmetric power for lists See also Math.Combinat.Combinations TODO better name",
          "hierarchy": "Math Combinat Sets",
          "module": "Math.Combinat.Sets",
          "name": "combine",
          "normalized": "Int-\u003e[a]-\u003e[[a]]",
          "package": "combinat",
          "signature": "Int-\u003e[a]-\u003e[[a]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Sets.html#v:combine"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA synonym for \u003ccode\u003e\u003ca\u003ecombine\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Math.Combinat.Sets",
          "name": "compose",
          "package": "combinat",
          "signature": "Int -\u003e [a] -\u003e [[a]]",
          "source": "src/Math-Combinat-Sets.html#compose",
          "type": "function"
        },
        "index": {
          "description": "synonym for combine",
          "hierarchy": "Math Combinat Sets",
          "module": "Math.Combinat.Sets",
          "name": "compose",
          "normalized": "Int-\u003e[a]-\u003e[[a]]",
          "package": "combinat",
          "signature": "Int-\u003e[a]-\u003e[[a]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Sets.html#v:compose"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e# = binom { n } { k }\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Math.Combinat.Sets",
          "name": "countKSublists",
          "package": "combinat",
          "signature": "Int -\u003e Int -\u003e Integer",
          "source": "src/Math-Combinat-Sets.html#countKSublists",
          "type": "function"
        },
        "index": {
          "description": "binom",
          "hierarchy": "Math Combinat Sets",
          "module": "Math.Combinat.Sets",
          "name": "countKSublists",
          "normalized": "Int-\u003eInt-\u003eInteger",
          "package": "combinat",
          "partial": "KSublists",
          "signature": "Int-\u003eInt-\u003eInteger",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Sets.html#v:countKSublists"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e# = 2^n\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Math.Combinat.Sets",
          "name": "countSublists",
          "package": "combinat",
          "signature": "Int -\u003e Integer",
          "source": "src/Math-Combinat-Sets.html#countSublists",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinat Sets",
          "module": "Math.Combinat.Sets",
          "name": "countSublists",
          "normalized": "Int-\u003eInteger",
          "package": "combinat",
          "partial": "Sublists",
          "signature": "Int-\u003eInteger",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Sets.html#v:countSublists"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSublists of a list having given number of elements.\n\u003c/p\u003e",
          "module": "Math.Combinat.Sets",
          "name": "kSublists",
          "package": "combinat",
          "signature": "Int -\u003e [a] -\u003e [[a]]",
          "source": "src/Math-Combinat-Sets.html#kSublists",
          "type": "function"
        },
        "index": {
          "description": "Sublists of list having given number of elements",
          "hierarchy": "Math Combinat Sets",
          "module": "Math.Combinat.Sets",
          "name": "kSublists",
          "normalized": "Int-\u003e[a]-\u003e[[a]]",
          "package": "combinat",
          "partial": "Sublists",
          "signature": "Int-\u003e[a]-\u003e[[a]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Sets.html#v:kSublists"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\"Tensor product\" for lists.\n\u003c/p\u003e",
          "module": "Math.Combinat.Sets",
          "name": "listTensor",
          "package": "combinat",
          "signature": "[[a]] -\u003e [[a]]",
          "source": "src/Math-Combinat-Sets.html#listTensor",
          "type": "function"
        },
        "index": {
          "description": "Tensor product for lists",
          "hierarchy": "Math Combinat Sets",
          "module": "Math.Combinat.Sets",
          "name": "listTensor",
          "normalized": "[[a]]-\u003e[[a]]",
          "package": "combinat",
          "partial": "Tensor",
          "signature": "[[a]]-\u003e[[a]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Sets.html#v:listTensor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAll sublists of a list.\n\u003c/p\u003e",
          "module": "Math.Combinat.Sets",
          "name": "sublists",
          "package": "combinat",
          "signature": "[a] -\u003e [[a]]",
          "source": "src/Math-Combinat-Sets.html#sublists",
          "type": "function"
        },
        "index": {
          "description": "All sublists of list",
          "hierarchy": "Math Combinat Sets",
          "module": "Math.Combinat.Sets",
          "name": "sublists",
          "normalized": "[a]-\u003e[[a]]",
          "package": "combinat",
          "signature": "[a]-\u003e[[a]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Sets.html#v:sublists"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\"Tensor power\" for lists. Special case of \u003ccode\u003e\u003ca\u003elistTensor\u003c/a\u003e\u003c/code\u003e:\n\u003c/p\u003e\u003cpre\u003e tuplesFromList k xs == listTensor (replicate k xs)\n\u003c/pre\u003e\u003cp\u003eSee also \u003ca\u003eMath.Combinat.Tuples\u003c/a\u003e.\n TODO: better name?\n\u003c/p\u003e",
          "module": "Math.Combinat.Sets",
          "name": "tuplesFromList",
          "package": "combinat",
          "signature": "Int -\u003e [a] -\u003e [[a]]",
          "source": "src/Math-Combinat-Sets.html#tuplesFromList",
          "type": "function"
        },
        "index": {
          "description": "Tensor power for lists Special case of listTensor tuplesFromList xs listTensor replicate xs See also Math.Combinat.Tuples TODO better name",
          "hierarchy": "Math Combinat Sets",
          "module": "Math.Combinat.Sets",
          "name": "tuplesFromList",
          "normalized": "Int-\u003e[a]-\u003e[[a]]",
          "package": "combinat",
          "partial": "From List",
          "signature": "Int-\u003e[a]-\u003e[[a]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Sets.html#v:tuplesFromList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module contains a function to generate (equivalence classes of) \n triangular tableaux of size \u003cem\u003ek\u003c/em\u003e, strictly increasing to the right and \n to the bottom. For example\n\u003c/p\u003e\u003cpre\u003e  1  \n  2  4  \n  3  5  8  \n  6  7  9  10 \n\u003c/pre\u003e\u003cp\u003eis such a tableau of size 4.\n The numbers filling a tableau always consist of an interval \u003ccode\u003e[1..c]\u003c/code\u003e;\n \u003ccode\u003ec\u003c/code\u003e is called the \u003cem\u003econtent\u003c/em\u003e of the tableaux. There is a unique tableau\n of minimal content \u003ccode\u003e2k-1\u003c/code\u003e:\n\u003c/p\u003e\u003cpre\u003e  1  \n  2  3  \n  3  4  5 \n  4  5  6  7 \n\u003c/pre\u003e\u003cp\u003eLet us call the tableaux with maximal content (that is, \u003ccode\u003em = binomial (k+1) 2\u003c/code\u003e)\n \u003cem\u003estandard\u003c/em\u003e. The number of standard tableaux are\n\u003c/p\u003e\u003cpre\u003e 1, 1, 2, 12, 286, 33592, 23178480, ...\n\u003c/pre\u003e\u003cp\u003eOEIS:A003121, \"Strict sense ballot numbers\", \n \u003ca\u003ehttp://www.research.att.com/~njas/sequences/A003121\u003c/a\u003e.\n\u003c/p\u003e\u003cp\u003eSee \n R. M. Thrall, A combinatorial problem, Michigan Math. J. 1, (1952), 81-88.\n\u003c/p\u003e\u003cp\u003eThe number of tableaux with content \u003ccode\u003ec=m-d\u003c/code\u003e are\n\u003c/p\u003e\u003cpre\u003e  d=  |     0      1      2      3    ...\n -----+----------------------------------------------\n  k=2 |     1\n  k=3 |     2      1\n  k=4 |    12     18      8      1\n  k=5 |   286    858   1001    572    165     22     1\n  k=6 | 33592 167960 361114 436696 326196 155584 47320 8892 962 52 1 \n\u003c/pre\u003e\u003cp\u003eWe call these \"Kostka tableaux\" (in the lack of a better name), since\n they are in bijection with the simplicial cones in a canonical simplicial \n decompositions of the Gelfand-Tsetlin cones (the content corresponds\n to the dimension), which encode the combinatorics of Kostka numbers.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Math.Combinat.Tableaux.Kostka",
          "name": "Kostka",
          "package": "combinat",
          "source": "src/Math-Combinat-Tableaux-Kostka.html",
          "type": "module"
        },
        "index": {
          "description": "This module contains function to generate equivalence classes of triangular tableaux of size strictly increasing to the right and to the bottom For example is such tableau of size The numbers filling tableau always consist of an interval is called the content of the tableaux There is unique tableau of minimal content k-1 Let us call the tableaux with maximal content that is binomial standard The number of standard tableaux are OEIS A003121 Strict sense ballot numbers http www.research.att.com njas sequences A003121 See Thrall combinatorial problem Michigan Math The number of tableaux with content m-d are We call these Kostka tableaux in the lack of better name since they are in bijection with the simplicial cones in canonical simplicial decompositions of the Gelfand-Tsetlin cones the content corresponds to the dimension which encode the combinatorics of Kostka numbers",
          "hierarchy": "Math Combinat Tableaux Kostka",
          "module": "Math.Combinat.Tableaux.Kostka",
          "name": "Kostka",
          "package": "combinat",
          "partial": "Kostka",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Tableaux-Kostka.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinat.Tableaux.Kostka",
          "name": "Tableau",
          "package": "combinat",
          "source": "src/Math-Combinat-Tableaux.html#Tableau",
          "type": "type"
        },
        "index": {
          "hierarchy": "Math Combinat Tableaux Kostka",
          "module": "Math.Combinat.Tableaux.Kostka",
          "name": "Tableau",
          "package": "combinat",
          "partial": "Tableau",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Tableaux-Kostka.html#t:Tableau"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSet of \u003ccode\u003e(i,j)\u003c/code\u003e pairs with \u003ccode\u003ei\u003e=j\u003e=1\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Math.Combinat.Tableaux.Kostka",
          "name": "Tri",
          "package": "combinat",
          "source": "src/Math-Combinat-Tableaux-Kostka.html#Tri",
          "type": "newtype"
        },
        "index": {
          "description": "Set of pairs with",
          "hierarchy": "Math Combinat Tableaux Kostka",
          "module": "Math.Combinat.Tableaux.Kostka",
          "name": "Tri",
          "package": "combinat",
          "partial": "Tri",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Tableaux-Kostka.html#t:Tri"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTriangular arrays\n\u003c/p\u003e",
          "module": "Math.Combinat.Tableaux.Kostka",
          "name": "TriangularArray",
          "package": "combinat",
          "source": "src/Math-Combinat-Tableaux-Kostka.html#TriangularArray",
          "type": "type"
        },
        "index": {
          "description": "Triangular arrays",
          "hierarchy": "Math Combinat Tableaux Kostka",
          "module": "Math.Combinat.Tableaux.Kostka",
          "name": "TriangularArray",
          "package": "combinat",
          "partial": "Triangular Array",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Tableaux-Kostka.html#t:TriangularArray"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinat.Tableaux.Kostka",
          "name": "Tri",
          "package": "combinat",
          "signature": "Tri",
          "source": "src/Math-Combinat-Tableaux-Kostka.html#Tri",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinat Tableaux Kostka",
          "module": "Math.Combinat.Tableaux.Kostka",
          "name": "Tri",
          "package": "combinat",
          "partial": "Tri",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Tableaux-Kostka.html#v:Tri"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinat.Tableaux.Kostka",
          "name": "_kostkaContent",
          "package": "combinat",
          "signature": "Tableau Int -\u003e Int",
          "source": "src/Math-Combinat-Tableaux-Kostka.html#_kostkaContent",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinat Tableaux Kostka",
          "module": "Math.Combinat.Tableaux.Kostka",
          "name": "_kostkaContent",
          "normalized": "Tableau Int-\u003eInt",
          "package": "combinat",
          "partial": "Content",
          "signature": "Tableau Int-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Tableaux-Kostka.html#v:_kostkaContent"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinat.Tableaux.Kostka",
          "name": "_kostkaTableaux",
          "package": "combinat",
          "signature": "Int -\u003e [Tableau Int]",
          "source": "src/Math-Combinat-Tableaux-Kostka.html#_kostkaTableaux",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinat Tableaux Kostka",
          "module": "Math.Combinat.Tableaux.Kostka",
          "name": "_kostkaTableaux",
          "normalized": "Int-\u003e[Tableau Int]",
          "package": "combinat",
          "partial": "Tableaux",
          "signature": "Int-\u003e[Tableau Int]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Tableaux-Kostka.html#v:_kostkaTableaux"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinat.Tableaux.Kostka",
          "name": "countKostkaTableaux",
          "package": "combinat",
          "signature": "Int -\u003e [Int]",
          "source": "src/Math-Combinat-Tableaux-Kostka.html#countKostkaTableaux",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinat Tableaux Kostka",
          "module": "Math.Combinat.Tableaux.Kostka",
          "name": "countKostkaTableaux",
          "normalized": "Int-\u003e[Int]",
          "package": "combinat",
          "partial": "Kostka Tableaux",
          "signature": "Int-\u003e[Int]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Tableaux-Kostka.html#v:countKostkaTableaux"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinat.Tableaux.Kostka",
          "name": "fromTriangularArray",
          "package": "combinat",
          "signature": "TriangularArray a -\u003e Tableau a",
          "source": "src/Math-Combinat-Tableaux-Kostka.html#fromTriangularArray",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinat Tableaux Kostka",
          "module": "Math.Combinat.Tableaux.Kostka",
          "name": "fromTriangularArray",
          "normalized": "TriangularArray a-\u003eTableau a",
          "package": "combinat",
          "partial": "Triangular Array",
          "signature": "TriangularArray a-\u003eTableau a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Tableaux-Kostka.html#v:fromTriangularArray"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinat.Tableaux.Kostka",
          "name": "kostkaContent",
          "package": "combinat",
          "signature": "TriangularArray Int -\u003e Int",
          "source": "src/Math-Combinat-Tableaux-Kostka.html#kostkaContent",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinat Tableaux Kostka",
          "module": "Math.Combinat.Tableaux.Kostka",
          "name": "kostkaContent",
          "normalized": "TriangularArray Int-\u003eInt",
          "package": "combinat",
          "partial": "Content",
          "signature": "TriangularArray Int-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Tableaux-Kostka.html#v:kostkaContent"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGenerates all tableaux of size \u003ccode\u003ek\u003c/code\u003e. Effective for \u003ccode\u003ek\u003c=6\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Math.Combinat.Tableaux.Kostka",
          "name": "kostkaTableaux",
          "package": "combinat",
          "signature": "Int -\u003e [TriangularArray Int]",
          "source": "src/Math-Combinat-Tableaux-Kostka.html#kostkaTableaux",
          "type": "function"
        },
        "index": {
          "description": "Generates all tableaux of size Effective for",
          "hierarchy": "Math Combinat Tableaux Kostka",
          "module": "Math.Combinat.Tableaux.Kostka",
          "name": "kostkaTableaux",
          "normalized": "Int-\u003e[TriangularArray Int]",
          "package": "combinat",
          "partial": "Tableaux",
          "signature": "Int-\u003e[TriangularArray Int]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Tableaux-Kostka.html#v:kostkaTableaux"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinat.Tableaux.Kostka",
          "name": "triangularArrayUnsafe",
          "package": "combinat",
          "signature": "Tableau a -\u003e TriangularArray a",
          "source": "src/Math-Combinat-Tableaux-Kostka.html#triangularArrayUnsafe",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinat Tableaux Kostka",
          "module": "Math.Combinat.Tableaux.Kostka",
          "name": "triangularArrayUnsafe",
          "normalized": "Tableau a-\u003eTriangularArray a",
          "package": "combinat",
          "partial": "Array Unsafe",
          "signature": "Tableau a-\u003eTriangularArray a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Tableaux-Kostka.html#v:triangularArrayUnsafe"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinat.Tableaux.Kostka",
          "name": "unTri",
          "package": "combinat",
          "signature": "(Int, Int)",
          "source": "src/Math-Combinat-Tableaux-Kostka.html#Tri",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinat Tableaux Kostka",
          "module": "Math.Combinat.Tableaux.Kostka",
          "name": "unTri",
          "normalized": "(Int,Int)",
          "package": "combinat",
          "partial": "Tri",
          "signature": "(Int,Int)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Tableaux-Kostka.html#v:unTri"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eYoung tableaux and similar gadgets. \n   See e.g. William Fulton: Young Tableaux, with Applications to \n   Representation theory and Geometry (CUP 1997).\n\u003c/p\u003e\u003cp\u003eThe convention is that we use \n   the English notation, and we store the tableaux as lists of the rows.\n\u003c/p\u003e\u003cp\u003eThat is, the following standard tableau of shape [5,4,1]\n\u003c/p\u003e\u003cpre\u003e  1  3  4  6  7\n  2  5  8 10\n  9\n\u003c/pre\u003e\u003cp\u003eis encoded conveniently as\n\u003c/p\u003e\u003cpre\u003e [ [ 1 , 3 , 4 , 6 , 7 ]\n , [ 2 , 5 , 8 ,10 ]\n , [ 9 ]\n ]\n\u003c/pre\u003e\u003c/div\u003e",
          "module": "Math.Combinat.Tableaux",
          "name": "Tableaux",
          "package": "combinat",
          "source": "src/Math-Combinat-Tableaux.html",
          "type": "module"
        },
        "index": {
          "description": "Young tableaux and similar gadgets See e.g William Fulton Young Tableaux with Applications to Representation theory and Geometry CUP The convention is that we use the English notation and we store the tableaux as lists of the rows That is the following standard tableau of shape is encoded conveniently as",
          "hierarchy": "Math Combinat Tableaux",
          "module": "Math.Combinat.Tableaux",
          "name": "Tableaux",
          "package": "combinat",
          "partial": "Tableaux",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Tableaux.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinat.Tableaux",
          "name": "Tableau",
          "package": "combinat",
          "source": "src/Math-Combinat-Tableaux.html#Tableau",
          "type": "type"
        },
        "index": {
          "hierarchy": "Math Combinat Tableaux",
          "module": "Math.Combinat.Tableaux",
          "name": "Tableau",
          "package": "combinat",
          "partial": "Tableau",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Tableaux.html#t:Tableau"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinat.Tableaux",
          "name": "_shape",
          "package": "combinat",
          "signature": "Tableau a -\u003e [Int]",
          "source": "src/Math-Combinat-Tableaux.html#_shape",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinat Tableaux",
          "module": "Math.Combinat.Tableaux",
          "name": "_shape",
          "normalized": "Tableau a-\u003e[Int]",
          "package": "combinat",
          "signature": "Tableau a-\u003e[Int]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Tableaux.html#v:_shape"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinat.Tableaux",
          "name": "columnWord",
          "package": "combinat",
          "signature": "Tableau a -\u003e [a]",
          "source": "src/Math-Combinat-Tableaux.html#columnWord",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinat Tableaux",
          "module": "Math.Combinat.Tableaux",
          "name": "columnWord",
          "normalized": "Tableau a-\u003e[a]",
          "package": "combinat",
          "partial": "Word",
          "signature": "Tableau a-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Tableaux.html#v:columnWord"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinat.Tableaux",
          "name": "columnWordToTableau",
          "package": "combinat",
          "signature": "[a] -\u003e Tableau a",
          "source": "src/Math-Combinat-Tableaux.html#columnWordToTableau",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinat Tableaux",
          "module": "Math.Combinat.Tableaux",
          "name": "columnWordToTableau",
          "normalized": "[a]-\u003eTableau a",
          "package": "combinat",
          "partial": "Word To Tableau",
          "signature": "[a]-\u003eTableau a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Tableaux.html#v:columnWordToTableau"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinat.Tableaux",
          "name": "content",
          "package": "combinat",
          "signature": "Tableau a -\u003e [a]",
          "source": "src/Math-Combinat-Tableaux.html#content",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinat Tableaux",
          "module": "Math.Combinat.Tableaux",
          "name": "content",
          "normalized": "Tableau a-\u003e[a]",
          "package": "combinat",
          "signature": "Tableau a-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Tableaux.html#v:content"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eStanley's hook formula (cf. Fulton page 55)\n\u003c/p\u003e",
          "module": "Math.Combinat.Tableaux",
          "name": "countSemiStandardYoungTableaux",
          "package": "combinat",
          "signature": "Int -\u003e Partition -\u003e Integer",
          "source": "src/Math-Combinat-Tableaux.html#countSemiStandardYoungTableaux",
          "type": "function"
        },
        "index": {
          "description": "Stanley hook formula cf Fulton page",
          "hierarchy": "Math Combinat Tableaux",
          "module": "Math.Combinat.Tableaux",
          "name": "countSemiStandardYoungTableaux",
          "normalized": "Int-\u003ePartition-\u003eInteger",
          "package": "combinat",
          "partial": "Semi Standard Young Tableaux",
          "signature": "Int-\u003ePartition-\u003eInteger",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Tableaux.html#v:countSemiStandardYoungTableaux"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ehook-length formula\n\u003c/p\u003e",
          "module": "Math.Combinat.Tableaux",
          "name": "countStandardYoungTableaux",
          "package": "combinat",
          "signature": "Partition -\u003e Integer",
          "source": "src/Math-Combinat-Tableaux.html#countStandardYoungTableaux",
          "type": "function"
        },
        "index": {
          "description": "hook-length formula",
          "hierarchy": "Math Combinat Tableaux",
          "module": "Math.Combinat.Tableaux",
          "name": "countStandardYoungTableaux",
          "normalized": "Partition-\u003eInteger",
          "package": "combinat",
          "partial": "Standard Young Tableaux",
          "signature": "Partition-\u003eInteger",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Tableaux.html#v:countStandardYoungTableaux"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinat.Tableaux",
          "name": "dualTableau",
          "package": "combinat",
          "signature": "Tableau a -\u003e Tableau a",
          "source": "src/Math-Combinat-Tableaux.html#dualTableau",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinat Tableaux",
          "module": "Math.Combinat.Tableaux",
          "name": "dualTableau",
          "normalized": "Tableau a-\u003eTableau a",
          "package": "combinat",
          "partial": "Tableau",
          "signature": "Tableau a-\u003eTableau a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Tableaux.html#v:dualTableau"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinat.Tableaux",
          "name": "hookLengths",
          "package": "combinat",
          "signature": "Partition -\u003e Tableau Int",
          "source": "src/Math-Combinat-Tableaux.html#hookLengths",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinat Tableaux",
          "module": "Math.Combinat.Tableaux",
          "name": "hookLengths",
          "normalized": "Partition-\u003eTableau Int",
          "package": "combinat",
          "partial": "Lengths",
          "signature": "Partition-\u003eTableau Int",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Tableaux.html#v:hookLengths"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn element \u003ccode\u003e(i,j)\u003c/code\u003e of the resulting tableau (which has shape of the\n given partition) means that the vertical part of the hook has length \u003ccode\u003ei\u003c/code\u003e,\n and the horizontal part \u003ccode\u003ej\u003c/code\u003e. The \u003cem\u003ehook length\u003c/em\u003e is thus \u003ccode\u003ei+j-1\u003c/code\u003e. \n\u003c/p\u003e\u003cp\u003eExample:\n\u003c/p\u003e\u003cpre\u003e \u003e mapM_ print $ hooks $ toPartition [5,4,1]\n [(3,5),(2,4),(2,3),(2,2),(1,1)]\n [(2,4),(1,3),(1,2),(1,1)]\n [(1,1)]\n\u003c/pre\u003e",
          "module": "Math.Combinat.Tableaux",
          "name": "hooks",
          "package": "combinat",
          "signature": "Partition -\u003e Tableau (Int, Int)",
          "source": "src/Math-Combinat-Tableaux.html#hooks",
          "type": "function"
        },
        "index": {
          "description": "An element of the resulting tableau which has shape of the given partition means that the vertical part of the hook has length and the horizontal part The hook length is thus j-1 Example mapM print hooks toPartition",
          "hierarchy": "Math Combinat Tableaux",
          "module": "Math.Combinat.Tableaux",
          "name": "hooks",
          "normalized": "Partition-\u003eTableau(Int,Int)",
          "package": "combinat",
          "signature": "Partition-\u003eTableau(Int,Int)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Tableaux.html#v:hooks"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinat.Tableaux",
          "name": "rowWord",
          "package": "combinat",
          "signature": "Tableau a -\u003e [a]",
          "source": "src/Math-Combinat-Tableaux.html#rowWord",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinat Tableaux",
          "module": "Math.Combinat.Tableaux",
          "name": "rowWord",
          "normalized": "Tableau a-\u003e[a]",
          "package": "combinat",
          "partial": "Word",
          "signature": "Tableau a-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Tableaux.html#v:rowWord"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinat.Tableaux",
          "name": "rowWordToTableau",
          "package": "combinat",
          "signature": "[a] -\u003e Tableau a",
          "source": "src/Math-Combinat-Tableaux.html#rowWordToTableau",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinat Tableaux",
          "module": "Math.Combinat.Tableaux",
          "name": "rowWordToTableau",
          "normalized": "[a]-\u003eTableau a",
          "package": "combinat",
          "partial": "Word To Tableau",
          "signature": "[a]-\u003eTableau a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Tableaux.html#v:rowWordToTableau"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSemistandard Young tableaux of given shape, \"naive\" algorithm    \n\u003c/p\u003e",
          "module": "Math.Combinat.Tableaux",
          "name": "semiStandardYoungTableaux",
          "package": "combinat",
          "signature": "Int -\u003e Partition -\u003e [Tableau Int]",
          "source": "src/Math-Combinat-Tableaux.html#semiStandardYoungTableaux",
          "type": "function"
        },
        "index": {
          "description": "Semistandard Young tableaux of given shape naive algorithm",
          "hierarchy": "Math Combinat Tableaux",
          "module": "Math.Combinat.Tableaux",
          "name": "semiStandardYoungTableaux",
          "normalized": "Int-\u003ePartition-\u003e[Tableau Int]",
          "package": "combinat",
          "partial": "Standard Young Tableaux",
          "signature": "Int-\u003ePartition-\u003e[Tableau Int]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Tableaux.html#v:semiStandardYoungTableaux"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinat.Tableaux",
          "name": "shape",
          "package": "combinat",
          "signature": "Tableau a -\u003e Partition",
          "source": "src/Math-Combinat-Tableaux.html#shape",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinat Tableaux",
          "module": "Math.Combinat.Tableaux",
          "name": "shape",
          "normalized": "Tableau a-\u003ePartition",
          "package": "combinat",
          "signature": "Tableau a-\u003ePartition",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Tableaux.html#v:shape"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eStandard Young tableaux of a given shape.\n   Adapted from John Stembridge, \n   \u003ca\u003ehttp://www.math.lsa.umich.edu/~jrs/software/SFexamples/tableaux\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Math.Combinat.Tableaux",
          "name": "standardYoungTableaux",
          "package": "combinat",
          "signature": "Partition -\u003e [Tableau Int]",
          "source": "src/Math-Combinat-Tableaux.html#standardYoungTableaux",
          "type": "function"
        },
        "index": {
          "description": "Standard Young tableaux of given shape Adapted from John Stembridge http www.math.lsa.umich.edu jrs software SFexamples tableaux",
          "hierarchy": "Math Combinat Tableaux",
          "module": "Math.Combinat.Tableaux",
          "name": "standardYoungTableaux",
          "normalized": "Partition-\u003e[Tableau Int]",
          "package": "combinat",
          "partial": "Young Tableaux",
          "signature": "Partition-\u003e[Tableau Int]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Tableaux.html#v:standardYoungTableaux"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eBinary trees, forests, etc. See:\n   Donald E. Knuth: The Art of Computer Programming, vol 4, pre-fascicle 4A.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Math.Combinat.Trees.Binary",
          "name": "Binary",
          "package": "combinat",
          "source": "src/Math-Combinat-Trees-Binary.html",
          "type": "module"
        },
        "index": {
          "description": "Binary trees forests etc See Donald Knuth The Art of Computer Programming vol pre-fascicle",
          "hierarchy": "Math Combinat Trees Binary",
          "module": "Math.Combinat.Trees.Binary",
          "name": "Binary",
          "package": "combinat",
          "partial": "Binary",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Trees-Binary.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA binary tree with leaves decorated with type \u003ccode\u003ea\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Math.Combinat.Trees.Binary",
          "name": "BinTree",
          "package": "combinat",
          "source": "src/Math-Combinat-Trees-Binary.html#BinTree",
          "type": "data"
        },
        "index": {
          "description": "binary tree with leaves decorated with type",
          "hierarchy": "Math Combinat Trees Binary",
          "module": "Math.Combinat.Trees.Binary",
          "name": "BinTree",
          "package": "combinat",
          "partial": "Bin Tree",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Trees-Binary.html#t:BinTree"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA binary tree with leaves and internal nodes decorated \n with types \u003ccode\u003ea\u003c/code\u003e and \u003ccode\u003eb\u003c/code\u003e, respectively.\n\u003c/p\u003e",
          "module": "Math.Combinat.Trees.Binary",
          "name": "BinTree'",
          "package": "combinat",
          "source": "src/Math-Combinat-Trees-Binary.html#BinTree%27",
          "type": "data"
        },
        "index": {
          "description": "binary tree with leaves and internal nodes decorated with types and respectively",
          "hierarchy": "Math Combinat Trees Binary",
          "module": "Math.Combinat.Trees.Binary",
          "name": "BinTree'",
          "package": "combinat",
          "partial": "Bin Tree'",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Trees-Binary.html#t:BinTree-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinat.Trees.Binary",
          "name": "Paren",
          "package": "combinat",
          "source": "src/Math-Combinat-Trees-Binary.html#Paren",
          "type": "data"
        },
        "index": {
          "hierarchy": "Math Combinat Trees Binary",
          "module": "Math.Combinat.Trees.Binary",
          "name": "Paren",
          "package": "combinat",
          "partial": "Paren",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Trees-Binary.html#t:Paren"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinat.Trees.Binary",
          "name": "Branch",
          "package": "combinat",
          "signature": "Branch (BinTree a) (BinTree a)",
          "source": "src/Math-Combinat-Trees-Binary.html#BinTree",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinat Trees Binary",
          "module": "Math.Combinat.Trees.Binary",
          "name": "Branch",
          "package": "combinat",
          "partial": "Branch",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Trees-Binary.html#v:Branch"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinat.Trees.Binary",
          "name": "Branch'",
          "package": "combinat",
          "signature": "Branch' (BinTree' a b) b (BinTree' a b)",
          "source": "src/Math-Combinat-Trees-Binary.html#BinTree%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinat Trees Binary",
          "module": "Math.Combinat.Trees.Binary",
          "name": "Branch'",
          "package": "combinat",
          "partial": "Branch'",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Trees-Binary.html#v:Branch-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinat.Trees.Binary",
          "name": "Leaf",
          "package": "combinat",
          "signature": "Leaf a",
          "source": "src/Math-Combinat-Trees-Binary.html#BinTree",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinat Trees Binary",
          "module": "Math.Combinat.Trees.Binary",
          "name": "Leaf",
          "package": "combinat",
          "partial": "Leaf",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Trees-Binary.html#v:Leaf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinat.Trees.Binary",
          "name": "Leaf'",
          "package": "combinat",
          "signature": "Leaf' a",
          "source": "src/Math-Combinat-Trees-Binary.html#BinTree%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinat Trees Binary",
          "module": "Math.Combinat.Trees.Binary",
          "name": "Leaf'",
          "package": "combinat",
          "partial": "Leaf'",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Trees-Binary.html#v:Leaf-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinat.Trees.Binary",
          "name": "LeftParen",
          "package": "combinat",
          "signature": "LeftParen",
          "source": "src/Math-Combinat-Trees-Binary.html#Paren",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinat Trees Binary",
          "module": "Math.Combinat.Trees.Binary",
          "name": "LeftParen",
          "package": "combinat",
          "partial": "Left Paren",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Trees-Binary.html#v:LeftParen"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinat.Trees.Binary",
          "name": "RightParen",
          "package": "combinat",
          "signature": "RightParen",
          "source": "src/Math-Combinat-Trees-Binary.html#Paren",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinat Trees Binary",
          "module": "Math.Combinat.Trees.Binary",
          "name": "RightParen",
          "package": "combinat",
          "partial": "Right Paren",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Trees-Binary.html#v:RightParen"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinat.Trees.Binary",
          "name": "binaryTreeToForest",
          "package": "combinat",
          "signature": "BinTree a -\u003e Forest ()",
          "source": "src/Math-Combinat-Trees-Binary.html#binaryTreeToForest",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinat Trees Binary",
          "module": "Math.Combinat.Trees.Binary",
          "name": "binaryTreeToForest",
          "normalized": "BinTree a-\u003eForest()",
          "package": "combinat",
          "partial": "Tree To Forest",
          "signature": "BinTree a-\u003eForest()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Trees-Binary.html#v:binaryTreeToForest"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinat.Trees.Binary",
          "name": "binaryTreeToNestedParentheses",
          "package": "combinat",
          "signature": "BinTree a -\u003e [Paren]",
          "source": "src/Math-Combinat-Trees-Binary.html#binaryTreeToNestedParentheses",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinat Trees Binary",
          "module": "Math.Combinat.Trees.Binary",
          "name": "binaryTreeToNestedParentheses",
          "normalized": "BinTree a-\u003e[Paren]",
          "package": "combinat",
          "partial": "Tree To Nested Parentheses",
          "signature": "BinTree a-\u003e[Paren]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Trees-Binary.html#v:binaryTreeToNestedParentheses"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGenerates all binary trees with n nodes. \n   At the moment just a synonym for \u003ccode\u003e\u003ca\u003ebinaryTreesNaive\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Math.Combinat.Trees.Binary",
          "name": "binaryTrees",
          "package": "combinat",
          "signature": "Int -\u003e [BinTree ()]",
          "source": "src/Math-Combinat-Trees-Binary.html#binaryTrees",
          "type": "function"
        },
        "index": {
          "description": "Generates all binary trees with nodes At the moment just synonym for binaryTreesNaive",
          "hierarchy": "Math Combinat Trees Binary",
          "module": "Math.Combinat.Trees.Binary",
          "name": "binaryTrees",
          "normalized": "Int-\u003e[BinTree()]",
          "package": "combinat",
          "partial": "Trees",
          "signature": "Int-\u003e[BinTree()]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Trees-Binary.html#v:binaryTrees"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGenerates all binary trees with n nodes. The naive algorithm.\n\u003c/p\u003e",
          "module": "Math.Combinat.Trees.Binary",
          "name": "binaryTreesNaive",
          "package": "combinat",
          "signature": "Int -\u003e [BinTree ()]",
          "source": "src/Math-Combinat-Trees-Binary.html#binaryTreesNaive",
          "type": "function"
        },
        "index": {
          "description": "Generates all binary trees with nodes The naive algorithm",
          "hierarchy": "Math Combinat Trees Binary",
          "module": "Math.Combinat.Trees.Binary",
          "name": "binaryTreesNaive",
          "normalized": "Int-\u003e[BinTree()]",
          "package": "combinat",
          "partial": "Trees Naive",
          "signature": "Int-\u003e[BinTree()]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Trees-Binary.html#v:binaryTreesNaive"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e# = Catalan(n) = \\frac { 1 } { n+1 } \\binom { 2n } { n }.\n\u003c/p\u003e\u003cp\u003eThis is also the counting function for forests and nested parentheses.\n\u003c/p\u003e",
          "module": "Math.Combinat.Trees.Binary",
          "name": "countBinaryTrees",
          "package": "combinat",
          "signature": "Int -\u003e Integer",
          "source": "src/Math-Combinat-Trees-Binary.html#countBinaryTrees",
          "type": "function"
        },
        "index": {
          "description": "Catalan frac binom This is also the counting function for forests and nested parentheses",
          "hierarchy": "Math Combinat Trees Binary",
          "module": "Math.Combinat.Trees.Binary",
          "name": "countBinaryTrees",
          "normalized": "Int-\u003eInteger",
          "package": "combinat",
          "partial": "Binary Trees",
          "signature": "Int-\u003eInteger",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Trees-Binary.html#v:countBinaryTrees"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinat.Trees.Binary",
          "name": "countNestedParentheses",
          "package": "combinat",
          "signature": "Int -\u003e Integer",
          "source": "src/Math-Combinat-Trees-Binary.html#countNestedParentheses",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinat Trees Binary",
          "module": "Math.Combinat.Trees.Binary",
          "name": "countNestedParentheses",
          "normalized": "Int-\u003eInteger",
          "package": "combinat",
          "partial": "Nested Parentheses",
          "signature": "Int-\u003eInteger",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Trees-Binary.html#v:countNestedParentheses"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGenerates all sequences of nested parentheses of length 2n.\n Order is lexigraphic (when right parentheses are considered \n smaller then left ones).\n Based on \"Algorithm P\" in Knuth, but less efficient because of\n the \"idiomatic\" code.\n\u003c/p\u003e",
          "module": "Math.Combinat.Trees.Binary",
          "name": "fasc4A_algorithm_P",
          "package": "combinat",
          "signature": "Int -\u003e [[Paren]]",
          "source": "src/Math-Combinat-Trees-Binary.html#fasc4A_algorithm_P",
          "type": "function"
        },
        "index": {
          "description": "Generates all sequences of nested parentheses of length Order is lexigraphic when right parentheses are considered smaller then left ones Based on Algorithm in Knuth but less efficient because of the idiomatic code",
          "hierarchy": "Math Combinat Trees Binary",
          "module": "Math.Combinat.Trees.Binary",
          "name": "fasc4A_algorithm_P",
          "normalized": "Int-\u003e[[Paren]]",
          "package": "combinat",
          "signature": "Int-\u003e[[Paren]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Trees-Binary.html#v:fasc4A_algorithm_P"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGrows a uniformly random binary tree. \n \"Algorithm R\" (Remy's procudere) in Knuth.\n Nodes are decorated with odd numbers, leaves with even numbers (from the\n set \u003ccode\u003e[0..2n]\u003c/code\u003e). Uses mutable arrays internally.\n\u003c/p\u003e",
          "module": "Math.Combinat.Trees.Binary",
          "name": "fasc4A_algorithm_R",
          "package": "combinat",
          "signature": "Int -\u003e g -\u003e (BinTree' Int Int, g)",
          "source": "src/Math-Combinat-Trees-Binary.html#fasc4A_algorithm_R",
          "type": "function"
        },
        "index": {
          "description": "Grows uniformly random binary tree Algorithm Remy procudere in Knuth Nodes are decorated with odd numbers leaves with even numbers from the set Uses mutable arrays internally",
          "hierarchy": "Math Combinat Trees Binary",
          "module": "Math.Combinat.Trees.Binary",
          "name": "fasc4A_algorithm_R",
          "normalized": "Int-\u003ea-\u003e(BinTree' Int Int,a)",
          "package": "combinat",
          "signature": "Int-\u003eg-\u003e(BinTree' Int Int,g)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Trees-Binary.html#v:fasc4A_algorithm_R"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eNth sequence of nested parentheses of length 2n. \n The order is the same as in \u003ccode\u003e\u003ca\u003efasc4A_algorithm_P\u003c/a\u003e\u003c/code\u003e.\n Based on \"Algorithm U\" in Knuth.\n\u003c/p\u003e",
          "module": "Math.Combinat.Trees.Binary",
          "name": "fasc4A_algorithm_U",
          "package": "combinat",
          "signature": "Int-\u003e Integer-\u003e [Paren]",
          "type": "function"
        },
        "index": {
          "description": "Nth sequence of nested parentheses of length The order is the same as in fasc4A algorithm Based on Algorithm in Knuth",
          "hierarchy": "Math Combinat Trees Binary",
          "module": "Math.Combinat.Trees.Binary",
          "name": "fasc4A_algorithm_U",
          "normalized": "Int-\u003eInteger-\u003e[Paren]",
          "package": "combinat",
          "signature": "Int-\u003eInteger-\u003e[Paren]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Trees-Binary.html#v:fasc4A_algorithm_U"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGenerates a uniformly random sequence of nested parentheses of length 2n.    \n Based on \"Algorithm W\" in Knuth.\n\u003c/p\u003e",
          "module": "Math.Combinat.Trees.Binary",
          "name": "fasc4A_algorithm_W",
          "package": "combinat",
          "signature": "Int -\u003e g -\u003e ([Paren], g)",
          "source": "src/Math-Combinat-Trees-Binary.html#fasc4A_algorithm_W",
          "type": "function"
        },
        "index": {
          "description": "Generates uniformly random sequence of nested parentheses of length Based on Algorithm in Knuth",
          "hierarchy": "Math Combinat Trees Binary",
          "module": "Math.Combinat.Trees.Binary",
          "name": "fasc4A_algorithm_W",
          "normalized": "Int-\u003ea-\u003e([Paren],a)",
          "package": "combinat",
          "signature": "Int-\u003eg-\u003e([Paren],g)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Trees-Binary.html#v:fasc4A_algorithm_W"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinat.Trees.Binary",
          "name": "forestToBinaryTree",
          "package": "combinat",
          "signature": "Forest a -\u003e BinTree ()",
          "source": "src/Math-Combinat-Trees-Binary.html#forestToBinaryTree",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinat Trees Binary",
          "module": "Math.Combinat.Trees.Binary",
          "name": "forestToBinaryTree",
          "normalized": "Forest a-\u003eBinTree()",
          "package": "combinat",
          "partial": "To Binary Tree",
          "signature": "Forest a-\u003eBinTree()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Trees-Binary.html#v:forestToBinaryTree"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinat.Trees.Binary",
          "name": "forestToNestedParentheses",
          "package": "combinat",
          "signature": "Forest a -\u003e [Paren]",
          "source": "src/Math-Combinat-Trees-Binary.html#forestToNestedParentheses",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinat Trees Binary",
          "module": "Math.Combinat.Trees.Binary",
          "name": "forestToNestedParentheses",
          "normalized": "Forest a-\u003e[Paren]",
          "package": "combinat",
          "partial": "To Nested Parentheses",
          "signature": "Forest a-\u003e[Paren]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Trees-Binary.html#v:forestToNestedParentheses"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinat.Trees.Binary",
          "name": "forgetNodeDecorations",
          "package": "combinat",
          "signature": "BinTree' a b -\u003e BinTree a",
          "source": "src/Math-Combinat-Trees-Binary.html#forgetNodeDecorations",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinat Trees Binary",
          "module": "Math.Combinat.Trees.Binary",
          "name": "forgetNodeDecorations",
          "normalized": "BinTree' a b-\u003eBinTree a",
          "package": "combinat",
          "partial": "Node Decorations",
          "signature": "BinTree' a b-\u003eBinTree a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Trees-Binary.html#v:forgetNodeDecorations"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinat.Trees.Binary",
          "name": "leaf",
          "package": "combinat",
          "signature": "BinTree ()",
          "source": "src/Math-Combinat-Trees-Binary.html#leaf",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinat Trees Binary",
          "module": "Math.Combinat.Trees.Binary",
          "name": "leaf",
          "normalized": "BinTree()",
          "package": "combinat",
          "signature": "BinTree()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Trees-Binary.html#v:leaf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSynonym for \u003ccode\u003e\u003ca\u003efasc4A_algorithm_P\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Math.Combinat.Trees.Binary",
          "name": "nestedParentheses",
          "package": "combinat",
          "signature": "Int -\u003e [[Paren]]",
          "source": "src/Math-Combinat-Trees-Binary.html#nestedParentheses",
          "type": "function"
        },
        "index": {
          "description": "Synonym for fasc4A algorithm",
          "hierarchy": "Math Combinat Trees Binary",
          "module": "Math.Combinat.Trees.Binary",
          "name": "nestedParentheses",
          "normalized": "Int-\u003e[[Paren]]",
          "package": "combinat",
          "partial": "Parentheses",
          "signature": "Int-\u003e[[Paren]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Trees-Binary.html#v:nestedParentheses"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinat.Trees.Binary",
          "name": "nestedParenthesesToBinaryTree",
          "package": "combinat",
          "signature": "[Paren] -\u003e Maybe (BinTree ())",
          "source": "src/Math-Combinat-Trees-Binary.html#nestedParenthesesToBinaryTree",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinat Trees Binary",
          "module": "Math.Combinat.Trees.Binary",
          "name": "nestedParenthesesToBinaryTree",
          "normalized": "[Paren]-\u003eMaybe(BinTree())",
          "package": "combinat",
          "partial": "Parentheses To Binary Tree",
          "signature": "[Paren]-\u003eMaybe(BinTree())",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Trees-Binary.html#v:nestedParenthesesToBinaryTree"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinat.Trees.Binary",
          "name": "nestedParenthesesToBinaryTreeUnsafe",
          "package": "combinat",
          "signature": "[Paren] -\u003e BinTree ()",
          "source": "src/Math-Combinat-Trees-Binary.html#nestedParenthesesToBinaryTreeUnsafe",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinat Trees Binary",
          "module": "Math.Combinat.Trees.Binary",
          "name": "nestedParenthesesToBinaryTreeUnsafe",
          "normalized": "[Paren]-\u003eBinTree()",
          "package": "combinat",
          "partial": "Parentheses To Binary Tree Unsafe",
          "signature": "[Paren]-\u003eBinTree()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Trees-Binary.html#v:nestedParenthesesToBinaryTreeUnsafe"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinat.Trees.Binary",
          "name": "nestedParenthesesToForest",
          "package": "combinat",
          "signature": "[Paren] -\u003e Maybe (Forest ())",
          "source": "src/Math-Combinat-Trees-Binary.html#nestedParenthesesToForest",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinat Trees Binary",
          "module": "Math.Combinat.Trees.Binary",
          "name": "nestedParenthesesToForest",
          "normalized": "[Paren]-\u003eMaybe(Forest())",
          "package": "combinat",
          "partial": "Parentheses To Forest",
          "signature": "[Paren]-\u003eMaybe(Forest())",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Trees-Binary.html#v:nestedParenthesesToForest"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinat.Trees.Binary",
          "name": "nestedParenthesesToForestUnsafe",
          "package": "combinat",
          "signature": "[Paren] -\u003e Forest ()",
          "source": "src/Math-Combinat-Trees-Binary.html#nestedParenthesesToForestUnsafe",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinat Trees Binary",
          "module": "Math.Combinat.Trees.Binary",
          "name": "nestedParenthesesToForestUnsafe",
          "normalized": "[Paren]-\u003eForest()",
          "package": "combinat",
          "partial": "Parentheses To Forest Unsafe",
          "signature": "[Paren]-\u003eForest()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Trees-Binary.html#v:nestedParenthesesToForestUnsafe"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSynonym for \u003ccode\u003e\u003ca\u003efasc4A_algorithm_U\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Math.Combinat.Trees.Binary",
          "name": "nthNestedParentheses",
          "package": "combinat",
          "signature": "Int -\u003e Integer -\u003e [Paren]",
          "source": "src/Math-Combinat-Trees-Binary.html#nthNestedParentheses",
          "type": "function"
        },
        "index": {
          "description": "Synonym for fasc4A algorithm",
          "hierarchy": "Math Combinat Trees Binary",
          "module": "Math.Combinat.Trees.Binary",
          "name": "nthNestedParentheses",
          "normalized": "Int-\u003eInteger-\u003e[Paren]",
          "package": "combinat",
          "partial": "Nested Parentheses",
          "signature": "Int-\u003eInteger-\u003e[Paren]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Trees-Binary.html#v:nthNestedParentheses"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinat.Trees.Binary",
          "name": "parenthesesToString",
          "package": "combinat",
          "signature": "[Paren] -\u003e String",
          "source": "src/Math-Combinat-Trees-Binary.html#parenthesesToString",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinat Trees Binary",
          "module": "Math.Combinat.Trees.Binary",
          "name": "parenthesesToString",
          "normalized": "[Paren]-\u003eString",
          "package": "combinat",
          "partial": "To String",
          "signature": "[Paren]-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Trees-Binary.html#v:parenthesesToString"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGenerates an uniformly random binary tree, using \u003ccode\u003e\u003ca\u003efasc4A_algorithm_R\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Math.Combinat.Trees.Binary",
          "name": "randomBinaryTree",
          "package": "combinat",
          "signature": "Int -\u003e g -\u003e (BinTree (), g)",
          "source": "src/Math-Combinat-Trees-Binary.html#randomBinaryTree",
          "type": "function"
        },
        "index": {
          "description": "Generates an uniformly random binary tree using fasc4A algorithm",
          "hierarchy": "Math Combinat Trees Binary",
          "module": "Math.Combinat.Trees.Binary",
          "name": "randomBinaryTree",
          "normalized": "Int-\u003ea-\u003e(BinTree(),a)",
          "package": "combinat",
          "partial": "Binary Tree",
          "signature": "Int-\u003eg-\u003e(BinTree(),g)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Trees-Binary.html#v:randomBinaryTree"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSynonym for \u003ccode\u003e\u003ca\u003efasc4A_algorithm_W\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Math.Combinat.Trees.Binary",
          "name": "randomNestedParentheses",
          "package": "combinat",
          "signature": "Int -\u003e g -\u003e ([Paren], g)",
          "source": "src/Math-Combinat-Trees-Binary.html#randomNestedParentheses",
          "type": "function"
        },
        "index": {
          "description": "Synonym for fasc4A algorithm",
          "hierarchy": "Math Combinat Trees Binary",
          "module": "Math.Combinat.Trees.Binary",
          "name": "randomNestedParentheses",
          "normalized": "Int-\u003ea-\u003e([Paren],a)",
          "package": "combinat",
          "partial": "Nested Parentheses",
          "signature": "Int-\u003eg-\u003e([Paren],g)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Trees-Binary.html#v:randomNestedParentheses"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinat.Trees.Binary",
          "name": "stringToParentheses",
          "package": "combinat",
          "signature": "String -\u003e [Paren]",
          "source": "src/Math-Combinat-Trees-Binary.html#stringToParentheses",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinat Trees Binary",
          "module": "Math.Combinat.Trees.Binary",
          "name": "stringToParentheses",
          "normalized": "String-\u003e[Paren]",
          "package": "combinat",
          "partial": "To Parentheses",
          "signature": "String-\u003e[Paren]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Trees-Binary.html#v:stringToParentheses"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eN-ary trees.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Math.Combinat.Trees.Nary",
          "name": "Nary",
          "package": "combinat",
          "source": "src/Math-Combinat-Trees-Nary.html",
          "type": "module"
        },
        "index": {
          "description": "N-ary trees",
          "hierarchy": "Math Combinat Trees Nary",
          "module": "Math.Combinat.Trees.Nary",
          "name": "Nary",
          "package": "combinat",
          "partial": "Nary",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Trees-Nary.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAdds unique labels to a \u003ccode\u003e\u003ca\u003eForest\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Math.Combinat.Trees.Nary",
          "name": "addUniqueLabelsForest",
          "package": "combinat",
          "signature": "Forest a -\u003e Forest (a, Int)",
          "source": "src/Math-Combinat-Trees-Nary.html#addUniqueLabelsForest",
          "type": "function"
        },
        "index": {
          "description": "Adds unique labels to Forest",
          "hierarchy": "Math Combinat Trees Nary",
          "module": "Math.Combinat.Trees.Nary",
          "name": "addUniqueLabelsForest",
          "normalized": "Forest a-\u003eForest(a,Int)",
          "package": "combinat",
          "partial": "Unique Labels Forest",
          "signature": "Forest a-\u003eForest(a,Int)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Trees-Nary.html#v:addUniqueLabelsForest"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinat.Trees.Nary",
          "name": "addUniqueLabelsForest_",
          "package": "combinat",
          "signature": "Forest a -\u003e Forest Int",
          "source": "src/Math-Combinat-Trees-Nary.html#addUniqueLabelsForest_",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinat Trees Nary",
          "module": "Math.Combinat.Trees.Nary",
          "name": "addUniqueLabelsForest_",
          "normalized": "Forest a-\u003eForest Int",
          "package": "combinat",
          "partial": "Unique Labels Forest",
          "signature": "Forest a-\u003eForest Int",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Trees-Nary.html#v:addUniqueLabelsForest_"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAdds unique labels to a \u003ccode\u003e\u003ca\u003eTree\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Math.Combinat.Trees.Nary",
          "name": "addUniqueLabelsTree",
          "package": "combinat",
          "signature": "Tree a -\u003e Tree (a, Int)",
          "source": "src/Math-Combinat-Trees-Nary.html#addUniqueLabelsTree",
          "type": "function"
        },
        "index": {
          "description": "Adds unique labels to Tree",
          "hierarchy": "Math Combinat Trees Nary",
          "module": "Math.Combinat.Trees.Nary",
          "name": "addUniqueLabelsTree",
          "normalized": "Tree a-\u003eTree(a,Int)",
          "package": "combinat",
          "partial": "Unique Labels Tree",
          "signature": "Tree a-\u003eTree(a,Int)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Trees-Nary.html#v:addUniqueLabelsTree"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinat.Trees.Nary",
          "name": "addUniqueLabelsTree_",
          "package": "combinat",
          "signature": "Tree a -\u003e Tree Int",
          "source": "src/Math-Combinat-Trees-Nary.html#addUniqueLabelsTree_",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinat Trees Nary",
          "module": "Math.Combinat.Trees.Nary",
          "name": "addUniqueLabelsTree_",
          "normalized": "Tree a-\u003eTree Int",
          "package": "combinat",
          "partial": "Unique Labels Tree",
          "signature": "Tree a-\u003eTree Int",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Trees-Nary.html#v:addUniqueLabelsTree_"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eComputes the set of equivalence classes of rooted trees (in the \n sense that the leaves of a node are \u003cem\u003eunordered\u003c/em\u003e) \n with \u003ccode\u003en = length ks\u003c/code\u003e leaves where the set of heights of \n the leaves matches the given set of numbers. \n The height is defined as the number of \u003cem\u003eedges\u003c/em\u003e from the leaf to the root. \n\u003c/p\u003e\u003cp\u003eTODO: better name?\n\u003c/p\u003e",
          "module": "Math.Combinat.Trees.Nary",
          "name": "derivTrees",
          "package": "combinat",
          "signature": "[Int] -\u003e [Tree ()]",
          "source": "src/Math-Combinat-Trees-Nary.html#derivTrees",
          "type": "function"
        },
        "index": {
          "description": "Computes the set of equivalence classes of rooted trees in the sense that the leaves of node are unordered with length ks leaves where the set of heights of the leaves matches the given set of numbers The height is defined as the number of edges from the leaf to the root TODO better name",
          "hierarchy": "Math Combinat Trees Nary",
          "module": "Math.Combinat.Trees.Nary",
          "name": "derivTrees",
          "normalized": "[Int]-\u003e[Tree()]",
          "package": "combinat",
          "partial": "Trees",
          "signature": "[Int]-\u003e[Tree()]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Trees-Nary.html#v:derivTrees"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinat.Trees.Nary",
          "name": "labelDepthForest",
          "package": "combinat",
          "signature": "Forest a -\u003e Forest (a, Int)",
          "source": "src/Math-Combinat-Trees-Nary.html#labelDepthForest",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinat Trees Nary",
          "module": "Math.Combinat.Trees.Nary",
          "name": "labelDepthForest",
          "normalized": "Forest a-\u003eForest(a,Int)",
          "package": "combinat",
          "partial": "Depth Forest",
          "signature": "Forest a-\u003eForest(a,Int)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Trees-Nary.html#v:labelDepthForest"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinat.Trees.Nary",
          "name": "labelDepthForest_",
          "package": "combinat",
          "signature": "Forest a -\u003e Forest Int",
          "source": "src/Math-Combinat-Trees-Nary.html#labelDepthForest_",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinat Trees Nary",
          "module": "Math.Combinat.Trees.Nary",
          "name": "labelDepthForest_",
          "normalized": "Forest a-\u003eForest Int",
          "package": "combinat",
          "partial": "Depth Forest",
          "signature": "Forest a-\u003eForest Int",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Trees-Nary.html#v:labelDepthForest_"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAttaches the depth to each node. The depth of the root is 0. \n\u003c/p\u003e",
          "module": "Math.Combinat.Trees.Nary",
          "name": "labelDepthTree",
          "package": "combinat",
          "signature": "Tree a -\u003e Tree (a, Int)",
          "source": "src/Math-Combinat-Trees-Nary.html#labelDepthTree",
          "type": "function"
        },
        "index": {
          "description": "Attaches the depth to each node The depth of the root is",
          "hierarchy": "Math Combinat Trees Nary",
          "module": "Math.Combinat.Trees.Nary",
          "name": "labelDepthTree",
          "normalized": "Tree a-\u003eTree(a,Int)",
          "package": "combinat",
          "partial": "Depth Tree",
          "signature": "Tree a-\u003eTree(a,Int)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Trees-Nary.html#v:labelDepthTree"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinat.Trees.Nary",
          "name": "labelDepthTree_",
          "package": "combinat",
          "signature": "Tree a -\u003e Tree Int",
          "source": "src/Math-Combinat-Trees-Nary.html#labelDepthTree_",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinat Trees Nary",
          "module": "Math.Combinat.Trees.Nary",
          "name": "labelDepthTree_",
          "normalized": "Tree a-\u003eTree Int",
          "package": "combinat",
          "partial": "Depth Tree",
          "signature": "Tree a-\u003eTree Int",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Trees-Nary.html#v:labelDepthTree_"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinat.Trees.Nary",
          "name": "labelNChildrenForest",
          "package": "combinat",
          "signature": "Forest a -\u003e Forest (a, Int)",
          "source": "src/Math-Combinat-Trees-Nary.html#labelNChildrenForest",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinat Trees Nary",
          "module": "Math.Combinat.Trees.Nary",
          "name": "labelNChildrenForest",
          "normalized": "Forest a-\u003eForest(a,Int)",
          "package": "combinat",
          "partial": "NChildren Forest",
          "signature": "Forest a-\u003eForest(a,Int)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Trees-Nary.html#v:labelNChildrenForest"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinat.Trees.Nary",
          "name": "labelNChildrenForest_",
          "package": "combinat",
          "signature": "Forest a -\u003e Forest Int",
          "source": "src/Math-Combinat-Trees-Nary.html#labelNChildrenForest_",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinat Trees Nary",
          "module": "Math.Combinat.Trees.Nary",
          "name": "labelNChildrenForest_",
          "normalized": "Forest a-\u003eForest Int",
          "package": "combinat",
          "partial": "NChildren Forest",
          "signature": "Forest a-\u003eForest Int",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Trees-Nary.html#v:labelNChildrenForest_"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAttaches the number of children to each node. \n\u003c/p\u003e",
          "module": "Math.Combinat.Trees.Nary",
          "name": "labelNChildrenTree",
          "package": "combinat",
          "signature": "Tree a -\u003e Tree (a, Int)",
          "source": "src/Math-Combinat-Trees-Nary.html#labelNChildrenTree",
          "type": "function"
        },
        "index": {
          "description": "Attaches the number of children to each node",
          "hierarchy": "Math Combinat Trees Nary",
          "module": "Math.Combinat.Trees.Nary",
          "name": "labelNChildrenTree",
          "normalized": "Tree a-\u003eTree(a,Int)",
          "package": "combinat",
          "partial": "NChildren Tree",
          "signature": "Tree a-\u003eTree(a,Int)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Trees-Nary.html#v:labelNChildrenTree"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinat.Trees.Nary",
          "name": "labelNChildrenTree_",
          "package": "combinat",
          "signature": "Tree a -\u003e Tree Int",
          "source": "src/Math-Combinat-Trees-Nary.html#labelNChildrenTree_",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinat Trees Nary",
          "module": "Math.Combinat.Trees.Nary",
          "name": "labelNChildrenTree_",
          "normalized": "Tree a-\u003eTree Int",
          "package": "combinat",
          "partial": "NChildren Tree",
          "signature": "Tree a-\u003eTree Int",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Trees-Nary.html#v:labelNChildrenTree_"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinat.Trees",
          "name": "Trees",
          "package": "combinat",
          "source": "src/Math-Combinat-Trees.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Math Combinat Trees",
          "module": "Math.Combinat.Trees",
          "name": "Trees",
          "package": "combinat",
          "partial": "Trees",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Trees.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eTuples.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Math.Combinat.Tuples",
          "name": "Tuples",
          "package": "combinat",
          "source": "src/Math-Combinat-Tuples.html",
          "type": "module"
        },
        "index": {
          "description": "Tuples",
          "hierarchy": "Math Combinat Tuples",
          "module": "Math.Combinat.Tuples",
          "name": "Tuples",
          "package": "combinat",
          "partial": "Tuples",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Tuples.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinat.Tuples",
          "name": "binaryTuples",
          "package": "combinat",
          "signature": "Int -\u003e [[Bool]]",
          "source": "src/Math-Combinat-Tuples.html#binaryTuples",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinat Tuples",
          "module": "Math.Combinat.Tuples",
          "name": "binaryTuples",
          "normalized": "Int-\u003e[[Bool]]",
          "package": "combinat",
          "partial": "Tuples",
          "signature": "Int-\u003e[[Bool]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Tuples.html#v:binaryTuples"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e# = (m+1) ^ len\n\u003c/p\u003e",
          "module": "Math.Combinat.Tuples",
          "name": "countTuples",
          "package": "combinat",
          "signature": "Int -\u003e Int -\u003e Integer",
          "source": "src/Math-Combinat-Tuples.html#countTuples",
          "type": "function"
        },
        "index": {
          "description": "len",
          "hierarchy": "Math Combinat Tuples",
          "module": "Math.Combinat.Tuples",
          "name": "countTuples",
          "normalized": "Int-\u003eInt-\u003eInteger",
          "package": "combinat",
          "partial": "Tuples",
          "signature": "Int-\u003eInt-\u003eInteger",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Tuples.html#v:countTuples"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e# = \\prod_i (m_i + 1)\n\u003c/p\u003e",
          "module": "Math.Combinat.Tuples",
          "name": "countTuples'",
          "package": "combinat",
          "signature": "[Int] -\u003e Integer",
          "source": "src/Math-Combinat-Tuples.html#countTuples%27",
          "type": "function"
        },
        "index": {
          "description": "prod",
          "hierarchy": "Math Combinat Tuples",
          "module": "Math.Combinat.Tuples",
          "name": "countTuples'",
          "normalized": "[Int]-\u003eInteger",
          "package": "combinat",
          "partial": "Tuples'",
          "signature": "[Int]-\u003eInteger",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Tuples.html#v:countTuples-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e# = m ^ len\n\u003c/p\u003e",
          "module": "Math.Combinat.Tuples",
          "name": "countTuples1",
          "package": "combinat",
          "signature": "Int -\u003e Int -\u003e Integer",
          "source": "src/Math-Combinat-Tuples.html#countTuples1",
          "type": "function"
        },
        "index": {
          "description": "len",
          "hierarchy": "Math Combinat Tuples",
          "module": "Math.Combinat.Tuples",
          "name": "countTuples1",
          "normalized": "Int-\u003eInt-\u003eInteger",
          "package": "combinat",
          "partial": "Tuples",
          "signature": "Int-\u003eInt-\u003eInteger",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Tuples.html#v:countTuples1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e# = \\prod_i m_i\n\u003c/p\u003e",
          "module": "Math.Combinat.Tuples",
          "name": "countTuples1'",
          "package": "combinat",
          "signature": "[Int] -\u003e Integer",
          "source": "src/Math-Combinat-Tuples.html#countTuples1%27",
          "type": "function"
        },
        "index": {
          "description": "prod",
          "hierarchy": "Math Combinat Tuples",
          "module": "Math.Combinat.Tuples",
          "name": "countTuples1'",
          "normalized": "[Int]-\u003eInteger",
          "package": "combinat",
          "partial": "Tuples",
          "signature": "[Int]-\u003eInteger",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Tuples.html#v:countTuples1-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinat.Tuples",
          "name": "tuples",
          "package": "combinat",
          "signature": "Int-\u003e Int-\u003e [[Int]]",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinat Tuples",
          "module": "Math.Combinat.Tuples",
          "name": "tuples",
          "normalized": "Int-\u003eInt-\u003e[[Int]]",
          "package": "combinat",
          "signature": "Int-\u003eInt-\u003e[[Int]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Tuples.html#v:tuples"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\"Tuples\" fitting into a give shape. The order is lexicographic, that is,\n\u003c/p\u003e\u003cpre\u003e sort ts == ts where ts = tuples' shape\n\u003c/pre\u003e\u003cp\u003eExample: \n\u003c/p\u003e\u003cpre\u003e tuples' [2,3] = \n   [[0,0],[0,1],[0,2],[0,3],[1,0],[1,1],[1,2],[1,3],[2,0],[2,1],[2,2],[2,3]]\n\u003c/pre\u003e",
          "module": "Math.Combinat.Tuples",
          "name": "tuples'",
          "package": "combinat",
          "signature": "[Int] -\u003e [[Int]]",
          "source": "src/Math-Combinat-Tuples.html#tuples%27",
          "type": "function"
        },
        "index": {
          "description": "Tuples fitting into give shape The order is lexicographic that is sort ts ts where ts tuples shape Example tuples",
          "hierarchy": "Math Combinat Tuples",
          "module": "Math.Combinat.Tuples",
          "name": "tuples'",
          "normalized": "[Int]-\u003e[[Int]]",
          "package": "combinat",
          "signature": "[Int]-\u003e[[Int]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Tuples.html#v:tuples-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.Combinat.Tuples",
          "name": "tuples1",
          "package": "combinat",
          "signature": "Int-\u003e Int-\u003e [[Int]]",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math Combinat Tuples",
          "module": "Math.Combinat.Tuples",
          "name": "tuples1",
          "normalized": "Int-\u003eInt-\u003e[[Int]]",
          "package": "combinat",
          "signature": "Int-\u003eInt-\u003e[[Int]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Tuples.html#v:tuples1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003epositive \"tuples\" fitting into a give shape.\n\u003c/p\u003e",
          "module": "Math.Combinat.Tuples",
          "name": "tuples1'",
          "package": "combinat",
          "signature": "[Int] -\u003e [[Int]]",
          "source": "src/Math-Combinat-Tuples.html#tuples1%27",
          "type": "function"
        },
        "index": {
          "description": "positive tuples fitting into give shape",
          "hierarchy": "Math Combinat Tuples",
          "module": "Math.Combinat.Tuples",
          "name": "tuples1'",
          "normalized": "[Int]-\u003e[[Int]]",
          "package": "combinat",
          "signature": "[Int]-\u003e[[Int]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat-Tuples.html#v:tuples1-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eA collection of functions to generate combinatorial\n objects like partitions, combinations, permutations,\n Young tableaux, various trees, etc.\n\u003c/p\u003e\u003cp\u003eThe long-term goals are \n\u003c/p\u003e\u003col\u003e\u003cli\u003e to be efficient; \n\u003c/li\u003e\u003cli\u003e to be able to enumerate the structures \n      with constant memory usage. \n\u003c/li\u003e\u003c/ol\u003e\u003cp\u003eThe short-term goal is to generate \n many interesting structures.\n\u003c/p\u003e\u003cp\u003eNaming conventions (subject to change): \n\u003c/p\u003e\u003cul\u003e\u003cli\u003e prime suffix: additional constrains, typically more general;\n\u003c/li\u003e\u003cli\u003e underscore prefix: use plain lists instead of other types with \n    enforced invariants;\n\u003c/li\u003e\u003cli\u003e \"random\" prefix: generates random objects \n    (typically with uniform distribution); \n\u003c/li\u003e\u003cli\u003e \"count\" prefix: counting functions.\n\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e",
          "module": "Math.Combinat",
          "name": "Combinat",
          "package": "combinat",
          "source": "src/Math-Combinat.html",
          "type": "module"
        },
        "index": {
          "description": "collection of functions to generate combinatorial objects like partitions combinations permutations Young tableaux various trees etc The long-term goals are to be efficient to be able to enumerate the structures with constant memory usage The short-term goal is to generate many interesting structures Naming conventions subject to change prime suffix additional constrains typically more general underscore prefix use plain lists instead of other types with enforced invariants random prefix generates random objects typically with uniform distribution count prefix counting functions",
          "hierarchy": "Math Combinat",
          "module": "Math.Combinat",
          "name": "Combinat",
          "package": "combinat",
          "partial": "Combinat",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/combinat/docs/Math-Combinat.html#"
      }
    }
  ]
]