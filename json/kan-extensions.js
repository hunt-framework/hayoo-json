[
  {
    "cmd": "delete-by-query",
    "query": {
      "contexts": [
        "package"
      ],
      "query": {
        "op": "case",
        "type": "word",
        "word": "kan-extensions"
      },
      "type": "context"
    }
  },
  [
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThe \u003ccode\u003e\u003ca\u003eDensity\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eComonad\u003c/a\u003e\u003c/code\u003e for a \u003ccode\u003e\u003ca\u003eFunctor\u003c/a\u003e\u003c/code\u003e (aka the 'Comonad generated by a \u003ccode\u003e\u003ca\u003eFunctor\u003c/a\u003e\u003c/code\u003e)\n The \u003ccode\u003e\u003ca\u003eDensity\u003c/a\u003e\u003c/code\u003e term dates back to Dubuc''s 1974 thesis. The term\n \u003ccode\u003e\u003ca\u003eMonad\u003c/a\u003e\u003c/code\u003e genererated by a \u003ccode\u003e\u003ca\u003eFunctor\u003c/a\u003e\u003c/code\u003e dates back to 1972 in Street''s\n ''Formal Theory of Monads''.\n\u003c/p\u003e\u003cp\u003eThe left Kan extension of a \u003ccode\u003e\u003ca\u003eFunctor\u003c/a\u003e\u003c/code\u003e along itself (\u003ccode\u003e\u003ccode\u003e\u003ca\u003eLan\u003c/a\u003e\u003c/code\u003e f f\u003c/code\u003e) forms a \u003ccode\u003e\u003ca\u003eComonad\u003c/a\u003e\u003c/code\u003e. This is\n that \u003ccode\u003e\u003ca\u003eComonad\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Control.Comonad.Density",
          "name": "Density",
          "package": "kan-extensions",
          "source": "src/Control-Comonad-Density.html",
          "type": "module"
        },
        "index": {
          "description": "The Density Comonad for Functor aka the Comonad generated by Functor The Density term dates back to Dubuc thesis The term Monad genererated by Functor dates back to in Street Formal Theory of Monads The left Kan extension of Functor along itself Lan forms Comonad This is that Comonad",
          "hierarchy": "Control Comonad Density",
          "module": "Control.Comonad.Density",
          "name": "Density",
          "package": "kan-extensions",
          "partial": "Density",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/kan-extensions/docs/Control-Comonad-Density.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Comonad.Density",
          "name": "Density",
          "package": "kan-extensions",
          "source": "src/Control-Comonad-Density.html#Density",
          "type": "data"
        },
        "index": {
          "hierarchy": "Control Comonad Density",
          "module": "Control.Comonad.Density",
          "name": "Density",
          "package": "kan-extensions",
          "partial": "Density",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/kan-extensions/docs/Control-Comonad-Density.html#t:Density"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Comonad.Density",
          "name": "Density",
          "package": "kan-extensions",
          "signature": "(k b -\u003e a) -\u003e k b -\u003e Density k a",
          "source": "src/Control-Comonad-Density.html#Density",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Comonad Density",
          "module": "Control.Comonad.Density",
          "name": "Density",
          "normalized": "(a b-\u003ec)-\u003ea b-\u003eDensity a c",
          "package": "kan-extensions",
          "partial": "Density",
          "signature": "(k b-\u003ea)-\u003ek b-\u003eDensity k a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/kan-extensions/docs/Control-Comonad-Density.html#v:Density"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Comonad.Density",
          "name": "adjunctionToDensity",
          "package": "kan-extensions",
          "signature": "f (g a) -\u003e Density f a",
          "source": "src/Control-Comonad-Density.html#adjunctionToDensity",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Comonad Density",
          "module": "Control.Comonad.Density",
          "name": "adjunctionToDensity",
          "normalized": "a(b c)-\u003eDensity a c",
          "package": "kan-extensions",
          "partial": "To Density",
          "signature": "f(g a)-\u003eDensity f a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/kan-extensions/docs/Control-Comonad-Density.html#v:adjunctionToDensity"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe Density \u003ccode\u003e\u003ca\u003eComonad\u003c/a\u003e\u003c/code\u003e of a left adjoint is isomorphic to the \u003ccode\u003e\u003ca\u003eComonad\u003c/a\u003e\u003c/code\u003e formed by that \u003ccode\u003e\u003ca\u003eAdjunction\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eThis isomorphism is witnessed by \u003ccode\u003e\u003ca\u003edensityToAdjunction\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003eadjunctionToDensity\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003edensityToAdjunction\u003c/a\u003e\u003c/code\u003e . \u003ccode\u003e\u003ca\u003eadjunctionToDensity\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003eid\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003eadjunctionToDensity\u003c/a\u003e\u003c/code\u003e . \u003ccode\u003e\u003ca\u003edensityToAdjunction\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003eid\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e",
          "module": "Control.Comonad.Density",
          "name": "densityToAdjunction",
          "package": "kan-extensions",
          "signature": "Density f a -\u003e f (g a)",
          "source": "src/Control-Comonad-Density.html#densityToAdjunction",
          "type": "function"
        },
        "index": {
          "description": "The Density Comonad of left adjoint is isomorphic to the Comonad formed by that Adjunction This isomorphism is witnessed by densityToAdjunction and adjunctionToDensity densityToAdjunction adjunctionToDensity id adjunctionToDensity densityToAdjunction id",
          "hierarchy": "Control Comonad Density",
          "module": "Control.Comonad.Density",
          "name": "densityToAdjunction",
          "normalized": "Density a b-\u003ea(c b)",
          "package": "kan-extensions",
          "partial": "To Adjunction",
          "signature": "Density f a-\u003ef(g a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/kan-extensions/docs/Control-Comonad-Density.html#v:densityToAdjunction"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Comonad.Density",
          "name": "densityToLan",
          "package": "kan-extensions",
          "signature": "Density f a -\u003e Lan f f a",
          "source": "src/Control-Comonad-Density.html#densityToLan",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Comonad Density",
          "module": "Control.Comonad.Density",
          "name": "densityToLan",
          "normalized": "Density a b-\u003eLan a a b",
          "package": "kan-extensions",
          "partial": "To Lan",
          "signature": "Density f a-\u003eLan f f a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/kan-extensions/docs/Control-Comonad-Density.html#v:densityToLan"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003eDensity\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eComonad\u003c/a\u003e\u003c/code\u003e of a \u003ccode\u003e\u003ca\u003eFunctor\u003c/a\u003e\u003c/code\u003e \u003ccode\u003ef\u003c/code\u003e is obtained by taking the left Kan extension\n (\u003ccode\u003e\u003ca\u003eLan\u003c/a\u003e\u003c/code\u003e) of \u003ccode\u003ef\u003c/code\u003e along itself. This isomorphism is witnessed by \u003ccode\u003e\u003ca\u003elanToDensity\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003edensityToLan\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003elanToDensity\u003c/a\u003e\u003c/code\u003e . \u003ccode\u003e\u003ca\u003edensityToLan\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003eid\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003edensityToLan\u003c/a\u003e\u003c/code\u003e . \u003ccode\u003e\u003ca\u003elanToDensity\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003eid\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e",
          "module": "Control.Comonad.Density",
          "name": "lanToDensity",
          "package": "kan-extensions",
          "signature": "Lan f f a -\u003e Density f a",
          "source": "src/Control-Comonad-Density.html#lanToDensity",
          "type": "function"
        },
        "index": {
          "description": "The Density Comonad of Functor is obtained by taking the left Kan extension Lan of along itself This isomorphism is witnessed by lanToDensity and densityToLan lanToDensity densityToLan id densityToLan lanToDensity id",
          "hierarchy": "Control Comonad Density",
          "module": "Control.Comonad.Density",
          "name": "lanToDensity",
          "normalized": "Lan a a b-\u003eDensity a b",
          "package": "kan-extensions",
          "partial": "To Density",
          "signature": "Lan f f a-\u003eDensity f a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/kan-extensions/docs/Control-Comonad-Density.html#v:lanToDensity"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe natural transformation from a \u003ccode\u003e\u003ccode\u003e\u003ca\u003eComonad\u003c/a\u003e\u003c/code\u003e w\u003c/code\u003e to the \u003ccode\u003e\u003ca\u003eComonad\u003c/a\u003e\u003c/code\u003e generated by \u003ccode\u003ew\u003c/code\u003e (forwards).\n\u003c/p\u003e\u003cp\u003eThis is merely a right-inverse (section) of \u003ccode\u003e\u003ca\u003elower\u003c/a\u003e\u003c/code\u003e, rather than a full inverse.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003elower\u003c/a\u003e\u003c/code\u003e . \u003ccode\u003e\u003ca\u003eliftDensity\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003eid\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e",
          "module": "Control.Comonad.Density",
          "name": "liftDensity",
          "package": "kan-extensions",
          "signature": "w a -\u003e Density w a",
          "source": "src/Control-Comonad-Density.html#liftDensity",
          "type": "function"
        },
        "index": {
          "description": "The natural transformation from Comonad to the Comonad generated by forwards This is merely right-inverse section of lower rather than full inverse lower liftDensity id",
          "hierarchy": "Control Comonad Density",
          "module": "Control.Comonad.Density",
          "name": "liftDensity",
          "normalized": "a b-\u003eDensity a b",
          "package": "kan-extensions",
          "partial": "Density",
          "signature": "w a-\u003eDensity w a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/kan-extensions/docs/Control-Comonad-Density.html#v:liftDensity"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eMonads from Comonads\n\u003c/p\u003e\u003cp\u003e\u003ca\u003ehttp://comonad.com/reader/2011/monads-from-comonads/\u003c/a\u003e\n\u003c/p\u003e\u003cp\u003e\u003ccode\u003e\u003ca\u003eCo\u003c/a\u003e\u003c/code\u003e can be viewed as a right Kan lift along a \u003ccode\u003e\u003ca\u003eComonad\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eIn general you can \"sandwich\" a monad in between two halves of an adjunction.\n That is to say, if you have an adjunction \u003ccode\u003eF -| G : C -\u003e D \u003c/code\u003e then not only does \u003ccode\u003eGF\u003c/code\u003e\n form a monad, but \u003ccode\u003eGMF\u003c/code\u003e forms a monad for \u003ccode\u003eM\u003c/code\u003e a monad in \u003ccode\u003eD\u003c/code\u003e. Therefore if we\n have an adjunction \u003ccode\u003eF -| G : Hask -\u003e Hask^op\u003c/code\u003e then we can lift a \u003ccode\u003e\u003ca\u003eComonad\u003c/a\u003e\u003c/code\u003e in \u003ccode\u003eHask\u003c/code\u003e\n which is a \u003ccode\u003e\u003ca\u003eMonad\u003c/a\u003e\u003c/code\u003e in \u003ccode\u003eHask^op\u003c/code\u003e to a \u003ccode\u003e\u003ca\u003eMonad\u003c/a\u003e\u003c/code\u003e in \u003ccode\u003eHask\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eFor any \u003ccode\u003er\u003c/code\u003e, the \u003ccode\u003eContravariant\u003c/code\u003e functor / presheaf \u003ccode\u003e(-\u003e r)\u003c/code\u003e :: Hask^op -\u003e Hask is adjoint to the \"same\"\n \u003ccode\u003eContravariant\u003c/code\u003e functor \u003ccode\u003e(-\u003e r) :: Hask -\u003e Hask^op\u003c/code\u003e. So we can sandwhich a\n Monad in Hask^op in the middle to obtain \u003ccode\u003ew (a -\u003e r-) -\u003e r+\u003c/code\u003e, and then take a coend over\n \u003ccode\u003er\u003c/code\u003e to obtain \u003ccode\u003eforall r. w (a -\u003e r) -\u003e r\u003c/code\u003e. This gives rise to \u003ccode\u003e\u003ca\u003eCo\u003c/a\u003e\u003c/code\u003e. If we observe that\n we didn't care what the choices we made for \u003ccode\u003er\u003c/code\u003e were to finish this construction, we can\n upgrade to \u003ccode\u003eforall r. w (a -\u003e m r) -\u003e m r\u003c/code\u003e in a manner similar to how \u003ccode\u003eContT\u003c/code\u003e is constructed\n yielding \u003ccode\u003e\u003ca\u003eCoT\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eWe could consider unifying the definition of \u003ccode\u003e\u003ca\u003eCo\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003eRift\u003c/code\u003e, but\n there are many other arguments for which \u003ccode\u003eRift\u003c/code\u003e can form a \u003ccode\u003e\u003ca\u003eMonad\u003c/a\u003e\u003c/code\u003e, and this\n wouldn't give rise to \u003ccode\u003e\u003ca\u003eCoT\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Control.Monad.Co",
          "name": "Co",
          "package": "kan-extensions",
          "source": "src/Control-Monad-Co.html",
          "type": "module"
        },
        "index": {
          "description": "Monads from Comonads http comonad.com reader monads-from-comonads Co can be viewed as right Kan lift along Comonad In general you can sandwich monad in between two halves of an adjunction That is to say if you have an adjunction then not only does GF form monad but GMF forms monad for monad in Therefore if we have an adjunction Hask Hask op then we can lift Comonad in Hask which is Monad in Hask op to Monad in Hask For any the Contravariant functor presheaf Hask op Hask is adjoint to the same Contravariant functor Hask Hask op So we can sandwhich Monad in Hask op in the middle to obtain and then take coend over to obtain forall This gives rise to Co If we observe that we didn care what the choices we made for were to finish this construction we can upgrade to forall in manner similar to how ContT is constructed yielding CoT We could consider unifying the definition of Co and Rift but there are many other arguments for which Rift can form Monad and this wouldn give rise to CoT",
          "hierarchy": "Control Monad Co",
          "module": "Control.Monad.Co",
          "name": "Co",
          "package": "kan-extensions",
          "partial": "Co",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/kan-extensions/docs/Control-Monad-Co.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Monad.Co",
          "name": "Co",
          "package": "kan-extensions",
          "source": "src/Control-Monad-Co.html#Co",
          "type": "type"
        },
        "index": {
          "hierarchy": "Control Monad Co",
          "module": "Control.Monad.Co",
          "name": "Co",
          "package": "kan-extensions",
          "partial": "Co",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/kan-extensions/docs/Control-Monad-Co.html#t:Co"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003eCo\u003c/a\u003e\u003c/code\u003e w a ~ \u003ccode\u003e\u003ca\u003eRift\u003c/a\u003e\u003c/code\u003e w \u003ccode\u003e\u003ca\u003eIdentity\u003c/a\u003e\u003c/code\u003e a\n\u003c/pre\u003e",
          "module": "Control.Monad.Co",
          "name": "CoT",
          "package": "kan-extensions",
          "source": "src/Control-Monad-Co.html#CoT",
          "type": "newtype"
        },
        "index": {
          "description": "Co Rift Identity",
          "hierarchy": "Control Monad Co",
          "module": "Control.Monad.Co",
          "name": "CoT",
          "package": "kan-extensions",
          "partial": "Co",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/kan-extensions/docs/Control-Monad-Co.html#t:CoT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Monad.Co",
          "name": "CoT",
          "package": "kan-extensions",
          "signature": "CoT",
          "source": "src/Control-Monad-Co.html#CoT",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Monad Co",
          "module": "Control.Monad.Co",
          "name": "CoT",
          "package": "kan-extensions",
          "partial": "Co",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/kan-extensions/docs/Control-Monad-Co.html#v:CoT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Monad.Co",
          "name": "askW",
          "package": "kan-extensions",
          "signature": "CoT w m e",
          "source": "src/Control-Monad-Co.html#askW",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Monad Co",
          "module": "Control.Monad.Co",
          "name": "askW",
          "package": "kan-extensions",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/kan-extensions/docs/Control-Monad-Co.html#v:askW"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Monad.Co",
          "name": "asksW",
          "package": "kan-extensions",
          "signature": "(e -\u003e a) -\u003e CoT w m a",
          "source": "src/Control-Monad-Co.html#asksW",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Monad Co",
          "module": "Control.Monad.Co",
          "name": "asksW",
          "normalized": "(a-\u003eb)-\u003eCoT c d b",
          "package": "kan-extensions",
          "signature": "(e-\u003ea)-\u003eCoT w m a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/kan-extensions/docs/Control-Monad-Co.html#v:asksW"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Monad.Co",
          "name": "co",
          "package": "kan-extensions",
          "signature": "(forall r.  w (a -\u003e r) -\u003e r) -\u003e Co w a",
          "source": "src/Control-Monad-Co.html#co",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Monad Co",
          "module": "Control.Monad.Co",
          "name": "co",
          "normalized": "(a b c(d-\u003ee)-\u003ee)-\u003eCo c d",
          "package": "kan-extensions",
          "signature": "(forall r. w(a-\u003er)-\u003er)-\u003eCo w a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/kan-extensions/docs/Control-Monad-Co.html#v:co"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Monad.Co",
          "name": "liftCoT0",
          "package": "kan-extensions",
          "signature": "(forall a.  w a -\u003e s) -\u003e CoT w m s",
          "source": "src/Control-Monad-Co.html#liftCoT0",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Monad Co",
          "module": "Control.Monad.Co",
          "name": "liftCoT0",
          "normalized": "(a b c d-\u003ee)-\u003eCoT c f e",
          "package": "kan-extensions",
          "partial": "Co",
          "signature": "(forall a. w a-\u003es)-\u003eCoT w m s",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/kan-extensions/docs/Control-Monad-Co.html#v:liftCoT0"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Monad.Co",
          "name": "liftCoT1",
          "package": "kan-extensions",
          "signature": "(forall a.  w a -\u003e a) -\u003e CoT w m ()",
          "source": "src/Control-Monad-Co.html#liftCoT1",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Monad Co",
          "module": "Control.Monad.Co",
          "name": "liftCoT1",
          "normalized": "(a b c d-\u003ed)-\u003eCoT c e()",
          "package": "kan-extensions",
          "partial": "Co",
          "signature": "(forall a. w a-\u003ea)-\u003eCoT w m()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/kan-extensions/docs/Control-Monad-Co.html#v:liftCoT1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Monad.Co",
          "name": "lowerCo0",
          "package": "kan-extensions",
          "signature": "Co w s -\u003e w a -\u003e s",
          "source": "src/Control-Monad-Co.html#lowerCo0",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Monad Co",
          "module": "Control.Monad.Co",
          "name": "lowerCo0",
          "normalized": "Co a b-\u003ea c-\u003eb",
          "package": "kan-extensions",
          "partial": "Co",
          "signature": "Co w s-\u003ew a-\u003es",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/kan-extensions/docs/Control-Monad-Co.html#v:lowerCo0"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Monad.Co",
          "name": "lowerCo1",
          "package": "kan-extensions",
          "signature": "Co w () -\u003e w a -\u003e a",
          "source": "src/Control-Monad-Co.html#lowerCo1",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Monad Co",
          "module": "Control.Monad.Co",
          "name": "lowerCo1",
          "normalized": "Co a()-\u003ea b-\u003eb",
          "package": "kan-extensions",
          "partial": "Co",
          "signature": "Co w()-\u003ew a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/kan-extensions/docs/Control-Monad-Co.html#v:lowerCo1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Monad.Co",
          "name": "lowerCoT0",
          "package": "kan-extensions",
          "signature": "CoT w m s -\u003e w a -\u003e m s",
          "source": "src/Control-Monad-Co.html#lowerCoT0",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Monad Co",
          "module": "Control.Monad.Co",
          "name": "lowerCoT0",
          "normalized": "CoT a b c-\u003ea d-\u003eb c",
          "package": "kan-extensions",
          "partial": "Co",
          "signature": "CoT w m s-\u003ew a-\u003em s",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/kan-extensions/docs/Control-Monad-Co.html#v:lowerCoT0"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Monad.Co",
          "name": "lowerCoT1",
          "package": "kan-extensions",
          "signature": "CoT w m () -\u003e w a -\u003e m a",
          "source": "src/Control-Monad-Co.html#lowerCoT1",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Monad Co",
          "module": "Control.Monad.Co",
          "name": "lowerCoT1",
          "normalized": "CoT a b()-\u003ea c-\u003eb c",
          "package": "kan-extensions",
          "partial": "Co",
          "signature": "CoT w m()-\u003ew a-\u003em a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/kan-extensions/docs/Control-Monad-Co.html#v:lowerCoT1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Monad.Co",
          "name": "peekW",
          "package": "kan-extensions",
          "signature": "s -\u003e CoT w m ()",
          "source": "src/Control-Monad-Co.html#peekW",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Monad Co",
          "module": "Control.Monad.Co",
          "name": "peekW",
          "normalized": "a-\u003eCoT b c()",
          "package": "kan-extensions",
          "signature": "s-\u003eCoT w m()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/kan-extensions/docs/Control-Monad-Co.html#v:peekW"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Monad.Co",
          "name": "peeksW",
          "package": "kan-extensions",
          "signature": "(s -\u003e s) -\u003e CoT w m ()",
          "source": "src/Control-Monad-Co.html#peeksW",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Monad Co",
          "module": "Control.Monad.Co",
          "name": "peeksW",
          "normalized": "(a-\u003ea)-\u003eCoT b c()",
          "package": "kan-extensions",
          "signature": "(s-\u003es)-\u003eCoT w m()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/kan-extensions/docs/Control-Monad-Co.html#v:peeksW"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Monad.Co",
          "name": "posW",
          "package": "kan-extensions",
          "signature": "CoT w m s",
          "source": "src/Control-Monad-Co.html#posW",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Monad Co",
          "module": "Control.Monad.Co",
          "name": "posW",
          "package": "kan-extensions",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/kan-extensions/docs/Control-Monad-Co.html#v:posW"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Monad.Co",
          "name": "runCo",
          "package": "kan-extensions",
          "signature": "Co w a -\u003e w (a -\u003e r) -\u003e r",
          "source": "src/Control-Monad-Co.html#runCo",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Monad Co",
          "module": "Control.Monad.Co",
          "name": "runCo",
          "normalized": "Co a b-\u003ea(b-\u003ec)-\u003ec",
          "package": "kan-extensions",
          "partial": "Co",
          "signature": "Co w a-\u003ew(a-\u003er)-\u003er",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/kan-extensions/docs/Control-Monad-Co.html#v:runCo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Monad.Co",
          "name": "runCoT",
          "package": "kan-extensions",
          "signature": "forall r.  w (a -\u003e m r) -\u003e m r",
          "source": "src/Control-Monad-Co.html#CoT",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Monad Co",
          "module": "Control.Monad.Co",
          "name": "runCoT",
          "normalized": "a b c(d-\u003ee f)-\u003ee f",
          "package": "kan-extensions",
          "partial": "Co",
          "signature": "forall r. w(a-\u003em r)-\u003em r",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/kan-extensions/docs/Control-Monad-Co.html#v:runCoT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Monad.Co",
          "name": "traceW",
          "package": "kan-extensions",
          "signature": "e -\u003e CoT w m ()",
          "source": "src/Control-Monad-Co.html#traceW",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Monad Co",
          "module": "Control.Monad.Co",
          "name": "traceW",
          "normalized": "a-\u003eCoT b c()",
          "package": "kan-extensions",
          "signature": "e-\u003eCoT w m()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/kan-extensions/docs/Control-Monad-Co.html#v:traceW"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Monad.Codensity",
          "name": "Codensity",
          "package": "kan-extensions",
          "source": "src/Control-Monad-Codensity.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Control Monad Codensity",
          "module": "Control.Monad.Codensity",
          "name": "Codensity",
          "package": "kan-extensions",
          "partial": "Codensity",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/kan-extensions/docs/Control-Monad-Codensity.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ccode\u003e\u003ca\u003eCodensity\u003c/a\u003e\u003c/code\u003e f\u003c/code\u003e is the Monad generated by taking the right Kan extension\n of any \u003ccode\u003e\u003ca\u003eFunctor\u003c/a\u003e\u003c/code\u003e \u003ccode\u003ef\u003c/code\u003e along itself (\u003ccode\u003eRan f f\u003c/code\u003e).\n\u003c/p\u003e\u003cp\u003eThis can often be more \"efficient\" to construct than \u003ccode\u003ef\u003c/code\u003e itself using\n repeated applications of \u003ccode\u003e(\u003e\u003e=)\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eSee \"Asymptotic Improvement of Computations over Free Monads\" by Janis\n Voightl&#228;nder for more information about this type.\n\u003c/p\u003e\u003cp\u003e\u003ca\u003ehttp://www.iai.uni-bonn.de/~jv/mpc08.pdf\u003c/a\u003e\n\u003c/p\u003e",
          "module": "Control.Monad.Codensity",
          "name": "Codensity",
          "package": "kan-extensions",
          "source": "src/Control-Monad-Codensity.html#Codensity",
          "type": "newtype"
        },
        "index": {
          "description": "Codensity is the Monad generated by taking the right Kan extension of any Functor along itself Ran This can often be more efficient to construct than itself using repeated applications of See Asymptotic Improvement of Computations over Free Monads by Janis Voightl nder for more information about this type http www.iai.uni-bonn.de jv mpc08.pdf",
          "hierarchy": "Control Monad Codensity",
          "module": "Control.Monad.Codensity",
          "name": "Codensity",
          "package": "kan-extensions",
          "partial": "Codensity",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/kan-extensions/docs/Control-Monad-Codensity.html#t:Codensity"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Monad.Codensity",
          "name": "Codensity",
          "package": "kan-extensions",
          "signature": "Codensity",
          "source": "src/Control-Monad-Codensity.html#Codensity",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Monad Codensity",
          "module": "Control.Monad.Codensity",
          "name": "Codensity",
          "package": "kan-extensions",
          "partial": "Codensity",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/kan-extensions/docs/Control-Monad-Codensity.html#v:Codensity"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Monad.Codensity",
          "name": "adjunctionToCodensity",
          "package": "kan-extensions",
          "signature": "g (f a) -\u003e Codensity g a",
          "source": "src/Control-Monad-Codensity.html#adjunctionToCodensity",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Monad Codensity",
          "module": "Control.Monad.Codensity",
          "name": "adjunctionToCodensity",
          "normalized": "a(b c)-\u003eCodensity a c",
          "package": "kan-extensions",
          "partial": "To Codensity",
          "signature": "g(f a)-\u003eCodensity g a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/kan-extensions/docs/Control-Monad-Codensity.html#v:adjunctionToCodensity"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003eCodensity\u003c/a\u003e\u003c/code\u003e monad of a right adjoint is isomorphic to the\n monad obtained from the \u003ccode\u003e\u003ca\u003eAdjunction\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003ecodensityToAdjunction\u003c/a\u003e\u003c/code\u003e . \u003ccode\u003e\u003ca\u003eadjunctionToCodensity\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003eid\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003eadjunctionToCodensity\u003c/a\u003e\u003c/code\u003e . \u003ccode\u003e\u003ca\u003ecodensityToAdjunction\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003eid\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e",
          "module": "Control.Monad.Codensity",
          "name": "codensityToAdjunction",
          "package": "kan-extensions",
          "signature": "Codensity g a -\u003e g (f a)",
          "source": "src/Control-Monad-Codensity.html#codensityToAdjunction",
          "type": "function"
        },
        "index": {
          "description": "The Codensity monad of right adjoint is isomorphic to the monad obtained from the Adjunction codensityToAdjunction adjunctionToCodensity id adjunctionToCodensity codensityToAdjunction id",
          "hierarchy": "Control Monad Codensity",
          "module": "Control.Monad.Codensity",
          "name": "codensityToAdjunction",
          "normalized": "Codensity a b-\u003ea(c b)",
          "package": "kan-extensions",
          "partial": "To Adjunction",
          "signature": "Codensity g a-\u003eg(f a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/kan-extensions/docs/Control-Monad-Codensity.html#v:codensityToAdjunction"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003eCodensity\u003c/a\u003e\u003c/code\u003e monad of a representable \u003ccode\u003e\u003ca\u003eFunctor\u003c/a\u003e\u003c/code\u003e is isomorphic to the\n monad obtained from the \u003ccode\u003e\u003ca\u003eAdjunction\u003c/a\u003e\u003c/code\u003e for which that \u003ccode\u003e\u003ca\u003eFunctor\u003c/a\u003e\u003c/code\u003e is the right\n adjoint.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003ecodensityToComposedRep\u003c/a\u003e\u003c/code\u003e . \u003ccode\u003e\u003ca\u003ecomposedRepToCodensity\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003eid\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003ecomposedRepToCodensity\u003c/a\u003e\u003c/code\u003e . \u003ccode\u003e\u003ca\u003ecodensityToComposedRep\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003eid\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e\u003cpre\u003e\n codensityToComposedRep = \u003ccode\u003e\u003ca\u003eranToComposedRep\u003c/a\u003e\u003c/code\u003e . \u003ccode\u003e\u003ca\u003ecodensityToRan\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e",
          "module": "Control.Monad.Codensity",
          "name": "codensityToComposedRep",
          "package": "kan-extensions",
          "signature": "Codensity u a -\u003e u (Rep u, a)",
          "source": "src/Control-Monad-Codensity.html#codensityToComposedRep",
          "type": "function"
        },
        "index": {
          "description": "The Codensity monad of representable Functor is isomorphic to the monad obtained from the Adjunction for which that Functor is the right adjoint codensityToComposedRep composedRepToCodensity id composedRepToCodensity codensityToComposedRep id codensityToComposedRep ranToComposedRep codensityToRan",
          "hierarchy": "Control Monad Codensity",
          "module": "Control.Monad.Codensity",
          "name": "codensityToComposedRep",
          "normalized": "Codensity a b-\u003ea(Rep a,b)",
          "package": "kan-extensions",
          "partial": "To Composed Rep",
          "signature": "Codensity u a-\u003eu(Rep u,a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/kan-extensions/docs/Control-Monad-Codensity.html#v:codensityToComposedRep"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003eCodensity\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eMonad\u003c/a\u003e\u003c/code\u003e of a \u003ccode\u003e\u003ca\u003eFunctor\u003c/a\u003e\u003c/code\u003e \u003ccode\u003eg\u003c/code\u003e is the right Kan extension (\u003ccode\u003e\u003ca\u003eRan\u003c/a\u003e\u003c/code\u003e)\n of \u003ccode\u003eg\u003c/code\u003e along itself.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003ecodensityToRan\u003c/a\u003e\u003c/code\u003e . \u003ccode\u003e\u003ca\u003eranToCodensity\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003eid\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003eranToCodensity\u003c/a\u003e\u003c/code\u003e . \u003ccode\u003e\u003ca\u003ecodensityToRan\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003eid\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e",
          "module": "Control.Monad.Codensity",
          "name": "codensityToRan",
          "package": "kan-extensions",
          "signature": "Codensity g a -\u003e Ran g g a",
          "source": "src/Control-Monad-Codensity.html#codensityToRan",
          "type": "function"
        },
        "index": {
          "description": "The Codensity Monad of Functor is the right Kan extension Ran of along itself codensityToRan ranToCodensity id ranToCodensity codensityToRan id",
          "hierarchy": "Control Monad Codensity",
          "module": "Control.Monad.Codensity",
          "name": "codensityToRan",
          "normalized": "Codensity a b-\u003eRan a a b",
          "package": "kan-extensions",
          "partial": "To Ran",
          "signature": "Codensity g a-\u003eRan g g a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/kan-extensions/docs/Control-Monad-Codensity.html#v:codensityToRan"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003ecomposedRepToCodensity\u003c/a\u003e\u003c/code\u003e = \u003ccode\u003e\u003ca\u003eranToCodensity\u003c/a\u003e\u003c/code\u003e . \u003ccode\u003e\u003ca\u003ecomposedRepToRan\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e",
          "module": "Control.Monad.Codensity",
          "name": "composedRepToCodensity",
          "package": "kan-extensions",
          "signature": "u (Rep u, a) -\u003e Codensity u a",
          "source": "src/Control-Monad-Codensity.html#composedRepToCodensity",
          "type": "function"
        },
        "index": {
          "description": "composedRepToCodensity ranToCodensity composedRepToRan",
          "hierarchy": "Control Monad Codensity",
          "module": "Control.Monad.Codensity",
          "name": "composedRepToCodensity",
          "normalized": "a(Rep a,b)-\u003eCodensity a b",
          "package": "kan-extensions",
          "partial": "Rep To Codensity",
          "signature": "u(Rep u,a)-\u003eCodensity u a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/kan-extensions/docs/Control-Monad-Codensity.html#v:composedRepToCodensity"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRight associate all binds in a computation that generates a free monad\n\u003c/p\u003e\u003cp\u003eThis can improve the asymptotic efficiency of the result, while preserving\n semantics.\n\u003c/p\u003e\u003cp\u003eSee \"Asymptotic Improvement of Computations over Free Monads\" by Janis\n Voightl&#228;nder for more information about this combinator.\n\u003c/p\u003e\u003cp\u003e\u003ca\u003ehttp://www.iai.uni-bonn.de/~jv/mpc08.pdf\u003c/a\u003e\n\u003c/p\u003e",
          "module": "Control.Monad.Codensity",
          "name": "improve",
          "package": "kan-extensions",
          "signature": "m a) -\u003e Free f a",
          "source": "src/Control-Monad-Codensity.html#improve",
          "type": "function"
        },
        "index": {
          "description": "Right associate all binds in computation that generates free monad This can improve the asymptotic efficiency of the result while preserving semantics See Asymptotic Improvement of Computations over Free Monads by Janis Voightl nder for more information about this combinator http www.iai.uni-bonn.de jv mpc08.pdf",
          "hierarchy": "Control Monad Codensity",
          "module": "Control.Monad.Codensity",
          "name": "improve",
          "normalized": "a b)-\u003eFree c b",
          "package": "kan-extensions",
          "signature": "m a)-\u003eFree f a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/kan-extensions/docs/Control-Monad-Codensity.html#v:improve"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis serves as the *left*-inverse (retraction) of \u003ccode\u003e\u003ca\u003elift\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e\n 'lowerCodensity . lift' &#8801; \u003ccode\u003e\u003ca\u003eid\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e\u003cp\u003eIn general this is not a full 2-sided inverse, merely a retraction, as\n \u003ccode\u003e\u003ccode\u003e\u003ca\u003eCodensity\u003c/a\u003e\u003c/code\u003e m\u003c/code\u003e is often considerably \u003ca\u003elarger\u003c/a\u003e than \u003ccode\u003em\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003ee.g. \u003ccode\u003e\u003ccode\u003e\u003ca\u003eCodensity\u003c/a\u003e\u003c/code\u003e ((-\u003e) s)) a ~ forall r. (a -\u003e s -\u003e r) -\u003e s -\u003e r\u003c/code\u003e\n could support a full complement of \u003ccode\u003e\u003ccode\u003e\u003ca\u003eMonadState\u003c/a\u003e\u003c/code\u003e s\u003c/code\u003e actions, while \u003ccode\u003e(-\u003e) s\u003c/code\u003e\n is limited to \u003ccode\u003e\u003ccode\u003e\u003ca\u003eMonadReader\u003c/a\u003e\u003c/code\u003e s\u003c/code\u003e actions.\n\u003c/p\u003e",
          "module": "Control.Monad.Codensity",
          "name": "lowerCodensity",
          "package": "kan-extensions",
          "signature": "Codensity m a -\u003e m a",
          "source": "src/Control-Monad-Codensity.html#lowerCodensity",
          "type": "function"
        },
        "index": {
          "description": "This serves as the left inverse retraction of lift lowerCodensity lift id In general this is not full sided inverse merely retraction as Codensity is often considerably larger than e.g Codensity forall could support full complement of MonadState actions while is limited to MonadReader actions",
          "hierarchy": "Control Monad Codensity",
          "module": "Control.Monad.Codensity",
          "name": "lowerCodensity",
          "normalized": "Codensity a b-\u003ea b",
          "package": "kan-extensions",
          "partial": "Codensity",
          "signature": "Codensity m a-\u003em a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/kan-extensions/docs/Control-Monad-Codensity.html#v:lowerCodensity"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Monad.Codensity",
          "name": "ranToCodensity",
          "package": "kan-extensions",
          "signature": "Ran g g a -\u003e Codensity g a",
          "source": "src/Control-Monad-Codensity.html#ranToCodensity",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Monad Codensity",
          "module": "Control.Monad.Codensity",
          "name": "ranToCodensity",
          "normalized": "Ran a a b-\u003eCodensity a b",
          "package": "kan-extensions",
          "partial": "To Codensity",
          "signature": "Ran g g a-\u003eCodensity g a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/kan-extensions/docs/Control-Monad-Codensity.html#v:ranToCodensity"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Monad.Codensity",
          "name": "runCodensity",
          "package": "kan-extensions",
          "signature": "forall b.  (a -\u003e m b) -\u003e m b",
          "source": "src/Control-Monad-Codensity.html#Codensity",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Monad Codensity",
          "module": "Control.Monad.Codensity",
          "name": "runCodensity",
          "normalized": "a b(c-\u003ed e)-\u003ed e",
          "package": "kan-extensions",
          "partial": "Codensity",
          "signature": "forall b.(a-\u003em b)-\u003em b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/kan-extensions/docs/Control-Monad-Codensity.html#v:runCodensity"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThe co-Yoneda lemma for presheafs states that \u003ccode\u003ef\u003c/code\u003e is naturally isomorphic to \u003ccode\u003e\u003ccode\u003e\u003ca\u003eCoyoneda\u003c/a\u003e\u003c/code\u003e f\u003c/code\u003e.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.Functor.Contravariant.Coyoneda",
          "name": "Coyoneda",
          "package": "kan-extensions",
          "source": "src/Data-Functor-Contravariant-Coyoneda.html",
          "type": "module"
        },
        "index": {
          "description": "The co-Yoneda lemma for presheafs states that is naturally isomorphic to Coyoneda",
          "hierarchy": "Data Functor Contravariant Coyoneda",
          "module": "Data.Functor.Contravariant.Coyoneda",
          "name": "Coyoneda",
          "package": "kan-extensions",
          "partial": "Coyoneda",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/kan-extensions/docs/Data-Functor-Contravariant-Coyoneda.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA \u003ccode\u003e\u003ca\u003eContravariant\u003c/a\u003e\u003c/code\u003e functor (aka presheaf) suitable for Yoneda reduction.\n\u003c/p\u003e\u003cp\u003e\u003ca\u003ehttp://ncatlab.org/nlab/show/Yoneda+reduction\u003c/a\u003e\n\u003c/p\u003e",
          "module": "Data.Functor.Contravariant.Coyoneda",
          "name": "Coyoneda",
          "package": "kan-extensions",
          "source": "src/Data-Functor-Contravariant-Coyoneda.html#Coyoneda",
          "type": "data"
        },
        "index": {
          "description": "Contravariant functor aka presheaf suitable for Yoneda reduction http ncatlab.org nlab show Yoneda reduction",
          "hierarchy": "Data Functor Contravariant Coyoneda",
          "module": "Data.Functor.Contravariant.Coyoneda",
          "name": "Coyoneda",
          "package": "kan-extensions",
          "partial": "Coyoneda",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/kan-extensions/docs/Data-Functor-Contravariant-Coyoneda.html#t:Coyoneda"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Functor.Contravariant.Coyoneda",
          "name": "Coyoneda",
          "package": "kan-extensions",
          "signature": "(a -\u003e b) -\u003e f b -\u003e Coyoneda f a",
          "source": "src/Data-Functor-Contravariant-Coyoneda.html#Coyoneda",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Functor Contravariant Coyoneda",
          "module": "Data.Functor.Contravariant.Coyoneda",
          "name": "Coyoneda",
          "normalized": "(a-\u003eb)-\u003ec b-\u003eCoyoneda c a",
          "package": "kan-extensions",
          "partial": "Coyoneda",
          "signature": "(a-\u003eb)-\u003ef b-\u003eCoyoneda f a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/kan-extensions/docs/Data-Functor-Contravariant-Coyoneda.html#v:Coyoneda"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCoyoneda \u003ca\u003eexpansion\u003c/a\u003e of a presheaf\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003eliftCoyoneda\u003c/a\u003e\u003c/code\u003e . \u003ccode\u003e\u003ca\u003elowerCoyoneda\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003eid\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003elowerCoyoneda\u003c/a\u003e\u003c/code\u003e . \u003ccode\u003e\u003ca\u003eliftCoyoneda\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003eid\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e",
          "module": "Data.Functor.Contravariant.Coyoneda",
          "name": "liftCoyoneda",
          "package": "kan-extensions",
          "signature": "f a -\u003e Coyoneda f a",
          "source": "src/Data-Functor-Contravariant-Coyoneda.html#liftCoyoneda",
          "type": "function"
        },
        "index": {
          "description": "Coyoneda expansion of presheaf liftCoyoneda lowerCoyoneda id lowerCoyoneda liftCoyoneda id",
          "hierarchy": "Data Functor Contravariant Coyoneda",
          "module": "Data.Functor.Contravariant.Coyoneda",
          "name": "liftCoyoneda",
          "normalized": "a b-\u003eCoyoneda a b",
          "package": "kan-extensions",
          "partial": "Coyoneda",
          "signature": "f a-\u003eCoyoneda f a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/kan-extensions/docs/Data-Functor-Contravariant-Coyoneda.html#v:liftCoyoneda"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCoyoneda reduction on a presheaf\n\u003c/p\u003e",
          "module": "Data.Functor.Contravariant.Coyoneda",
          "name": "lowerCoyoneda",
          "package": "kan-extensions",
          "signature": "Coyoneda f a -\u003e f a",
          "source": "src/Data-Functor-Contravariant-Coyoneda.html#lowerCoyoneda",
          "type": "function"
        },
        "index": {
          "description": "Coyoneda reduction on presheaf",
          "hierarchy": "Data Functor Contravariant Coyoneda",
          "module": "Data.Functor.Contravariant.Coyoneda",
          "name": "lowerCoyoneda",
          "normalized": "Coyoneda a b-\u003ea b",
          "package": "kan-extensions",
          "partial": "Coyoneda",
          "signature": "Coyoneda f a-\u003ef a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/kan-extensions/docs/Data-Functor-Contravariant-Coyoneda.html#v:lowerCoyoneda"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Functor.Contravariant.Yoneda",
          "name": "Yoneda",
          "package": "kan-extensions",
          "source": "src/Data-Functor-Contravariant-Yoneda.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Data Functor Contravariant Yoneda",
          "module": "Data.Functor.Contravariant.Yoneda",
          "name": "Yoneda",
          "package": "kan-extensions",
          "partial": "Yoneda",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/kan-extensions/docs/Data-Functor-Contravariant-Yoneda.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eYoneda embedding for a presheaf\n\u003c/p\u003e",
          "module": "Data.Functor.Contravariant.Yoneda",
          "name": "Yoneda",
          "package": "kan-extensions",
          "source": "src/Data-Functor-Contravariant-Yoneda.html#Yoneda",
          "type": "newtype"
        },
        "index": {
          "description": "Yoneda embedding for presheaf",
          "hierarchy": "Data Functor Contravariant Yoneda",
          "module": "Data.Functor.Contravariant.Yoneda",
          "name": "Yoneda",
          "package": "kan-extensions",
          "partial": "Yoneda",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/kan-extensions/docs/Data-Functor-Contravariant-Yoneda.html#t:Yoneda"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Functor.Contravariant.Yoneda",
          "name": "Yoneda",
          "package": "kan-extensions",
          "signature": "Yoneda",
          "source": "src/Data-Functor-Contravariant-Yoneda.html#Yoneda",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Functor Contravariant Yoneda",
          "module": "Data.Functor.Contravariant.Yoneda",
          "name": "Yoneda",
          "package": "kan-extensions",
          "partial": "Yoneda",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/kan-extensions/docs/Data-Functor-Contravariant-Yoneda.html#v:Yoneda"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003eliftYoneda\u003c/a\u003e\u003c/code\u003e . \u003ccode\u003e\u003ca\u003elowerYoneda\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003eid\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003elowerYoneda\u003c/a\u003e\u003c/code\u003e . \u003ccode\u003e\u003ca\u003eliftYoneda\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003eid\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e",
          "module": "Data.Functor.Contravariant.Yoneda",
          "name": "liftYoneda",
          "package": "kan-extensions",
          "signature": "f a -\u003e Yoneda f a",
          "source": "src/Data-Functor-Contravariant-Yoneda.html#liftYoneda",
          "type": "function"
        },
        "index": {
          "description": "liftYoneda lowerYoneda id lowerYoneda liftYoneda id",
          "hierarchy": "Data Functor Contravariant Yoneda",
          "module": "Data.Functor.Contravariant.Yoneda",
          "name": "liftYoneda",
          "normalized": "a b-\u003eYoneda a b",
          "package": "kan-extensions",
          "partial": "Yoneda",
          "signature": "f a-\u003eYoneda f a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/kan-extensions/docs/Data-Functor-Contravariant-Yoneda.html#v:liftYoneda"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Functor.Contravariant.Yoneda",
          "name": "lowerYoneda",
          "package": "kan-extensions",
          "signature": "Yoneda f a -\u003e f a",
          "source": "src/Data-Functor-Contravariant-Yoneda.html#lowerYoneda",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Functor Contravariant Yoneda",
          "module": "Data.Functor.Contravariant.Yoneda",
          "name": "lowerYoneda",
          "normalized": "Yoneda a b-\u003ea b",
          "package": "kan-extensions",
          "partial": "Yoneda",
          "signature": "Yoneda f a-\u003ef a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/kan-extensions/docs/Data-Functor-Contravariant-Yoneda.html#v:lowerYoneda"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Functor.Contravariant.Yoneda",
          "name": "runYoneda",
          "package": "kan-extensions",
          "signature": "forall r.  (r -\u003e a) -\u003e f r",
          "source": "src/Data-Functor-Contravariant-Yoneda.html#Yoneda",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Functor Contravariant Yoneda",
          "module": "Data.Functor.Contravariant.Yoneda",
          "name": "runYoneda",
          "normalized": "a b(c-\u003ed)-\u003ee c",
          "package": "kan-extensions",
          "partial": "Yoneda",
          "signature": "forall r.(r-\u003ea)-\u003ef r",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/kan-extensions/docs/Data-Functor-Contravariant-Yoneda.html#v:runYoneda"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThe co-Yoneda lemma for a covariant \u003ccode\u003e\u003ca\u003eFunctor\u003c/a\u003e\u003c/code\u003e \u003ccode\u003ef\u003c/code\u003e states that \u003ccode\u003e\u003ccode\u003e\u003ca\u003eCoyoneda\u003c/a\u003e\u003c/code\u003e f\u003c/code\u003e\n is naturally isomorphic to \u003ccode\u003ef\u003c/code\u003e.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.Functor.Coyoneda",
          "name": "Coyoneda",
          "package": "kan-extensions",
          "source": "src/Data-Functor-Coyoneda.html",
          "type": "module"
        },
        "index": {
          "description": "The co-Yoneda lemma for covariant Functor states that Coyoneda is naturally isomorphic to",
          "hierarchy": "Data Functor Coyoneda",
          "module": "Data.Functor.Coyoneda",
          "name": "Coyoneda",
          "package": "kan-extensions",
          "partial": "Coyoneda",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/kan-extensions/docs/Data-Functor-Coyoneda.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA covariant \u003ccode\u003e\u003ca\u003eFunctor\u003c/a\u003e\u003c/code\u003e suitable for Yoneda reduction\n\u003c/p\u003e",
          "module": "Data.Functor.Coyoneda",
          "name": "Coyoneda",
          "package": "kan-extensions",
          "source": "src/Data-Functor-Coyoneda.html#Coyoneda",
          "type": "data"
        },
        "index": {
          "description": "covariant Functor suitable for Yoneda reduction",
          "hierarchy": "Data Functor Coyoneda",
          "module": "Data.Functor.Coyoneda",
          "name": "Coyoneda",
          "package": "kan-extensions",
          "partial": "Coyoneda",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/kan-extensions/docs/Data-Functor-Coyoneda.html#t:Coyoneda"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Functor.Coyoneda",
          "name": "Coyoneda",
          "package": "kan-extensions",
          "signature": "(b -\u003e a) -\u003e f b -\u003e Coyoneda f a",
          "source": "src/Data-Functor-Coyoneda.html#Coyoneda",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Functor Coyoneda",
          "module": "Data.Functor.Coyoneda",
          "name": "Coyoneda",
          "normalized": "(a-\u003eb)-\u003ec a-\u003eCoyoneda c b",
          "package": "kan-extensions",
          "partial": "Coyoneda",
          "signature": "(b-\u003ea)-\u003ef b-\u003eCoyoneda f a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/kan-extensions/docs/Data-Functor-Coyoneda.html#v:Coyoneda"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eCoyoneda f\u003c/code\u003e is the left Kan extension of \u003ccode\u003ef\u003c/code\u003e along the \u003ccode\u003e\u003ca\u003eIdentity\u003c/a\u003e\u003c/code\u003e functor.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003ecoyonedaToLan\u003c/a\u003e\u003c/code\u003e . \u003ccode\u003e\u003ca\u003elanToCoyoneda\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003eid\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003elanToCoyoneda\u003c/a\u003e\u003c/code\u003e . \u003ccode\u003e\u003ca\u003ecoyonedaToLan\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003eid\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e",
          "module": "Data.Functor.Coyoneda",
          "name": "coyonedaToLan",
          "package": "kan-extensions",
          "signature": "Coyoneda f a -\u003e Lan Identity f a",
          "source": "src/Data-Functor-Coyoneda.html#coyonedaToLan",
          "type": "function"
        },
        "index": {
          "description": "Coyoneda is the left Kan extension of along the Identity functor coyonedaToLan lanToCoyoneda id lanToCoyoneda coyonedaToLan id",
          "hierarchy": "Data Functor Coyoneda",
          "module": "Data.Functor.Coyoneda",
          "name": "coyonedaToLan",
          "normalized": "Coyoneda a b-\u003eLan Identity a b",
          "package": "kan-extensions",
          "partial": "To Lan",
          "signature": "Coyoneda f a-\u003eLan Identity f a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/kan-extensions/docs/Data-Functor-Coyoneda.html#v:coyonedaToLan"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ccode\u003e\u003ca\u003eCoyoneda\u003c/a\u003e\u003c/code\u003e f\u003c/code\u003e is the left Kan lift of \u003ccode\u003ef\u003c/code\u003e along the \u003ccode\u003e\u003ca\u003eIdentity\u003c/a\u003e\u003c/code\u003e functor.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003ecoyonedaToLift\u003c/a\u003e\u003c/code\u003e . \u003ccode\u003e\u003ca\u003eliftToCoyoneda\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003eid\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003eliftToCoyoneda\u003c/a\u003e\u003c/code\u003e . \u003ccode\u003e\u003ca\u003ecoyonedaToLift\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003eid\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e",
          "module": "Data.Functor.Coyoneda",
          "name": "coyonedaToLift",
          "package": "kan-extensions",
          "signature": "Coyoneda f a -\u003e Lift Identity f a",
          "source": "src/Data-Functor-Coyoneda.html#coyonedaToLift",
          "type": "function"
        },
        "index": {
          "description": "Coyoneda is the left Kan lift of along the Identity functor coyonedaToLift liftToCoyoneda id liftToCoyoneda coyonedaToLift id",
          "hierarchy": "Data Functor Coyoneda",
          "module": "Data.Functor.Coyoneda",
          "name": "coyonedaToLift",
          "normalized": "Coyoneda a b-\u003eLift Identity a b",
          "package": "kan-extensions",
          "partial": "To Lift",
          "signature": "Coyoneda f a-\u003eLift Identity f a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/kan-extensions/docs/Data-Functor-Coyoneda.html#v:coyonedaToLift"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Functor.Coyoneda",
          "name": "lanToCoyoneda",
          "package": "kan-extensions",
          "signature": "Lan Identity f a -\u003e Coyoneda f a",
          "source": "src/Data-Functor-Coyoneda.html#lanToCoyoneda",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Functor Coyoneda",
          "module": "Data.Functor.Coyoneda",
          "name": "lanToCoyoneda",
          "normalized": "Lan Identity a b-\u003eCoyoneda a b",
          "package": "kan-extensions",
          "partial": "To Coyoneda",
          "signature": "Lan Identity f a-\u003eCoyoneda f a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/kan-extensions/docs/Data-Functor-Coyoneda.html#v:lanToCoyoneda"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eYoneda \u003ca\u003eexpansion\u003c/a\u003e\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003eliftCoyoneda\u003c/a\u003e\u003c/code\u003e . \u003ccode\u003e\u003ca\u003elowerCoyoneda\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003eid\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003elowerCoyoneda\u003c/a\u003e\u003c/code\u003e . \u003ccode\u003e\u003ca\u003eliftCoyoneda\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003eid\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e\u003cpre\u003e\n lowerCoyoneda (liftCoyoneda fa) = -- by definition\n lowerCoyoneda (Coyoneda id fa)  = -- by definition\n fmap id fa                      = -- functor law\n fa\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003elift\u003c/a\u003e\u003c/code\u003e = \u003ccode\u003e\u003ca\u003eliftCoyoneda\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e",
          "module": "Data.Functor.Coyoneda",
          "name": "liftCoyoneda",
          "package": "kan-extensions",
          "signature": "f a -\u003e Coyoneda f a",
          "source": "src/Data-Functor-Coyoneda.html#liftCoyoneda",
          "type": "function"
        },
        "index": {
          "description": "Yoneda expansion liftCoyoneda lowerCoyoneda id lowerCoyoneda liftCoyoneda id lowerCoyoneda liftCoyoneda fa by definition lowerCoyoneda Coyoneda id fa by definition fmap id fa functor law fa lift liftCoyoneda",
          "hierarchy": "Data Functor Coyoneda",
          "module": "Data.Functor.Coyoneda",
          "name": "liftCoyoneda",
          "normalized": "a b-\u003eCoyoneda a b",
          "package": "kan-extensions",
          "partial": "Coyoneda",
          "signature": "f a-\u003eCoyoneda f a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/kan-extensions/docs/Data-Functor-Coyoneda.html#v:liftCoyoneda"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Functor.Coyoneda",
          "name": "liftToCoyoneda",
          "package": "kan-extensions",
          "signature": "Lift Identity f a -\u003e Coyoneda f a",
          "source": "src/Data-Functor-Coyoneda.html#liftToCoyoneda",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Functor Coyoneda",
          "module": "Data.Functor.Coyoneda",
          "name": "liftToCoyoneda",
          "normalized": "Lift Identity a b-\u003eCoyoneda a b",
          "package": "kan-extensions",
          "partial": "To Coyoneda",
          "signature": "Lift Identity f a-\u003eCoyoneda f a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/kan-extensions/docs/Data-Functor-Coyoneda.html#v:liftToCoyoneda"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eYoneda reduction lets us walk under the existential and apply \u003ccode\u003e\u003ca\u003efmap\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eMnemonically, \"Yoneda reduction\" sounds like and works a bit like &#946;-reduction.\u003c/p\u003e\u003cp\u003e\u003ca\u003ehttp://ncatlab.org/nlab/show/Yoneda+reduction\u003c/a\u003e\n\u003c/p\u003e\u003cp\u003eYou can view \u003ccode\u003e\u003ca\u003eCoyoneda\u003c/a\u003e\u003c/code\u003e as just the arguments to \u003ccode\u003e\u003ca\u003efmap\u003c/a\u003e\u003c/code\u003e tupled up.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003elower\u003c/a\u003e\u003c/code\u003e = \u003ccode\u003e\u003ca\u003elowerM\u003c/a\u003e\u003c/code\u003e = \u003ccode\u003e\u003ca\u003elowerCoyoneda\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e",
          "module": "Data.Functor.Coyoneda",
          "name": "lowerCoyoneda",
          "package": "kan-extensions",
          "signature": "Coyoneda f a -\u003e f a",
          "source": "src/Data-Functor-Coyoneda.html#lowerCoyoneda",
          "type": "function"
        },
        "index": {
          "description": "Yoneda reduction lets us walk under the existential and apply fmap Mnemonically Yoneda reduction sounds like and works bit like reduction http ncatlab.org nlab show Yoneda reduction You can view Coyoneda as just the arguments to fmap tupled up lower lowerM lowerCoyoneda",
          "hierarchy": "Data Functor Coyoneda",
          "module": "Data.Functor.Coyoneda",
          "name": "lowerCoyoneda",
          "normalized": "Coyoneda a b-\u003ea b",
          "package": "kan-extensions",
          "partial": "Coyoneda",
          "signature": "Coyoneda f a-\u003ef a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/kan-extensions/docs/Data-Functor-Coyoneda.html#v:lowerCoyoneda"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eYoneda reduction given a \u003ccode\u003e\u003ca\u003eMonad\u003c/a\u003e\u003c/code\u003e lets us walk under the existential and apply \u003ccode\u003e\u003ca\u003eliftM\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eYou can view \u003ccode\u003e\u003ca\u003eCoyoneda\u003c/a\u003e\u003c/code\u003e as just the arguments to \u003ccode\u003e\u003ca\u003eliftM\u003c/a\u003e\u003c/code\u003e tupled up.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003elower\u003c/a\u003e\u003c/code\u003e = \u003ccode\u003e\u003ca\u003elowerM\u003c/a\u003e\u003c/code\u003e = \u003ccode\u003e\u003ca\u003elowerCoyoneda\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e",
          "module": "Data.Functor.Coyoneda",
          "name": "lowerM",
          "package": "kan-extensions",
          "signature": "Coyoneda f a -\u003e f a",
          "source": "src/Data-Functor-Coyoneda.html#lowerM",
          "type": "function"
        },
        "index": {
          "description": "Yoneda reduction given Monad lets us walk under the existential and apply liftM You can view Coyoneda as just the arguments to liftM tupled up lower lowerM lowerCoyoneda",
          "hierarchy": "Data Functor Coyoneda",
          "module": "Data.Functor.Coyoneda",
          "name": "lowerM",
          "normalized": "Coyoneda a b-\u003ea b",
          "package": "kan-extensions",
          "signature": "Coyoneda f a-\u003ef a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/kan-extensions/docs/Data-Functor-Coyoneda.html#v:lowerM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eLeft Kan Extensions\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.Functor.Kan.Lan",
          "name": "Lan",
          "package": "kan-extensions",
          "source": "src/Data-Functor-Kan-Lan.html",
          "type": "module"
        },
        "index": {
          "description": "Left Kan Extensions",
          "hierarchy": "Data Functor Kan Lan",
          "module": "Data.Functor.Kan.Lan",
          "name": "Lan",
          "package": "kan-extensions",
          "partial": "Lan",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/kan-extensions/docs/Data-Functor-Kan-Lan.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe left Kan extension of a \u003ccode\u003e\u003ca\u003eFunctor\u003c/a\u003e\u003c/code\u003e \u003ccode\u003eh\u003c/code\u003e along a \u003ccode\u003e\u003ca\u003eFunctor\u003c/a\u003e\u003c/code\u003e \u003ccode\u003eg\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Functor.Kan.Lan",
          "name": "Lan",
          "package": "kan-extensions",
          "source": "src/Data-Functor-Kan-Lan.html#Lan",
          "type": "data"
        },
        "index": {
          "description": "The left Kan extension of Functor along Functor",
          "hierarchy": "Data Functor Kan Lan",
          "module": "Data.Functor.Kan.Lan",
          "name": "Lan",
          "package": "kan-extensions",
          "partial": "Lan",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/kan-extensions/docs/Data-Functor-Kan-Lan.html#t:Lan"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Functor.Kan.Lan",
          "name": "Lan",
          "package": "kan-extensions",
          "signature": "(g b -\u003e a) -\u003e h b -\u003e Lan g h a",
          "source": "src/Data-Functor-Kan-Lan.html#Lan",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Functor Kan Lan",
          "module": "Data.Functor.Kan.Lan",
          "name": "Lan",
          "normalized": "(a b-\u003ec)-\u003ed b-\u003eLan a d c",
          "package": "kan-extensions",
          "partial": "Lan",
          "signature": "(g b-\u003ea)-\u003eh b-\u003eLan g h a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/kan-extensions/docs/Data-Functor-Kan-Lan.html#v:Lan"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003eadjointToLan\u003c/a\u003e\u003c/code\u003e . \u003ccode\u003e\u003ca\u003elanToAdjoint\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003eid\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003elanToAdjoint\u003c/a\u003e\u003c/code\u003e . \u003ccode\u003e\u003ca\u003eadjointToLan\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003eid\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e",
          "module": "Data.Functor.Kan.Lan",
          "name": "adjointToLan",
          "package": "kan-extensions",
          "signature": "g a -\u003e Lan f Identity a",
          "source": "src/Data-Functor-Kan-Lan.html#adjointToLan",
          "type": "function"
        },
        "index": {
          "description": "adjointToLan lanToAdjoint id lanToAdjoint adjointToLan id",
          "hierarchy": "Data Functor Kan Lan",
          "module": "Data.Functor.Kan.Lan",
          "name": "adjointToLan",
          "normalized": "a b-\u003eLan c Identity b",
          "package": "kan-extensions",
          "partial": "To Lan",
          "signature": "g a-\u003eLan f Identity a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/kan-extensions/docs/Data-Functor-Kan-Lan.html#v:adjointToLan"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003ecomposeLan\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003edecomposeLan\u003c/a\u003e\u003c/code\u003e witness the natural isomorphism from \u003ccode\u003eLan f (Lan g h)\u003c/code\u003e and \u003ccode\u003eLan (f \u003ccode\u003eo\u003c/code\u003e g) h\u003c/code\u003e\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003ecomposeLan\u003c/a\u003e\u003c/code\u003e . \u003ccode\u003e\u003ca\u003edecomposeLan\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003eid\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003edecomposeLan\u003c/a\u003e\u003c/code\u003e . \u003ccode\u003e\u003ca\u003ecomposeLan\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003eid\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e",
          "module": "Data.Functor.Kan.Lan",
          "name": "composeLan",
          "package": "kan-extensions",
          "signature": "Lan f (Lan g h) a -\u003e Lan (compose f g) h a",
          "source": "src/Data-Functor-Kan-Lan.html#composeLan",
          "type": "function"
        },
        "index": {
          "description": "composeLan and decomposeLan witness the natural isomorphism from Lan Lan and Lan composeLan decomposeLan id decomposeLan composeLan id",
          "hierarchy": "Data Functor Kan Lan",
          "module": "Data.Functor.Kan.Lan",
          "name": "composeLan",
          "normalized": "Lan a(Lan b c)d-\u003eLan(e a b)c d",
          "package": "kan-extensions",
          "partial": "Lan",
          "signature": "Lan f(Lan g h)a-\u003eLan(compose f g)h a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/kan-extensions/docs/Data-Functor-Kan-Lan.html#v:composeLan"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Functor.Kan.Lan",
          "name": "composedAdjointToLan",
          "package": "kan-extensions",
          "signature": "h (g a) -\u003e Lan f h a",
          "source": "src/Data-Functor-Kan-Lan.html#composedAdjointToLan",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Functor Kan Lan",
          "module": "Data.Functor.Kan.Lan",
          "name": "composedAdjointToLan",
          "normalized": "a(b c)-\u003eLan d a c",
          "package": "kan-extensions",
          "partial": "Adjoint To Lan",
          "signature": "h(g a)-\u003eLan f h a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/kan-extensions/docs/Data-Functor-Kan-Lan.html#v:composedAdjointToLan"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Functor.Kan.Lan",
          "name": "decomposeLan",
          "package": "kan-extensions",
          "signature": "Lan (compose f g) h a -\u003e Lan f (Lan g h) a",
          "source": "src/Data-Functor-Kan-Lan.html#decomposeLan",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Functor Kan Lan",
          "module": "Data.Functor.Kan.Lan",
          "name": "decomposeLan",
          "normalized": "Lan(a b c)d e-\u003eLan b(Lan c d)e",
          "package": "kan-extensions",
          "partial": "Lan",
          "signature": "Lan(compose f g)h a-\u003eLan f(Lan g h)a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/kan-extensions/docs/Data-Functor-Kan-Lan.html#v:decomposeLan"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003efromLan\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003etoLan\u003c/a\u003e\u003c/code\u003e witness a (higher kinded) adjunction between \u003ccode\u003e\u003ccode\u003e\u003ca\u003eLan\u003c/a\u003e\u003c/code\u003e g\u003c/code\u003e and \u003ccode\u003e(\u003ccode\u003eCompose\u003c/code\u003e g)\u003c/code\u003e\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003etoLan\u003c/a\u003e\u003c/code\u003e . \u003ccode\u003e\u003ca\u003efromLan\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003eid\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003efromLan\u003c/a\u003e\u003c/code\u003e . \u003ccode\u003e\u003ca\u003etoLan\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003eid\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e",
          "module": "Data.Functor.Kan.Lan",
          "name": "fromLan",
          "package": "kan-extensions",
          "signature": "(forall a.  Lan g h a -\u003e f a) -\u003e h b -\u003e f (g b)",
          "source": "src/Data-Functor-Kan-Lan.html#fromLan",
          "type": "function"
        },
        "index": {
          "description": "fromLan and toLan witness higher kinded adjunction between Lan and Compose toLan fromLan id fromLan toLan id",
          "hierarchy": "Data Functor Kan Lan",
          "module": "Data.Functor.Kan.Lan",
          "name": "fromLan",
          "normalized": "(a b Lan c d e-\u003ef e)-\u003ed g-\u003ef(c g)",
          "package": "kan-extensions",
          "partial": "Lan",
          "signature": "(forall a. Lan g h a-\u003ef a)-\u003eh b-\u003ef(g b)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/kan-extensions/docs/Data-Functor-Kan-Lan.html#v:fromLan"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis is the natural transformation that defines a Left Kan extension.\n\u003c/p\u003e",
          "module": "Data.Functor.Kan.Lan",
          "name": "glan",
          "package": "kan-extensions",
          "signature": "h a -\u003e Lan g h (g a)",
          "source": "src/Data-Functor-Kan-Lan.html#glan",
          "type": "function"
        },
        "index": {
          "description": "This is the natural transformation that defines Left Kan extension",
          "hierarchy": "Data Functor Kan Lan",
          "module": "Data.Functor.Kan.Lan",
          "name": "glan",
          "normalized": "a b-\u003eLan c a(c b)",
          "package": "kan-extensions",
          "signature": "h a-\u003eLan g h(g a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/kan-extensions/docs/Data-Functor-Kan-Lan.html#v:glan"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Functor.Kan.Lan",
          "name": "lanToAdjoint",
          "package": "kan-extensions",
          "signature": "Lan f Identity a -\u003e g a",
          "source": "src/Data-Functor-Kan-Lan.html#lanToAdjoint",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Functor Kan Lan",
          "module": "Data.Functor.Kan.Lan",
          "name": "lanToAdjoint",
          "normalized": "Lan a Identity b-\u003ec b",
          "package": "kan-extensions",
          "partial": "To Adjoint",
          "signature": "Lan f Identity a-\u003eg a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/kan-extensions/docs/Data-Functor-Kan-Lan.html#v:lanToAdjoint"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003elanToComposedAdjoint\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003ecomposedAdjointToLan\u003c/a\u003e\u003c/code\u003e witness the natural isomorphism between \u003ccode\u003eLan f h\u003c/code\u003e and \u003ccode\u003eCompose h g\u003c/code\u003e given \u003ccode\u003ef -| g\u003c/code\u003e\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003ecomposedAdjointToLan\u003c/a\u003e\u003c/code\u003e . \u003ccode\u003e\u003ca\u003elanToComposedAdjoint\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003eid\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003elanToComposedAdjoint\u003c/a\u003e\u003c/code\u003e . \u003ccode\u003e\u003ca\u003ecomposedAdjointToLan\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003eid\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e",
          "module": "Data.Functor.Kan.Lan",
          "name": "lanToComposedAdjoint",
          "package": "kan-extensions",
          "signature": "Lan f h a -\u003e h (g a)",
          "source": "src/Data-Functor-Kan-Lan.html#lanToComposedAdjoint",
          "type": "function"
        },
        "index": {
          "description": "lanToComposedAdjoint and composedAdjointToLan witness the natural isomorphism between Lan and Compose given composedAdjointToLan lanToComposedAdjoint id lanToComposedAdjoint composedAdjointToLan id",
          "hierarchy": "Data Functor Kan Lan",
          "module": "Data.Functor.Kan.Lan",
          "name": "lanToComposedAdjoint",
          "normalized": "Lan a b c-\u003eb(d c)",
          "package": "kan-extensions",
          "partial": "To Composed Adjoint",
          "signature": "Lan f h a-\u003eh(g a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/kan-extensions/docs/Data-Functor-Kan-Lan.html#v:lanToComposedAdjoint"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe universal property of a left Kan extension.\n\u003c/p\u003e",
          "module": "Data.Functor.Kan.Lan",
          "name": "toLan",
          "package": "kan-extensions",
          "signature": "(forall a.  h a -\u003e f (g a)) -\u003e Lan g h b -\u003e f b",
          "source": "src/Data-Functor-Kan-Lan.html#toLan",
          "type": "function"
        },
        "index": {
          "description": "The universal property of left Kan extension",
          "hierarchy": "Data Functor Kan Lan",
          "module": "Data.Functor.Kan.Lan",
          "name": "toLan",
          "normalized": "(a b c d-\u003ee(f d))-\u003eLan f c g-\u003ee g",
          "package": "kan-extensions",
          "partial": "Lan",
          "signature": "(forall a. h a-\u003ef(g a))-\u003eLan g h b-\u003ef b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/kan-extensions/docs/Data-Functor-Kan-Lan.html#v:toLan"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eLeft Kan lifts for functors over Hask, wherever they exist.\n\u003c/p\u003e\u003cp\u003e\u003ca\u003ehttp://ncatlab.org/nlab/show/Kan+lift\u003c/a\u003e\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.Functor.Kan.Lift",
          "name": "Lift",
          "package": "kan-extensions",
          "source": "src/Data-Functor-Kan-Lift.html",
          "type": "module"
        },
        "index": {
          "description": "Left Kan lifts for functors over Hask wherever they exist http ncatlab.org nlab show Kan lift",
          "hierarchy": "Data Functor Kan Lift",
          "module": "Data.Functor.Kan.Lift",
          "name": "Lift",
          "package": "kan-extensions",
          "partial": "Lift",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/kan-extensions/docs/Data-Functor-Kan-Lift.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cpre\u003e f =\u003e g . Lift g f\n (forall z. f =\u003e g . z) -\u003e Lift g f =\u003e z -- couniversal\n\u003c/pre\u003e\u003cp\u003eHere we use the universal property directly as how we extract from our definition of \u003ccode\u003e\u003ca\u003eLift\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Functor.Kan.Lift",
          "name": "Lift",
          "package": "kan-extensions",
          "source": "src/Data-Functor-Kan-Lift.html#Lift",
          "type": "newtype"
        },
        "index": {
          "description": "Lift forall Lift couniversal Here we use the universal property directly as how we extract from our definition of Lift",
          "hierarchy": "Data Functor Kan Lift",
          "module": "Data.Functor.Kan.Lift",
          "name": "Lift",
          "package": "kan-extensions",
          "partial": "Lift",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/kan-extensions/docs/Data-Functor-Kan-Lift.html#t:Lift"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Functor.Kan.Lift",
          "name": "Lift",
          "package": "kan-extensions",
          "signature": "Lift",
          "source": "src/Data-Functor-Kan-Lift.html#Lift",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Functor Kan Lift",
          "module": "Data.Functor.Kan.Lift",
          "name": "Lift",
          "package": "kan-extensions",
          "partial": "Lift",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/kan-extensions/docs/Data-Functor-Kan-Lift.html#v:Lift"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eLift u Identity a\u003c/code\u003e is isomorphic to the left adjoint to \u003ccode\u003eu\u003c/code\u003e if one exists.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003eadjointToLift\u003c/a\u003e\u003c/code\u003e . \u003ccode\u003e\u003ca\u003eliftToAdjoint\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003eid\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003eliftToAdjoint\u003c/a\u003e\u003c/code\u003e . \u003ccode\u003e\u003ca\u003eadjointToLift\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003eid\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e",
          "module": "Data.Functor.Kan.Lift",
          "name": "adjointToLift",
          "package": "kan-extensions",
          "signature": "f a -\u003e Lift u Identity a",
          "source": "src/Data-Functor-Kan-Lift.html#adjointToLift",
          "type": "function"
        },
        "index": {
          "description": "Lift Identity is isomorphic to the left adjoint to if one exists adjointToLift liftToAdjoint id liftToAdjoint adjointToLift id",
          "hierarchy": "Data Functor Kan Lift",
          "module": "Data.Functor.Kan.Lift",
          "name": "adjointToLift",
          "normalized": "a b-\u003eLift c Identity b",
          "package": "kan-extensions",
          "partial": "To Lift",
          "signature": "f a-\u003eLift u Identity a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/kan-extensions/docs/Data-Functor-Kan-Lift.html#v:adjointToLift"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003ecomposeLift\u003c/a\u003e\u003c/code\u003e . \u003ccode\u003e\u003ca\u003edecomposeLift\u003c/a\u003e\u003c/code\u003e = \u003ccode\u003e\u003ca\u003eid\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003edecomposeLift\u003c/a\u003e\u003c/code\u003e . \u003ccode\u003e\u003ca\u003ecomposeLift\u003c/a\u003e\u003c/code\u003e = \u003ccode\u003e\u003ca\u003eid\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e",
          "module": "Data.Functor.Kan.Lift",
          "name": "composeLift",
          "package": "kan-extensions",
          "signature": "Lift f (Lift g h) a -\u003e Lift (compose g f) h a",
          "source": "src/Data-Functor-Kan-Lift.html#composeLift",
          "type": "function"
        },
        "index": {
          "description": "composeLift decomposeLift id decomposeLift composeLift id",
          "hierarchy": "Data Functor Kan Lift",
          "module": "Data.Functor.Kan.Lift",
          "name": "composeLift",
          "normalized": "Lift a(Lift b c)d-\u003eLift(e b a)c d",
          "package": "kan-extensions",
          "partial": "Lift",
          "signature": "Lift f(Lift g h)a-\u003eLift(compose g f)h a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/kan-extensions/docs/Data-Functor-Kan-Lift.html#v:composeLift"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eLift u h a\u003c/code\u003e is isomorphic to the post-composition of the left adjoint of \u003ccode\u003eu\u003c/code\u003e onto \u003ccode\u003eh\u003c/code\u003e if such a left adjoint exists.\n\u003c/p\u003e",
          "module": "Data.Functor.Kan.Lift",
          "name": "composedAdjointToLift",
          "package": "kan-extensions",
          "signature": "f (h a) -\u003e Lift u h a",
          "source": "src/Data-Functor-Kan-Lift.html#composedAdjointToLift",
          "type": "function"
        },
        "index": {
          "description": "Lift is isomorphic to the post-composition of the left adjoint of onto if such left adjoint exists",
          "hierarchy": "Data Functor Kan Lift",
          "module": "Data.Functor.Kan.Lift",
          "name": "composedAdjointToLift",
          "normalized": "a(b c)-\u003eLift d b c",
          "package": "kan-extensions",
          "partial": "Adjoint To Lift",
          "signature": "f(h a)-\u003eLift u h a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/kan-extensions/docs/Data-Functor-Kan-Lift.html#v:composedAdjointToLift"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Functor.Kan.Lift",
          "name": "composedRepToLift",
          "package": "kan-extensions",
          "signature": "Rep u -\u003e h a -\u003e Lift u h a",
          "source": "src/Data-Functor-Kan-Lift.html#composedRepToLift",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Functor Kan Lift",
          "module": "Data.Functor.Kan.Lift",
          "name": "composedRepToLift",
          "normalized": "Rep a-\u003eb c-\u003eLift a b c",
          "package": "kan-extensions",
          "partial": "Rep To Lift",
          "signature": "Rep u-\u003eh a-\u003eLift u h a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/kan-extensions/docs/Data-Functor-Kan-Lift.html#v:composedRepToLift"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Functor.Kan.Lift",
          "name": "decomposeLift",
          "package": "kan-extensions",
          "signature": "Lift (compose g f) h a -\u003e Lift f (Lift g h) a",
          "source": "src/Data-Functor-Kan-Lift.html#decomposeLift",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Functor Kan Lift",
          "module": "Data.Functor.Kan.Lift",
          "name": "decomposeLift",
          "normalized": "Lift(a b c)d e-\u003eLift c(Lift b d)e",
          "package": "kan-extensions",
          "partial": "Lift",
          "signature": "Lift(compose g f)h a-\u003eLift f(Lift g h)a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/kan-extensions/docs/Data-Functor-Kan-Lift.html#v:decomposeLift"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWhen the adjunction exists\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003efromLift\u003c/a\u003e\u003c/code\u003e . \u003ccode\u003e\u003ca\u003etoLift\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003eid\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003etoLift\u003c/a\u003e\u003c/code\u003e . \u003ccode\u003e\u003ca\u003efromLift\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003eid\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e",
          "module": "Data.Functor.Kan.Lift",
          "name": "fromLift",
          "package": "kan-extensions",
          "signature": "(forall a.  Lift u f a -\u003e z a) -\u003e f b -\u003e u (z b)",
          "source": "src/Data-Functor-Kan-Lift.html#fromLift",
          "type": "function"
        },
        "index": {
          "description": "When the adjunction exists fromLift toLift id toLift fromLift id",
          "hierarchy": "Data Functor Kan Lift",
          "module": "Data.Functor.Kan.Lift",
          "name": "fromLift",
          "normalized": "(a b Lift c d e-\u003ef e)-\u003ed g-\u003ec(f g)",
          "package": "kan-extensions",
          "partial": "Lift",
          "signature": "(forall a. Lift u f a-\u003ez a)-\u003ef b-\u003eu(z b)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/kan-extensions/docs/Data-Functor-Kan-Lift.html#v:fromLift"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cpre\u003ef =\u003e g (\u003ccode\u003e\u003ca\u003eLift\u003c/a\u003e\u003c/code\u003e g f a)\u003c/pre\u003e",
          "module": "Data.Functor.Kan.Lift",
          "name": "glift",
          "package": "kan-extensions",
          "signature": "k a -\u003e g (Lift g k a)",
          "source": "src/Data-Functor-Kan-Lift.html#glift",
          "type": "function"
        },
        "index": {
          "description": "Lift",
          "hierarchy": "Data Functor Kan Lift",
          "module": "Data.Functor.Kan.Lift",
          "name": "glift",
          "normalized": "a b-\u003ec(Lift c a b)",
          "package": "kan-extensions",
          "signature": "k a-\u003eg(Lift g k a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/kan-extensions/docs/Data-Functor-Kan-Lift.html#v:glift"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eLift u Identity a\u003c/code\u003e is isomorphic to the left adjoint to \u003ccode\u003eu\u003c/code\u003e if one exists.\n\u003c/p\u003e",
          "module": "Data.Functor.Kan.Lift",
          "name": "liftToAdjoint",
          "package": "kan-extensions",
          "signature": "Lift u Identity a -\u003e f a",
          "source": "src/Data-Functor-Kan-Lift.html#liftToAdjoint",
          "type": "function"
        },
        "index": {
          "description": "Lift Identity is isomorphic to the left adjoint to if one exists",
          "hierarchy": "Data Functor Kan Lift",
          "module": "Data.Functor.Kan.Lift",
          "name": "liftToAdjoint",
          "normalized": "Lift a Identity b-\u003ec b",
          "package": "kan-extensions",
          "partial": "To Adjoint",
          "signature": "Lift u Identity a-\u003ef a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/kan-extensions/docs/Data-Functor-Kan-Lift.html#v:liftToAdjoint"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eLift u h a\u003c/code\u003e is isomorphic to the post-composition of the left adjoint of \u003ccode\u003eu\u003c/code\u003e onto \u003ccode\u003eh\u003c/code\u003e if such a left adjoint exists.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003eliftToComposedAdjoint\u003c/a\u003e\u003c/code\u003e . \u003ccode\u003e\u003ca\u003ecomposedAdjointToLift\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003eid\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003ecomposedAdjointToLift\u003c/a\u003e\u003c/code\u003e . \u003ccode\u003e\u003ca\u003eliftToComposedAdjoint\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003eid\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e",
          "module": "Data.Functor.Kan.Lift",
          "name": "liftToComposedAdjoint",
          "package": "kan-extensions",
          "signature": "Lift u h a -\u003e f (h a)",
          "source": "src/Data-Functor-Kan-Lift.html#liftToComposedAdjoint",
          "type": "function"
        },
        "index": {
          "description": "Lift is isomorphic to the post-composition of the left adjoint of onto if such left adjoint exists liftToComposedAdjoint composedAdjointToLift id composedAdjointToLift liftToComposedAdjoint id",
          "hierarchy": "Data Functor Kan Lift",
          "module": "Data.Functor.Kan.Lift",
          "name": "liftToComposedAdjoint",
          "normalized": "Lift a b c-\u003ed(b c)",
          "package": "kan-extensions",
          "partial": "To Composed Adjoint",
          "signature": "Lift u h a-\u003ef(h a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/kan-extensions/docs/Data-Functor-Kan-Lift.html#v:liftToComposedAdjoint"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003eliftToComposedRep\u003c/a\u003e\u003c/code\u003e . \u003ccode\u003e\u003ca\u003ecomposedRepToLift\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003eid\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003ecomposedRepToLift\u003c/a\u003e\u003c/code\u003e . \u003ccode\u003e\u003ca\u003eliftToComposedRep\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003eid\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e",
          "module": "Data.Functor.Kan.Lift",
          "name": "liftToComposedRep",
          "package": "kan-extensions",
          "signature": "Lift u h a -\u003e (Rep u, h a)",
          "source": "src/Data-Functor-Kan-Lift.html#liftToComposedRep",
          "type": "function"
        },
        "index": {
          "description": "liftToComposedRep composedRepToLift id composedRepToLift liftToComposedRep id",
          "hierarchy": "Data Functor Kan Lift",
          "module": "Data.Functor.Kan.Lift",
          "name": "liftToComposedRep",
          "normalized": "Lift a b c-\u003e(Rep a,b c)",
          "package": "kan-extensions",
          "partial": "To Composed Rep",
          "signature": "Lift u h a-\u003e(Rep u,h a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/kan-extensions/docs/Data-Functor-Kan-Lift.html#v:liftToComposedRep"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Functor.Kan.Lift",
          "name": "liftToRep",
          "package": "kan-extensions",
          "signature": "Lift u Identity a -\u003e (Rep u, a)",
          "source": "src/Data-Functor-Kan-Lift.html#liftToRep",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Functor Kan Lift",
          "module": "Data.Functor.Kan.Lift",
          "name": "liftToRep",
          "normalized": "Lift a Identity b-\u003e(Rep a,b)",
          "package": "kan-extensions",
          "partial": "To Rep",
          "signature": "Lift u Identity a-\u003e(Rep u,a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/kan-extensions/docs/Data-Functor-Kan-Lift.html#v:liftToRep"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003erepToLift\u003c/a\u003e\u003c/code\u003e . \u003ccode\u003e\u003ca\u003eliftToRep\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003eid\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003eliftToRep\u003c/a\u003e\u003c/code\u003e . \u003ccode\u003e\u003ca\u003erepToLift\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003eid\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e",
          "module": "Data.Functor.Kan.Lift",
          "name": "repToLift",
          "package": "kan-extensions",
          "signature": "Rep u -\u003e a -\u003e Lift u Identity a",
          "source": "src/Data-Functor-Kan-Lift.html#repToLift",
          "type": "function"
        },
        "index": {
          "description": "repToLift liftToRep id liftToRep repToLift id",
          "hierarchy": "Data Functor Kan Lift",
          "module": "Data.Functor.Kan.Lift",
          "name": "repToLift",
          "normalized": "Rep a-\u003eb-\u003eLift a Identity b",
          "package": "kan-extensions",
          "partial": "To Lift",
          "signature": "Rep u-\u003ea-\u003eLift u Identity a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/kan-extensions/docs/Data-Functor-Kan-Lift.html#v:repToLift"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Functor.Kan.Lift",
          "name": "runLift",
          "package": "kan-extensions",
          "signature": "(forall x.  f x -\u003e g (z x)) -\u003e z a",
          "source": "src/Data-Functor-Kan-Lift.html#Lift",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Functor Kan Lift",
          "module": "Data.Functor.Kan.Lift",
          "name": "runLift",
          "normalized": "(a b c d-\u003ee(f d))-\u003ef g",
          "package": "kan-extensions",
          "partial": "Lift",
          "signature": "(forall x. f x-\u003eg(z x))-\u003ez a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/kan-extensions/docs/Data-Functor-Kan-Lift.html#v:runLift"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe universal property of \u003ccode\u003e\u003ca\u003eLift\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Data.Functor.Kan.Lift",
          "name": "toLift",
          "package": "kan-extensions",
          "signature": "(forall a.  f a -\u003e g (z a)) -\u003e Lift g f b -\u003e z b",
          "source": "src/Data-Functor-Kan-Lift.html#toLift",
          "type": "function"
        },
        "index": {
          "description": "The universal property of Lift",
          "hierarchy": "Data Functor Kan Lift",
          "module": "Data.Functor.Kan.Lift",
          "name": "toLift",
          "normalized": "(a b c d-\u003ee(f d))-\u003eLift e c g-\u003ef g",
          "package": "kan-extensions",
          "partial": "Lift",
          "signature": "(forall a. f a-\u003eg(z a))-\u003eLift g f b-\u003ez b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/kan-extensions/docs/Data-Functor-Kan-Lift.html#v:toLift"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cul\u003e\u003cli\u003e Right Kan Extensions\n\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e",
          "module": "Data.Functor.Kan.Ran",
          "name": "Ran",
          "package": "kan-extensions",
          "source": "src/Data-Functor-Kan-Ran.html",
          "type": "module"
        },
        "index": {
          "description": "Right Kan Extensions",
          "hierarchy": "Data Functor Kan Ran",
          "module": "Data.Functor.Kan.Ran",
          "name": "Ran",
          "package": "kan-extensions",
          "partial": "Ran",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/kan-extensions/docs/Data-Functor-Kan-Ran.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe right Kan extension of a \u003ccode\u003e\u003ca\u003eFunctor\u003c/a\u003e\u003c/code\u003e h along a \u003ccode\u003e\u003ca\u003eFunctor\u003c/a\u003e\u003c/code\u003e g.\n\u003c/p\u003e\u003cp\u003eWe can define a right Kan extension in several ways. The definition here is obtained by reading off\n the definition in of a right Kan extension in terms of an End, but we can derive an equivalent definition\n from the universal property.\n\u003c/p\u003e\u003cp\u003eGiven a \u003ccode\u003e\u003ca\u003eFunctor\u003c/a\u003e\u003c/code\u003e \u003ccode\u003eh : C -\u003e D\u003c/code\u003e and a \u003ccode\u003e\u003ca\u003eFunctor\u003c/a\u003e\u003c/code\u003e \u003ccode\u003eg : C -\u003e C'\u003c/code\u003e, we want to find extend \u003ccode\u003eh\u003c/code\u003e \u003cem\u003eback\u003c/em\u003e along \u003ccode\u003eg\u003c/code\u003e\n to give \u003ccode\u003eRan g h : C' -\u003e C\u003c/code\u003e, such that the natural transformation \u003ccode\u003e\u003ccode\u003e\u003ca\u003egran\u003c/a\u003e\u003c/code\u003e :: Ran g h (g a) -\u003e h a\u003c/code\u003e exists.\n\u003c/p\u003e\u003cp\u003eIn some sense this is trying to approximate the inverse of \u003ccode\u003eg\u003c/code\u003e by using one of\n its adjoints, because if the adjoint and the inverse both exist, they match!\n\u003c/p\u003e\u003cpre\u003e Hask -h-\u003e Hask\n   |       +\n   g      /\n   |    Ran g h\n   v    /\n Hask -'\n\u003c/pre\u003e\u003cp\u003eThe Right Kan extension is unique (up to isomorphism) by taking this as its universal property.\n\u003c/p\u003e\u003cp\u003eThat is to say given any \u003ccode\u003eK : C' -\u003e C\u003c/code\u003e such that we have a natural transformation from \u003ccode\u003ek.g\u003c/code\u003e to \u003ccode\u003eh\u003c/code\u003e\n \u003ccode\u003e(forall x. k (g x) -\u003e h x)\u003c/code\u003e there exists a canonical natural transformation from \u003ccode\u003ek\u003c/code\u003e to \u003ccode\u003eRan g h\u003c/code\u003e.\n \u003ccode\u003e(forall x. k x -\u003e Ran g h x)\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eWe could literally read this off as a valid Rank-3 definition for \u003ccode\u003e\u003ca\u003eRan\u003c/a\u003e\u003c/code\u003e:\n\u003c/p\u003e\u003cpre\u003e\n data Ran' g h a = forall z. \u003ccode\u003e\u003ca\u003eFunctor\u003c/a\u003e\u003c/code\u003e z =\u003e Ran' (forall x. z (g x) -\u003e h x) (z a)\n\u003c/pre\u003e\u003cp\u003eThis definition is isomorphic the simpler Rank-2 definition we use below as witnessed by the\n\u003c/p\u003e\u003cpre\u003e\n ranIso1 :: Ran g f x -\u003e Ran' g f x\n ranIso1 (Ran e) = Ran' e id\n\nranIso2 :: Ran' g f x -\u003e Ran g f x\n ranIso2 (Ran' h z) = Ran $ k -\u003e h (k \u003ca\u003e$\u003c/a\u003e z)\n\u003c/pre\u003e\u003cpre\u003e\n ranIso2 (ranIso1 (Ran e)) &#8801; -- by definition\n ranIso2 (Ran' e id) &#8801;       -- by definition\n Ran $ k -\u003e e (k \u003ca\u003e$\u003c/a\u003e id)    -- by definition\n Ran $ k -\u003e e (k . id)      -- f . id = f\n Ran $ k -\u003e e k             -- eta reduction\n Ran e\n\u003c/pre\u003e\u003cp\u003eThe other direction is left as an exercise for the reader.\n\u003c/p\u003e",
          "module": "Data.Functor.Kan.Ran",
          "name": "Ran",
          "package": "kan-extensions",
          "source": "src/Data-Functor-Kan-Ran.html#Ran",
          "type": "newtype"
        },
        "index": {
          "description": "The right Kan extension of Functor along Functor We can define right Kan extension in several ways The definition here is obtained by reading off the definition in of right Kan extension in terms of an End but we can derive an equivalent definition from the universal property Given Functor and Functor we want to find extend back along to give Ran such that the natural transformation gran Ran exists In some sense this is trying to approximate the inverse of by using one of its adjoints because if the adjoint and the inverse both exist they match Hask Hask Ran Hask The Right Kan extension is unique up to isomorphism by taking this as its universal property That is to say given any such that we have natural transformation from k.g to forall there exists canonical natural transformation from to Ran forall Ran We could literally read this off as valid Rank-3 definition for Ran data Ran forall Functor Ran forall This definition is isomorphic the simpler Rank-2 definition we use below as witnessed by the ranIso1 Ran Ran ranIso1 Ran Ran id ranIso2 Ran Ran ranIso2 Ran Ran ranIso2 ranIso1 Ran by definition ranIso2 Ran id by definition Ran id by definition Ran id id Ran eta reduction Ran The other direction is left as an exercise for the reader",
          "hierarchy": "Data Functor Kan Ran",
          "module": "Data.Functor.Kan.Ran",
          "name": "Ran",
          "package": "kan-extensions",
          "partial": "Ran",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/kan-extensions/docs/Data-Functor-Kan-Ran.html#t:Ran"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Functor.Kan.Ran",
          "name": "Ran",
          "package": "kan-extensions",
          "signature": "Ran",
          "source": "src/Data-Functor-Kan-Ran.html#Ran",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Functor Kan Ran",
          "module": "Data.Functor.Kan.Ran",
          "name": "Ran",
          "package": "kan-extensions",
          "partial": "Ran",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/kan-extensions/docs/Data-Functor-Kan-Ran.html#v:Ran"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003eadjointToRan\u003c/a\u003e\u003c/code\u003e . \u003ccode\u003e\u003ca\u003eranToAdjoint\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003eid\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003eranToAdjoint\u003c/a\u003e\u003c/code\u003e . \u003ccode\u003e\u003ca\u003eadjointToRan\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003eid\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e",
          "module": "Data.Functor.Kan.Ran",
          "name": "adjointToRan",
          "package": "kan-extensions",
          "signature": "f a -\u003e Ran g Identity a",
          "source": "src/Data-Functor-Kan-Ran.html#adjointToRan",
          "type": "function"
        },
        "index": {
          "description": "adjointToRan ranToAdjoint id ranToAdjoint adjointToRan id",
          "hierarchy": "Data Functor Kan Ran",
          "module": "Data.Functor.Kan.Ran",
          "name": "adjointToRan",
          "normalized": "a b-\u003eRan c Identity b",
          "package": "kan-extensions",
          "partial": "To Ran",
          "signature": "f a-\u003eRan g Identity a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/kan-extensions/docs/Data-Functor-Kan-Ran.html#v:adjointToRan"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003ecomposeRan\u003c/a\u003e\u003c/code\u003e . \u003ccode\u003e\u003ca\u003edecomposeRan\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003eid\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003edecomposeRan\u003c/a\u003e\u003c/code\u003e . \u003ccode\u003e\u003ca\u003ecomposeRan\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003eid\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e",
          "module": "Data.Functor.Kan.Ran",
          "name": "composeRan",
          "package": "kan-extensions",
          "signature": "Ran f (Ran g h) a -\u003e Ran (compose f g) h a",
          "source": "src/Data-Functor-Kan-Ran.html#composeRan",
          "type": "function"
        },
        "index": {
          "description": "composeRan decomposeRan id decomposeRan composeRan id",
          "hierarchy": "Data Functor Kan Ran",
          "module": "Data.Functor.Kan.Ran",
          "name": "composeRan",
          "normalized": "Ran a(Ran b c)d-\u003eRan(e a b)c d",
          "package": "kan-extensions",
          "partial": "Ran",
          "signature": "Ran f(Ran g h)a-\u003eRan(compose f g)h a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/kan-extensions/docs/Data-Functor-Kan-Ran.html#v:composeRan"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Functor.Kan.Ran",
          "name": "composedAdjointToRan",
          "package": "kan-extensions",
          "signature": "h (f a) -\u003e Ran g h a",
          "source": "src/Data-Functor-Kan-Ran.html#composedAdjointToRan",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Functor Kan Ran",
          "module": "Data.Functor.Kan.Ran",
          "name": "composedAdjointToRan",
          "normalized": "a(b c)-\u003eRan d a c",
          "package": "kan-extensions",
          "partial": "Adjoint To Ran",
          "signature": "h(f a)-\u003eRan g h a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/kan-extensions/docs/Data-Functor-Kan-Ran.html#v:composedAdjointToRan"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Functor.Kan.Ran",
          "name": "composedRepToRan",
          "package": "kan-extensions",
          "signature": "h (Rep u, a) -\u003e Ran u h a",
          "source": "src/Data-Functor-Kan-Ran.html#composedRepToRan",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Functor Kan Ran",
          "module": "Data.Functor.Kan.Ran",
          "name": "composedRepToRan",
          "normalized": "a(Rep b,c)-\u003eRan b a c",
          "package": "kan-extensions",
          "partial": "Rep To Ran",
          "signature": "h(Rep u,a)-\u003eRan u h a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/kan-extensions/docs/Data-Functor-Kan-Ran.html#v:composedRepToRan"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Functor.Kan.Ran",
          "name": "decomposeRan",
          "package": "kan-extensions",
          "signature": "Ran (compose f g) h a -\u003e Ran f (Ran g h) a",
          "source": "src/Data-Functor-Kan-Ran.html#decomposeRan",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Functor Kan Ran",
          "module": "Data.Functor.Kan.Ran",
          "name": "decomposeRan",
          "normalized": "Ran(a b c)d e-\u003eRan b(Ran c d)e",
          "package": "kan-extensions",
          "partial": "Ran",
          "signature": "Ran(compose f g)h a-\u003eRan f(Ran g h)a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/kan-extensions/docs/Data-Functor-Kan-Ran.html#v:decomposeRan"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003etoRan\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003efromRan\u003c/a\u003e\u003c/code\u003e witness a higher kinded adjunction. from \u003ccode\u003e(`'Compose'` g)\u003c/code\u003e to \u003ccode\u003e\u003ccode\u003e\u003ca\u003eRan\u003c/a\u003e\u003c/code\u003e g\u003c/code\u003e\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003etoRan\u003c/a\u003e\u003c/code\u003e . \u003ccode\u003e\u003ca\u003efromRan\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003eid\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003efromRan\u003c/a\u003e\u003c/code\u003e . \u003ccode\u003e\u003ca\u003etoRan\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003eid\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e",
          "module": "Data.Functor.Kan.Ran",
          "name": "fromRan",
          "package": "kan-extensions",
          "signature": "(forall a.  k a -\u003e Ran g h a) -\u003e k (g b) -\u003e h b",
          "source": "src/Data-Functor-Kan-Ran.html#fromRan",
          "type": "function"
        },
        "index": {
          "description": "toRan and fromRan witness higher kinded adjunction from Compose to Ran toRan fromRan id fromRan toRan id",
          "hierarchy": "Data Functor Kan Ran",
          "module": "Data.Functor.Kan.Ran",
          "name": "fromRan",
          "normalized": "(a b c d-\u003eRan e f d)-\u003ec(e g)-\u003ef g",
          "package": "kan-extensions",
          "partial": "Ran",
          "signature": "(forall a. k a-\u003eRan g h a)-\u003ek(g b)-\u003eh b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/kan-extensions/docs/Data-Functor-Kan-Ran.html#v:fromRan"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis is the natural transformation that defines a Right Kan extension.\n\u003c/p\u003e",
          "module": "Data.Functor.Kan.Ran",
          "name": "gran",
          "package": "kan-extensions",
          "signature": "Ran g h (g a) -\u003e h a",
          "source": "src/Data-Functor-Kan-Ran.html#gran",
          "type": "function"
        },
        "index": {
          "description": "This is the natural transformation that defines Right Kan extension",
          "hierarchy": "Data Functor Kan Ran",
          "module": "Data.Functor.Kan.Ran",
          "name": "gran",
          "normalized": "Ran a b(a c)-\u003eb c",
          "package": "kan-extensions",
          "signature": "Ran g h(g a)-\u003eh a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/kan-extensions/docs/Data-Functor-Kan-Ran.html#v:gran"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Functor.Kan.Ran",
          "name": "ranToAdjoint",
          "package": "kan-extensions",
          "signature": "Ran g Identity a -\u003e f a",
          "source": "src/Data-Functor-Kan-Ran.html#ranToAdjoint",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Functor Kan Ran",
          "module": "Data.Functor.Kan.Ran",
          "name": "ranToAdjoint",
          "normalized": "Ran a Identity b-\u003ec b",
          "package": "kan-extensions",
          "partial": "To Adjoint",
          "signature": "Ran g Identity a-\u003ef a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/kan-extensions/docs/Data-Functor-Kan-Ran.html#v:ranToAdjoint"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003ecomposedAdjointToRan\u003c/a\u003e\u003c/code\u003e . \u003ccode\u003e\u003ca\u003eranToComposedAdjoint\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003eid\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003eranToComposedAdjoint\u003c/a\u003e\u003c/code\u003e . \u003ccode\u003e\u003ca\u003ecomposedAdjointToRan\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003eid\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e",
          "module": "Data.Functor.Kan.Ran",
          "name": "ranToComposedAdjoint",
          "package": "kan-extensions",
          "signature": "Ran g h a -\u003e h (f a)",
          "source": "src/Data-Functor-Kan-Ran.html#ranToComposedAdjoint",
          "type": "function"
        },
        "index": {
          "description": "composedAdjointToRan ranToComposedAdjoint id ranToComposedAdjoint composedAdjointToRan id",
          "hierarchy": "Data Functor Kan Ran",
          "module": "Data.Functor.Kan.Ran",
          "name": "ranToComposedAdjoint",
          "normalized": "Ran a b c-\u003eb(d c)",
          "package": "kan-extensions",
          "partial": "To Composed Adjoint",
          "signature": "Ran g h a-\u003eh(f a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/kan-extensions/docs/Data-Functor-Kan-Ran.html#v:ranToComposedAdjoint"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Functor.Kan.Ran",
          "name": "ranToComposedRep",
          "package": "kan-extensions",
          "signature": "Ran u h a -\u003e h (Rep u, a)",
          "source": "src/Data-Functor-Kan-Ran.html#ranToComposedRep",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Functor Kan Ran",
          "module": "Data.Functor.Kan.Ran",
          "name": "ranToComposedRep",
          "normalized": "Ran a b c-\u003eb(Rep a,c)",
          "package": "kan-extensions",
          "partial": "To Composed Rep",
          "signature": "Ran u h a-\u003eh(Rep u,a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/kan-extensions/docs/Data-Functor-Kan-Ran.html#v:ranToComposedRep"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Functor.Kan.Ran",
          "name": "ranToRep",
          "package": "kan-extensions",
          "signature": "Ran u Identity a -\u003e (Rep u, a)",
          "source": "src/Data-Functor-Kan-Ran.html#ranToRep",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Functor Kan Ran",
          "module": "Data.Functor.Kan.Ran",
          "name": "ranToRep",
          "normalized": "Ran a Identity b-\u003e(Rep a,b)",
          "package": "kan-extensions",
          "partial": "To Rep",
          "signature": "Ran u Identity a-\u003e(Rep u,a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/kan-extensions/docs/Data-Functor-Kan-Ran.html#v:ranToRep"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Functor.Kan.Ran",
          "name": "repToRan",
          "package": "kan-extensions",
          "signature": "Rep u -\u003e a -\u003e Ran u Identity a",
          "source": "src/Data-Functor-Kan-Ran.html#repToRan",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Functor Kan Ran",
          "module": "Data.Functor.Kan.Ran",
          "name": "repToRan",
          "normalized": "Rep a-\u003eb-\u003eRan a Identity b",
          "package": "kan-extensions",
          "partial": "To Ran",
          "signature": "Rep u-\u003ea-\u003eRan u Identity a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/kan-extensions/docs/Data-Functor-Kan-Ran.html#v:repToRan"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Functor.Kan.Ran",
          "name": "runRan",
          "package": "kan-extensions",
          "signature": "forall b.  (a -\u003e g b) -\u003e h b",
          "source": "src/Data-Functor-Kan-Ran.html#Ran",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Functor Kan Ran",
          "module": "Data.Functor.Kan.Ran",
          "name": "runRan",
          "normalized": "a b(c-\u003ed e)-\u003ef e",
          "package": "kan-extensions",
          "partial": "Ran",
          "signature": "forall b.(a-\u003eg b)-\u003eh b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/kan-extensions/docs/Data-Functor-Kan-Ran.html#v:runRan"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe universal property of a right Kan extension.\n\u003c/p\u003e",
          "module": "Data.Functor.Kan.Ran",
          "name": "toRan",
          "package": "kan-extensions",
          "signature": "(forall a.  k (g a) -\u003e h a) -\u003e k b -\u003e Ran g h b",
          "source": "src/Data-Functor-Kan-Ran.html#toRan",
          "type": "function"
        },
        "index": {
          "description": "The universal property of right Kan extension",
          "hierarchy": "Data Functor Kan Ran",
          "module": "Data.Functor.Kan.Ran",
          "name": "toRan",
          "normalized": "(a b c(d e)-\u003ef e)-\u003ec g-\u003eRan d f g",
          "package": "kan-extensions",
          "partial": "Ran",
          "signature": "(forall a. k(g a)-\u003eh a)-\u003ek b-\u003eRan g h b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/kan-extensions/docs/Data-Functor-Kan-Ran.html#v:toRan"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eRight and Left Kan lifts for functors over Hask, where they exist.\n\u003c/p\u003e\u003cp\u003e\u003ca\u003ehttp://ncatlab.org/nlab/show/Kan+lift\u003c/a\u003e\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.Functor.Kan.Rift",
          "name": "Rift",
          "package": "kan-extensions",
          "source": "src/Data-Functor-Kan-Rift.html",
          "type": "module"
        },
        "index": {
          "description": "Right and Left Kan lifts for functors over Hask where they exist http ncatlab.org nlab show Kan lift",
          "hierarchy": "Data Functor Kan Rift",
          "module": "Data.Functor.Kan.Rift",
          "name": "Rift",
          "package": "kan-extensions",
          "partial": "Rift",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/kan-extensions/docs/Data-Functor-Kan-Rift.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cpre\u003eg . \u003ccode\u003e\u003ca\u003eRift\u003c/a\u003e\u003c/code\u003e g f =\u003e f\u003c/pre\u003e\u003cp\u003eThis could alternately be defined directly from the (co)universal propertly\n in which case, we'd get \u003ccode\u003e\u003ca\u003etoRift\u003c/a\u003e\u003c/code\u003e = \u003ccode\u003eUniversalRift\u003c/code\u003e, but then the usage would\n suffer.\n\u003c/p\u003e\u003cpre\u003e\n data \u003ccode\u003eUniversalRift\u003c/code\u003e g f a = forall z. \u003ccode\u003e\u003ca\u003eFunctor\u003c/a\u003e\u003c/code\u003e z =\u003e\n      \u003ccode\u003eUniversalRift\u003c/code\u003e (forall x. g (z x) -\u003e f x) (z a)\n\u003c/pre\u003e\u003cp\u003eWe can witness the isomorphism between Rift and UniversalRift using:\n\u003c/p\u003e\u003cpre\u003e\n riftIso1 :: Functor g =\u003e UniversalRift g f a -\u003e Rift g f a\n riftIso1 (UniversalRift h z) = Rift $ g -\u003e h $ fmap (k -\u003e k \u003ca\u003e$\u003c/a\u003e z) g\n\u003c/pre\u003e\u003cpre\u003e\n riftIso2 :: Rift g f a -\u003e UniversalRift g f a\n riftIso2 (Rift e) = UniversalRift e id\n\u003c/pre\u003e\u003cpre\u003e\n riftIso1 (riftIso2 (Rift h)) =\n riftIso1 (UniversalRift h id) =          -- by definition\n Rift $ g -\u003e h $ fmap (k -\u003e k \u003ca\u003e$\u003c/a\u003e id) g -- by definition\n Rift $ g -\u003e h $ fmap id g               -- \u003ca\u003e$\u003c/a\u003e = (.) and (.id)\n Rift $ g -\u003e h g                         -- by functor law\n Rift h                                   -- eta reduction\n\u003c/pre\u003e\u003cp\u003eThe other direction is left as an exercise for the reader.\n\u003c/p\u003e\u003cp\u003eThere are several monads that we can form from \u003ccode\u003eRift\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eWhen \u003ccode\u003eg\u003c/code\u003e is corepresentable (e.g. is a right adjoint) then there exists \u003ccode\u003ex\u003c/code\u003e such that \u003ccode\u003eg ~ (-\u003e) x\u003c/code\u003e, then it follows that\n\u003c/p\u003e\u003cpre\u003e\n Rift g g a ~\n forall r. (x -\u003e a -\u003e r) -\u003e x -\u003e r ~\n forall r. (a -\u003e x -\u003e r) -\u003e x -\u003e r ~\n forall r. (a -\u003e g r) -\u003e g r ~\n Codensity g r\n\u003c/pre\u003e\u003cp\u003eWhen \u003ccode\u003ef\u003c/code\u003e is a left adjoint, so that \u003ccode\u003ef -| g\u003c/code\u003e then\n\u003c/p\u003e\u003cpre\u003e\n Rift f f a ~\n forall r. f (a -\u003e r) -\u003e f r ~\n forall r. (a -\u003e r) -\u003e g (f r) ~\n forall r. (a -\u003e r) -\u003e Adjoint f g r ~\n Yoneda (Adjoint f g r)\n\u003c/pre\u003e\u003cp\u003eAn alternative way to view that is to note that whenever \u003ccode\u003ef\u003c/code\u003e is a left adjoint then \u003ccode\u003ef -| \u003ccode\u003e\u003ca\u003eRift\u003c/a\u003e\u003c/code\u003e f \u003ccode\u003e\u003ca\u003eIdentity\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e, and since \u003ccode\u003e\u003ccode\u003e\u003ca\u003eRift\u003c/a\u003e\u003c/code\u003e f f\u003c/code\u003e is isomorphic to \u003ccode\u003e\u003ccode\u003e\u003ca\u003eRift\u003c/a\u003e\u003c/code\u003e f \u003ccode\u003e\u003ca\u003eIdentity\u003c/a\u003e\u003c/code\u003e (f a)\u003c/code\u003e, this is the \u003ccode\u003e\u003ca\u003eMonad\u003c/a\u003e\u003c/code\u003e formed by the adjunction.\n\u003c/p\u003e\u003cp\u003e\u003ccode\u003e\u003ccode\u003e\u003ca\u003eRift\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eIdentity\u003c/a\u003e\u003c/code\u003e m\u003c/code\u003e can be a \u003ccode\u003e\u003ca\u003eMonad\u003c/a\u003e\u003c/code\u003e for any \u003ccode\u003e\u003ca\u003eMonad\u003c/a\u003e\u003c/code\u003e \u003ccode\u003em\u003c/code\u003e, as it is isomorphic to \u003ccode\u003e\u003ccode\u003eYoneda\u003c/code\u003e m\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Functor.Kan.Rift",
          "name": "Rift",
          "package": "kan-extensions",
          "source": "src/Data-Functor-Kan-Rift.html#Rift",
          "type": "newtype"
        },
        "index": {
          "description": "Rift This could alternately be defined directly from the co universal propertly in which case we get toRift UniversalRift but then the usage would suffer data UniversalRift forall Functor UniversalRift forall We can witness the isomorphism between Rift and UniversalRift using riftIso1 Functor UniversalRift Rift riftIso1 UniversalRift Rift fmap riftIso2 Rift UniversalRift riftIso2 Rift UniversalRift id riftIso1 riftIso2 Rift riftIso1 UniversalRift id by definition Rift fmap id by definition Rift fmap id and id Rift by functor law Rift eta reduction The other direction is left as an exercise for the reader There are several monads that we can form from Rift When is corepresentable e.g is right adjoint then there exists such that then it follows that Rift forall forall forall Codensity When is left adjoint so that then Rift forall forall forall Adjoint Yoneda Adjoint An alternative way to view that is to note that whenever is left adjoint then Rift Identity and since Rift is isomorphic to Rift Identity this is the Monad formed by the adjunction Rift Identity can be Monad for any Monad as it is isomorphic to Yoneda",
          "hierarchy": "Data Functor Kan Rift",
          "module": "Data.Functor.Kan.Rift",
          "name": "Rift",
          "package": "kan-extensions",
          "partial": "Rift",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/kan-extensions/docs/Data-Functor-Kan-Rift.html#t:Rift"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Functor.Kan.Rift",
          "name": "Rift",
          "package": "kan-extensions",
          "signature": "Rift",
          "source": "src/Data-Functor-Kan-Rift.html#Rift",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Functor Kan Rift",
          "module": "Data.Functor.Kan.Rift",
          "name": "Rift",
          "package": "kan-extensions",
          "partial": "Rift",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/kan-extensions/docs/Data-Functor-Kan-Rift.html#v:Rift"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eRift f Identity a\u003c/code\u003e is isomorphic to the right adjoint to \u003ccode\u003ef\u003c/code\u003e if one exists.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003eadjointToRift\u003c/a\u003e\u003c/code\u003e . \u003ccode\u003e\u003ca\u003eriftToAdjoint\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003eid\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003eriftToAdjoint\u003c/a\u003e\u003c/code\u003e . \u003ccode\u003e\u003ca\u003eadjointToRift\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003eid\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e",
          "module": "Data.Functor.Kan.Rift",
          "name": "adjointToRift",
          "package": "kan-extensions",
          "signature": "u a -\u003e Rift f Identity a",
          "source": "src/Data-Functor-Kan-Rift.html#adjointToRift",
          "type": "function"
        },
        "index": {
          "description": "Rift Identity is isomorphic to the right adjoint to if one exists adjointToRift riftToAdjoint id riftToAdjoint adjointToRift id",
          "hierarchy": "Data Functor Kan Rift",
          "module": "Data.Functor.Kan.Rift",
          "name": "adjointToRift",
          "normalized": "a b-\u003eRift c Identity b",
          "package": "kan-extensions",
          "partial": "To Rift",
          "signature": "u a-\u003eRift f Identity a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/kan-extensions/docs/Data-Functor-Kan-Rift.html#v:adjointToRift"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003ecomposeRift\u003c/a\u003e\u003c/code\u003e . \u003ccode\u003e\u003ca\u003edecomposeRift\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003eid\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003edecomposeRift\u003c/a\u003e\u003c/code\u003e . \u003ccode\u003e\u003ca\u003ecomposeRift\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003eid\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e",
          "module": "Data.Functor.Kan.Rift",
          "name": "composeRift",
          "package": "kan-extensions",
          "signature": "Rift f (Rift g h) a -\u003e Rift (compose g f) h a",
          "source": "src/Data-Functor-Kan-Rift.html#composeRift",
          "type": "function"
        },
        "index": {
          "description": "composeRift decomposeRift id decomposeRift composeRift id",
          "hierarchy": "Data Functor Kan Rift",
          "module": "Data.Functor.Kan.Rift",
          "name": "composeRift",
          "normalized": "Rift a(Rift b c)d-\u003eRift(e b a)c d",
          "package": "kan-extensions",
          "partial": "Rift",
          "signature": "Rift f(Rift g h)a-\u003eRift(compose g f)h a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/kan-extensions/docs/Data-Functor-Kan-Rift.html#v:composeRift"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eRift f h a\u003c/code\u003e is isomorphic to the post-composition of the right adjoint of \u003ccode\u003ef\u003c/code\u003e onto \u003ccode\u003eh\u003c/code\u003e if such a right adjoint exists.\n\u003c/p\u003e",
          "module": "Data.Functor.Kan.Rift",
          "name": "composedAdjointToRift",
          "package": "kan-extensions",
          "signature": "u (h a) -\u003e Rift f h a",
          "source": "src/Data-Functor-Kan-Rift.html#composedAdjointToRift",
          "type": "function"
        },
        "index": {
          "description": "Rift is isomorphic to the post-composition of the right adjoint of onto if such right adjoint exists",
          "hierarchy": "Data Functor Kan Rift",
          "module": "Data.Functor.Kan.Rift",
          "name": "composedAdjointToRift",
          "normalized": "a(b c)-\u003eRift d b c",
          "package": "kan-extensions",
          "partial": "Adjoint To Rift",
          "signature": "u(h a)-\u003eRift f h a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/kan-extensions/docs/Data-Functor-Kan-Rift.html#v:composedAdjointToRift"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Functor.Kan.Rift",
          "name": "decomposeRift",
          "package": "kan-extensions",
          "signature": "Rift (compose g f) h a -\u003e Rift f (Rift g h) a",
          "source": "src/Data-Functor-Kan-Rift.html#decomposeRift",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Functor Kan Rift",
          "module": "Data.Functor.Kan.Rift",
          "name": "decomposeRift",
          "normalized": "Rift(a b c)d e-\u003eRift c(Rift b d)e",
          "package": "kan-extensions",
          "partial": "Rift",
          "signature": "Rift(compose g f)h a-\u003eRift f(Rift g h)a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/kan-extensions/docs/Data-Functor-Kan-Rift.html#v:decomposeRift"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWhen \u003ccode\u003ef -| u\u003c/code\u003e, then \u003ccode\u003ef -| Rift f Identity\u003c/code\u003e and\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003etoRift\u003c/a\u003e\u003c/code\u003e . \u003ccode\u003e\u003ca\u003efromRift\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003eid\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003efromRift\u003c/a\u003e\u003c/code\u003e . \u003ccode\u003e\u003ca\u003etoRift\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003eid\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e",
          "module": "Data.Functor.Kan.Rift",
          "name": "fromRift",
          "package": "kan-extensions",
          "signature": "(forall a.  k a -\u003e Rift f h a) -\u003e f (k b) -\u003e h b",
          "source": "src/Data-Functor-Kan-Rift.html#fromRift",
          "type": "function"
        },
        "index": {
          "description": "When then Rift Identity and toRift fromRift id fromRift toRift id",
          "hierarchy": "Data Functor Kan Rift",
          "module": "Data.Functor.Kan.Rift",
          "name": "fromRift",
          "normalized": "(a b c d-\u003eRift e f d)-\u003ee(c g)-\u003ef g",
          "package": "kan-extensions",
          "partial": "Rift",
          "signature": "(forall a. k a-\u003eRift f h a)-\u003ef(k b)-\u003eh b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/kan-extensions/docs/Data-Functor-Kan-Rift.html#v:fromRift"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Functor.Kan.Rift",
          "name": "grift",
          "package": "kan-extensions",
          "signature": "f (Rift f k a) -\u003e k a",
          "source": "src/Data-Functor-Kan-Rift.html#grift",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Functor Kan Rift",
          "module": "Data.Functor.Kan.Rift",
          "name": "grift",
          "normalized": "a(Rift a b c)-\u003eb c",
          "package": "kan-extensions",
          "signature": "f(Rift f k a)-\u003ek a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/kan-extensions/docs/Data-Functor-Kan-Rift.html#v:grift"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIndexed applicative composition of right Kan lifts.\n\u003c/p\u003e",
          "module": "Data.Functor.Kan.Rift",
          "name": "rap",
          "package": "kan-extensions",
          "signature": "Rift f g (a -\u003e b) -\u003e Rift g h a -\u003e Rift f h b",
          "source": "src/Data-Functor-Kan-Rift.html#rap",
          "type": "function"
        },
        "index": {
          "description": "Indexed applicative composition of right Kan lifts",
          "hierarchy": "Data Functor Kan Rift",
          "module": "Data.Functor.Kan.Rift",
          "name": "rap",
          "normalized": "Rift a b(c-\u003ed)-\u003eRift b e c-\u003eRift a e d",
          "package": "kan-extensions",
          "signature": "Rift f g(a-\u003eb)-\u003eRift g h a-\u003eRift f h b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/kan-extensions/docs/Data-Functor-Kan-Rift.html#v:rap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eRift f Identity a\u003c/code\u003e is isomorphic to the right adjoint to \u003ccode\u003ef\u003c/code\u003e if one exists.\n\u003c/p\u003e",
          "module": "Data.Functor.Kan.Rift",
          "name": "riftToAdjoint",
          "package": "kan-extensions",
          "signature": "Rift f Identity a -\u003e u a",
          "source": "src/Data-Functor-Kan-Rift.html#riftToAdjoint",
          "type": "function"
        },
        "index": {
          "description": "Rift Identity is isomorphic to the right adjoint to if one exists",
          "hierarchy": "Data Functor Kan Rift",
          "module": "Data.Functor.Kan.Rift",
          "name": "riftToAdjoint",
          "normalized": "Rift a Identity b-\u003ec b",
          "package": "kan-extensions",
          "partial": "To Adjoint",
          "signature": "Rift f Identity a-\u003eu a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/kan-extensions/docs/Data-Functor-Kan-Rift.html#v:riftToAdjoint"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eRift f h a\u003c/code\u003e is isomorphic to the post-composition of the right adjoint of \u003ccode\u003ef\u003c/code\u003e onto \u003ccode\u003eh\u003c/code\u003e if such a right adjoint exists.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003eriftToComposedAdjoint\u003c/a\u003e\u003c/code\u003e . \u003ccode\u003e\u003ca\u003ecomposedAdjointToRift\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003eid\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003ecomposedAdjointToRift\u003c/a\u003e\u003c/code\u003e . \u003ccode\u003e\u003ca\u003eriftToComposedAdjoint\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003eid\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e",
          "module": "Data.Functor.Kan.Rift",
          "name": "riftToComposedAdjoint",
          "package": "kan-extensions",
          "signature": "Rift f h a -\u003e u (h a)",
          "source": "src/Data-Functor-Kan-Rift.html#riftToComposedAdjoint",
          "type": "function"
        },
        "index": {
          "description": "Rift is isomorphic to the post-composition of the right adjoint of onto if such right adjoint exists riftToComposedAdjoint composedAdjointToRift id composedAdjointToRift riftToComposedAdjoint id",
          "hierarchy": "Data Functor Kan Rift",
          "module": "Data.Functor.Kan.Rift",
          "name": "riftToComposedAdjoint",
          "normalized": "Rift a b c-\u003ed(b c)",
          "package": "kan-extensions",
          "partial": "To Composed Adjoint",
          "signature": "Rift f h a-\u003eu(h a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/kan-extensions/docs/Data-Functor-Kan-Rift.html#v:riftToComposedAdjoint"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Functor.Kan.Rift",
          "name": "runRift",
          "package": "kan-extensions",
          "signature": "forall r.  g (a -\u003e r) -\u003e h r",
          "source": "src/Data-Functor-Kan-Rift.html#Rift",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Functor Kan Rift",
          "module": "Data.Functor.Kan.Rift",
          "name": "runRift",
          "normalized": "a b c(d-\u003ee)-\u003ef e",
          "package": "kan-extensions",
          "partial": "Rift",
          "signature": "forall r. g(a-\u003er)-\u003eh r",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/kan-extensions/docs/Data-Functor-Kan-Rift.html#v:runRift"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe universal property of \u003ccode\u003e\u003ca\u003eRift\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Data.Functor.Kan.Rift",
          "name": "toRift",
          "package": "kan-extensions",
          "signature": "(forall x.  g (k x) -\u003e h x) -\u003e k a -\u003e Rift g h a",
          "source": "src/Data-Functor-Kan-Rift.html#toRift",
          "type": "function"
        },
        "index": {
          "description": "The universal property of Rift",
          "hierarchy": "Data Functor Kan Rift",
          "module": "Data.Functor.Kan.Rift",
          "name": "toRift",
          "normalized": "(a b c(d e)-\u003ef e)-\u003ed g-\u003eRift c f g",
          "package": "kan-extensions",
          "partial": "Rift",
          "signature": "(forall x. g(k x)-\u003eh x)-\u003ek a-\u003eRift g h a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/kan-extensions/docs/Data-Functor-Kan-Rift.html#v:toRift"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThe covariant form of the Yoneda lemma states that \u003ccode\u003ef\u003c/code\u003e is naturally\n isomorphic to \u003ccode\u003eYoneda f\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eThis is described in a rather intuitive fashion by Dan Piponi in\n\u003c/p\u003e\u003cp\u003e\u003ca\u003ehttp://blog.sigfpe.com/2006/11/yoneda-lemma.html\u003c/a\u003e\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.Functor.Yoneda",
          "name": "Yoneda",
          "package": "kan-extensions",
          "source": "src/Data-Functor-Yoneda.html",
          "type": "module"
        },
        "index": {
          "description": "The covariant form of the Yoneda lemma states that is naturally isomorphic to Yoneda This is described in rather intuitive fashion by Dan Piponi in http blog.sigfpe.com yoneda-lemma.html",
          "hierarchy": "Data Functor Yoneda",
          "module": "Data.Functor.Yoneda",
          "name": "Yoneda",
          "package": "kan-extensions",
          "partial": "Yoneda",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/kan-extensions/docs/Data-Functor-Yoneda.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eYoneda f a\u003c/code\u003e can be viewed as the partial application of \u003ccode\u003e\u003ca\u003efmap\u003c/a\u003e\u003c/code\u003e to its second argument.\n\u003c/p\u003e",
          "module": "Data.Functor.Yoneda",
          "name": "Yoneda",
          "package": "kan-extensions",
          "source": "src/Data-Functor-Yoneda.html#Yoneda",
          "type": "newtype"
        },
        "index": {
          "description": "Yoneda can be viewed as the partial application of fmap to its second argument",
          "hierarchy": "Data Functor Yoneda",
          "module": "Data.Functor.Yoneda",
          "name": "Yoneda",
          "package": "kan-extensions",
          "partial": "Yoneda",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/kan-extensions/docs/Data-Functor-Yoneda.html#t:Yoneda"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Functor.Yoneda",
          "name": "Yoneda",
          "package": "kan-extensions",
          "signature": "Yoneda",
          "source": "src/Data-Functor-Yoneda.html#Yoneda",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Functor Yoneda",
          "module": "Data.Functor.Yoneda",
          "name": "Yoneda",
          "package": "kan-extensions",
          "partial": "Yoneda",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/kan-extensions/docs/Data-Functor-Yoneda.html#v:Yoneda"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe natural isomorphism between \u003ccode\u003ef\u003c/code\u003e and \u003ccode\u003e\u003ccode\u003e\u003ca\u003eYoneda\u003c/a\u003e\u003c/code\u003e f\u003c/code\u003e given by the Yoneda lemma\n is witnessed by \u003ccode\u003e\u003ca\u003eliftYoneda\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003elowerYoneda\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003eliftYoneda\u003c/a\u003e\u003c/code\u003e . \u003ccode\u003e\u003ca\u003elowerYoneda\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003eid\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003elowerYoneda\u003c/a\u003e\u003c/code\u003e . \u003ccode\u003e\u003ca\u003eliftYoneda\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003eid\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e\u003cpre\u003e\n lowerYoneda (liftYoneda fa) =         -- definition\n lowerYoneda (Yoneda (f -\u003e fmap f a)) -- definition\n (f -\u003e fmap f fa) id                  -- beta reduction\n fmap id fa                            -- functor law\n fa\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003elift\u003c/a\u003e\u003c/code\u003e = \u003ccode\u003e\u003ca\u003eliftYoneda\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e",
          "module": "Data.Functor.Yoneda",
          "name": "liftYoneda",
          "package": "kan-extensions",
          "signature": "f a -\u003e Yoneda f a",
          "source": "src/Data-Functor-Yoneda.html#liftYoneda",
          "type": "function"
        },
        "index": {
          "description": "The natural isomorphism between and Yoneda given by the Yoneda lemma is witnessed by liftYoneda and lowerYoneda liftYoneda lowerYoneda id lowerYoneda liftYoneda id lowerYoneda liftYoneda fa definition lowerYoneda Yoneda fmap definition fmap fa id beta reduction fmap id fa functor law fa lift liftYoneda",
          "hierarchy": "Data Functor Yoneda",
          "module": "Data.Functor.Yoneda",
          "name": "liftYoneda",
          "normalized": "a b-\u003eYoneda a b",
          "package": "kan-extensions",
          "partial": "Yoneda",
          "signature": "f a-\u003eYoneda f a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/kan-extensions/docs/Data-Functor-Yoneda.html#v:liftYoneda"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Functor.Yoneda",
          "name": "lowerYoneda",
          "package": "kan-extensions",
          "signature": "Yoneda f a -\u003e f a",
          "source": "src/Data-Functor-Yoneda.html#lowerYoneda",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Functor Yoneda",
          "module": "Data.Functor.Yoneda",
          "name": "lowerYoneda",
          "normalized": "Yoneda a b-\u003ea b",
          "package": "kan-extensions",
          "partial": "Yoneda",
          "signature": "Yoneda f a-\u003ef a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/kan-extensions/docs/Data-Functor-Yoneda.html#v:lowerYoneda"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Functor.Yoneda",
          "name": "maxF",
          "package": "kan-extensions",
          "signature": "Yoneda f a -\u003e Yoneda f a -\u003e Yoneda f a",
          "source": "src/Data-Functor-Yoneda.html#maxF",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Functor Yoneda",
          "module": "Data.Functor.Yoneda",
          "name": "maxF",
          "normalized": "Yoneda a b-\u003eYoneda a b-\u003eYoneda a b",
          "package": "kan-extensions",
          "signature": "Yoneda f a-\u003eYoneda f a-\u003eYoneda f a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/kan-extensions/docs/Data-Functor-Yoneda.html#v:maxF"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Functor.Yoneda",
          "name": "maxM",
          "package": "kan-extensions",
          "signature": "Yoneda m a -\u003e Yoneda m a -\u003e Yoneda m a",
          "source": "src/Data-Functor-Yoneda.html#maxM",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Functor Yoneda",
          "module": "Data.Functor.Yoneda",
          "name": "maxM",
          "normalized": "Yoneda a b-\u003eYoneda a b-\u003eYoneda a b",
          "package": "kan-extensions",
          "signature": "Yoneda m a-\u003eYoneda m a-\u003eYoneda m a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/kan-extensions/docs/Data-Functor-Yoneda.html#v:maxM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Functor.Yoneda",
          "name": "minF",
          "package": "kan-extensions",
          "signature": "Yoneda f a -\u003e Yoneda f a -\u003e Yoneda f a",
          "source": "src/Data-Functor-Yoneda.html#minF",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Functor Yoneda",
          "module": "Data.Functor.Yoneda",
          "name": "minF",
          "normalized": "Yoneda a b-\u003eYoneda a b-\u003eYoneda a b",
          "package": "kan-extensions",
          "signature": "Yoneda f a-\u003eYoneda f a-\u003eYoneda f a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/kan-extensions/docs/Data-Functor-Yoneda.html#v:minF"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Functor.Yoneda",
          "name": "minM",
          "package": "kan-extensions",
          "signature": "Yoneda m a -\u003e Yoneda m a -\u003e Yoneda m a",
          "source": "src/Data-Functor-Yoneda.html#minM",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Functor Yoneda",
          "module": "Data.Functor.Yoneda",
          "name": "minM",
          "normalized": "Yoneda a b-\u003eYoneda a b-\u003eYoneda a b",
          "package": "kan-extensions",
          "signature": "Yoneda m a-\u003eYoneda m a-\u003eYoneda m a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/kan-extensions/docs/Data-Functor-Yoneda.html#v:minM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Functor.Yoneda",
          "name": "ranToYoneda",
          "package": "kan-extensions",
          "signature": "Ran Identity f a -\u003e Yoneda f a",
          "source": "src/Data-Functor-Yoneda.html#ranToYoneda",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Functor Yoneda",
          "module": "Data.Functor.Yoneda",
          "name": "ranToYoneda",
          "normalized": "Ran Identity a b-\u003eYoneda a b",
          "package": "kan-extensions",
          "partial": "To Yoneda",
          "signature": "Ran Identity f a-\u003eYoneda f a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/kan-extensions/docs/Data-Functor-Yoneda.html#v:ranToYoneda"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Functor.Yoneda",
          "name": "riftToYoneda",
          "package": "kan-extensions",
          "signature": "Rift Identity f a -\u003e Yoneda f a",
          "source": "src/Data-Functor-Yoneda.html#riftToYoneda",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Functor Yoneda",
          "module": "Data.Functor.Yoneda",
          "name": "riftToYoneda",
          "normalized": "Rift Identity a b-\u003eYoneda a b",
          "package": "kan-extensions",
          "partial": "To Yoneda",
          "signature": "Rift Identity f a-\u003eYoneda f a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/kan-extensions/docs/Data-Functor-Yoneda.html#v:riftToYoneda"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Functor.Yoneda",
          "name": "runYoneda",
          "package": "kan-extensions",
          "signature": "forall b.  (a -\u003e b) -\u003e f b",
          "source": "src/Data-Functor-Yoneda.html#Yoneda",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Functor Yoneda",
          "module": "Data.Functor.Yoneda",
          "name": "runYoneda",
          "normalized": "a b(c-\u003ed)-\u003ee d",
          "package": "kan-extensions",
          "partial": "Yoneda",
          "signature": "forall b.(a-\u003eb)-\u003ef b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/kan-extensions/docs/Data-Functor-Yoneda.html#v:runYoneda"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eYoneda f\u003c/code\u003e can be viewed as the right Kan extension of \u003ccode\u003ef\u003c/code\u003e along the \u003ccode\u003e\u003ca\u003eIdentity\u003c/a\u003e\u003c/code\u003e functor.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003eyonedaToRan\u003c/a\u003e\u003c/code\u003e . \u003ccode\u003e\u003ca\u003eranToYoneda\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003eid\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003eranToYoneda\u003c/a\u003e\u003c/code\u003e . \u003ccode\u003e\u003ca\u003eyonedaToRan\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003eid\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e",
          "module": "Data.Functor.Yoneda",
          "name": "yonedaToRan",
          "package": "kan-extensions",
          "signature": "Yoneda f a -\u003e Ran Identity f a",
          "source": "src/Data-Functor-Yoneda.html#yonedaToRan",
          "type": "function"
        },
        "index": {
          "description": "Yoneda can be viewed as the right Kan extension of along the Identity functor yonedaToRan ranToYoneda id ranToYoneda yonedaToRan id",
          "hierarchy": "Data Functor Yoneda",
          "module": "Data.Functor.Yoneda",
          "name": "yonedaToRan",
          "normalized": "Yoneda a b-\u003eRan Identity a b",
          "package": "kan-extensions",
          "partial": "To Ran",
          "signature": "Yoneda f a-\u003eRan Identity f a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/kan-extensions/docs/Data-Functor-Yoneda.html#v:yonedaToRan"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eYoneda f\u003c/code\u003e can be viewed as the right Kan lift of \u003ccode\u003ef\u003c/code\u003e along the \u003ccode\u003e\u003ca\u003eIdentity\u003c/a\u003e\u003c/code\u003e functor.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003eyonedaToRift\u003c/a\u003e\u003c/code\u003e . \u003ccode\u003e\u003ca\u003eriftToYoneda\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003eid\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003eriftToYoneda\u003c/a\u003e\u003c/code\u003e . \u003ccode\u003e\u003ca\u003eyonedaToRift\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003eid\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e",
          "module": "Data.Functor.Yoneda",
          "name": "yonedaToRift",
          "package": "kan-extensions",
          "signature": "Yoneda f a -\u003e Rift Identity f a",
          "source": "src/Data-Functor-Yoneda.html#yonedaToRift",
          "type": "function"
        },
        "index": {
          "description": "Yoneda can be viewed as the right Kan lift of along the Identity functor yonedaToRift riftToYoneda id riftToYoneda yonedaToRift id",
          "hierarchy": "Data Functor Yoneda",
          "module": "Data.Functor.Yoneda",
          "name": "yonedaToRift",
          "normalized": "Yoneda a b-\u003eRift Identity a b",
          "package": "kan-extensions",
          "partial": "To Rift",
          "signature": "Yoneda f a-\u003eRift Identity f a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/kan-extensions/docs/Data-Functor-Yoneda.html#v:yonedaToRift"
      }
    }
  ]
]