[
  {
    "cmd": "delete-by-query",
    "query": {
      "contexts": [
        "package"
      ],
      "query": {
        "op": "case",
        "type": "word",
        "word": "antfarm"
      },
      "type": "context"
    }
  },
  [
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eCardinality constraints\n\u003c/p\u003e\u003c/div\u003e",
          "module": "NLP.Antfarm.Cardinality",
          "name": "Cardinality",
          "package": "antfarm",
          "source": "src/NLP-Antfarm-Cardinality.html",
          "type": "module"
        },
        "index": {
          "description": "Cardinality constraints",
          "hierarchy": "NLP Antfarm Cardinality",
          "module": "NLP.Antfarm.Cardinality",
          "name": "Cardinality",
          "package": "antfarm",
          "partial": "Cardinality",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/antfarm/docs/NLP-Antfarm-Cardinality.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.Antfarm.Cardinality",
          "name": "Constraint",
          "package": "antfarm",
          "source": "src/NLP-Antfarm-Cardinality.html#Constraint",
          "type": "data"
        },
        "index": {
          "hierarchy": "NLP Antfarm Cardinality",
          "module": "NLP.Antfarm.Cardinality",
          "name": "Constraint",
          "package": "antfarm",
          "partial": "Constraint",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/antfarm/docs/NLP-Antfarm-Cardinality.html#t:Constraint"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.Antfarm.Cardinality",
          "name": "AtLeast",
          "package": "antfarm",
          "signature": "AtLeast Int",
          "source": "src/NLP-Antfarm-Cardinality.html#Constraint",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP Antfarm Cardinality",
          "module": "NLP.Antfarm.Cardinality",
          "name": "AtLeast",
          "package": "antfarm",
          "partial": "At Least",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/antfarm/docs/NLP-Antfarm-Cardinality.html#v:AtLeast"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.Antfarm.Cardinality",
          "name": "AtMost",
          "package": "antfarm",
          "signature": "AtMost Int",
          "source": "src/NLP-Antfarm-Cardinality.html#Constraint",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP Antfarm Cardinality",
          "module": "NLP.Antfarm.Cardinality",
          "name": "AtMost",
          "package": "antfarm",
          "partial": "At Most",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/antfarm/docs/NLP-Antfarm-Cardinality.html#v:AtMost"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.Antfarm.Cardinality",
          "name": "Exactly",
          "package": "antfarm",
          "signature": "Exactly Int",
          "source": "src/NLP-Antfarm-Cardinality.html#Constraint",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP Antfarm Cardinality",
          "module": "NLP.Antfarm.Cardinality",
          "name": "Exactly",
          "package": "antfarm",
          "partial": "Exactly",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/antfarm/docs/NLP-Antfarm-Cardinality.html#v:Exactly"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.Antfarm.Cardinality",
          "name": "Unknown",
          "package": "antfarm",
          "signature": "Unknown Text",
          "source": "src/NLP-Antfarm-Cardinality.html#Constraint",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP Antfarm Cardinality",
          "module": "NLP.Antfarm.Cardinality",
          "name": "Unknown",
          "package": "antfarm",
          "partial": "Unknown",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/antfarm/docs/NLP-Antfarm-Cardinality.html#v:Unknown"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.Antfarm.Cardinality",
          "name": "lowerBound",
          "package": "antfarm",
          "signature": "Constraint -\u003e Maybe Int",
          "source": "src/NLP-Antfarm-Cardinality.html#lowerBound",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP Antfarm Cardinality",
          "module": "NLP.Antfarm.Cardinality",
          "name": "lowerBound",
          "normalized": "Constraint-\u003eMaybe Int",
          "package": "antfarm",
          "partial": "Bound",
          "signature": "Constraint-\u003eMaybe Int",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/antfarm/docs/NLP-Antfarm-Cardinality.html#v:lowerBound"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.Antfarm.Cardinality",
          "name": "unknown",
          "package": "antfarm",
          "signature": "Constraint -\u003e Maybe Text",
          "source": "src/NLP-Antfarm-Cardinality.html#unknown",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP Antfarm Cardinality",
          "module": "NLP.Antfarm.Cardinality",
          "name": "unknown",
          "normalized": "Constraint-\u003eMaybe Text",
          "package": "antfarm",
          "signature": "Constraint-\u003eMaybe Text",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/antfarm/docs/NLP-Antfarm-Cardinality.html#v:unknown"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.Antfarm.Cardinality",
          "name": "upperBound",
          "package": "antfarm",
          "signature": "Constraint -\u003e Maybe Int",
          "source": "src/NLP-Antfarm-Cardinality.html#upperBound",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP Antfarm Cardinality",
          "module": "NLP.Antfarm.Cardinality",
          "name": "upperBound",
          "normalized": "Constraint-\u003eMaybe Int",
          "package": "antfarm",
          "partial": "Bound",
          "signature": "Constraint-\u003eMaybe Int",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/antfarm/docs/NLP-Antfarm-Cardinality.html#v:upperBound"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eHelper functions for the antfarm demonstrator.  You probably don't want to\n import this module unless you're doing something amusing like making a web\n app out of the antfarm demonstrator.  But it could be useful to look at the\n source if you're making something using antfarm\n\u003c/p\u003e\u003c/div\u003e",
          "module": "NLP.Antfarm.Demo",
          "name": "Demo",
          "package": "antfarm",
          "source": "src/NLP-Antfarm-Demo.html",
          "type": "module"
        },
        "index": {
          "description": "Helper functions for the antfarm demonstrator You probably don want to import this module unless you re doing something amusing like making web app out of the antfarm demonstrator But it could be useful to look at the source if you re making something using antfarm",
          "hierarchy": "NLP Antfarm Demo",
          "module": "NLP.Antfarm.Demo",
          "name": "Demo",
          "package": "antfarm",
          "partial": "Demo",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/antfarm/docs/NLP-Antfarm-Demo.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.Antfarm.Demo",
          "name": "Constr",
          "package": "antfarm",
          "source": "src/NLP-Antfarm-Demo.html#Constr",
          "type": "data"
        },
        "index": {
          "hierarchy": "NLP Antfarm Demo",
          "module": "NLP.Antfarm.Demo",
          "name": "Constr",
          "package": "antfarm",
          "partial": "Constr",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/antfarm/docs/NLP-Antfarm-Demo.html#t:Constr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.Antfarm.Demo",
          "name": "DemoElem",
          "package": "antfarm",
          "source": "src/NLP-Antfarm-Demo.html#DemoElem",
          "type": "data"
        },
        "index": {
          "hierarchy": "NLP Antfarm Demo",
          "module": "NLP.Antfarm.Demo",
          "name": "DemoElem",
          "package": "antfarm",
          "partial": "Demo Elem",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/antfarm/docs/NLP-Antfarm-Demo.html#t:DemoElem"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.Antfarm.Demo",
          "name": "Pretty",
          "package": "antfarm",
          "source": "src/NLP-Antfarm-Demo.html#Pretty",
          "type": "class"
        },
        "index": {
          "hierarchy": "NLP Antfarm Demo",
          "module": "NLP.Antfarm.Demo",
          "name": "Pretty",
          "package": "antfarm",
          "partial": "Pretty",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/antfarm/docs/NLP-Antfarm-Demo.html#t:Pretty"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.Antfarm.Demo",
          "name": "RefState",
          "package": "antfarm",
          "source": "src/NLP-Antfarm-Demo.html#RefState",
          "type": "type"
        },
        "index": {
          "hierarchy": "NLP Antfarm Demo",
          "module": "NLP.Antfarm.Demo",
          "name": "RefState",
          "package": "antfarm",
          "partial": "Ref State",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/antfarm/docs/NLP-Antfarm-Demo.html#t:RefState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.Antfarm.Demo",
          "name": "RefStateT",
          "package": "antfarm",
          "source": "src/NLP-Antfarm-Demo.html#RefStateT",
          "type": "type"
        },
        "index": {
          "hierarchy": "NLP Antfarm Demo",
          "module": "NLP.Antfarm.Demo",
          "name": "RefStateT",
          "package": "antfarm",
          "partial": "Ref State",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/antfarm/docs/NLP-Antfarm-Demo.html#t:RefStateT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.Antfarm.Demo",
          "name": "ClassWide",
          "package": "antfarm",
          "signature": "ClassWide",
          "source": "src/NLP-Antfarm-Demo.html#Constr",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP Antfarm Demo",
          "module": "NLP.Antfarm.Demo",
          "name": "ClassWide",
          "package": "antfarm",
          "partial": "Class Wide",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/antfarm/docs/NLP-Antfarm-Demo.html#v:ClassWide"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.Antfarm.Demo",
          "name": "Constr",
          "package": "antfarm",
          "signature": "Constr Constraint",
          "source": "src/NLP-Antfarm-Demo.html#Constr",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP Antfarm Demo",
          "module": "NLP.Antfarm.Demo",
          "name": "Constr",
          "package": "antfarm",
          "partial": "Constr",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/antfarm/docs/NLP-Antfarm-Demo.html#v:Constr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.Antfarm.Demo",
          "name": "DemoElem",
          "package": "antfarm",
          "signature": "DemoElem",
          "source": "src/NLP-Antfarm-Demo.html#DemoElem",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP Antfarm Demo",
          "module": "NLP.Antfarm.Demo",
          "name": "DemoElem",
          "package": "antfarm",
          "partial": "Demo Elem",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/antfarm/docs/NLP-Antfarm-Demo.html#v:DemoElem"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.Antfarm.Demo",
          "name": "Inst",
          "package": "antfarm",
          "signature": "Inst Text",
          "source": "src/NLP-Antfarm-Demo.html#Constr",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP Antfarm Demo",
          "module": "NLP.Antfarm.Demo",
          "name": "Inst",
          "package": "antfarm",
          "partial": "Inst",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/antfarm/docs/NLP-Antfarm-Demo.html#v:Inst"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.Antfarm.Demo",
          "name": "buckets",
          "package": "antfarm",
          "signature": "(a -\u003e b) -\u003e [a] -\u003e [(b, [a])]",
          "source": "src/NLP-Antfarm-Demo.html#buckets",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP Antfarm Demo",
          "module": "NLP.Antfarm.Demo",
          "name": "buckets",
          "normalized": "(a-\u003eb)-\u003e[a]-\u003e[(b,[a])]",
          "package": "antfarm",
          "signature": "(a-\u003eb)-\u003e[a]-\u003e[(b,[a])]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/antfarm/docs/NLP-Antfarm-Demo.html#v:buckets"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.Antfarm.Demo",
          "name": "dClass",
          "package": "antfarm",
          "signature": "Text",
          "source": "src/NLP-Antfarm-Demo.html#DemoElem",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP Antfarm Demo",
          "module": "NLP.Antfarm.Demo",
          "name": "dClass",
          "package": "antfarm",
          "partial": "Class",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/antfarm/docs/NLP-Antfarm-Demo.html#v:dClass"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.Antfarm.Demo",
          "name": "dConstr",
          "package": "antfarm",
          "signature": "Constr",
          "source": "src/NLP-Antfarm-Demo.html#DemoElem",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP Antfarm Demo",
          "module": "NLP.Antfarm.Demo",
          "name": "dConstr",
          "package": "antfarm",
          "partial": "Constr",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/antfarm/docs/NLP-Antfarm-Demo.html#v:dConstr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.Antfarm.Demo",
          "name": "decode",
          "package": "antfarm",
          "signature": "String -\u003e Either ParseError [[DiscourseUnit]]",
          "source": "src/NLP-Antfarm-Demo.html#decode",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP Antfarm Demo",
          "module": "NLP.Antfarm.Demo",
          "name": "decode",
          "normalized": "String-\u003eEither ParseError[[DiscourseUnit]]",
          "package": "antfarm",
          "signature": "String-\u003eEither ParseError[[DiscourseUnit]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/antfarm/docs/NLP-Antfarm-Demo.html#v:decode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.Antfarm.Demo",
          "name": "decodeRx",
          "package": "antfarm",
          "signature": "String -\u003e Either ParseError [DiscourseUnit]",
          "source": "src/NLP-Antfarm-Demo.html#decodeRx",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP Antfarm Demo",
          "module": "NLP.Antfarm.Demo",
          "name": "decodeRx",
          "normalized": "String-\u003eEither ParseError[DiscourseUnit]",
          "package": "antfarm",
          "partial": "Rx",
          "signature": "String-\u003eEither ParseError[DiscourseUnit]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/antfarm/docs/NLP-Antfarm-Demo.html#v:decodeRx"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.Antfarm.Demo",
          "name": "fromDemoElem",
          "package": "antfarm",
          "signature": "DemoElem -\u003e RefGroup",
          "source": "src/NLP-Antfarm-Demo.html#fromDemoElem",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP Antfarm Demo",
          "module": "NLP.Antfarm.Demo",
          "name": "fromDemoElem",
          "normalized": "DemoElem-\u003eRefGroup",
          "package": "antfarm",
          "partial": "Demo Elem",
          "signature": "DemoElem-\u003eRefGroup",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/antfarm/docs/NLP-Antfarm-Demo.html#v:fromDemoElem"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRegroup constraints and examples so that like are with like\n\u003c/p\u003e\u003cpre\u003e a1 b3 a4\n   ==\u003e [a1 a4] [b3]\n a1 b3 a4 (x \u003c= 3) b6\n   ==\u003e [a1 a4]([x \u003c= 3]) [b3 b6]\n a1 b3 a4 (x \u003c= 3) b6 (y \u003e= 8) a \u003c= 1 (x \u003e= 8)\n   ==\u003e [a1 a4]([x \u003c= 3 \u003e= 8]) [b3 b6]([y\u003e=8])\n\u003c/pre\u003e",
          "module": "NLP.Antfarm.Demo",
          "name": "fromDemoForest",
          "package": "antfarm",
          "signature": "[Tree DemoElem] -\u003e [DiscourseUnit]",
          "source": "src/NLP-Antfarm-Demo.html#fromDemoForest",
          "type": "function"
        },
        "index": {
          "description": "Regroup constraints and examples so that like are with like a1 b3 a4 a1 a4 b3 a1 b3 a4 b6 a1 a4 b3 b6 a1 b3 a4 b6 a1 a4 b3 b6",
          "hierarchy": "NLP Antfarm Demo",
          "module": "NLP.Antfarm.Demo",
          "name": "fromDemoForest",
          "normalized": "[Tree DemoElem]-\u003e[DiscourseUnit]",
          "package": "antfarm",
          "partial": "Demo Forest",
          "signature": "[Tree DemoElem]-\u003e[DiscourseUnit]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/antfarm/docs/NLP-Antfarm-Demo.html#v:fromDemoForest"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.Antfarm.Demo",
          "name": "intercalateRx",
          "package": "antfarm",
          "signature": "[Text] -\u003e Text",
          "source": "src/NLP-Antfarm-Demo.html#intercalateRx",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP Antfarm Demo",
          "module": "NLP.Antfarm.Demo",
          "name": "intercalateRx",
          "normalized": "[Text]-\u003eText",
          "package": "antfarm",
          "partial": "Rx",
          "signature": "[Text]-\u003eText",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/antfarm/docs/NLP-Antfarm-Demo.html#v:intercalateRx"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.Antfarm.Demo",
          "name": "isClassWide",
          "package": "antfarm",
          "signature": "Text -\u003e Bool",
          "source": "src/NLP-Antfarm-Demo.html#isClassWide",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP Antfarm Demo",
          "module": "NLP.Antfarm.Demo",
          "name": "isClassWide",
          "normalized": "Text-\u003eBool",
          "package": "antfarm",
          "partial": "Class Wide",
          "signature": "Text-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/antfarm/docs/NLP-Antfarm-Demo.html#v:isClassWide"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.Antfarm.Demo",
          "name": "itemToClass",
          "package": "antfarm",
          "signature": "Text -\u003e Text",
          "source": "src/NLP-Antfarm-Demo.html#itemToClass",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP Antfarm Demo",
          "module": "NLP.Antfarm.Demo",
          "name": "itemToClass",
          "normalized": "Text-\u003eText",
          "package": "antfarm",
          "partial": "To Class",
          "signature": "Text-\u003eText",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/antfarm/docs/NLP-Antfarm-Demo.html#v:itemToClass"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.Antfarm.Demo",
          "name": "lexMap",
          "package": "antfarm",
          "signature": "[(Text, Text)]",
          "source": "src/NLP-Antfarm-Demo.html#lexMap",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP Antfarm Demo",
          "module": "NLP.Antfarm.Demo",
          "name": "lexMap",
          "normalized": "[(Text,Text)]",
          "package": "antfarm",
          "partial": "Map",
          "signature": "[(Text,Text)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/antfarm/docs/NLP-Antfarm-Demo.html#v:lexMap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.Antfarm.Demo",
          "name": "mergeGroups",
          "package": "antfarm",
          "signature": "[RefGroup] -\u003e RefGroup",
          "source": "src/NLP-Antfarm-Demo.html#mergeGroups",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP Antfarm Demo",
          "module": "NLP.Antfarm.Demo",
          "name": "mergeGroups",
          "normalized": "[RefGroup]-\u003eRefGroup",
          "package": "antfarm",
          "partial": "Groups",
          "signature": "[RefGroup]-\u003eRefGroup",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/antfarm/docs/NLP-Antfarm-Demo.html#v:mergeGroups"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.Antfarm.Demo",
          "name": "nextRx",
          "package": "antfarm",
          "signature": "[DiscourseUnit] -\u003e RefStateT m Text",
          "source": "src/NLP-Antfarm-Demo.html#nextRx",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP Antfarm Demo",
          "module": "NLP.Antfarm.Demo",
          "name": "nextRx",
          "normalized": "[DiscourseUnit]-\u003eRefStateT a Text",
          "package": "antfarm",
          "partial": "Rx",
          "signature": "[DiscourseUnit]-\u003eRefStateT m Text",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/antfarm/docs/NLP-Antfarm-Demo.html#v:nextRx"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.Antfarm.Demo",
          "name": "onSubTrees",
          "package": "antfarm",
          "signature": "(Tree a -\u003e b) -\u003e Tree a -\u003e Tree b",
          "source": "src/NLP-Antfarm-Demo.html#onSubTrees",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP Antfarm Demo",
          "module": "NLP.Antfarm.Demo",
          "name": "onSubTrees",
          "normalized": "(Tree a-\u003eb)-\u003eTree a-\u003eTree b",
          "package": "antfarm",
          "partial": "Sub Trees",
          "signature": "(Tree a-\u003eb)-\u003eTree a-\u003eTree b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/antfarm/docs/NLP-Antfarm-Demo.html#v:onSubTrees"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.Antfarm.Demo",
          "name": "onWords",
          "package": "antfarm",
          "signature": "(Text -\u003e Maybe Text) -\u003e Text -\u003e Text",
          "source": "src/NLP-Antfarm-Demo.html#onWords",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP Antfarm Demo",
          "module": "NLP.Antfarm.Demo",
          "name": "onWords",
          "normalized": "(Text-\u003eMaybe Text)-\u003eText-\u003eText",
          "package": "antfarm",
          "partial": "Words",
          "signature": "(Text-\u003eMaybe Text)-\u003eText-\u003eText",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/antfarm/docs/NLP-Antfarm-Demo.html#v:onWords"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.Antfarm.Demo",
          "name": "opTable",
          "package": "antfarm",
          "signature": "[(Int -\u003e Constraint, [Text])]",
          "source": "src/NLP-Antfarm-Demo.html#opTable",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP Antfarm Demo",
          "module": "NLP.Antfarm.Demo",
          "name": "opTable",
          "normalized": "[(Int-\u003eConstraint,[Text])]",
          "package": "antfarm",
          "partial": "Table",
          "signature": "[(Int-\u003eConstraint,[Text])]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/antfarm/docs/NLP-Antfarm-Demo.html#v:opTable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.Antfarm.Demo",
          "name": "pConstr",
          "package": "antfarm",
          "signature": "Parser Constraint",
          "source": "src/NLP-Antfarm-Demo.html#pConstr",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP Antfarm Demo",
          "module": "NLP.Antfarm.Demo",
          "name": "pConstr",
          "package": "antfarm",
          "partial": "Constr",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/antfarm/docs/NLP-Antfarm-Demo.html#v:pConstr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.Antfarm.Demo",
          "name": "pDemoElem",
          "package": "antfarm",
          "signature": "Parser DemoElem",
          "source": "src/NLP-Antfarm-Demo.html#pDemoElem",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP Antfarm Demo",
          "module": "NLP.Antfarm.Demo",
          "name": "pDemoElem",
          "package": "antfarm",
          "partial": "Demo Elem",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/antfarm/docs/NLP-Antfarm-Demo.html#v:pDemoElem"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.Antfarm.Demo",
          "name": "pDemoElemForest",
          "package": "antfarm",
          "signature": "Parser [Tree DemoElem]",
          "source": "src/NLP-Antfarm-Demo.html#pDemoElemForest",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP Antfarm Demo",
          "module": "NLP.Antfarm.Demo",
          "name": "pDemoElemForest",
          "normalized": "Parser[Tree DemoElem]",
          "package": "antfarm",
          "partial": "Demo Elem Forest",
          "signature": "Parser[Tree DemoElem]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/antfarm/docs/NLP-Antfarm-Demo.html#v:pDemoElemForest"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.Antfarm.Demo",
          "name": "pDemoElemTree",
          "package": "antfarm",
          "signature": "Parser (Tree DemoElem)",
          "source": "src/NLP-Antfarm-Demo.html#pDemoElemTree",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP Antfarm Demo",
          "module": "NLP.Antfarm.Demo",
          "name": "pDemoElemTree",
          "package": "antfarm",
          "partial": "Demo Elem Tree",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/antfarm/docs/NLP-Antfarm-Demo.html#v:pDemoElemTree"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.Antfarm.Demo",
          "name": "pFilled",
          "package": "antfarm",
          "signature": "Parser a -\u003e Parser a",
          "source": "src/NLP-Antfarm-Demo.html#pFilled",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP Antfarm Demo",
          "module": "NLP.Antfarm.Demo",
          "name": "pFilled",
          "normalized": "Parser a-\u003eParser a",
          "package": "antfarm",
          "partial": "Filled",
          "signature": "Parser a-\u003eParser a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/antfarm/docs/NLP-Antfarm-Demo.html#v:pFilled"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.Antfarm.Demo",
          "name": "pLexeme",
          "package": "antfarm",
          "signature": "Parser Text",
          "source": "src/NLP-Antfarm-Demo.html#pLexeme",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP Antfarm Demo",
          "module": "NLP.Antfarm.Demo",
          "name": "pLexeme",
          "package": "antfarm",
          "partial": "Lexeme",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/antfarm/docs/NLP-Antfarm-Demo.html#v:pLexeme"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.Antfarm.Demo",
          "name": "pNatural",
          "package": "antfarm",
          "signature": "Parser Int",
          "source": "src/NLP-Antfarm-Demo.html#pNatural",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP Antfarm Demo",
          "module": "NLP.Antfarm.Demo",
          "name": "pNatural",
          "package": "antfarm",
          "partial": "Natural",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/antfarm/docs/NLP-Antfarm-Demo.html#v:pNatural"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.Antfarm.Demo",
          "name": "pOp",
          "package": "antfarm",
          "signature": "Parser Text",
          "source": "src/NLP-Antfarm-Demo.html#pOp",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP Antfarm Demo",
          "module": "NLP.Antfarm.Demo",
          "name": "pOp",
          "package": "antfarm",
          "partial": "Op",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/antfarm/docs/NLP-Antfarm-Demo.html#v:pOp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.Antfarm.Demo",
          "name": "pSentence",
          "package": "antfarm",
          "signature": "Parser [[Tree DemoElem]]",
          "source": "src/NLP-Antfarm-Demo.html#pSentence",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP Antfarm Demo",
          "module": "NLP.Antfarm.Demo",
          "name": "pSentence",
          "normalized": "Parser[[Tree DemoElem]]",
          "package": "antfarm",
          "partial": "Sentence",
          "signature": "Parser[[Tree DemoElem]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/antfarm/docs/NLP-Antfarm-Demo.html#v:pSentence"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.Antfarm.Demo",
          "name": "parens",
          "package": "antfarm",
          "signature": "Text -\u003e Text",
          "source": "src/NLP-Antfarm-Demo.html#parens",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP Antfarm Demo",
          "module": "NLP.Antfarm.Demo",
          "name": "parens",
          "normalized": "Text-\u003eText",
          "package": "antfarm",
          "signature": "Text-\u003eText",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/antfarm/docs/NLP-Antfarm-Demo.html#v:parens"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.Antfarm.Demo",
          "name": "pretty",
          "package": "antfarm",
          "signature": "a -\u003e Text",
          "source": "src/NLP-Antfarm-Demo.html#pretty",
          "type": "method"
        },
        "index": {
          "hierarchy": "NLP Antfarm Demo",
          "module": "NLP.Antfarm.Demo",
          "name": "pretty",
          "normalized": "a-\u003eText",
          "package": "antfarm",
          "signature": "a-\u003eText",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/antfarm/docs/NLP-Antfarm-Demo.html#v:pretty"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.Antfarm.Demo",
          "name": "prettyForest",
          "package": "antfarm",
          "signature": "[Tree a] -\u003e Text",
          "source": "src/NLP-Antfarm-Demo.html#prettyForest",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP Antfarm Demo",
          "module": "NLP.Antfarm.Demo",
          "name": "prettyForest",
          "normalized": "[Tree a]-\u003eText",
          "package": "antfarm",
          "partial": "Forest",
          "signature": "[Tree a]-\u003eText",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/antfarm/docs/NLP-Antfarm-Demo.html#v:prettyForest"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.Antfarm.Demo",
          "name": "prettyTree",
          "package": "antfarm",
          "signature": "Tree a -\u003e Text",
          "source": "src/NLP-Antfarm-Demo.html#prettyTree",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP Antfarm Demo",
          "module": "NLP.Antfarm.Demo",
          "name": "prettyTree",
          "normalized": "Tree a-\u003eText",
          "package": "antfarm",
          "partial": "Tree",
          "signature": "Tree a-\u003eText",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/antfarm/docs/NLP-Antfarm-Demo.html#v:prettyTree"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.Antfarm.Demo",
          "name": "squares",
          "package": "antfarm",
          "signature": "Text -\u003e Text",
          "source": "src/NLP-Antfarm-Demo.html#squares",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP Antfarm Demo",
          "module": "NLP.Antfarm.Demo",
          "name": "squares",
          "normalized": "Text-\u003eText",
          "package": "antfarm",
          "signature": "Text-\u003eText",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/antfarm/docs/NLP-Antfarm-Demo.html#v:squares"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.Antfarm.Demo",
          "name": "stripNonClassStuff",
          "package": "antfarm",
          "signature": "Text -\u003e Text",
          "source": "src/NLP-Antfarm-Demo.html#stripNonClassStuff",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP Antfarm Demo",
          "module": "NLP.Antfarm.Demo",
          "name": "stripNonClassStuff",
          "normalized": "Text-\u003eText",
          "package": "antfarm",
          "partial": "Non Class Stuff",
          "signature": "Text-\u003eText",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/antfarm/docs/NLP-Antfarm-Demo.html#v:stripNonClassStuff"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.Antfarm.Demo",
          "name": "toSubRxInput",
          "package": "antfarm",
          "signature": "DiscourseUnit -\u003e Tree SubRxInput",
          "source": "src/NLP-Antfarm-Demo.html#toSubRxInput",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP Antfarm Demo",
          "module": "NLP.Antfarm.Demo",
          "name": "toSubRxInput",
          "normalized": "DiscourseUnit-\u003eTree SubRxInput",
          "package": "antfarm",
          "partial": "Sub Rx Input",
          "signature": "DiscourseUnit-\u003eTree SubRxInput",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/antfarm/docs/NLP-Antfarm-Demo.html#v:toSubRxInput"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eFunctions to realise antfarm output in English.\n\u003c/p\u003e\u003cp\u003eWe're not under any illusions that antfarm will work well for\n languages other than English, but it could still be useful to\n try anyway.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "NLP.Antfarm.English",
          "name": "English",
          "package": "antfarm",
          "source": "src/NLP-Antfarm-English.html",
          "type": "module"
        },
        "index": {
          "description": "Functions to realise antfarm output in English We re not under any illusions that antfarm will work well for languages other than English but it could still be useful to try anyway",
          "hierarchy": "NLP Antfarm English",
          "module": "NLP.Antfarm.English",
          "name": "English",
          "package": "antfarm",
          "partial": "English",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/antfarm/docs/NLP-Antfarm-English.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.Antfarm.English",
          "name": "englishDiscriminator",
          "package": "antfarm",
          "signature": "SingPlu [Text]-\u003e Discriminator-\u003e [Text]",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP Antfarm English",
          "module": "NLP.Antfarm.English",
          "name": "englishDiscriminator",
          "normalized": "SingPlu[Text]-\u003eDiscriminator-\u003e[Text]",
          "package": "antfarm",
          "partial": "Discriminator",
          "signature": "SingPlu[Text]-\u003eDiscriminator-\u003e[Text]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/antfarm/docs/NLP-Antfarm-English.html#v:englishDiscriminator"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEnglish realisation for a referring expression\n\u003c/p\u003e",
          "module": "[\"NLP.Antfarm.English\",\"NLP.Antfarm\"]",
          "name": "englishRx",
          "package": "antfarm",
          "signature": "[Tree SubRx] -\u003e Text",
          "source": "src/NLP-Antfarm-English.html#englishRx",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/antfarm/docs/NLP-Antfarm-English.html#v:englishRx\",\"http://hackage.haskell.org/package/antfarm/docs/NLP-Antfarm.html#v:englishRx\"]"
        },
        "index": {
          "description": "English realisation for referring expression",
          "hierarchy": "NLP Antfarm English",
          "module": "NLP.Antfarm.English",
          "name": "englishRx",
          "normalized": "[Tree SubRx]-\u003eText",
          "package": "antfarm",
          "partial": "Rx",
          "signature": "[Tree SubRx]-\u003eText",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/antfarm/docs/NLP-Antfarm-English.html#v:englishRx"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEnglish realisation for a referring expression subunit (this can be useful\n   if you need special formatting between units, eg. bullet points)\n\u003c/p\u003e",
          "module": "[\"NLP.Antfarm.English\",\"NLP.Antfarm\"]",
          "name": "englishSubrx",
          "package": "antfarm",
          "signature": "SubRx -\u003e Text",
          "source": "src/NLP-Antfarm-English.html#englishSubrx",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/antfarm/docs/NLP-Antfarm-English.html#v:englishSubrx\",\"http://hackage.haskell.org/package/antfarm/docs/NLP-Antfarm.html#v:englishSubrx\"]"
        },
        "index": {
          "description": "English realisation for referring expression subunit this can be useful if you need special formatting between units eg bullet points",
          "hierarchy": "NLP Antfarm English",
          "module": "NLP.Antfarm.English",
          "name": "englishSubrx",
          "normalized": "SubRx-\u003eText",
          "package": "antfarm",
          "partial": "Subrx",
          "signature": "SubRx-\u003eText",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/antfarm/docs/NLP-Antfarm-English.html#v:englishSubrx"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eDiscourse history tracking\n\u003c/p\u003e\u003c/div\u003e",
          "module": "NLP.Antfarm.History",
          "name": "History",
          "package": "antfarm",
          "source": "src/NLP-Antfarm-History.html",
          "type": "module"
        },
        "index": {
          "description": "Discourse history tracking",
          "hierarchy": "NLP Antfarm History",
          "module": "NLP.Antfarm.History",
          "name": "History",
          "package": "antfarm",
          "partial": "History",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/antfarm/docs/NLP-Antfarm-History.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.Antfarm.History",
          "name": "RefCount",
          "package": "antfarm",
          "source": "src/NLP-Antfarm-History.html#RefCount",
          "type": "type"
        },
        "index": {
          "hierarchy": "NLP Antfarm History",
          "module": "NLP.Antfarm.History",
          "name": "RefCount",
          "package": "antfarm",
          "partial": "Ref Count",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/antfarm/docs/NLP-Antfarm-History.html#t:RefCount"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.Antfarm.History",
          "name": "RefHistory",
          "package": "antfarm",
          "source": "src/NLP-Antfarm-History.html#RefHistory",
          "type": "data"
        },
        "index": {
          "hierarchy": "NLP Antfarm History",
          "module": "NLP.Antfarm.History",
          "name": "RefHistory",
          "package": "antfarm",
          "partial": "Ref History",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/antfarm/docs/NLP-Antfarm-History.html#t:RefHistory"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"NLP.Antfarm.History\",\"NLP.Antfarm\"]",
          "name": "RefHistory",
          "package": "antfarm",
          "signature": "RefHistory",
          "source": "src/NLP-Antfarm-History.html#RefHistory",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/antfarm/docs/NLP-Antfarm-History.html#v:RefHistory\",\"http://hackage.haskell.org/package/antfarm/docs/NLP-Antfarm.html#v:RefHistory\"]"
        },
        "index": {
          "hierarchy": "NLP Antfarm History",
          "module": "NLP.Antfarm.History",
          "name": "RefHistory",
          "package": "antfarm",
          "partial": "Ref History",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/antfarm/docs/NLP-Antfarm-History.html#v:RefHistory"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTake note of the fact that these discourse units have been mentioned\n   (again) in the history.\n\u003c/p\u003e\u003cp\u003eYou probably want to realise the units first, then add them to the\n   history.\n\u003c/p\u003e",
          "module": "[\"NLP.Antfarm.History\",\"NLP.Antfarm\"]",
          "name": "addToHistory",
          "package": "antfarm",
          "signature": "[DiscourseUnit] -\u003e RefHistory -\u003e RefHistory",
          "source": "src/NLP-Antfarm-History.html#addToHistory",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/antfarm/docs/NLP-Antfarm-History.html#v:addToHistory\",\"http://hackage.haskell.org/package/antfarm/docs/NLP-Antfarm.html#v:addToHistory\"]"
        },
        "index": {
          "description": "Take note of the fact that these discourse units have been mentioned again in the history You probably want to realise the units first then add them to the history",
          "hierarchy": "NLP Antfarm History",
          "module": "NLP.Antfarm.History",
          "name": "addToHistory",
          "normalized": "[DiscourseUnit]-\u003eRefHistory-\u003eRefHistory",
          "package": "antfarm",
          "partial": "To History",
          "signature": "[DiscourseUnit]-\u003eRefHistory-\u003eRefHistory",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/antfarm/docs/NLP-Antfarm-History.html#v:addToHistory"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003edistractorGroups st k\u003c/code\u003e returns all the distractor groups for \u003ccode\u003ek\u003c/code\u003e\n   in the discourse history.\n\u003c/p\u003e\u003cp\u003eA distractor is defined (here) as something that has the the same class\n   as \u003ccode\u003ek\u003c/code\u003e but a different index.\n\u003c/p\u003e",
          "module": "NLP.Antfarm.History",
          "name": "distractorGroups",
          "package": "antfarm",
          "signature": "RefHistory -\u003e RefKey -\u003e [DiscourseUnit]",
          "source": "src/NLP-Antfarm-History.html#distractorGroups",
          "type": "function"
        },
        "index": {
          "description": "distractorGroups st returns all the distractor groups for in the discourse history distractor is defined here as something that has the the same class as but different index",
          "hierarchy": "NLP Antfarm History",
          "module": "NLP.Antfarm.History",
          "name": "distractorGroups",
          "normalized": "RefHistory-\u003eRefKey-\u003e[DiscourseUnit]",
          "package": "antfarm",
          "partial": "Groups",
          "signature": "RefHistory-\u003eRefKey-\u003e[DiscourseUnit]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/antfarm/docs/NLP-Antfarm-History.html#v:distractorGroups"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIndividuals mentioned in a discourse unit\n   (see \u003ccode\u003e\u003ca\u003erefSingleton\u003c/a\u003e\u003c/code\u003e)\n\u003c/p\u003e",
          "module": "NLP.Antfarm.History",
          "name": "duSingletons",
          "package": "antfarm",
          "signature": "DiscourseUnit -\u003e [RefKey]",
          "source": "src/NLP-Antfarm-History.html#duSingletons",
          "type": "function"
        },
        "index": {
          "description": "Individuals mentioned in discourse unit see refSingleton",
          "hierarchy": "NLP Antfarm History",
          "module": "NLP.Antfarm.History",
          "name": "duSingletons",
          "normalized": "DiscourseUnit-\u003e[RefKey]",
          "package": "antfarm",
          "partial": "Singletons",
          "signature": "DiscourseUnit-\u003e[RefKey]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/antfarm/docs/NLP-Antfarm-History.html#v:duSingletons"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDiscourse history without any objects\n\u003c/p\u003e",
          "module": "[\"NLP.Antfarm.History\",\"NLP.Antfarm\"]",
          "name": "emptyHistory",
          "package": "antfarm",
          "signature": "RefHistory",
          "source": "src/NLP-Antfarm-History.html#emptyHistory",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/antfarm/docs/NLP-Antfarm-History.html#v:emptyHistory\",\"http://hackage.haskell.org/package/antfarm/docs/NLP-Antfarm.html#v:emptyHistory\"]"
        },
        "index": {
          "description": "Discourse history without any objects",
          "hierarchy": "NLP Antfarm History",
          "module": "NLP.Antfarm.History",
          "name": "emptyHistory",
          "package": "antfarm",
          "partial": "History",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/antfarm/docs/NLP-Antfarm-History.html#v:emptyHistory"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.Antfarm.History",
          "name": "fst3",
          "package": "antfarm",
          "signature": "(a, b, c) -\u003e a",
          "source": "src/NLP-Antfarm-History.html#fst3",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP Antfarm History",
          "module": "NLP.Antfarm.History",
          "name": "fst3",
          "normalized": "(a,b,c)-\u003ea",
          "package": "antfarm",
          "signature": "(a,b,c)-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/antfarm/docs/NLP-Antfarm-History.html#v:fst3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003ehasDistractorGroup st k\u003c/code\u003e returns whether or not the discourse history\n   \u003ccode\u003est\u003c/code\u003e contains a group with distractors to \u003ccode\u003ek\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eSee \u003ccode\u003e\u003ca\u003edistractorGroups\u003c/a\u003e\u003c/code\u003e for more details\n\u003c/p\u003e",
          "module": "NLP.Antfarm.History",
          "name": "hasDistractorGroup",
          "package": "antfarm",
          "signature": "RefHistory -\u003e RefKey -\u003e Bool",
          "source": "src/NLP-Antfarm-History.html#hasDistractorGroup",
          "type": "function"
        },
        "index": {
          "description": "hasDistractorGroup st returns whether or not the discourse history st contains group with distractors to See distractorGroups for more details",
          "hierarchy": "NLP Antfarm History",
          "module": "NLP.Antfarm.History",
          "name": "hasDistractorGroup",
          "normalized": "RefHistory-\u003eRefKey-\u003eBool",
          "package": "antfarm",
          "partial": "Distractor Group",
          "signature": "RefHistory-\u003eRefKey-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/antfarm/docs/NLP-Antfarm-History.html#v:hasDistractorGroup"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003ehasSupersetMention st g\u003c/code\u003e returns whether or not the discourse history\n   contains a group that includes all members of \u003ccode\u003eg\u003c/code\u003e\n\u003c/p\u003e\u003cp\u003eNote that if a group has already occured in the discourse history, this\n   returns a True (ie. not a strict superset)\n\u003c/p\u003e",
          "module": "NLP.Antfarm.History",
          "name": "hasSupersetMention",
          "package": "antfarm",
          "signature": "RefHistory -\u003e DiscourseUnit -\u003e Bool",
          "source": "src/NLP-Antfarm-History.html#hasSupersetMention",
          "type": "function"
        },
        "index": {
          "description": "hasSupersetMention st returns whether or not the discourse history contains group that includes all members of Note that if group has already occured in the discourse history this returns True ie not strict superset",
          "hierarchy": "NLP Antfarm History",
          "module": "NLP.Antfarm.History",
          "name": "hasSupersetMention",
          "normalized": "RefHistory-\u003eDiscourseUnit-\u003eBool",
          "package": "antfarm",
          "partial": "Superset Mention",
          "signature": "RefHistory-\u003eDiscourseUnit-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/antfarm/docs/NLP-Antfarm-History.html#v:hasSupersetMention"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIs a subset of a previously mentioned group \u003ccode\u003eg\u003c/code\u003e where there are no\n distractors to \u003ccode\u003eg\u003c/code\u003e in the discourse history\n\u003c/p\u003e",
          "module": "NLP.Antfarm.History",
          "name": "hasTidyBackpointer",
          "package": "antfarm",
          "signature": "RefHistory -\u003e DiscourseUnit -\u003e Bool",
          "source": "src/NLP-Antfarm-History.html#hasTidyBackpointer",
          "type": "function"
        },
        "index": {
          "description": "Is subset of previously mentioned group where there are no distractors to in the discourse history",
          "hierarchy": "NLP Antfarm History",
          "module": "NLP.Antfarm.History",
          "name": "hasTidyBackpointer",
          "normalized": "RefHistory-\u003eDiscourseUnit-\u003eBool",
          "package": "antfarm",
          "partial": "Tidy Backpointer",
          "signature": "RefHistory-\u003eDiscourseUnit-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/antfarm/docs/NLP-Antfarm-History.html#v:hasTidyBackpointer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIs the class itself, not any individual entity within that class\n   ie. &#8220;ants&#8221; instead of &#8220;an ant&#8221; or &#8220;some ants&#8221;\n\u003c/p\u003e\u003cp\u003eBy convention, any group which containts no indices or constraints\n   is considered to be classwide.\n\u003c/p\u003e",
          "module": "NLP.Antfarm.History",
          "name": "isClasswide",
          "package": "antfarm",
          "signature": "RefGroup -\u003e Bool",
          "source": "src/NLP-Antfarm-History.html#isClasswide",
          "type": "function"
        },
        "index": {
          "description": "Is the class itself not any individual entity within that class ie ants instead of an ant or some ants By convention any group which containts no indices or constraints is considered to be classwide",
          "hierarchy": "NLP Antfarm History",
          "module": "NLP.Antfarm.History",
          "name": "isClasswide",
          "normalized": "RefGroup-\u003eBool",
          "package": "antfarm",
          "partial": "Classwide",
          "signature": "RefGroup-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/antfarm/docs/NLP-Antfarm-History.html#v:isClasswide"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA \u003ccode\u003e\u003ca\u003eRefGroup\u003c/a\u003e\u003c/code\u003e is considered to refer exactly to its indices if it\n   has no bounds information or examples associated with it.\n\u003c/p\u003e",
          "module": "NLP.Antfarm.History",
          "name": "isExact",
          "package": "antfarm",
          "signature": "RefGroup -\u003e Bool",
          "source": "src/NLP-Antfarm-History.html#isExact",
          "type": "function"
        },
        "index": {
          "description": "RefGroup is considered to refer exactly to its indices if it has no bounds information or examples associated with it",
          "hierarchy": "NLP Antfarm History",
          "module": "NLP.Antfarm.History",
          "name": "isExact",
          "normalized": "RefGroup-\u003eBool",
          "package": "antfarm",
          "partial": "Exact",
          "signature": "RefGroup-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/antfarm/docs/NLP-Antfarm-History.html#v:isExact"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.Antfarm.History",
          "name": "isFirstMention",
          "package": "antfarm",
          "signature": "RefHistory -\u003e RefKey -\u003e Bool",
          "source": "src/NLP-Antfarm-History.html#isFirstMention",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP Antfarm History",
          "module": "NLP.Antfarm.History",
          "name": "isFirstMention",
          "normalized": "RefHistory-\u003eRefKey-\u003eBool",
          "package": "antfarm",
          "partial": "First Mention",
          "signature": "RefHistory-\u003eRefKey-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/antfarm/docs/NLP-Antfarm-History.html#v:isFirstMention"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eisTheOther st k\u003c/code\u003e returns whether or not there is a two-member group in\n   the discourse history which \u003ccode\u003ek\u003c/code\u003e is a member of such that the other\n   member has already been mentioned as a part of a singleton group.\n\u003c/p\u003e\u003cp\u003eThe idea is that if you have said \u003ca\u003eone of the X\u003c/a\u003e, you will want to say\n   \u003ca\u003ethe other X\u003c/a\u003e for the other member of that group\n\u003c/p\u003e",
          "module": "NLP.Antfarm.History",
          "name": "isTheOther",
          "package": "antfarm",
          "signature": "RefHistory -\u003e RefKey -\u003e Bool",
          "source": "src/NLP-Antfarm-History.html#isTheOther",
          "type": "function"
        },
        "index": {
          "description": "isTheOther st returns whether or not there is two-member group in the discourse history which is member of such that the other member has already been mentioned as part of singleton group The idea is that if you have said one of the you will want to say the other for the other member of that group",
          "hierarchy": "NLP Antfarm History",
          "module": "NLP.Antfarm.History",
          "name": "isTheOther",
          "normalized": "RefHistory-\u003eRefKey-\u003eBool",
          "package": "antfarm",
          "partial": "The Other",
          "signature": "RefHistory-\u003eRefKey-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/antfarm/docs/NLP-Antfarm-History.html#v:isTheOther"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003elastMention st k\u003c/code\u003e returns the number of times \u003ccode\u003ek\u003c/code\u003e has been mentioned\n\u003c/p\u003e",
          "module": "NLP.Antfarm.History",
          "name": "lastMention",
          "package": "antfarm",
          "signature": "RefHistory -\u003e RefKey -\u003e Int",
          "source": "src/NLP-Antfarm-History.html#lastMention",
          "type": "function"
        },
        "index": {
          "description": "lastMention st returns the number of times has been mentioned",
          "hierarchy": "NLP Antfarm History",
          "module": "NLP.Antfarm.History",
          "name": "lastMention",
          "normalized": "RefHistory-\u003eRefKey-\u003eInt",
          "package": "antfarm",
          "partial": "Mention",
          "signature": "RefHistory-\u003eRefKey-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/antfarm/docs/NLP-Antfarm-History.html#v:lastMention"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003elastMention st g\u003c/code\u003e returns the number of times the group \u003ccode\u003eg\u003c/code\u003e has been\n   mentioned\n\u003c/p\u003e",
          "module": "NLP.Antfarm.History",
          "name": "lastMentions",
          "package": "antfarm",
          "signature": "RefHistory -\u003e DiscourseUnit -\u003e Int",
          "source": "src/NLP-Antfarm-History.html#lastMentions",
          "type": "function"
        },
        "index": {
          "description": "lastMention st returns the number of times the group has been mentioned",
          "hierarchy": "NLP Antfarm History",
          "module": "NLP.Antfarm.History",
          "name": "lastMentions",
          "normalized": "RefHistory-\u003eDiscourseUnit-\u003eInt",
          "package": "antfarm",
          "partial": "Mentions",
          "signature": "RefHistory-\u003eDiscourseUnit-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/antfarm/docs/NLP-Antfarm-History.html#v:lastMentions"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIf it makes sense to refer to a key using an ordinal expression,\n   the order we should assign it (Nothing if we either can't sensibly\n   assign one, or the history does not give us enough information to\n   do so)\n\u003c/p\u003e",
          "module": "NLP.Antfarm.History",
          "name": "mentionOrder",
          "package": "antfarm",
          "signature": "RefHistory -\u003e RefKey -\u003e Maybe Int",
          "source": "src/NLP-Antfarm-History.html#mentionOrder",
          "type": "function"
        },
        "index": {
          "description": "If it makes sense to refer to key using an ordinal expression the order we should assign it Nothing if we either can sensibly assign one or the history does not give us enough information to do so",
          "hierarchy": "NLP Antfarm History",
          "module": "NLP.Antfarm.History",
          "name": "mentionOrder",
          "normalized": "RefHistory-\u003eRefKey-\u003eMaybe Int",
          "package": "antfarm",
          "partial": "Order",
          "signature": "RefHistory-\u003eRefKey-\u003eMaybe Int",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/antfarm/docs/NLP-Antfarm-History.html#v:mentionOrder"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.Antfarm.History",
          "name": "mkLeaf",
          "package": "antfarm",
          "signature": "a -\u003e Tree a",
          "source": "src/NLP-Antfarm-History.html#mkLeaf",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP Antfarm History",
          "module": "NLP.Antfarm.History",
          "name": "mkLeaf",
          "normalized": "a-\u003eTree a",
          "package": "antfarm",
          "partial": "Leaf",
          "signature": "a-\u003eTree a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/antfarm/docs/NLP-Antfarm-History.html#v:mkLeaf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA discourse unit that would refer to just an element\n\u003c/p\u003e",
          "module": "NLP.Antfarm.History",
          "name": "mkSingletonDu",
          "package": "antfarm",
          "signature": "RefKey -\u003e DiscourseUnit",
          "source": "src/NLP-Antfarm-History.html#mkSingletonDu",
          "type": "function"
        },
        "index": {
          "description": "discourse unit that would refer to just an element",
          "hierarchy": "NLP Antfarm History",
          "module": "NLP.Antfarm.History",
          "name": "mkSingletonDu",
          "normalized": "RefKey-\u003eDiscourseUnit",
          "package": "antfarm",
          "partial": "Singleton Du",
          "signature": "RefKey-\u003eDiscourseUnit",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/antfarm/docs/NLP-Antfarm-History.html#v:mkSingletonDu"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIf a RefGroup has explicit constraints, augment them with the\n   implicit constraints that arise from treating each item\n   as evidence of an at least constraint\n\u003c/p\u003e\u003cp\u003eIt's a good idea to run this once when building \u003ccode\u003e\u003ca\u003eRefGroup\u003c/a\u003e\u003c/code\u003es,\n   but you may also decide that this sort of behaviour is not\n   desirable for your application, so it's off by default\n\u003c/p\u003e",
          "module": "[\"NLP.Antfarm.History\",\"NLP.Antfarm\"]",
          "name": "noteImplicitBounds",
          "package": "antfarm",
          "signature": "RefGroup -\u003e RefGroup",
          "source": "src/NLP-Antfarm-History.html#noteImplicitBounds",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/antfarm/docs/NLP-Antfarm-History.html#v:noteImplicitBounds\",\"http://hackage.haskell.org/package/antfarm/docs/NLP-Antfarm.html#v:noteImplicitBounds\"]"
        },
        "index": {
          "description": "If RefGroup has explicit constraints augment them with the implicit constraints that arise from treating each item as evidence of an at least constraint It good idea to run this once when building RefGroup but you may also decide that this sort of behaviour is not desirable for your application so it off by default",
          "hierarchy": "NLP Antfarm History",
          "module": "NLP.Antfarm.History",
          "name": "noteImplicitBounds",
          "normalized": "RefGroup-\u003eRefGroup",
          "package": "antfarm",
          "partial": "Implicit Bounds",
          "signature": "RefGroup-\u003eRefGroup",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/antfarm/docs/NLP-Antfarm-History.html#v:noteImplicitBounds"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.Antfarm.History",
          "name": "plusRefCount",
          "package": "antfarm",
          "signature": "RefCount -\u003e RefCount -\u003e RefCount",
          "source": "src/NLP-Antfarm-History.html#plusRefCount",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP Antfarm History",
          "module": "NLP.Antfarm.History",
          "name": "plusRefCount",
          "normalized": "RefCount-\u003eRefCount-\u003eRefCount",
          "package": "antfarm",
          "partial": "Ref Count",
          "signature": "RefCount-\u003eRefCount-\u003eRefCount",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/antfarm/docs/NLP-Antfarm-History.html#v:plusRefCount"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA \u003ccode\u003e\u003ca\u003erefSingleton\u003c/a\u003e\u003c/code\u003e is an instance that appears by itself in a \u003ccode\u003e\u003ca\u003eRefGroup\u003c/a\u003e\u003c/code\u003e\n   without other items or constraints that imply that there could be other\n   items\n\u003c/p\u003e",
          "module": "NLP.Antfarm.History",
          "name": "refSingleton",
          "package": "antfarm",
          "signature": "RefGroup -\u003e Maybe RefKey",
          "source": "src/NLP-Antfarm-History.html#refSingleton",
          "type": "function"
        },
        "index": {
          "description": "refSingleton is an instance that appears by itself in RefGroup without other items or constraints that imply that there could be other items",
          "hierarchy": "NLP Antfarm History",
          "module": "NLP.Antfarm.History",
          "name": "refSingleton",
          "normalized": "RefGroup-\u003eMaybe RefKey",
          "package": "antfarm",
          "partial": "Singleton",
          "signature": "RefGroup-\u003eMaybe RefKey",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/antfarm/docs/NLP-Antfarm-History.html#v:refSingleton"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eHow many times a \u003ccode\u003e\u003ca\u003eDiscourseUnit\u003c/a\u003e\u003c/code\u003e has been mentioned\n\u003c/p\u003e",
          "module": "[\"NLP.Antfarm.History\",\"NLP.Antfarm\"]",
          "name": "rhCount",
          "package": "antfarm",
          "signature": "Map DiscourseUnit RefCount",
          "source": "src/NLP-Antfarm-History.html#RefHistory",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/antfarm/docs/NLP-Antfarm-History.html#v:rhCount\",\"http://hackage.haskell.org/package/antfarm/docs/NLP-Antfarm.html#v:rhCount\"]"
        },
        "index": {
          "description": "How many times DiscourseUnit has been mentioned",
          "hierarchy": "NLP Antfarm History",
          "module": "NLP.Antfarm.History",
          "name": "rhCount",
          "package": "antfarm",
          "partial": "Count",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/antfarm/docs/NLP-Antfarm-History.html#v:rhCount"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFor each class: an ordering of indices that reflects what\n   ordinal expression should be used for them (if at all)\n\u003c/p\u003e\u003cp\u003eSo \u003ccode\u003e[c8,c3,c4]\u003c/code\u003e means\n\u003c/p\u003e\u003cp\u003ec8: the first\n   c3: the second\n   c4: the third\n\u003c/p\u003e",
          "module": "[\"NLP.Antfarm.History\",\"NLP.Antfarm\"]",
          "name": "rhOrder",
          "package": "antfarm",
          "signature": "Map Text [Text]",
          "source": "src/NLP-Antfarm-History.html#RefHistory",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/antfarm/docs/NLP-Antfarm-History.html#v:rhOrder\",\"http://hackage.haskell.org/package/antfarm/docs/NLP-Antfarm.html#v:rhOrder\"]"
        },
        "index": {
          "description": "For each class an ordering of indices that reflects what ordinal expression should be used for them if at all So c8 c3 c4 means c8 the first c3 the second c4 the third",
          "hierarchy": "NLP Antfarm History",
          "module": "NLP.Antfarm.History",
          "name": "rhOrder",
          "normalized": "Map Text[Text]",
          "package": "antfarm",
          "partial": "Order",
          "signature": "Map Text[Text]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/antfarm/docs/NLP-Antfarm-History.html#v:rhOrder"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.Antfarm.History",
          "name": "snd3",
          "package": "antfarm",
          "signature": "(a, b, c) -\u003e b",
          "source": "src/NLP-Antfarm-History.html#snd3",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP Antfarm History",
          "module": "NLP.Antfarm.History",
          "name": "snd3",
          "normalized": "(a,b,c)-\u003eb",
          "package": "antfarm",
          "signature": "(a,b,c)-\u003eb",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/antfarm/docs/NLP-Antfarm-History.html#v:snd3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLike \u003ccode\u003e\u003ca\u003eflatten\u003c/a\u003e\u003c/code\u003e, but returns whole subtrees instead of\n   just nodes:\n\u003c/p\u003e\u003cpre\u003e a(b c(d e(f g)) h)\n b\n c(d e(f g))\n d\n e(f g)\n f\n g\n h\n\u003c/pre\u003e\u003cp\u003eInvariant: \u003ccode\u003emap rootLabel (subtrees x) == flatten x\u003c/code\u003e\n\u003c/p\u003e",
          "module": "NLP.Antfarm.History",
          "name": "subtrees",
          "package": "antfarm",
          "signature": "Tree a -\u003e [Tree a]",
          "source": "src/NLP-Antfarm-History.html#subtrees",
          "type": "function"
        },
        "index": {
          "description": "Like flatten but returns whole subtrees instead of just nodes Invariant map rootLabel subtrees flatten",
          "hierarchy": "NLP Antfarm History",
          "module": "NLP.Antfarm.History",
          "name": "subtrees",
          "normalized": "Tree a-\u003e[Tree a]",
          "package": "antfarm",
          "signature": "Tree a-\u003e[Tree a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/antfarm/docs/NLP-Antfarm-History.html#v:subtrees"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003esupersetMentions g st\u003c/code\u003e returns the portion of discourse history \u003ccode\u003est\u003c/code\u003e\n   in which all groups are supersets of \u003ccode\u003eg\u003c/code\u003e (inclusive, not strict super)\n\u003c/p\u003e",
          "module": "NLP.Antfarm.History",
          "name": "supersetMentions",
          "package": "antfarm",
          "signature": "DiscourseUnit -\u003e RefHistory -\u003e RefHistory",
          "source": "src/NLP-Antfarm-History.html#supersetMentions",
          "type": "function"
        },
        "index": {
          "description": "supersetMentions st returns the portion of discourse history st in which all groups are supersets of inclusive not strict super",
          "hierarchy": "NLP Antfarm History",
          "module": "NLP.Antfarm.History",
          "name": "supersetMentions",
          "normalized": "DiscourseUnit-\u003eRefHistory-\u003eRefHistory",
          "package": "antfarm",
          "partial": "Mentions",
          "signature": "DiscourseUnit-\u003eRefHistory-\u003eRefHistory",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/antfarm/docs/NLP-Antfarm-History.html#v:supersetMentions"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.Antfarm.History",
          "name": "thd3",
          "package": "antfarm",
          "signature": "(a, b, c) -\u003e c",
          "source": "src/NLP-Antfarm-History.html#thd3",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP Antfarm History",
          "module": "NLP.Antfarm.History",
          "name": "thd3",
          "normalized": "(a,b,c)-\u003ec",
          "package": "antfarm",
          "signature": "(a,b,c)-\u003ec",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/antfarm/docs/NLP-Antfarm-History.html#v:thd3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThe heart of the referring expression generation\n\u003c/p\u003e\u003c/div\u003e",
          "module": "NLP.Antfarm.Internal",
          "name": "Internal",
          "package": "antfarm",
          "source": "src/NLP-Antfarm-Internal.html",
          "type": "module"
        },
        "index": {
          "description": "The heart of the referring expression generation",
          "hierarchy": "NLP Antfarm Internal",
          "module": "NLP.Antfarm.Internal",
          "name": "Internal",
          "package": "antfarm",
          "partial": "Internal",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/antfarm/docs/NLP-Antfarm-Internal.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIf there are any unknown constraints, we pick the first one.\n   Otherwise, we generate an expression appropriate for the lower/upper bounds\n\u003c/p\u003e",
          "module": "NLP.Antfarm.Internal",
          "name": "boundsText",
          "package": "antfarm",
          "signature": "Bounds -\u003e Maybe BoundsExpr",
          "source": "src/NLP-Antfarm-Internal.html#boundsText",
          "type": "function"
        },
        "index": {
          "description": "If there are any unknown constraints we pick the first one Otherwise we generate an expression appropriate for the lower upper bounds",
          "hierarchy": "NLP Antfarm Internal",
          "module": "NLP.Antfarm.Internal",
          "name": "boundsText",
          "normalized": "Bounds-\u003eMaybe BoundsExpr",
          "package": "antfarm",
          "partial": "Text",
          "signature": "Bounds-\u003eMaybe BoundsExpr",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/antfarm/docs/NLP-Antfarm-Internal.html#v:boundsText"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eHelper for \u003ccode\u003efromConcept\u003c/code\u003e\n\u003c/p\u003e\u003cp\u003eA discriminator is what we call the optional bit of text that helps\n   you distinguish one set instances of a class from another, eg,\n   &#8220;the same&#8221; or &#8220;another three&#8221;, or simply &#8220;the&#8220;\n\u003c/p\u003e",
          "module": "NLP.Antfarm.Internal",
          "name": "discriminate",
          "package": "antfarm",
          "signature": "RefHistory-\u003e DiscourseUnit-\u003e Discriminator",
          "type": "function"
        },
        "index": {
          "description": "Helper for fromConcept discriminator is what we call the optional bit of text that helps you distinguish one set instances of class from another eg the same or another three or simply the",
          "hierarchy": "NLP Antfarm Internal",
          "module": "NLP.Antfarm.Internal",
          "name": "discriminate",
          "normalized": "RefHistory-\u003eDiscourseUnit-\u003eDiscriminator",
          "package": "antfarm",
          "signature": "RefHistory-\u003eDiscourseUnit-\u003eDiscriminator",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/antfarm/docs/NLP-Antfarm-Internal.html#v:discriminate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDecide how to realise a referring expression\n\u003c/p\u003e",
          "module": "[\"NLP.Antfarm.Internal\",\"NLP.Antfarm\"]",
          "name": "rx",
          "package": "antfarm",
          "signature": "RefHistory -\u003e [Tree SubRxInput] -\u003e [Tree SubRx]",
          "source": "src/NLP-Antfarm-Internal.html#rx",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/antfarm/docs/NLP-Antfarm-Internal.html#v:rx\",\"http://hackage.haskell.org/package/antfarm/docs/NLP-Antfarm.html#v:rx\"]"
        },
        "index": {
          "description": "Decide how to realise referring expression",
          "hierarchy": "NLP Antfarm Internal",
          "module": "NLP.Antfarm.Internal",
          "name": "rx",
          "normalized": "RefHistory-\u003e[Tree SubRxInput]-\u003e[Tree SubRx]",
          "package": "antfarm",
          "signature": "RefHistory-\u003e[Tree SubRxInput]-\u003e[Tree SubRx]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/antfarm/docs/NLP-Antfarm-Internal.html#v:rx"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDecide how to realise a single unit within a referring expression\n\u003c/p\u003e\u003cp\u003eKeep in mind that this is only for one \u003ccode\u003e\u003ca\u003eDiscourseUnit\u003c/a\u003e\u003c/code\u003e within a single rx.\n   An rx may involve multiple discourse units (eg. 3 cats and 1 dog)\n\u003c/p\u003e",
          "module": "[\"NLP.Antfarm.Internal\",\"NLP.Antfarm\"]",
          "name": "subrx",
          "package": "antfarm",
          "signature": "RefHistory -\u003e Tree SubRxInput -\u003e Tree SubRx",
          "source": "src/NLP-Antfarm-Internal.html#subrx",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/antfarm/docs/NLP-Antfarm-Internal.html#v:subrx\",\"http://hackage.haskell.org/package/antfarm/docs/NLP-Antfarm.html#v:subrx\"]"
        },
        "index": {
          "description": "Decide how to realise single unit within referring expression Keep in mind that this is only for one DiscourseUnit within single rx An rx may involve multiple discourse units eg cats and dog",
          "hierarchy": "NLP Antfarm Internal",
          "module": "NLP.Antfarm.Internal",
          "name": "subrx",
          "normalized": "RefHistory-\u003eTree SubRxInput-\u003eTree SubRx",
          "package": "antfarm",
          "signature": "RefHistory-\u003eTree SubRxInput-\u003eTree SubRx",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/antfarm/docs/NLP-Antfarm-Internal.html#v:subrx"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWhether a \u003ccode\u003e\u003ca\u003eDiscourseUnit\u003c/a\u003e\u003c/code\u003e should be considered *morally*\n   (semantically) singular or plural.  The actual form used may be\n   different (see \u003ccode\u003econceptNumber\u003c/code\u003e because of deeper issues that\n   override this).\n\u003c/p\u003e\u003cp\u003eConsider one of the *dogs*; here the rx number is \u003ccode\u003e\u003ca\u003eSingular\u003c/a\u003e\u003c/code\u003e\n   &#8212; one dog &#8212; but on the surface we use the \u003ccode\u003e\u003ca\u003ePlural\u003c/a\u003e\u003c/code\u003e (the NP\n   'the dogs' is itself plural).  This discrepency is partly due\n   to the hacky way we've written this.  A cleaner implementation\n   would recursively realise 'the dogs' as a separate expression\n   with its own number.\n\u003c/p\u003e",
          "module": "[\"NLP.Antfarm.Internal\",\"NLP.Antfarm\"]",
          "name": "subrxNumber",
          "package": "antfarm",
          "signature": "DiscourseUnit -\u003e FuzzyNumber",
          "source": "src/NLP-Antfarm-Internal.html#subrxNumber",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/antfarm/docs/NLP-Antfarm-Internal.html#v:subrxNumber\",\"http://hackage.haskell.org/package/antfarm/docs/NLP-Antfarm.html#v:subrxNumber\"]"
        },
        "index": {
          "description": "Whether DiscourseUnit should be considered morally semantically singular or plural The actual form used may be different see conceptNumber because of deeper issues that override this Consider one of the dogs here the rx number is Singular one dog but on the surface we use the Plural the NP the dogs is itself plural This discrepency is partly due to the hacky way we ve written this cleaner implementation would recursively realise the dogs as separate expression with its own number",
          "hierarchy": "NLP Antfarm Internal",
          "module": "NLP.Antfarm.Internal",
          "name": "subrxNumber",
          "normalized": "DiscourseUnit-\u003eFuzzyNumber",
          "package": "antfarm",
          "partial": "Number",
          "signature": "DiscourseUnit-\u003eFuzzyNumber",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/antfarm/docs/NLP-Antfarm-Internal.html#v:subrxNumber"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eHelper for \u003ccode\u003efromConcept\u003c/code\u003e\n\u003c/p\u003e\u003cp\u003eWhether the noun in a \u003ccode\u003e\u003ca\u003eDiscourseUnit\u003c/a\u003e\u003c/code\u003e should be realised as singular\n   or plural.  Note the difference between this and\n   \u003ccode\u003eactualNumber\u003c/code\u003e\n\u003c/p\u003e",
          "module": "NLP.Antfarm.Internal",
          "name": "surfaceNumber",
          "package": "antfarm",
          "signature": "RefHistory -\u003e DiscourseUnit -\u003e Number",
          "source": "src/NLP-Antfarm-Internal.html#surfaceNumber",
          "type": "function"
        },
        "index": {
          "description": "Helper for fromConcept Whether the noun in DiscourseUnit should be realised as singular or plural Note the difference between this and actualNumber",
          "hierarchy": "NLP Antfarm Internal",
          "module": "NLP.Antfarm.Internal",
          "name": "surfaceNumber",
          "normalized": "RefHistory-\u003eDiscourseUnit-\u003eNumber",
          "package": "antfarm",
          "partial": "Number",
          "signature": "RefHistory-\u003eDiscourseUnit-\u003eNumber",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/antfarm/docs/NLP-Antfarm-Internal.html#v:surfaceNumber"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.Antfarm.Refex",
          "name": "Refex",
          "package": "antfarm",
          "source": "src/NLP-Antfarm-Refex.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "NLP Antfarm Refex",
          "module": "NLP.Antfarm.Refex",
          "name": "Refex",
          "package": "antfarm",
          "partial": "Refex",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/antfarm/docs/NLP-Antfarm-Refex.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.Antfarm.Refex",
          "name": "Bounds",
          "package": "antfarm",
          "source": "src/NLP-Antfarm-Refex.html#Bounds",
          "type": "data"
        },
        "index": {
          "hierarchy": "NLP Antfarm Refex",
          "module": "NLP.Antfarm.Refex",
          "name": "Bounds",
          "package": "antfarm",
          "partial": "Bounds",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/antfarm/docs/NLP-Antfarm-Refex.html#t:Bounds"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.Antfarm.Refex",
          "name": "BoundsExpr",
          "package": "antfarm",
          "source": "src/NLP-Antfarm-Refex.html#BoundsExpr",
          "type": "data"
        },
        "index": {
          "hierarchy": "NLP Antfarm Refex",
          "module": "NLP.Antfarm.Refex",
          "name": "BoundsExpr",
          "package": "antfarm",
          "partial": "Bounds Expr",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/antfarm/docs/NLP-Antfarm-Refex.html#t:BoundsExpr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA discourse unit includes all instances and constraints needed\n   to uniquely identify it. (see note discourse tree)\n\u003c/p\u003e\u003cp\u003eIn the current implementation, a referring expression may contain\n   more than one discourse unit.  So in a referring expression &#8220;three cats\n   and at most two dogs (a poodle and a labrador)&#8221;, the &#8220;at most two dogs\n   (a poodle and a labrador)&#8221; and &#8220;three cats&#8221; would each correspond to\n   different \u003ccode\u003e\u003ca\u003eDiscourseUnit\u003c/a\u003e\u003c/code\u003es\n\u003c/p\u003e",
          "module": "NLP.Antfarm.Refex",
          "name": "DiscourseUnit",
          "package": "antfarm",
          "source": "src/NLP-Antfarm-Refex.html#DiscourseUnit",
          "type": "type"
        },
        "index": {
          "description": "discourse unit includes all instances and constraints needed to uniquely identify it see note discourse tree In the current implementation referring expression may contain more than one discourse unit So in referring expression three cats and at most two dogs poodle and labrador the at most two dogs poodle and labrador and three cats would each correspond to different DiscourseUnit",
          "hierarchy": "NLP Antfarm Refex",
          "module": "NLP.Antfarm.Refex",
          "name": "DiscourseUnit",
          "package": "antfarm",
          "partial": "Discourse Unit",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/antfarm/docs/NLP-Antfarm-Refex.html#t:DiscourseUnit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSomewhat abstract representation of subrx discriminators\n   (but in reality just based on English)\n\u003c/p\u003e\u003cp\u003eA discriminator is what we call the optional bit of text that helps\n   you distinguish one set instances of a class from another, eg,\n   &#8220;the same&#8221; or &#8220;another three&#8221;, or simply &#8220;the&#8220;.  This isn't a\n   technical term as far as I'm aware, just a made-up convenience word\n\u003c/p\u003e",
          "module": "NLP.Antfarm.Refex",
          "name": "Discriminator",
          "package": "antfarm",
          "source": "src/NLP-Antfarm-Refex.html#Discriminator",
          "type": "data"
        },
        "index": {
          "description": "Somewhat abstract representation of subrx discriminators but in reality just based on English discriminator is what we call the optional bit of text that helps you distinguish one set instances of class from another eg the same or another three or simply the This isn technical term as far as aware just made-up convenience word",
          "hierarchy": "NLP Antfarm Refex",
          "module": "NLP.Antfarm.Refex",
          "name": "Discriminator",
          "package": "antfarm",
          "partial": "Discriminator",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/antfarm/docs/NLP-Antfarm-Refex.html#t:Discriminator"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFuzzy number is a variant on \u003ccode\u003e\u003ca\u003eNumber\u003c/a\u003e\u003c/code\u003e that allows us the option\n   of overriding what would otherwise be singular agreement\n\u003c/p\u003e\u003cp\u003eIf you don't need to, or have no idea why somebody would even want\n   to do such a thing, just \u003ccode\u003e\u003ca\u003edefuzz\u003c/a\u003e\u003c/code\u003e it\n\u003c/p\u003e",
          "module": "NLP.Antfarm.Refex",
          "name": "FuzzyNumber",
          "package": "antfarm",
          "source": "src/NLP-Antfarm-Refex.html#FuzzyNumber",
          "type": "data"
        },
        "index": {
          "description": "Fuzzy number is variant on Number that allows us the option of overriding what would otherwise be singular agreement If you don need to or have no idea why somebody would even want to do such thing just defuzz it",
          "hierarchy": "NLP Antfarm Refex",
          "module": "NLP.Antfarm.Refex",
          "name": "FuzzyNumber",
          "package": "antfarm",
          "partial": "Fuzzy Number",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/antfarm/docs/NLP-Antfarm-Refex.html#t:FuzzyNumber"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA sub-unit in a referring expression, instances of and/or constraints\n   over class.  So in a referring expression &#8220;three cats and at most two\n   dogs&#8221;, the &#8220;at most two dogs&#8221; and &#8220;three cats&#8221; would each be \u003ccode\u003e\u003ca\u003eRefGroup\u003c/a\u003e\u003c/code\u003es\n\u003c/p\u003e",
          "module": "NLP.Antfarm.Refex",
          "name": "RefGroup",
          "package": "antfarm",
          "source": "src/NLP-Antfarm-Refex.html#RefGroup",
          "type": "data"
        },
        "index": {
          "description": "sub-unit in referring expression instances of and or constraints over class So in referring expression three cats and at most two dogs the at most two dogs and three cats would each be RefGroup",
          "hierarchy": "NLP Antfarm Refex",
          "module": "NLP.Antfarm.Refex",
          "name": "RefGroup",
          "package": "antfarm",
          "partial": "Ref Group",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/antfarm/docs/NLP-Antfarm-Refex.html#t:RefGroup"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA unique object\n\u003c/p\u003e",
          "module": "NLP.Antfarm.Refex",
          "name": "RefKey",
          "package": "antfarm",
          "source": "src/NLP-Antfarm-Refex.html#RefKey",
          "type": "type"
        },
        "index": {
          "description": "unique object",
          "hierarchy": "NLP Antfarm Refex",
          "module": "NLP.Antfarm.Refex",
          "name": "RefKey",
          "package": "antfarm",
          "partial": "Ref Key",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/antfarm/docs/NLP-Antfarm-Refex.html#t:RefKey"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA referring expression\n\u003c/p\u003e",
          "module": "NLP.Antfarm.Refex",
          "name": "Rx",
          "package": "antfarm",
          "source": "src/NLP-Antfarm-Refex.html#Rx",
          "type": "type"
        },
        "index": {
          "description": "referring expression",
          "hierarchy": "NLP Antfarm Refex",
          "module": "NLP.Antfarm.Refex",
          "name": "Rx",
          "package": "antfarm",
          "partial": "Rx",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/antfarm/docs/NLP-Antfarm-Refex.html#t:Rx"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA single referring expression has subunits, each of which\n   potentially having examples\n\u003c/p\u003e",
          "module": "NLP.Antfarm.Refex",
          "name": "RxInput",
          "package": "antfarm",
          "source": "src/NLP-Antfarm-Refex.html#RxInput",
          "type": "type"
        },
        "index": {
          "description": "single referring expression has subunits each of which potentially having examples",
          "hierarchy": "NLP Antfarm Refex",
          "module": "NLP.Antfarm.Refex",
          "name": "RxInput",
          "package": "antfarm",
          "partial": "Rx Input",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/antfarm/docs/NLP-Antfarm-Refex.html#t:RxInput"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eOutput for a subunit of a referring expression\n\u003c/p\u003e",
          "module": "NLP.Antfarm.Refex",
          "name": "SubRx",
          "package": "antfarm",
          "source": "src/NLP-Antfarm-Refex.html#SubRx",
          "type": "data"
        },
        "index": {
          "description": "Output for subunit of referring expression",
          "hierarchy": "NLP Antfarm Refex",
          "module": "NLP.Antfarm.Refex",
          "name": "SubRx",
          "package": "antfarm",
          "partial": "Sub Rx",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/antfarm/docs/NLP-Antfarm-Refex.html#t:SubRx"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInput needed to realise a subunit of a referring expression\n   A subunit corresponds to \u003ccode\u003e\u003ca\u003eRefGroup\u003c/a\u003e\u003c/code\u003e (but in practice,\n   we need the whole \u003ccode\u003e\u003ca\u003eDiscourseUnit\u003c/a\u003e\u003c/code\u003e, not just the \u003ccode\u003e\u003ca\u003eRefGroup\u003c/a\u003e\u003c/code\u003e\n   root)\n\u003c/p\u003e",
          "module": "NLP.Antfarm.Refex",
          "name": "SubRxInput",
          "package": "antfarm",
          "source": "src/NLP-Antfarm-Refex.html#SubRxInput",
          "type": "data"
        },
        "index": {
          "description": "Input needed to realise subunit of referring expression subunit corresponds to RefGroup but in practice we need the whole DiscourseUnit not just the RefGroup root",
          "hierarchy": "NLP Antfarm Refex",
          "module": "NLP.Antfarm.Refex",
          "name": "SubRxInput",
          "package": "antfarm",
          "partial": "Sub Rx Input",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/antfarm/docs/NLP-Antfarm-Refex.html#t:SubRxInput"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.Antfarm.Refex",
          "name": "Another",
          "package": "antfarm",
          "signature": "Another Int",
          "source": "src/NLP-Antfarm-Refex.html#Discriminator",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP Antfarm Refex",
          "module": "NLP.Antfarm.Refex",
          "name": "Another",
          "package": "antfarm",
          "partial": "Another",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/antfarm/docs/NLP-Antfarm-Refex.html#v:Another"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.Antfarm.Refex",
          "name": "Bounded",
          "package": "antfarm",
          "signature": "Bounded BoundsExpr",
          "source": "src/NLP-Antfarm-Refex.html#Discriminator",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP Antfarm Refex",
          "module": "NLP.Antfarm.Refex",
          "name": "Bounded",
          "package": "antfarm",
          "partial": "Bounded",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/antfarm/docs/NLP-Antfarm-Refex.html#v:Bounded"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.Antfarm.Refex",
          "name": "Bounds",
          "package": "antfarm",
          "signature": "Bounds",
          "source": "src/NLP-Antfarm-Refex.html#Bounds",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP Antfarm Refex",
          "module": "NLP.Antfarm.Refex",
          "name": "Bounds",
          "package": "antfarm",
          "partial": "Bounds",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/antfarm/docs/NLP-Antfarm-Refex.html#v:Bounds"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.Antfarm.Refex",
          "name": "CardinalOfThe",
          "package": "antfarm",
          "signature": "CardinalOfThe Int",
          "source": "src/NLP-Antfarm-Refex.html#Discriminator",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP Antfarm Refex",
          "module": "NLP.Antfarm.Refex",
          "name": "CardinalOfThe",
          "package": "antfarm",
          "partial": "Cardinal Of The",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/antfarm/docs/NLP-Antfarm-Refex.html#v:CardinalOfThe"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.Antfarm.Refex",
          "name": "FN_MaybeSingular",
          "package": "antfarm",
          "signature": "FN_MaybeSingular",
          "source": "src/NLP-Antfarm-Refex.html#FuzzyNumber",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP Antfarm Refex",
          "module": "NLP.Antfarm.Refex",
          "name": "FN_MaybeSingular",
          "package": "antfarm",
          "partial": "FN Maybe Singular",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/antfarm/docs/NLP-Antfarm-Refex.html#v:FN_MaybeSingular"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.Antfarm.Refex",
          "name": "FN_Plural",
          "package": "antfarm",
          "signature": "FN_Plural",
          "source": "src/NLP-Antfarm-Refex.html#FuzzyNumber",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP Antfarm Refex",
          "module": "NLP.Antfarm.Refex",
          "name": "FN_Plural",
          "package": "antfarm",
          "partial": "FN Plural",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/antfarm/docs/NLP-Antfarm-Refex.html#v:FN_Plural"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.Antfarm.Refex",
          "name": "FN_Singular",
          "package": "antfarm",
          "signature": "FN_Singular",
          "source": "src/NLP-Antfarm-Refex.html#FuzzyNumber",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP Antfarm Refex",
          "module": "NLP.Antfarm.Refex",
          "name": "FN_Singular",
          "package": "antfarm",
          "partial": "FN Singular",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/antfarm/docs/NLP-Antfarm-Refex.html#v:FN_Singular"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.Antfarm.Refex",
          "name": "NewOrdinal",
          "package": "antfarm",
          "signature": "NewOrdinal Int",
          "source": "src/NLP-Antfarm-Refex.html#Discriminator",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP Antfarm Refex",
          "module": "NLP.Antfarm.Refex",
          "name": "NewOrdinal",
          "package": "antfarm",
          "partial": "New Ordinal",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/antfarm/docs/NLP-Antfarm-Refex.html#v:NewOrdinal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.Antfarm.Refex",
          "name": "NilDiscriminator",
          "package": "antfarm",
          "signature": "NilDiscriminator",
          "source": "src/NLP-Antfarm-Refex.html#Discriminator",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP Antfarm Refex",
          "module": "NLP.Antfarm.Refex",
          "name": "NilDiscriminator",
          "package": "antfarm",
          "partial": "Nil Discriminator",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/antfarm/docs/NLP-Antfarm-Refex.html#v:NilDiscriminator"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.Antfarm.Refex",
          "name": "PlainCardinal",
          "package": "antfarm",
          "signature": "PlainCardinal Int",
          "source": "src/NLP-Antfarm-Refex.html#Discriminator",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP Antfarm Refex",
          "module": "NLP.Antfarm.Refex",
          "name": "PlainCardinal",
          "package": "antfarm",
          "partial": "Plain Cardinal",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/antfarm/docs/NLP-Antfarm-Refex.html#v:PlainCardinal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.Antfarm.Refex",
          "name": "RefGroup",
          "package": "antfarm",
          "signature": "RefGroup",
          "source": "src/NLP-Antfarm-Refex.html#RefGroup",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP Antfarm Refex",
          "module": "NLP.Antfarm.Refex",
          "name": "RefGroup",
          "package": "antfarm",
          "partial": "Ref Group",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/antfarm/docs/NLP-Antfarm-Refex.html#v:RefGroup"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.Antfarm.Refex",
          "name": "SayArbitrary",
          "package": "antfarm",
          "signature": "SayArbitrary Text",
          "source": "src/NLP-Antfarm-Refex.html#BoundsExpr",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP Antfarm Refex",
          "module": "NLP.Antfarm.Refex",
          "name": "SayArbitrary",
          "package": "antfarm",
          "partial": "Say Arbitrary",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/antfarm/docs/NLP-Antfarm-Refex.html#v:SayArbitrary"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.Antfarm.Refex",
          "name": "SayAtLeast",
          "package": "antfarm",
          "signature": "SayAtLeast Int",
          "source": "src/NLP-Antfarm-Refex.html#BoundsExpr",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP Antfarm Refex",
          "module": "NLP.Antfarm.Refex",
          "name": "SayAtLeast",
          "package": "antfarm",
          "partial": "Say At Least",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/antfarm/docs/NLP-Antfarm-Refex.html#v:SayAtLeast"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.Antfarm.Refex",
          "name": "SayAtMost",
          "package": "antfarm",
          "signature": "SayAtMost Int",
          "source": "src/NLP-Antfarm-Refex.html#BoundsExpr",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP Antfarm Refex",
          "module": "NLP.Antfarm.Refex",
          "name": "SayAtMost",
          "package": "antfarm",
          "partial": "Say At Most",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/antfarm/docs/NLP-Antfarm-Refex.html#v:SayAtMost"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.Antfarm.Refex",
          "name": "SayBetween",
          "package": "antfarm",
          "signature": "SayBetween Int Int",
          "source": "src/NLP-Antfarm-Refex.html#BoundsExpr",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP Antfarm Refex",
          "module": "NLP.Antfarm.Refex",
          "name": "SayBetween",
          "package": "antfarm",
          "partial": "Say Between",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/antfarm/docs/NLP-Antfarm-Refex.html#v:SayBetween"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.Antfarm.Refex",
          "name": "SayExactly",
          "package": "antfarm",
          "signature": "SayExactly Int",
          "source": "src/NLP-Antfarm-Refex.html#BoundsExpr",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP Antfarm Refex",
          "module": "NLP.Antfarm.Refex",
          "name": "SayExactly",
          "package": "antfarm",
          "partial": "Say Exactly",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/antfarm/docs/NLP-Antfarm-Refex.html#v:SayExactly"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.Antfarm.Refex",
          "name": "SubRx",
          "package": "antfarm",
          "signature": "SubRx",
          "source": "src/NLP-Antfarm-Refex.html#SubRx",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP Antfarm Refex",
          "module": "NLP.Antfarm.Refex",
          "name": "SubRx",
          "package": "antfarm",
          "partial": "Sub Rx",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/antfarm/docs/NLP-Antfarm-Refex.html#v:SubRx"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.Antfarm.Refex",
          "name": "SubRxInput",
          "package": "antfarm",
          "signature": "SubRxInput",
          "source": "src/NLP-Antfarm-Refex.html#SubRxInput",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP Antfarm Refex",
          "module": "NLP.Antfarm.Refex",
          "name": "SubRxInput",
          "package": "antfarm",
          "partial": "Sub Rx Input",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/antfarm/docs/NLP-Antfarm-Refex.html#v:SubRxInput"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.Antfarm.Refex",
          "name": "The",
          "package": "antfarm",
          "signature": "The",
          "source": "src/NLP-Antfarm-Refex.html#Discriminator",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP Antfarm Refex",
          "module": "NLP.Antfarm.Refex",
          "name": "The",
          "package": "antfarm",
          "partial": "The",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/antfarm/docs/NLP-Antfarm-Refex.html#v:The"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.Antfarm.Refex",
          "name": "TheOrdinal",
          "package": "antfarm",
          "signature": "TheOrdinal Int",
          "source": "src/NLP-Antfarm-Refex.html#Discriminator",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP Antfarm Refex",
          "module": "NLP.Antfarm.Refex",
          "name": "TheOrdinal",
          "package": "antfarm",
          "partial": "The Ordinal",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/antfarm/docs/NLP-Antfarm-Refex.html#v:TheOrdinal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.Antfarm.Refex",
          "name": "TheOther",
          "package": "antfarm",
          "signature": "TheOther",
          "source": "src/NLP-Antfarm-Refex.html#Discriminator",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP Antfarm Refex",
          "module": "NLP.Antfarm.Refex",
          "name": "TheOther",
          "package": "antfarm",
          "partial": "The Other",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/antfarm/docs/NLP-Antfarm-Refex.html#v:TheOther"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.Antfarm.Refex",
          "name": "TheSame",
          "package": "antfarm",
          "signature": "TheSame",
          "source": "src/NLP-Antfarm-Refex.html#Discriminator",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP Antfarm Refex",
          "module": "NLP.Antfarm.Refex",
          "name": "TheSame",
          "package": "antfarm",
          "partial": "The Same",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/antfarm/docs/NLP-Antfarm-Refex.html#v:TheSame"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003elower\n\u003c/p\u003e",
          "module": "NLP.Antfarm.Refex",
          "name": "bLower",
          "package": "antfarm",
          "signature": "Maybe Int",
          "source": "src/NLP-Antfarm-Refex.html#Bounds",
          "type": "function"
        },
        "index": {
          "description": "lower",
          "hierarchy": "NLP Antfarm Refex",
          "module": "NLP.Antfarm.Refex",
          "name": "bLower",
          "package": "antfarm",
          "partial": "Lower",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/antfarm/docs/NLP-Antfarm-Refex.html#v:bLower"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.Antfarm.Refex",
          "name": "bUnknown",
          "package": "antfarm",
          "signature": "[Text]",
          "source": "src/NLP-Antfarm-Refex.html#Bounds",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP Antfarm Refex",
          "module": "NLP.Antfarm.Refex",
          "name": "bUnknown",
          "normalized": "[Text]",
          "package": "antfarm",
          "partial": "Unknown",
          "signature": "[Text]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/antfarm/docs/NLP-Antfarm-Refex.html#v:bUnknown"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eupper\n\u003c/p\u003e",
          "module": "NLP.Antfarm.Refex",
          "name": "bUpper",
          "package": "antfarm",
          "signature": "Maybe Int",
          "source": "src/NLP-Antfarm-Refex.html#Bounds",
          "type": "function"
        },
        "index": {
          "description": "upper",
          "hierarchy": "NLP Antfarm Refex",
          "module": "NLP.Antfarm.Refex",
          "name": "bUpper",
          "package": "antfarm",
          "partial": "Upper",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/antfarm/docs/NLP-Antfarm-Refex.html#v:bUpper"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003edefuzz\u003c/code\u003e treats \u003ccode\u003e\u003ca\u003eFN_MaybeSingular\u003c/a\u003e\u003c/code\u003e as \u003ccode\u003e\u003ca\u003eSingular\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "NLP.Antfarm.Refex",
          "name": "defuzz",
          "package": "antfarm",
          "signature": "FuzzyNumber -\u003e Number",
          "source": "src/NLP-Antfarm-Refex.html#defuzz",
          "type": "function"
        },
        "index": {
          "description": "defuzz treats FN MaybeSingular as Singular",
          "hierarchy": "NLP Antfarm Refex",
          "module": "NLP.Antfarm.Refex",
          "name": "defuzz",
          "normalized": "FuzzyNumber-\u003eNumber",
          "package": "antfarm",
          "signature": "FuzzyNumber-\u003eNumber",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/antfarm/docs/NLP-Antfarm-Refex.html#v:defuzz"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.Antfarm.Refex",
          "name": "emptyBounds",
          "package": "antfarm",
          "signature": "Bounds",
          "source": "src/NLP-Antfarm-Refex.html#emptyBounds",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP Antfarm Refex",
          "module": "NLP.Antfarm.Refex",
          "name": "emptyBounds",
          "package": "antfarm",
          "partial": "Bounds",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/antfarm/docs/NLP-Antfarm-Refex.html#v:emptyBounds"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.Antfarm.Refex",
          "name": "explicitBounds",
          "package": "antfarm",
          "signature": "[Constraint] -\u003e Bounds",
          "source": "src/NLP-Antfarm-Refex.html#explicitBounds",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP Antfarm Refex",
          "module": "NLP.Antfarm.Refex",
          "name": "explicitBounds",
          "normalized": "[Constraint]-\u003eBounds",
          "package": "antfarm",
          "partial": "Bounds",
          "signature": "[Constraint]-\u003eBounds",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/antfarm/docs/NLP-Antfarm-Refex.html#v:explicitBounds"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWhen two \u003ccode\u003e\u003ca\u003eBounds\u003c/a\u003e\u003c/code\u003e are combined the result is narrower: the highest low\n   and the lowest high.\n\u003c/p\u003e\u003cp\u003eThe unknown bounds are not really defined.  We concatenate them, for\n   what it's worth, which is at least sensible when none or only one of\n   them is defined, but not ideal when both are\n\u003c/p\u003e",
          "module": "NLP.Antfarm.Refex",
          "name": "narrow",
          "package": "antfarm",
          "signature": "Bounds -\u003e Bounds -\u003e Bounds",
          "source": "src/NLP-Antfarm-Refex.html#narrow",
          "type": "function"
        },
        "index": {
          "description": "When two Bounds are combined the result is narrower the highest low and the lowest high The unknown bounds are not really defined We concatenate them for what it worth which is at least sensible when none or only one of them is defined but not ideal when both are",
          "hierarchy": "NLP Antfarm Refex",
          "module": "NLP.Antfarm.Refex",
          "name": "narrow",
          "normalized": "Bounds-\u003eBounds-\u003eBounds",
          "package": "antfarm",
          "signature": "Bounds-\u003eBounds-\u003eBounds",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/antfarm/docs/NLP-Antfarm-Refex.html#v:narrow"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.Antfarm.Refex",
          "name": "rgBounds",
          "package": "antfarm",
          "signature": "Bounds",
          "source": "src/NLP-Antfarm-Refex.html#RefGroup",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP Antfarm Refex",
          "module": "NLP.Antfarm.Refex",
          "name": "rgBounds",
          "package": "antfarm",
          "partial": "Bounds",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/antfarm/docs/NLP-Antfarm-Refex.html#v:rgBounds"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.Antfarm.Refex",
          "name": "rgClass",
          "package": "antfarm",
          "signature": "Text",
          "source": "src/NLP-Antfarm-Refex.html#RefGroup",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP Antfarm Refex",
          "module": "NLP.Antfarm.Refex",
          "name": "rgClass",
          "package": "antfarm",
          "partial": "Class",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/antfarm/docs/NLP-Antfarm-Refex.html#v:rgClass"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.Antfarm.Refex",
          "name": "rgIdxList",
          "package": "antfarm",
          "signature": "RefGroup -\u003e [Text]",
          "source": "src/NLP-Antfarm-Refex.html#rgIdxList",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP Antfarm Refex",
          "module": "NLP.Antfarm.Refex",
          "name": "rgIdxList",
          "normalized": "RefGroup-\u003e[Text]",
          "package": "antfarm",
          "partial": "Idx List",
          "signature": "RefGroup-\u003e[Text]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/antfarm/docs/NLP-Antfarm-Refex.html#v:rgIdxList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.Antfarm.Refex",
          "name": "rgIdxes",
          "package": "antfarm",
          "signature": "Set Text",
          "source": "src/NLP-Antfarm-Refex.html#RefGroup",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP Antfarm Refex",
          "module": "NLP.Antfarm.Refex",
          "name": "rgIdxes",
          "package": "antfarm",
          "partial": "Idxes",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/antfarm/docs/NLP-Antfarm-Refex.html#v:rgIdxes"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.Antfarm.Refex",
          "name": "srxDet",
          "package": "antfarm",
          "signature": "SingPlu [Text]",
          "source": "src/NLP-Antfarm-Refex.html#SubRx",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP Antfarm Refex",
          "module": "NLP.Antfarm.Refex",
          "name": "srxDet",
          "normalized": "SingPlu[Text]",
          "package": "antfarm",
          "partial": "Det",
          "signature": "SingPlu[Text]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/antfarm/docs/NLP-Antfarm-Refex.html#v:srxDet"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.Antfarm.Refex",
          "name": "srxDiscriminator",
          "package": "antfarm",
          "signature": "Discriminator",
          "source": "src/NLP-Antfarm-Refex.html#SubRx",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP Antfarm Refex",
          "module": "NLP.Antfarm.Refex",
          "name": "srxDiscriminator",
          "package": "antfarm",
          "partial": "Discriminator",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/antfarm/docs/NLP-Antfarm-Refex.html#v:srxDiscriminator"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003edeterminer (can be empty)\n\u003c/p\u003e",
          "module": "NLP.Antfarm.Refex",
          "name": "srxInpDet",
          "package": "antfarm",
          "signature": "SingPlu [Text]",
          "source": "src/NLP-Antfarm-Refex.html#SubRxInput",
          "type": "function"
        },
        "index": {
          "description": "determiner can be empty",
          "hierarchy": "NLP Antfarm Refex",
          "module": "NLP.Antfarm.Refex",
          "name": "srxInpDet",
          "normalized": "SingPlu[Text]",
          "package": "antfarm",
          "partial": "Inp Det",
          "signature": "SingPlu[Text]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/antfarm/docs/NLP-Antfarm-Refex.html#v:srxInpDet"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.Antfarm.Refex",
          "name": "srxInpEntity",
          "package": "antfarm",
          "signature": "DiscourseUnit",
          "source": "src/NLP-Antfarm-Refex.html#SubRxInput",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP Antfarm Refex",
          "module": "NLP.Antfarm.Refex",
          "name": "srxInpEntity",
          "package": "antfarm",
          "partial": "Inp Entity",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/antfarm/docs/NLP-Antfarm-Refex.html#v:srxInpEntity"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003emain word\n\u003c/p\u003e",
          "module": "NLP.Antfarm.Refex",
          "name": "srxInpWord",
          "package": "antfarm",
          "signature": "SingPlu Text",
          "source": "src/NLP-Antfarm-Refex.html#SubRxInput",
          "type": "function"
        },
        "index": {
          "description": "main word",
          "hierarchy": "NLP Antfarm Refex",
          "module": "NLP.Antfarm.Refex",
          "name": "srxInpWord",
          "package": "antfarm",
          "partial": "Inp Word",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/antfarm/docs/NLP-Antfarm-Refex.html#v:srxInpWord"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.Antfarm.Refex",
          "name": "srxNumber",
          "package": "antfarm",
          "signature": "Number",
          "source": "src/NLP-Antfarm-Refex.html#SubRx",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP Antfarm Refex",
          "module": "NLP.Antfarm.Refex",
          "name": "srxNumber",
          "package": "antfarm",
          "partial": "Number",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/antfarm/docs/NLP-Antfarm-Refex.html#v:srxNumber"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.Antfarm.Refex",
          "name": "srxWord",
          "package": "antfarm",
          "signature": "SingPlu Text",
          "source": "src/NLP-Antfarm-Refex.html#SubRx",
          "type": "function"
        },
        "index": {
          "hierarchy": "NLP Antfarm Refex",
          "module": "NLP.Antfarm.Refex",
          "name": "srxWord",
          "package": "antfarm",
          "partial": "Word",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/antfarm/docs/NLP-Antfarm-Refex.html#v:srxWord"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eReferring expression generation for definitions.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "NLP.Antfarm",
          "name": "Antfarm",
          "package": "antfarm",
          "source": "src/NLP-Antfarm.html",
          "type": "module"
        },
        "index": {
          "description": "Referring expression generation for definitions",
          "hierarchy": "NLP Antfarm",
          "module": "NLP.Antfarm",
          "name": "Antfarm",
          "package": "antfarm",
          "partial": "Antfarm",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/antfarm/docs/NLP-Antfarm.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NLP.Antfarm",
          "name": "RefHistory",
          "package": "antfarm",
          "source": "src/NLP-Antfarm-History.html#RefHistory",
          "type": "data"
        },
        "index": {
          "hierarchy": "NLP Antfarm",
          "module": "NLP.Antfarm",
          "name": "RefHistory",
          "package": "antfarm",
          "partial": "Ref History",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/antfarm/docs/NLP-Antfarm.html#t:RefHistory"
      }
    }
  ]
]