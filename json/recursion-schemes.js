[
  {
    "cmd": "delete-by-query",
    "query": {
      "contexts": [
        "package"
      ],
      "query": {
        "op": "case",
        "type": "word",
        "word": "recursion-schemes"
      },
      "type": "context"
    }
  },
  [
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Functor.Foldable",
          "name": "Foldable",
          "package": "recursion-schemes",
          "source": "src/Data-Functor-Foldable.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Data Functor Foldable",
          "module": "Data.Functor.Foldable",
          "name": "Foldable",
          "package": "recursion-schemes",
          "partial": "Foldable",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/recursion-schemes/docs/Data-Functor-Foldable.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Functor.Foldable",
          "name": "Base",
          "package": "recursion-schemes",
          "signature": "Base",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Functor Foldable",
          "module": "Data.Functor.Foldable",
          "name": "Base",
          "package": "recursion-schemes",
          "partial": "Base",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/recursion-schemes/docs/Data-Functor-Foldable.html#t:Base"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Functor.Foldable",
          "name": "Fix",
          "package": "recursion-schemes",
          "source": "src/Data-Functor-Foldable.html#Fix",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "Data Functor Foldable",
          "module": "Data.Functor.Foldable",
          "name": "Fix",
          "package": "recursion-schemes",
          "partial": "Fix",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/recursion-schemes/docs/Data-Functor-Foldable.html#t:Fix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Functor.Foldable",
          "name": "Foldable",
          "package": "recursion-schemes",
          "source": "src/Data-Functor-Foldable.html#Foldable",
          "type": "class"
        },
        "index": {
          "hierarchy": "Data Functor Foldable",
          "module": "Data.Functor.Foldable",
          "name": "Foldable",
          "package": "recursion-schemes",
          "partial": "Foldable",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/recursion-schemes/docs/Data-Functor-Foldable.html#t:Foldable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Functor.Foldable",
          "name": "Mu",
          "package": "recursion-schemes",
          "source": "src/Data-Functor-Foldable.html#Mu",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "Data Functor Foldable",
          "module": "Data.Functor.Foldable",
          "name": "Mu",
          "package": "recursion-schemes",
          "partial": "Mu",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/recursion-schemes/docs/Data-Functor-Foldable.html#t:Mu"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Functor.Foldable",
          "name": "Nu",
          "package": "recursion-schemes",
          "source": "src/Data-Functor-Foldable.html#Nu",
          "type": "data"
        },
        "index": {
          "hierarchy": "Data Functor Foldable",
          "module": "Data.Functor.Foldable",
          "name": "Nu",
          "package": "recursion-schemes",
          "partial": "Nu",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/recursion-schemes/docs/Data-Functor-Foldable.html#t:Nu"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Functor.Foldable",
          "name": "Prim",
          "package": "recursion-schemes",
          "signature": "Prim",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Functor Foldable",
          "module": "Data.Functor.Foldable",
          "name": "Prim",
          "package": "recursion-schemes",
          "partial": "Prim",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/recursion-schemes/docs/Data-Functor-Foldable.html#t:Prim"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Functor.Foldable",
          "name": "Unfoldable",
          "package": "recursion-schemes",
          "source": "src/Data-Functor-Foldable.html#Unfoldable",
          "type": "class"
        },
        "index": {
          "hierarchy": "Data Functor Foldable",
          "module": "Data.Functor.Foldable",
          "name": "Unfoldable",
          "package": "recursion-schemes",
          "partial": "Unfoldable",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/recursion-schemes/docs/Data-Functor-Foldable.html#t:Unfoldable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Functor.Foldable",
          "name": "Fix",
          "package": "recursion-schemes",
          "signature": "Fix (f (Fix f))",
          "source": "src/Data-Functor-Foldable.html#Fix",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Functor Foldable",
          "module": "Data.Functor.Foldable",
          "name": "Fix",
          "package": "recursion-schemes",
          "partial": "Fix",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/recursion-schemes/docs/Data-Functor-Foldable.html#v:Fix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Functor.Foldable",
          "name": "Mu",
          "package": "recursion-schemes",
          "signature": "Mu (forall a.  (f a -\u003e a) -\u003e a)",
          "source": "src/Data-Functor-Foldable.html#Mu",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Functor Foldable",
          "module": "Data.Functor.Foldable",
          "name": "Mu",
          "normalized": "Mu(a b(c d-\u003ed)-\u003ed)",
          "package": "recursion-schemes",
          "partial": "Mu",
          "signature": "Mu(forall a.(f a-\u003ea)-\u003ea)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/recursion-schemes/docs/Data-Functor-Foldable.html#v:Mu"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Functor.Foldable",
          "name": "Nu",
          "package": "recursion-schemes",
          "signature": "(a -\u003e f a) -\u003e a -\u003e Nu f",
          "source": "src/Data-Functor-Foldable.html#Nu",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Functor Foldable",
          "module": "Data.Functor.Foldable",
          "name": "Nu",
          "normalized": "(a-\u003eb a)-\u003ea-\u003eNu b",
          "package": "recursion-schemes",
          "partial": "Nu",
          "signature": "(a-\u003ef a)-\u003ea-\u003eNu f",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/recursion-schemes/docs/Data-Functor-Foldable.html#v:Nu"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Functor.Foldable",
          "name": "ana",
          "package": "recursion-schemes",
          "signature": "ana",
          "source": "src/Data-Functor-Foldable.html#ana",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Functor Foldable",
          "module": "Data.Functor.Foldable",
          "name": "ana",
          "package": "recursion-schemes",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/recursion-schemes/docs/Data-Functor-Foldable.html#v:ana"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Functor.Foldable",
          "name": "apo",
          "package": "recursion-schemes",
          "signature": "(a -\u003e Base t (Either t a)) -\u003e a -\u003e t",
          "source": "src/Data-Functor-Foldable.html#apo",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Functor Foldable",
          "module": "Data.Functor.Foldable",
          "name": "apo",
          "normalized": "(a-\u003eBase b(Either b a))-\u003ea-\u003eb",
          "package": "recursion-schemes",
          "signature": "(a-\u003eBase t(Either t a))-\u003ea-\u003et",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/recursion-schemes/docs/Data-Functor-Foldable.html#v:apo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Functor.Foldable",
          "name": "cata",
          "package": "recursion-schemes",
          "signature": "cata",
          "source": "src/Data-Functor-Foldable.html#cata",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Functor Foldable",
          "module": "Data.Functor.Foldable",
          "name": "cata",
          "package": "recursion-schemes",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/recursion-schemes/docs/Data-Functor-Foldable.html#v:cata"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eElgot coalgebras: \u003ca\u003ehttp://comonad.com/reader/2008/elgot-coalgebras/\u003c/a\u003e\n\u003c/p\u003e",
          "module": "Data.Functor.Foldable",
          "name": "coelgot",
          "package": "recursion-schemes",
          "signature": "((a, f b) -\u003e b) -\u003e (a -\u003e f a) -\u003e a -\u003e b",
          "source": "src/Data-Functor-Foldable.html#coelgot",
          "type": "function"
        },
        "index": {
          "description": "Elgot coalgebras http comonad.com reader elgot-coalgebras",
          "hierarchy": "Data Functor Foldable",
          "module": "Data.Functor.Foldable",
          "name": "coelgot",
          "normalized": "((a,b c)-\u003ec)-\u003e(a-\u003eb a)-\u003ea-\u003ec",
          "package": "recursion-schemes",
          "signature": "((a,f b)-\u003eb)-\u003e(a-\u003ef a)-\u003ea-\u003eb",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/recursion-schemes/docs/Data-Functor-Foldable.html#v:coelgot"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Functor.Foldable",
          "name": "distAna",
          "package": "recursion-schemes",
          "signature": "Identity (f a) -\u003e f (Identity a)",
          "source": "src/Data-Functor-Foldable.html#distAna",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Functor Foldable",
          "module": "Data.Functor.Foldable",
          "name": "distAna",
          "normalized": "Identity(a b)-\u003ea(Identity b)",
          "package": "recursion-schemes",
          "partial": "Ana",
          "signature": "Identity(f a)-\u003ef(Identity a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/recursion-schemes/docs/Data-Functor-Foldable.html#v:distAna"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Functor.Foldable",
          "name": "distApo",
          "package": "recursion-schemes",
          "signature": "Either t (Base t a) -\u003e Base t (Either t a)",
          "source": "src/Data-Functor-Foldable.html#distApo",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Functor Foldable",
          "module": "Data.Functor.Foldable",
          "name": "distApo",
          "normalized": "Either a(Base a b)-\u003eBase a(Either a b)",
          "package": "recursion-schemes",
          "partial": "Apo",
          "signature": "Either t(Base t a)-\u003eBase t(Either t a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/recursion-schemes/docs/Data-Functor-Foldable.html#v:distApo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Functor.Foldable",
          "name": "distCata",
          "package": "recursion-schemes",
          "signature": "f (Identity a) -\u003e Identity (f a)",
          "source": "src/Data-Functor-Foldable.html#distCata",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Functor Foldable",
          "module": "Data.Functor.Foldable",
          "name": "distCata",
          "normalized": "a(Identity b)-\u003eIdentity(a b)",
          "package": "recursion-schemes",
          "partial": "Cata",
          "signature": "f(Identity a)-\u003eIdentity(f a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/recursion-schemes/docs/Data-Functor-Foldable.html#v:distCata"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Functor.Foldable",
          "name": "distFutu",
          "package": "recursion-schemes",
          "signature": "Free f (f a) -\u003e f (Free f a)",
          "source": "src/Data-Functor-Foldable.html#distFutu",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Functor Foldable",
          "module": "Data.Functor.Foldable",
          "name": "distFutu",
          "normalized": "Free a(a b)-\u003ea(Free a b)",
          "package": "recursion-schemes",
          "partial": "Futu",
          "signature": "Free f(f a)-\u003ef(Free f a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/recursion-schemes/docs/Data-Functor-Foldable.html#v:distFutu"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Functor.Foldable",
          "name": "distGApo",
          "package": "recursion-schemes",
          "signature": "(b -\u003e f b) -\u003e Either b (f a) -\u003e f (Either b a)",
          "source": "src/Data-Functor-Foldable.html#distGApo",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Functor Foldable",
          "module": "Data.Functor.Foldable",
          "name": "distGApo",
          "normalized": "(a-\u003eb a)-\u003eEither a(b c)-\u003eb(Either a c)",
          "package": "recursion-schemes",
          "partial": "GApo",
          "signature": "(b-\u003ef b)-\u003eEither b(f a)-\u003ef(Either b a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/recursion-schemes/docs/Data-Functor-Foldable.html#v:distGApo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Functor.Foldable",
          "name": "distGFutu",
          "package": "recursion-schemes",
          "signature": "(forall b.  h (f b) -\u003e f (h b)) -\u003e Free h (f a) -\u003e f (Free h a)",
          "source": "src/Data-Functor-Foldable.html#distGFutu",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Functor Foldable",
          "module": "Data.Functor.Foldable",
          "name": "distGFutu",
          "normalized": "(a b c(d e)-\u003ed(c e))-\u003eFree c(d f)-\u003ed(Free c f)",
          "package": "recursion-schemes",
          "partial": "GFutu",
          "signature": "(forall b. h(f b)-\u003ef(h b))-\u003eFree h(f a)-\u003ef(Free h a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/recursion-schemes/docs/Data-Functor-Foldable.html#v:distGFutu"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Functor.Foldable",
          "name": "distGHisto",
          "package": "recursion-schemes",
          "signature": "(forall b.  f (h b) -\u003e h (f b)) -\u003e f (Cofree h a) -\u003e Cofree h (f a)",
          "source": "src/Data-Functor-Foldable.html#distGHisto",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Functor Foldable",
          "module": "Data.Functor.Foldable",
          "name": "distGHisto",
          "normalized": "(a b c(d e)-\u003ed(c e))-\u003ec(Cofree d f)-\u003eCofree d(c f)",
          "package": "recursion-schemes",
          "partial": "GHisto",
          "signature": "(forall b. f(h b)-\u003eh(f b))-\u003ef(Cofree h a)-\u003eCofree h(f a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/recursion-schemes/docs/Data-Functor-Foldable.html#v:distGHisto"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Functor.Foldable",
          "name": "distHisto",
          "package": "recursion-schemes",
          "signature": "f (Cofree f a) -\u003e Cofree f (f a)",
          "source": "src/Data-Functor-Foldable.html#distHisto",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Functor Foldable",
          "module": "Data.Functor.Foldable",
          "name": "distHisto",
          "normalized": "a(Cofree a b)-\u003eCofree a(a b)",
          "package": "recursion-schemes",
          "partial": "Histo",
          "signature": "f(Cofree f a)-\u003eCofree f(f a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/recursion-schemes/docs/Data-Functor-Foldable.html#v:distHisto"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Functor.Foldable",
          "name": "distPara",
          "package": "recursion-schemes",
          "signature": "Base t (t, a) -\u003e (t, Base t a)",
          "source": "src/Data-Functor-Foldable.html#distPara",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Functor Foldable",
          "module": "Data.Functor.Foldable",
          "name": "distPara",
          "normalized": "Base a(a,b)-\u003e(a,Base a b)",
          "package": "recursion-schemes",
          "partial": "Para",
          "signature": "Base t(t,a)-\u003e(t,Base t a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/recursion-schemes/docs/Data-Functor-Foldable.html#v:distPara"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Functor.Foldable",
          "name": "distParaT",
          "package": "recursion-schemes",
          "signature": "(forall b.  Base t (w b) -\u003e w (Base t b)) -\u003e Base t (EnvT t w a) -\u003e EnvT t w (Base t a)",
          "source": "src/Data-Functor-Foldable.html#distParaT",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Functor Foldable",
          "module": "Data.Functor.Foldable",
          "name": "distParaT",
          "normalized": "(a b Base c(d e)-\u003ed(Base c e))-\u003eBase c(EnvT c d f)-\u003eEnvT c d(Base c f)",
          "package": "recursion-schemes",
          "partial": "Para",
          "signature": "(forall b. Base t(w b)-\u003ew(Base t b))-\u003eBase t(EnvT t w a)-\u003eEnvT t w(Base t a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/recursion-schemes/docs/Data-Functor-Foldable.html#v:distParaT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Functor.Foldable",
          "name": "distZygo",
          "package": "recursion-schemes",
          "signature": "(f b -\u003e b)-\u003e f (b, a) -\u003e (b, f a)",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Functor Foldable",
          "module": "Data.Functor.Foldable",
          "name": "distZygo",
          "normalized": "(a b-\u003eb)-\u003ea(b,c)-\u003e(b,a c)",
          "package": "recursion-schemes",
          "partial": "Zygo",
          "signature": "(f b-\u003eb)-\u003ef(b,a)-\u003e(b,f a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/recursion-schemes/docs/Data-Functor-Foldable.html#v:distZygo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Functor.Foldable",
          "name": "distZygoT",
          "package": "recursion-schemes",
          "signature": "(f b -\u003e b) -\u003e (forall c.  f (w c) -\u003e w (f c)) -\u003e f (EnvT b w a) -\u003e EnvT b w (f a)",
          "source": "src/Data-Functor-Foldable.html#distZygoT",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Functor Foldable",
          "module": "Data.Functor.Foldable",
          "name": "distZygoT",
          "normalized": "(a b-\u003eb)-\u003e(c d a(e f)-\u003ee(a f))-\u003ea(EnvT b e g)-\u003eEnvT b e(a g)",
          "package": "recursion-schemes",
          "partial": "Zygo",
          "signature": "(f b-\u003eb)-\u003e(forall c. f(w c)-\u003ew(f c))-\u003ef(EnvT b w a)-\u003eEnvT b w(f a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/recursion-schemes/docs/Data-Functor-Foldable.html#v:distZygoT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eElgot algebras\n\u003c/p\u003e",
          "module": "Data.Functor.Foldable",
          "name": "elgot",
          "package": "recursion-schemes",
          "signature": "(f a -\u003e a) -\u003e (b -\u003e Either a (f b)) -\u003e b -\u003e a",
          "source": "src/Data-Functor-Foldable.html#elgot",
          "type": "function"
        },
        "index": {
          "description": "Elgot algebras",
          "hierarchy": "Data Functor Foldable",
          "module": "Data.Functor.Foldable",
          "name": "elgot",
          "normalized": "(a b-\u003eb)-\u003e(c-\u003eEither b(a c))-\u003ec-\u003eb",
          "package": "recursion-schemes",
          "signature": "(f a-\u003ea)-\u003e(b-\u003eEither a(f b))-\u003eb-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/recursion-schemes/docs/Data-Functor-Foldable.html#v:elgot"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Functor.Foldable",
          "name": "embed",
          "package": "recursion-schemes",
          "signature": "Base t t -\u003e t",
          "source": "src/Data-Functor-Foldable.html#embed",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Functor Foldable",
          "module": "Data.Functor.Foldable",
          "name": "embed",
          "normalized": "Base a a-\u003ea",
          "package": "recursion-schemes",
          "signature": "Base t t-\u003et",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/recursion-schemes/docs/Data-Functor-Foldable.html#v:embed"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Functor.Foldable",
          "name": "fold",
          "package": "recursion-schemes",
          "signature": "(Base t a -\u003e a) -\u003e t -\u003e a",
          "source": "src/Data-Functor-Foldable.html#fold",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Functor Foldable",
          "module": "Data.Functor.Foldable",
          "name": "fold",
          "normalized": "(Base a b-\u003eb)-\u003ea-\u003eb",
          "package": "recursion-schemes",
          "signature": "(Base t a-\u003ea)-\u003et-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/recursion-schemes/docs/Data-Functor-Foldable.html#v:fold"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Functor.Foldable",
          "name": "futu",
          "package": "recursion-schemes",
          "signature": "(a -\u003e Base t (Free (Base t) a)) -\u003e a -\u003e t",
          "source": "src/Data-Functor-Foldable.html#futu",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Functor Foldable",
          "module": "Data.Functor.Foldable",
          "name": "futu",
          "normalized": "(a-\u003eBase b(Free(Base b)a))-\u003ea-\u003eb",
          "package": "recursion-schemes",
          "signature": "(a-\u003eBase t(Free(Base t)a))-\u003ea-\u003et",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/recursion-schemes/docs/Data-Functor-Foldable.html#v:futu"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA generalized anamorphism\n\u003c/p\u003e",
          "module": "Data.Functor.Foldable",
          "name": "gana",
          "package": "recursion-schemes",
          "signature": "(forall b.  m (Base t b) -\u003e Base t (m b))-\u003e (a -\u003e Base t (m a))-\u003e a-\u003e t",
          "type": "function"
        },
        "index": {
          "description": "generalized anamorphism",
          "hierarchy": "Data Functor Foldable",
          "module": "Data.Functor.Foldable",
          "name": "gana",
          "normalized": "(a b c(Base d e)-\u003eBase d(c e))-\u003e(f-\u003eBase d(c f))-\u003ef-\u003ed",
          "package": "recursion-schemes",
          "signature": "(forall b. m(Base t b)-\u003eBase t(m b))-\u003e(a-\u003eBase t(m a))-\u003ea-\u003et",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/recursion-schemes/docs/Data-Functor-Foldable.html#v:gana"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA generalized catamorphism\n\u003c/p\u003e",
          "module": "Data.Functor.Foldable",
          "name": "gcata",
          "package": "recursion-schemes",
          "signature": "(forall b.  Base t (w b) -\u003e w (Base t b))-\u003e (Base t (w a) -\u003e a)-\u003e t-\u003e a",
          "type": "function"
        },
        "index": {
          "description": "generalized catamorphism",
          "hierarchy": "Data Functor Foldable",
          "module": "Data.Functor.Foldable",
          "name": "gcata",
          "normalized": "(a b Base c(d e)-\u003ed(Base c e))-\u003e(Base c(d f)-\u003ef)-\u003ec-\u003ef",
          "package": "recursion-schemes",
          "signature": "(forall b. Base t(w b)-\u003ew(Base t b))-\u003e(Base t(w a)-\u003ea)-\u003et-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/recursion-schemes/docs/Data-Functor-Foldable.html#v:gcata"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA generalized catamorphism\n\u003c/p\u003e",
          "module": "Data.Functor.Foldable",
          "name": "gfold",
          "package": "recursion-schemes",
          "signature": "(forall b.  Base t (w b) -\u003e w (Base t b))-\u003e (Base t (w a) -\u003e a)-\u003e t-\u003e a",
          "type": "function"
        },
        "index": {
          "description": "generalized catamorphism",
          "hierarchy": "Data Functor Foldable",
          "module": "Data.Functor.Foldable",
          "name": "gfold",
          "normalized": "(a b Base c(d e)-\u003ed(Base c e))-\u003e(Base c(d f)-\u003ef)-\u003ec-\u003ef",
          "package": "recursion-schemes",
          "signature": "(forall b. Base t(w b)-\u003ew(Base t b))-\u003e(Base t(w a)-\u003ea)-\u003et-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/recursion-schemes/docs/Data-Functor-Foldable.html#v:gfold"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Functor.Foldable",
          "name": "ghisto",
          "package": "recursion-schemes",
          "signature": "(forall b.  Base t (h b) -\u003e h (Base t b)) -\u003e (Base t (Cofree h a) -\u003e a) -\u003e t -\u003e a",
          "source": "src/Data-Functor-Foldable.html#ghisto",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Functor Foldable",
          "module": "Data.Functor.Foldable",
          "name": "ghisto",
          "normalized": "(a b Base c(d e)-\u003ed(Base c e))-\u003e(Base c(Cofree d f)-\u003ef)-\u003ec-\u003ef",
          "package": "recursion-schemes",
          "signature": "(forall b. Base t(h b)-\u003eh(Base t b))-\u003e(Base t(Cofree h a)-\u003ea)-\u003et-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/recursion-schemes/docs/Data-Functor-Foldable.html#v:ghisto"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA generalized hylomorphism\n\u003c/p\u003e",
          "module": "Data.Functor.Foldable",
          "name": "ghylo",
          "package": "recursion-schemes",
          "signature": "(forall c.  f (w c) -\u003e w (f c)) -\u003e (forall d.  m (f d) -\u003e f (m d)) -\u003e (f (w b) -\u003e b) -\u003e (a -\u003e f (m a)) -\u003e a -\u003e b",
          "source": "src/Data-Functor-Foldable.html#ghylo",
          "type": "function"
        },
        "index": {
          "description": "generalized hylomorphism",
          "hierarchy": "Data Functor Foldable",
          "module": "Data.Functor.Foldable",
          "name": "ghylo",
          "normalized": "(a b c(d e)-\u003ed(c e))-\u003e(a f g(c h)-\u003ec(g h))-\u003e(c(d i)-\u003ei)-\u003e(j-\u003ec(g j))-\u003ej-\u003ei",
          "package": "recursion-schemes",
          "signature": "(forall c. f(w c)-\u003ew(f c))-\u003e(forall d. m(f d)-\u003ef(m d))-\u003e(f(w b)-\u003eb)-\u003e(a-\u003ef(m a))-\u003ea-\u003eb",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/recursion-schemes/docs/Data-Functor-Foldable.html#v:ghylo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Functor.Foldable",
          "name": "gpara",
          "package": "recursion-schemes",
          "signature": "(forall b.  Base t (w b) -\u003e w (Base t b)) -\u003e (Base t (EnvT t w a) -\u003e a) -\u003e t -\u003e a",
          "source": "src/Data-Functor-Foldable.html#gpara",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Functor Foldable",
          "module": "Data.Functor.Foldable",
          "name": "gpara",
          "normalized": "(a b Base c(d e)-\u003ed(Base c e))-\u003e(Base c(EnvT c d f)-\u003ef)-\u003ec-\u003ef",
          "package": "recursion-schemes",
          "signature": "(forall b. Base t(w b)-\u003ew(Base t b))-\u003e(Base t(EnvT t w a)-\u003ea)-\u003et-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/recursion-schemes/docs/Data-Functor-Foldable.html#v:gpara"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA generalized postpromorphism\n\u003c/p\u003e",
          "module": "Data.Functor.Foldable",
          "name": "gpostpro",
          "package": "recursion-schemes",
          "signature": "(forall b.  m (Base t b) -\u003e Base t (m b)) -\u003e (forall c.  Base t c -\u003e Base t c) -\u003e (a -\u003e Base t (m a)) -\u003e a -\u003e t",
          "source": "src/Data-Functor-Foldable.html#gpostpro",
          "type": "method"
        },
        "index": {
          "description": "generalized postpromorphism",
          "hierarchy": "Data Functor Foldable",
          "module": "Data.Functor.Foldable",
          "name": "gpostpro",
          "normalized": "(a b c(Base d e)-\u003eBase d(c e))-\u003e(a f Base d g-\u003eBase d g)-\u003e(h-\u003eBase d(c h))-\u003eh-\u003ed",
          "package": "recursion-schemes",
          "signature": "(forall b. m(Base t b)-\u003eBase t(m b))-\u003e(forall c. Base t c-\u003eBase t c)-\u003e(a-\u003eBase t(m a))-\u003ea-\u003et",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/recursion-schemes/docs/Data-Functor-Foldable.html#v:gpostpro"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Functor.Foldable",
          "name": "gprepro",
          "package": "recursion-schemes",
          "signature": "(forall b.  Base t (w b) -\u003e w (Base t b)) -\u003e (forall c.  Base t c -\u003e Base t c) -\u003e (Base t (w a) -\u003e a) -\u003e t -\u003e a",
          "source": "src/Data-Functor-Foldable.html#gprepro",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Functor Foldable",
          "module": "Data.Functor.Foldable",
          "name": "gprepro",
          "normalized": "(a b Base c(d e)-\u003ed(Base c e))-\u003e(a f Base c g-\u003eBase c g)-\u003e(Base c(d h)-\u003eh)-\u003ec-\u003eh",
          "package": "recursion-schemes",
          "signature": "(forall b. Base t(w b)-\u003ew(Base t b))-\u003e(forall c. Base t c-\u003eBase t c)-\u003e(Base t(w a)-\u003ea)-\u003et-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/recursion-schemes/docs/Data-Functor-Foldable.html#v:gprepro"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA generalized hylomorphism\n\u003c/p\u003e",
          "module": "Data.Functor.Foldable",
          "name": "grefold",
          "package": "recursion-schemes",
          "signature": "(forall c.  f (w c) -\u003e w (f c)) -\u003e (forall d.  m (f d) -\u003e f (m d)) -\u003e (f (w b) -\u003e b) -\u003e (a -\u003e f (m a)) -\u003e a -\u003e b",
          "source": "src/Data-Functor-Foldable.html#grefold",
          "type": "function"
        },
        "index": {
          "description": "generalized hylomorphism",
          "hierarchy": "Data Functor Foldable",
          "module": "Data.Functor.Foldable",
          "name": "grefold",
          "normalized": "(a b c(d e)-\u003ed(c e))-\u003e(a f g(c h)-\u003ec(g h))-\u003e(c(d i)-\u003ei)-\u003e(j-\u003ec(g j))-\u003ej-\u003ei",
          "package": "recursion-schemes",
          "signature": "(forall c. f(w c)-\u003ew(f c))-\u003e(forall d. m(f d)-\u003ef(m d))-\u003e(f(w b)-\u003eb)-\u003e(a-\u003ef(m a))-\u003ea-\u003eb",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/recursion-schemes/docs/Data-Functor-Foldable.html#v:grefold"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA generalized anamorphism\n\u003c/p\u003e",
          "module": "Data.Functor.Foldable",
          "name": "gunfold",
          "package": "recursion-schemes",
          "signature": "(forall b.  m (Base t b) -\u003e Base t (m b))-\u003e (a -\u003e Base t (m a))-\u003e a-\u003e t",
          "type": "function"
        },
        "index": {
          "description": "generalized anamorphism",
          "hierarchy": "Data Functor Foldable",
          "module": "Data.Functor.Foldable",
          "name": "gunfold",
          "normalized": "(a b c(Base d e)-\u003eBase d(c e))-\u003e(f-\u003eBase d(c f))-\u003ef-\u003ed",
          "package": "recursion-schemes",
          "signature": "(forall b. m(Base t b)-\u003eBase t(m b))-\u003e(a-\u003eBase t(m a))-\u003ea-\u003et",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/recursion-schemes/docs/Data-Functor-Foldable.html#v:gunfold"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Functor.Foldable",
          "name": "gzygo",
          "package": "recursion-schemes",
          "signature": "(Base t b -\u003e b) -\u003e (forall c.  Base t (w c) -\u003e w (Base t c)) -\u003e (Base t (EnvT b w a) -\u003e a) -\u003e t -\u003e a",
          "source": "src/Data-Functor-Foldable.html#gzygo",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Functor Foldable",
          "module": "Data.Functor.Foldable",
          "name": "gzygo",
          "normalized": "(Base a b-\u003eb)-\u003e(c d Base a(e f)-\u003ee(Base a f))-\u003e(Base a(EnvT b e g)-\u003eg)-\u003ea-\u003eg",
          "package": "recursion-schemes",
          "signature": "(Base t b-\u003eb)-\u003e(forall c. Base t(w c)-\u003ew(Base t c))-\u003e(Base t(EnvT b w a)-\u003ea)-\u003et-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/recursion-schemes/docs/Data-Functor-Foldable.html#v:gzygo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCourse-of-value iteration\n\u003c/p\u003e",
          "module": "Data.Functor.Foldable",
          "name": "histo",
          "package": "recursion-schemes",
          "signature": "(Base t (Cofree (Base t) a) -\u003e a) -\u003e t -\u003e a",
          "source": "src/Data-Functor-Foldable.html#histo",
          "type": "function"
        },
        "index": {
          "description": "Course-of-value iteration",
          "hierarchy": "Data Functor Foldable",
          "module": "Data.Functor.Foldable",
          "name": "histo",
          "normalized": "(Base a(Cofree(Base a)b)-\u003eb)-\u003ea-\u003eb",
          "package": "recursion-schemes",
          "signature": "(Base t(Cofree(Base t)a)-\u003ea)-\u003et-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/recursion-schemes/docs/Data-Functor-Foldable.html#v:histo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Functor.Foldable",
          "name": "hylo",
          "package": "recursion-schemes",
          "signature": "(f b -\u003e b) -\u003e (a -\u003e f a) -\u003e a -\u003e b",
          "source": "src/Data-Functor-Foldable.html#hylo",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Functor Foldable",
          "module": "Data.Functor.Foldable",
          "name": "hylo",
          "normalized": "(a b-\u003eb)-\u003e(c-\u003ea c)-\u003ec-\u003eb",
          "package": "recursion-schemes",
          "signature": "(f b-\u003eb)-\u003e(a-\u003ef a)-\u003ea-\u003eb",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/recursion-schemes/docs/Data-Functor-Foldable.html#v:hylo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMendler-style iteration\n\u003c/p\u003e",
          "module": "Data.Functor.Foldable",
          "name": "mcata",
          "package": "recursion-schemes",
          "signature": "(forall y.  (y -\u003e c) -\u003e f y -\u003e c) -\u003e Fix f -\u003e c",
          "source": "src/Data-Functor-Foldable.html#mcata",
          "type": "function"
        },
        "index": {
          "description": "Mendler-style iteration",
          "hierarchy": "Data Functor Foldable",
          "module": "Data.Functor.Foldable",
          "name": "mcata",
          "normalized": "(a b(c-\u003ed)-\u003ee c-\u003ed)-\u003eFix e-\u003ed",
          "package": "recursion-schemes",
          "signature": "(forall y.(y-\u003ec)-\u003ef y-\u003ec)-\u003eFix f-\u003ec",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/recursion-schemes/docs/Data-Functor-Foldable.html#v:mcata"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMendler-style course-of-value iteration\n\u003c/p\u003e",
          "module": "Data.Functor.Foldable",
          "name": "mhisto",
          "package": "recursion-schemes",
          "signature": "(forall y.  (y -\u003e c) -\u003e (y -\u003e f y) -\u003e f y -\u003e c) -\u003e Fix f -\u003e c",
          "source": "src/Data-Functor-Foldable.html#mhisto",
          "type": "function"
        },
        "index": {
          "description": "Mendler-style course-of-value iteration",
          "hierarchy": "Data Functor Foldable",
          "module": "Data.Functor.Foldable",
          "name": "mhisto",
          "normalized": "(a b(c-\u003ed)-\u003e(c-\u003ee c)-\u003ee c-\u003ed)-\u003eFix e-\u003ed",
          "package": "recursion-schemes",
          "signature": "(forall y.(y-\u003ec)-\u003e(y-\u003ef y)-\u003ef y-\u003ec)-\u003eFix f-\u003ec",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/recursion-schemes/docs/Data-Functor-Foldable.html#v:mhisto"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Functor.Foldable",
          "name": "para",
          "package": "recursion-schemes",
          "signature": "(Base t (t, a) -\u003e a) -\u003e t -\u003e a",
          "source": "src/Data-Functor-Foldable.html#para",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Functor Foldable",
          "module": "Data.Functor.Foldable",
          "name": "para",
          "normalized": "(Base a(a,b)-\u003eb)-\u003ea-\u003eb",
          "package": "recursion-schemes",
          "signature": "(Base t(t,a)-\u003ea)-\u003et-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/recursion-schemes/docs/Data-Functor-Foldable.html#v:para"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFokkinga's postpromorphism\n\u003c/p\u003e",
          "module": "Data.Functor.Foldable",
          "name": "postpro",
          "package": "recursion-schemes",
          "signature": "(forall b.  Base t b -\u003e Base t b) -\u003e (a -\u003e Base t a) -\u003e a -\u003e t",
          "source": "src/Data-Functor-Foldable.html#postpro",
          "type": "method"
        },
        "index": {
          "description": "Fokkinga postpromorphism",
          "hierarchy": "Data Functor Foldable",
          "module": "Data.Functor.Foldable",
          "name": "postpro",
          "normalized": "(a b Base c d-\u003eBase c d)-\u003e(e-\u003eBase c e)-\u003ee-\u003ec",
          "package": "recursion-schemes",
          "signature": "(forall b. Base t b-\u003eBase t b)-\u003e(a-\u003eBase t a)-\u003ea-\u003et",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/recursion-schemes/docs/Data-Functor-Foldable.html#v:postpro"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFokkinga's prepromorphism\n\u003c/p\u003e",
          "module": "Data.Functor.Foldable",
          "name": "prepro",
          "package": "recursion-schemes",
          "signature": "(forall b.  Base t b -\u003e Base t b) -\u003e (Base t a -\u003e a) -\u003e t -\u003e a",
          "source": "src/Data-Functor-Foldable.html#prepro",
          "type": "method"
        },
        "index": {
          "description": "Fokkinga prepromorphism",
          "hierarchy": "Data Functor Foldable",
          "module": "Data.Functor.Foldable",
          "name": "prepro",
          "normalized": "(a b Base c d-\u003eBase c d)-\u003e(Base c e-\u003ee)-\u003ec-\u003ee",
          "package": "recursion-schemes",
          "signature": "(forall b. Base t b-\u003eBase t b)-\u003e(Base t a-\u003ea)-\u003et-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/recursion-schemes/docs/Data-Functor-Foldable.html#v:prepro"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Functor.Foldable",
          "name": "project",
          "package": "recursion-schemes",
          "signature": "t -\u003e Base t t",
          "source": "src/Data-Functor-Foldable.html#project",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Functor Foldable",
          "module": "Data.Functor.Foldable",
          "name": "project",
          "normalized": "a-\u003eBase a a",
          "package": "recursion-schemes",
          "signature": "t-\u003eBase t t",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/recursion-schemes/docs/Data-Functor-Foldable.html#v:project"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Functor.Foldable",
          "name": "refix",
          "package": "recursion-schemes",
          "signature": "s -\u003e t",
          "source": "src/Data-Functor-Foldable.html#refix",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Functor Foldable",
          "module": "Data.Functor.Foldable",
          "name": "refix",
          "normalized": "a-\u003eb",
          "package": "recursion-schemes",
          "signature": "s-\u003et",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/recursion-schemes/docs/Data-Functor-Foldable.html#v:refix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Functor.Foldable",
          "name": "refold",
          "package": "recursion-schemes",
          "signature": "(f b -\u003e b) -\u003e (a -\u003e f a) -\u003e a -\u003e b",
          "source": "src/Data-Functor-Foldable.html#refold",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Functor Foldable",
          "module": "Data.Functor.Foldable",
          "name": "refold",
          "normalized": "(a b-\u003eb)-\u003e(c-\u003ea c)-\u003ec-\u003eb",
          "package": "recursion-schemes",
          "signature": "(f b-\u003eb)-\u003e(a-\u003ef a)-\u003ea-\u003eb",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/recursion-schemes/docs/Data-Functor-Foldable.html#v:refold"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Functor.Foldable",
          "name": "unfold",
          "package": "recursion-schemes",
          "signature": "(a -\u003e Base t a) -\u003e a -\u003e t",
          "source": "src/Data-Functor-Foldable.html#unfold",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Functor Foldable",
          "module": "Data.Functor.Foldable",
          "name": "unfold",
          "normalized": "(a-\u003eBase b a)-\u003ea-\u003eb",
          "package": "recursion-schemes",
          "signature": "(a-\u003eBase t a)-\u003ea-\u003et",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/recursion-schemes/docs/Data-Functor-Foldable.html#v:unfold"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Functor.Foldable",
          "name": "zygo",
          "package": "recursion-schemes",
          "signature": "(Base t b -\u003e b) -\u003e (Base t (b, a) -\u003e a) -\u003e t -\u003e a",
          "source": "src/Data-Functor-Foldable.html#zygo",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Functor Foldable",
          "module": "Data.Functor.Foldable",
          "name": "zygo",
          "normalized": "(Base a b-\u003eb)-\u003e(Base a(b,c)-\u003ec)-\u003ea-\u003ec",
          "package": "recursion-schemes",
          "signature": "(Base t b-\u003eb)-\u003e(Base t(b,a)-\u003ea)-\u003et-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/recursion-schemes/docs/Data-Functor-Foldable.html#v:zygo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eZygohistomorphic prepromorphisms:\n\u003c/p\u003e\u003cp\u003eA corrected and modernized version of \u003ca\u003ehttp://www.haskell.org/haskellwiki/Zygohistomorphic_prepromorphisms\u003c/a\u003e\n\u003c/p\u003e",
          "module": "Data.Functor.Foldable",
          "name": "zygoHistoPrepro",
          "package": "recursion-schemes",
          "signature": "(Base t b -\u003e b) -\u003e (forall c.  Base t c -\u003e Base t c) -\u003e (Base t (EnvT b (Cofree (Base t)) a) -\u003e a) -\u003e t -\u003e a",
          "source": "src/Data-Functor-Foldable.html#zygoHistoPrepro",
          "type": "function"
        },
        "index": {
          "description": "Zygohistomorphic prepromorphisms corrected and modernized version of http www.haskell.org haskellwiki Zygohistomorphic prepromorphisms",
          "hierarchy": "Data Functor Foldable",
          "module": "Data.Functor.Foldable",
          "name": "zygoHistoPrepro",
          "normalized": "(Base a b-\u003eb)-\u003e(c d Base a e-\u003eBase a e)-\u003e(Base a(EnvT b(Cofree(Base a))f)-\u003ef)-\u003ea-\u003ef",
          "package": "recursion-schemes",
          "partial": "Histo Prepro",
          "signature": "(Base t b-\u003eb)-\u003e(forall c. Base t c-\u003eBase t c)-\u003e(Base t(EnvT b(Cofree(Base t))a)-\u003ea)-\u003et-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/recursion-schemes/docs/Data-Functor-Foldable.html#v:zygoHistoPrepro"
      }
    }
  ]
]