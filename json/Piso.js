[
  {
    "cmd": "delete-by-query",
    "query": {
      "contexts": [
        "package"
      ],
      "query": {
        "op": "case",
        "type": "word",
        "word": "Piso"
      },
      "type": "context"
    }
  },
  [
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eConstructor-destructor isomorphisms for some common datatypes.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.Piso.Common",
          "name": "Common",
          "package": "Piso",
          "source": "src/Data-Piso-Common.html",
          "type": "module"
        },
        "index": {
          "description": "Constructor-destructor isomorphisms for some common datatypes",
          "hierarchy": "Data Piso Common",
          "module": "Data.Piso.Common",
          "name": "Common",
          "package": "Piso",
          "partial": "Common",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/Piso/docs/Data-Piso-Common.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Piso.Common",
          "name": "cons",
          "package": "Piso",
          "signature": "Piso (a :- ([a] :- t)) ([a] :- t)",
          "source": "src/Data-Piso-Common.html#cons",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Piso Common",
          "module": "Data.Piso.Common",
          "name": "cons",
          "normalized": "Piso(a([a]b))([a]b)",
          "package": "Piso",
          "signature": "Piso(a([a]t))([a]t)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Piso/docs/Data-Piso-Common.html#v:cons"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Piso.Common",
          "name": "false",
          "package": "Piso",
          "signature": "Piso t (Bool :- t)",
          "source": "src/Data-Piso-Common.html#false",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Piso Common",
          "module": "Data.Piso.Common",
          "name": "false",
          "package": "Piso",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Piso/docs/Data-Piso-Common.html#v:false"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Piso.Common",
          "name": "just",
          "package": "Piso",
          "signature": "Piso (a :- t) (Maybe a :- t)",
          "source": "src/Data-Piso-Common.html#just",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Piso Common",
          "module": "Data.Piso.Common",
          "name": "just",
          "package": "Piso",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Piso/docs/Data-Piso-Common.html#v:just"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Piso.Common",
          "name": "left",
          "package": "Piso",
          "signature": "Piso (a :- t) (Either a b :- t)",
          "source": "src/Data-Piso-Common.html#left",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Piso Common",
          "module": "Data.Piso.Common",
          "name": "left",
          "package": "Piso",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Piso/docs/Data-Piso-Common.html#v:left"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Piso.Common",
          "name": "nil",
          "package": "Piso",
          "signature": "Piso t ([a] :- t)",
          "source": "src/Data-Piso-Common.html#nil",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Piso Common",
          "module": "Data.Piso.Common",
          "name": "nil",
          "normalized": "Piso a([b]a)",
          "package": "Piso",
          "signature": "Piso t([a]t)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Piso/docs/Data-Piso-Common.html#v:nil"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Piso.Common",
          "name": "nothing",
          "package": "Piso",
          "signature": "Piso t (Maybe a :- t)",
          "source": "src/Data-Piso-Common.html#nothing",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Piso Common",
          "module": "Data.Piso.Common",
          "name": "nothing",
          "package": "Piso",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Piso/docs/Data-Piso-Common.html#v:nothing"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Piso.Common",
          "name": "right",
          "package": "Piso",
          "signature": "Piso (b :- t) (Either a b :- t)",
          "source": "src/Data-Piso-Common.html#right",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Piso Common",
          "module": "Data.Piso.Common",
          "name": "right",
          "package": "Piso",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Piso/docs/Data-Piso-Common.html#v:right"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Piso.Common",
          "name": "true",
          "package": "Piso",
          "signature": "Piso t (Bool :- t)",
          "source": "src/Data-Piso-Common.html#true",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Piso Common",
          "module": "Data.Piso.Common",
          "name": "true",
          "package": "Piso",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Piso/docs/Data-Piso-Common.html#v:true"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Piso.Common",
          "name": "tup",
          "package": "Piso",
          "signature": "Piso (a :- (b :- t)) ((a, b) :- t)",
          "source": "src/Data-Piso-Common.html#tup",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Piso Common",
          "module": "Data.Piso.Common",
          "name": "tup",
          "normalized": "Piso(a(b c))((a,b)c)",
          "package": "Piso",
          "signature": "Piso(a(b t))((a,b)t)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Piso/docs/Data-Piso-Common.html#v:tup"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Piso.Common",
          "name": "tup3",
          "package": "Piso",
          "signature": "Piso (a :- (b :- (c :- t))) ((a, b, c) :- t)",
          "source": "src/Data-Piso-Common.html#tup3",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Piso Common",
          "module": "Data.Piso.Common",
          "name": "tup3",
          "normalized": "Piso(a(b(c d)))((a,b,c)d)",
          "package": "Piso",
          "signature": "Piso(a(b(c t)))((a,b,c)t)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Piso/docs/Data-Piso-Common.html#v:tup3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Piso.Common",
          "name": "unit",
          "package": "Piso",
          "signature": "Piso t (() :- t)",
          "source": "src/Data-Piso-Common.html#unit",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Piso Common",
          "module": "Data.Piso.Common",
          "name": "unit",
          "normalized": "Piso a(()a)",
          "package": "Piso",
          "signature": "Piso t(()t)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Piso/docs/Data-Piso-Common.html#v:unit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Piso.Generic",
          "name": "Generic",
          "package": "Piso",
          "source": "src/Data-Piso-Generic.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Data Piso Generic",
          "module": "Data.Piso.Generic",
          "name": "Generic",
          "package": "Piso",
          "partial": "Generic",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/Piso/docs/Data-Piso-Generic.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDerive a list of partial isomorphisms, one for each constructor in the \u003ccode\u003e\u003ca\u003eGeneric\u003c/a\u003e\u003c/code\u003e datatype \u003ccode\u003ea\u003c/code\u003e. The list is wrapped in the unary constructor \u003ccode\u003ePisoList\u003c/code\u003e. Within that constructor, the isomorphisms are separated by the right-associative binary infix constructor \u003ccode\u003e:&\u003c/code\u003e. Finally, the individual isomorphisms are wrapped in the unary constructor \u003ccode\u003eI\u003c/code\u003e. These constructors are all exported by this module, but no documentation is generated for them by Hackage.\n\u003c/p\u003e\u003cp\u003eAs an example, here is how to define the isomorphisms \u003ccode\u003enil\u003c/code\u003e and \u003ccode\u003econs\u003c/code\u003e for \u003ccode\u003e[a]\u003c/code\u003e, which is an instance of \u003ccode\u003eGeneric\u003c/code\u003e:\n\u003c/p\u003e\u003cpre\u003e nil  :: Piso              t  ([a] :- t)\n cons :: Piso (a :- [a] :- t) ([a] :- t)\n (nil, cons) = (nil', cons')\n   where\n     PisoList (I nil' :& I cons') = mkPisoList\n\u003c/pre\u003e\u003cp\u003eGHC 7.6.3 requires the extra indirection through \u003ccode\u003enil'\u003c/code\u003e and \u003ccode\u003econs'\u003c/code\u003e, due to bug 7268 (\u003ca\u003ehttp://ghc.haskell.org/trac/ghc/ticket/7268\u003c/a\u003e). When it is fixed, the example above can be written in a more direct way:\n\u003c/p\u003e\u003cpre\u003e nil  :: Piso              t  ([a] :- t)\n cons :: Piso (a :- [a] :- t) ([a] :- t)\n PisoList (I nil :& I cons) = mkPisoList\n\u003c/pre\u003e\u003cp\u003eIf you are familiar with the generic representations from \u003ccode\u003eData.Generic\u003c/code\u003e, you might be interested in the exact types of the various constructors in which the isomorphisms are wrapped:\n\u003c/p\u003e\u003cpre\u003e I        :: (forall t. Piso (PisoLhs f t) (a :- t)) -\u003e PisoList (M1 C c f) a\n (:&)     :: PisoList f a -\u003e PisoList g a -\u003e PisoList (f :+: g) a\n PisoList :: PisoList f a -\u003e PisoList (M1 D c f) a\n\u003c/pre\u003e\u003cp\u003eThe type constructor \u003ccode\u003ePisoLhs\u003c/code\u003e that appears in the type of \u003ccode\u003eI\u003c/code\u003e is an internal type family that builds the proper heterogenous list of types (using \u003ccode\u003e\u003ca\u003e:-\u003c/a\u003e\u003c/code\u003e) based on the constructor's fields.\n\u003c/p\u003e",
          "module": "Data.Piso.Generic",
          "name": "mkPisoList",
          "package": "Piso",
          "signature": "PisoList (Rep a) a",
          "source": "src/Data-Piso-Generic.html#mkPisoList",
          "type": "function"
        },
        "index": {
          "description": "Derive list of partial isomorphisms one for each constructor in the Generic datatype The list is wrapped in the unary constructor PisoList Within that constructor the isomorphisms are separated by the right-associative binary infix constructor Finally the individual isomorphisms are wrapped in the unary constructor These constructors are all exported by this module but no documentation is generated for them by Hackage As an example here is how to define the isomorphisms nil and cons for which is an instance of Generic nil Piso cons Piso nil cons nil cons where PisoList nil cons mkPisoList GHC requires the extra indirection through nil and cons due to bug http ghc.haskell.org trac ghc ticket When it is fixed the example above can be written in more direct way nil Piso cons Piso PisoList nil cons mkPisoList If you are familiar with the generic representations from Data.Generic you might be interested in the exact types of the various constructors in which the isomorphisms are wrapped forall Piso PisoLhs PisoList M1 PisoList PisoList PisoList PisoList PisoList PisoList M1 The type constructor PisoLhs that appears in the type of is an internal type family that builds the proper heterogenous list of types using based on the constructor fields",
          "hierarchy": "Data Piso Generic",
          "module": "Data.Piso.Generic",
          "name": "mkPisoList",
          "package": "Piso",
          "partial": "Piso List",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Piso/docs/Data-Piso-Generic.html#v:mkPisoList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Piso.TH",
          "name": "TH",
          "package": "Piso",
          "source": "src/Data-Piso-TH.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Data Piso TH",
          "module": "Data.Piso.TH",
          "name": "TH",
          "package": "Piso",
          "partial": "TH",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/Piso/docs/Data-Piso-TH.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDerive partial isomorphisms for a given datatype. The resulting\n expression is a tuple with one isomorphism element for each constructor in\n the datatype.\n\u003c/p\u003e\u003cp\u003eFor example:\n\u003c/p\u003e\u003cpre\u003e nothing :: Piso t (Maybe a :- t)\n just    :: Piso (a :- t) (Maybe a :- t)\n (nothing, just) = $(derivePisos ''Maybe)\n\u003c/pre\u003e\u003cp\u003eDeriving isomorphisms this way requires \u003ccode\u003e-XNoMonoPatBinds\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Piso.TH",
          "name": "derivePisos",
          "package": "Piso",
          "signature": "Name -\u003e Q Exp",
          "source": "src/Data-Piso-TH.html#derivePisos",
          "type": "function"
        },
        "index": {
          "description": "Derive partial isomorphisms for given datatype The resulting expression is tuple with one isomorphism element for each constructor in the datatype For example nothing Piso Maybe just Piso Maybe nothing just derivePisos Maybe Deriving isomorphisms this way requires XNoMonoPatBinds",
          "hierarchy": "Data Piso TH",
          "module": "Data.Piso.TH",
          "name": "derivePisos",
          "normalized": "Name-\u003eQ Exp",
          "package": "Piso",
          "partial": "Pisos",
          "signature": "Name-\u003eQ Exp",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Piso/docs/Data-Piso-TH.html#v:derivePisos"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Piso",
          "name": "Piso",
          "package": "Piso",
          "source": "src/Data-Piso.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Data Piso",
          "module": "Data.Piso",
          "name": "Piso",
          "package": "Piso",
          "partial": "Piso",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/Piso/docs/Data-Piso.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eHeterogenous stack with a head and a tail. Or: an infix way to write \u003ccode\u003e(,)\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Piso",
          "name": ":-",
          "package": "Piso",
          "source": "src/Data-Piso.html#%3A-",
          "type": "data"
        },
        "index": {
          "description": "Heterogenous stack with head and tail Or an infix way to write",
          "hierarchy": "Data Piso",
          "module": "Data.Piso",
          "name": ":-",
          "package": "Piso",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/Piso/docs/Data-Piso.html#t::-45-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA type class that expresses that a category is able to embed \u003ccode\u003e\u003ca\u003ePiso\u003c/a\u003e\u003c/code\u003e values.\n\u003c/p\u003e",
          "module": "Data.Piso",
          "name": "FromPiso",
          "package": "Piso",
          "source": "src/Data-Piso.html#FromPiso",
          "type": "class"
        },
        "index": {
          "description": "type class that expresses that category is able to embed Piso values",
          "hierarchy": "Data Piso",
          "module": "Data.Piso",
          "name": "FromPiso",
          "package": "Piso",
          "partial": "From Piso",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/Piso/docs/Data-Piso.html#t:FromPiso"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eBidirectional isomorphism that is partial in the backward direction.\n\u003c/p\u003e\u003cp\u003eThis can be used to express constructor-deconstructor pairs. For example:\n\u003c/p\u003e\u003cpre\u003e nil :: Piso t ([a] :- t)\n nil = Piso f g\n   where\n     f        t  = [] :- t\n     g ([] :- t) = Just t\n     g _         = Nothing\n\n cons :: Piso (a :- [a] :- t) ([a] :- t)\n cons = Piso f g\n   where\n     f (x :- xs  :- t) = (x : xs) :- t\n     g ((x : xs) :- t) = Just (x :- xs :- t)\n     g _               = Nothing\n\u003c/pre\u003e\u003cp\u003eHere \u003ccode\u003e\u003ca\u003e:-\u003c/a\u003e\u003c/code\u003e can be read as 'cons', forming a stack of values. For example,\n \u003ccode\u003enil\u003c/code\u003e pushes \u003ccode\u003e[]\u003c/code\u003e onto the stack; or, in the backward direction, tries to\n remove \u003ccode\u003e[]\u003c/code\u003e from the stack. Representing constructor-destructor pairs as\n stack manipulators allows them to be composed more easily.\n\u003c/p\u003e\u003cp\u003eModule \u003ccode\u003eData.Piso.Common\u003c/code\u003e contains \u003ccode\u003ePiso\u003c/code\u003es for some common datatypes.\n\u003c/p\u003e\u003cp\u003eModules \u003ccode\u003eData.Piso.Generic\u003c/code\u003e and \u003ccode\u003eData.Piso.TH\u003c/code\u003e offer generic ways of deriving \u003ccode\u003ePiso\u003c/code\u003es for custom datatypes.\n\u003c/p\u003e",
          "module": "Data.Piso",
          "name": "Piso",
          "package": "Piso",
          "source": "src/Data-Piso.html#Piso",
          "type": "data"
        },
        "index": {
          "description": "Bidirectional isomorphism that is partial in the backward direction This can be used to express constructor-deconstructor pairs For example nil Piso nil Piso where Just Nothing cons Piso cons Piso where xs xs xs Just xs Nothing Here can be read as cons forming stack of values For example nil pushes onto the stack or in the backward direction tries to remove from the stack Representing constructor-destructor pairs as stack manipulators allows them to be composed more easily Module Data.Piso.Common contains Piso for some common datatypes Modules Data.Piso.Generic and Data.Piso.TH offer generic ways of deriving Piso for custom datatypes",
          "hierarchy": "Data Piso",
          "module": "Data.Piso",
          "name": "Piso",
          "package": "Piso",
          "partial": "Piso",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/Piso/docs/Data-Piso.html#t:Piso"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Piso",
          "name": ":-",
          "package": "Piso",
          "signature": "h :- t",
          "source": "src/Data-Piso.html#%3A-",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Piso",
          "module": "Data.Piso",
          "name": ":-",
          "package": "Piso",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Piso/docs/Data-Piso.html#v::-45-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Piso",
          "name": "Piso",
          "package": "Piso",
          "signature": "Piso (a -\u003e b) (b -\u003e Maybe a)",
          "source": "src/Data-Piso.html#Piso",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Piso",
          "module": "Data.Piso",
          "name": "Piso",
          "normalized": "Piso(a-\u003eb)(b-\u003eMaybe a)",
          "package": "Piso",
          "partial": "Piso",
          "signature": "Piso(a-\u003eb)(b-\u003eMaybe a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Piso/docs/Data-Piso.html#v:Piso"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eApply an isomorphism in backward direction.\n\u003c/p\u003e",
          "module": "Data.Piso",
          "name": "backward",
          "package": "Piso",
          "signature": "Piso a b -\u003e b -\u003e Maybe a",
          "source": "src/Data-Piso.html#backward",
          "type": "function"
        },
        "index": {
          "description": "Apply an isomorphism in backward direction",
          "hierarchy": "Data Piso",
          "module": "Data.Piso",
          "name": "backward",
          "normalized": "Piso a b-\u003eb-\u003eMaybe a",
          "package": "Piso",
          "signature": "Piso a b-\u003eb-\u003eMaybe a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Piso/docs/Data-Piso.html#v:backward"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eApply an isomorphism in forward direction.\n\u003c/p\u003e",
          "module": "Data.Piso",
          "name": "forward",
          "package": "Piso",
          "signature": "Piso a b -\u003e a -\u003e b",
          "source": "src/Data-Piso.html#forward",
          "type": "function"
        },
        "index": {
          "description": "Apply an isomorphism in forward direction",
          "hierarchy": "Data Piso",
          "module": "Data.Piso",
          "name": "forward",
          "normalized": "Piso a b-\u003ea-\u003eb",
          "package": "Piso",
          "signature": "Piso a b-\u003ea-\u003eb",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Piso/docs/Data-Piso.html#v:forward"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Piso",
          "name": "fromPiso",
          "package": "Piso",
          "signature": "Piso a b -\u003e cat a b",
          "source": "src/Data-Piso.html#fromPiso",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Piso",
          "module": "Data.Piso",
          "name": "fromPiso",
          "normalized": "Piso a b-\u003ec a b",
          "package": "Piso",
          "partial": "Piso",
          "signature": "Piso a b-\u003ecat a b",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/Piso/docs/Data-Piso.html#v:fromPiso"
      }
    }
  ]
]