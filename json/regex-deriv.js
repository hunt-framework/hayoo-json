[
  {
    "cmd": "delete-by-query",
    "query": {
      "contexts": [
        "package"
      ],
      "query": {
        "op": "case",
        "type": "word",
        "word": "regex-deriv"
      },
      "type": "context"
    }
  },
  [
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.Deriv.ByteString.BitCode",
          "name": "BitCode",
          "package": "regex-deriv",
          "source": "src/Text-Regex-Deriv-ByteString-BitCode.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Text Regex Deriv ByteString BitCode",
          "module": "Text.Regex.Deriv.ByteString.BitCode",
          "name": "BitCode",
          "package": "regex-deriv",
          "partial": "Bit Code",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/regex-deriv/docs/Text-Regex-Deriv-ByteString-BitCode.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eControl whether the pattern is multiline or case-sensitive like Text.Regex and whether to\n capture the subgroups (1, 2, etc).  Controls enabling extra anchor syntax.\n\u003c/p\u003e",
          "module": "Text.Regex.Deriv.ByteString.BitCode",
          "name": "CompOption",
          "package": "regex-deriv",
          "source": "src/Text-Regex-Deriv-ByteString-BitCode.html#CompOption",
          "type": "data"
        },
        "index": {
          "description": "Control whether the pattern is multiline or case-sensitive like Text.Regex and whether to capture the subgroups etc Controls enabling extra anchor syntax",
          "hierarchy": "Text Regex Deriv ByteString BitCode",
          "module": "Text.Regex.Deriv.ByteString.BitCode",
          "name": "CompOption",
          "package": "regex-deriv",
          "partial": "Comp Option",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/regex-deriv/docs/Text-Regex-Deriv-ByteString-BitCode.html#t:CompOption"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.Deriv.ByteString.BitCode",
          "name": "ExecOption",
          "package": "regex-deriv",
          "source": "src/Text-Regex-Deriv-ByteString-BitCode.html#ExecOption",
          "type": "data"
        },
        "index": {
          "hierarchy": "Text Regex Deriv ByteString BitCode",
          "module": "Text.Regex.Deriv.ByteString.BitCode",
          "name": "ExecOption",
          "package": "regex-deriv",
          "partial": "Exec Option",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/regex-deriv/docs/Text-Regex-Deriv-ByteString-BitCode.html#t:ExecOption"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.Deriv.ByteString.BitCode",
          "name": "Regex",
          "package": "regex-deriv",
          "source": "src/Text-Regex-Deriv-ByteString-BitCode.html#Regex",
          "type": "type"
        },
        "index": {
          "hierarchy": "Text Regex Deriv ByteString BitCode",
          "module": "Text.Regex.Deriv.ByteString.BitCode",
          "name": "Regex",
          "package": "regex-deriv",
          "partial": "Regex",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/regex-deriv/docs/Text-Regex-Deriv-ByteString-BitCode.html#t:Regex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.Deriv.ByteString.BitCode",
          "name": "CompOption",
          "package": "regex-deriv",
          "signature": "CompOption",
          "source": "src/Text-Regex-Deriv-ByteString-BitCode.html#CompOption",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex Deriv ByteString BitCode",
          "module": "Text.Regex.Deriv.ByteString.BitCode",
          "name": "CompOption",
          "package": "regex-deriv",
          "partial": "Comp Option",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-deriv/docs/Text-Regex-Deriv-ByteString-BitCode.html#v:CompOption"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.Deriv.ByteString.BitCode",
          "name": "ExecOption",
          "package": "regex-deriv",
          "signature": "ExecOption",
          "source": "src/Text-Regex-Deriv-ByteString-BitCode.html#ExecOption",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex Deriv ByteString BitCode",
          "module": "Text.Regex.Deriv.ByteString.BitCode",
          "name": "ExecOption",
          "package": "regex-deriv",
          "partial": "Exec Option",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-deriv/docs/Text-Regex-Deriv-ByteString-BitCode.html#v:ExecOption"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTrue by default.  Set to False to improve speed (and space).\n\u003c/p\u003e",
          "module": "Text.Regex.Deriv.ByteString.BitCode",
          "name": "captureGroups",
          "package": "regex-deriv",
          "signature": "Bool",
          "source": "src/Text-Regex-Deriv-ByteString-BitCode.html#ExecOption",
          "type": "function"
        },
        "index": {
          "description": "True by default Set to False to improve speed and space",
          "hierarchy": "Text Regex Deriv ByteString BitCode",
          "module": "Text.Regex.Deriv.ByteString.BitCode",
          "name": "captureGroups",
          "package": "regex-deriv",
          "partial": "Groups",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-deriv/docs/Text-Regex-Deriv-ByteString-BitCode.html#v:captureGroups"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTrue in blankCompOpt and defaultCompOpt\n\u003c/p\u003e",
          "module": "Text.Regex.Deriv.ByteString.BitCode",
          "name": "caseSensitive",
          "package": "regex-deriv",
          "signature": "Bool",
          "source": "src/Text-Regex-Deriv-ByteString-BitCode.html#CompOption",
          "type": "function"
        },
        "index": {
          "description": "True in blankCompOpt and defaultCompOpt",
          "hierarchy": "Text Regex Deriv ByteString BitCode",
          "module": "Text.Regex.Deriv.ByteString.BitCode",
          "name": "caseSensitive",
          "package": "regex-deriv",
          "partial": "Sensitive",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-deriv/docs/Text-Regex-Deriv-ByteString-BitCode.html#v:caseSensitive"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Text.Regex.Deriv.ByteString.BitCode\",\"Text.Regex.Deriv.ByteString.Posix\",\"Text.Regex.Deriv.ByteString\"]",
          "name": "compile",
          "package": "regex-deriv",
          "signature": "CompOption-\u003e ExecOption-\u003e ByteString-\u003e Either String Regex",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/regex-deriv/docs/Text-Regex-Deriv-ByteString-BitCode.html#v:compile\",\"http://hackage.haskell.org/package/regex-deriv/docs/Text-Regex-Deriv-ByteString-Posix.html#v:compile\",\"http://hackage.haskell.org/package/regex-deriv/docs/Text-Regex-Deriv-ByteString.html#v:compile\"]"
        },
        "index": {
          "hierarchy": "Text Regex Deriv ByteString BitCode",
          "module": "Text.Regex.Deriv.ByteString.BitCode",
          "name": "compile",
          "normalized": "CompOption-\u003eExecOption-\u003eByteString-\u003eEither String Regex",
          "package": "regex-deriv",
          "signature": "CompOption-\u003eExecOption-\u003eByteString-\u003eEither String Regex",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-deriv/docs/Text-Regex-Deriv-ByteString-BitCode.html#v:compile"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Text.Regex.Deriv.ByteString.BitCode\",\"Text.Regex.Deriv.ByteString.Posix\",\"Text.Regex.Deriv.ByteString\"]",
          "name": "defaultCompOpt",
          "package": "regex-deriv",
          "signature": "compOpt",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/regex-deriv/docs/Text-Regex-Deriv-ByteString-BitCode.html#v:defaultCompOpt\",\"http://hackage.haskell.org/package/regex-deriv/docs/Text-Regex-Deriv-ByteString-Posix.html#v:defaultCompOpt\",\"http://hackage.haskell.org/package/regex-deriv/docs/Text-Regex-Deriv-ByteString.html#v:defaultCompOpt\"]"
        },
        "index": {
          "hierarchy": "Text Regex Deriv ByteString BitCode",
          "module": "Text.Regex.Deriv.ByteString.BitCode",
          "name": "defaultCompOpt",
          "package": "regex-deriv",
          "partial": "Comp Opt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-deriv/docs/Text-Regex-Deriv-ByteString-BitCode.html#v:defaultCompOpt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Text.Regex.Deriv.ByteString.BitCode\",\"Text.Regex.Deriv.ByteString.Posix\",\"Text.Regex.Deriv.ByteString\"]",
          "name": "defaultExecOpt",
          "package": "regex-deriv",
          "signature": "execOpt",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/regex-deriv/docs/Text-Regex-Deriv-ByteString-BitCode.html#v:defaultExecOpt\",\"http://hackage.haskell.org/package/regex-deriv/docs/Text-Regex-Deriv-ByteString-Posix.html#v:defaultExecOpt\",\"http://hackage.haskell.org/package/regex-deriv/docs/Text-Regex-Deriv-ByteString.html#v:defaultExecOpt\"]"
        },
        "index": {
          "hierarchy": "Text Regex Deriv ByteString BitCode",
          "module": "Text.Regex.Deriv.ByteString.BitCode",
          "name": "defaultExecOpt",
          "package": "regex-deriv",
          "partial": "Exec Opt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-deriv/docs/Text-Regex-Deriv-ByteString-BitCode.html#v:defaultExecOpt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Text.Regex.Deriv.ByteString.BitCode\",\"Text.Regex.Deriv.ByteString.Posix\",\"Text.Regex.Deriv.ByteString\"]",
          "name": "execute",
          "package": "regex-deriv",
          "signature": "Regex-\u003e ByteString-\u003e Either String (Maybe Env)",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/regex-deriv/docs/Text-Regex-Deriv-ByteString-BitCode.html#v:execute\",\"http://hackage.haskell.org/package/regex-deriv/docs/Text-Regex-Deriv-ByteString-Posix.html#v:execute\",\"http://hackage.haskell.org/package/regex-deriv/docs/Text-Regex-Deriv-ByteString.html#v:execute\"]"
        },
        "index": {
          "hierarchy": "Text Regex Deriv ByteString BitCode",
          "module": "Text.Regex.Deriv.ByteString.BitCode",
          "name": "execute",
          "normalized": "Regex-\u003eByteString-\u003eEither String(Maybe Env)",
          "package": "regex-deriv",
          "signature": "Regex-\u003eByteString-\u003eEither String(Maybe Env)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-deriv/docs/Text-Regex-Deriv-ByteString-BitCode.html#v:execute"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFalse by default.  This is POSIX correct but it takes space and is slower.\n Setting this to true will improve performance, and should be done\n if you plan to set the captureGroups execoption to False.\n\u003c/p\u003e",
          "module": "Text.Regex.Deriv.ByteString.BitCode",
          "name": "lastStarGreedy",
          "package": "regex-deriv",
          "signature": "Bool",
          "source": "src/Text-Regex-Deriv-ByteString-BitCode.html#CompOption",
          "type": "function"
        },
        "index": {
          "description": "False by default This is POSIX correct but it takes space and is slower Setting this to true will improve performance and should be done if you plan to set the captureGroups execoption to False",
          "hierarchy": "Text Regex Deriv ByteString BitCode",
          "module": "Text.Regex.Deriv.ByteString.BitCode",
          "name": "lastStarGreedy",
          "package": "regex-deriv",
          "partial": "Star Greedy",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-deriv/docs/Text-Regex-Deriv-ByteString-BitCode.html#v:lastStarGreedy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFalse in blankCompOpt, True in defaultCompOpt. Compile for\n  newline-sensitive matching.  \u003ca\u003eBy default, newline is a completely ordinary\n  character with no special meaning in either REs or strings.  With this flag,\n  inverted bracket expressions and . never match newline, a ^ anchor matches the\n  null string after any newline in the string in addition to its normal\n  function, and the $ anchor matches the null string before any newline in the\n  string in addition to its normal function.\u003c/a\u003e \n\u003c/p\u003e",
          "module": "Text.Regex.Deriv.ByteString.BitCode",
          "name": "multiline",
          "package": "regex-deriv",
          "signature": "Bool",
          "source": "src/Text-Regex-Deriv-ByteString-BitCode.html#CompOption",
          "type": "function"
        },
        "index": {
          "description": "False in blankCompOpt True in defaultCompOpt Compile for newline-sensitive matching By default newline is completely ordinary character with no special meaning in either REs or strings With this flag inverted bracket expressions and never match newline anchor matches the null string after any newline in the string in addition to its normal function and the anchor matches the null string before any newline in the string in addition to its normal function",
          "hierarchy": "Text Regex Deriv ByteString BitCode",
          "module": "Text.Regex.Deriv.ByteString.BitCode",
          "name": "multiline",
          "package": "regex-deriv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-deriv/docs/Text-Regex-Deriv-ByteString-BitCode.html#v:multiline"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFalse in blankCompOpt, True in defaultCompOpt. Add the extended non-POSIX syntax described in \u003ca\u003eText.Regex.TDFA\u003c/a\u003e haddock documentation.\n\u003c/p\u003e",
          "module": "Text.Regex.Deriv.ByteString.BitCode",
          "name": "newSyntax",
          "package": "regex-deriv",
          "signature": "Bool",
          "source": "src/Text-Regex-Deriv-ByteString-BitCode.html#CompOption",
          "type": "function"
        },
        "index": {
          "description": "False in blankCompOpt True in defaultCompOpt Add the extended non-POSIX syntax described in Text.Regex.TDFA haddock documentation",
          "hierarchy": "Text Regex Deriv ByteString BitCode",
          "module": "Text.Regex.Deriv.ByteString.BitCode",
          "name": "newSyntax",
          "package": "regex-deriv",
          "partial": "Syntax",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-deriv/docs/Text-Regex-Deriv-ByteString-BitCode.html#v:newSyntax"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Text.Regex.Deriv.ByteString.BitCode\",\"Text.Regex.Deriv.ByteString.Posix\",\"Text.Regex.Deriv.ByteString\"]",
          "name": "regexec",
          "package": "regex-deriv",
          "signature": "Regex-\u003e ByteString-\u003e Either String (Maybe (ByteString, ByteString, ByteString, [ByteString]))",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/regex-deriv/docs/Text-Regex-Deriv-ByteString-BitCode.html#v:regexec\",\"http://hackage.haskell.org/package/regex-deriv/docs/Text-Regex-Deriv-ByteString-Posix.html#v:regexec\",\"http://hackage.haskell.org/package/regex-deriv/docs/Text-Regex-Deriv-ByteString.html#v:regexec\"]"
        },
        "index": {
          "hierarchy": "Text Regex Deriv ByteString BitCode",
          "module": "Text.Regex.Deriv.ByteString.BitCode",
          "name": "regexec",
          "normalized": "Regex-\u003eByteString-\u003eEither String(Maybe(ByteString,ByteString,ByteString,[ByteString]))",
          "package": "regex-deriv",
          "signature": "Regex-\u003eByteString-\u003eEither String(Maybe(ByteString,ByteString,ByteString,[ByteString]))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-deriv/docs/Text-Regex-Deriv-ByteString-BitCode.html#v:regexec"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTrue (and therefore Right associative) in blankCompOpt and defaultCompOpt\n\u003c/p\u003e",
          "module": "Text.Regex.Deriv.ByteString.BitCode",
          "name": "rightAssoc",
          "package": "regex-deriv",
          "signature": "Bool",
          "source": "src/Text-Regex-Deriv-ByteString-BitCode.html#CompOption",
          "type": "function"
        },
        "index": {
          "description": "True and therefore Right associative in blankCompOpt and defaultCompOpt",
          "hierarchy": "Text Regex Deriv ByteString BitCode",
          "module": "Text.Regex.Deriv.ByteString.BitCode",
          "name": "rightAssoc",
          "package": "regex-deriv",
          "partial": "Assoc",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-deriv/docs/Text-Regex-Deriv-ByteString-BitCode.html#v:rightAssoc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.Deriv.ByteString.Posix",
          "name": "Posix",
          "package": "regex-deriv",
          "source": "src/Text-Regex-Deriv-ByteString-Posix.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Text Regex Deriv ByteString Posix",
          "module": "Text.Regex.Deriv.ByteString.Posix",
          "name": "Posix",
          "package": "regex-deriv",
          "partial": "Posix",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/regex-deriv/docs/Text-Regex-Deriv-ByteString-Posix.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eControl whether the pattern is multiline or case-sensitive like Text.Regex and whether to\n capture the subgroups (1, 2, etc).  Controls enabling extra anchor syntax.\n\u003c/p\u003e",
          "module": "Text.Regex.Deriv.ByteString.Posix",
          "name": "CompOption",
          "package": "regex-deriv",
          "source": "src/Text-Regex-Deriv-ByteString-Posix.html#CompOption",
          "type": "data"
        },
        "index": {
          "description": "Control whether the pattern is multiline or case-sensitive like Text.Regex and whether to capture the subgroups etc Controls enabling extra anchor syntax",
          "hierarchy": "Text Regex Deriv ByteString Posix",
          "module": "Text.Regex.Deriv.ByteString.Posix",
          "name": "CompOption",
          "package": "regex-deriv",
          "partial": "Comp Option",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/regex-deriv/docs/Text-Regex-Deriv-ByteString-Posix.html#t:CompOption"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.Deriv.ByteString.Posix",
          "name": "ExecOption",
          "package": "regex-deriv",
          "source": "src/Text-Regex-Deriv-ByteString-Posix.html#ExecOption",
          "type": "data"
        },
        "index": {
          "hierarchy": "Text Regex Deriv ByteString Posix",
          "module": "Text.Regex.Deriv.ByteString.Posix",
          "name": "ExecOption",
          "package": "regex-deriv",
          "partial": "Exec Option",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/regex-deriv/docs/Text-Regex-Deriv-ByteString-Posix.html#t:ExecOption"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe Deriv backend spepcific \u003ccode\u003e\u003ca\u003eRegex\u003c/a\u003e\u003c/code\u003e type\n | the IntMap keeps track of the auxillary binder generated because of posix matching, i.e. all sub expressions need to be tag\n | the FollowBy keeps track of the order of the pattern binder \n\u003c/p\u003e",
          "module": "Text.Regex.Deriv.ByteString.Posix",
          "name": "Regex",
          "package": "regex-deriv",
          "source": "src/Text-Regex-Deriv-ByteString-Posix.html#Regex",
          "type": "type"
        },
        "index": {
          "description": "The Deriv backend spepcific Regex type the IntMap keeps track of the auxillary binder generated because of posix matching i.e all sub expressions need to be tag the FollowBy keeps track of the order of the pattern binder",
          "hierarchy": "Text Regex Deriv ByteString Posix",
          "module": "Text.Regex.Deriv.ByteString.Posix",
          "name": "Regex",
          "package": "regex-deriv",
          "partial": "Regex",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/regex-deriv/docs/Text-Regex-Deriv-ByteString-Posix.html#t:Regex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Text.Regex.Deriv.ByteString.Posix\",\"Text.Regex.Deriv.ByteString\"]",
          "name": "CompOption",
          "package": "regex-deriv",
          "signature": "CompOption",
          "source": "src/Text-Regex-Deriv-ByteString-Posix.html#CompOption",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/regex-deriv/docs/Text-Regex-Deriv-ByteString-Posix.html#v:CompOption\",\"http://hackage.haskell.org/package/regex-deriv/docs/Text-Regex-Deriv-ByteString.html#v:CompOption\"]"
        },
        "index": {
          "hierarchy": "Text Regex Deriv ByteString Posix",
          "module": "Text.Regex.Deriv.ByteString.Posix",
          "name": "CompOption",
          "package": "regex-deriv",
          "partial": "Comp Option",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-deriv/docs/Text-Regex-Deriv-ByteString-Posix.html#v:CompOption"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Text.Regex.Deriv.ByteString.Posix\",\"Text.Regex.Deriv.ByteString\"]",
          "name": "ExecOption",
          "package": "regex-deriv",
          "signature": "ExecOption",
          "source": "src/Text-Regex-Deriv-ByteString-Posix.html#ExecOption",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/regex-deriv/docs/Text-Regex-Deriv-ByteString-Posix.html#v:ExecOption\",\"http://hackage.haskell.org/package/regex-deriv/docs/Text-Regex-Deriv-ByteString.html#v:ExecOption\"]"
        },
        "index": {
          "hierarchy": "Text Regex Deriv ByteString Posix",
          "module": "Text.Regex.Deriv.ByteString.Posix",
          "name": "ExecOption",
          "package": "regex-deriv",
          "partial": "Exec Option",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-deriv/docs/Text-Regex-Deriv-ByteString-Posix.html#v:ExecOption"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTrue by default.  Set to False to improve speed (and space).\n\u003c/p\u003e",
          "module": "[\"Text.Regex.Deriv.ByteString.Posix\",\"Text.Regex.Deriv.ByteString\"]",
          "name": "captureGroups",
          "package": "regex-deriv",
          "signature": "Bool",
          "source": "src/Text-Regex-Deriv-ByteString-Posix.html#ExecOption",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/regex-deriv/docs/Text-Regex-Deriv-ByteString-Posix.html#v:captureGroups\",\"http://hackage.haskell.org/package/regex-deriv/docs/Text-Regex-Deriv-ByteString.html#v:captureGroups\"]"
        },
        "index": {
          "description": "True by default Set to False to improve speed and space",
          "hierarchy": "Text Regex Deriv ByteString Posix",
          "module": "Text.Regex.Deriv.ByteString.Posix",
          "name": "captureGroups",
          "package": "regex-deriv",
          "partial": "Groups",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-deriv/docs/Text-Regex-Deriv-ByteString-Posix.html#v:captureGroups"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTrue in blankCompOpt and defaultCompOpt\n\u003c/p\u003e",
          "module": "[\"Text.Regex.Deriv.ByteString.Posix\",\"Text.Regex.Deriv.ByteString\"]",
          "name": "caseSensitive",
          "package": "regex-deriv",
          "signature": "Bool",
          "source": "src/Text-Regex-Deriv-ByteString-Posix.html#CompOption",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/regex-deriv/docs/Text-Regex-Deriv-ByteString-Posix.html#v:caseSensitive\",\"http://hackage.haskell.org/package/regex-deriv/docs/Text-Regex-Deriv-ByteString.html#v:caseSensitive\"]"
        },
        "index": {
          "description": "True in blankCompOpt and defaultCompOpt",
          "hierarchy": "Text Regex Deriv ByteString Posix",
          "module": "Text.Regex.Deriv.ByteString.Posix",
          "name": "caseSensitive",
          "package": "regex-deriv",
          "partial": "Sensitive",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-deriv/docs/Text-Regex-Deriv-ByteString-Posix.html#v:caseSensitive"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFalse by default.  This is POSIX correct but it takes space and is slower.\n Setting this to true will improve performance, and should be done\n if you plan to set the captureGroups execoption to False.\n\u003c/p\u003e",
          "module": "[\"Text.Regex.Deriv.ByteString.Posix\",\"Text.Regex.Deriv.ByteString\"]",
          "name": "lastStarGreedy",
          "package": "regex-deriv",
          "signature": "Bool",
          "source": "src/Text-Regex-Deriv-ByteString-Posix.html#CompOption",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/regex-deriv/docs/Text-Regex-Deriv-ByteString-Posix.html#v:lastStarGreedy\",\"http://hackage.haskell.org/package/regex-deriv/docs/Text-Regex-Deriv-ByteString.html#v:lastStarGreedy\"]"
        },
        "index": {
          "description": "False by default This is POSIX correct but it takes space and is slower Setting this to true will improve performance and should be done if you plan to set the captureGroups execoption to False",
          "hierarchy": "Text Regex Deriv ByteString Posix",
          "module": "Text.Regex.Deriv.ByteString.Posix",
          "name": "lastStarGreedy",
          "package": "regex-deriv",
          "partial": "Star Greedy",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-deriv/docs/Text-Regex-Deriv-ByteString-Posix.html#v:lastStarGreedy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFalse in blankCompOpt, True in defaultCompOpt. Compile for\n    newline-sensitive matching.  \u003ca\u003eBy default, newline is a completely ordinary\n    character with no special meaning in either REs or strings.  With this flag,\n    inverted bracket expressions and . never match newline, a ^ anchor matches the\n    null string after any newline in the string in addition to its normal\n    function, and the $ anchor matches the null string before any newline in the\n    string in addition to its normal function.\u003c/a\u003e \n\u003c/p\u003e",
          "module": "[\"Text.Regex.Deriv.ByteString.Posix\",\"Text.Regex.Deriv.ByteString\"]",
          "name": "multiline",
          "package": "regex-deriv",
          "signature": "Bool",
          "source": "src/Text-Regex-Deriv-ByteString-Posix.html#CompOption",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/regex-deriv/docs/Text-Regex-Deriv-ByteString-Posix.html#v:multiline\",\"http://hackage.haskell.org/package/regex-deriv/docs/Text-Regex-Deriv-ByteString.html#v:multiline\"]"
        },
        "index": {
          "description": "False in blankCompOpt True in defaultCompOpt Compile for newline-sensitive matching By default newline is completely ordinary character with no special meaning in either REs or strings With this flag inverted bracket expressions and never match newline anchor matches the null string after any newline in the string in addition to its normal function and the anchor matches the null string before any newline in the string in addition to its normal function",
          "hierarchy": "Text Regex Deriv ByteString Posix",
          "module": "Text.Regex.Deriv.ByteString.Posix",
          "name": "multiline",
          "package": "regex-deriv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-deriv/docs/Text-Regex-Deriv-ByteString-Posix.html#v:multiline"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFalse in blankCompOpt, True in defaultCompOpt. Add the extended non-POSIX syntax described in \u003ca\u003eText.Regex.TDFA\u003c/a\u003e haddock documentation.\n\u003c/p\u003e",
          "module": "[\"Text.Regex.Deriv.ByteString.Posix\",\"Text.Regex.Deriv.ByteString\"]",
          "name": "newSyntax",
          "package": "regex-deriv",
          "signature": "Bool",
          "source": "src/Text-Regex-Deriv-ByteString-Posix.html#CompOption",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/regex-deriv/docs/Text-Regex-Deriv-ByteString-Posix.html#v:newSyntax\",\"http://hackage.haskell.org/package/regex-deriv/docs/Text-Regex-Deriv-ByteString.html#v:newSyntax\"]"
        },
        "index": {
          "description": "False in blankCompOpt True in defaultCompOpt Add the extended non-POSIX syntax described in Text.Regex.TDFA haddock documentation",
          "hierarchy": "Text Regex Deriv ByteString Posix",
          "module": "Text.Regex.Deriv.ByteString.Posix",
          "name": "newSyntax",
          "package": "regex-deriv",
          "partial": "Syntax",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-deriv/docs/Text-Regex-Deriv-ByteString-Posix.html#v:newSyntax"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTrue (and therefore Right associative) in blankCompOpt and defaultCompOpt\n\u003c/p\u003e",
          "module": "[\"Text.Regex.Deriv.ByteString.Posix\",\"Text.Regex.Deriv.ByteString\"]",
          "name": "rightAssoc",
          "package": "regex-deriv",
          "signature": "Bool",
          "source": "src/Text-Regex-Deriv-ByteString-Posix.html#CompOption",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/regex-deriv/docs/Text-Regex-Deriv-ByteString-Posix.html#v:rightAssoc\",\"http://hackage.haskell.org/package/regex-deriv/docs/Text-Regex-Deriv-ByteString.html#v:rightAssoc\"]"
        },
        "index": {
          "description": "True and therefore Right associative in blankCompOpt and defaultCompOpt",
          "hierarchy": "Text Regex Deriv ByteString Posix",
          "module": "Text.Regex.Deriv.ByteString.Posix",
          "name": "rightAssoc",
          "package": "regex-deriv",
          "partial": "Assoc",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-deriv/docs/Text-Regex-Deriv-ByteString-Posix.html#v:rightAssoc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.Deriv.ByteString",
          "name": "ByteString",
          "package": "regex-deriv",
          "source": "src/Text-Regex-Deriv-ByteString.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Text Regex Deriv ByteString",
          "module": "Text.Regex.Deriv.ByteString",
          "name": "ByteString",
          "package": "regex-deriv",
          "partial": "Byte String",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/regex-deriv/docs/Text-Regex-Deriv-ByteString.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eControl whether the pattern is multiline or case-sensitive like Text.Regex and whether to\n capture the subgroups (1, 2, etc).  Controls enabling extra anchor syntax.\n\u003c/p\u003e",
          "module": "Text.Regex.Deriv.ByteString",
          "name": "CompOption",
          "package": "regex-deriv",
          "source": "src/Text-Regex-Deriv-ByteString-Posix.html#CompOption",
          "type": "data"
        },
        "index": {
          "description": "Control whether the pattern is multiline or case-sensitive like Text.Regex and whether to capture the subgroups etc Controls enabling extra anchor syntax",
          "hierarchy": "Text Regex Deriv ByteString",
          "module": "Text.Regex.Deriv.ByteString",
          "name": "CompOption",
          "package": "regex-deriv",
          "partial": "Comp Option",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/regex-deriv/docs/Text-Regex-Deriv-ByteString.html#t:CompOption"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.Deriv.ByteString",
          "name": "ExecOption",
          "package": "regex-deriv",
          "source": "src/Text-Regex-Deriv-ByteString-Posix.html#ExecOption",
          "type": "data"
        },
        "index": {
          "hierarchy": "Text Regex Deriv ByteString",
          "module": "Text.Regex.Deriv.ByteString",
          "name": "ExecOption",
          "package": "regex-deriv",
          "partial": "Exec Option",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/regex-deriv/docs/Text-Regex-Deriv-ByteString.html#t:ExecOption"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe Deriv backend spepcific \u003ccode\u003e\u003ca\u003eRegex\u003c/a\u003e\u003c/code\u003e type\n | the IntMap keeps track of the auxillary binder generated because of posix matching, i.e. all sub expressions need to be tag\n | the FollowBy keeps track of the order of the pattern binder \n\u003c/p\u003e",
          "module": "Text.Regex.Deriv.ByteString",
          "name": "Regex",
          "package": "regex-deriv",
          "source": "src/Text-Regex-Deriv-ByteString-Posix.html#Regex",
          "type": "type"
        },
        "index": {
          "description": "The Deriv backend spepcific Regex type the IntMap keeps track of the auxillary binder generated because of posix matching i.e all sub expressions need to be tag the FollowBy keeps track of the order of the pattern binder",
          "hierarchy": "Text Regex Deriv ByteString",
          "module": "Text.Regex.Deriv.ByteString",
          "name": "Regex",
          "package": "regex-deriv",
          "partial": "Regex",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/regex-deriv/docs/Text-Regex-Deriv-ByteString.html#t:Regex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003ethis module contains the defs of common data types and type classes\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Text.Regex.Deriv.Common",
          "name": "Common",
          "package": "regex-deriv",
          "source": "src/Text-Regex-Deriv-Common.html",
          "type": "module"
        },
        "index": {
          "description": "this module contains the defs of common data types and type classes",
          "hierarchy": "Text Regex Deriv Common",
          "module": "Text.Regex.Deriv.Common",
          "name": "Common",
          "package": "regex-deriv",
          "partial": "Common",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/regex-deriv/docs/Text-Regex-Deriv-Common.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe greediness flag\n\u003c/p\u003e",
          "module": "Text.Regex.Deriv.Common",
          "name": "GFlag",
          "package": "regex-deriv",
          "source": "src/Text-Regex-Deriv-Common.html#GFlag",
          "type": "data"
        },
        "index": {
          "description": "The greediness flag",
          "hierarchy": "Text Regex Deriv Common",
          "module": "Text.Regex.Deriv.Common",
          "name": "GFlag",
          "package": "regex-deriv",
          "partial": "GFlag",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/regex-deriv/docs/Text-Regex-Deriv-Common.html#t:GFlag"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003etest for epsilon == a\n\u003c/p\u003e",
          "module": "Text.Regex.Deriv.Common",
          "name": "IsEpsilon",
          "package": "regex-deriv",
          "source": "src/Text-Regex-Deriv-Common.html#IsEpsilon",
          "type": "class"
        },
        "index": {
          "description": "test for epsilon",
          "hierarchy": "Text Regex Deriv Common",
          "module": "Text.Regex.Deriv.Common",
          "name": "IsEpsilon",
          "package": "regex-deriv",
          "partial": "Is Epsilon",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/regex-deriv/docs/Text-Regex-Deriv-Common.html#t:IsEpsilon"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.Deriv.Common",
          "name": "IsGreedy",
          "package": "regex-deriv",
          "source": "src/Text-Regex-Deriv-Common.html#IsGreedy",
          "type": "class"
        },
        "index": {
          "hierarchy": "Text Regex Deriv Common",
          "module": "Text.Regex.Deriv.Common",
          "name": "IsGreedy",
          "package": "regex-deriv",
          "partial": "Is Greedy",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/regex-deriv/docs/Text-Regex-Deriv-Common.html#t:IsGreedy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003etest for phi == a\n\u003c/p\u003e",
          "module": "Text.Regex.Deriv.Common",
          "name": "IsPhi",
          "package": "regex-deriv",
          "source": "src/Text-Regex-Deriv-Common.html#IsPhi",
          "type": "class"
        },
        "index": {
          "description": "test for phi",
          "hierarchy": "Text Regex Deriv Common",
          "module": "Text.Regex.Deriv.Common",
          "name": "IsPhi",
          "package": "regex-deriv",
          "partial": "Is Phi",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/regex-deriv/docs/Text-Regex-Deriv-Common.html#t:IsPhi"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ea character and its index (position)\n\u003c/p\u003e",
          "module": "Text.Regex.Deriv.Common",
          "name": "Letter",
          "package": "regex-deriv",
          "source": "src/Text-Regex-Deriv-Common.html#Letter",
          "type": "type"
        },
        "index": {
          "description": "character and its index position",
          "hierarchy": "Text Regex Deriv Common",
          "module": "Text.Regex.Deriv.Common",
          "name": "Letter",
          "package": "regex-deriv",
          "partial": "Letter",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/regex-deriv/docs/Text-Regex-Deriv-Common.html#t:Letter"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003etest for 'epsilon in a' epsilon-possession\n\u003c/p\u003e",
          "module": "Text.Regex.Deriv.Common",
          "name": "PosEpsilon",
          "package": "regex-deriv",
          "source": "src/Text-Regex-Deriv-Common.html#PosEpsilon",
          "type": "class"
        },
        "index": {
          "description": "test for epsilon in epsilon-possession",
          "hierarchy": "Text Regex Deriv Common",
          "module": "Text.Regex.Deriv.Common",
          "name": "PosEpsilon",
          "package": "regex-deriv",
          "partial": "Pos Epsilon",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/regex-deriv/docs/Text-Regex-Deriv-Common.html#t:PosEpsilon"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e(sub)words represent by range\n type Range  = (Int,Int)      \n\u003c/p\u003e",
          "module": "Text.Regex.Deriv.Common",
          "name": "Range",
          "package": "regex-deriv",
          "source": "src/Text-Regex-Deriv-Common.html#Range",
          "type": "data"
        },
        "index": {
          "description": "sub words represent by range type Range Int Int",
          "hierarchy": "Text Regex Deriv Common",
          "module": "Text.Regex.Deriv.Common",
          "name": "Range",
          "package": "regex-deriv",
          "partial": "Range",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/regex-deriv/docs/Text-Regex-Deriv-Common.html#t:Range"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.Deriv.Common",
          "name": "Simplifiable",
          "package": "regex-deriv",
          "source": "src/Text-Regex-Deriv-Common.html#Simplifiable",
          "type": "class"
        },
        "index": {
          "hierarchy": "Text Regex Deriv Common",
          "module": "Text.Regex.Deriv.Common",
          "name": "Simplifiable",
          "package": "regex-deriv",
          "partial": "Simplifiable",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/regex-deriv/docs/Text-Regex-Deriv-Common.html#t:Simplifiable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003egreedy\n\u003c/p\u003e",
          "module": "Text.Regex.Deriv.Common",
          "name": "Greedy",
          "package": "regex-deriv",
          "signature": "Greedy",
          "source": "src/Text-Regex-Deriv-Common.html#GFlag",
          "type": "function"
        },
        "index": {
          "description": "greedy",
          "hierarchy": "Text Regex Deriv Common",
          "module": "Text.Regex.Deriv.Common",
          "name": "Greedy",
          "package": "regex-deriv",
          "partial": "Greedy",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-deriv/docs/Text-Regex-Deriv-Common.html#v:Greedy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003enot greedy\n\u003c/p\u003e",
          "module": "Text.Regex.Deriv.Common",
          "name": "NotGreedy",
          "package": "regex-deriv",
          "signature": "NotGreedy",
          "source": "src/Text-Regex-Deriv-Common.html#GFlag",
          "type": "function"
        },
        "index": {
          "description": "not greedy",
          "hierarchy": "Text Regex Deriv Common",
          "module": "Text.Regex.Deriv.Common",
          "name": "NotGreedy",
          "package": "regex-deriv",
          "partial": "Not Greedy",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-deriv/docs/Text-Regex-Deriv-Common.html#v:NotGreedy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.Deriv.Common",
          "name": "Range",
          "package": "regex-deriv",
          "signature": "Range !Int !Int",
          "source": "src/Text-Regex-Deriv-Common.html#Range",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex Deriv Common",
          "module": "Text.Regex.Deriv.Common",
          "name": "Range",
          "package": "regex-deriv",
          "partial": "Range",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-deriv/docs/Text-Regex-Deriv-Common.html#v:Range"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.Deriv.Common",
          "name": "isEpsilon",
          "package": "regex-deriv",
          "signature": "a -\u003e Bool",
          "source": "src/Text-Regex-Deriv-Common.html#isEpsilon",
          "type": "method"
        },
        "index": {
          "hierarchy": "Text Regex Deriv Common",
          "module": "Text.Regex.Deriv.Common",
          "name": "isEpsilon",
          "normalized": "a-\u003eBool",
          "package": "regex-deriv",
          "partial": "Epsilon",
          "signature": "a-\u003eBool",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/regex-deriv/docs/Text-Regex-Deriv-Common.html#v:isEpsilon"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.Deriv.Common",
          "name": "isGreedy",
          "package": "regex-deriv",
          "signature": "a -\u003e Bool",
          "source": "src/Text-Regex-Deriv-Common.html#isGreedy",
          "type": "method"
        },
        "index": {
          "hierarchy": "Text Regex Deriv Common",
          "module": "Text.Regex.Deriv.Common",
          "name": "isGreedy",
          "normalized": "a-\u003eBool",
          "package": "regex-deriv",
          "partial": "Greedy",
          "signature": "a-\u003eBool",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/regex-deriv/docs/Text-Regex-Deriv-Common.html#v:isGreedy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.Deriv.Common",
          "name": "isPhi",
          "package": "regex-deriv",
          "signature": "a -\u003e Bool",
          "source": "src/Text-Regex-Deriv-Common.html#isPhi",
          "type": "method"
        },
        "index": {
          "hierarchy": "Text Regex Deriv Common",
          "module": "Text.Regex.Deriv.Common",
          "name": "isPhi",
          "normalized": "a-\u003eBool",
          "package": "regex-deriv",
          "partial": "Phi",
          "signature": "a-\u003eBool",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/regex-deriv/docs/Text-Regex-Deriv-Common.html#v:isPhi"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.Deriv.Common",
          "name": "mainBinder",
          "package": "regex-deriv",
          "signature": "Int",
          "source": "src/Text-Regex-Deriv-Common.html#mainBinder",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex Deriv Common",
          "module": "Text.Regex.Deriv.Common",
          "name": "mainBinder",
          "package": "regex-deriv",
          "partial": "Binder",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-deriv/docs/Text-Regex-Deriv-Common.html#v:mainBinder"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.Deriv.Common",
          "name": "maxRange",
          "package": "regex-deriv",
          "signature": "(a, b) -\u003e b",
          "source": "src/Text-Regex-Deriv-Common.html#maxRange",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex Deriv Common",
          "module": "Text.Regex.Deriv.Common",
          "name": "maxRange",
          "normalized": "(a,b)-\u003eb",
          "package": "regex-deriv",
          "partial": "Range",
          "signature": "(a,b)-\u003eb",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-deriv/docs/Text-Regex-Deriv-Common.html#v:maxRange"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.Deriv.Common",
          "name": "minRange",
          "package": "regex-deriv",
          "signature": "(a, b) -\u003e a",
          "source": "src/Text-Regex-Deriv-Common.html#minRange",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex Deriv Common",
          "module": "Text.Regex.Deriv.Common",
          "name": "minRange",
          "normalized": "(a,b)-\u003ea",
          "package": "regex-deriv",
          "partial": "Range",
          "signature": "(a,b)-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-deriv/docs/Text-Regex-Deriv-Common.html#v:minRange"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.Deriv.Common",
          "name": "my_hash",
          "package": "regex-deriv",
          "signature": "Int -\u003e Char -\u003e Int",
          "source": "src/Text-Regex-Deriv-Common.html#my_hash",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex Deriv Common",
          "module": "Text.Regex.Deriv.Common",
          "name": "my_hash",
          "normalized": "Int-\u003eChar-\u003eInt",
          "package": "regex-deriv",
          "signature": "Int-\u003eChar-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-deriv/docs/Text-Regex-Deriv-Common.html#v:my_hash"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.Deriv.Common",
          "name": "my_lookup",
          "package": "regex-deriv",
          "signature": "Int -\u003e Char -\u003e IntMap [Int] -\u003e [Int]",
          "source": "src/Text-Regex-Deriv-Common.html#my_lookup",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex Deriv Common",
          "module": "Text.Regex.Deriv.Common",
          "name": "my_lookup",
          "normalized": "Int-\u003eChar-\u003eIntMap[Int]-\u003e[Int]",
          "package": "regex-deriv",
          "signature": "Int-\u003eChar-\u003eIntMap[Int]-\u003e[Int]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-deriv/docs/Text-Regex-Deriv-Common.html#v:my_lookup"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eremove duplications in a list of pairs, using the first components as key.\n\u003c/p\u003e",
          "module": "Text.Regex.Deriv.Common",
          "name": "nub2",
          "package": "regex-deriv",
          "signature": "[(Int, a)] -\u003e [(Int, a)]",
          "source": "src/Text-Regex-Deriv-Common.html#nub2",
          "type": "function"
        },
        "index": {
          "description": "remove duplications in list of pairs using the first components as key",
          "hierarchy": "Text Regex Deriv Common",
          "module": "Text.Regex.Deriv.Common",
          "name": "nub2",
          "normalized": "[(Int,a)]-\u003e[(Int,a)]",
          "package": "regex-deriv",
          "signature": "[(Int,a)]-\u003e[(Int,a)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-deriv/docs/Text-Regex-Deriv-Common.html#v:nub2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.Deriv.Common",
          "name": "nub3",
          "package": "regex-deriv",
          "signature": "[(Int, a, Int)] -\u003e [(Int, a, Int)]",
          "source": "src/Text-Regex-Deriv-Common.html#nub3",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex Deriv Common",
          "module": "Text.Regex.Deriv.Common",
          "name": "nub3",
          "normalized": "[(Int,a,Int)]-\u003e[(Int,a,Int)]",
          "package": "regex-deriv",
          "signature": "[(Int,a,Int)]-\u003e[(Int,a,Int)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-deriv/docs/Text-Regex-Deriv-Common.html#v:nub3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.Deriv.Common",
          "name": "posEpsilon",
          "package": "regex-deriv",
          "signature": "a -\u003e Bool",
          "source": "src/Text-Regex-Deriv-Common.html#posEpsilon",
          "type": "method"
        },
        "index": {
          "hierarchy": "Text Regex Deriv Common",
          "module": "Text.Regex.Deriv.Common",
          "name": "posEpsilon",
          "normalized": "a-\u003eBool",
          "package": "regex-deriv",
          "partial": "Epsilon",
          "signature": "a-\u003eBool",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/regex-deriv/docs/Text-Regex-Deriv-Common.html#v:posEpsilon"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.Deriv.Common",
          "name": "preBinder",
          "package": "regex-deriv",
          "signature": "Int",
          "source": "src/Text-Regex-Deriv-Common.html#preBinder",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex Deriv Common",
          "module": "Text.Regex.Deriv.Common",
          "name": "preBinder",
          "package": "regex-deriv",
          "partial": "Binder",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-deriv/docs/Text-Regex-Deriv-Common.html#v:preBinder"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.Deriv.Common",
          "name": "preBinder_",
          "package": "regex-deriv",
          "signature": "Int",
          "source": "src/Text-Regex-Deriv-Common.html#preBinder_",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex Deriv Common",
          "module": "Text.Regex.Deriv.Common",
          "name": "preBinder_",
          "package": "regex-deriv",
          "partial": "Binder",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-deriv/docs/Text-Regex-Deriv-Common.html#v:preBinder_"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.Deriv.Common",
          "name": "range",
          "package": "regex-deriv",
          "signature": "Int -\u003e Int -\u003e Range",
          "source": "src/Text-Regex-Deriv-Common.html#range",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex Deriv Common",
          "module": "Text.Regex.Deriv.Common",
          "name": "range",
          "normalized": "Int-\u003eInt-\u003eRange",
          "package": "regex-deriv",
          "signature": "Int-\u003eInt-\u003eRange",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-deriv/docs/Text-Regex-Deriv-Common.html#v:range"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.Deriv.Common",
          "name": "simplify",
          "package": "regex-deriv",
          "signature": "a -\u003e a",
          "source": "src/Text-Regex-Deriv-Common.html#simplify",
          "type": "method"
        },
        "index": {
          "hierarchy": "Text Regex Deriv Common",
          "module": "Text.Regex.Deriv.Common",
          "name": "simplify",
          "normalized": "a-\u003ea",
          "package": "regex-deriv",
          "signature": "a-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/regex-deriv/docs/Text-Regex-Deriv-Common.html#v:simplify"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.Deriv.Common",
          "name": "subBinder",
          "package": "regex-deriv",
          "signature": "Int",
          "source": "src/Text-Regex-Deriv-Common.html#subBinder",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex Deriv Common",
          "module": "Text.Regex.Deriv.Common",
          "name": "subBinder",
          "package": "regex-deriv",
          "partial": "Binder",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-deriv/docs/Text-Regex-Deriv-Common.html#v:subBinder"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eA module that implements a dictionary/hash table\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Text.Regex.Deriv.Dictionary",
          "name": "Dictionary",
          "package": "regex-deriv",
          "source": "src/Text-Regex-Deriv-Dictionary.html",
          "type": "module"
        },
        "index": {
          "description": "module that implements dictionary hash table",
          "hierarchy": "Text Regex Deriv Dictionary",
          "module": "Text.Regex.Deriv.Dictionary",
          "name": "Dictionary",
          "package": "regex-deriv",
          "partial": "Dictionary",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/regex-deriv/docs/Text-Regex-Deriv-Dictionary.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.Deriv.Dictionary",
          "name": "Dictionary",
          "package": "regex-deriv",
          "source": "src/Text-Regex-Deriv-Dictionary.html#Dictionary",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "Text Regex Deriv Dictionary",
          "module": "Text.Regex.Deriv.Dictionary",
          "name": "Dictionary",
          "package": "regex-deriv",
          "partial": "Dictionary",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/regex-deriv/docs/Text-Regex-Deriv-Dictionary.html#t:Dictionary"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.Deriv.Dictionary",
          "name": "Key",
          "package": "regex-deriv",
          "source": "src/Text-Regex-Deriv-Dictionary.html#Key",
          "type": "class"
        },
        "index": {
          "hierarchy": "Text Regex Deriv Dictionary",
          "module": "Text.Regex.Deriv.Dictionary",
          "name": "Key",
          "package": "regex-deriv",
          "partial": "Key",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/regex-deriv/docs/Text-Regex-Deriv-Dictionary.html#t:Key"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.Deriv.Dictionary",
          "name": "Trie",
          "package": "regex-deriv",
          "source": "src/Text-Regex-Deriv-Dictionary.html#Trie",
          "type": "data"
        },
        "index": {
          "hierarchy": "Text Regex Deriv Dictionary",
          "module": "Text.Regex.Deriv.Dictionary",
          "name": "Trie",
          "package": "regex-deriv",
          "partial": "Trie",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/regex-deriv/docs/Text-Regex-Deriv-Dictionary.html#t:Trie"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.Deriv.Dictionary",
          "name": "Dictionary",
          "package": "regex-deriv",
          "signature": "Dictionary (Trie a)",
          "source": "src/Text-Regex-Deriv-Dictionary.html#Dictionary",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex Deriv Dictionary",
          "module": "Text.Regex.Deriv.Dictionary",
          "name": "Dictionary",
          "package": "regex-deriv",
          "partial": "Dictionary",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-deriv/docs/Text-Regex-Deriv-Dictionary.html#v:Dictionary"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.Deriv.Dictionary",
          "name": "Trie",
          "package": "regex-deriv",
          "signature": "Trie ![a] !(IntMap (Trie a))",
          "source": "src/Text-Regex-Deriv-Dictionary.html#Trie",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex Deriv Dictionary",
          "module": "Text.Regex.Deriv.Dictionary",
          "name": "Trie",
          "normalized": "Trie[a](IntMap(Trie a))",
          "package": "regex-deriv",
          "partial": "Trie",
          "signature": "Trie[a](IntMap(Trie a))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-deriv/docs/Text-Regex-Deriv-Dictionary.html#v:Trie"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.Deriv.Dictionary",
          "name": "empty",
          "package": "regex-deriv",
          "signature": "Dictionary a",
          "source": "src/Text-Regex-Deriv-Dictionary.html#empty",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex Deriv Dictionary",
          "module": "Text.Regex.Deriv.Dictionary",
          "name": "empty",
          "package": "regex-deriv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-deriv/docs/Text-Regex-Deriv-Dictionary.html#v:empty"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.Deriv.Dictionary",
          "name": "emptyTrie",
          "package": "regex-deriv",
          "signature": "Trie a",
          "source": "src/Text-Regex-Deriv-Dictionary.html#emptyTrie",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex Deriv Dictionary",
          "module": "Text.Regex.Deriv.Dictionary",
          "name": "emptyTrie",
          "package": "regex-deriv",
          "partial": "Trie",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-deriv/docs/Text-Regex-Deriv-Dictionary.html#v:emptyTrie"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.Deriv.Dictionary",
          "name": "fromList",
          "package": "regex-deriv",
          "signature": "[(k, a)] -\u003e Dictionary a",
          "source": "src/Text-Regex-Deriv-Dictionary.html#fromList",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex Deriv Dictionary",
          "module": "Text.Regex.Deriv.Dictionary",
          "name": "fromList",
          "normalized": "[(a,b)]-\u003eDictionary b",
          "package": "regex-deriv",
          "partial": "List",
          "signature": "[(k,a)]-\u003eDictionary a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-deriv/docs/Text-Regex-Deriv-Dictionary.html#v:fromList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.Deriv.Dictionary",
          "name": "fromListNotOverwrite",
          "package": "regex-deriv",
          "signature": "[(k, a)] -\u003e Dictionary a",
          "source": "src/Text-Regex-Deriv-Dictionary.html#fromListNotOverwrite",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex Deriv Dictionary",
          "module": "Text.Regex.Deriv.Dictionary",
          "name": "fromListNotOverwrite",
          "normalized": "[(a,b)]-\u003eDictionary b",
          "package": "regex-deriv",
          "partial": "List Not Overwrite",
          "signature": "[(k,a)]-\u003eDictionary a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-deriv/docs/Text-Regex-Deriv-Dictionary.html#v:fromListNotOverwrite"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.Deriv.Dictionary",
          "name": "hash",
          "package": "regex-deriv",
          "signature": "a -\u003e [Int]",
          "source": "src/Text-Regex-Deriv-Dictionary.html#hash",
          "type": "method"
        },
        "index": {
          "hierarchy": "Text Regex Deriv Dictionary",
          "module": "Text.Regex.Deriv.Dictionary",
          "name": "hash",
          "normalized": "a-\u003e[Int]",
          "package": "regex-deriv",
          "signature": "a-\u003e[Int]",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/regex-deriv/docs/Text-Regex-Deriv-Dictionary.html#v:hash"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.Deriv.Dictionary",
          "name": "insert",
          "package": "regex-deriv",
          "signature": "k -\u003e a -\u003e Dictionary a -\u003e Dictionary a",
          "source": "src/Text-Regex-Deriv-Dictionary.html#insert",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex Deriv Dictionary",
          "module": "Text.Regex.Deriv.Dictionary",
          "name": "insert",
          "normalized": "a-\u003eb-\u003eDictionary b-\u003eDictionary b",
          "package": "regex-deriv",
          "signature": "k-\u003ea-\u003eDictionary a-\u003eDictionary a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-deriv/docs/Text-Regex-Deriv-Dictionary.html#v:insert"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.Deriv.Dictionary",
          "name": "insertNotOverwrite",
          "package": "regex-deriv",
          "signature": "k -\u003e a -\u003e Dictionary a -\u003e Dictionary a",
          "source": "src/Text-Regex-Deriv-Dictionary.html#insertNotOverwrite",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex Deriv Dictionary",
          "module": "Text.Regex.Deriv.Dictionary",
          "name": "insertNotOverwrite",
          "normalized": "a-\u003eb-\u003eDictionary b-\u003eDictionary b",
          "package": "regex-deriv",
          "partial": "Not Overwrite",
          "signature": "k-\u003ea-\u003eDictionary a-\u003eDictionary a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-deriv/docs/Text-Regex-Deriv-Dictionary.html#v:insertNotOverwrite"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.Deriv.Dictionary",
          "name": "insertTrie",
          "package": "regex-deriv",
          "signature": "Bool -\u003e [Int] -\u003e a -\u003e Trie a -\u003e Trie a",
          "source": "src/Text-Regex-Deriv-Dictionary.html#insertTrie",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex Deriv Dictionary",
          "module": "Text.Regex.Deriv.Dictionary",
          "name": "insertTrie",
          "normalized": "Bool-\u003e[Int]-\u003ea-\u003eTrie a-\u003eTrie a",
          "package": "regex-deriv",
          "partial": "Trie",
          "signature": "Bool-\u003e[Int]-\u003ea-\u003eTrie a-\u003eTrie a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-deriv/docs/Text-Regex-Deriv-Dictionary.html#v:insertTrie"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.Deriv.Dictionary",
          "name": "isIn",
          "package": "regex-deriv",
          "signature": "k -\u003e Dictionary (k, a) -\u003e Bool",
          "source": "src/Text-Regex-Deriv-Dictionary.html#isIn",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex Deriv Dictionary",
          "module": "Text.Regex.Deriv.Dictionary",
          "name": "isIn",
          "normalized": "a-\u003eDictionary(a,b)-\u003eBool",
          "package": "regex-deriv",
          "partial": "In",
          "signature": "k-\u003eDictionary(k,a)-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-deriv/docs/Text-Regex-Deriv-Dictionary.html#v:isIn"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.Deriv.Dictionary",
          "name": "lookup",
          "package": "regex-deriv",
          "signature": "k -\u003e Dictionary a -\u003e Maybe a",
          "source": "src/Text-Regex-Deriv-Dictionary.html#lookup",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex Deriv Dictionary",
          "module": "Text.Regex.Deriv.Dictionary",
          "name": "lookup",
          "normalized": "a-\u003eDictionary b-\u003eMaybe b",
          "package": "regex-deriv",
          "signature": "k-\u003eDictionary a-\u003eMaybe a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-deriv/docs/Text-Regex-Deriv-Dictionary.html#v:lookup"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.Deriv.Dictionary",
          "name": "lookupAll",
          "package": "regex-deriv",
          "signature": "k -\u003e Dictionary a -\u003e [a]",
          "source": "src/Text-Regex-Deriv-Dictionary.html#lookupAll",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex Deriv Dictionary",
          "module": "Text.Regex.Deriv.Dictionary",
          "name": "lookupAll",
          "normalized": "a-\u003eDictionary b-\u003e[b]",
          "package": "regex-deriv",
          "partial": "All",
          "signature": "k-\u003eDictionary a-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-deriv/docs/Text-Regex-Deriv-Dictionary.html#v:lookupAll"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.Deriv.Dictionary",
          "name": "lookupTrie",
          "package": "regex-deriv",
          "signature": "[Int] -\u003e Trie a -\u003e Maybe (Trie a)",
          "source": "src/Text-Regex-Deriv-Dictionary.html#lookupTrie",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex Deriv Dictionary",
          "module": "Text.Regex.Deriv.Dictionary",
          "name": "lookupTrie",
          "normalized": "[Int]-\u003eTrie a-\u003eMaybe(Trie a)",
          "package": "regex-deriv",
          "partial": "Trie",
          "signature": "[Int]-\u003eTrie a-\u003eMaybe(Trie a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-deriv/docs/Text-Regex-Deriv-Dictionary.html#v:lookupTrie"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.Deriv.Dictionary",
          "name": "member",
          "package": "regex-deriv",
          "signature": "k -\u003e Dictionary a -\u003e Bool",
          "source": "src/Text-Regex-Deriv-Dictionary.html#member",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex Deriv Dictionary",
          "module": "Text.Regex.Deriv.Dictionary",
          "name": "member",
          "normalized": "a-\u003eDictionary b-\u003eBool",
          "package": "regex-deriv",
          "signature": "k-\u003eDictionary a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-deriv/docs/Text-Regex-Deriv-Dictionary.html#v:member"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.Deriv.Dictionary",
          "name": "nub",
          "package": "regex-deriv",
          "signature": "[k] -\u003e [k]",
          "source": "src/Text-Regex-Deriv-Dictionary.html#nub",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex Deriv Dictionary",
          "module": "Text.Regex.Deriv.Dictionary",
          "name": "nub",
          "normalized": "[a]-\u003e[a]",
          "package": "regex-deriv",
          "signature": "[k]-\u003e[k]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-deriv/docs/Text-Regex-Deriv-Dictionary.html#v:nub"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.Deriv.Dictionary",
          "name": "nubSub",
          "package": "regex-deriv",
          "signature": "[k] -\u003e Dictionary (k, ()) -\u003e [k]",
          "source": "src/Text-Regex-Deriv-Dictionary.html#nubSub",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex Deriv Dictionary",
          "module": "Text.Regex.Deriv.Dictionary",
          "name": "nubSub",
          "normalized": "[a]-\u003eDictionary(a,())-\u003e[a]",
          "package": "regex-deriv",
          "partial": "Sub",
          "signature": "[k]-\u003eDictionary(k,())-\u003e[k]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-deriv/docs/Text-Regex-Deriv-Dictionary.html#v:nubSub"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.Deriv.Dictionary",
          "name": "primeL",
          "package": "regex-deriv",
          "signature": "Int",
          "source": "src/Text-Regex-Deriv-Dictionary.html#primeL",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex Deriv Dictionary",
          "module": "Text.Regex.Deriv.Dictionary",
          "name": "primeL",
          "package": "regex-deriv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-deriv/docs/Text-Regex-Deriv-Dictionary.html#v:primeL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.Deriv.Dictionary",
          "name": "primeR",
          "package": "regex-deriv",
          "signature": "Int",
          "source": "src/Text-Regex-Deriv-Dictionary.html#primeR",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex Deriv Dictionary",
          "module": "Text.Regex.Deriv.Dictionary",
          "name": "primeR",
          "package": "regex-deriv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-deriv/docs/Text-Regex-Deriv-Dictionary.html#v:primeR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ethe dictionary (k,a) version of elem\n\u003c/p\u003e",
          "module": "Text.Regex.Deriv.Dictionary",
          "name": "update",
          "package": "regex-deriv",
          "signature": "k -\u003e a -\u003e Dictionary a -\u003e Dictionary a",
          "source": "src/Text-Regex-Deriv-Dictionary.html#update",
          "type": "function"
        },
        "index": {
          "description": "the dictionary version of elem",
          "hierarchy": "Text Regex Deriv Dictionary",
          "module": "Text.Regex.Deriv.Dictionary",
          "name": "update",
          "normalized": "a-\u003eb-\u003eDictionary b-\u003eDictionary b",
          "package": "regex-deriv",
          "signature": "k-\u003ea-\u003eDictionary a-\u003eDictionary a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-deriv/docs/Text-Regex-Deriv-Dictionary.html#v:update"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.Deriv.Dictionary",
          "name": "updateTrie",
          "package": "regex-deriv",
          "signature": "[Int] -\u003e a -\u003e Trie a -\u003e Trie a",
          "source": "src/Text-Regex-Deriv-Dictionary.html#updateTrie",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex Deriv Dictionary",
          "module": "Text.Regex.Deriv.Dictionary",
          "name": "updateTrie",
          "normalized": "[Int]-\u003ea-\u003eTrie a-\u003eTrie a",
          "package": "regex-deriv",
          "partial": "Trie",
          "signature": "[Int]-\u003ea-\u003eTrie a-\u003eTrie a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-deriv/docs/Text-Regex-Deriv-Dictionary.html#v:updateTrie"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.Deriv.ExtPattern",
          "name": "ExtPattern",
          "package": "regex-deriv",
          "source": "src/Text-Regex-Deriv-ExtPattern.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Text Regex Deriv ExtPattern",
          "module": "Text.Regex.Deriv.ExtPattern",
          "name": "ExtPattern",
          "package": "regex-deriv",
          "partial": "Ext Pattern",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/regex-deriv/docs/Text-Regex-Deriv-ExtPattern.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe external pattern syntax (ERE syntax)\n\u003c/p\u003e",
          "module": "Text.Regex.Deriv.ExtPattern",
          "name": "EPat",
          "package": "regex-deriv",
          "source": "src/Text-Regex-Deriv-ExtPattern.html#EPat",
          "type": "data"
        },
        "index": {
          "description": "The external pattern syntax ERE syntax",
          "hierarchy": "Text Regex Deriv ExtPattern",
          "module": "Text.Regex.Deriv.ExtPattern",
          "name": "EPat",
          "package": "regex-deriv",
          "partial": "EPat",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/regex-deriv/docs/Text-Regex-Deriv-ExtPattern.html#t:EPat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ethe character class [ a-z ] \n\u003c/p\u003e",
          "module": "Text.Regex.Deriv.ExtPattern",
          "name": "EAny",
          "package": "regex-deriv",
          "signature": "EAny [Char]",
          "source": "src/Text-Regex-Deriv-ExtPattern.html#EPat",
          "type": "function"
        },
        "index": {
          "description": "the character class a-z",
          "hierarchy": "Text Regex Deriv ExtPattern",
          "module": "Text.Regex.Deriv.ExtPattern",
          "name": "EAny",
          "normalized": "EAny[Char]",
          "package": "regex-deriv",
          "partial": "EAny",
          "signature": "EAny[Char]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-deriv/docs/Text-Regex-Deriv-ExtPattern.html#v:EAny"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ere{1:10}\n\u003c/p\u003e",
          "module": "Text.Regex.Deriv.ExtPattern",
          "name": "EBound",
          "package": "regex-deriv",
          "signature": "EBound EPat Int (Maybe Int) Bool",
          "source": "src/Text-Regex-Deriv-ExtPattern.html#EPat",
          "type": "function"
        },
        "index": {
          "description": "re",
          "hierarchy": "Text Regex Deriv ExtPattern",
          "module": "Text.Regex.Deriv.ExtPattern",
          "name": "EBound",
          "package": "regex-deriv",
          "partial": "EBound",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-deriv/docs/Text-Regex-Deriv-ExtPattern.html#v:EBound"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ethe ^ NOTE:shouldn't this must be top level?\n\u003c/p\u003e",
          "module": "Text.Regex.Deriv.ExtPattern",
          "name": "ECarat",
          "package": "regex-deriv",
          "signature": "ECarat",
          "source": "src/Text-Regex-Deriv-ExtPattern.html#EPat",
          "type": "function"
        },
        "index": {
          "description": "the NOTE shouldn this must be top level",
          "hierarchy": "Text Regex Deriv ExtPattern",
          "module": "Text.Regex.Deriv.ExtPattern",
          "name": "ECarat",
          "package": "regex-deriv",
          "partial": "ECarat",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-deriv/docs/Text-Regex-Deriv-ExtPattern.html#v:ECarat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ethe non-escaped char\n\u003c/p\u003e",
          "module": "Text.Regex.Deriv.ExtPattern",
          "name": "EChar",
          "package": "regex-deriv",
          "signature": "EChar Char",
          "source": "src/Text-Regex-Deriv-ExtPattern.html#EPat",
          "type": "function"
        },
        "index": {
          "description": "the non-escaped char",
          "hierarchy": "Text Regex Deriv ExtPattern",
          "module": "Text.Regex.Deriv.ExtPattern",
          "name": "EChar",
          "package": "regex-deriv",
          "partial": "EChar",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-deriv/docs/Text-Regex-Deriv-ExtPattern.html#v:EChar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ethe concantenation rere\n\u003c/p\u003e",
          "module": "Text.Regex.Deriv.ExtPattern",
          "name": "EConcat",
          "package": "regex-deriv",
          "signature": "EConcat [EPat]",
          "source": "src/Text-Regex-Deriv-ExtPattern.html#EPat",
          "type": "function"
        },
        "index": {
          "description": "the concantenation rere",
          "hierarchy": "Text Regex Deriv ExtPattern",
          "module": "Text.Regex.Deriv.ExtPattern",
          "name": "EConcat",
          "normalized": "EConcat[EPat]",
          "package": "regex-deriv",
          "partial": "EConcat",
          "signature": "EConcat[EPat]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-deriv/docs/Text-Regex-Deriv-ExtPattern.html#v:EConcat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ethe $\n\u003c/p\u003e",
          "module": "Text.Regex.Deriv.ExtPattern",
          "name": "EDollar",
          "package": "regex-deriv",
          "signature": "EDollar",
          "source": "src/Text-Regex-Deriv-ExtPattern.html#EPat",
          "type": "function"
        },
        "index": {
          "description": "the",
          "hierarchy": "Text Regex Deriv ExtPattern",
          "module": "Text.Regex.Deriv.ExtPattern",
          "name": "EDollar",
          "package": "regex-deriv",
          "partial": "EDollar",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-deriv/docs/Text-Regex-Deriv-ExtPattern.html#v:EDollar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ethe any char .\n\u003c/p\u003e",
          "module": "Text.Regex.Deriv.ExtPattern",
          "name": "EDot",
          "package": "regex-deriv",
          "signature": "EDot",
          "source": "src/Text-Regex-Deriv-ExtPattern.html#EPat",
          "type": "function"
        },
        "index": {
          "description": "the any char",
          "hierarchy": "Text Regex Deriv ExtPattern",
          "module": "Text.Regex.Deriv.ExtPattern",
          "name": "EDot",
          "package": "regex-deriv",
          "partial": "EDot",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-deriv/docs/Text-Regex-Deriv-ExtPattern.html#v:EDot"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.Deriv.ExtPattern",
          "name": "EEmpty",
          "package": "regex-deriv",
          "signature": "EEmpty",
          "source": "src/Text-Regex-Deriv-ExtPattern.html#EPat",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex Deriv ExtPattern",
          "module": "Text.Regex.Deriv.ExtPattern",
          "name": "EEmpty",
          "package": "regex-deriv",
          "partial": "EEmpty",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-deriv/docs/Text-Regex-Deriv-ExtPattern.html#v:EEmpty"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ebackslash char\n\u003c/p\u003e",
          "module": "Text.Regex.Deriv.ExtPattern",
          "name": "EEscape",
          "package": "regex-deriv",
          "signature": "EEscape Char",
          "source": "src/Text-Regex-Deriv-ExtPattern.html#EPat",
          "type": "function"
        },
        "index": {
          "description": "backslash char",
          "hierarchy": "Text Regex Deriv ExtPattern",
          "module": "Text.Regex.Deriv.ExtPattern",
          "name": "EEscape",
          "package": "regex-deriv",
          "partial": "EEscape",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-deriv/docs/Text-Regex-Deriv-ExtPattern.html#v:EEscape"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ethe group ( re )\n\u003c/p\u003e",
          "module": "Text.Regex.Deriv.ExtPattern",
          "name": "EGroup",
          "package": "regex-deriv",
          "signature": "EGroup EPat",
          "source": "src/Text-Regex-Deriv-ExtPattern.html#EPat",
          "type": "function"
        },
        "index": {
          "description": "the group re",
          "hierarchy": "Text Regex Deriv ExtPattern",
          "module": "Text.Regex.Deriv.ExtPattern",
          "name": "EGroup",
          "package": "regex-deriv",
          "partial": "EGroup",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-deriv/docs/Text-Regex-Deriv-ExtPattern.html#v:EGroup"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003enon marking group (?: re )\n\u003c/p\u003e",
          "module": "Text.Regex.Deriv.ExtPattern",
          "name": "EGroupNonMarking",
          "package": "regex-deriv",
          "signature": "EGroupNonMarking EPat",
          "source": "src/Text-Regex-Deriv-ExtPattern.html#EPat",
          "type": "function"
        },
        "index": {
          "description": "non marking group re",
          "hierarchy": "Text Regex Deriv ExtPattern",
          "module": "Text.Regex.Deriv.ExtPattern",
          "name": "EGroupNonMarking",
          "package": "regex-deriv",
          "partial": "EGroup Non Marking",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-deriv/docs/Text-Regex-Deriv-ExtPattern.html#v:EGroupNonMarking"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ethe negative character class [^a-z]\n\u003c/p\u003e",
          "module": "Text.Regex.Deriv.ExtPattern",
          "name": "ENoneOf",
          "package": "regex-deriv",
          "signature": "ENoneOf [Char]",
          "source": "src/Text-Regex-Deriv-ExtPattern.html#EPat",
          "type": "function"
        },
        "index": {
          "description": "the negative character class a-z",
          "hierarchy": "Text Regex Deriv ExtPattern",
          "module": "Text.Regex.Deriv.ExtPattern",
          "name": "ENoneOf",
          "normalized": "ENoneOf[Char]",
          "package": "regex-deriv",
          "partial": "ENone Of",
          "signature": "ENoneOf[Char]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-deriv/docs/Text-Regex-Deriv-ExtPattern.html#v:ENoneOf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ethe option re?, the last boolean flag indicates whether it is greedy\n\u003c/p\u003e",
          "module": "Text.Regex.Deriv.ExtPattern",
          "name": "EOpt",
          "package": "regex-deriv",
          "signature": "EOpt EPat Bool",
          "source": "src/Text-Regex-Deriv-ExtPattern.html#EPat",
          "type": "function"
        },
        "index": {
          "description": "the option re the last boolean flag indicates whether it is greedy",
          "hierarchy": "Text Regex Deriv ExtPattern",
          "module": "Text.Regex.Deriv.ExtPattern",
          "name": "EOpt",
          "package": "regex-deriv",
          "partial": "EOpt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-deriv/docs/Text-Regex-Deriv-ExtPattern.html#v:EOpt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ethe union re|re\n\u003c/p\u003e",
          "module": "Text.Regex.Deriv.ExtPattern",
          "name": "EOr",
          "package": "regex-deriv",
          "signature": "EOr [EPat]",
          "source": "src/Text-Regex-Deriv-ExtPattern.html#EPat",
          "type": "function"
        },
        "index": {
          "description": "the union re re",
          "hierarchy": "Text Regex Deriv ExtPattern",
          "module": "Text.Regex.Deriv.ExtPattern",
          "name": "EOr",
          "normalized": "EOr[EPat]",
          "package": "regex-deriv",
          "partial": "EOr",
          "signature": "EOr[EPat]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-deriv/docs/Text-Regex-Deriv-ExtPattern.html#v:EOr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ethe plus re+\n\u003c/p\u003e",
          "module": "Text.Regex.Deriv.ExtPattern",
          "name": "EPlus",
          "package": "regex-deriv",
          "signature": "EPlus EPat Bool",
          "source": "src/Text-Regex-Deriv-ExtPattern.html#EPat",
          "type": "function"
        },
        "index": {
          "description": "the plus re",
          "hierarchy": "Text Regex Deriv ExtPattern",
          "module": "Text.Regex.Deriv.ExtPattern",
          "name": "EPlus",
          "package": "regex-deriv",
          "partial": "EPlus",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-deriv/docs/Text-Regex-Deriv-ExtPattern.html#v:EPlus"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ethe star re*\n\u003c/p\u003e",
          "module": "Text.Regex.Deriv.ExtPattern",
          "name": "EStar",
          "package": "regex-deriv",
          "signature": "EStar EPat Bool",
          "source": "src/Text-Regex-Deriv-ExtPattern.html#EPat",
          "type": "function"
        },
        "index": {
          "description": "the star re",
          "hierarchy": "Text Regex Deriv ExtPattern",
          "module": "Text.Regex.Deriv.ExtPattern",
          "name": "EStar",
          "package": "regex-deriv",
          "partial": "EStar",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-deriv/docs/Text-Regex-Deriv-ExtPattern.html#v:EStar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFunction \u003ccode\u003e\u003ca\u003ehasGroup\u003c/a\u003e\u003c/code\u003e tests whether an external pattern has ( ... ) (i.e. variable patterns in the internal pattern)\n\u003c/p\u003e",
          "module": "Text.Regex.Deriv.ExtPattern",
          "name": "hasGroup",
          "package": "regex-deriv",
          "signature": "EPat -\u003e Bool",
          "source": "src/Text-Regex-Deriv-ExtPattern.html#hasGroup",
          "type": "function"
        },
        "index": {
          "description": "Function hasGroup tests whether an external pattern has i.e variable patterns in the internal pattern",
          "hierarchy": "Text Regex Deriv ExtPattern",
          "module": "Text.Regex.Deriv.ExtPattern",
          "name": "hasGroup",
          "normalized": "EPat-\u003eBool",
          "package": "regex-deriv",
          "partial": "Group",
          "signature": "EPat-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-deriv/docs/Text-Regex-Deriv-ExtPattern.html#v:hasGroup"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module defines the data type of internal regular expression pattern, \n | as well as the partial derivative operations for regular expression patterns.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Text.Regex.Deriv.IntPattern",
          "name": "IntPattern",
          "package": "regex-deriv",
          "source": "src/Text-Regex-Deriv-IntPattern.html",
          "type": "module"
        },
        "index": {
          "description": "This module defines the data type of internal regular expression pattern as well as the partial derivative operations for regular expression patterns",
          "hierarchy": "Text Regex Deriv IntPattern",
          "module": "Text.Regex.Deriv.IntPattern",
          "name": "IntPattern",
          "package": "regex-deriv",
          "partial": "Int Pattern",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/regex-deriv/docs/Text-Regex-Deriv-IntPattern.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003eBinder\u003c/a\u003e\u003c/code\u003e type denotes a set of (pattern var * range) pairs\n type Binder = [(Int, [Range])]\n\u003c/p\u003e",
          "module": "Text.Regex.Deriv.IntPattern",
          "name": "Binder",
          "package": "regex-deriv",
          "source": "src/Text-Regex-Deriv-IntPattern.html#Binder",
          "type": "type"
        },
        "index": {
          "description": "The Binder type denotes set of pattern var range pairs type Binder Int Range",
          "hierarchy": "Text Regex Deriv IntPattern",
          "module": "Text.Regex.Deriv.IntPattern",
          "name": "Binder",
          "package": "regex-deriv",
          "partial": "Binder",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/regex-deriv/docs/Text-Regex-Deriv-IntPattern.html#t:Binder"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.Deriv.IntPattern",
          "name": "Key",
          "package": "regex-deriv",
          "source": "src/Text-Regex-Deriv-Dictionary.html#Key",
          "type": "class"
        },
        "index": {
          "hierarchy": "Text Regex Deriv IntPattern",
          "module": "Text.Regex.Deriv.IntPattern",
          "name": "Key",
          "package": "regex-deriv",
          "partial": "Key",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/regex-deriv/docs/Text-Regex-Deriv-IntPattern.html#t:Key"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eregular expression patterns\n\u003c/p\u003e",
          "module": "Text.Regex.Deriv.IntPattern",
          "name": "Pat",
          "package": "regex-deriv",
          "source": "src/Text-Regex-Deriv-IntPattern.html#Pat",
          "type": "data"
        },
        "index": {
          "description": "regular expression patterns",
          "hierarchy": "Text Regex Deriv IntPattern",
          "module": "Text.Regex.Deriv.IntPattern",
          "name": "Pat",
          "package": "regex-deriv",
          "partial": "Pat",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/regex-deriv/docs/Text-Regex-Deriv-IntPattern.html#t:Pat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003echoice pattern \n\u003c/p\u003e",
          "module": "Text.Regex.Deriv.IntPattern",
          "name": "PChoice",
          "package": "regex-deriv",
          "signature": "PChoice [Pat] GFlag",
          "source": "src/Text-Regex-Deriv-IntPattern.html#Pat",
          "type": "function"
        },
        "index": {
          "description": "choice pattern",
          "hierarchy": "Text Regex Deriv IntPattern",
          "module": "Text.Regex.Deriv.IntPattern",
          "name": "PChoice",
          "normalized": "PChoice[Pat]GFlag",
          "package": "regex-deriv",
          "partial": "PChoice",
          "signature": "PChoice[Pat]GFlag",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-deriv/docs/Text-Regex-Deriv-IntPattern.html#v:PChoice"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003epattern without binder\n\u003c/p\u003e",
          "module": "Text.Regex.Deriv.IntPattern",
          "name": "PE",
          "package": "regex-deriv",
          "signature": "PE [RE]",
          "source": "src/Text-Regex-Deriv-IntPattern.html#Pat",
          "type": "function"
        },
        "index": {
          "description": "pattern without binder",
          "hierarchy": "Text Regex Deriv IntPattern",
          "module": "Text.Regex.Deriv.IntPattern",
          "name": "PE",
          "normalized": "PE[RE]",
          "package": "regex-deriv",
          "partial": "PE",
          "signature": "PE[RE]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-deriv/docs/Text-Regex-Deriv-IntPattern.html#v:PE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eempty pattern, it is used intermally to indicate that mkEmpty function has been applied.\n\u003c/p\u003e",
          "module": "Text.Regex.Deriv.IntPattern",
          "name": "PEmpty",
          "package": "regex-deriv",
          "signature": "PEmpty Pat",
          "source": "src/Text-Regex-Deriv-IntPattern.html#Pat",
          "type": "function"
        },
        "index": {
          "description": "empty pattern it is used intermally to indicate that mkEmpty function has been applied",
          "hierarchy": "Text Regex Deriv IntPattern",
          "module": "Text.Regex.Deriv.IntPattern",
          "name": "PEmpty",
          "package": "regex-deriv",
          "partial": "PEmpty",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-deriv/docs/Text-Regex-Deriv-IntPattern.html#v:PEmpty"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003epair pattern\n\u003c/p\u003e",
          "module": "Text.Regex.Deriv.IntPattern",
          "name": "PPair",
          "package": "regex-deriv",
          "signature": "PPair Pat Pat",
          "source": "src/Text-Regex-Deriv-IntPattern.html#Pat",
          "type": "function"
        },
        "index": {
          "description": "pair pattern",
          "hierarchy": "Text Regex Deriv IntPattern",
          "module": "Text.Regex.Deriv.IntPattern",
          "name": "PPair",
          "package": "regex-deriv",
          "partial": "PPair",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-deriv/docs/Text-Regex-Deriv-IntPattern.html#v:PPair"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eplus pattern, it is used internally to indicate that it is unrolled from a PStar\n\u003c/p\u003e",
          "module": "Text.Regex.Deriv.IntPattern",
          "name": "PPlus",
          "package": "regex-deriv",
          "signature": "PPlus Pat Pat",
          "source": "src/Text-Regex-Deriv-IntPattern.html#Pat",
          "type": "function"
        },
        "index": {
          "description": "plus pattern it is used internally to indicate that it is unrolled from PStar",
          "hierarchy": "Text Regex Deriv IntPattern",
          "module": "Text.Regex.Deriv.IntPattern",
          "name": "PPlus",
          "package": "regex-deriv",
          "partial": "PPlus",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-deriv/docs/Text-Regex-Deriv-IntPattern.html#v:PPlus"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003estar pattern \n\u003c/p\u003e",
          "module": "Text.Regex.Deriv.IntPattern",
          "name": "PStar",
          "package": "regex-deriv",
          "signature": "PStar Pat GFlag",
          "source": "src/Text-Regex-Deriv-IntPattern.html#Pat",
          "type": "function"
        },
        "index": {
          "description": "star pattern",
          "hierarchy": "Text Regex Deriv IntPattern",
          "module": "Text.Regex.Deriv.IntPattern",
          "name": "PStar",
          "package": "regex-deriv",
          "partial": "PStar",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-deriv/docs/Text-Regex-Deriv-IntPattern.html#v:PStar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003evariable pattern \n\u003c/p\u003e",
          "module": "Text.Regex.Deriv.IntPattern",
          "name": "PVar",
          "package": "regex-deriv",
          "signature": "PVar Int [Range] Pat",
          "source": "src/Text-Regex-Deriv-IntPattern.html#Pat",
          "type": "function"
        },
        "index": {
          "description": "variable pattern",
          "hierarchy": "Text Regex Deriv IntPattern",
          "module": "Text.Regex.Deriv.IntPattern",
          "name": "PVar",
          "normalized": "PVar Int[Range]Pat",
          "package": "regex-deriv",
          "partial": "PVar",
          "signature": "PVar Int[Range]Pat",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-deriv/docs/Text-Regex-Deriv-IntPattern.html#v:PVar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.Deriv.IntPattern",
          "name": "hash",
          "package": "regex-deriv",
          "signature": "a -\u003e [Int]",
          "source": "src/Text-Regex-Deriv-Dictionary.html#hash",
          "type": "method"
        },
        "index": {
          "hierarchy": "Text Regex Deriv IntPattern",
          "module": "Text.Regex.Deriv.IntPattern",
          "name": "hash",
          "normalized": "a-\u003e[Int]",
          "package": "regex-deriv",
          "signature": "a-\u003e[Int]",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/regex-deriv/docs/Text-Regex-Deriv-IntPattern.html#v:hash"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.Deriv.IntPattern",
          "name": "listifyBinder",
          "package": "regex-deriv",
          "signature": "Binder -\u003e [(Int, [Range])]",
          "source": "src/Text-Regex-Deriv-IntPattern.html#listifyBinder",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex Deriv IntPattern",
          "module": "Text.Regex.Deriv.IntPattern",
          "name": "listifyBinder",
          "normalized": "Binder-\u003e[(Int,[Range])]",
          "package": "regex-deriv",
          "partial": "Binder",
          "signature": "Binder-\u003e[(Int,[Range])]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-deriv/docs/Text-Regex-Deriv-IntPattern.html#v:listifyBinder"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003efunction \u003ccode\u003e\u003ca\u003estrip\u003c/a\u003e\u003c/code\u003e strips away the bindings from a pattern\n\u003c/p\u003e",
          "module": "Text.Regex.Deriv.IntPattern",
          "name": "strip",
          "package": "regex-deriv",
          "signature": "Pat -\u003e RE",
          "source": "src/Text-Regex-Deriv-IntPattern.html#strip",
          "type": "function"
        },
        "index": {
          "description": "function strip strips away the bindings from pattern",
          "hierarchy": "Text Regex Deriv IntPattern",
          "module": "Text.Regex.Deriv.IntPattern",
          "name": "strip",
          "normalized": "Pat-\u003eRE",
          "package": "regex-deriv",
          "signature": "Pat-\u003eRE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-deriv/docs/Text-Regex-Deriv-IntPattern.html#v:strip"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFunction \u003ccode\u003e\u003ca\u003etoBinder\u003c/a\u003e\u003c/code\u003e turns a pattern into a binder\n\u003c/p\u003e",
          "module": "Text.Regex.Deriv.IntPattern",
          "name": "toBinder",
          "package": "regex-deriv",
          "signature": "Pat -\u003e Binder",
          "source": "src/Text-Regex-Deriv-IntPattern.html#toBinder",
          "type": "function"
        },
        "index": {
          "description": "Function toBinder turns pattern into binder",
          "hierarchy": "Text Regex Deriv IntPattern",
          "module": "Text.Regex.Deriv.IntPattern",
          "name": "toBinder",
          "normalized": "Pat-\u003eBinder",
          "package": "regex-deriv",
          "partial": "Binder",
          "signature": "Pat-\u003eBinder",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-deriv/docs/Text-Regex-Deriv-IntPattern.html#v:toBinder"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.Deriv.Parse",
          "name": "Parse",
          "package": "regex-deriv",
          "source": "src/Text-Regex-Deriv-Parse.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Text Regex Deriv Parse",
          "module": "Text.Regex.Deriv.Parse",
          "name": "Parse",
          "package": "regex-deriv",
          "partial": "Parse",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/regex-deriv/docs/Text-Regex-Deriv-Parse.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn either a parse error or an external pattern\n\u003c/p\u003e",
          "module": "Text.Regex.Deriv.Parse",
          "name": "parseEPat",
          "package": "regex-deriv",
          "signature": "String -\u003e Either ParseError (EPat, EState)",
          "source": "src/Text-Regex-Deriv-Parse.html#parseEPat",
          "type": "function"
        },
        "index": {
          "description": "Return either parse error or an external pattern",
          "hierarchy": "Text Regex Deriv Parse",
          "module": "Text.Regex.Deriv.Parse",
          "name": "parseEPat",
          "normalized": "String-\u003eEither ParseError(EPat,EState)",
          "package": "regex-deriv",
          "partial": "EPat",
          "signature": "String-\u003eEither ParseError(EPat,EState)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-deriv/docs/Text-Regex-Deriv-Parse.html#v:parseEPat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.Deriv.Parse",
          "name": "parsePat",
          "package": "regex-deriv",
          "signature": "String -\u003e Either ParseError Pat",
          "source": "src/Text-Regex-Deriv-Parse.html#parsePat",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex Deriv Parse",
          "module": "Text.Regex.Deriv.Parse",
          "name": "parsePat",
          "normalized": "String-\u003eEither ParseError Pat",
          "package": "regex-deriv",
          "partial": "Pat",
          "signature": "String-\u003eEither ParseError Pat",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-deriv/docs/Text-Regex-Deriv-Parse.html#v:parsePat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.Deriv.Parse",
          "name": "parsePatPosix",
          "package": "regex-deriv",
          "signature": "String -\u003e Either ParseError (Pat, IntMap ())",
          "source": "src/Text-Regex-Deriv-Parse.html#parsePatPosix",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex Deriv Parse",
          "module": "Text.Regex.Deriv.Parse",
          "name": "parsePatPosix",
          "normalized": "String-\u003eEither ParseError(Pat,IntMap())",
          "package": "regex-deriv",
          "partial": "Pat Posix",
          "signature": "String-\u003eEither ParseError(Pat,IntMap())",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-deriv/docs/Text-Regex-Deriv-Parse.html#v:parsePatPosix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.Deriv.Pretty",
          "name": "Pretty",
          "package": "regex-deriv",
          "source": "src/Text-Regex-Deriv-Pretty.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Text Regex Deriv Pretty",
          "module": "Text.Regex.Deriv.Pretty",
          "name": "Pretty",
          "package": "regex-deriv",
          "partial": "Pretty",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/regex-deriv/docs/Text-Regex-Deriv-Pretty.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.Deriv.Pretty",
          "name": "Pretty",
          "package": "regex-deriv",
          "source": "src/Text-Regex-Deriv-Pretty.html#Pretty",
          "type": "class"
        },
        "index": {
          "hierarchy": "Text Regex Deriv Pretty",
          "module": "Text.Regex.Deriv.Pretty",
          "name": "Pretty",
          "package": "regex-deriv",
          "partial": "Pretty",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/regex-deriv/docs/Text-Regex-Deriv-Pretty.html#t:Pretty"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.Deriv.Pretty",
          "name": "pretty",
          "package": "regex-deriv",
          "signature": "a -\u003e String",
          "source": "src/Text-Regex-Deriv-Pretty.html#pretty",
          "type": "method"
        },
        "index": {
          "hierarchy": "Text Regex Deriv Pretty",
          "module": "Text.Regex.Deriv.Pretty",
          "name": "pretty",
          "normalized": "a-\u003eString",
          "package": "regex-deriv",
          "signature": "a-\u003eString",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/regex-deriv/docs/Text-Regex-Deriv-Pretty.html#v:pretty"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.Deriv.RE",
          "name": "RE",
          "package": "regex-deriv",
          "source": "src/Text-Regex-Deriv-RE.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Text Regex Deriv RE",
          "module": "Text.Regex.Deriv.RE",
          "name": "RE",
          "package": "regex-deriv",
          "partial": "RE",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/regex-deriv/docs/Text-Regex-Deriv-RE.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003edata type of the regular expresions\n\u003c/p\u003e",
          "module": "Text.Regex.Deriv.RE",
          "name": "RE",
          "package": "regex-deriv",
          "source": "src/Text-Regex-Deriv-RE.html#RE",
          "type": "data"
        },
        "index": {
          "description": "data type of the regular expresions",
          "hierarchy": "Text Regex Deriv RE",
          "module": "Text.Regex.Deriv.RE",
          "name": "RE",
          "package": "regex-deriv",
          "partial": "RE",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/regex-deriv/docs/Text-Regex-Deriv-RE.html#t:RE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e.\n\u003c/p\u003e",
          "module": "Text.Regex.Deriv.RE",
          "name": "Any",
          "package": "regex-deriv",
          "signature": "Any",
          "source": "src/Text-Regex-Deriv-RE.html#RE",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex Deriv RE",
          "module": "Text.Regex.Deriv.RE",
          "name": "Any",
          "package": "regex-deriv",
          "partial": "Any",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-deriv/docs/Text-Regex-Deriv-RE.html#v:Any"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ea choice exp 'r1 + r2'\n\u003c/p\u003e",
          "module": "Text.Regex.Deriv.RE",
          "name": "Choice",
          "package": "regex-deriv",
          "signature": "Choice [RE] GFlag",
          "source": "src/Text-Regex-Deriv-RE.html#RE",
          "type": "function"
        },
        "index": {
          "description": "choice exp r1 r2",
          "hierarchy": "Text Regex Deriv RE",
          "module": "Text.Regex.Deriv.RE",
          "name": "Choice",
          "normalized": "Choice[RE]GFlag",
          "package": "regex-deriv",
          "partial": "Choice",
          "signature": "Choice[RE]GFlag",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-deriv/docs/Text-Regex-Deriv-RE.html#v:Choice"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003einternal choice used in the BitCode version\n\u003c/p\u003e",
          "module": "Text.Regex.Deriv.RE",
          "name": "ChoiceInt",
          "package": "regex-deriv",
          "signature": "ChoiceInt [RE]",
          "source": "src/Text-Regex-Deriv-RE.html#RE",
          "type": "function"
        },
        "index": {
          "description": "internal choice used in the BitCode version",
          "hierarchy": "Text Regex Deriv RE",
          "module": "Text.Regex.Deriv.RE",
          "name": "ChoiceInt",
          "normalized": "ChoiceInt[RE]",
          "package": "regex-deriv",
          "partial": "Choice Int",
          "signature": "ChoiceInt[RE]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-deriv/docs/Text-Regex-Deriv-RE.html#v:ChoiceInt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ean empty exp\n\u003c/p\u003e",
          "module": "Text.Regex.Deriv.RE",
          "name": "Empty",
          "package": "regex-deriv",
          "signature": "Empty",
          "source": "src/Text-Regex-Deriv-RE.html#RE",
          "type": "function"
        },
        "index": {
          "description": "an empty exp",
          "hierarchy": "Text Regex Deriv RE",
          "module": "Text.Regex.Deriv.RE",
          "name": "Empty",
          "package": "regex-deriv",
          "partial": "Empty",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-deriv/docs/Text-Regex-Deriv-RE.html#v:Empty"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ea literal / a character\n\u003c/p\u003e",
          "module": "Text.Regex.Deriv.RE",
          "name": "L",
          "package": "regex-deriv",
          "signature": "L Char",
          "source": "src/Text-Regex-Deriv-RE.html#RE",
          "type": "function"
        },
        "index": {
          "description": "literal character",
          "hierarchy": "Text Regex Deriv RE",
          "module": "Text.Regex.Deriv.RE",
          "name": "L",
          "package": "regex-deriv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-deriv/docs/Text-Regex-Deriv-RE.html#v:L"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eexcluding characters e.g. [^abc]\n\u003c/p\u003e",
          "module": "Text.Regex.Deriv.RE",
          "name": "Not",
          "package": "regex-deriv",
          "signature": "Not [Char]",
          "source": "src/Text-Regex-Deriv-RE.html#RE",
          "type": "function"
        },
        "index": {
          "description": "excluding characters e.g abc",
          "hierarchy": "Text Regex Deriv RE",
          "module": "Text.Regex.Deriv.RE",
          "name": "Not",
          "normalized": "Not[Char]",
          "package": "regex-deriv",
          "partial": "Not",
          "signature": "Not[Char]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-deriv/docs/Text-Regex-Deriv-RE.html#v:Not"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.Deriv.RE",
          "name": "Phi",
          "package": "regex-deriv",
          "signature": "Phi",
          "source": "src/Text-Regex-Deriv-RE.html#RE",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex Deriv RE",
          "module": "Text.Regex.Deriv.RE",
          "name": "Phi",
          "package": "regex-deriv",
          "partial": "Phi",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-deriv/docs/Text-Regex-Deriv-RE.html#v:Phi"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ea pair exp '(r1,r2)'\n\u003c/p\u003e",
          "module": "Text.Regex.Deriv.RE",
          "name": "Seq",
          "package": "regex-deriv",
          "signature": "Seq RE RE",
          "source": "src/Text-Regex-Deriv-RE.html#RE",
          "type": "function"
        },
        "index": {
          "description": "pair exp r1 r2",
          "hierarchy": "Text Regex Deriv RE",
          "module": "Text.Regex.Deriv.RE",
          "name": "Seq",
          "package": "regex-deriv",
          "partial": "Seq",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-deriv/docs/Text-Regex-Deriv-RE.html#v:Seq"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ea kleene's star exp 'r*'\n\u003c/p\u003e",
          "module": "Text.Regex.Deriv.RE",
          "name": "Star",
          "package": "regex-deriv",
          "signature": "Star RE GFlag",
          "source": "src/Text-Regex-Deriv-RE.html#RE",
          "type": "function"
        },
        "index": {
          "description": "kleene star exp",
          "hierarchy": "Text Regex Deriv RE",
          "module": "Text.Regex.Deriv.RE",
          "name": "Star",
          "package": "regex-deriv",
          "partial": "Star",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-deriv/docs/Text-Regex-Deriv-RE.html#v:Star"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003efunction \u003ccode\u003e\u003ca\u003epartDeriv\u003c/a\u003e\u003c/code\u003e implements the partial derivative operations for regular expressions. We don't pay attention to the greediness flag here.\n\u003c/p\u003e",
          "module": "Text.Regex.Deriv.RE",
          "name": "partDeriv",
          "package": "regex-deriv",
          "signature": "RE -\u003e Char -\u003e [RE]",
          "source": "src/Text-Regex-Deriv-RE.html#partDeriv",
          "type": "function"
        },
        "index": {
          "description": "function partDeriv implements the partial derivative operations for regular expressions We don pay attention to the greediness flag here",
          "hierarchy": "Text Regex Deriv RE",
          "module": "Text.Regex.Deriv.RE",
          "name": "partDeriv",
          "normalized": "RE-\u003eChar-\u003e[RE]",
          "package": "regex-deriv",
          "partial": "Deriv",
          "signature": "RE-\u003eChar-\u003e[RE]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-deriv/docs/Text-Regex-Deriv-RE.html#v:partDeriv"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.Deriv.RE",
          "name": "partDerivSub",
          "package": "regex-deriv",
          "signature": "RE -\u003e Char -\u003e [RE]",
          "source": "src/Text-Regex-Deriv-RE.html#partDerivSub",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex Deriv RE",
          "module": "Text.Regex.Deriv.RE",
          "name": "partDerivSub",
          "normalized": "RE-\u003eChar-\u003e[RE]",
          "package": "regex-deriv",
          "partial": "Deriv Sub",
          "signature": "RE-\u003eChar-\u003e[RE]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-deriv/docs/Text-Regex-Deriv-RE.html#v:partDerivSub"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003efunction \u003ccode\u003e\u003ca\u003eresToRE\u003c/a\u003e\u003c/code\u003e sums up a list of regular expressions with the choice operation.\n\u003c/p\u003e",
          "module": "Text.Regex.Deriv.RE",
          "name": "resToRE",
          "package": "regex-deriv",
          "signature": "[RE] -\u003e RE",
          "source": "src/Text-Regex-Deriv-RE.html#resToRE",
          "type": "function"
        },
        "index": {
          "description": "function resToRE sums up list of regular expressions with the choice operation",
          "hierarchy": "Text Regex Deriv RE",
          "module": "Text.Regex.Deriv.RE",
          "name": "resToRE",
          "normalized": "[RE]-\u003eRE",
          "package": "regex-deriv",
          "partial": "To RE",
          "signature": "[RE]-\u003eRE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-deriv/docs/Text-Regex-Deriv-RE.html#v:resToRE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003efunction \u003ccode\u003e\u003ca\u003esigmaRE\u003c/a\u003e\u003c/code\u003e returns all characters appearing in a reg exp.\n\u003c/p\u003e",
          "module": "Text.Regex.Deriv.RE",
          "name": "sigmaRE",
          "package": "regex-deriv",
          "signature": "RE -\u003e [Char]",
          "source": "src/Text-Regex-Deriv-RE.html#sigmaRE",
          "type": "function"
        },
        "index": {
          "description": "function sigmaRE returns all characters appearing in reg exp",
          "hierarchy": "Text Regex Deriv RE",
          "module": "Text.Regex.Deriv.RE",
          "name": "sigmaRE",
          "normalized": "RE-\u003e[Char]",
          "package": "regex-deriv",
          "partial": "RE",
          "signature": "RE-\u003e[Char]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-deriv/docs/Text-Regex-Deriv-RE.html#v:sigmaRE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.Deriv.RE",
          "name": "sigmaREsub",
          "package": "regex-deriv",
          "signature": "RE -\u003e [Char]",
          "source": "src/Text-Regex-Deriv-RE.html#sigmaREsub",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex Deriv RE",
          "module": "Text.Regex.Deriv.RE",
          "name": "sigmaREsub",
          "normalized": "RE-\u003e[Char]",
          "package": "regex-deriv",
          "partial": "REsub",
          "signature": "RE-\u003e[Char]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-deriv/docs/Text-Regex-Deriv-RE.html#v:sigmaREsub"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eA translation schema from the external syntax (ERE) to our interal syntax (xhaskell style pattern)\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Text.Regex.Deriv.Translate",
          "name": "Translate",
          "package": "regex-deriv",
          "source": "src/Text-Regex-Deriv-Translate.html",
          "type": "module"
        },
        "index": {
          "description": "translation schema from the external syntax ERE to our interal syntax xhaskell style pattern",
          "hierarchy": "Text Regex Deriv Translate",
          "module": "Text.Regex.Deriv.Translate",
          "name": "Translate",
          "package": "regex-deriv",
          "partial": "Translate",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/regex-deriv/docs/Text-Regex-Deriv-Translate.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTranslating external pattern to internal pattern\n\u003c/p\u003e",
          "module": "Text.Regex.Deriv.Translate",
          "name": "translate",
          "package": "regex-deriv",
          "signature": "EPat -\u003e Pat",
          "source": "src/Text-Regex-Deriv-Translate.html#translate",
          "type": "function"
        },
        "index": {
          "description": "Translating external pattern to internal pattern",
          "hierarchy": "Text Regex Deriv Translate",
          "module": "Text.Regex.Deriv.Translate",
          "name": "translate",
          "normalized": "EPat-\u003ePat",
          "package": "regex-deriv",
          "signature": "EPat-\u003ePat",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-deriv/docs/Text-Regex-Deriv-Translate.html#v:translate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003efor posix \n\u003c/p\u003e",
          "module": "Text.Regex.Deriv.Translate",
          "name": "translatePosix",
          "package": "regex-deriv",
          "signature": "EPat -\u003e (Pat, IntMap ())",
          "source": "src/Text-Regex-Deriv-Translate.html#translatePosix",
          "type": "function"
        },
        "index": {
          "description": "for posix",
          "hierarchy": "Text Regex Deriv Translate",
          "module": "Text.Regex.Deriv.Translate",
          "name": "translatePosix",
          "normalized": "EPat-\u003e(Pat,IntMap())",
          "package": "regex-deriv",
          "partial": "Posix",
          "signature": "EPat-\u003e(Pat,IntMap())",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-deriv/docs/Text-Regex-Deriv-Translate.html#v:translatePosix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.Deriv.Word",
          "name": "Word",
          "package": "regex-deriv",
          "source": "src/Text-Regex-Deriv-Word.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Text Regex Deriv Word",
          "module": "Text.Regex.Deriv.Word",
          "name": "Word",
          "package": "regex-deriv",
          "partial": "Word",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/regex-deriv/docs/Text-Regex-Deriv-Word.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ethe Word type class\n\u003c/p\u003e",
          "module": "Text.Regex.Deriv.Word",
          "name": "Word",
          "package": "regex-deriv",
          "source": "src/Text-Regex-Deriv-Word.html#Word",
          "type": "class"
        },
        "index": {
          "description": "the Word type class",
          "hierarchy": "Text Regex Deriv Word",
          "module": "Text.Regex.Deriv.Word",
          "name": "Word",
          "package": "regex-deriv",
          "partial": "Word",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/regex-deriv/docs/Text-Regex-Deriv-Word.html#t:Word"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.Deriv.Word",
          "name": "append",
          "package": "regex-deriv",
          "signature": "a -\u003e a -\u003e a",
          "source": "src/Text-Regex-Deriv-Word.html#append",
          "type": "method"
        },
        "index": {
          "hierarchy": "Text Regex Deriv Word",
          "module": "Text.Regex.Deriv.Word",
          "name": "append",
          "normalized": "a-\u003ea-\u003ea",
          "package": "regex-deriv",
          "signature": "a-\u003ea-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/regex-deriv/docs/Text-Regex-Deriv-Word.html#v:append"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.Deriv.Word",
          "name": "drop",
          "package": "regex-deriv",
          "signature": "Int -\u003e a -\u003e a",
          "source": "src/Text-Regex-Deriv-Word.html#drop",
          "type": "method"
        },
        "index": {
          "hierarchy": "Text Regex Deriv Word",
          "module": "Text.Regex.Deriv.Word",
          "name": "drop",
          "normalized": "Int-\u003ea-\u003ea",
          "package": "regex-deriv",
          "signature": "Int-\u003ea-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/regex-deriv/docs/Text-Regex-Deriv-Word.html#v:drop"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.Deriv.Word",
          "name": "empty",
          "package": "regex-deriv",
          "signature": "a",
          "source": "src/Text-Regex-Deriv-Word.html#empty",
          "type": "method"
        },
        "index": {
          "hierarchy": "Text Regex Deriv Word",
          "module": "Text.Regex.Deriv.Word",
          "name": "empty",
          "package": "regex-deriv",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/regex-deriv/docs/Text-Regex-Deriv-Word.html#v:empty"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.Deriv.Word",
          "name": "length",
          "package": "regex-deriv",
          "signature": "a -\u003e Int",
          "source": "src/Text-Regex-Deriv-Word.html#length",
          "type": "method"
        },
        "index": {
          "hierarchy": "Text Regex Deriv Word",
          "module": "Text.Regex.Deriv.Word",
          "name": "length",
          "normalized": "a-\u003eInt",
          "package": "regex-deriv",
          "signature": "a-\u003eInt",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/regex-deriv/docs/Text-Regex-Deriv-Word.html#v:length"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.Deriv.Word",
          "name": "reverse",
          "package": "regex-deriv",
          "signature": "a -\u003e a",
          "source": "src/Text-Regex-Deriv-Word.html#reverse",
          "type": "method"
        },
        "index": {
          "hierarchy": "Text Regex Deriv Word",
          "module": "Text.Regex.Deriv.Word",
          "name": "reverse",
          "normalized": "a-\u003ea",
          "package": "regex-deriv",
          "signature": "a-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/regex-deriv/docs/Text-Regex-Deriv-Word.html#v:reverse"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.Deriv.Word",
          "name": "take",
          "package": "regex-deriv",
          "signature": "Int -\u003e a -\u003e a",
          "source": "src/Text-Regex-Deriv-Word.html#take",
          "type": "method"
        },
        "index": {
          "hierarchy": "Text Regex Deriv Word",
          "module": "Text.Regex.Deriv.Word",
          "name": "take",
          "normalized": "Int-\u003ea-\u003ea",
          "package": "regex-deriv",
          "signature": "Int-\u003ea-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/regex-deriv/docs/Text-Regex-Deriv-Word.html#v:take"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.Deriv.Word",
          "name": "uncons",
          "package": "regex-deriv",
          "signature": "a -\u003e Maybe (Char, a)",
          "source": "src/Text-Regex-Deriv-Word.html#uncons",
          "type": "method"
        },
        "index": {
          "hierarchy": "Text Regex Deriv Word",
          "module": "Text.Regex.Deriv.Word",
          "name": "uncons",
          "normalized": "a-\u003eMaybe(Char,a)",
          "package": "regex-deriv",
          "signature": "a-\u003eMaybe(Char,a)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/regex-deriv/docs/Text-Regex-Deriv-Word.html#v:uncons"
      }
    }
  ]
]