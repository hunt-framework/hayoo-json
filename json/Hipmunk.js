[
  {
    "cmd": "delete-by-query",
    "query": {
      "contexts": [
        "package"
      ],
      "query": {
        "op": "case",
        "type": "word",
        "word": "Hipmunk"
      },
      "type": "context"
    }
  },
  [
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eRigid bodies and their properties.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Physics.Hipmunk.Body",
          "name": "Body",
          "package": "Hipmunk",
          "source": "src/Physics-Hipmunk-Body.html",
          "type": "module"
        },
        "index": {
          "description": "Rigid bodies and their properties",
          "hierarchy": "Physics Hipmunk Body",
          "module": "Physics.Hipmunk.Body",
          "name": "Body",
          "package": "Hipmunk",
          "partial": "Body",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Body.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Physics.Hipmunk.Body",
          "name": "AngVel",
          "package": "Hipmunk",
          "source": "src/Physics-Hipmunk-Body.html#AngVel",
          "type": "type"
        },
        "index": {
          "hierarchy": "Physics Hipmunk Body",
          "module": "Physics.Hipmunk.Body",
          "name": "AngVel",
          "package": "Hipmunk",
          "partial": "Ang Vel",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Body.html#t:AngVel"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA rigid body representing the physical properties of an\n   object, but without a shape. It may help to think of it as a\n   particle that is able to rotate.\n\u003c/p\u003e",
          "module": "Physics.Hipmunk.Body",
          "name": "Body",
          "package": "Hipmunk",
          "source": "src/Physics-Hipmunk-Internal.html#Body",
          "type": "data"
        },
        "index": {
          "description": "rigid body representing the physical properties of an object but without shape It may help to think of it as particle that is able to rotate",
          "hierarchy": "Physics Hipmunk Body",
          "module": "Physics.Hipmunk.Body",
          "name": "Body",
          "package": "Hipmunk",
          "partial": "Body",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Body.html#t:Body"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Physics.Hipmunk.Body",
          "name": "Force",
          "package": "Hipmunk",
          "source": "src/Physics-Hipmunk-Body.html#Force",
          "type": "type"
        },
        "index": {
          "hierarchy": "Physics Hipmunk Body",
          "module": "Physics.Hipmunk.Body",
          "name": "Force",
          "package": "Hipmunk",
          "partial": "Force",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Body.html#t:Force"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Physics.Hipmunk.Body",
          "name": "Mass",
          "package": "Hipmunk",
          "source": "src/Physics-Hipmunk-Body.html#Mass",
          "type": "type"
        },
        "index": {
          "hierarchy": "Physics Hipmunk Body",
          "module": "Physics.Hipmunk.Body",
          "name": "Mass",
          "package": "Hipmunk",
          "partial": "Mass",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Body.html#t:Mass"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Physics.Hipmunk.Body",
          "name": "Moment",
          "package": "Hipmunk",
          "source": "src/Physics-Hipmunk-Body.html#Moment",
          "type": "type"
        },
        "index": {
          "hierarchy": "Physics Hipmunk Body",
          "module": "Physics.Hipmunk.Body",
          "name": "Moment",
          "package": "Hipmunk",
          "partial": "Moment",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Body.html#t:Moment"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Physics.Hipmunk.Body",
          "name": "Torque",
          "package": "Hipmunk",
          "source": "src/Physics-Hipmunk-Body.html#Torque",
          "type": "type"
        },
        "index": {
          "hierarchy": "Physics Hipmunk Body",
          "module": "Physics.Hipmunk.Body",
          "name": "Torque",
          "package": "Hipmunk",
          "partial": "Torque",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Body.html#t:Torque"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Physics.Hipmunk.Body",
          "name": "Velocity",
          "package": "Hipmunk",
          "source": "src/Physics-Hipmunk-Body.html#Velocity",
          "type": "type"
        },
        "index": {
          "hierarchy": "Physics Hipmunk Body",
          "module": "Physics.Hipmunk.Body",
          "name": "Velocity",
          "package": "Hipmunk",
          "partial": "Velocity",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Body.html#t:Velocity"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Physics.Hipmunk.Body",
          "name": "angVel",
          "package": "Hipmunk",
          "signature": "Body -\u003e StateVar AngVel",
          "source": "src/Physics-Hipmunk-Body.html#angVel",
          "type": "function"
        },
        "index": {
          "hierarchy": "Physics Hipmunk Body",
          "module": "Physics.Hipmunk.Body",
          "name": "angVel",
          "normalized": "Body-\u003eStateVar AngVel",
          "package": "Hipmunk",
          "partial": "Vel",
          "signature": "Body-\u003eStateVar AngVel",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Body.html#v:angVel"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Physics.Hipmunk.Body",
          "name": "angle",
          "package": "Hipmunk",
          "signature": "Body -\u003e StateVar Angle",
          "source": "src/Physics-Hipmunk-Body.html#angle",
          "type": "function"
        },
        "index": {
          "hierarchy": "Physics Hipmunk Body",
          "module": "Physics.Hipmunk.Body",
          "name": "angle",
          "normalized": "Body-\u003eStateVar Angle",
          "package": "Hipmunk",
          "signature": "Body-\u003eStateVar Angle",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Body.html#v:angle"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003edampedSpring (b1,a1) (b2,a2) rlen k dmp dt\u003c/code\u003e applies a damped\n   spring force between bodies \u003ccode\u003eb1\u003c/code\u003e and \u003ccode\u003eb2\u003c/code\u003e at anchors\n   \u003ccode\u003ea1\u003c/code\u003e and \u003ccode\u003ea2\u003c/code\u003e, respectively. \u003ccode\u003ek\u003c/code\u003e is the spring constant\n   (force/distance), \u003ccode\u003erlen\u003c/code\u003e is the rest length of the spring,\n   \u003ccode\u003edmp\u003c/code\u003e is the damping constant (force/velocity), and \u003ccode\u003edt\u003c/code\u003e\n   is the time step to apply the force over. Both anchors are\n   in body coordinates.\n\u003c/p\u003e\u003cp\u003eNote: large damping values can be unstable, you should use\n   the damped spring constraint instead.\n\u003c/p\u003e",
          "module": "Physics.Hipmunk.Body",
          "name": "applyDampedSpring",
          "package": "Hipmunk",
          "signature": "(Body, Position) -\u003e (Body, Position) -\u003e Distance -\u003e CpFloat -\u003e Damping -\u003e Time -\u003e IO ()",
          "source": "src/Physics-Hipmunk-Body.html#applyDampedSpring",
          "type": "function"
        },
        "index": {
          "description": "dampedSpring b1 a1 b2 a2 rlen dmp dt applies damped spring force between bodies b1 and b2 at anchors a1 and a2 respectively is the spring constant force distance rlen is the rest length of the spring dmp is the damping constant force velocity and dt is the time step to apply the force over Both anchors are in body coordinates Note large damping values can be unstable you should use the damped spring constraint instead",
          "hierarchy": "Physics Hipmunk Body",
          "module": "Physics.Hipmunk.Body",
          "name": "applyDampedSpring",
          "normalized": "(Body,Position)-\u003e(Body,Position)-\u003eDistance-\u003eCpFloat-\u003eDamping-\u003eTime-\u003eIO()",
          "package": "Hipmunk",
          "partial": "Damped Spring",
          "signature": "(Body,Position)-\u003e(Body,Position)-\u003eDistance-\u003eCpFloat-\u003eDamping-\u003eTime-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Body.html#v:applyDampedSpring"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eapplyForce b f r\u003c/code\u003e applies to the body \u003ccode\u003eb\u003c/code\u003e the force\n   \u003ccode\u003ef\u003c/code\u003e with offset \u003ccode\u003er\u003c/code\u003e, both vectors in world coordinates.\n   This is the most stable way to change a body's velocity.\n\u003c/p\u003e\u003cp\u003eNote that the force is accumulated in the body, so you\n   may need to call \u003ccode\u003e\u003ca\u003eapplyOnlyForce\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Physics.Hipmunk.Body",
          "name": "applyForce",
          "package": "Hipmunk",
          "signature": "Body -\u003e Vector -\u003e Position -\u003e IO ()",
          "source": "src/Physics-Hipmunk-Body.html#applyForce",
          "type": "function"
        },
        "index": {
          "description": "applyForce applies to the body the force with offset both vectors in world coordinates This is the most stable way to change body velocity Note that the force is accumulated in the body so you may need to call applyOnlyForce",
          "hierarchy": "Physics Hipmunk Body",
          "module": "Physics.Hipmunk.Body",
          "name": "applyForce",
          "normalized": "Body-\u003eVector-\u003ePosition-\u003eIO()",
          "package": "Hipmunk",
          "partial": "Force",
          "signature": "Body-\u003eVector-\u003ePosition-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Body.html#v:applyForce"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eapplyImpulse b j r\u003c/code\u003e applies to the body \u003ccode\u003eb\u003c/code\u003e the impulse\n   \u003ccode\u003ej\u003c/code\u003e with offset \u003ccode\u003er\u003c/code\u003e, both vectors in world coordinates.\n\u003c/p\u003e",
          "module": "Physics.Hipmunk.Body",
          "name": "applyImpulse",
          "package": "Hipmunk",
          "signature": "Body -\u003e Vector -\u003e Position -\u003e IO ()",
          "source": "src/Physics-Hipmunk-Body.html#applyImpulse",
          "type": "function"
        },
        "index": {
          "description": "applyImpulse applies to the body the impulse with offset both vectors in world coordinates",
          "hierarchy": "Physics Hipmunk Body",
          "module": "Physics.Hipmunk.Body",
          "name": "applyImpulse",
          "normalized": "Body-\u003eVector-\u003ePosition-\u003eIO()",
          "package": "Hipmunk",
          "partial": "Impulse",
          "signature": "Body-\u003eVector-\u003ePosition-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Body.html#v:applyImpulse"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eapplyOnlyForce b f r\u003c/code\u003e applies a force like \u003ccode\u003e\u003ca\u003eapplyForce\u003c/a\u003e\u003c/code\u003e,\n   but calling \u003ccode\u003e\u003ca\u003eresetForces\u003c/a\u003e\u003c/code\u003e before. Note that using this\n   function is preferable as it is optimized over this common\n   case.\n\u003c/p\u003e",
          "module": "Physics.Hipmunk.Body",
          "name": "applyOnlyForce",
          "package": "Hipmunk",
          "signature": "Body -\u003e Vector -\u003e Position -\u003e IO ()",
          "source": "src/Physics-Hipmunk-Body.html#applyOnlyForce",
          "type": "function"
        },
        "index": {
          "description": "applyOnlyForce applies force like applyForce but calling resetForces before Note that using this function is preferable as it is optimized over this common case",
          "hierarchy": "Physics Hipmunk Body",
          "module": "Physics.Hipmunk.Body",
          "name": "applyOnlyForce",
          "normalized": "Body-\u003eVector-\u003ePosition-\u003eIO()",
          "package": "Hipmunk",
          "partial": "Only Force",
          "signature": "Body-\u003eVector-\u003ePosition-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Body.html#v:applyOnlyForce"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Physics.Hipmunk.Body",
          "name": "force",
          "package": "Hipmunk",
          "signature": "Body -\u003e StateVar Force",
          "source": "src/Physics-Hipmunk-Body.html#force",
          "type": "function"
        },
        "index": {
          "hierarchy": "Physics Hipmunk Body",
          "module": "Physics.Hipmunk.Body",
          "name": "force",
          "normalized": "Body-\u003eStateVar Force",
          "package": "Hipmunk",
          "signature": "Body-\u003eStateVar Force",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Body.html#v:force"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFor a vector \u003ccode\u003ep\u003c/code\u003e in body \u003ccode\u003eb\u003c/code\u003e's coordinates,\n   \u003ccode\u003elocalToWorld b p\u003c/code\u003e returns the corresponding vector\n   in world coordinates.\n\u003c/p\u003e",
          "module": "Physics.Hipmunk.Body",
          "name": "localToWorld",
          "package": "Hipmunk",
          "signature": "Body -\u003e Position -\u003e IO Position",
          "source": "src/Physics-Hipmunk-Body.html#localToWorld",
          "type": "function"
        },
        "index": {
          "description": "For vector in body coordinates localToWorld returns the corresponding vector in world coordinates",
          "hierarchy": "Physics Hipmunk Body",
          "module": "Physics.Hipmunk.Body",
          "name": "localToWorld",
          "normalized": "Body-\u003ePosition-\u003eIO Position",
          "package": "Hipmunk",
          "partial": "To World",
          "signature": "Body-\u003ePosition-\u003eIO Position",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Body.html#v:localToWorld"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Physics.Hipmunk.Body",
          "name": "mass",
          "package": "Hipmunk",
          "signature": "Body -\u003e StateVar Mass",
          "source": "src/Physics-Hipmunk-Body.html#mass",
          "type": "function"
        },
        "index": {
          "hierarchy": "Physics Hipmunk Body",
          "module": "Physics.Hipmunk.Body",
          "name": "mass",
          "normalized": "Body-\u003eStateVar Mass",
          "package": "Hipmunk",
          "signature": "Body-\u003eStateVar Mass",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Body.html#v:mass"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMaximum angular velocity after integrating, defaults to infinity.\n\u003c/p\u003e",
          "module": "Physics.Hipmunk.Body",
          "name": "maxAngVel",
          "package": "Hipmunk",
          "signature": "Body -\u003e StateVar CpFloat",
          "source": "src/Physics-Hipmunk-Body.html#maxAngVel",
          "type": "function"
        },
        "index": {
          "description": "Maximum angular velocity after integrating defaults to infinity",
          "hierarchy": "Physics Hipmunk Body",
          "module": "Physics.Hipmunk.Body",
          "name": "maxAngVel",
          "normalized": "Body-\u003eStateVar CpFloat",
          "package": "Hipmunk",
          "partial": "Ang Vel",
          "signature": "Body-\u003eStateVar CpFloat",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Body.html#v:maxAngVel"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMaximum linear velocity after integrating, defaults to infinity.\n\u003c/p\u003e",
          "module": "Physics.Hipmunk.Body",
          "name": "maxVelocity",
          "package": "Hipmunk",
          "signature": "Body -\u003e StateVar CpFloat",
          "source": "src/Physics-Hipmunk-Body.html#maxVelocity",
          "type": "function"
        },
        "index": {
          "description": "Maximum linear velocity after integrating defaults to infinity",
          "hierarchy": "Physics Hipmunk Body",
          "module": "Physics.Hipmunk.Body",
          "name": "maxVelocity",
          "normalized": "Body-\u003eStateVar CpFloat",
          "package": "Hipmunk",
          "partial": "Velocity",
          "signature": "Body-\u003eStateVar CpFloat",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Body.html#v:maxVelocity"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Physics.Hipmunk.Body",
          "name": "moment",
          "package": "Hipmunk",
          "signature": "Body -\u003e StateVar Moment",
          "source": "src/Physics-Hipmunk-Body.html#moment",
          "type": "function"
        },
        "index": {
          "hierarchy": "Physics Hipmunk Body",
          "module": "Physics.Hipmunk.Body",
          "name": "moment",
          "normalized": "Body-\u003eStateVar Moment",
          "package": "Hipmunk",
          "signature": "Body-\u003eStateVar Moment",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Body.html#v:moment"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003enewBody mass inertia\u003c/code\u003e creates a new \u003ccode\u003e\u003ca\u003eBody\u003c/a\u003e\u003c/code\u003e with\n   the given mass and moment of inertia.\n\u003c/p\u003e\u003cp\u003eIt is recommended to call \u003ccode\u003esetPosition\u003c/code\u003e afterwards.\n\u003c/p\u003e",
          "module": "Physics.Hipmunk.Body",
          "name": "newBody",
          "package": "Hipmunk",
          "signature": "Mass -\u003e Moment -\u003e IO Body",
          "source": "src/Physics-Hipmunk-Body.html#newBody",
          "type": "function"
        },
        "index": {
          "description": "newBody mass inertia creates new Body with the given mass and moment of inertia It is recommended to call setPosition afterwards",
          "hierarchy": "Physics Hipmunk Body",
          "module": "Physics.Hipmunk.Body",
          "name": "newBody",
          "normalized": "Mass-\u003eMoment-\u003eIO Body",
          "package": "Hipmunk",
          "partial": "Body",
          "signature": "Mass-\u003eMoment-\u003eIO Body",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Body.html#v:newBody"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eNote that using this function to change the position\n   on every step is not recommended as it may leave\n   the velocity out of sync.\n\u003c/p\u003e",
          "module": "Physics.Hipmunk.Body",
          "name": "position",
          "package": "Hipmunk",
          "signature": "Body -\u003e StateVar Position",
          "source": "src/Physics-Hipmunk-Body.html#position",
          "type": "function"
        },
        "index": {
          "description": "Note that using this function to change the position on every step is not recommended as it may leave the velocity out of sync",
          "hierarchy": "Physics Hipmunk Body",
          "module": "Physics.Hipmunk.Body",
          "name": "position",
          "normalized": "Body-\u003eStateVar Position",
          "package": "Hipmunk",
          "signature": "Body-\u003eStateVar Position",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Body.html#v:position"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eresetForces b\u003c/code\u003e redefines as zero all forces and torque\n   acting on body \u003ccode\u003eb\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Physics.Hipmunk.Body",
          "name": "resetForces",
          "package": "Hipmunk",
          "signature": "Body -\u003e IO ()",
          "source": "src/Physics-Hipmunk-Body.html#resetForces",
          "type": "function"
        },
        "index": {
          "description": "resetForces redefines as zero all forces and torque acting on body",
          "hierarchy": "Physics Hipmunk Body",
          "module": "Physics.Hipmunk.Body",
          "name": "resetForces",
          "normalized": "Body-\u003eIO()",
          "package": "Hipmunk",
          "partial": "Forces",
          "signature": "Body-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Body.html#v:resetForces"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eslew b newpos dt\u003c/code\u003e changes the body \u003ccode\u003eb\u003c/code\u003e's velocity\n   so that it reaches \u003ccode\u003enewpos\u003c/code\u003e in \u003ccode\u003edt\u003c/code\u003e time.\n\u003c/p\u003e\u003cp\u003eIt is usually used to change the position of a\n   static body in the world. In that case, remember\n   to reset the velocity to zero afterwards!\n\u003c/p\u003e",
          "module": "Physics.Hipmunk.Body",
          "name": "slew",
          "package": "Hipmunk",
          "signature": "Body -\u003e Position -\u003e Time -\u003e IO ()",
          "source": "src/Physics-Hipmunk-Body.html#slew",
          "type": "function"
        },
        "index": {
          "description": "slew newpos dt changes the body velocity so that it reaches newpos in dt time It is usually used to change the position of static body in the world In that case remember to reset the velocity to zero afterwards",
          "hierarchy": "Physics Hipmunk Body",
          "module": "Physics.Hipmunk.Body",
          "name": "slew",
          "normalized": "Body-\u003ePosition-\u003eTime-\u003eIO()",
          "package": "Hipmunk",
          "signature": "Body-\u003ePosition-\u003eTime-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Body.html#v:slew"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Physics.Hipmunk.Body",
          "name": "torque",
          "package": "Hipmunk",
          "signature": "Body -\u003e StateVar Torque",
          "source": "src/Physics-Hipmunk-Body.html#torque",
          "type": "function"
        },
        "index": {
          "hierarchy": "Physics Hipmunk Body",
          "module": "Physics.Hipmunk.Body",
          "name": "torque",
          "normalized": "Body-\u003eStateVar Torque",
          "package": "Hipmunk",
          "signature": "Body-\u003eStateVar Torque",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Body.html#v:torque"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eupdatePosition b dt\u003c/code\u003e redefines the body position like\n   \u003ccode\u003e\u003ca\u003eupdateVelocity\u003c/a\u003e\u003c/code\u003e (and it also shouldn't be called if you\n   are adding this body to a space).\n\u003c/p\u003e",
          "module": "Physics.Hipmunk.Body",
          "name": "updatePosition",
          "package": "Hipmunk",
          "signature": "Body -\u003e Time -\u003e IO ()",
          "source": "src/Physics-Hipmunk-Body.html#updatePosition",
          "type": "function"
        },
        "index": {
          "description": "updatePosition dt redefines the body position like updateVelocity and it also shouldn be called if you are adding this body to space",
          "hierarchy": "Physics Hipmunk Body",
          "module": "Physics.Hipmunk.Body",
          "name": "updatePosition",
          "normalized": "Body-\u003eTime-\u003eIO()",
          "package": "Hipmunk",
          "partial": "Position",
          "signature": "Body-\u003eTime-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Body.html#v:updatePosition"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eupdateVelocity b gravity damping dt\u003c/code\u003e redefines body \u003ccode\u003eb\u003c/code\u003e's\n   linear and angular velocity to account for the force/torque\n   being applied to it, the gravity and a damping factor\n   during \u003ccode\u003edt\u003c/code\u003e time using Euler integration.\n\u003c/p\u003e\u003cp\u003eNote that this function only needs to be called if you\n   are not adding the body to a space.\n\u003c/p\u003e",
          "module": "Physics.Hipmunk.Body",
          "name": "updateVelocity",
          "package": "Hipmunk",
          "signature": "Body -\u003e Vector -\u003e Damping -\u003e Time -\u003e IO ()",
          "source": "src/Physics-Hipmunk-Body.html#updateVelocity",
          "type": "function"
        },
        "index": {
          "description": "updateVelocity gravity damping dt redefines body linear and angular velocity to account for the force torque being applied to it the gravity and damping factor during dt time using Euler integration Note that this function only needs to be called if you are not adding the body to space",
          "hierarchy": "Physics Hipmunk Body",
          "module": "Physics.Hipmunk.Body",
          "name": "updateVelocity",
          "normalized": "Body-\u003eVector-\u003eDamping-\u003eTime-\u003eIO()",
          "package": "Hipmunk",
          "partial": "Velocity",
          "signature": "Body-\u003eVector-\u003eDamping-\u003eTime-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Body.html#v:updateVelocity"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Physics.Hipmunk.Body",
          "name": "velocity",
          "package": "Hipmunk",
          "signature": "Body -\u003e StateVar Velocity",
          "source": "src/Physics-Hipmunk-Body.html#velocity",
          "type": "function"
        },
        "index": {
          "hierarchy": "Physics Hipmunk Body",
          "module": "Physics.Hipmunk.Body",
          "name": "velocity",
          "normalized": "Body-\u003eStateVar Velocity",
          "package": "Hipmunk",
          "signature": "Body-\u003eStateVar Velocity",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Body.html#v:velocity"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFor a vector \u003ccode\u003ep\u003c/code\u003e in world coordinates,\n   \u003ccode\u003eworldToLocal b p\u003c/code\u003e returns the corresponding vector\n   in body \u003ccode\u003eb\u003c/code\u003e's coordinates.\n\u003c/p\u003e",
          "module": "Physics.Hipmunk.Body",
          "name": "worldToLocal",
          "package": "Hipmunk",
          "signature": "Body -\u003e Position -\u003e IO Position",
          "source": "src/Physics-Hipmunk-Body.html#worldToLocal",
          "type": "function"
        },
        "index": {
          "description": "For vector in world coordinates worldToLocal returns the corresponding vector in body coordinates",
          "hierarchy": "Physics Hipmunk Body",
          "module": "Physics.Hipmunk.Body",
          "name": "worldToLocal",
          "normalized": "Body-\u003ePosition-\u003eIO Position",
          "package": "Hipmunk",
          "partial": "To Local",
          "signature": "Body-\u003ePosition-\u003eIO Position",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Body.html#v:worldToLocal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eCallbacks are functions that are called whenever certain\n events happen.  For example, you may use a callback to know\n when a player bumps into an enemy.  Or when a bullet hits its\n target.  Or how strong was a collision.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Physics.Hipmunk.Callbacks",
          "name": "Callbacks",
          "package": "Hipmunk",
          "source": "src/Physics-Hipmunk-Callbacks.html",
          "type": "module"
        },
        "index": {
          "description": "Callbacks are functions that are called whenever certain events happen For example you may use callback to know when player bumps into an enemy Or when bullet hits its target Or how strong was collision",
          "hierarchy": "Physics Hipmunk Callbacks",
          "module": "Physics.Hipmunk.Callbacks",
          "name": "Callbacks",
          "package": "Hipmunk",
          "partial": "Callbacks",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Callbacks.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePhantom type used in \u003ccode\u003eBegin\u003c/code\u003e collision events.\n\u003c/p\u003e",
          "module": "Physics.Hipmunk.Callbacks",
          "name": "Begin",
          "package": "Hipmunk",
          "source": "src/Physics-Hipmunk-Callbacks.html#Begin",
          "type": "data"
        },
        "index": {
          "description": "Phantom type used in Begin collision events",
          "hierarchy": "Physics Hipmunk Callbacks",
          "module": "Physics.Hipmunk.Callbacks",
          "name": "Begin",
          "package": "Hipmunk",
          "partial": "Begin",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Callbacks.html#t:Begin"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMonad where callbacks are run.  Within this monad you have\n access to functions describing the collision.  You can also\n run any IO actions using \u003ccode\u003eliftIO\u003c/code\u003e from \u003ccode\u003etransformers\u003c/code\u003e package.\n However, remember not to call \u003ccode\u003e\u003ca\u003espaceAdd\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003espaceRemove\u003c/a\u003e\u003c/code\u003e\n outside a \u003ccode\u003ePostStep\u003c/code\u003e callback -- use \u003ccode\u003e\u003ca\u003epostStep\u003c/a\u003e\u003c/code\u003e instead, for example:\n\u003c/p\u003e\u003cpre\u003e\n postStep entity (currentSpaceRemove entity)\n\u003c/pre\u003e\u003cp\u003eThe phantom type \u003ccode\u003et\u003c/code\u003e describes the type of callback, which can be\n\u003c/p\u003e\u003cdl\u003e\u003cdt\u003e\u003ccode\u003e\u003ca\u003eBegin\u003c/a\u003e\u003c/code\u003e\u003c/dt\u003e\u003cdd\u003e When the collision first occurs.\n\u003c/dd\u003e\u003cdt\u003e\u003ccode\u003e\u003ca\u003ePreSolve\u003c/a\u003e\u003c/code\u003e\u003c/dt\u003e\u003cdd\u003e Before the collision is processed.\n\u003c/dd\u003e\u003cdt\u003e\u003ccode\u003e\u003ca\u003ePostSolve\u003c/a\u003e\u003c/code\u003e\u003c/dt\u003e\u003cdd\u003e After the collision is processed.\n\u003c/dd\u003e\u003cdt\u003e\u003ccode\u003e\u003ca\u003eSeparate\u003c/a\u003e\u003c/code\u003e\u003c/dt\u003e\u003cdd\u003e When the collision ends.\n\u003c/dd\u003e\u003cdt\u003e\u003ccode\u003e\u003ca\u003ePostStep\u003c/a\u003e\u003c/code\u003e\u003c/dt\u003e\u003cdd\u003e After the \u003ccode\u003estep\u003c/code\u003e finishes.\n\u003c/dd\u003e\u003c/dl\u003e\u003cp\u003eThis phantom type is used to disallow invalid operations.  For\n example, you can't calculate the normal of a collision if you\n are in a \u003ccode\u003eSeparate\u003c/code\u003e event, as there is no collision inside\n this event.  And you can't add a new post-step callback inside\n a post-step callback.\n\u003c/p\u003e",
          "module": "Physics.Hipmunk.Callbacks",
          "name": "Callback",
          "package": "Hipmunk",
          "source": "src/Physics-Hipmunk-Callbacks.html#Callback",
          "type": "data"
        },
        "index": {
          "description": "Monad where callbacks are run Within this monad you have access to functions describing the collision You can also run any IO actions using liftIO from transformers package However remember not to call spaceAdd or spaceRemove outside PostStep callback use postStep instead for example postStep entity currentSpaceRemove entity The phantom type describes the type of callback which can be Begin When the collision first occurs PreSolve Before the collision is processed PostSolve After the collision is processed Separate When the collision ends PostStep After the step finishes This phantom type is used to disallow invalid operations For example you can calculate the normal of collision if you are in Separate event as there is no collision inside this event And you can add new post-step callback inside post-step callback",
          "hierarchy": "Physics Hipmunk Callbacks",
          "module": "Physics.Hipmunk.Callbacks",
          "name": "Callback",
          "package": "Hipmunk",
          "partial": "Callback",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Callbacks.html#t:Callback"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA 4-tuple of callbacks, one for each kind of collision\n event.\n\u003c/p\u003e\u003cp\u003e\u003ccode\u003ebeginHandler\u003c/code\u003e and \u003ccode\u003epreSolveHandler\u003c/code\u003e should return a \u003ccode\u003eBool\u003c/code\u003e\n stating \u003ccode\u003eTrue\u003c/code\u003e if the collision should be processed or \u003ccode\u003eFalse\u003c/code\u003e\n if the collision should be ignored.  If \u003ccode\u003ebeginHandler\u003c/code\u003e returns\n \u003ccode\u003eFalse\u003c/code\u003e, the collision will be completely ignored.  If\n \u003ccode\u003epreSolveHandler\u003c/code\u003e returns \u003ccode\u003eFalse\u003c/code\u003e, then the collision will be\n ignored only for this time step.\n\u003c/p\u003e\u003cp\u003eYou may also use \u003ccode\u003eNothing\u003c/code\u003e to use the default handlers.  The\n default is to process all collisions.  That is, \u003ccode\u003eHandler\n Nothing Nothing Nothing Nothing\u003c/code\u003e is the same as\n\u003c/p\u003e\u003cpre\u003e\n Handler {beginHandler     = Just (return True)\n         ,preSolveHandler  = Just (return True)\n         ,postSolveHandler = Just (return ())\n         ,separateHandler  = Just (return ())}\n\u003c/pre\u003e\u003cp\u003ehowever using \u003ccode\u003eNothing\u003c/code\u003e is more efficient (the Chipmunk\n library won't need to call a Haskell function).\n\u003c/p\u003e\u003cp\u003eNote that assigning \u003ccode\u003eNothing\u003c/code\u003e \u003cem\u003edoes not\u003c/em\u003e mean that the default\n set with \u003ccode\u003e\u003ca\u003esetDefaultCollisionHandler\u003c/a\u003e\u003c/code\u003e will be called.  That\n default is called only if there isn't a registered handler for\n the given collision types.\n\u003c/p\u003e",
          "module": "Physics.Hipmunk.Callbacks",
          "name": "CollisionHandler",
          "package": "Hipmunk",
          "source": "src/Physics-Hipmunk-Callbacks.html#CollisionHandler",
          "type": "data"
        },
        "index": {
          "description": "tuple of callbacks one for each kind of collision event beginHandler and preSolveHandler should return Bool stating True if the collision should be processed or False if the collision should be ignored If beginHandler returns False the collision will be completely ignored If preSolveHandler returns False then the collision will be ignored only for this time step You may also use Nothing to use the default handlers The default is to process all collisions That is Handler Nothing Nothing Nothing Nothing is the same as Handler beginHandler Just return True preSolveHandler Just return True postSolveHandler Just return separateHandler Just return however using Nothing is more efficient the Chipmunk library won need to call Haskell function Note that assigning Nothing does not mean that the default set with setDefaultCollisionHandler will be called That default is called only if there isn registered handler for the given collision types",
          "hierarchy": "Physics Hipmunk Callbacks",
          "module": "Physics.Hipmunk.Callbacks",
          "name": "CollisionHandler",
          "package": "Hipmunk",
          "partial": "Collision Handler",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Callbacks.html#t:CollisionHandler"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eClass of callbacks called from collision events. That is,\n everything other than \u003ccode\u003e\u003ca\u003ePostStep\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Physics.Hipmunk.Callbacks",
          "name": "NotPostStep",
          "package": "Hipmunk",
          "source": "src/Physics-Hipmunk-Callbacks.html#NotPostStep",
          "type": "class"
        },
        "index": {
          "description": "Class of callbacks called from collision events That is everything other than PostStep",
          "hierarchy": "Physics Hipmunk Callbacks",
          "module": "Physics.Hipmunk.Callbacks",
          "name": "NotPostStep",
          "package": "Hipmunk",
          "partial": "Not Post Step",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Callbacks.html#t:NotPostStep"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eClass of collision events other than \u003ccode\u003eSeparate\u003c/code\u003e.  That is,\n collision events where the shapes are touching or overlapping.\n\u003c/p\u003e",
          "module": "Physics.Hipmunk.Callbacks",
          "name": "NotSeparate",
          "package": "Hipmunk",
          "source": "src/Physics-Hipmunk-Callbacks.html#NotSeparate",
          "type": "class"
        },
        "index": {
          "description": "Class of collision events other than Separate That is collision events where the shapes are touching or overlapping",
          "hierarchy": "Physics Hipmunk Callbacks",
          "module": "Physics.Hipmunk.Callbacks",
          "name": "NotSeparate",
          "package": "Hipmunk",
          "partial": "Not Separate",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Callbacks.html#t:NotSeparate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePhantom type used in \u003ccode\u003ePostSolve\u003c/code\u003e collision events.\n\u003c/p\u003e",
          "module": "Physics.Hipmunk.Callbacks",
          "name": "PostSolve",
          "package": "Hipmunk",
          "source": "src/Physics-Hipmunk-Callbacks.html#PostSolve",
          "type": "data"
        },
        "index": {
          "description": "Phantom type used in PostSolve collision events",
          "hierarchy": "Physics Hipmunk Callbacks",
          "module": "Physics.Hipmunk.Callbacks",
          "name": "PostSolve",
          "package": "Hipmunk",
          "partial": "Post Solve",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Callbacks.html#t:PostSolve"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePhantom type used in \u003ccode\u003ePostStep\u003c/code\u003e callbacks.\n\u003c/p\u003e\u003cp\u003eThe phantom type \u003ccode\u003et\u003c/code\u003e inside this \u003ccode\u003ePostStep\u003c/code\u003e phantom type is\n  the collision event that originated this \u003ccode\u003ePostStep\u003c/code\u003e callback.\n  For example, if you add a \u003ccode\u003ePostStep\u003c/code\u003e from a \u003ccode\u003eBegin\u003c/code\u003e handler,\n  then it will have type \u003ccode\u003ePostStep Begin\u003c/code\u003e.  It is used by the\n  \u003ccode\u003ePostStep\u003c/code\u003e's instance of \u003ccode\u003e\u003ca\u003eNotSeparate\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Physics.Hipmunk.Callbacks",
          "name": "PostStep",
          "package": "Hipmunk",
          "source": "src/Physics-Hipmunk-Callbacks.html#PostStep",
          "type": "data"
        },
        "index": {
          "description": "Phantom type used in PostStep callbacks The phantom type inside this PostStep phantom type is the collision event that originated this PostStep callback For example if you add PostStep from Begin handler then it will have type PostStep Begin It is used by the PostStep instance of NotSeparate",
          "hierarchy": "Physics Hipmunk Callbacks",
          "module": "Physics.Hipmunk.Callbacks",
          "name": "PostStep",
          "package": "Hipmunk",
          "partial": "Post Step",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Callbacks.html#t:PostStep"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePhantom type used in \u003ccode\u003ePreSolve\u003c/code\u003e collision events.\n\u003c/p\u003e",
          "module": "Physics.Hipmunk.Callbacks",
          "name": "PreSolve",
          "package": "Hipmunk",
          "source": "src/Physics-Hipmunk-Callbacks.html#PreSolve",
          "type": "data"
        },
        "index": {
          "description": "Phantom type used in PreSolve collision events",
          "hierarchy": "Physics Hipmunk Callbacks",
          "module": "Physics.Hipmunk.Callbacks",
          "name": "PreSolve",
          "package": "Hipmunk",
          "partial": "Pre Solve",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Callbacks.html#t:PreSolve"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePhantom type used in \u003ccode\u003eSeparate\u003c/code\u003e collision events.\n\u003c/p\u003e",
          "module": "Physics.Hipmunk.Callbacks",
          "name": "Separate",
          "package": "Hipmunk",
          "source": "src/Physics-Hipmunk-Callbacks.html#Separate",
          "type": "data"
        },
        "index": {
          "description": "Phantom type used in Separate collision events",
          "hierarchy": "Physics Hipmunk Callbacks",
          "module": "Physics.Hipmunk.Callbacks",
          "name": "Separate",
          "package": "Hipmunk",
          "partial": "Separate",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Callbacks.html#t:Separate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Physics.Hipmunk.Callbacks",
          "name": "Handler",
          "package": "Hipmunk",
          "signature": "Handler",
          "source": "src/Physics-Hipmunk-Callbacks.html#CollisionHandler",
          "type": "function"
        },
        "index": {
          "hierarchy": "Physics Hipmunk Callbacks",
          "module": "Physics.Hipmunk.Callbacks",
          "name": "Handler",
          "package": "Hipmunk",
          "partial": "Handler",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Callbacks.html#v:Handler"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eaddCollisionHandler sp (cta,ctb) handler\u003c/code\u003e defines \u003ccode\u003ehandler\u003c/code\u003e\n as the handler to be used whenever a collision occurs between\n a shape of collision type \u003ccode\u003ecta\u003c/code\u003e and another of collision type\n \u003ccode\u003ectb\u003c/code\u003e (and vice versa).  Any other callback already registered\n to handle \u003ccode\u003e(cta,ctb)\u003c/code\u003e will be removed.\n\u003c/p\u003e\u003cp\u003eNote that you should \u003cem\u003enot\u003c/em\u003e add handlers to both combinations\n of \u003ccode\u003e(cta,ctb)\u003c/code\u003e and \u003ccode\u003e(ctb,cta)\u003c/code\u003e.  Doing so results in undefined\n behaviour.  A good rule of thumb is to always use \u003ccode\u003ecta \u003c=\n ctb\u003c/code\u003e, although this is not necessary.\n\u003c/p\u003e",
          "module": "Physics.Hipmunk.Callbacks",
          "name": "addCollisionHandler",
          "package": "Hipmunk",
          "signature": "Space -\u003e CollisionType -\u003e CollisionType -\u003e CollisionHandler -\u003e IO ()",
          "source": "src/Physics-Hipmunk-Callbacks.html#addCollisionHandler",
          "type": "function"
        },
        "index": {
          "description": "addCollisionHandler sp cta ctb handler defines handler as the handler to be used whenever collision occurs between shape of collision type cta and another of collision type ctb and vice versa Any other callback already registered to handle cta ctb will be removed Note that you should not add handlers to both combinations of cta ctb and ctb cta Doing so results in undefined behaviour good rule of thumb is to always use cta ctb although this is not necessary",
          "hierarchy": "Physics Hipmunk Callbacks",
          "module": "Physics.Hipmunk.Callbacks",
          "name": "addCollisionHandler",
          "normalized": "Space-\u003eCollisionType-\u003eCollisionType-\u003eCollisionHandler-\u003eIO()",
          "package": "Hipmunk",
          "partial": "Collision Handler",
          "signature": "Space-\u003eCollisionType-\u003eCollisionType-\u003eCollisionHandler-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Callbacks.html#v:addCollisionHandler"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Physics.Hipmunk.Callbacks",
          "name": "beginHandler",
          "package": "Hipmunk",
          "signature": "Maybe (Callback Begin Bool)",
          "source": "src/Physics-Hipmunk-Callbacks.html#CollisionHandler",
          "type": "function"
        },
        "index": {
          "hierarchy": "Physics Hipmunk Callbacks",
          "module": "Physics.Hipmunk.Callbacks",
          "name": "beginHandler",
          "package": "Hipmunk",
          "partial": "Handler",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Callbacks.html#v:beginHandler"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAdd an entity to the current \u003ccode\u003e\u003ca\u003eSpace\u003c/a\u003e\u003c/code\u003e from where this\n callback was called.  Don't add the same entity twice to a\n space.\n\u003c/p\u003e\u003cp\u003eYou can add entities only in \u003ccode\u003e\u003ca\u003ePostStep\u003c/a\u003e\u003c/code\u003e callbacks.  You should\n not use \u003ccode\u003eliftIO\u003c/code\u003e and \u003ccode\u003espaceAdd\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Physics.Hipmunk.Callbacks",
          "name": "currentSpaceAdd",
          "package": "Hipmunk",
          "signature": "a -\u003e Callback (PostStep t) ()",
          "source": "src/Physics-Hipmunk-Callbacks.html#currentSpaceAdd",
          "type": "function"
        },
        "index": {
          "description": "Add an entity to the current Space from where this callback was called Don add the same entity twice to space You can add entities only in PostStep callbacks You should not use liftIO and spaceAdd",
          "hierarchy": "Physics Hipmunk Callbacks",
          "module": "Physics.Hipmunk.Callbacks",
          "name": "currentSpaceAdd",
          "normalized": "a-\u003eCallback(PostStep b)()",
          "package": "Hipmunk",
          "partial": "Space Add",
          "signature": "a-\u003eCallback(PostStep t)()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Callbacks.html#v:currentSpaceAdd"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRemove an entity from the current \u003ccode\u003e\u003ca\u003eSpace\u003c/a\u003e\u003c/code\u003e from where this\n callback was called.  Don't remove an entity that wasn't\n added.\n\u003c/p\u003e\u003cp\u003eYou can remove entities only in \u003ccode\u003e\u003ca\u003ePostStep\u003c/a\u003e\u003c/code\u003e callbacks.  You\n should not use \u003ccode\u003eliftIO\u003c/code\u003e and \u003ccode\u003espaceRemove\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Physics.Hipmunk.Callbacks",
          "name": "currentSpaceRemove",
          "package": "Hipmunk",
          "signature": "a -\u003e Callback (PostStep t) ()",
          "source": "src/Physics-Hipmunk-Callbacks.html#currentSpaceRemove",
          "type": "function"
        },
        "index": {
          "description": "Remove an entity from the current Space from where this callback was called Don remove an entity that wasn added You can remove entities only in PostStep callbacks You should not use liftIO and spaceRemove",
          "hierarchy": "Physics Hipmunk Callbacks",
          "module": "Physics.Hipmunk.Callbacks",
          "name": "currentSpaceRemove",
          "normalized": "a-\u003eCallback(PostStep b)()",
          "package": "Hipmunk",
          "partial": "Space Remove",
          "signature": "a-\u003eCallback(PostStep t)()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Callbacks.html#v:currentSpaceRemove"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eTrue\u003c/code\u003e iff this is the first step that the shapes touched.\n\u003c/p\u003e",
          "module": "Physics.Hipmunk.Callbacks",
          "name": "isFirstContact",
          "package": "Hipmunk",
          "signature": "Callback t Bool",
          "source": "src/Physics-Hipmunk-Callbacks.html#isFirstContact",
          "type": "function"
        },
        "index": {
          "description": "True iff this is the first step that the shapes touched",
          "hierarchy": "Physics Hipmunk Callbacks",
          "module": "Physics.Hipmunk.Callbacks",
          "name": "isFirstContact",
          "package": "Hipmunk",
          "partial": "First Contact",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Callbacks.html#v:isFirstContact"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe normal vector of the collision.\n\u003c/p\u003e",
          "module": "Physics.Hipmunk.Callbacks",
          "name": "normal",
          "package": "Hipmunk",
          "signature": "Callback t Vector",
          "source": "src/Physics-Hipmunk-Callbacks.html#normal",
          "type": "function"
        },
        "index": {
          "description": "The normal vector of the collision",
          "hierarchy": "Physics Hipmunk Callbacks",
          "module": "Physics.Hipmunk.Callbacks",
          "name": "normal",
          "package": "Hipmunk",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Callbacks.html#v:normal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePoints where the collision occured.\n\u003c/p\u003e",
          "module": "Physics.Hipmunk.Callbacks",
          "name": "points",
          "package": "Hipmunk",
          "signature": "Callback t [Position]",
          "source": "src/Physics-Hipmunk-Callbacks.html#points",
          "type": "function"
        },
        "index": {
          "description": "Points where the collision occured",
          "hierarchy": "Physics Hipmunk Callbacks",
          "module": "Physics.Hipmunk.Callbacks",
          "name": "points",
          "normalized": "Callback a[Position]",
          "package": "Hipmunk",
          "signature": "Callback t[Position]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Callbacks.html#v:points"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Physics.Hipmunk.Callbacks",
          "name": "postSolveHandler",
          "package": "Hipmunk",
          "signature": "Maybe (Callback PostSolve ())",
          "source": "src/Physics-Hipmunk-Callbacks.html#CollisionHandler",
          "type": "function"
        },
        "index": {
          "hierarchy": "Physics Hipmunk Callbacks",
          "module": "Physics.Hipmunk.Callbacks",
          "name": "postSolveHandler",
          "normalized": "Maybe(Callback PostSolve())",
          "package": "Hipmunk",
          "partial": "Solve Handler",
          "signature": "Maybe(Callback PostSolve())",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Callbacks.html#v:postSolveHandler"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003epostStep e cb\u003c/code\u003e registers a callback \u003ccode\u003ecb\u003c/code\u003e for the \u003ccode\u003e\u003ca\u003ePostStep\u003c/a\u003e\u003c/code\u003e\n phase on a given entity \u003ccode\u003ee\u003c/code\u003e.  \u003ccode\u003ePostStep\u003c/code\u003e callbacks are called\n once when the \u003ccode\u003estep\u003c/code\u003e call finishes (and only on the current\n time step).  This is the only kind of callbacks that may call\n \u003ccode\u003e\u003ca\u003ecurrentSpaceAdd\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003ecurrentSpaceRemove\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eEach entity may have \u003cem\u003eat most one\u003c/em\u003e callback registered on it.\n If a second callback \u003ccode\u003ecb2\u003c/code\u003e gets registered on the same entity\n \u003ccode\u003ee\u003c/code\u003e, then callback \u003ccode\u003ecb\u003c/code\u003e \u003cem\u003ewill not\u003c/em\u003e be called, only \u003ccode\u003ecb2\u003c/code\u003e.\n This is not a bug, but a feature.  This allows you to say, for\n example, \u003ccode\u003epostStep shape (currentSpaceRemove shape)\u003c/code\u003e every\n time \u003ccode\u003eshape\u003c/code\u003e collides.  Even if \u003ccode\u003eshape\u003c/code\u003e collided many times in\n a single time step, only the last callback would be called and\n \u003ccode\u003eshape\u003c/code\u003e would be removed just once.\n\u003c/p\u003e\u003cp\u003eNote that this function registers a callback from within\n another callback, as this is the motivation of using\n \u003ccode\u003ePostStep\u003c/code\u003e callbacks.\n\u003c/p\u003e",
          "module": "Physics.Hipmunk.Callbacks",
          "name": "postStep",
          "package": "Hipmunk",
          "signature": "a -\u003e Callback (PostStep t) () -\u003e Callback t ()",
          "source": "src/Physics-Hipmunk-Callbacks.html#postStep",
          "type": "function"
        },
        "index": {
          "description": "postStep cb registers callback cb for the PostStep phase on given entity PostStep callbacks are called once when the step call finishes and only on the current time step This is the only kind of callbacks that may call currentSpaceAdd and currentSpaceRemove Each entity may have at most one callback registered on it If second callback cb2 gets registered on the same entity then callback cb will not be called only cb2 This is not bug but feature This allows you to say for example postStep shape currentSpaceRemove shape every time shape collides Even if shape collided many times in single time step only the last callback would be called and shape would be removed just once Note that this function registers callback from within another callback as this is the motivation of using PostStep callbacks",
          "hierarchy": "Physics Hipmunk Callbacks",
          "module": "Physics.Hipmunk.Callbacks",
          "name": "postStep",
          "normalized": "a-\u003eCallback(PostStep b)()-\u003eCallback b()",
          "package": "Hipmunk",
          "partial": "Step",
          "signature": "a-\u003eCallback(PostStep t)()-\u003eCallback t()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Callbacks.html#v:postStep"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Physics.Hipmunk.Callbacks",
          "name": "preSolveHandler",
          "package": "Hipmunk",
          "signature": "Maybe (Callback PreSolve Bool)",
          "source": "src/Physics-Hipmunk-Callbacks.html#CollisionHandler",
          "type": "function"
        },
        "index": {
          "hierarchy": "Physics Hipmunk Callbacks",
          "module": "Physics.Hipmunk.Callbacks",
          "name": "preSolveHandler",
          "package": "Hipmunk",
          "partial": "Solve Handler",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Callbacks.html#v:preSolveHandler"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eremoveCollisionHandler sp (cta,ctb)\u003c/code\u003e removes the handler\n that was registered to handle \u003ccode\u003e(cta,ctb)\u003c/code\u003e, if any (see\n \u003ccode\u003e\u003ca\u003eaddCollisionHandler\u003c/a\u003e\u003c/code\u003e).  Any collisions that would be handled\n by the removed handler will be handled by the default one (see\n \u003ccode\u003e\u003ca\u003esetDefaultCollisionHandler\u003c/a\u003e\u003c/code\u003e).\n\u003c/p\u003e\u003cp\u003eNote that you should \u003cem\u003ealways\u003c/em\u003e use the same order that was\n passed to \u003ccode\u003e\u003ca\u003eaddCollisionHandler\u003c/a\u003e\u003c/code\u003e. In other words, after\n \u003ccode\u003eaddCollisionHandler sp (cta,ctb) handler\u003c/code\u003e you should use\n \u003ccode\u003eremoveCollisionHandler sp (cta,ctb)\u003c/code\u003e, and \u003cem\u003enever\u003c/em\u003e\n \u003ccode\u003eremoveCollisionHandler sp (ctb,cta)\u003c/code\u003e (note the swapped\n tuple).\n\u003c/p\u003e\u003cp\u003eAlthough pointless, it is harmless to remove a callback that\n was not added.\n\u003c/p\u003e",
          "module": "Physics.Hipmunk.Callbacks",
          "name": "removeCollisionHandler",
          "package": "Hipmunk",
          "signature": "Space -\u003e CollisionType -\u003e CollisionType -\u003e IO ()",
          "source": "src/Physics-Hipmunk-Callbacks.html#removeCollisionHandler",
          "type": "function"
        },
        "index": {
          "description": "removeCollisionHandler sp cta ctb removes the handler that was registered to handle cta ctb if any see addCollisionHandler Any collisions that would be handled by the removed handler will be handled by the default one see setDefaultCollisionHandler Note that you should always use the same order that was passed to addCollisionHandler In other words after addCollisionHandler sp cta ctb handler you should use removeCollisionHandler sp cta ctb and never removeCollisionHandler sp ctb cta note the swapped tuple Although pointless it is harmless to remove callback that was not added",
          "hierarchy": "Physics Hipmunk Callbacks",
          "module": "Physics.Hipmunk.Callbacks",
          "name": "removeCollisionHandler",
          "normalized": "Space-\u003eCollisionType-\u003eCollisionType-\u003eIO()",
          "package": "Hipmunk",
          "partial": "Collision Handler",
          "signature": "Space-\u003eCollisionType-\u003eCollisionType-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Callbacks.html#v:removeCollisionHandler"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Physics.Hipmunk.Callbacks",
          "name": "separateHandler",
          "package": "Hipmunk",
          "signature": "Maybe (Callback Separate ())",
          "source": "src/Physics-Hipmunk-Callbacks.html#CollisionHandler",
          "type": "function"
        },
        "index": {
          "hierarchy": "Physics Hipmunk Callbacks",
          "module": "Physics.Hipmunk.Callbacks",
          "name": "separateHandler",
          "normalized": "Maybe(Callback Separate())",
          "package": "Hipmunk",
          "partial": "Handler",
          "signature": "Maybe(Callback Separate())",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Callbacks.html#v:separateHandler"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDefines a new default collision handler.  This handler is\n used whenever two shapes \u003ccode\u003ea\u003c/code\u003e and \u003ccode\u003eb\u003c/code\u003e collide such that no\n other collision pair function was defined to \u003ccode\u003ea\u003c/code\u003e's and \u003ccode\u003eb\u003c/code\u003e's\n collision types. The default is \u003ccode\u003eHandler Nothing Nothing\n Nothing Nothing\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Physics.Hipmunk.Callbacks",
          "name": "setDefaultCollisionHandler",
          "package": "Hipmunk",
          "signature": "Space -\u003e CollisionHandler -\u003e IO ()",
          "source": "src/Physics-Hipmunk-Callbacks.html#setDefaultCollisionHandler",
          "type": "function"
        },
        "index": {
          "description": "Defines new default collision handler This handler is used whenever two shapes and collide such that no other collision pair function was defined to and collision types The default is Handler Nothing Nothing Nothing Nothing",
          "hierarchy": "Physics Hipmunk Callbacks",
          "module": "Physics.Hipmunk.Callbacks",
          "name": "setDefaultCollisionHandler",
          "normalized": "Space-\u003eCollisionHandler-\u003eIO()",
          "package": "Hipmunk",
          "partial": "Default Collision Handler",
          "signature": "Space-\u003eCollisionHandler-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Callbacks.html#v:setDefaultCollisionHandler"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eShapes involved in this collision.\n\u003c/p\u003e",
          "module": "Physics.Hipmunk.Callbacks",
          "name": "shapes",
          "package": "Hipmunk",
          "signature": "Callback t (Shape, Shape)",
          "source": "src/Physics-Hipmunk-Callbacks.html#shapes",
          "type": "function"
        },
        "index": {
          "description": "Shapes involved in this collision",
          "hierarchy": "Physics Hipmunk Callbacks",
          "module": "Physics.Hipmunk.Callbacks",
          "name": "shapes",
          "normalized": "Callback a(Shape,Shape)",
          "package": "Hipmunk",
          "signature": "Callback t(Shape,Shape)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Callbacks.html#v:shapes"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe total impulse that was applied to resolve the collision.\n Returns incorrect results if elastic iterations are being used.\n\u003c/p\u003e",
          "module": "Physics.Hipmunk.Callbacks",
          "name": "totalImpulse",
          "package": "Hipmunk",
          "signature": "Callback (PostStep t) Vector",
          "source": "src/Physics-Hipmunk-Callbacks.html#totalImpulse",
          "type": "function"
        },
        "index": {
          "description": "The total impulse that was applied to resolve the collision Returns incorrect results if elastic iterations are being used",
          "hierarchy": "Physics Hipmunk Callbacks",
          "module": "Physics.Hipmunk.Callbacks",
          "name": "totalImpulse",
          "package": "Hipmunk",
          "partial": "Impulse",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Callbacks.html#v:totalImpulse"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe total impulse with friction that was applied to resolve\n the collision.  Returns incorrect results if elastic\n iterations are being used.\n\u003c/p\u003e",
          "module": "Physics.Hipmunk.Callbacks",
          "name": "totalImpulseWithFriction",
          "package": "Hipmunk",
          "signature": "Callback (PostStep t) Vector",
          "source": "src/Physics-Hipmunk-Callbacks.html#totalImpulseWithFriction",
          "type": "function"
        },
        "index": {
          "description": "The total impulse with friction that was applied to resolve the collision Returns incorrect results if elastic iterations are being used",
          "hierarchy": "Physics Hipmunk Callbacks",
          "module": "Physics.Hipmunk.Callbacks",
          "name": "totalImpulseWithFriction",
          "package": "Hipmunk",
          "partial": "Impulse With Friction",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Callbacks.html#v:totalImpulseWithFriction"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAs \u003ccode\u003e\u003ca\u003epostStep\u003c/a\u003e\u003c/code\u003e, registers a \u003ccode\u003ePostStep\u003c/code\u003e callback.  Unlike\n \u003ccode\u003e\u003ca\u003epostStep\u003c/a\u003e\u003c/code\u003e, this function allows you to register a \u003ccode\u003ePostStep\u003c/code\u003e\n callback from anywhere.  Also, from this callback you won't be\n in \u003ccode\u003e\u003ca\u003eCallback\u003c/a\u003e\u003c/code\u003e monad.  It is therefore unsafe and should not be\n used unless you really know what you are doing.\n\u003c/p\u003e",
          "module": "Physics.Hipmunk.Callbacks",
          "name": "unsafePostStep",
          "package": "Hipmunk",
          "signature": "Space -\u003e a -\u003e IO () -\u003e IO ()",
          "source": "src/Physics-Hipmunk-Callbacks.html#unsafePostStep",
          "type": "function"
        },
        "index": {
          "description": "As postStep registers PostStep callback Unlike postStep this function allows you to register PostStep callback from anywhere Also from this callback you won be in Callback monad It is therefore unsafe and should not be used unless you really know what you are doing",
          "hierarchy": "Physics Hipmunk Callbacks",
          "module": "Physics.Hipmunk.Callbacks",
          "name": "unsafePostStep",
          "normalized": "Space-\u003ea-\u003eIO()-\u003eIO()",
          "package": "Hipmunk",
          "partial": "Post Step",
          "signature": "Space-\u003ea-\u003eIO()-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Callbacks.html#v:unsafePostStep"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eFunctionality used by various modules and routines for\n initialization and change of global variables.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Physics.Hipmunk.Common",
          "name": "Common",
          "package": "Hipmunk",
          "source": "src/Physics-Hipmunk-Common.html",
          "type": "module"
        },
        "index": {
          "description": "Functionality used by various modules and routines for initialization and change of global variables",
          "hierarchy": "Physics Hipmunk Common",
          "module": "Physics.Hipmunk.Common",
          "name": "Common",
          "package": "Hipmunk",
          "partial": "Common",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Common.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eType synonym used to hint that the argument or result\n   represents an angle in radians.\n\u003c/p\u003e",
          "module": "Physics.Hipmunk.Common",
          "name": "Angle",
          "package": "Hipmunk",
          "source": "src/Physics-Hipmunk-Common.html#Angle",
          "type": "type"
        },
        "index": {
          "description": "Type synonym used to hint that the argument or result represents an angle in radians",
          "hierarchy": "Physics Hipmunk Common",
          "module": "Physics.Hipmunk.Common",
          "name": "Angle",
          "package": "Hipmunk",
          "partial": "Angle",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Common.html#t:Angle"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Physics.Hipmunk.Common",
          "name": "BiasCoef",
          "package": "Hipmunk",
          "source": "src/Physics-Hipmunk-Common.html#BiasCoef",
          "type": "type"
        },
        "index": {
          "hierarchy": "Physics Hipmunk Common",
          "module": "Physics.Hipmunk.Common",
          "name": "BiasCoef",
          "package": "Hipmunk",
          "partial": "Bias Coef",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Common.html#t:BiasCoef"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe floating point type used internally in Chipmunk.\n\u003c/p\u003e",
          "module": "Physics.Hipmunk.Common",
          "name": "CpFloat",
          "package": "Hipmunk",
          "source": "src/Physics-Hipmunk-Common.html#CpFloat",
          "type": "type"
        },
        "index": {
          "description": "The floating point type used internally in Chipmunk",
          "hierarchy": "Physics Hipmunk Common",
          "module": "Physics.Hipmunk.Common",
          "name": "CpFloat",
          "package": "Hipmunk",
          "partial": "Cp Float",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Common.html#t:CpFloat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eType synonym used to hint that the argument or result\n   represents a damping constant.\n\u003c/p\u003e",
          "module": "Physics.Hipmunk.Common",
          "name": "Damping",
          "package": "Hipmunk",
          "source": "src/Physics-Hipmunk-Common.html#Damping",
          "type": "type"
        },
        "index": {
          "description": "Type synonym used to hint that the argument or result represents damping constant",
          "hierarchy": "Physics Hipmunk Common",
          "module": "Physics.Hipmunk.Common",
          "name": "Damping",
          "package": "Hipmunk",
          "partial": "Damping",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Common.html#t:Damping"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eType synonym used to hint that the argument or result\n   represents a distance.\n\u003c/p\u003e",
          "module": "Physics.Hipmunk.Common",
          "name": "Distance",
          "package": "Hipmunk",
          "source": "src/Physics-Hipmunk-Common.html#Distance",
          "type": "type"
        },
        "index": {
          "description": "Type synonym used to hint that the argument or result represents distance",
          "hierarchy": "Physics Hipmunk Common",
          "module": "Physics.Hipmunk.Common",
          "name": "Distance",
          "package": "Hipmunk",
          "partial": "Distance",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Common.html#t:Distance"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eType synonym used to hint that the argument or result\n   represents a position.\n\u003c/p\u003e",
          "module": "Physics.Hipmunk.Common",
          "name": "Position",
          "package": "Hipmunk",
          "source": "src/Physics-Hipmunk-Common.html#Position",
          "type": "type"
        },
        "index": {
          "description": "Type synonym used to hint that the argument or result represents position",
          "hierarchy": "Physics Hipmunk Common",
          "module": "Physics.Hipmunk.Common",
          "name": "Position",
          "package": "Hipmunk",
          "partial": "Position",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Common.html#t:Position"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eType synonym used to hint that the argument or result\n   represents time.\n\u003c/p\u003e",
          "module": "Physics.Hipmunk.Common",
          "name": "Time",
          "package": "Hipmunk",
          "source": "src/Physics-Hipmunk-Common.html#Time",
          "type": "type"
        },
        "index": {
          "description": "Type synonym used to hint that the argument or result represents time",
          "hierarchy": "Physics Hipmunk Common",
          "module": "Physics.Hipmunk.Common",
          "name": "Time",
          "package": "Hipmunk",
          "partial": "Time",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Common.html#t:Time"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA two-dimensional vector. It is an instance of \u003ccode\u003e\u003ca\u003eNum\u003c/a\u003e\u003c/code\u003e\n   however the operations \u003ccode\u003e\u003ca\u003esignum\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e(*)\u003c/code\u003e are not\n   supported.\n\u003c/p\u003e",
          "module": "Physics.Hipmunk.Common",
          "name": "Vector",
          "package": "Hipmunk",
          "source": "src/Physics-Hipmunk-Common.html#Vector",
          "type": "data"
        },
        "index": {
          "description": "two-dimensional vector It is an instance of Num however the operations signum and are not supported",
          "hierarchy": "Physics Hipmunk Common",
          "module": "Physics.Hipmunk.Common",
          "name": "Vector",
          "package": "Hipmunk",
          "partial": "Vector",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Common.html#t:Vector"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Physics.Hipmunk.Common",
          "name": "Vector",
          "package": "Hipmunk",
          "signature": "Vector !CpFloat !CpFloat",
          "source": "src/Physics-Hipmunk-Common.html#Vector",
          "type": "function"
        },
        "index": {
          "hierarchy": "Physics Hipmunk Common",
          "module": "Physics.Hipmunk.Common",
          "name": "Vector",
          "package": "Hipmunk",
          "partial": "Vector",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Common.html#v:Vector"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Physics.Hipmunk.Common",
          "name": "biasCoef",
          "package": "Hipmunk",
          "signature": "StateVar BiasCoef",
          "source": "src/Physics-Hipmunk-Common.html#biasCoef",
          "type": "function"
        },
        "index": {
          "hierarchy": "Physics Hipmunk Common",
          "module": "Physics.Hipmunk.Common",
          "name": "biasCoef",
          "package": "Hipmunk",
          "partial": "Coef",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Common.html#v:biasCoef"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Physics.Hipmunk.Common",
          "name": "collisionSlop",
          "package": "Hipmunk",
          "signature": "StateVar CpFloat",
          "source": "src/Physics-Hipmunk-Common.html#collisionSlop",
          "type": "function"
        },
        "index": {
          "hierarchy": "Physics Hipmunk Common",
          "module": "Physics.Hipmunk.Common",
          "name": "collisionSlop",
          "package": "Hipmunk",
          "partial": "Slop",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Common.html#v:collisionSlop"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Physics.Hipmunk.Common",
          "name": "constraintBiasCoef",
          "package": "Hipmunk",
          "signature": "StateVar BiasCoef",
          "source": "src/Physics-Hipmunk-Common.html#constraintBiasCoef",
          "type": "function"
        },
        "index": {
          "hierarchy": "Physics Hipmunk Common",
          "module": "Physics.Hipmunk.Common",
          "name": "constraintBiasCoef",
          "package": "Hipmunk",
          "partial": "Bias Coef",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Common.html#v:constraintBiasCoef"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Physics.Hipmunk.Common",
          "name": "contactPersistence",
          "package": "Hipmunk",
          "signature": "StateVar CInt",
          "source": "src/Physics-Hipmunk-Common.html#contactPersistence",
          "type": "function"
        },
        "index": {
          "hierarchy": "Physics Hipmunk Common",
          "module": "Physics.Hipmunk.Common",
          "name": "contactPersistence",
          "package": "Hipmunk",
          "partial": "Persistence",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Common.html#v:contactPersistence"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003ev1 `cross` v2\u003c/code\u003e computes the familiar cross operation.\n\u003c/p\u003e",
          "module": "Physics.Hipmunk.Common",
          "name": "cross",
          "package": "Hipmunk",
          "signature": "Vector -\u003e Vector -\u003e CpFloat",
          "source": "src/Physics-Hipmunk-Common.html#cross",
          "type": "function"
        },
        "index": {
          "description": "v1 cross v2 computes the familiar cross operation",
          "hierarchy": "Physics Hipmunk Common",
          "module": "Physics.Hipmunk.Common",
          "name": "cross",
          "normalized": "Vector-\u003eVector-\u003eCpFloat",
          "package": "Hipmunk",
          "signature": "Vector-\u003eVector-\u003eCpFloat",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Common.html#v:cross"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003ev1 `dot` v2\u003c/code\u003e computes the familiar dot operation.\n\u003c/p\u003e",
          "module": "Physics.Hipmunk.Common",
          "name": "dot",
          "package": "Hipmunk",
          "signature": "Vector -\u003e Vector -\u003e CpFloat",
          "source": "src/Physics-Hipmunk-Common.html#dot",
          "type": "function"
        },
        "index": {
          "description": "v1 dot v2 computes the familiar dot operation",
          "hierarchy": "Physics Hipmunk Common",
          "module": "Physics.Hipmunk.Common",
          "name": "dot",
          "normalized": "Vector-\u003eVector-\u003eCpFloat",
          "package": "Hipmunk",
          "signature": "Vector-\u003eVector-\u003eCpFloat",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Common.html#v:dot"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstructs an unitary vector pointing to the given\n   angle (in radians).\n\u003c/p\u003e",
          "module": "Physics.Hipmunk.Common",
          "name": "fromAngle",
          "package": "Hipmunk",
          "signature": "Angle -\u003e Vector",
          "source": "src/Physics-Hipmunk-Common.html#fromAngle",
          "type": "function"
        },
        "index": {
          "description": "Constructs an unitary vector pointing to the given angle in radians",
          "hierarchy": "Physics Hipmunk Common",
          "module": "Physics.Hipmunk.Common",
          "name": "fromAngle",
          "normalized": "Angle-\u003eVector",
          "package": "Hipmunk",
          "partial": "Angle",
          "signature": "Angle-\u003eVector",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Common.html#v:fromAngle"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003einfinity\u003c/code\u003e may be used to create bodies with\n   an infinite mass.\n\u003c/p\u003e",
          "module": "Physics.Hipmunk.Common",
          "name": "infinity",
          "package": "Hipmunk",
          "signature": "CpFloat",
          "source": "src/Physics-Hipmunk-Common.html#infinity",
          "type": "function"
        },
        "index": {
          "description": "infinity may be used to create bodies with an infinite mass",
          "hierarchy": "Physics Hipmunk Common",
          "module": "Physics.Hipmunk.Common",
          "name": "infinity",
          "package": "Hipmunk",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Common.html#v:infinity"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInitilizes the Chipmunk library. This should be called\n   once before using any functions of this library.\n\u003c/p\u003e",
          "module": "Physics.Hipmunk.Common",
          "name": "initChipmunk",
          "package": "Hipmunk",
          "signature": "IO ()",
          "source": "src/Physics-Hipmunk-Common.html#initChipmunk",
          "type": "function"
        },
        "index": {
          "description": "Initilizes the Chipmunk library This should be called once before using any functions of this library",
          "hierarchy": "Physics Hipmunk Common",
          "module": "Physics.Hipmunk.Common",
          "name": "initChipmunk",
          "normalized": "IO()",
          "package": "Hipmunk",
          "partial": "Chipmunk",
          "signature": "IO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Common.html#v:initChipmunk"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe length of a vector.\n\u003c/p\u003e",
          "module": "Physics.Hipmunk.Common",
          "name": "len",
          "package": "Hipmunk",
          "signature": "Vector -\u003e CpFloat",
          "source": "src/Physics-Hipmunk-Common.html#len",
          "type": "function"
        },
        "index": {
          "description": "The length of vector",
          "hierarchy": "Physics Hipmunk Common",
          "module": "Physics.Hipmunk.Common",
          "name": "len",
          "normalized": "Vector-\u003eCpFloat",
          "package": "Hipmunk",
          "signature": "Vector-\u003eCpFloat",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Common.html#v:len"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eNormalizes the vector (i.e. divides it by its length).\n\u003c/p\u003e",
          "module": "Physics.Hipmunk.Common",
          "name": "normalize",
          "package": "Hipmunk",
          "signature": "Vector -\u003e Vector",
          "source": "src/Physics-Hipmunk-Common.html#normalize",
          "type": "function"
        },
        "index": {
          "description": "Normalizes the vector i.e divides it by its length",
          "hierarchy": "Physics Hipmunk Common",
          "module": "Physics.Hipmunk.Common",
          "name": "normalize",
          "normalized": "Vector-\u003eVector",
          "package": "Hipmunk",
          "signature": "Vector-\u003eVector",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Common.html#v:normalize"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eperp v\u003c/code\u003e is a vector of same length as \u003ccode\u003ev\u003c/code\u003e but perpendicular\n   to \u003ccode\u003ev\u003c/code\u003e (i.e. \u003ccode\u003etoAngle (perp v) - toAngle v\u003c/code\u003e equals \u003ccode\u003epi/2\u003c/code\u003e\n   modulo \u003ccode\u003e2*pi\u003c/code\u003e).\n\u003c/p\u003e",
          "module": "Physics.Hipmunk.Common",
          "name": "perp",
          "package": "Hipmunk",
          "signature": "Vector -\u003e Vector",
          "source": "src/Physics-Hipmunk-Common.html#perp",
          "type": "function"
        },
        "index": {
          "description": "perp is vector of same length as but perpendicular to i.e toAngle perp toAngle equals pi modulo pi",
          "hierarchy": "Physics Hipmunk Common",
          "module": "Physics.Hipmunk.Common",
          "name": "perp",
          "normalized": "Vector-\u003eVector",
          "package": "Hipmunk",
          "signature": "Vector-\u003eVector",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Common.html#v:perp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003ev1 `project` v2\u003c/code\u003e is the vector projection of \u003ccode\u003ev1\u003c/code\u003e onto \u003ccode\u003ev2\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Physics.Hipmunk.Common",
          "name": "project",
          "package": "Hipmunk",
          "signature": "Vector -\u003e Vector -\u003e Vector",
          "source": "src/Physics-Hipmunk-Common.html#project",
          "type": "function"
        },
        "index": {
          "description": "v1 project v2 is the vector projection of v1 onto v2",
          "hierarchy": "Physics Hipmunk Common",
          "module": "Physics.Hipmunk.Common",
          "name": "project",
          "normalized": "Vector-\u003eVector-\u003eVector",
          "package": "Hipmunk",
          "signature": "Vector-\u003eVector-\u003eVector",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Common.html#v:project"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eresetShapeCounter\u003c/code\u003e reset the shape counter to its default\n   value.  This is used to add determinism to a simulation.  As\n   the ids created with this counter may affect the order in\n   which the collisions happen, there may be very slight\n   differences in different simulations.  It may be very useful\n   to call \u003ccode\u003eresetShapeCounter\u003c/code\u003e everytime you start a new\n   simulation.\n\u003c/p\u003e\u003cp\u003eHowever, be careful as you should not use shapes created\n   before a call to \u003ccode\u003eresetCounter\u003c/code\u003e with shapes created after it\n   as they may have the same id.  This means that you can't add\n   shapes created after the call to a space created before it.\n\u003c/p\u003e",
          "module": "Physics.Hipmunk.Common",
          "name": "resetShapeCounter",
          "package": "Hipmunk",
          "signature": "IO ()",
          "source": "src/Physics-Hipmunk-Common.html#resetShapeCounter",
          "type": "function"
        },
        "index": {
          "description": "resetShapeCounter reset the shape counter to its default value This is used to add determinism to simulation As the ids created with this counter may affect the order in which the collisions happen there may be very slight differences in different simulations It may be very useful to call resetShapeCounter everytime you start new simulation However be careful as you should not use shapes created before call to resetCounter with shapes created after it as they may have the same id This means that you can add shapes created after the call to space created before it",
          "hierarchy": "Physics Hipmunk Common",
          "module": "Physics.Hipmunk.Common",
          "name": "resetShapeCounter",
          "normalized": "IO()",
          "package": "Hipmunk",
          "partial": "Shape Counter",
          "signature": "IO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Common.html#v:resetShapeCounter"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003ev1 `rotate` v2\u003c/code\u003e uses complex multiplication\n   to rotate (and scale) \u003ccode\u003ev1\u003c/code\u003e by \u003ccode\u003ev2\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Physics.Hipmunk.Common",
          "name": "rotate",
          "package": "Hipmunk",
          "signature": "Vector -\u003e Vector -\u003e Vector",
          "source": "src/Physics-Hipmunk-Common.html#rotate",
          "type": "function"
        },
        "index": {
          "description": "v1 rotate v2 uses complex multiplication to rotate and scale v1 by v2",
          "hierarchy": "Physics Hipmunk Common",
          "module": "Physics.Hipmunk.Common",
          "name": "rotate",
          "normalized": "Vector-\u003eVector-\u003eVector",
          "package": "Hipmunk",
          "signature": "Vector-\u003eVector-\u003eVector",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Common.html#v:rotate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eScales the components of a vector by the same amount.\n\u003c/p\u003e",
          "module": "Physics.Hipmunk.Common",
          "name": "scale",
          "package": "Hipmunk",
          "signature": "Vector -\u003e CpFloat -\u003e Vector",
          "source": "src/Physics-Hipmunk-Common.html#scale",
          "type": "function"
        },
        "index": {
          "description": "Scales the components of vector by the same amount",
          "hierarchy": "Physics Hipmunk Common",
          "module": "Physics.Hipmunk.Common",
          "name": "scale",
          "normalized": "Vector-\u003eCpFloat-\u003eVector",
          "package": "Hipmunk",
          "signature": "Vector-\u003eCpFloat-\u003eVector",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Common.html#v:scale"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003etoAngle v\u003c/code\u003e is the angle that \u003ccode\u003ev\u003c/code\u003e has\n   with the vector \u003ccode\u003eVector 1 0\u003c/code\u003e (modulo \u003ccode\u003e2*pi\u003c/code\u003e).\n\u003c/p\u003e",
          "module": "Physics.Hipmunk.Common",
          "name": "toAngle",
          "package": "Hipmunk",
          "signature": "Vector -\u003e Angle",
          "source": "src/Physics-Hipmunk-Common.html#toAngle",
          "type": "function"
        },
        "index": {
          "description": "toAngle is the angle that has with the vector Vector modulo pi",
          "hierarchy": "Physics Hipmunk Common",
          "module": "Physics.Hipmunk.Common",
          "name": "toAngle",
          "normalized": "Vector-\u003eAngle",
          "package": "Hipmunk",
          "partial": "Angle",
          "signature": "Vector-\u003eAngle",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Common.html#v:toAngle"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe inverse operation of \u003ccode\u003erotate\u003c/code\u003e, such that\n   \u003ccode\u003eunrotate (rotate v1 v2) v2\u003c/code\u003e equals \u003ccode\u003ev1\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Physics.Hipmunk.Common",
          "name": "unrotate",
          "package": "Hipmunk",
          "signature": "Vector -\u003e Vector -\u003e Vector",
          "source": "src/Physics-Hipmunk-Common.html#unrotate",
          "type": "function"
        },
        "index": {
          "description": "The inverse operation of rotate such that unrotate rotate v1 v2 v2 equals v1",
          "hierarchy": "Physics Hipmunk Common",
          "module": "Physics.Hipmunk.Common",
          "name": "unrotate",
          "normalized": "Vector-\u003eVector-\u003eVector",
          "package": "Hipmunk",
          "signature": "Vector-\u003eVector-\u003eVector",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Common.html#v:unrotate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eConstraints that restrict the bodies' movement.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Physics.Hipmunk.Constraint",
          "name": "Constraint",
          "package": "Hipmunk",
          "source": "src/Physics-Hipmunk-Constraint.html",
          "type": "module"
        },
        "index": {
          "description": "Constraints that restrict the bodies movement",
          "hierarchy": "Physics Hipmunk Constraint",
          "module": "Physics.Hipmunk.Constraint",
          "name": "Constraint",
          "package": "Hipmunk",
          "partial": "Constraint",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Constraint.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRepresents a constraint between two bodies. Don't forget to\n   add the bodies and the constraint itself to the space.\n   The phantom type indicates the type of the constraint.\n\u003c/p\u003e",
          "module": "Physics.Hipmunk.Constraint",
          "name": "Constraint",
          "package": "Hipmunk",
          "source": "src/Physics-Hipmunk-Internal.html#Constraint",
          "type": "data"
        },
        "index": {
          "description": "Represents constraint between two bodies Don forget to add the bodies and the constraint itself to the space The phantom type indicates the type of the constraint",
          "hierarchy": "Physics Hipmunk Constraint",
          "module": "Physics.Hipmunk.Constraint",
          "name": "Constraint",
          "package": "Hipmunk",
          "partial": "Constraint",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Constraint.html#t:Constraint"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA damped rotary spring constraint.\n\u003c/p\u003e",
          "module": "Physics.Hipmunk.Constraint",
          "name": "DampedRotarySpring",
          "package": "Hipmunk",
          "source": "src/Physics-Hipmunk-Constraint.html#DampedRotarySpring",
          "type": "data"
        },
        "index": {
          "description": "damped rotary spring constraint",
          "hierarchy": "Physics Hipmunk Constraint",
          "module": "Physics.Hipmunk.Constraint",
          "name": "DampedRotarySpring",
          "package": "Hipmunk",
          "partial": "Damped Rotary Spring",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Constraint.html#t:DampedRotarySpring"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA simple damped spring.  Generally this constraint\n   should be used instead of \u003ccode\u003eapplyDampedSpring\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Physics.Hipmunk.Constraint",
          "name": "DampedSpring",
          "package": "Hipmunk",
          "source": "src/Physics-Hipmunk-Constraint.html#DampedSpring",
          "type": "data"
        },
        "index": {
          "description": "simple damped spring Generally this constraint should be used instead of applyDampedSpring",
          "hierarchy": "Physics Hipmunk Constraint",
          "module": "Physics.Hipmunk.Constraint",
          "name": "DampedSpring",
          "package": "Hipmunk",
          "partial": "Damped Spring",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Constraint.html#t:DampedSpring"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA gear joint restricts the bodies movement to be\n   coordinated as if they were attached like dented gears.\n\u003c/p\u003e",
          "module": "Physics.Hipmunk.Constraint",
          "name": "Gear",
          "package": "Hipmunk",
          "source": "src/Physics-Hipmunk-Constraint.html#Gear",
          "type": "data"
        },
        "index": {
          "description": "gear joint restricts the bodies movement to be coordinated as if they were attached like dented gears",
          "hierarchy": "Physics Hipmunk Constraint",
          "module": "Physics.Hipmunk.Constraint",
          "name": "Gear",
          "package": "Hipmunk",
          "partial": "Gear",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Constraint.html#t:Gear"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA groove joint attaches a point on the second body\n   to a groove in the first one.\n\u003c/p\u003e",
          "module": "Physics.Hipmunk.Constraint",
          "name": "Groove",
          "package": "Hipmunk",
          "source": "src/Physics-Hipmunk-Constraint.html#Groove",
          "type": "data"
        },
        "index": {
          "description": "groove joint attaches point on the second body to groove in the first one",
          "hierarchy": "Physics Hipmunk Constraint",
          "module": "Physics.Hipmunk.Constraint",
          "name": "Groove",
          "package": "Hipmunk",
          "partial": "Groove",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Constraint.html#t:Groove"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA pin joint connects the bodies with a solid pin.\n   The anchor points are kept at a fixed distance.\n\u003c/p\u003e",
          "module": "Physics.Hipmunk.Constraint",
          "name": "Pin",
          "package": "Hipmunk",
          "source": "src/Physics-Hipmunk-Constraint.html#Pin",
          "type": "data"
        },
        "index": {
          "description": "pin joint connects the bodies with solid pin The anchor points are kept at fixed distance",
          "hierarchy": "Physics Hipmunk Constraint",
          "module": "Physics.Hipmunk.Constraint",
          "name": "Pin",
          "package": "Hipmunk",
          "partial": "Pin",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Constraint.html#t:Pin"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA pivot joint allows the bodies to pivot around\n   a single point.\n\u003c/p\u003e",
          "module": "Physics.Hipmunk.Constraint",
          "name": "Pivot",
          "package": "Hipmunk",
          "source": "src/Physics-Hipmunk-Constraint.html#Pivot",
          "type": "data"
        },
        "index": {
          "description": "pivot joint allows the bodies to pivot around single point",
          "hierarchy": "Physics Hipmunk Constraint",
          "module": "Physics.Hipmunk.Constraint",
          "name": "Pivot",
          "package": "Hipmunk",
          "partial": "Pivot",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Constraint.html#t:Pivot"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA ratchet constraint.\n\u003c/p\u003e",
          "module": "Physics.Hipmunk.Constraint",
          "name": "Ratchet",
          "package": "Hipmunk",
          "source": "src/Physics-Hipmunk-Constraint.html#Ratchet",
          "type": "data"
        },
        "index": {
          "description": "ratchet constraint",
          "hierarchy": "Physics Hipmunk Constraint",
          "module": "Physics.Hipmunk.Constraint",
          "name": "Ratchet",
          "package": "Hipmunk",
          "partial": "Ratchet",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Constraint.html#t:Ratchet"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA rotary limit constraints the difference of angle\n   between two bodies.\n\u003c/p\u003e",
          "module": "Physics.Hipmunk.Constraint",
          "name": "RotaryLimit",
          "package": "Hipmunk",
          "source": "src/Physics-Hipmunk-Constraint.html#RotaryLimit",
          "type": "data"
        },
        "index": {
          "description": "rotary limit constraints the difference of angle between two bodies",
          "hierarchy": "Physics Hipmunk Constraint",
          "module": "Physics.Hipmunk.Constraint",
          "name": "RotaryLimit",
          "package": "Hipmunk",
          "partial": "Rotary Limit",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Constraint.html#t:RotaryLimit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA simple motor that applies opposite impulses to each\n   body.  The rate is used to compute the torque.\n\u003c/p\u003e",
          "module": "Physics.Hipmunk.Constraint",
          "name": "SimpleMotor",
          "package": "Hipmunk",
          "source": "src/Physics-Hipmunk-Constraint.html#SimpleMotor",
          "type": "data"
        },
        "index": {
          "description": "simple motor that applies opposite impulses to each body The rate is used to compute the torque",
          "hierarchy": "Physics Hipmunk Constraint",
          "module": "Physics.Hipmunk.Constraint",
          "name": "SimpleMotor",
          "package": "Hipmunk",
          "partial": "Simple Motor",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Constraint.html#t:SimpleMotor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA slide joint is similar to a pin joint, however\n   it has a minimum and a maximum distance.\n\u003c/p\u003e",
          "module": "Physics.Hipmunk.Constraint",
          "name": "Slide",
          "package": "Hipmunk",
          "source": "src/Physics-Hipmunk-Constraint.html#Slide",
          "type": "data"
        },
        "index": {
          "description": "slide joint is similar to pin joint however it has minimum and maximum distance",
          "hierarchy": "Physics Hipmunk Constraint",
          "module": "Physics.Hipmunk.Constraint",
          "name": "Slide",
          "package": "Hipmunk",
          "partial": "Slide",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Constraint.html#t:Slide"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn unknown constraint \"type\".  Note that this isn't a\n   \u003ccode\u003eConstraintType\u003c/code\u003e because you can't create a constraint of\n   \u003ccode\u003eUnknown\u003c/code\u003e type.\n\u003c/p\u003e",
          "module": "Physics.Hipmunk.Constraint",
          "name": "Unknown",
          "package": "Hipmunk",
          "source": "src/Physics-Hipmunk-Internal.html#Unknown",
          "type": "data"
        },
        "index": {
          "description": "An unknown constraint type Note that this isn ConstraintType because you can create constraint of Unknown type",
          "hierarchy": "Physics Hipmunk Constraint",
          "module": "Physics.Hipmunk.Constraint",
          "name": "Unknown",
          "package": "Hipmunk",
          "partial": "Unknown",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Constraint.html#t:Unknown"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Physics.Hipmunk.Constraint",
          "name": "DampedRotarySpring",
          "package": "Hipmunk",
          "signature": "DampedRotarySpring",
          "source": "src/Physics-Hipmunk-Constraint.html#DampedRotarySpring",
          "type": "function"
        },
        "index": {
          "hierarchy": "Physics Hipmunk Constraint",
          "module": "Physics.Hipmunk.Constraint",
          "name": "DampedRotarySpring",
          "package": "Hipmunk",
          "partial": "Damped Rotary Spring",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Constraint.html#v:DampedRotarySpring"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Physics.Hipmunk.Constraint",
          "name": "DampedSpring",
          "package": "Hipmunk",
          "signature": "DampedSpring",
          "source": "src/Physics-Hipmunk-Constraint.html#DampedSpring",
          "type": "function"
        },
        "index": {
          "hierarchy": "Physics Hipmunk Constraint",
          "module": "Physics.Hipmunk.Constraint",
          "name": "DampedSpring",
          "package": "Hipmunk",
          "partial": "Damped Spring",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Constraint.html#v:DampedSpring"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Physics.Hipmunk.Constraint",
          "name": "Gear",
          "package": "Hipmunk",
          "signature": "Gear",
          "source": "src/Physics-Hipmunk-Constraint.html#Gear",
          "type": "function"
        },
        "index": {
          "hierarchy": "Physics Hipmunk Constraint",
          "module": "Physics.Hipmunk.Constraint",
          "name": "Gear",
          "package": "Hipmunk",
          "partial": "Gear",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Constraint.html#v:Gear"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Physics.Hipmunk.Constraint",
          "name": "Groove",
          "package": "Hipmunk",
          "signature": "Groove",
          "source": "src/Physics-Hipmunk-Constraint.html#Groove",
          "type": "function"
        },
        "index": {
          "hierarchy": "Physics Hipmunk Constraint",
          "module": "Physics.Hipmunk.Constraint",
          "name": "Groove",
          "package": "Hipmunk",
          "partial": "Groove",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Constraint.html#v:Groove"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Physics.Hipmunk.Constraint",
          "name": "Pin",
          "package": "Hipmunk",
          "signature": "Pin",
          "source": "src/Physics-Hipmunk-Constraint.html#Pin",
          "type": "function"
        },
        "index": {
          "hierarchy": "Physics Hipmunk Constraint",
          "module": "Physics.Hipmunk.Constraint",
          "name": "Pin",
          "package": "Hipmunk",
          "partial": "Pin",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Constraint.html#v:Pin"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eYou may specify the pivot point in world's coordinates\n   (so both bodies should be already in place).\n\u003c/p\u003e",
          "module": "Physics.Hipmunk.Constraint",
          "name": "Pivot1",
          "package": "Hipmunk",
          "signature": "Pivot1",
          "source": "src/Physics-Hipmunk-Constraint.html#Pivot",
          "type": "function"
        },
        "index": {
          "description": "You may specify the pivot point in world coordinates so both bodies should be already in place",
          "hierarchy": "Physics Hipmunk Constraint",
          "module": "Physics.Hipmunk.Constraint",
          "name": "Pivot1",
          "package": "Hipmunk",
          "partial": "Pivot",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Constraint.html#v:Pivot1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eOr you may specify the joint as two anchors (on each\n   body's coordinates), removing the need having the bodies\n   already in place.\n\u003c/p\u003e",
          "module": "Physics.Hipmunk.Constraint",
          "name": "Pivot2",
          "package": "Hipmunk",
          "signature": "Pivot2",
          "source": "src/Physics-Hipmunk-Constraint.html#Pivot",
          "type": "function"
        },
        "index": {
          "description": "Or you may specify the joint as two anchors on each body coordinates removing the need having the bodies already in place",
          "hierarchy": "Physics Hipmunk Constraint",
          "module": "Physics.Hipmunk.Constraint",
          "name": "Pivot2",
          "package": "Hipmunk",
          "partial": "Pivot",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Constraint.html#v:Pivot2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Physics.Hipmunk.Constraint",
          "name": "Ratchet",
          "package": "Hipmunk",
          "signature": "Ratchet",
          "source": "src/Physics-Hipmunk-Constraint.html#Ratchet",
          "type": "function"
        },
        "index": {
          "hierarchy": "Physics Hipmunk Constraint",
          "module": "Physics.Hipmunk.Constraint",
          "name": "Ratchet",
          "package": "Hipmunk",
          "partial": "Ratchet",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Constraint.html#v:Ratchet"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Physics.Hipmunk.Constraint",
          "name": "RotaryLimit",
          "package": "Hipmunk",
          "signature": "RotaryLimit",
          "source": "src/Physics-Hipmunk-Constraint.html#RotaryLimit",
          "type": "function"
        },
        "index": {
          "hierarchy": "Physics Hipmunk Constraint",
          "module": "Physics.Hipmunk.Constraint",
          "name": "RotaryLimit",
          "package": "Hipmunk",
          "partial": "Rotary Limit",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Constraint.html#v:RotaryLimit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Physics.Hipmunk.Constraint",
          "name": "SimpleMotor",
          "package": "Hipmunk",
          "signature": "SimpleMotor",
          "source": "src/Physics-Hipmunk-Constraint.html#SimpleMotor",
          "type": "function"
        },
        "index": {
          "hierarchy": "Physics Hipmunk Constraint",
          "module": "Physics.Hipmunk.Constraint",
          "name": "SimpleMotor",
          "package": "Hipmunk",
          "partial": "Simple Motor",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Constraint.html#v:SimpleMotor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Physics.Hipmunk.Constraint",
          "name": "Slide",
          "package": "Hipmunk",
          "signature": "Slide",
          "source": "src/Physics-Hipmunk-Constraint.html#Slide",
          "type": "function"
        },
        "index": {
          "hierarchy": "Physics Hipmunk Constraint",
          "module": "Physics.Hipmunk.Constraint",
          "name": "Slide",
          "package": "Hipmunk",
          "partial": "Slide",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Constraint.html#v:Slide"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFirst anchor. \n\u003c/p\u003e",
          "module": "Physics.Hipmunk.Constraint",
          "name": "dampedAnchor1",
          "package": "Hipmunk",
          "signature": "Position",
          "source": "src/Physics-Hipmunk-Constraint.html#DampedSpring",
          "type": "function"
        },
        "index": {
          "description": "First anchor",
          "hierarchy": "Physics Hipmunk Constraint",
          "module": "Physics.Hipmunk.Constraint",
          "name": "dampedAnchor1",
          "package": "Hipmunk",
          "partial": "Anchor",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Constraint.html#v:dampedAnchor1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSecond anchor. \n\u003c/p\u003e",
          "module": "Physics.Hipmunk.Constraint",
          "name": "dampedAnchor2",
          "package": "Hipmunk",
          "signature": "Position",
          "source": "src/Physics-Hipmunk-Constraint.html#DampedSpring",
          "type": "function"
        },
        "index": {
          "description": "Second anchor",
          "hierarchy": "Physics Hipmunk Constraint",
          "module": "Physics.Hipmunk.Constraint",
          "name": "dampedAnchor2",
          "package": "Hipmunk",
          "partial": "Anchor",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Constraint.html#v:dampedAnchor2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDamping. \n\u003c/p\u003e",
          "module": "Physics.Hipmunk.Constraint",
          "name": "dampedDamping",
          "package": "Hipmunk",
          "signature": "Damping",
          "source": "src/Physics-Hipmunk-Constraint.html#DampedSpring",
          "type": "function"
        },
        "index": {
          "description": "Damping",
          "hierarchy": "Physics Hipmunk Constraint",
          "module": "Physics.Hipmunk.Constraint",
          "name": "dampedDamping",
          "package": "Hipmunk",
          "partial": "Damping",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Constraint.html#v:dampedDamping"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRest length. \n\u003c/p\u003e",
          "module": "Physics.Hipmunk.Constraint",
          "name": "dampedRestLength",
          "package": "Hipmunk",
          "signature": "Distance",
          "source": "src/Physics-Hipmunk-Constraint.html#DampedSpring",
          "type": "function"
        },
        "index": {
          "description": "Rest length",
          "hierarchy": "Physics Hipmunk Constraint",
          "module": "Physics.Hipmunk.Constraint",
          "name": "dampedRestLength",
          "package": "Hipmunk",
          "partial": "Rest Length",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Constraint.html#v:dampedRestLength"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDamping. \n\u003c/p\u003e",
          "module": "Physics.Hipmunk.Constraint",
          "name": "dampedRotDamping",
          "package": "Hipmunk",
          "signature": "Damping",
          "source": "src/Physics-Hipmunk-Constraint.html#DampedRotarySpring",
          "type": "function"
        },
        "index": {
          "description": "Damping",
          "hierarchy": "Physics Hipmunk Constraint",
          "module": "Physics.Hipmunk.Constraint",
          "name": "dampedRotDamping",
          "package": "Hipmunk",
          "partial": "Rot Damping",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Constraint.html#v:dampedRotDamping"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRest angle. \n\u003c/p\u003e",
          "module": "Physics.Hipmunk.Constraint",
          "name": "dampedRotRestAngle",
          "package": "Hipmunk",
          "signature": "Angle",
          "source": "src/Physics-Hipmunk-Constraint.html#DampedRotarySpring",
          "type": "function"
        },
        "index": {
          "description": "Rest angle",
          "hierarchy": "Physics Hipmunk Constraint",
          "module": "Physics.Hipmunk.Constraint",
          "name": "dampedRotRestAngle",
          "package": "Hipmunk",
          "partial": "Rot Rest Angle",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Constraint.html#v:dampedRotRestAngle"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eStiffness. \n\u003c/p\u003e",
          "module": "Physics.Hipmunk.Constraint",
          "name": "dampedRotStiffness",
          "package": "Hipmunk",
          "signature": "CpFloat",
          "source": "src/Physics-Hipmunk-Constraint.html#DampedRotarySpring",
          "type": "function"
        },
        "index": {
          "description": "Stiffness",
          "hierarchy": "Physics Hipmunk Constraint",
          "module": "Physics.Hipmunk.Constraint",
          "name": "dampedRotStiffness",
          "package": "Hipmunk",
          "partial": "Rot Stiffness",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Constraint.html#v:dampedRotStiffness"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eStiffness. \n\u003c/p\u003e",
          "module": "Physics.Hipmunk.Constraint",
          "name": "dampedStiffness",
          "package": "Hipmunk",
          "signature": "CpFloat",
          "source": "src/Physics-Hipmunk-Constraint.html#DampedSpring",
          "type": "function"
        },
        "index": {
          "description": "Stiffness",
          "hierarchy": "Physics Hipmunk Constraint",
          "module": "Physics.Hipmunk.Constraint",
          "name": "dampedStiffness",
          "package": "Hipmunk",
          "partial": "Stiffness",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Constraint.html#v:dampedStiffness"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCompletely safe function that discards the constraint type\n   (which is a phantom type).  You can \"remember\" it again by\n   using \u003ccode\u003eunsafeRemember\u003c/code\u003e from the \u003ccode\u003eUnsafe\u003c/code\u003e module.\n\u003c/p\u003e",
          "module": "Physics.Hipmunk.Constraint",
          "name": "forgetC",
          "package": "Hipmunk",
          "signature": "Constraint a -\u003e Constraint Unknown",
          "source": "src/Physics-Hipmunk-Constraint.html#forgetC",
          "type": "function"
        },
        "index": {
          "description": "Completely safe function that discards the constraint type which is phantom type You can remember it again by using unsafeRemember from the Unsafe module",
          "hierarchy": "Physics Hipmunk Constraint",
          "module": "Physics.Hipmunk.Constraint",
          "name": "forgetC",
          "normalized": "Constraint a-\u003eConstraint Unknown",
          "package": "Hipmunk",
          "signature": "Constraint a-\u003eConstraint Unknown",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Constraint.html#v:forgetC"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePhase of the movement. \n\u003c/p\u003e",
          "module": "Physics.Hipmunk.Constraint",
          "name": "gearPhase",
          "package": "Hipmunk",
          "signature": "Angle",
          "source": "src/Physics-Hipmunk-Constraint.html#Gear",
          "type": "function"
        },
        "index": {
          "description": "Phase of the movement",
          "hierarchy": "Physics Hipmunk Constraint",
          "module": "Physics.Hipmunk.Constraint",
          "name": "gearPhase",
          "package": "Hipmunk",
          "partial": "Phase",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Constraint.html#v:gearPhase"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRatio between the gears. \n\u003c/p\u003e",
          "module": "Physics.Hipmunk.Constraint",
          "name": "gearRatio",
          "package": "Hipmunk",
          "signature": "CpFloat",
          "source": "src/Physics-Hipmunk-Constraint.html#Gear",
          "type": "function"
        },
        "index": {
          "description": "Ratio between the gears",
          "hierarchy": "Physics Hipmunk Constraint",
          "module": "Physics.Hipmunk.Constraint",
          "name": "gearRatio",
          "package": "Hipmunk",
          "partial": "Ratio",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Constraint.html#v:gearRatio"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePivot, in second body's coordinates. \n\u003c/p\u003e",
          "module": "Physics.Hipmunk.Constraint",
          "name": "groovePivot",
          "package": "Hipmunk",
          "signature": "Position",
          "source": "src/Physics-Hipmunk-Constraint.html#Groove",
          "type": "function"
        },
        "index": {
          "description": "Pivot in second body coordinates",
          "hierarchy": "Physics Hipmunk Constraint",
          "module": "Physics.Hipmunk.Constraint",
          "name": "groovePivot",
          "package": "Hipmunk",
          "partial": "Pivot",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Constraint.html#v:groovePivot"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGroove, in first body's coordinates. \n\u003c/p\u003e",
          "module": "Physics.Hipmunk.Constraint",
          "name": "groovePoints",
          "package": "Hipmunk",
          "signature": "(Position, Position)",
          "source": "src/Physics-Hipmunk-Constraint.html#Groove",
          "type": "function"
        },
        "index": {
          "description": "Groove in first body coordinates",
          "hierarchy": "Physics Hipmunk Constraint",
          "module": "Physics.Hipmunk.Constraint",
          "name": "groovePoints",
          "normalized": "(Position,Position)",
          "package": "Hipmunk",
          "partial": "Points",
          "signature": "(Position,Position)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Constraint.html#v:groovePoints"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003enewConstraint b1 b2 type_\u003c/code\u003e connects the two bodies \u003ccode\u003eb1\u003c/code\u003e and \u003ccode\u003eb2\u003c/code\u003e\n   with a constraint of the given type. Note that you should\n   add the \u003ccode\u003e\u003ca\u003eConstraint\u003c/a\u003e\u003c/code\u003e to a space.\n\u003c/p\u003e\u003cp\u003eThe \u003ccode\u003eConstraintType\u003c/code\u003e type class is implemented by all\n   constraint types to allow them to be manipulated by the same\n   framework while retaining type-safety, consequently it isn't\n   exported.\n\u003c/p\u003e",
          "module": "Physics.Hipmunk.Constraint",
          "name": "newConstraint",
          "package": "Hipmunk",
          "signature": "Body -\u003e Body -\u003e a -\u003e IO (Constraint a)",
          "source": "src/Physics-Hipmunk-Constraint.html#newConstraint",
          "type": "function"
        },
        "index": {
          "description": "newConstraint b1 b2 type connects the two bodies b1 and b2 with constraint of the given type Note that you should add the Constraint to space The ConstraintType type class is implemented by all constraint types to allow them to be manipulated by the same framework while retaining type-safety consequently it isn exported",
          "hierarchy": "Physics Hipmunk Constraint",
          "module": "Physics.Hipmunk.Constraint",
          "name": "newConstraint",
          "normalized": "Body-\u003eBody-\u003ea-\u003eIO(Constraint a)",
          "package": "Hipmunk",
          "partial": "Constraint",
          "signature": "Body-\u003eBody-\u003ea-\u003eIO(Constraint a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Constraint.html#v:newConstraint"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFirst anchor. \n\u003c/p\u003e",
          "module": "Physics.Hipmunk.Constraint",
          "name": "pinAnchor1",
          "package": "Hipmunk",
          "signature": "Position",
          "source": "src/Physics-Hipmunk-Constraint.html#Pin",
          "type": "function"
        },
        "index": {
          "description": "First anchor",
          "hierarchy": "Physics Hipmunk Constraint",
          "module": "Physics.Hipmunk.Constraint",
          "name": "pinAnchor1",
          "package": "Hipmunk",
          "partial": "Anchor",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Constraint.html#v:pinAnchor1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSecond anchor. \n\u003c/p\u003e",
          "module": "Physics.Hipmunk.Constraint",
          "name": "pinAnchor2",
          "package": "Hipmunk",
          "signature": "Position",
          "source": "src/Physics-Hipmunk-Constraint.html#Pin",
          "type": "function"
        },
        "index": {
          "description": "Second anchor",
          "hierarchy": "Physics Hipmunk Constraint",
          "module": "Physics.Hipmunk.Constraint",
          "name": "pinAnchor2",
          "package": "Hipmunk",
          "partial": "Anchor",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Constraint.html#v:pinAnchor2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFirst anchor. \n\u003c/p\u003e",
          "module": "Physics.Hipmunk.Constraint",
          "name": "pivotAnchor1",
          "package": "Hipmunk",
          "signature": "Position",
          "source": "src/Physics-Hipmunk-Constraint.html#Pivot",
          "type": "function"
        },
        "index": {
          "description": "First anchor",
          "hierarchy": "Physics Hipmunk Constraint",
          "module": "Physics.Hipmunk.Constraint",
          "name": "pivotAnchor1",
          "package": "Hipmunk",
          "partial": "Anchor",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Constraint.html#v:pivotAnchor1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSecond anchor. \n\u003c/p\u003e",
          "module": "Physics.Hipmunk.Constraint",
          "name": "pivotAnchor2",
          "package": "Hipmunk",
          "signature": "Position",
          "source": "src/Physics-Hipmunk-Constraint.html#Pivot",
          "type": "function"
        },
        "index": {
          "description": "Second anchor",
          "hierarchy": "Physics Hipmunk Constraint",
          "module": "Physics.Hipmunk.Constraint",
          "name": "pivotAnchor2",
          "package": "Hipmunk",
          "partial": "Anchor",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Constraint.html#v:pivotAnchor2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePivot point in world's coordinates. \n\u003c/p\u003e",
          "module": "Physics.Hipmunk.Constraint",
          "name": "pivotPos",
          "package": "Hipmunk",
          "signature": "Position",
          "source": "src/Physics-Hipmunk-Constraint.html#Pivot",
          "type": "function"
        },
        "index": {
          "description": "Pivot point in world coordinates",
          "hierarchy": "Physics Hipmunk Constraint",
          "module": "Physics.Hipmunk.Constraint",
          "name": "pivotPos",
          "package": "Hipmunk",
          "partial": "Pos",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Constraint.html#v:pivotPos"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRatchet. \n\u003c/p\u003e",
          "module": "Physics.Hipmunk.Constraint",
          "name": "ratchet",
          "package": "Hipmunk",
          "signature": "CpFloat",
          "source": "src/Physics-Hipmunk-Constraint.html#Ratchet",
          "type": "function"
        },
        "index": {
          "description": "Ratchet",
          "hierarchy": "Physics Hipmunk Constraint",
          "module": "Physics.Hipmunk.Constraint",
          "name": "ratchet",
          "package": "Hipmunk",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Constraint.html#v:ratchet"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePhase. \n\u003c/p\u003e",
          "module": "Physics.Hipmunk.Constraint",
          "name": "ratchetPhase",
          "package": "Hipmunk",
          "signature": "CpFloat",
          "source": "src/Physics-Hipmunk-Constraint.html#Ratchet",
          "type": "function"
        },
        "index": {
          "description": "Phase",
          "hierarchy": "Physics Hipmunk Constraint",
          "module": "Physics.Hipmunk.Constraint",
          "name": "ratchetPhase",
          "package": "Hipmunk",
          "partial": "Phase",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Constraint.html#v:ratchetPhase"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eredefine constr type_\u003c/code\u003e redefines \u003ccode\u003econstr\u003c/code\u003e's parameters\n   on-the-fly, allowing you to dynamically change the\n   constraint's behaviour.\n\u003c/p\u003e",
          "module": "Physics.Hipmunk.Constraint",
          "name": "redefineC",
          "package": "Hipmunk",
          "signature": "Constraint a -\u003e a -\u003e IO ()",
          "source": "src/Physics-Hipmunk-Constraint.html#redefineC",
          "type": "function"
        },
        "index": {
          "description": "redefine constr type redefines constr parameters on-the-fly allowing you to dynamically change the constraint behaviour",
          "hierarchy": "Physics Hipmunk Constraint",
          "module": "Physics.Hipmunk.Constraint",
          "name": "redefineC",
          "normalized": "Constraint a-\u003ea-\u003eIO()",
          "package": "Hipmunk",
          "signature": "Constraint a-\u003ea-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Constraint.html#v:redefineC"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMaximum distance. \n\u003c/p\u003e",
          "module": "Physics.Hipmunk.Constraint",
          "name": "rotaryMaxDist",
          "package": "Hipmunk",
          "signature": "Distance",
          "source": "src/Physics-Hipmunk-Constraint.html#RotaryLimit",
          "type": "function"
        },
        "index": {
          "description": "Maximum distance",
          "hierarchy": "Physics Hipmunk Constraint",
          "module": "Physics.Hipmunk.Constraint",
          "name": "rotaryMaxDist",
          "package": "Hipmunk",
          "partial": "Max Dist",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Constraint.html#v:rotaryMaxDist"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMinimum distance. \n\u003c/p\u003e",
          "module": "Physics.Hipmunk.Constraint",
          "name": "rotaryMinDist",
          "package": "Hipmunk",
          "signature": "Distance",
          "source": "src/Physics-Hipmunk-Constraint.html#RotaryLimit",
          "type": "function"
        },
        "index": {
          "description": "Minimum distance",
          "hierarchy": "Physics Hipmunk Constraint",
          "module": "Physics.Hipmunk.Constraint",
          "name": "rotaryMinDist",
          "package": "Hipmunk",
          "partial": "Min Dist",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Constraint.html#v:rotaryMinDist"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSets the constraint's bias coefficient.  By default it is\n   equal to the last value set globally with\n   \u003ccode\u003esetConstraintBiasCoef\u003c/code\u003e, which initially is \u003ccode\u003e0.1\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Physics.Hipmunk.Constraint",
          "name": "setBiasCoefC",
          "package": "Hipmunk",
          "signature": "BiasCoef -\u003e Constraint a -\u003e IO ()",
          "source": "src/Physics-Hipmunk-Constraint.html#setBiasCoefC",
          "type": "function"
        },
        "index": {
          "description": "Sets the constraint bias coefficient By default it is equal to the last value set globally with setConstraintBiasCoef which initially is",
          "hierarchy": "Physics Hipmunk Constraint",
          "module": "Physics.Hipmunk.Constraint",
          "name": "setBiasCoefC",
          "normalized": "BiasCoef-\u003eConstraint a-\u003eIO()",
          "package": "Hipmunk",
          "partial": "Bias Coef",
          "signature": "BiasCoef-\u003eConstraint a-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Constraint.html#v:setBiasCoefC"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Physics.Hipmunk.Constraint",
          "name": "setMaxBias",
          "package": "Hipmunk",
          "signature": "CpFloat -\u003e Constraint a -\u003e IO ()",
          "source": "src/Physics-Hipmunk-Constraint.html#setMaxBias",
          "type": "function"
        },
        "index": {
          "hierarchy": "Physics Hipmunk Constraint",
          "module": "Physics.Hipmunk.Constraint",
          "name": "setMaxBias",
          "normalized": "CpFloat-\u003eConstraint a-\u003eIO()",
          "package": "Hipmunk",
          "partial": "Max Bias",
          "signature": "CpFloat-\u003eConstraint a-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Constraint.html#v:setMaxBias"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Physics.Hipmunk.Constraint",
          "name": "setMaxForce",
          "package": "Hipmunk",
          "signature": "CpFloat -\u003e Constraint a -\u003e IO ()",
          "source": "src/Physics-Hipmunk-Constraint.html#setMaxForce",
          "type": "function"
        },
        "index": {
          "hierarchy": "Physics Hipmunk Constraint",
          "module": "Physics.Hipmunk.Constraint",
          "name": "setMaxForce",
          "normalized": "CpFloat-\u003eConstraint a-\u003eIO()",
          "package": "Hipmunk",
          "partial": "Max Force",
          "signature": "CpFloat-\u003eConstraint a-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Constraint.html#v:setMaxForce"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRate. \n\u003c/p\u003e",
          "module": "Physics.Hipmunk.Constraint",
          "name": "simpleMotorRate",
          "package": "Hipmunk",
          "signature": "CpFloat",
          "source": "src/Physics-Hipmunk-Constraint.html#SimpleMotor",
          "type": "function"
        },
        "index": {
          "description": "Rate",
          "hierarchy": "Physics Hipmunk Constraint",
          "module": "Physics.Hipmunk.Constraint",
          "name": "simpleMotorRate",
          "package": "Hipmunk",
          "partial": "Motor Rate",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Constraint.html#v:simpleMotorRate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFirst anchor. \n\u003c/p\u003e",
          "module": "Physics.Hipmunk.Constraint",
          "name": "slideAnchor1",
          "package": "Hipmunk",
          "signature": "Position",
          "source": "src/Physics-Hipmunk-Constraint.html#Slide",
          "type": "function"
        },
        "index": {
          "description": "First anchor",
          "hierarchy": "Physics Hipmunk Constraint",
          "module": "Physics.Hipmunk.Constraint",
          "name": "slideAnchor1",
          "package": "Hipmunk",
          "partial": "Anchor",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Constraint.html#v:slideAnchor1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSecond anchor. \n\u003c/p\u003e",
          "module": "Physics.Hipmunk.Constraint",
          "name": "slideAnchor2",
          "package": "Hipmunk",
          "signature": "Position",
          "source": "src/Physics-Hipmunk-Constraint.html#Slide",
          "type": "function"
        },
        "index": {
          "description": "Second anchor",
          "hierarchy": "Physics Hipmunk Constraint",
          "module": "Physics.Hipmunk.Constraint",
          "name": "slideAnchor2",
          "package": "Hipmunk",
          "partial": "Anchor",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Constraint.html#v:slideAnchor2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMaximum distance. \n\u003c/p\u003e",
          "module": "Physics.Hipmunk.Constraint",
          "name": "slideMaxDist",
          "package": "Hipmunk",
          "signature": "Distance",
          "source": "src/Physics-Hipmunk-Constraint.html#Slide",
          "type": "function"
        },
        "index": {
          "description": "Maximum distance",
          "hierarchy": "Physics Hipmunk Constraint",
          "module": "Physics.Hipmunk.Constraint",
          "name": "slideMaxDist",
          "package": "Hipmunk",
          "partial": "Max Dist",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Constraint.html#v:slideMaxDist"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMinimum distance. \n\u003c/p\u003e",
          "module": "Physics.Hipmunk.Constraint",
          "name": "slideMinDist",
          "package": "Hipmunk",
          "signature": "Distance",
          "source": "src/Physics-Hipmunk-Constraint.html#Slide",
          "type": "function"
        },
        "index": {
          "description": "Minimum distance",
          "hierarchy": "Physics Hipmunk Constraint",
          "module": "Physics.Hipmunk.Constraint",
          "name": "slideMinDist",
          "package": "Hipmunk",
          "partial": "Min Dist",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Constraint.html#v:slideMinDist"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eShapes used for collisions, their properties and some useful\n polygon functions.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Physics.Hipmunk.Shape",
          "name": "Shape",
          "package": "Hipmunk",
          "source": "src/Physics-Hipmunk-Shape.html",
          "type": "module"
        },
        "index": {
          "description": "Shapes used for collisions their properties and some useful polygon functions",
          "hierarchy": "Physics Hipmunk Shape",
          "module": "Physics.Hipmunk.Shape",
          "name": "Shape",
          "package": "Hipmunk",
          "partial": "Shape",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Shape.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe collision type is used to determine which collision\n   callback will be called. Its actual value doesn't have a\n   meaning for Chipmunk other than the correspondence between\n   shapes and the collision pair functions you add. (default is\n   zero)\n\u003c/p\u003e",
          "module": "Physics.Hipmunk.Shape",
          "name": "CollisionType",
          "package": "Hipmunk",
          "source": "src/Physics-Hipmunk-Shape.html#CollisionType",
          "type": "type"
        },
        "index": {
          "description": "The collision type is used to determine which collision callback will be called Its actual value doesn have meaning for Chipmunk other than the correspondence between shapes and the collision pair functions you add default is zero",
          "hierarchy": "Physics Hipmunk Shape",
          "module": "Physics.Hipmunk.Shape",
          "name": "CollisionType",
          "package": "Hipmunk",
          "partial": "Collision Type",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Shape.html#t:CollisionType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe elasticity of the shape is such that \u003ccode\u003e0.0\u003c/code\u003e gives no bounce\n   while \u003ccode\u003e1.0\u003c/code\u003e give a \"perfect\" bounce. Note that due to\n   inaccuracies using \u003ccode\u003e1.0\u003c/code\u003e or greater is not recommended.\n\u003c/p\u003e\u003cp\u003eThe amount of elasticity applied during a collision is\n   calculated by multiplying the elasticity of both shapes.\n   (default is zero)\n\u003c/p\u003e\u003cp\u003eBy default old-style elastic iterations are done when the\n   space \u003ccode\u003estep\u003c/code\u003es.  This used to result in a not-so-good\n   simulation, but now this is the recommended setting.\n\u003c/p\u003e",
          "module": "Physics.Hipmunk.Shape",
          "name": "Elasticity",
          "package": "Hipmunk",
          "source": "src/Physics-Hipmunk-Shape.html#Elasticity",
          "type": "type"
        },
        "index": {
          "description": "The elasticity of the shape is such that gives no bounce while give perfect bounce Note that due to inaccuracies using or greater is not recommended The amount of elasticity applied during collision is calculated by multiplying the elasticity of both shapes default is zero By default old-style elastic iterations are done when the space step This used to result in not-so-good simulation but now this is the recommended setting",
          "hierarchy": "Physics Hipmunk Shape",
          "module": "Physics.Hipmunk.Shape",
          "name": "Elasticity",
          "package": "Hipmunk",
          "partial": "Elasticity",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Shape.html#t:Elasticity"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe friction coefficient of the shape according\n   to Coulumb friction model (i.e. \u003ccode\u003e0.0\u003c/code\u003e is frictionless,\n   iron on iron is around \u003ccode\u003e1.0\u003c/code\u003e, and it could be greater\n   then \u003ccode\u003e1.0\u003c/code\u003e).\n\u003c/p\u003e\u003cp\u003eThe amount of friction applied during a collision is\n   determined by multiplying the friction coefficient\n   of both shapes. (default is zero)\n\u003c/p\u003e",
          "module": "Physics.Hipmunk.Shape",
          "name": "Friction",
          "package": "Hipmunk",
          "source": "src/Physics-Hipmunk-Shape.html#Friction",
          "type": "type"
        },
        "index": {
          "description": "The friction coefficient of the shape according to Coulumb friction model i.e is frictionless iron on iron is around and it could be greater then The amount of friction applied during collision is determined by multiplying the friction coefficient of both shapes default is zero",
          "hierarchy": "Physics Hipmunk Shape",
          "module": "Physics.Hipmunk.Shape",
          "name": "Friction",
          "package": "Hipmunk",
          "partial": "Friction",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Shape.html#t:Friction"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGroups are used to filter collisions between shapes. If\n   the group is zero, then it imposes no restriction\n   to the collisions. However, if the group is non-zero then\n   the shape will not collide with other shapes in the same\n   non-zero group. (default is zero)\n\u003c/p\u003e\u003cp\u003eThis is primarely used to create multi-body, multi-shape\n   objects such as ragdolls. It may be thought as a lightweight\n   alternative to creating a callback that filters the\n   collisions.\n\u003c/p\u003e",
          "module": "Physics.Hipmunk.Shape",
          "name": "Group",
          "package": "Hipmunk",
          "source": "src/Physics-Hipmunk-Shape.html#Group",
          "type": "type"
        },
        "index": {
          "description": "Groups are used to filter collisions between shapes If the group is zero then it imposes no restriction to the collisions However if the group is non-zero then the shape will not collide with other shapes in the same non-zero group default is zero This is primarely used to create multi-body multi-shape objects such as ragdolls It may be thought as lightweight alternative to creating callback that filters the collisions",
          "hierarchy": "Physics Hipmunk Shape",
          "module": "Physics.Hipmunk.Shape",
          "name": "Group",
          "package": "Hipmunk",
          "partial": "Group",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Shape.html#t:Group"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA possible intersection between two segments.\n\u003c/p\u003e",
          "module": "Physics.Hipmunk.Shape",
          "name": "Intersection",
          "package": "Hipmunk",
          "source": "src/Physics-Hipmunk-Shape.html#Intersection",
          "type": "data"
        },
        "index": {
          "description": "possible intersection between two segments",
          "hierarchy": "Physics Hipmunk Shape",
          "module": "Physics.Hipmunk.Shape",
          "name": "Intersection",
          "package": "Hipmunk",
          "partial": "Intersection",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Shape.html#t:Intersection"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLayers are similar to groups, but use a bitmask. For a collision\n   to occur, two shapes must have at least one layer in common.\n   In other words, \u003ccode\u003elayer1 .&. layer2\u003c/code\u003e should be non-zero.\n   (default is \u003ccode\u003e-1\u003c/code\u003e, meaning all bits set)\n\u003c/p\u003e\u003cp\u003eNote that although this type may have more than 32 bits,\n   for portability you should only rely on the lower 32 bits.\n\u003c/p\u003e",
          "module": "Physics.Hipmunk.Shape",
          "name": "Layers",
          "package": "Hipmunk",
          "source": "src/Physics-Hipmunk-Shape.html#Layers",
          "type": "type"
        },
        "index": {
          "description": "Layers are similar to groups but use bitmask For collision to occur two shapes must have at least one layer in common In other words layer1 layer2 should be non-zero default is meaning all bits set Note that although this type may have more than bits for portability you should only rely on the lower bits",
          "hierarchy": "Physics Hipmunk Shape",
          "module": "Physics.Hipmunk.Shape",
          "name": "Layers",
          "package": "Hipmunk",
          "partial": "Layers",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Shape.html#t:Layers"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA line segment.\n\u003c/p\u003e",
          "module": "Physics.Hipmunk.Shape",
          "name": "Segment",
          "package": "Hipmunk",
          "source": "src/Physics-Hipmunk-Shape.html#Segment",
          "type": "type"
        },
        "index": {
          "description": "line segment",
          "hierarchy": "Physics Hipmunk Shape",
          "module": "Physics.Hipmunk.Shape",
          "name": "Segment",
          "package": "Hipmunk",
          "partial": "Segment",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Shape.html#t:Segment"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA collision shape is attached to a \u003ccode\u003e\u003ca\u003eBody\u003c/a\u003e\u003c/code\u003e to define its\n   shape. Multiple shapes may be attached, including\n   overlapping ones (shapes of a body don't generate collisions\n   with each other).\n\u003c/p\u003e\u003cp\u003eNote that to have any effect, a \u003ccode\u003e\u003ca\u003eShape\u003c/a\u003e\u003c/code\u003e must also be\n   added to a \u003ccode\u003e\u003ca\u003eSpace\u003c/a\u003e\u003c/code\u003e, even if the body was already added.\n\u003c/p\u003e",
          "module": "Physics.Hipmunk.Shape",
          "name": "Shape",
          "package": "Hipmunk",
          "source": "src/Physics-Hipmunk-Internal.html#Shape",
          "type": "data"
        },
        "index": {
          "description": "collision shape is attached to Body to define its shape Multiple shapes may be attached including overlapping ones shapes of body don generate collisions with each other Note that to have any effect Shape must also be added to Space even if the body was already added",
          "hierarchy": "Physics Hipmunk Shape",
          "module": "Physics.Hipmunk.Shape",
          "name": "Shape",
          "package": "Hipmunk",
          "partial": "Shape",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Shape.html#t:Shape"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThere are three types of shapes that can be attached\n   to bodies:\n\u003c/p\u003e",
          "module": "Physics.Hipmunk.Shape",
          "name": "ShapeType",
          "package": "Hipmunk",
          "source": "src/Physics-Hipmunk-Shape.html#ShapeType",
          "type": "data"
        },
        "index": {
          "description": "There are three types of shapes that can be attached to bodies",
          "hierarchy": "Physics Hipmunk Shape",
          "module": "Physics.Hipmunk.Shape",
          "name": "ShapeType",
          "package": "Hipmunk",
          "partial": "Shape Type",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Shape.html#t:ShapeType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe surface velocity of the shape. Useful to create\n   conveyor belts and players that move around. This\n   value is only used when calculating friction, not\n   collision. (default is zero)\n\u003c/p\u003e",
          "module": "Physics.Hipmunk.Shape",
          "name": "SurfaceVel",
          "package": "Hipmunk",
          "source": "src/Physics-Hipmunk-Shape.html#SurfaceVel",
          "type": "type"
        },
        "index": {
          "description": "The surface velocity of the shape Useful to create conveyor belts and players that move around This value is only used when calculating friction not collision default is zero",
          "hierarchy": "Physics Hipmunk Shape",
          "module": "Physics.Hipmunk.Shape",
          "name": "SurfaceVel",
          "package": "Hipmunk",
          "partial": "Surface Vel",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Shape.html#t:SurfaceVel"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\"Equality\" under \u003ccode\u003e\u003ca\u003eepsilon\u003c/a\u003e\u003c/code\u003e. That is, \u003ccode\u003ea .==. b\u003c/code\u003e\n   if \u003ccode\u003eabs (a - b) \u003c= epsilon\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Physics.Hipmunk.Shape",
          "name": "(.==.)",
          "package": "Hipmunk",
          "signature": "CpFloat -\u003e CpFloat -\u003e Bool",
          "source": "src/Physics-Hipmunk-Shape.html#.%3D%3D.",
          "type": "function"
        },
        "index": {
          "description": "Equality under epsilon That is if abs epsilon",
          "hierarchy": "Physics Hipmunk Shape",
          "module": "Physics.Hipmunk.Shape",
          "name": "(.==.) .==.",
          "normalized": "CpFloat-\u003eCpFloat-\u003eBool",
          "package": "Hipmunk",
          "signature": "CpFloat-\u003eCpFloat-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Shape.html#v:.-61--61-."
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA circle is the fastest collision type. It also\n   rolls smoothly.\n\u003c/p\u003e",
          "module": "Physics.Hipmunk.Shape",
          "name": "Circle",
          "package": "Hipmunk",
          "signature": "Circle",
          "source": "src/Physics-Hipmunk-Shape.html#ShapeType",
          "type": "function"
        },
        "index": {
          "description": "circle is the fastest collision type It also rolls smoothly",
          "hierarchy": "Physics Hipmunk Shape",
          "module": "Physics.Hipmunk.Shape",
          "name": "Circle",
          "package": "Hipmunk",
          "partial": "Circle",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Shape.html#v:Circle"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDon't intercept.\n\u003c/p\u003e",
          "module": "Physics.Hipmunk.Shape",
          "name": "IntNowhere",
          "package": "Hipmunk",
          "signature": "IntNowhere",
          "source": "src/Physics-Hipmunk-Shape.html#Intersection",
          "type": "function"
        },
        "index": {
          "description": "Don intercept",
          "hierarchy": "Physics Hipmunk Shape",
          "module": "Physics.Hipmunk.Shape",
          "name": "IntNowhere",
          "package": "Hipmunk",
          "partial": "Int Nowhere",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Shape.html#v:IntNowhere"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIntercept in a point.\n\u003c/p\u003e",
          "module": "Physics.Hipmunk.Shape",
          "name": "IntPoint",
          "package": "Hipmunk",
          "signature": "IntPoint !Position",
          "source": "src/Physics-Hipmunk-Shape.html#Intersection",
          "type": "function"
        },
        "index": {
          "description": "Intercept in point",
          "hierarchy": "Physics Hipmunk Shape",
          "module": "Physics.Hipmunk.Shape",
          "name": "IntPoint",
          "package": "Hipmunk",
          "partial": "Int Point",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Shape.html#v:IntPoint"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eShare a segment.\n\u003c/p\u003e",
          "module": "Physics.Hipmunk.Shape",
          "name": "IntSegmt",
          "package": "Hipmunk",
          "signature": "IntSegmt !Segment",
          "source": "src/Physics-Hipmunk-Shape.html#Intersection",
          "type": "function"
        },
        "index": {
          "description": "Share segment",
          "hierarchy": "Physics Hipmunk Shape",
          "module": "Physics.Hipmunk.Shape",
          "name": "IntSegmt",
          "package": "Hipmunk",
          "partial": "Int Segmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Shape.html#v:IntSegmt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA line segment is meant to be used as a static\n   shape. (It can be used with moving bodies, however\n   two line segments never generate collisions between\n   each other.)\n\u003c/p\u003e",
          "module": "Physics.Hipmunk.Shape",
          "name": "LineSegment",
          "package": "Hipmunk",
          "signature": "LineSegment",
          "source": "src/Physics-Hipmunk-Shape.html#ShapeType",
          "type": "function"
        },
        "index": {
          "description": "line segment is meant to be used as static shape It can be used with moving bodies however two line segments never generate collisions between each other",
          "hierarchy": "Physics Hipmunk Shape",
          "module": "Physics.Hipmunk.Shape",
          "name": "LineSegment",
          "package": "Hipmunk",
          "partial": "Line Segment",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Shape.html#v:LineSegment"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePolygons are the slowest of all shapes but\n   the most flexible. The list of vertices must form\n   a convex hull with clockwise winding.\n   Note that if you want a non-convex polygon you may\n   add several convex polygons to the body.\n\u003c/p\u003e",
          "module": "Physics.Hipmunk.Shape",
          "name": "Polygon",
          "package": "Hipmunk",
          "signature": "Polygon",
          "source": "src/Physics-Hipmunk-Shape.html#ShapeType",
          "type": "function"
        },
        "index": {
          "description": "Polygons are the slowest of all shapes but the most flexible The list of vertices must form convex hull with clockwise winding Note that if you want non-convex polygon you may add several convex polygons to the body",
          "hierarchy": "Physics Hipmunk Shape",
          "module": "Physics.Hipmunk.Shape",
          "name": "Polygon",
          "package": "Hipmunk",
          "partial": "Polygon",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Shape.html#v:Polygon"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003ebody s\u003c/code\u003e is the body that this shape is associated\n   to. Useful especially in a space callback.\n\u003c/p\u003e",
          "module": "Physics.Hipmunk.Shape",
          "name": "body",
          "package": "Hipmunk",
          "signature": "Shape -\u003e Body",
          "source": "src/Physics-Hipmunk-Shape.html#body",
          "type": "function"
        },
        "index": {
          "description": "body is the body that this shape is associated to Useful especially in space callback",
          "hierarchy": "Physics Hipmunk Shape",
          "module": "Physics.Hipmunk.Shape",
          "name": "body",
          "normalized": "Shape-\u003eBody",
          "package": "Hipmunk",
          "signature": "Shape-\u003eBody",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Shape.html#v:body"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Physics.Hipmunk.Shape",
          "name": "collisionType",
          "package": "Hipmunk",
          "signature": "Shape -\u003e StateVar CollisionType",
          "source": "src/Physics-Hipmunk-Shape.html#collisionType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Physics Hipmunk Shape",
          "module": "Physics.Hipmunk.Shape",
          "name": "collisionType",
          "normalized": "Shape-\u003eStateVar CollisionType",
          "package": "Hipmunk",
          "partial": "Type",
          "signature": "Shape-\u003eStateVar CollisionType",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Shape.html#v:collisionType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n log n)\u003c/em\u003e. \u003ccode\u003econvexHull verts\u003c/code\u003e is the convex hull of the\n   polygon defined by \u003ccode\u003everts\u003c/code\u003e. The vertices of the convex\n   hulls are given in clockwise winding. The polygon\n   doesn't have to be simple.\n\u003c/p\u003e\u003cp\u003eImplemented using Graham scan, see\n   \u003ca\u003ehttp://cgm.cs.mcgill.ca/~beezer/cs507/3coins.html\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Physics.Hipmunk.Shape",
          "name": "convexHull",
          "package": "Hipmunk",
          "signature": "[Position] -\u003e [Position]",
          "source": "src/Physics-Hipmunk-Shape.html#convexHull",
          "type": "function"
        },
        "index": {
          "description": "log convexHull verts is the convex hull of the polygon defined by verts The vertices of the convex hulls are given in clockwise winding The polygon doesn have to be simple Implemented using Graham scan see http cgm.cs.mcgill.ca beezer cs507 coins.html",
          "hierarchy": "Physics Hipmunk Shape",
          "module": "Physics.Hipmunk.Shape",
          "name": "convexHull",
          "normalized": "[Position]-\u003e[Position]",
          "package": "Hipmunk",
          "partial": "Hull",
          "signature": "[Position]-\u003e[Position]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Shape.html#v:convexHull"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Physics.Hipmunk.Shape",
          "name": "elasticity",
          "package": "Hipmunk",
          "signature": "Shape -\u003e StateVar Elasticity",
          "source": "src/Physics-Hipmunk-Shape.html#elasticity",
          "type": "function"
        },
        "index": {
          "hierarchy": "Physics Hipmunk Shape",
          "module": "Physics.Hipmunk.Shape",
          "name": "elasticity",
          "normalized": "Shape-\u003eStateVar Elasticity",
          "package": "Hipmunk",
          "signature": "Shape-\u003eStateVar Elasticity",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Shape.html#v:elasticity"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Physics.Hipmunk.Shape",
          "name": "end",
          "package": "Hipmunk",
          "signature": "Position",
          "source": "src/Physics-Hipmunk-Shape.html#ShapeType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Physics Hipmunk Shape",
          "module": "Physics.Hipmunk.Shape",
          "name": "end",
          "package": "Hipmunk",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Shape.html#v:end"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe epsilon used in the algorithms below when necessary\n   to compare floats for \"equality\".\n\u003c/p\u003e",
          "module": "Physics.Hipmunk.Shape",
          "name": "epsilon",
          "package": "Hipmunk",
          "signature": "CpFloat",
          "source": "src/Physics-Hipmunk-Shape.html#epsilon",
          "type": "function"
        },
        "index": {
          "description": "The epsilon used in the algorithms below when necessary to compare floats for equality",
          "hierarchy": "Physics Hipmunk Shape",
          "module": "Physics.Hipmunk.Shape",
          "name": "epsilon",
          "package": "Hipmunk",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Shape.html#v:epsilon"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Physics.Hipmunk.Shape",
          "name": "friction",
          "package": "Hipmunk",
          "signature": "Shape -\u003e StateVar Friction",
          "source": "src/Physics-Hipmunk-Shape.html#friction",
          "type": "function"
        },
        "index": {
          "hierarchy": "Physics Hipmunk Shape",
          "module": "Physics.Hipmunk.Shape",
          "name": "friction",
          "normalized": "Shape-\u003eStateVar Friction",
          "package": "Hipmunk",
          "signature": "Shape-\u003eStateVar Friction",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Shape.html#v:friction"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Physics.Hipmunk.Shape",
          "name": "group",
          "package": "Hipmunk",
          "signature": "Shape -\u003e StateVar Group",
          "source": "src/Physics-Hipmunk-Shape.html#group",
          "type": "function"
        },
        "index": {
          "hierarchy": "Physics Hipmunk Shape",
          "module": "Physics.Hipmunk.Shape",
          "name": "group",
          "normalized": "Shape-\u003eStateVar Group",
          "package": "Hipmunk",
          "signature": "Shape-\u003eStateVar Group",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Shape.html#v:group"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e. \u003ccode\u003eintersects seg1 seg2\u003c/code\u003e is the intersection between\n   the two segments \u003ccode\u003eseg1\u003c/code\u003e and \u003ccode\u003eseg2\u003c/code\u003e. See \u003ccode\u003e\u003ca\u003eIntersection\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Physics.Hipmunk.Shape",
          "name": "intersects",
          "package": "Hipmunk",
          "signature": "Segment -\u003e Segment -\u003e Intersection",
          "source": "src/Physics-Hipmunk-Shape.html#intersects",
          "type": "function"
        },
        "index": {
          "description": "intersects seg1 seg2 is the intersection between the two segments seg1 and seg2 See Intersection",
          "hierarchy": "Physics Hipmunk Shape",
          "module": "Physics.Hipmunk.Shape",
          "name": "intersects",
          "normalized": "Segment-\u003eSegment-\u003eIntersection",
          "package": "Hipmunk",
          "signature": "Segment-\u003eSegment-\u003eIntersection",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Shape.html#v:intersects"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e. \u003ccode\u003eisClockwise verts\u003c/code\u003e is \u003ccode\u003eTrue\u003c/code\u003e iff \u003ccode\u003everts\u003c/code\u003e form\n   a clockwise polygon.\n\u003c/p\u003e",
          "module": "Physics.Hipmunk.Shape",
          "name": "isClockwise",
          "package": "Hipmunk",
          "signature": "[Position] -\u003e Bool",
          "source": "src/Physics-Hipmunk-Shape.html#isClockwise",
          "type": "function"
        },
        "index": {
          "description": "isClockwise verts is True iff verts form clockwise polygon",
          "hierarchy": "Physics Hipmunk Shape",
          "module": "Physics.Hipmunk.Shape",
          "name": "isClockwise",
          "normalized": "[Position]-\u003eBool",
          "package": "Hipmunk",
          "partial": "Clockwise",
          "signature": "[Position]-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Shape.html#v:isClockwise"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e. \u003ccode\u003eisConvex verts\u003c/code\u003e is \u003ccode\u003eTrue\u003c/code\u003e iff \u003ccode\u003evers\u003c/code\u003e form a convex\n   polygon.\n\u003c/p\u003e",
          "module": "Physics.Hipmunk.Shape",
          "name": "isConvex",
          "package": "Hipmunk",
          "signature": "[Position] -\u003e Bool",
          "source": "src/Physics-Hipmunk-Shape.html#isConvex",
          "type": "function"
        },
        "index": {
          "description": "isConvex verts is True iff vers form convex polygon",
          "hierarchy": "Physics Hipmunk Shape",
          "module": "Physics.Hipmunk.Shape",
          "name": "isConvex",
          "normalized": "[Position]-\u003eBool",
          "package": "Hipmunk",
          "partial": "Convex",
          "signature": "[Position]-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Shape.html#v:isConvex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eisLeft (p1,p2) vert\u003c/code\u003e is\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e \u003ccode\u003eLT\u003c/code\u003e if \u003ccode\u003evert\u003c/code\u003e is at the left of the line defined by \u003ccode\u003e(p1,p2)\u003c/code\u003e.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003eEQ\u003c/code\u003e if \u003ccode\u003evert\u003c/code\u003e is at the line \u003ccode\u003e(p1,p2)\u003c/code\u003e.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003eGT\u003c/code\u003e otherwise.\n\u003c/li\u003e\u003c/ul\u003e",
          "module": "Physics.Hipmunk.Shape",
          "name": "isLeft",
          "package": "Hipmunk",
          "signature": "(Position, Position) -\u003e Position -\u003e Ordering",
          "source": "src/Physics-Hipmunk-Shape.html#isLeft",
          "type": "function"
        },
        "index": {
          "description": "isLeft p1 p2 vert is LT if vert is at the left of the line defined by p1 p2 EQ if vert is at the line p1 p2 GT otherwise",
          "hierarchy": "Physics Hipmunk Shape",
          "module": "Physics.Hipmunk.Shape",
          "name": "isLeft",
          "normalized": "(Position,Position)-\u003ePosition-\u003eOrdering",
          "package": "Hipmunk",
          "partial": "Left",
          "signature": "(Position,Position)-\u003ePosition-\u003eOrdering",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Shape.html#v:isLeft"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Physics.Hipmunk.Shape",
          "name": "layers",
          "package": "Hipmunk",
          "signature": "Shape -\u003e StateVar Layers",
          "source": "src/Physics-Hipmunk-Shape.html#layers",
          "type": "function"
        },
        "index": {
          "hierarchy": "Physics Hipmunk Shape",
          "module": "Physics.Hipmunk.Shape",
          "name": "layers",
          "normalized": "Shape-\u003eStateVar Layers",
          "package": "Hipmunk",
          "signature": "Shape-\u003eStateVar Layers",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Shape.html#v:layers"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003emomentForCircle m (ri,ro) off\u003c/code\u003e is the moment of inertia\n   of a circle of \u003ccode\u003em\u003c/code\u003e mass, inner radius of \u003ccode\u003eri\u003c/code\u003e, outer radius\n   of \u003ccode\u003ero\u003c/code\u003e and at an offset \u003ccode\u003eoff\u003c/code\u003e from the center of the body.\n\u003c/p\u003e",
          "module": "Physics.Hipmunk.Shape",
          "name": "momentForCircle",
          "package": "Hipmunk",
          "signature": "Mass -\u003e (Distance, Distance) -\u003e Position -\u003e Moment",
          "source": "src/Physics-Hipmunk-Shape.html#momentForCircle",
          "type": "function"
        },
        "index": {
          "description": "momentForCircle ri ro off is the moment of inertia of circle of mass inner radius of ri outer radius of ro and at an offset off from the center of the body",
          "hierarchy": "Physics Hipmunk Shape",
          "module": "Physics.Hipmunk.Shape",
          "name": "momentForCircle",
          "normalized": "Mass-\u003e(Distance,Distance)-\u003ePosition-\u003eMoment",
          "package": "Hipmunk",
          "partial": "For Circle",
          "signature": "Mass-\u003e(Distance,Distance)-\u003ePosition-\u003eMoment",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Shape.html#v:momentForCircle"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003emomentForPoly m verts off\u003c/code\u003e is the moment of inertia of a\n   polygon of \u003ccode\u003em\u003c/code\u003e mass, at offset \u003ccode\u003eoff\u003c/code\u003e from the center of\n   the body and comprised of \u003ccode\u003everts\u003c/code\u003e vertices. This is similar\n   to \u003ccode\u003e\u003ca\u003ePolygon\u003c/a\u003e\u003c/code\u003e (and the same restrictions for the vertices\n   apply as well).\n\u003c/p\u003e",
          "module": "Physics.Hipmunk.Shape",
          "name": "momentForPoly",
          "package": "Hipmunk",
          "signature": "Mass -\u003e [Position] -\u003e Position -\u003e Moment",
          "source": "src/Physics-Hipmunk-Shape.html#momentForPoly",
          "type": "function"
        },
        "index": {
          "description": "momentForPoly verts off is the moment of inertia of polygon of mass at offset off from the center of the body and comprised of verts vertices This is similar to Polygon and the same restrictions for the vertices apply as well",
          "hierarchy": "Physics Hipmunk Shape",
          "module": "Physics.Hipmunk.Shape",
          "name": "momentForPoly",
          "normalized": "Mass-\u003e[Position]-\u003ePosition-\u003eMoment",
          "package": "Hipmunk",
          "partial": "For Poly",
          "signature": "Mass-\u003e[Position]-\u003ePosition-\u003eMoment",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Shape.html#v:momentForPoly"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003emomentForSegment m p1 p2\u003c/code\u003e is the moment of inertia of a\n   segment of mass \u003ccode\u003em\u003c/code\u003e going from point \u003ccode\u003ep1\u003c/code\u003e to point \u003ccode\u003ep2\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Physics.Hipmunk.Shape",
          "name": "momentForSegment",
          "package": "Hipmunk",
          "signature": "Mass -\u003e Position -\u003e Position -\u003e Moment",
          "source": "src/Physics-Hipmunk-Shape.html#momentForSegment",
          "type": "function"
        },
        "index": {
          "description": "momentForSegment p1 p2 is the moment of inertia of segment of mass going from point p1 to point p2",
          "hierarchy": "Physics Hipmunk Shape",
          "module": "Physics.Hipmunk.Shape",
          "name": "momentForSegment",
          "normalized": "Mass-\u003ePosition-\u003ePosition-\u003eMoment",
          "package": "Hipmunk",
          "partial": "For Segment",
          "signature": "Mass-\u003ePosition-\u003ePosition-\u003eMoment",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Shape.html#v:momentForSegment"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003emomentForShape m s off\u003c/code\u003e is a convenience function that calculates\n   the moment of inertia for shape \u003ccode\u003es\u003c/code\u003e with mass \u003ccode\u003em\u003c/code\u003e and at a\n   offset \u003ccode\u003eoff\u003c/code\u003e of the body's center.  Uses \u003ccode\u003e\u003ca\u003emomentForCircle\u003c/a\u003e\u003c/code\u003e,\n   \u003ccode\u003e\u003ca\u003emomentForSegment\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003emomentForPoly\u003c/a\u003e\u003c/code\u003e internally.\n\u003c/p\u003e",
          "module": "Physics.Hipmunk.Shape",
          "name": "momentForShape",
          "package": "Hipmunk",
          "signature": "Mass -\u003e ShapeType -\u003e Position -\u003e Moment",
          "source": "src/Physics-Hipmunk-Shape.html#momentForShape",
          "type": "function"
        },
        "index": {
          "description": "momentForShape off is convenience function that calculates the moment of inertia for shape with mass and at offset off of the body center Uses momentForCircle momentForSegment and momentForPoly internally",
          "hierarchy": "Physics Hipmunk Shape",
          "module": "Physics.Hipmunk.Shape",
          "name": "momentForShape",
          "normalized": "Mass-\u003eShapeType-\u003ePosition-\u003eMoment",
          "package": "Hipmunk",
          "partial": "For Shape",
          "signature": "Mass-\u003eShapeType-\u003ePosition-\u003eMoment",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Shape.html#v:momentForShape"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003enewShape b type off\u003c/code\u003e creates a new shape attached to\n   body \u003ccode\u003eb\u003c/code\u003e at offset \u003ccode\u003eoff\u003c/code\u003e. Note that you have to\n   add the shape to a space otherwise it won't generate\n   collisions.\n\u003c/p\u003e",
          "module": "Physics.Hipmunk.Shape",
          "name": "newShape",
          "package": "Hipmunk",
          "signature": "Body -\u003e ShapeType -\u003e Position -\u003e IO Shape",
          "source": "src/Physics-Hipmunk-Shape.html#newShape",
          "type": "function"
        },
        "index": {
          "description": "newShape type off creates new shape attached to body at offset off Note that you have to add the shape to space otherwise it won generate collisions",
          "hierarchy": "Physics Hipmunk Shape",
          "module": "Physics.Hipmunk.Shape",
          "name": "newShape",
          "normalized": "Body-\u003eShapeType-\u003ePosition-\u003eIO Shape",
          "package": "Hipmunk",
          "partial": "Shape",
          "signature": "Body-\u003eShapeType-\u003ePosition-\u003eIO Shape",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Shape.html#v:newShape"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e. \u003ccode\u003epolyCenter verts\u003c/code\u003e is the position in the center\n   of the polygon formed by \u003ccode\u003everts\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Physics.Hipmunk.Shape",
          "name": "polyCenter",
          "package": "Hipmunk",
          "signature": "[Position] -\u003e Position",
          "source": "src/Physics-Hipmunk-Shape.html#polyCenter",
          "type": "function"
        },
        "index": {
          "description": "polyCenter verts is the position in the center of the polygon formed by verts",
          "hierarchy": "Physics Hipmunk Shape",
          "module": "Physics.Hipmunk.Shape",
          "name": "polyCenter",
          "normalized": "[Position]-\u003ePosition",
          "package": "Hipmunk",
          "partial": "Center",
          "signature": "[Position]-\u003ePosition",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Shape.html#v:polyCenter"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e. \u003ccode\u003epolyReduce delta verts\u003c/code\u003e removes from \u003ccode\u003everts\u003c/code\u003e all\n   points that have less than \u003ccode\u003edelta\u003c/code\u003e distance\n   in relation to the one preceding it.\n\u003c/p\u003e\u003cp\u003eNote that a very small polygon may be completely \"eaten\"\n   if all its vertices are within a \u003ccode\u003edelta\u003c/code\u003e radius from the\n   first.\n\u003c/p\u003e",
          "module": "Physics.Hipmunk.Shape",
          "name": "polyReduce",
          "package": "Hipmunk",
          "signature": "Distance -\u003e [Position] -\u003e [Position]",
          "source": "src/Physics-Hipmunk-Shape.html#polyReduce",
          "type": "function"
        },
        "index": {
          "description": "polyReduce delta verts removes from verts all points that have less than delta distance in relation to the one preceding it Note that very small polygon may be completely eaten if all its vertices are within delta radius from the first",
          "hierarchy": "Physics Hipmunk Shape",
          "module": "Physics.Hipmunk.Shape",
          "name": "polyReduce",
          "normalized": "Distance-\u003e[Position]-\u003e[Position]",
          "package": "Hipmunk",
          "partial": "Reduce",
          "signature": "Distance-\u003e[Position]-\u003e[Position]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Shape.html#v:polyReduce"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Physics.Hipmunk.Shape",
          "name": "radius",
          "package": "Hipmunk",
          "signature": "Distance",
          "source": "src/Physics-Hipmunk-Shape.html#ShapeType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Physics Hipmunk Shape",
          "module": "Physics.Hipmunk.Shape",
          "name": "radius",
          "package": "Hipmunk",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Shape.html#v:radius"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eshapePointQuery shape p\u003c/code\u003e returns \u003ccode\u003eTrue\u003c/code\u003e iff the point\n   in position \u003ccode\u003ep\u003c/code\u003e (in world's coordinates) lies within the\n   shape \u003ccode\u003eshape\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Physics.Hipmunk.Shape",
          "name": "shapePointQuery",
          "package": "Hipmunk",
          "signature": "Shape -\u003e Position -\u003e IO Bool",
          "source": "src/Physics-Hipmunk-Shape.html#shapePointQuery",
          "type": "function"
        },
        "index": {
          "description": "shapePointQuery shape returns True iff the point in position in world coordinates lies within the shape shape",
          "hierarchy": "Physics Hipmunk Shape",
          "module": "Physics.Hipmunk.Shape",
          "name": "shapePointQuery",
          "normalized": "Shape-\u003ePosition-\u003eIO Bool",
          "package": "Hipmunk",
          "partial": "Point Query",
          "signature": "Shape-\u003ePosition-\u003eIO Bool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Shape.html#v:shapePointQuery"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eshapeSegmentQuery shape p1 p2\u003c/code\u003e returns \u003ccode\u003eJust (t,n)\u003c/code\u003e iff the\n   segment from \u003ccode\u003ep1\u003c/code\u003e to \u003ccode\u003ep2\u003c/code\u003e (in world's coordinates)\n   intersects with the shape \u003ccode\u003eshape\u003c/code\u003e.  In that case, \u003ccode\u003e0 \u003c= t \u003c=\n   1\u003c/code\u003e indicates that one of the intersections is at point \u003ccode\u003ep1 +\n   (p2 - p1) `scale` t\u003c/code\u003e with normal \u003ccode\u003en\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Physics.Hipmunk.Shape",
          "name": "shapeSegmentQuery",
          "package": "Hipmunk",
          "signature": "Shape -\u003e Position -\u003e Position -\u003e IO (Maybe (CpFloat, Vector))",
          "source": "src/Physics-Hipmunk-Shape.html#shapeSegmentQuery",
          "type": "function"
        },
        "index": {
          "description": "shapeSegmentQuery shape p1 p2 returns Just iff the segment from p1 to p2 in world coordinates intersects with the shape shape In that case indicates that one of the intersections is at point p1 p2 p1 scale with normal",
          "hierarchy": "Physics Hipmunk Shape",
          "module": "Physics.Hipmunk.Shape",
          "name": "shapeSegmentQuery",
          "normalized": "Shape-\u003ePosition-\u003ePosition-\u003eIO(Maybe(CpFloat,Vector))",
          "package": "Hipmunk",
          "partial": "Segment Query",
          "signature": "Shape-\u003ePosition-\u003ePosition-\u003eIO(Maybe(CpFloat,Vector))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Shape.html#v:shapeSegmentQuery"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Physics.Hipmunk.Shape",
          "name": "start",
          "package": "Hipmunk",
          "signature": "Position",
          "source": "src/Physics-Hipmunk-Shape.html#ShapeType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Physics Hipmunk Shape",
          "module": "Physics.Hipmunk.Shape",
          "name": "start",
          "package": "Hipmunk",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Shape.html#v:start"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Physics.Hipmunk.Shape",
          "name": "surfaceVel",
          "package": "Hipmunk",
          "signature": "Shape -\u003e StateVar SurfaceVel",
          "source": "src/Physics-Hipmunk-Shape.html#surfaceVel",
          "type": "function"
        },
        "index": {
          "hierarchy": "Physics Hipmunk Shape",
          "module": "Physics.Hipmunk.Shape",
          "name": "surfaceVel",
          "normalized": "Shape-\u003eStateVar SurfaceVel",
          "package": "Hipmunk",
          "partial": "Vel",
          "signature": "Shape-\u003eStateVar SurfaceVel",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Shape.html#v:surfaceVel"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Physics.Hipmunk.Shape",
          "name": "thickness",
          "package": "Hipmunk",
          "signature": "Distance",
          "source": "src/Physics-Hipmunk-Shape.html#ShapeType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Physics Hipmunk Shape",
          "module": "Physics.Hipmunk.Shape",
          "name": "thickness",
          "package": "Hipmunk",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Shape.html#v:thickness"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Physics.Hipmunk.Shape",
          "name": "vertices",
          "package": "Hipmunk",
          "signature": "[Position]",
          "source": "src/Physics-Hipmunk-Shape.html#ShapeType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Physics Hipmunk Shape",
          "module": "Physics.Hipmunk.Shape",
          "name": "vertices",
          "normalized": "[Position]",
          "package": "Hipmunk",
          "signature": "[Position]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Shape.html#v:vertices"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThe space, where the simulation happens and the various entities\n interact.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Physics.Hipmunk.Space",
          "name": "Space",
          "package": "Hipmunk",
          "source": "src/Physics-Hipmunk-Space.html",
          "type": "module"
        },
        "index": {
          "description": "The space where the simulation happens and the various entities interact",
          "hierarchy": "Physics Hipmunk Space",
          "module": "Physics.Hipmunk.Space",
          "name": "Space",
          "package": "Hipmunk",
          "partial": "Space",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Space.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe number of elastic iterations to use when solving\n   constraints.  If \u003ccode\u003e0\u003c/code\u003e, then old-style elastic code is used.\n   (default is 0).\n\u003c/p\u003e\u003cp\u003eThis property is deprecated.  You should no longer need to\n   set any value other than the default.\n\u003c/p\u003e",
          "module": "Physics.Hipmunk.Space",
          "name": "ElasticIterations",
          "package": "Hipmunk",
          "source": "src/Physics-Hipmunk-Space.html#ElasticIterations",
          "type": "type"
        },
        "index": {
          "description": "The number of elastic iterations to use when solving constraints If then old-style elastic code is used default is This property is deprecated You should no longer need to set any value other than the default",
          "hierarchy": "Physics Hipmunk Space",
          "module": "Physics.Hipmunk.Space",
          "name": "ElasticIterations",
          "package": "Hipmunk",
          "partial": "Elastic Iterations",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Space.html#t:ElasticIterations"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eType class implemented by entities that can be\n   added to a space.\n\u003c/p\u003e",
          "module": "Physics.Hipmunk.Space",
          "name": "Entity",
          "package": "Hipmunk",
          "source": "src/Physics-Hipmunk-Internal.html#Entity",
          "type": "class"
        },
        "index": {
          "description": "Type class implemented by entities that can be added to space",
          "hierarchy": "Physics Hipmunk Space",
          "module": "Physics.Hipmunk.Space",
          "name": "Entity",
          "package": "Hipmunk",
          "partial": "Entity",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Space.html#t:Entity"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe gravity applied to the system. (default is 0)\n\u003c/p\u003e",
          "module": "Physics.Hipmunk.Space",
          "name": "Gravity",
          "package": "Hipmunk",
          "source": "src/Physics-Hipmunk-Space.html#Gravity",
          "type": "type"
        },
        "index": {
          "description": "The gravity applied to the system default is",
          "hierarchy": "Physics Hipmunk Space",
          "module": "Physics.Hipmunk.Space",
          "name": "Gravity",
          "package": "Hipmunk",
          "partial": "Gravity",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Space.html#t:Gravity"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe number of iterations to use when solving constraints.\n   (default is 10).\n\u003c/p\u003e",
          "module": "Physics.Hipmunk.Space",
          "name": "Iterations",
          "package": "Hipmunk",
          "source": "src/Physics-Hipmunk-Space.html#Iterations",
          "type": "type"
        },
        "index": {
          "description": "The number of iterations to use when solving constraints default is",
          "hierarchy": "Physics Hipmunk Space",
          "module": "Physics.Hipmunk.Space",
          "name": "Iterations",
          "package": "Hipmunk",
          "partial": "Iterations",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Space.html#t:Iterations"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA space is where the simulation really occurs. You add\n   bodies, shapes and constraints to a space and then \u003ccode\u003estep\u003c/code\u003e it\n   to update it as whole.\n\u003c/p\u003e",
          "module": "Physics.Hipmunk.Space",
          "name": "Space",
          "package": "Hipmunk",
          "source": "src/Physics-Hipmunk-Internal.html#Space",
          "type": "data"
        },
        "index": {
          "description": "space is where the simulation really occurs You add bodies shapes and constraints to space and then step it to update it as whole",
          "hierarchy": "Physics Hipmunk Space",
          "module": "Physics.Hipmunk.Space",
          "name": "Space",
          "package": "Hipmunk",
          "partial": "Space",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Space.html#t:Space"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA \u003ccode\u003e\u003ca\u003eStaticShape\u003c/a\u003e\u003c/code\u003e is a \u003ccode\u003e\u003ca\u003eShape\u003c/a\u003e\u003c/code\u003e container that, when added\n   to a space via \u003ccode\u003e\u003ca\u003espaceAdd\u003c/a\u003e\u003c/code\u003e, is added to the static\n   list of shapes.\n\u003c/p\u003e\u003cp\u003eA static shape is one assumed not to move. If you move\n   a static shape after adding it, then you need to \u003ccode\u003e\u003ca\u003erehashStatic\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eYou should not add the same shape as active and static,\n   nor should you add as active and try to remove as\n   static or vice versa.\n\u003c/p\u003e",
          "module": "Physics.Hipmunk.Space",
          "name": "StaticShape",
          "package": "Hipmunk",
          "source": "src/Physics-Hipmunk-Space.html#StaticShape",
          "type": "newtype"
        },
        "index": {
          "description": "StaticShape is Shape container that when added to space via spaceAdd is added to the static list of shapes static shape is one assumed not to move If you move static shape after adding it then you need to rehashStatic You should not add the same shape as active and static nor should you add as active and try to remove as static or vice versa",
          "hierarchy": "Physics Hipmunk Space",
          "module": "Physics.Hipmunk.Space",
          "name": "StaticShape",
          "package": "Hipmunk",
          "partial": "Static Shape",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Space.html#t:StaticShape"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe time stamp of the simulation, increased in 1\n   every time \u003ccode\u003e\u003ca\u003estep\u003c/a\u003e\u003c/code\u003e is called.\n\u003c/p\u003e",
          "module": "Physics.Hipmunk.Space",
          "name": "TimeStamp",
          "package": "Hipmunk",
          "source": "src/Physics-Hipmunk-Space.html#TimeStamp",
          "type": "type"
        },
        "index": {
          "description": "The time stamp of the simulation increased in every time step is called",
          "hierarchy": "Physics Hipmunk Space",
          "module": "Physics.Hipmunk.Space",
          "name": "TimeStamp",
          "package": "Hipmunk",
          "partial": "Time Stamp",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Space.html#t:TimeStamp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Physics.Hipmunk.Space",
          "name": "Static",
          "package": "Hipmunk",
          "signature": "Static",
          "source": "src/Physics-Hipmunk-Space.html#StaticShape",
          "type": "function"
        },
        "index": {
          "hierarchy": "Physics Hipmunk Space",
          "module": "Physics.Hipmunk.Space",
          "name": "Static",
          "package": "Hipmunk",
          "partial": "Static",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Space.html#v:Static"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe amount of viscous damping applied to the system.\n   (default is 1)\n\u003c/p\u003e",
          "module": "Physics.Hipmunk.Space",
          "name": "damping",
          "package": "Hipmunk",
          "signature": "Space -\u003e StateVar Damping",
          "source": "src/Physics-Hipmunk-Space.html#damping",
          "type": "function"
        },
        "index": {
          "description": "The amount of viscous damping applied to the system default is",
          "hierarchy": "Physics Hipmunk Space",
          "module": "Physics.Hipmunk.Space",
          "name": "damping",
          "normalized": "Space-\u003eStateVar Damping",
          "package": "Hipmunk",
          "signature": "Space-\u003eStateVar Damping",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Space.html#v:damping"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"warning\"\u003e\u003cp\u003eDeprecated: Elastic iterations should no longer be needed\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Physics.Hipmunk.Space",
          "name": "elasticIterations",
          "package": "Hipmunk",
          "signature": "Space -\u003e StateVar ElasticIterations",
          "source": "src/Physics-Hipmunk-Space.html#elasticIterations",
          "type": "function"
        },
        "index": {
          "description": "Deprecated Elastic iterations should no longer be needed",
          "hierarchy": "Physics Hipmunk Space",
          "module": "Physics.Hipmunk.Space",
          "name": "elasticIterations",
          "normalized": "Space-\u003eStateVar ElasticIterations",
          "package": "Hipmunk",
          "partial": "Iterations",
          "signature": "Space-\u003eStateVar ElasticIterations",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Space.html#v:elasticIterations"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003efreeSpace sp\u003c/code\u003e frees some memory resources that can't\n   be automatically deallocated in a portable way.\n   The space \u003ccode\u003esp\u003c/code\u003e then becomes invalid and should\n   not be used (passing \u003ccode\u003esp\u003c/code\u003e to any other function,\n   including \u003ccode\u003e\u003ca\u003efreeSpace\u003c/a\u003e\u003c/code\u003e, results in undefined behavior).\n\u003c/p\u003e",
          "module": "Physics.Hipmunk.Space",
          "name": "freeSpace",
          "package": "Hipmunk",
          "signature": "Space -\u003e IO ()",
          "source": "src/Physics-Hipmunk-Space.html#freeSpace",
          "type": "function"
        },
        "index": {
          "description": "freeSpace sp frees some memory resources that can be automatically deallocated in portable way The space sp then becomes invalid and should not be used passing sp to any other function including freeSpace results in undefined behavior",
          "hierarchy": "Physics Hipmunk Space",
          "module": "Physics.Hipmunk.Space",
          "name": "freeSpace",
          "normalized": "Space-\u003eIO()",
          "package": "Hipmunk",
          "partial": "Space",
          "signature": "Space-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Space.html#v:freeSpace"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Physics.Hipmunk.Space",
          "name": "gravity",
          "package": "Hipmunk",
          "signature": "Space -\u003e StateVar Gravity",
          "source": "src/Physics-Hipmunk-Space.html#gravity",
          "type": "function"
        },
        "index": {
          "hierarchy": "Physics Hipmunk Space",
          "module": "Physics.Hipmunk.Space",
          "name": "gravity",
          "normalized": "Space-\u003eStateVar Gravity",
          "package": "Hipmunk",
          "signature": "Space-\u003eStateVar Gravity",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Space.html#v:gravity"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Physics.Hipmunk.Space",
          "name": "iterations",
          "package": "Hipmunk",
          "signature": "Space -\u003e StateVar Iterations",
          "source": "src/Physics-Hipmunk-Space.html#iterations",
          "type": "function"
        },
        "index": {
          "hierarchy": "Physics Hipmunk Space",
          "module": "Physics.Hipmunk.Space",
          "name": "iterations",
          "normalized": "Space-\u003eStateVar Iterations",
          "package": "Hipmunk",
          "signature": "Space-\u003eStateVar Iterations",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Space.html#v:iterations"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreates a new, empty space.\n   Some of the memory resources associated with the space\n   must be manually freed through \u003ccode\u003e\u003ca\u003efreeSpace\u003c/a\u003e\u003c/code\u003e when the\n   \u003ccode\u003e\u003ca\u003eSpace\u003c/a\u003e\u003c/code\u003e is no longer necessary.\n\u003c/p\u003e",
          "module": "Physics.Hipmunk.Space",
          "name": "newSpace",
          "package": "Hipmunk",
          "signature": "IO Space",
          "source": "src/Physics-Hipmunk-Space.html#newSpace",
          "type": "function"
        },
        "index": {
          "description": "Creates new empty space Some of the memory resources associated with the space must be manually freed through freeSpace when the Space is no longer necessary",
          "hierarchy": "Physics Hipmunk Space",
          "module": "Physics.Hipmunk.Space",
          "name": "newSpace",
          "package": "Hipmunk",
          "partial": "Space",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Space.html#v:newSpace"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRehashes the shapes in the static spatial hash.\n   You only need to call this if you move one of the\n   static shapes.\n\u003c/p\u003e",
          "module": "Physics.Hipmunk.Space",
          "name": "rehashStatic",
          "package": "Hipmunk",
          "signature": "Space -\u003e IO ()",
          "source": "src/Physics-Hipmunk-Space.html#rehashStatic",
          "type": "function"
        },
        "index": {
          "description": "Rehashes the shapes in the static spatial hash You only need to call this if you move one of the static shapes",
          "hierarchy": "Physics Hipmunk Space",
          "module": "Physics.Hipmunk.Space",
          "name": "rehashStatic",
          "normalized": "Space-\u003eIO()",
          "package": "Hipmunk",
          "partial": "Static",
          "signature": "Space-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Space.html#v:rehashStatic"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Physics.Hipmunk.Space",
          "name": "resizeActiveHash",
          "package": "Hipmunk",
          "signature": "Space -\u003e Distance -\u003e CInt -\u003e IO ()",
          "source": "src/Physics-Hipmunk-Space.html#resizeActiveHash",
          "type": "function"
        },
        "index": {
          "hierarchy": "Physics Hipmunk Space",
          "module": "Physics.Hipmunk.Space",
          "name": "resizeActiveHash",
          "normalized": "Space-\u003eDistance-\u003eCInt-\u003eIO()",
          "package": "Hipmunk",
          "partial": "Active Hash",
          "signature": "Space-\u003eDistance-\u003eCInt-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Space.html#v:resizeActiveHash"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Physics.Hipmunk.Space",
          "name": "resizeStaticHash",
          "package": "Hipmunk",
          "signature": "Space -\u003e Distance -\u003e CInt -\u003e IO ()",
          "source": "src/Physics-Hipmunk-Space.html#resizeStaticHash",
          "type": "function"
        },
        "index": {
          "hierarchy": "Physics Hipmunk Space",
          "module": "Physics.Hipmunk.Space",
          "name": "resizeStaticHash",
          "normalized": "Space-\u003eDistance-\u003eCInt-\u003eIO()",
          "package": "Hipmunk",
          "partial": "Static Hash",
          "signature": "Space-\u003eDistance-\u003eCInt-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Space.html#v:resizeStaticHash"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAdd an entity to a \u003ccode\u003e\u003ca\u003eSpace\u003c/a\u003e\u003c/code\u003e. Don't add the same\n   entity twice to a space.\n\u003c/p\u003e",
          "module": "Physics.Hipmunk.Space",
          "name": "spaceAdd",
          "package": "Hipmunk",
          "signature": "Space -\u003e a -\u003e IO ()",
          "source": "src/Physics-Hipmunk-Internal.html#spaceAdd",
          "type": "method"
        },
        "index": {
          "description": "Add an entity to Space Don add the same entity twice to space",
          "hierarchy": "Physics Hipmunk Space",
          "module": "Physics.Hipmunk.Space",
          "name": "spaceAdd",
          "normalized": "Space-\u003ea-\u003eIO()",
          "package": "Hipmunk",
          "partial": "Add",
          "signature": "Space-\u003ea-\u003eIO()",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Space.html#v:spaceAdd"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003espaceQuery sp pos l g cb\u003c/code\u003e will call \u003ccode\u003ecb\u003c/code\u003e for every\n   shape that\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e Contains point \u003ccode\u003epos\u003c/code\u003e (in world's coordinates).\n\u003c/li\u003e\u003cli\u003e Isn't of the same group as \u003ccode\u003eg\u003c/code\u003e.\n\u003c/li\u003e\u003cli\u003e Shares at least one layer with \u003ccode\u003el\u003c/code\u003e.\n\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eThe order in which the callback is called is unspecified.\n   However it is guaranteed that it will be called once,\n   and only once, for each of the shapes described above\n   (and never for those who aren't).\n\u003c/p\u003e",
          "module": "Physics.Hipmunk.Space",
          "name": "spaceQuery",
          "package": "Hipmunk",
          "signature": "Space -\u003e Position -\u003e Layers -\u003e Group -\u003e (Shape -\u003e IO ()) -\u003e IO ()",
          "source": "src/Physics-Hipmunk-Space.html#spaceQuery",
          "type": "function"
        },
        "index": {
          "description": "spaceQuery sp pos cb will call cb for every shape that Contains point pos in world coordinates Isn of the same group as Shares at least one layer with The order in which the callback is called is unspecified However it is guaranteed that it will be called once and only once for each of the shapes described above and never for those who aren",
          "hierarchy": "Physics Hipmunk Space",
          "module": "Physics.Hipmunk.Space",
          "name": "spaceQuery",
          "normalized": "Space-\u003ePosition-\u003eLayers-\u003eGroup-\u003e(Shape-\u003eIO())-\u003eIO()",
          "package": "Hipmunk",
          "partial": "Query",
          "signature": "Space-\u003ePosition-\u003eLayers-\u003eGroup-\u003e(Shape-\u003eIO())-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Space.html#v:spaceQuery"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003espaceQueryList sp pos l g\u003c/code\u003e acts like \u003ccode\u003e\u003ca\u003espaceQuery\u003c/a\u003e\u003c/code\u003e but\n   returns a list of \u003ccode\u003e\u003ca\u003eShape\u003c/a\u003e\u003c/code\u003es instead of calling a callback.\n   This is just a convenience function.\n\u003c/p\u003e",
          "module": "Physics.Hipmunk.Space",
          "name": "spaceQueryList",
          "package": "Hipmunk",
          "signature": "Space -\u003e Position -\u003e Layers -\u003e Group -\u003e IO [Shape]",
          "source": "src/Physics-Hipmunk-Space.html#spaceQueryList",
          "type": "function"
        },
        "index": {
          "description": "spaceQueryList sp pos acts like spaceQuery but returns list of Shape instead of calling callback This is just convenience function",
          "hierarchy": "Physics Hipmunk Space",
          "module": "Physics.Hipmunk.Space",
          "name": "spaceQueryList",
          "normalized": "Space-\u003ePosition-\u003eLayers-\u003eGroup-\u003eIO[Shape]",
          "package": "Hipmunk",
          "partial": "Query List",
          "signature": "Space-\u003ePosition-\u003eLayers-\u003eGroup-\u003eIO[Shape]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Space.html#v:spaceQueryList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRemove an entity from a \u003ccode\u003e\u003ca\u003eSpace\u003c/a\u003e\u003c/code\u003e. Don't remove\n   an entity that wasn't added.\n\u003c/p\u003e",
          "module": "Physics.Hipmunk.Space",
          "name": "spaceRemove",
          "package": "Hipmunk",
          "signature": "Space -\u003e a -\u003e IO ()",
          "source": "src/Physics-Hipmunk-Internal.html#spaceRemove",
          "type": "method"
        },
        "index": {
          "description": "Remove an entity from Space Don remove an entity that wasn added",
          "hierarchy": "Physics Hipmunk Space",
          "module": "Physics.Hipmunk.Space",
          "name": "spaceRemove",
          "normalized": "Space-\u003ea-\u003eIO()",
          "package": "Hipmunk",
          "partial": "Remove",
          "signature": "Space-\u003ea-\u003eIO()",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Space.html#v:spaceRemove"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003estep sp dt\u003c/code\u003e will update the space \u003ccode\u003esp\u003c/code\u003e for a \u003ccode\u003edt\u003c/code\u003e time\n   step.\n\u003c/p\u003e\u003cp\u003eIt is highly recommended to use a fixed \u003ccode\u003edt\u003c/code\u003e to increase\n   the efficiency of contact persistence. Some tips may be\n   found in \u003ca\u003ehttp://www.gaffer.org/game-physics/fix-your-timestep\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Physics.Hipmunk.Space",
          "name": "step",
          "package": "Hipmunk",
          "signature": "Space -\u003e Time -\u003e IO ()",
          "source": "src/Physics-Hipmunk-Space.html#step",
          "type": "function"
        },
        "index": {
          "description": "step sp dt will update the space sp for dt time step It is highly recommended to use fixed dt to increase the efficiency of contact persistence Some tips may be found in http www.gaffer.org game-physics fix-your-timestep",
          "hierarchy": "Physics Hipmunk Space",
          "module": "Physics.Hipmunk.Space",
          "name": "step",
          "normalized": "Space-\u003eTime-\u003eIO()",
          "package": "Hipmunk",
          "signature": "Space-\u003eTime-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Space.html#v:step"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Physics.Hipmunk.Space",
          "name": "timeStamp",
          "package": "Hipmunk",
          "signature": "Space -\u003e GettableStateVar TimeStamp",
          "source": "src/Physics-Hipmunk-Space.html#timeStamp",
          "type": "function"
        },
        "index": {
          "hierarchy": "Physics Hipmunk Space",
          "module": "Physics.Hipmunk.Space",
          "name": "timeStamp",
          "normalized": "Space-\u003eGettableStateVar TimeStamp",
          "package": "Hipmunk",
          "partial": "Stamp",
          "signature": "Space-\u003eGettableStateVar TimeStamp",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Space.html#v:timeStamp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Physics.Hipmunk.Space",
          "name": "unStatic",
          "package": "Hipmunk",
          "signature": "Shape",
          "source": "src/Physics-Hipmunk-Space.html#StaticShape",
          "type": "function"
        },
        "index": {
          "hierarchy": "Physics Hipmunk Space",
          "module": "Physics.Hipmunk.Space",
          "name": "unStatic",
          "package": "Hipmunk",
          "partial": "Static",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Space.html#v:unStatic"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eAll functions on this module are \u003cem\u003eUNSAFE\u003c/em\u003e in the sense that\n they may reduce the physical accuracy or numerical stability\n of the simulation if you use them correctly, or may crash your\n system if you are not careful enough.  Read their\n documentation carefully and use them only if you really need\n and know what you are doing.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Physics.Hipmunk.Unsafe",
          "name": "Unsafe",
          "package": "Hipmunk",
          "source": "src/Physics-Hipmunk-Unsafe.html",
          "type": "module"
        },
        "index": {
          "description": "All functions on this module are UNSAFE in the sense that they may reduce the physical accuracy or numerical stability of the simulation if you use them correctly or may crash your system if you are not careful enough Read their documentation carefully and use them only if you really need and know what you are doing",
          "hierarchy": "Physics Hipmunk Unsafe",
          "module": "Physics.Hipmunk.Unsafe",
          "name": "Unsafe",
          "package": "Hipmunk",
          "partial": "Unsafe",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Unsafe.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUnsafe function that changes the constraint type to\n   anything. It is unsafe because you should call \u003ccode\u003eredefine\u003c/code\u003e\n   only on the same kind of constraint you created, and this\n   function allows you to bypass the type system checks.  Note\n   also that, unlike Chipmunk, we don't check at run-time that\n   \u003ccode\u003eredefine\u003c/code\u003e is being called on the right type!\n\u003c/p\u003e",
          "module": "Physics.Hipmunk.Unsafe",
          "name": "unsafeRememberC",
          "package": "Hipmunk",
          "signature": "Constraint Unknown -\u003e Constraint a",
          "source": "src/Physics-Hipmunk-Unsafe.html#unsafeRememberC",
          "type": "function"
        },
        "index": {
          "description": "Unsafe function that changes the constraint type to anything It is unsafe because you should call redefine only on the same kind of constraint you created and this function allows you to bypass the type system checks Note also that unlike Chipmunk we don check at run-time that redefine is being called on the right type",
          "hierarchy": "Physics Hipmunk Unsafe",
          "module": "Physics.Hipmunk.Unsafe",
          "name": "unsafeRememberC",
          "normalized": "Constraint Unknown-\u003eConstraint a",
          "package": "Hipmunk",
          "partial": "Remember",
          "signature": "Constraint Unknown-\u003eConstraint a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Unsafe.html#v:unsafeRememberC"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eunsafeShapeRedefine shape type off\u003c/code\u003e redefines \u003ccode\u003eshape\u003c/code\u003e to\n   have new parameters described on \u003ccode\u003etype\u003c/code\u003e and to be at offset\n   \u003ccode\u003eoff\u003c/code\u003e.  Be careful, \u003cem\u003eyou should not change the shape type\u003c/em\u003e.\n   For example, it is unsafe to change a circle shape's radius,\n   but it is an error to try to change a circle into a segment\n   or a polygon.  Note also that these errors \u003cem\u003eare not\u003c/em\u003e\n   \u003cem\u003echecked\u003c/em\u003e, meaning \u003cem\u003ethey will probably crash Chipmunk\u003c/em\u003e.\n\u003c/p\u003e",
          "module": "Physics.Hipmunk.Unsafe",
          "name": "unsafeShapeRedefine",
          "package": "Hipmunk",
          "signature": "Shape -\u003e ShapeType -\u003e Position -\u003e IO ()",
          "source": "src/Physics-Hipmunk-Unsafe.html#unsafeShapeRedefine",
          "type": "function"
        },
        "index": {
          "description": "unsafeShapeRedefine shape type off redefines shape to have new parameters described on type and to be at offset off Be careful you should not change the shape type For example it is unsafe to change circle shape radius but it is an error to try to change circle into segment or polygon Note also that these errors are not checked meaning they will probably crash Chipmunk",
          "hierarchy": "Physics Hipmunk Unsafe",
          "module": "Physics.Hipmunk.Unsafe",
          "name": "unsafeShapeRedefine",
          "normalized": "Shape-\u003eShapeType-\u003ePosition-\u003eIO()",
          "package": "Hipmunk",
          "partial": "Shape Redefine",
          "signature": "Shape-\u003eShapeType-\u003ePosition-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk-Unsafe.html#v:unsafeShapeRedefine"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module re-exports all other Hipmunk modules. It is\n meant to be imported qualified such as\n\u003c/p\u003e\u003cpre\u003e\n import qualified Physics.Hipmunk as H\n\u003c/pre\u003e\u003cp\u003ehowever it doesn't clash with the \u003ccode\u003ePrelude\u003c/code\u003e.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Physics.Hipmunk",
          "name": "Hipmunk",
          "package": "Hipmunk",
          "source": "src/Physics-Hipmunk.html",
          "type": "module"
        },
        "index": {
          "description": "This module re-exports all other Hipmunk modules It is meant to be imported qualified such as import qualified Physics.Hipmunk as however it doesn clash with the Prelude",
          "hierarchy": "Physics Hipmunk",
          "module": "Physics.Hipmunk",
          "name": "Hipmunk",
          "package": "Hipmunk",
          "partial": "Hipmunk",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/Hipmunk/docs/Physics-Hipmunk.html#"
      }
    }
  ]
]