[
  {
    "cmd": "delete-by-query",
    "query": {
      "contexts": [
        "package"
      ],
      "query": {
        "op": "case",
        "type": "word",
        "word": "GLUT"
      },
      "type": "context"
    }
  },
  [
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eAfter a GLUT program has done initial setup such as creating windows and\n menus, GLUT programs enter the GLUT event processing loop by calling\n \u003ccode\u003e\u003ca\u003emainLoop\u003c/a\u003e\u003c/code\u003e or handle events iteratively with \u003ccode\u003e\u003ca\u003emainLoopEvent\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Graphics.UI.GLUT.Begin",
          "name": "Begin",
          "package": "GLUT",
          "source": "src/Graphics-UI-GLUT-Begin.html",
          "type": "module"
        },
        "index": {
          "description": "After GLUT program has done initial setup such as creating windows and menus GLUT programs enter the GLUT event processing loop by calling mainLoop or handle events iteratively with mainLoopEvent",
          "hierarchy": "Graphics UI GLUT Begin",
          "module": "Graphics.UI.GLUT.Begin",
          "name": "Begin",
          "package": "GLUT",
          "partial": "Begin",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Begin.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe behaviour when the user closes a window.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Begin",
          "name": "ActionOnWindowClose",
          "package": "GLUT",
          "source": "src/Graphics-UI-GLUT-Begin.html#ActionOnWindowClose",
          "type": "data"
        },
        "index": {
          "description": "The behaviour when the user closes window",
          "hierarchy": "Graphics UI GLUT Begin",
          "module": "Graphics.UI.GLUT.Begin",
          "name": "ActionOnWindowClose",
          "package": "GLUT",
          "partial": "Action On Window Close",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Begin.html#t:ActionOnWindowClose"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"warning\"\u003e\u003cp\u003eDeprecated: Use \u003ccode\u003e\u003ca\u003eContinueExecution\u003c/a\u003e\u003c/code\u003e instead.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Graphics.UI.GLUT.Begin",
          "name": "ContinueExectuion",
          "package": "GLUT",
          "signature": "ContinueExectuion",
          "source": "src/Graphics-UI-GLUT-Begin.html#ActionOnWindowClose",
          "type": "function"
        },
        "index": {
          "description": "Deprecated Use ContinueExecution instead",
          "hierarchy": "Graphics UI GLUT Begin",
          "module": "Graphics.UI.GLUT.Begin",
          "name": "ContinueExectuion",
          "package": "GLUT",
          "partial": "Continue Exectuion",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Begin.html#v:ContinueExectuion"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn from mainLoop after the last window is closed.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Begin",
          "name": "ContinueExecution",
          "package": "GLUT",
          "signature": "ContinueExecution",
          "source": "src/Graphics-UI-GLUT-Begin.html#ActionOnWindowClose",
          "type": "function"
        },
        "index": {
          "description": "Return from mainLoop after the last window is closed",
          "hierarchy": "Graphics UI GLUT Begin",
          "module": "Graphics.UI.GLUT.Begin",
          "name": "ContinueExecution",
          "package": "GLUT",
          "partial": "Continue Execution",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Begin.html#v:ContinueExecution"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExit the whole program when any window is closed or \u003ccode\u003e\u003ca\u003eleaveMainLoop\u003c/a\u003e\u003c/code\u003e\n is called (default).\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Begin",
          "name": "Exit",
          "package": "GLUT",
          "signature": "Exit",
          "source": "src/Graphics-UI-GLUT-Begin.html#ActionOnWindowClose",
          "type": "function"
        },
        "index": {
          "description": "Exit the whole program when any window is closed or leaveMainLoop is called default",
          "hierarchy": "Graphics UI GLUT Begin",
          "module": "Graphics.UI.GLUT.Begin",
          "name": "Exit",
          "package": "GLUT",
          "partial": "Exit",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Begin.html#v:Exit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn from mainLoop when any window is closed.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Begin",
          "name": "MainLoopReturns",
          "package": "GLUT",
          "signature": "MainLoopReturns",
          "source": "src/Graphics-UI-GLUT-Begin.html#ActionOnWindowClose",
          "type": "function"
        },
        "index": {
          "description": "Return from mainLoop when any window is closed",
          "hierarchy": "Graphics UI GLUT Begin",
          "module": "Graphics.UI.GLUT.Begin",
          "name": "MainLoopReturns",
          "package": "GLUT",
          "partial": "Main Loop Returns",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Begin.html#v:MainLoopReturns"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e(\u003cem\u003efreeglut only\u003c/em\u003e) Controls the behaviour when the user closes a window.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Begin",
          "name": "actionOnWindowClose",
          "package": "GLUT",
          "signature": "StateVar ActionOnWindowClose",
          "source": "src/Graphics-UI-GLUT-Begin.html#actionOnWindowClose",
          "type": "function"
        },
        "index": {
          "description": "freeglut only Controls the behaviour when the user closes window",
          "hierarchy": "Graphics UI GLUT Begin",
          "module": "Graphics.UI.GLUT.Begin",
          "name": "actionOnWindowClose",
          "package": "GLUT",
          "partial": "On Window Close",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Begin.html#v:actionOnWindowClose"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e(\u003cem\u003efreeglut only\u003c/em\u003e) Stop the event loop. If \u003ccode\u003e\u003ca\u003eactionOnWindowClose\u003c/a\u003e\u003c/code\u003e contains\n \u003ccode\u003e\u003ca\u003eExit\u003c/a\u003e\u003c/code\u003e, the application will exit; otherwise control will return to the\n function which called \u003ccode\u003e\u003ca\u003emainLoop\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eIf the application has two nested calls to \u003ccode\u003e\u003ca\u003emainLoop\u003c/a\u003e\u003c/code\u003e and calls\n \u003ccode\u003e\u003ca\u003eleaveMainLoop\u003c/a\u003e\u003c/code\u003e, the behaviour is undefined. It may leave only the inner\n nested loop or it may leave both loops. If the reader has a strong preference\n for one behaviour over the other he should contact the freeglut Programming\n Consortium and ask for the code to be fixed.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Begin",
          "name": "leaveMainLoop",
          "package": "GLUT",
          "signature": "IO ()",
          "source": "src/Graphics-UI-GLUT-Begin.html#leaveMainLoop",
          "type": "function"
        },
        "index": {
          "description": "freeglut only Stop the event loop If actionOnWindowClose contains Exit the application will exit otherwise control will return to the function which called mainLoop If the application has two nested calls to mainLoop and calls leaveMainLoop the behaviour is undefined It may leave only the inner nested loop or it may leave both loops If the reader has strong preference for one behaviour over the other he should contact the freeglut Programming Consortium and ask for the code to be fixed",
          "hierarchy": "Graphics UI GLUT Begin",
          "module": "Graphics.UI.GLUT.Begin",
          "name": "leaveMainLoop",
          "normalized": "IO()",
          "package": "GLUT",
          "partial": "Main Loop",
          "signature": "IO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Begin.html#v:leaveMainLoop"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEnter the GLUT event processing loop; it will call as necessary any\n callbacks that have been registered. This routine should be called at most\n once in a GLUT program.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Begin",
          "name": "mainLoop",
          "package": "GLUT",
          "signature": "IO ()",
          "source": "src/Graphics-UI-GLUT-Begin.html#mainLoop",
          "type": "function"
        },
        "index": {
          "description": "Enter the GLUT event processing loop it will call as necessary any callbacks that have been registered This routine should be called at most once in GLUT program",
          "hierarchy": "Graphics UI GLUT Begin",
          "module": "Graphics.UI.GLUT.Begin",
          "name": "mainLoop",
          "normalized": "IO()",
          "package": "GLUT",
          "partial": "Loop",
          "signature": "IO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Begin.html#v:mainLoop"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e(\u003cem\u003efreeglut only\u003c/em\u003e) Process one iteration's worth of events in its event loop.\n This allows the application to control its own event loop and still use the\n GLUT package.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Begin",
          "name": "mainLoopEvent",
          "package": "GLUT",
          "signature": "IO ()",
          "source": "src/Graphics-UI-GLUT-Begin.html#mainLoopEvent",
          "type": "function"
        },
        "index": {
          "description": "freeglut only Process one iteration worth of events in its event loop This allows the application to control its own event loop and still use the GLUT package",
          "hierarchy": "Graphics UI GLUT Begin",
          "module": "Graphics.UI.GLUT.Begin",
          "name": "mainLoopEvent",
          "normalized": "IO()",
          "package": "GLUT",
          "partial": "Loop Event",
          "signature": "IO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Begin.html#v:mainLoopEvent"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.UI.GLUT.Callbacks.Global",
          "name": "Global",
          "package": "GLUT",
          "source": "src/Graphics-UI-GLUT-Callbacks-Global.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Graphics UI GLUT Callbacks Global",
          "module": "Graphics.UI.GLUT.Callbacks.Global",
          "name": "Global",
          "package": "GLUT",
          "partial": "Global",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Callbacks-Global.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.UI.GLUT.Callbacks.Global",
          "name": "IdleCallback",
          "package": "GLUT",
          "source": "src/Graphics-UI-GLUT-Callbacks-Global.html#IdleCallback",
          "type": "type"
        },
        "index": {
          "hierarchy": "Graphics UI GLUT Callbacks Global",
          "module": "Graphics.UI.GLUT.Callbacks.Global",
          "name": "IdleCallback",
          "package": "GLUT",
          "partial": "Idle Callback",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Callbacks-Global.html#t:IdleCallback"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.UI.GLUT.Callbacks.Global",
          "name": "MenuStatusCallback",
          "package": "GLUT",
          "source": "src/Graphics-UI-GLUT-Callbacks-Global.html#MenuStatusCallback",
          "type": "type"
        },
        "index": {
          "hierarchy": "Graphics UI GLUT Callbacks Global",
          "module": "Graphics.UI.GLUT.Callbacks.Global",
          "name": "MenuStatusCallback",
          "package": "GLUT",
          "partial": "Menu Status Callback",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Callbacks-Global.html#t:MenuStatusCallback"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.UI.GLUT.Callbacks.Global",
          "name": "MenuUsage",
          "package": "GLUT",
          "source": "src/Graphics-UI-GLUT-Callbacks-Global.html#MenuUsage",
          "type": "data"
        },
        "index": {
          "hierarchy": "Graphics UI GLUT Callbacks Global",
          "module": "Graphics.UI.GLUT.Callbacks.Global",
          "name": "MenuUsage",
          "package": "GLUT",
          "partial": "Menu Usage",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Callbacks-Global.html#t:MenuUsage"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTimeout for the timer callback in milliseconds\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Callbacks.Global",
          "name": "Timeout",
          "package": "GLUT",
          "source": "src/Graphics-UI-GLUT-Callbacks-Global.html#Timeout",
          "type": "type"
        },
        "index": {
          "description": "Timeout for the timer callback in milliseconds",
          "hierarchy": "Graphics UI GLUT Callbacks Global",
          "module": "Graphics.UI.GLUT.Callbacks.Global",
          "name": "Timeout",
          "package": "GLUT",
          "partial": "Timeout",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Callbacks-Global.html#t:Timeout"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.UI.GLUT.Callbacks.Global",
          "name": "TimerCallback",
          "package": "GLUT",
          "source": "src/Graphics-UI-GLUT-Callbacks-Global.html#TimerCallback",
          "type": "type"
        },
        "index": {
          "hierarchy": "Graphics UI GLUT Callbacks Global",
          "module": "Graphics.UI.GLUT.Callbacks.Global",
          "name": "TimerCallback",
          "package": "GLUT",
          "partial": "Timer Callback",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Callbacks-Global.html#t:TimerCallback"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.UI.GLUT.Callbacks.Global",
          "name": "InUse",
          "package": "GLUT",
          "signature": "InUse",
          "source": "src/Graphics-UI-GLUT-Callbacks-Global.html#MenuUsage",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics UI GLUT Callbacks Global",
          "module": "Graphics.UI.GLUT.Callbacks.Global",
          "name": "InUse",
          "package": "GLUT",
          "partial": "In Use",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Callbacks-Global.html#v:InUse"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.UI.GLUT.Callbacks.Global",
          "name": "NotInUse",
          "package": "GLUT",
          "signature": "NotInUse",
          "source": "src/Graphics-UI-GLUT-Callbacks-Global.html#MenuUsage",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics UI GLUT Callbacks Global",
          "module": "Graphics.UI.GLUT.Callbacks.Global",
          "name": "NotInUse",
          "package": "GLUT",
          "partial": "Not In Use",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Callbacks-Global.html#v:NotInUse"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRegister a one-shot timer callback to be triggered after at least the given\n amount of time. Multiple timer callbacks at same or differing times may be\n registered simultaneously. There is no support for canceling a registered\n callback.\n\u003c/p\u003e\u003cp\u003eThe number of milliseconds is a lower bound on the time before the callback\n is generated. GLUT attempts to deliver the timer callback as soon as possible\n after the expiration of the callback's time interval.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Callbacks.Global",
          "name": "addTimerCallback",
          "package": "GLUT",
          "signature": "Timeout -\u003e TimerCallback -\u003e IO ()",
          "source": "src/Graphics-UI-GLUT-Callbacks-Global.html#addTimerCallback",
          "type": "function"
        },
        "index": {
          "description": "Register one-shot timer callback to be triggered after at least the given amount of time Multiple timer callbacks at same or differing times may be registered simultaneously There is no support for canceling registered callback The number of milliseconds is lower bound on the time before the callback is generated GLUT attempts to deliver the timer callback as soon as possible after the expiration of the callback time interval",
          "hierarchy": "Graphics UI GLUT Callbacks Global",
          "module": "Graphics.UI.GLUT.Callbacks.Global",
          "name": "addTimerCallback",
          "normalized": "Timeout-\u003eTimerCallback-\u003eIO()",
          "package": "GLUT",
          "partial": "Timer Callback",
          "signature": "Timeout-\u003eTimerCallback-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Callbacks-Global.html#v:addTimerCallback"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eControls the global idle callback so a GLUT program can perform background\n processing tasks or continuous animation when window system events are not\n being received. If enabled, the idle callback is continuously called when\n events are not being received. The \u003cem\u003ecurrent window\u003c/em\u003e and \u003cem\u003ecurrent menu\u003c/em\u003e will\n not be changed before the idle callback. Programs with multiple windows\n and/or menus should explicitly set the \u003cem\u003ecurrent window\u003c/em\u003e and/or /current\n menu/ and not rely on its current setting.\n\u003c/p\u003e\u003cp\u003eThe amount of computation and rendering done in an idle callback should be\n minimized to avoid affecting the program's interactive response. In general,\n not more than a single frame of rendering should be done in an idle callback.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Callbacks.Global",
          "name": "idleCallback",
          "package": "GLUT",
          "signature": "SettableStateVar (Maybe IdleCallback)",
          "source": "src/Graphics-UI-GLUT-Callbacks-Global.html#idleCallback",
          "type": "function"
        },
        "index": {
          "description": "Controls the global idle callback so GLUT program can perform background processing tasks or continuous animation when window system events are not being received If enabled the idle callback is continuously called when events are not being received The current window and current menu will not be changed before the idle callback Programs with multiple windows and or menus should explicitly set the current window and or current menu and not rely on its current setting The amount of computation and rendering done in an idle callback should be minimized to avoid affecting the program interactive response In general not more than single frame of rendering should be done in an idle callback",
          "hierarchy": "Graphics UI GLUT Callbacks Global",
          "module": "Graphics.UI.GLUT.Callbacks.Global",
          "name": "idleCallback",
          "package": "GLUT",
          "partial": "Callback",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Callbacks-Global.html#v:idleCallback"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eControls the global menu status callback so a GLUT program can determine\n when a menu is in use or not. When a menu status callback is registered, it\n will be called with the value \u003ccode\u003e\u003ca\u003eInUse\u003c/a\u003e\u003c/code\u003e when pop-up menus are in use by the\n user; and the callback will be called with the value \u003ccode\u003e\u003ca\u003eNotInUse\u003c/a\u003e\u003c/code\u003e when pop-up\n menus are no longer in use. Additionally, the location in window coordinates\n of the button press that caused the menu to go into use, or the location where\n the menu was released (maybe outside the window). Other callbacks continue to\n operate (except mouse motion callbacks) when pop-up menus are in use so the\n menu status callback allows a program to suspend animation or other tasks\n when menus are in use. The cascading and unmapping of sub-menus from an\n initial pop-up menu does not generate menu status callbacks. There is a\n single menu status callback for GLUT.\n\u003c/p\u003e\u003cp\u003eWhen the menu status callback is called, the \u003cem\u003ecurrent menu\u003c/em\u003e will be set to\n the initial pop-up menu in both the \u003ccode\u003e\u003ca\u003eInUse\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003eNotInUse\u003c/a\u003e\u003c/code\u003e cases. The\n \u003cem\u003ecurrent window\u003c/em\u003e will be set to the window from which the initial menu was\n popped up from, also in both cases.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Callbacks.Global",
          "name": "menuStatusCallback",
          "package": "GLUT",
          "signature": "SettableStateVar (Maybe MenuStatusCallback)",
          "source": "src/Graphics-UI-GLUT-Callbacks-Global.html#menuStatusCallback",
          "type": "function"
        },
        "index": {
          "description": "Controls the global menu status callback so GLUT program can determine when menu is in use or not When menu status callback is registered it will be called with the value InUse when pop-up menus are in use by the user and the callback will be called with the value NotInUse when pop-up menus are no longer in use Additionally the location in window coordinates of the button press that caused the menu to go into use or the location where the menu was released maybe outside the window Other callbacks continue to operate except mouse motion callbacks when pop-up menus are in use so the menu status callback allows program to suspend animation or other tasks when menus are in use The cascading and unmapping of sub-menus from an initial pop-up menu does not generate menu status callbacks There is single menu status callback for GLUT When the menu status callback is called the current menu will be set to the initial pop-up menu in both the InUse and NotInUse cases The current window will be set to the window from which the initial menu was popped up from also in both cases",
          "hierarchy": "Graphics UI GLUT Callbacks Global",
          "module": "Graphics.UI.GLUT.Callbacks.Global",
          "name": "menuStatusCallback",
          "package": "GLUT",
          "partial": "Status Callback",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Callbacks-Global.html#v:menuStatusCallback"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "Window",
          "package": "GLUT",
          "source": "src/Graphics-UI-GLUT-Callbacks-Window.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Graphics UI GLUT Callbacks Window",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "Window",
          "package": "GLUT",
          "partial": "Window",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Callbacks-Window.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe application status of the \u003cem\u003ecurrent window\u003c/em\u003e\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "AppStatus",
          "package": "GLUT",
          "source": "src/Graphics-UI-GLUT-Callbacks-Window.html#AppStatus",
          "type": "data"
        },
        "index": {
          "description": "The application status of the current window",
          "hierarchy": "Graphics UI GLUT Callbacks Window",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "AppStatus",
          "package": "GLUT",
          "partial": "App Status",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Callbacks-Window.html#t:AppStatus"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn application status callback\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "AppStatusCallback",
          "package": "GLUT",
          "source": "src/Graphics-UI-GLUT-Callbacks-Window.html#AppStatusCallback",
          "type": "type"
        },
        "index": {
          "description": "An application status callback",
          "hierarchy": "Graphics UI GLUT Callbacks Window",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "AppStatusCallback",
          "package": "GLUT",
          "partial": "App Status Callback",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Callbacks-Window.html#t:AppStatusCallback"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe index of a specific buttons of an input device.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "ButtonIndex",
          "package": "GLUT",
          "source": "src/Graphics-UI-GLUT-Callbacks-Window.html#ButtonIndex",
          "type": "type"
        },
        "index": {
          "description": "The index of specific buttons of an input device",
          "hierarchy": "Graphics UI GLUT Callbacks Window",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "ButtonIndex",
          "package": "GLUT",
          "partial": "Button Index",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Callbacks-Window.html#t:ButtonIndex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA window close callback\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "CloseCallback",
          "package": "GLUT",
          "source": "src/Graphics-UI-GLUT-Callbacks-Window.html#CloseCallback",
          "type": "type"
        },
        "index": {
          "description": "window close callback",
          "hierarchy": "Graphics UI GLUT Callbacks Window",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "CloseCallback",
          "package": "GLUT",
          "partial": "Close Callback",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Callbacks-Window.html#t:CloseCallback"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe relation between the mouse pointer and the \u003cem\u003ecurrent window\u003c/em\u003e has\n changed.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "Crossing",
          "package": "GLUT",
          "source": "src/Graphics-UI-GLUT-Callbacks-Window.html#Crossing",
          "type": "data"
        },
        "index": {
          "description": "The relation between the mouse pointer and the current window has changed",
          "hierarchy": "Graphics UI GLUT Callbacks Window",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "Crossing",
          "package": "GLUT",
          "partial": "Crossing",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Callbacks-Window.html#t:Crossing"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn enter/leave callback\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "CrossingCallback",
          "package": "GLUT",
          "source": "src/Graphics-UI-GLUT-Callbacks-Window.html#CrossingCallback",
          "type": "type"
        },
        "index": {
          "description": "An enter leave callback",
          "hierarchy": "Graphics UI GLUT Callbacks Window",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "CrossingCallback",
          "package": "GLUT",
          "partial": "Crossing Callback",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Callbacks-Window.html#t:CrossingCallback"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA dial & button box callback\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "DialAndButtonBoxCallback",
          "package": "GLUT",
          "source": "src/Graphics-UI-GLUT-Callbacks-Window.html#DialAndButtonBoxCallback",
          "type": "type"
        },
        "index": {
          "description": "dial button box callback",
          "hierarchy": "Graphics UI GLUT Callbacks Window",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "DialAndButtonBoxCallback",
          "package": "GLUT",
          "partial": "Dial And Button Box Callback",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Callbacks-Window.html#t:DialAndButtonBoxCallback"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe dial & button box state has changed.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "DialAndButtonBoxInput",
          "package": "GLUT",
          "source": "src/Graphics-UI-GLUT-Callbacks-Window.html#DialAndButtonBoxInput",
          "type": "data"
        },
        "index": {
          "description": "The dial button box state has changed",
          "hierarchy": "Graphics UI GLUT Callbacks Window",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "DialAndButtonBoxInput",
          "package": "GLUT",
          "partial": "Dial And Button Box Input",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Callbacks-Window.html#t:DialAndButtonBoxInput"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe index of a specific dial of a dial and button box.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "DialIndex",
          "package": "GLUT",
          "source": "src/Graphics-UI-GLUT-Callbacks-Window.html#DialIndex",
          "type": "type"
        },
        "index": {
          "description": "The index of specific dial of dial and button box",
          "hierarchy": "Graphics UI GLUT Callbacks Window",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "DialIndex",
          "package": "GLUT",
          "partial": "Dial Index",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Callbacks-Window.html#t:DialIndex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA display callback\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "DisplayCallback",
          "package": "GLUT",
          "source": "src/Graphics-UI-GLUT-Callbacks-Window.html#DisplayCallback",
          "type": "type"
        },
        "index": {
          "description": "display callback",
          "hierarchy": "Graphics UI GLUT Callbacks Window",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "DisplayCallback",
          "package": "GLUT",
          "partial": "Display Callback",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Callbacks-Window.html#t:DisplayCallback"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn initialize context callback\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "InitContextCallback",
          "package": "GLUT",
          "source": "src/Graphics-UI-GLUT-Callbacks-Window.html#InitContextCallback",
          "type": "type"
        },
        "index": {
          "description": "An initialize context callback",
          "hierarchy": "Graphics UI GLUT Callbacks Window",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "InitContextCallback",
          "package": "GLUT",
          "partial": "Init Context Callback",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Callbacks-Window.html#t:InitContextCallback"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe state of the joystick buttons\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "JoystickButtons",
          "package": "GLUT",
          "source": "src/Graphics-UI-GLUT-Callbacks-Window.html#JoystickButtons",
          "type": "data"
        },
        "index": {
          "description": "The state of the joystick buttons",
          "hierarchy": "Graphics UI GLUT Callbacks Window",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "JoystickButtons",
          "package": "GLUT",
          "partial": "Joystick Buttons",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Callbacks-Window.html#t:JoystickButtons"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA joystick callback\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "JoystickCallback",
          "package": "GLUT",
          "source": "src/Graphics-UI-GLUT-Callbacks-Window.html#JoystickCallback",
          "type": "type"
        },
        "index": {
          "description": "joystick callback",
          "hierarchy": "Graphics UI GLUT Callbacks Window",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "JoystickCallback",
          "package": "GLUT",
          "partial": "Joystick Callback",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Callbacks-Window.html#t:JoystickCallback"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAbsolute joystick position, with coordinates normalized to be in the range\n of -1000 to 1000 inclusive. The signs of the three axes mean the following:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e negative = left, positive = right\n\u003c/li\u003e\u003cli\u003e negative = towards player, positive = away\n\u003c/li\u003e\u003cli\u003e if available (e.g. rudder): negative = down, positive = up\n\u003c/li\u003e\u003c/ul\u003e",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "JoystickPosition",
          "package": "GLUT",
          "source": "src/Graphics-UI-GLUT-Callbacks-Window.html#JoystickPosition",
          "type": "data"
        },
        "index": {
          "description": "Absolute joystick position with coordinates normalized to be in the range of to inclusive The signs of the three axes mean the following negative left positive right negative towards player positive away if available e.g rudder negative down positive up",
          "hierarchy": "Graphics UI GLUT Callbacks Window",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "JoystickPosition",
          "package": "GLUT",
          "partial": "Joystick Position",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Callbacks-Window.html#t:JoystickPosition"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA generalized view of keys\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "Key",
          "package": "GLUT",
          "source": "src/Graphics-UI-GLUT-Callbacks-Window.html#Key",
          "type": "data"
        },
        "index": {
          "description": "generalized view of keys",
          "hierarchy": "Graphics UI GLUT Callbacks Window",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "Key",
          "package": "GLUT",
          "partial": "Key",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Callbacks-Window.html#t:Key"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe current state of a key or button\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "KeyState",
          "package": "GLUT",
          "source": "src/Graphics-UI-GLUT-Callbacks-Window.html#KeyState",
          "type": "data"
        },
        "index": {
          "description": "The current state of key or button",
          "hierarchy": "Graphics UI GLUT Callbacks Window",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "KeyState",
          "package": "GLUT",
          "partial": "Key State",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Callbacks-Window.html#t:KeyState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA keyboard callback\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "KeyboardCallback",
          "package": "GLUT",
          "source": "src/Graphics-UI-GLUT-Callbacks-Window.html#KeyboardCallback",
          "type": "type"
        },
        "index": {
          "description": "keyboard callback",
          "hierarchy": "Graphics UI GLUT Callbacks Window",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "KeyboardCallback",
          "package": "GLUT",
          "partial": "Keyboard Callback",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Callbacks-Window.html#t:KeyboardCallback"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA keyboard/mouse callback\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "KeyboardMouseCallback",
          "package": "GLUT",
          "source": "src/Graphics-UI-GLUT-Callbacks-Window.html#KeyboardMouseCallback",
          "type": "type"
        },
        "index": {
          "description": "keyboard mouse callback",
          "hierarchy": "Graphics UI GLUT Callbacks Window",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "KeyboardMouseCallback",
          "package": "GLUT",
          "partial": "Keyboard Mouse Callback",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Callbacks-Window.html#t:KeyboardMouseCallback"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe state of the keyboard modifiers\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "Modifiers",
          "package": "GLUT",
          "source": "src/Graphics-UI-GLUT-Callbacks-Window.html#Modifiers",
          "type": "data"
        },
        "index": {
          "description": "The state of the keyboard modifiers",
          "hierarchy": "Graphics UI GLUT Callbacks Window",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "Modifiers",
          "package": "GLUT",
          "partial": "Modifiers",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Callbacks-Window.html#t:Modifiers"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA motion callback\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "MotionCallback",
          "package": "GLUT",
          "source": "src/Graphics-UI-GLUT-Callbacks-Window.html#MotionCallback",
          "type": "type"
        },
        "index": {
          "description": "motion callback",
          "hierarchy": "Graphics UI GLUT Callbacks Window",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "MotionCallback",
          "package": "GLUT",
          "partial": "Motion Callback",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Callbacks-Window.html#t:MotionCallback"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMouse buttons, including a wheel\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "MouseButton",
          "package": "GLUT",
          "source": "src/Graphics-UI-GLUT-Types.html#MouseButton",
          "type": "data"
        },
        "index": {
          "description": "Mouse buttons including wheel",
          "hierarchy": "Graphics UI GLUT Callbacks Window",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "MouseButton",
          "package": "GLUT",
          "partial": "Mouse Button",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Callbacks-Window.html#t:MouseButton"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA mouse callback\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "MouseCallback",
          "package": "GLUT",
          "source": "src/Graphics-UI-GLUT-Callbacks-Window.html#MouseCallback",
          "type": "type"
        },
        "index": {
          "description": "mouse callback",
          "hierarchy": "Graphics UI GLUT Callbacks Window",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "MouseCallback",
          "package": "GLUT",
          "partial": "Mouse Callback",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Callbacks-Window.html#t:MouseCallback"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "MouseWheelCallback",
          "package": "GLUT",
          "source": "src/Graphics-UI-GLUT-Callbacks-Window.html#MouseWheelCallback",
          "type": "type"
        },
        "index": {
          "hierarchy": "Graphics UI GLUT Callbacks Window",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "MouseWheelCallback",
          "package": "GLUT",
          "partial": "Mouse Wheel Callback",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Callbacks-Window.html#t:MouseWheelCallback"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA multi-touch variant of \u003ccode\u003e\u003ca\u003eCrossingCallback\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "MultiCrossingCallback",
          "package": "GLUT",
          "source": "src/Graphics-UI-GLUT-Callbacks-Window.html#MultiCrossingCallback",
          "type": "type"
        },
        "index": {
          "description": "multi-touch variant of CrossingCallback",
          "hierarchy": "Graphics UI GLUT Callbacks Window",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "MultiCrossingCallback",
          "package": "GLUT",
          "partial": "Multi Crossing Callback",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Callbacks-Window.html#t:MultiCrossingCallback"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA multi-touch variant of \u003ccode\u003e\u003ca\u003eMotionCallback\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "MultiMotionCallback",
          "package": "GLUT",
          "source": "src/Graphics-UI-GLUT-Callbacks-Window.html#MultiMotionCallback",
          "type": "type"
        },
        "index": {
          "description": "multi-touch variant of MotionCallback",
          "hierarchy": "Graphics UI GLUT Callbacks Window",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "MultiMotionCallback",
          "package": "GLUT",
          "partial": "Multi Motion Callback",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Callbacks-Window.html#t:MultiMotionCallback"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA multi-touch variant of \u003ccode\u003e\u003ca\u003eMouseCallback\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "MultiMouseCallback",
          "package": "GLUT",
          "source": "src/Graphics-UI-GLUT-Callbacks-Window.html#MultiMouseCallback",
          "type": "type"
        },
        "index": {
          "description": "multi-touch variant of MouseCallback",
          "hierarchy": "Graphics UI GLUT Callbacks Window",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "MultiMouseCallback",
          "package": "GLUT",
          "partial": "Multi Mouse Callback",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Callbacks-Window.html#t:MultiMouseCallback"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA position callback\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "PositionCallback",
          "package": "GLUT",
          "source": "src/Graphics-UI-GLUT-Callbacks-Window.html#PositionCallback",
          "type": "type"
        },
        "index": {
          "description": "position callback",
          "hierarchy": "Graphics UI GLUT Callbacks Window",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "PositionCallback",
          "package": "GLUT",
          "partial": "Position Callback",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Callbacks-Window.html#t:PositionCallback"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA reshape callback\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "ReshapeCallback",
          "package": "GLUT",
          "source": "src/Graphics-UI-GLUT-Callbacks-Window.html#ReshapeCallback",
          "type": "type"
        },
        "index": {
          "description": "reshape callback",
          "hierarchy": "Graphics UI GLUT Callbacks Window",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "ReshapeCallback",
          "package": "GLUT",
          "partial": "Reshape Callback",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Callbacks-Window.html#t:ReshapeCallback"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA SpaceballButton callback\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "SpaceballCallback",
          "package": "GLUT",
          "source": "src/Graphics-UI-GLUT-Callbacks-Window.html#SpaceballCallback",
          "type": "type"
        },
        "index": {
          "description": "SpaceballButton callback",
          "hierarchy": "Graphics UI GLUT Callbacks Window",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "SpaceballCallback",
          "package": "GLUT",
          "partial": "Spaceball Callback",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Callbacks-Window.html#t:SpaceballCallback"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe state of the Spaceball has changed.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "SpaceballInput",
          "package": "GLUT",
          "source": "src/Graphics-UI-GLUT-Callbacks-Window.html#SpaceballInput",
          "type": "data"
        },
        "index": {
          "description": "The state of the Spaceball has changed",
          "hierarchy": "Graphics UI GLUT Callbacks Window",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "SpaceballInput",
          "package": "GLUT",
          "partial": "Spaceball Input",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Callbacks-Window.html#t:SpaceballInput"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTranslation of the Spaceball along one axis, normalized to be in the range\n of -1000 to +1000 inclusive\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "SpaceballMotion",
          "package": "GLUT",
          "source": "src/Graphics-UI-GLUT-Callbacks-Window.html#SpaceballMotion",
          "type": "type"
        },
        "index": {
          "description": "Translation of the Spaceball along one axis normalized to be in the range of to inclusive",
          "hierarchy": "Graphics UI GLUT Callbacks Window",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "SpaceballMotion",
          "package": "GLUT",
          "partial": "Spaceball Motion",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Callbacks-Window.html#t:SpaceballMotion"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRotation of the Spaceball along one axis, normalized to be in the range\n of -1800 .. +1800 inclusive\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "SpaceballRotation",
          "package": "GLUT",
          "source": "src/Graphics-UI-GLUT-Callbacks-Window.html#SpaceballRotation",
          "type": "type"
        },
        "index": {
          "description": "Rotation of the Spaceball along one axis normalized to be in the range of inclusive",
          "hierarchy": "Graphics UI GLUT Callbacks Window",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "SpaceballRotation",
          "package": "GLUT",
          "partial": "Spaceball Rotation",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Callbacks-Window.html#t:SpaceballRotation"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA special key callback\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "SpecialCallback",
          "package": "GLUT",
          "source": "src/Graphics-UI-GLUT-Callbacks-Window.html#SpecialCallback",
          "type": "type"
        },
        "index": {
          "description": "special key callback",
          "hierarchy": "Graphics UI GLUT Callbacks Window",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "SpecialCallback",
          "package": "GLUT",
          "partial": "Special Callback",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Callbacks-Window.html#t:SpecialCallback"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSpecial keys\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "SpecialKey",
          "package": "GLUT",
          "source": "src/Graphics-UI-GLUT-Callbacks-Window.html#SpecialKey",
          "type": "data"
        },
        "index": {
          "description": "Special keys",
          "hierarchy": "Graphics UI GLUT Callbacks Window",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "SpecialKey",
          "package": "GLUT",
          "partial": "Special Key",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Callbacks-Window.html#t:SpecialKey"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA tablet callback\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "TabletCallback",
          "package": "GLUT",
          "source": "src/Graphics-UI-GLUT-Callbacks-Window.html#TabletCallback",
          "type": "type"
        },
        "index": {
          "description": "tablet callback",
          "hierarchy": "Graphics UI GLUT Callbacks Window",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "TabletCallback",
          "package": "GLUT",
          "partial": "Tablet Callback",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Callbacks-Window.html#t:TabletCallback"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe table state has changed.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "TabletInput",
          "package": "GLUT",
          "source": "src/Graphics-UI-GLUT-Callbacks-Window.html#TabletInput",
          "type": "data"
        },
        "index": {
          "description": "The table state has changed",
          "hierarchy": "Graphics UI GLUT Callbacks Window",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "TabletInput",
          "package": "GLUT",
          "partial": "Tablet Input",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Callbacks-Window.html#t:TabletInput"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAbsolute tablet position, with coordinates normalized to be in the range of\n 0 to 2000 inclusive\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "TabletPosition",
          "package": "GLUT",
          "source": "src/Graphics-UI-GLUT-Callbacks-Window.html#TabletPosition",
          "type": "data"
        },
        "index": {
          "description": "Absolute tablet position with coordinates normalized to be in the range of to inclusive",
          "hierarchy": "Graphics UI GLUT Callbacks Window",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "TabletPosition",
          "package": "GLUT",
          "partial": "Tablet Position",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Callbacks-Window.html#t:TabletPosition"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA description where the multi-touch event is coming from, the freeglut\n specs are very vague about the actual semantics. It contains the device ID\n and/or the cursor/finger ID.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "TouchID",
          "package": "GLUT",
          "source": "src/Graphics-UI-GLUT-Callbacks-Window.html#TouchID",
          "type": "type"
        },
        "index": {
          "description": "description where the multi-touch event is coming from the freeglut specs are very vague about the actual semantics It contains the device ID and or the cursor finger ID",
          "hierarchy": "Graphics UI GLUT Callbacks Window",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "TouchID",
          "package": "GLUT",
          "partial": "Touch ID",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Callbacks-Window.html#t:TouchID"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe visibility state of the \u003cem\u003ecurrent window\u003c/em\u003e\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "Visibility",
          "package": "GLUT",
          "source": "src/Graphics-UI-GLUT-Callbacks-Window.html#Visibility",
          "type": "data"
        },
        "index": {
          "description": "The visibility state of the current window",
          "hierarchy": "Graphics UI GLUT Callbacks Window",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "Visibility",
          "package": "GLUT",
          "partial": "Visibility",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Callbacks-Window.html#t:Visibility"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA visibility callback\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "VisibilityCallback",
          "package": "GLUT",
          "source": "src/Graphics-UI-GLUT-Callbacks-Window.html#VisibilityCallback",
          "type": "type"
        },
        "index": {
          "description": "visibility callback",
          "hierarchy": "Graphics UI GLUT Callbacks Window",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "VisibilityCallback",
          "package": "GLUT",
          "partial": "Visibility Callback",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Callbacks-Window.html#t:VisibilityCallback"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "WheelDirection",
          "package": "GLUT",
          "source": "src/Graphics-UI-GLUT-Callbacks-Window.html#WheelDirection",
          "type": "type"
        },
        "index": {
          "hierarchy": "Graphics UI GLUT Callbacks Window",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "WheelDirection",
          "package": "GLUT",
          "partial": "Wheel Direction",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Callbacks-Window.html#t:WheelDirection"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "WheelNumber",
          "package": "GLUT",
          "source": "src/Graphics-UI-GLUT-Callbacks-Window.html#WheelNumber",
          "type": "type"
        },
        "index": {
          "hierarchy": "Graphics UI GLUT Callbacks Window",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "WheelNumber",
          "package": "GLUT",
          "partial": "Wheel Number",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Callbacks-Window.html#t:WheelNumber"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe window state of the \u003cem\u003ecurrent window\u003c/em\u003e\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "WindowState",
          "package": "GLUT",
          "source": "src/Graphics-UI-GLUT-Callbacks-Window.html#WindowState",
          "type": "data"
        },
        "index": {
          "description": "The window state of the current window",
          "hierarchy": "Graphics UI GLUT Callbacks Window",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "WindowState",
          "package": "GLUT",
          "partial": "Window State",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Callbacks-Window.html#t:WindowState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA window state callback\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "WindowStateCallback",
          "package": "GLUT",
          "source": "src/Graphics-UI-GLUT-Callbacks-Window.html#WindowStateCallback",
          "type": "type"
        },
        "index": {
          "description": "window state callback",
          "hierarchy": "Graphics UI GLUT Callbacks Window",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "WindowStateCallback",
          "package": "GLUT",
          "partial": "Window State Callback",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Callbacks-Window.html#t:WindowStateCallback"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "AdditionalButton",
          "package": "GLUT",
          "signature": "AdditionalButton Int",
          "source": "src/Graphics-UI-GLUT-Types.html#MouseButton",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics UI GLUT Callbacks Window",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "AdditionalButton",
          "package": "GLUT",
          "partial": "Additional Button",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Callbacks-Window.html#v:AdditionalButton"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "AppStatusPause",
          "package": "GLUT",
          "signature": "AppStatusPause",
          "source": "src/Graphics-UI-GLUT-Callbacks-Window.html#AppStatus",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics UI GLUT Callbacks Window",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "AppStatusPause",
          "package": "GLUT",
          "partial": "App Status Pause",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Callbacks-Window.html#v:AppStatusPause"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "AppStatusResume",
          "package": "GLUT",
          "signature": "AppStatusResume",
          "source": "src/Graphics-UI-GLUT-Callbacks-Window.html#AppStatus",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics UI GLUT Callbacks Window",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "AppStatusResume",
          "package": "GLUT",
          "partial": "App Status Resume",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Callbacks-Window.html#v:AppStatusResume"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "Char",
          "package": "GLUT",
          "signature": "Char Char",
          "source": "src/Graphics-UI-GLUT-Callbacks-Window.html#Key",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics UI GLUT Callbacks Window",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "Char",
          "package": "GLUT",
          "partial": "Char",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Callbacks-Window.html#v:Char"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "DialAndButtonBoxButton",
          "package": "GLUT",
          "signature": "DialAndButtonBoxButton ButtonIndex KeyState",
          "source": "src/Graphics-UI-GLUT-Callbacks-Window.html#DialAndButtonBoxInput",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics UI GLUT Callbacks Window",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "DialAndButtonBoxButton",
          "package": "GLUT",
          "partial": "Dial And Button Box Button",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Callbacks-Window.html#v:DialAndButtonBoxButton"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "DialAndButtonBoxDial",
          "package": "GLUT",
          "signature": "DialAndButtonBoxDial DialIndex Int",
          "source": "src/Graphics-UI-GLUT-Callbacks-Window.html#DialAndButtonBoxInput",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics UI GLUT Callbacks Window",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "DialAndButtonBoxDial",
          "package": "GLUT",
          "partial": "Dial And Button Box Dial",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Callbacks-Window.html#v:DialAndButtonBoxDial"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "Down",
          "package": "GLUT",
          "signature": "Down",
          "source": "src/Graphics-UI-GLUT-Callbacks-Window.html#KeyState",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics UI GLUT Callbacks Window",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "Down",
          "package": "GLUT",
          "partial": "Down",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Callbacks-Window.html#v:Down"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003cem\u003ecurrent window\u003c/em\u003e is fully obscured.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "FullyCovered",
          "package": "GLUT",
          "signature": "FullyCovered",
          "source": "src/Graphics-UI-GLUT-Callbacks-Window.html#WindowState",
          "type": "function"
        },
        "index": {
          "description": "The current window is fully obscured",
          "hierarchy": "Graphics UI GLUT Callbacks Window",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "FullyCovered",
          "package": "GLUT",
          "partial": "Fully Covered",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Callbacks-Window.html#v:FullyCovered"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003cem\u003ecurrent window\u003c/em\u003e is unobscured.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "FullyRetained",
          "package": "GLUT",
          "signature": "FullyRetained",
          "source": "src/Graphics-UI-GLUT-Callbacks-Window.html#WindowState",
          "type": "function"
        },
        "index": {
          "description": "The current window is unobscured",
          "hierarchy": "Graphics UI GLUT Callbacks Window",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "FullyRetained",
          "package": "GLUT",
          "partial": "Fully Retained",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Callbacks-Window.html#v:FullyRetained"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "JoystickButtons",
          "package": "GLUT",
          "signature": "JoystickButtons",
          "source": "src/Graphics-UI-GLUT-Callbacks-Window.html#JoystickButtons",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics UI GLUT Callbacks Window",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "JoystickButtons",
          "package": "GLUT",
          "partial": "Joystick Buttons",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Callbacks-Window.html#v:JoystickButtons"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "JoystickPosition",
          "package": "GLUT",
          "signature": "JoystickPosition Int Int Int",
          "source": "src/Graphics-UI-GLUT-Callbacks-Window.html#JoystickPosition",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics UI GLUT Callbacks Window",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "JoystickPosition",
          "package": "GLUT",
          "partial": "Joystick Position",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Callbacks-Window.html#v:JoystickPosition"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "KeyAltL",
          "package": "GLUT",
          "signature": "KeyAltL",
          "source": "src/Graphics-UI-GLUT-Callbacks-Window.html#SpecialKey",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics UI GLUT Callbacks Window",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "KeyAltL",
          "package": "GLUT",
          "partial": "Key Alt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Callbacks-Window.html#v:KeyAltL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "KeyAltR",
          "package": "GLUT",
          "signature": "KeyAltR",
          "source": "src/Graphics-UI-GLUT-Callbacks-Window.html#SpecialKey",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics UI GLUT Callbacks Window",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "KeyAltR",
          "package": "GLUT",
          "partial": "Key Alt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Callbacks-Window.html#v:KeyAltR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "KeyBegin",
          "package": "GLUT",
          "signature": "KeyBegin",
          "source": "src/Graphics-UI-GLUT-Callbacks-Window.html#SpecialKey",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics UI GLUT Callbacks Window",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "KeyBegin",
          "package": "GLUT",
          "partial": "Key Begin",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Callbacks-Window.html#v:KeyBegin"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "KeyCtrlL",
          "package": "GLUT",
          "signature": "KeyCtrlL",
          "source": "src/Graphics-UI-GLUT-Callbacks-Window.html#SpecialKey",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics UI GLUT Callbacks Window",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "KeyCtrlL",
          "package": "GLUT",
          "partial": "Key Ctrl",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Callbacks-Window.html#v:KeyCtrlL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "KeyCtrlR",
          "package": "GLUT",
          "signature": "KeyCtrlR",
          "source": "src/Graphics-UI-GLUT-Callbacks-Window.html#SpecialKey",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics UI GLUT Callbacks Window",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "KeyCtrlR",
          "package": "GLUT",
          "partial": "Key Ctrl",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Callbacks-Window.html#v:KeyCtrlR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "KeyDelete",
          "package": "GLUT",
          "signature": "KeyDelete",
          "source": "src/Graphics-UI-GLUT-Callbacks-Window.html#SpecialKey",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics UI GLUT Callbacks Window",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "KeyDelete",
          "package": "GLUT",
          "partial": "Key Delete",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Callbacks-Window.html#v:KeyDelete"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "KeyDown",
          "package": "GLUT",
          "signature": "KeyDown",
          "source": "src/Graphics-UI-GLUT-Callbacks-Window.html#SpecialKey",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics UI GLUT Callbacks Window",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "KeyDown",
          "package": "GLUT",
          "partial": "Key Down",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Callbacks-Window.html#v:KeyDown"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "KeyEnd",
          "package": "GLUT",
          "signature": "KeyEnd",
          "source": "src/Graphics-UI-GLUT-Callbacks-Window.html#SpecialKey",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics UI GLUT Callbacks Window",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "KeyEnd",
          "package": "GLUT",
          "partial": "Key End",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Callbacks-Window.html#v:KeyEnd"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "KeyF1",
          "package": "GLUT",
          "signature": "KeyF1",
          "source": "src/Graphics-UI-GLUT-Callbacks-Window.html#SpecialKey",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics UI GLUT Callbacks Window",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "KeyF1",
          "package": "GLUT",
          "partial": "Key",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Callbacks-Window.html#v:KeyF1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "KeyF10",
          "package": "GLUT",
          "signature": "KeyF10",
          "source": "src/Graphics-UI-GLUT-Callbacks-Window.html#SpecialKey",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics UI GLUT Callbacks Window",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "KeyF10",
          "package": "GLUT",
          "partial": "Key",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Callbacks-Window.html#v:KeyF10"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "KeyF11",
          "package": "GLUT",
          "signature": "KeyF11",
          "source": "src/Graphics-UI-GLUT-Callbacks-Window.html#SpecialKey",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics UI GLUT Callbacks Window",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "KeyF11",
          "package": "GLUT",
          "partial": "Key",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Callbacks-Window.html#v:KeyF11"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "KeyF12",
          "package": "GLUT",
          "signature": "KeyF12",
          "source": "src/Graphics-UI-GLUT-Callbacks-Window.html#SpecialKey",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics UI GLUT Callbacks Window",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "KeyF12",
          "package": "GLUT",
          "partial": "Key",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Callbacks-Window.html#v:KeyF12"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "KeyF2",
          "package": "GLUT",
          "signature": "KeyF2",
          "source": "src/Graphics-UI-GLUT-Callbacks-Window.html#SpecialKey",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics UI GLUT Callbacks Window",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "KeyF2",
          "package": "GLUT",
          "partial": "Key",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Callbacks-Window.html#v:KeyF2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "KeyF3",
          "package": "GLUT",
          "signature": "KeyF3",
          "source": "src/Graphics-UI-GLUT-Callbacks-Window.html#SpecialKey",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics UI GLUT Callbacks Window",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "KeyF3",
          "package": "GLUT",
          "partial": "Key",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Callbacks-Window.html#v:KeyF3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "KeyF4",
          "package": "GLUT",
          "signature": "KeyF4",
          "source": "src/Graphics-UI-GLUT-Callbacks-Window.html#SpecialKey",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics UI GLUT Callbacks Window",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "KeyF4",
          "package": "GLUT",
          "partial": "Key",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Callbacks-Window.html#v:KeyF4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "KeyF5",
          "package": "GLUT",
          "signature": "KeyF5",
          "source": "src/Graphics-UI-GLUT-Callbacks-Window.html#SpecialKey",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics UI GLUT Callbacks Window",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "KeyF5",
          "package": "GLUT",
          "partial": "Key",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Callbacks-Window.html#v:KeyF5"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "KeyF6",
          "package": "GLUT",
          "signature": "KeyF6",
          "source": "src/Graphics-UI-GLUT-Callbacks-Window.html#SpecialKey",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics UI GLUT Callbacks Window",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "KeyF6",
          "package": "GLUT",
          "partial": "Key",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Callbacks-Window.html#v:KeyF6"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "KeyF7",
          "package": "GLUT",
          "signature": "KeyF7",
          "source": "src/Graphics-UI-GLUT-Callbacks-Window.html#SpecialKey",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics UI GLUT Callbacks Window",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "KeyF7",
          "package": "GLUT",
          "partial": "Key",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Callbacks-Window.html#v:KeyF7"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "KeyF8",
          "package": "GLUT",
          "signature": "KeyF8",
          "source": "src/Graphics-UI-GLUT-Callbacks-Window.html#SpecialKey",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics UI GLUT Callbacks Window",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "KeyF8",
          "package": "GLUT",
          "partial": "Key",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Callbacks-Window.html#v:KeyF8"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "KeyF9",
          "package": "GLUT",
          "signature": "KeyF9",
          "source": "src/Graphics-UI-GLUT-Callbacks-Window.html#SpecialKey",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics UI GLUT Callbacks Window",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "KeyF9",
          "package": "GLUT",
          "partial": "Key",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Callbacks-Window.html#v:KeyF9"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "KeyHome",
          "package": "GLUT",
          "signature": "KeyHome",
          "source": "src/Graphics-UI-GLUT-Callbacks-Window.html#SpecialKey",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics UI GLUT Callbacks Window",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "KeyHome",
          "package": "GLUT",
          "partial": "Key Home",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Callbacks-Window.html#v:KeyHome"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "KeyInsert",
          "package": "GLUT",
          "signature": "KeyInsert",
          "source": "src/Graphics-UI-GLUT-Callbacks-Window.html#SpecialKey",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics UI GLUT Callbacks Window",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "KeyInsert",
          "package": "GLUT",
          "partial": "Key Insert",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Callbacks-Window.html#v:KeyInsert"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "KeyLeft",
          "package": "GLUT",
          "signature": "KeyLeft",
          "source": "src/Graphics-UI-GLUT-Callbacks-Window.html#SpecialKey",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics UI GLUT Callbacks Window",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "KeyLeft",
          "package": "GLUT",
          "partial": "Key Left",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Callbacks-Window.html#v:KeyLeft"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "KeyNumLock",
          "package": "GLUT",
          "signature": "KeyNumLock",
          "source": "src/Graphics-UI-GLUT-Callbacks-Window.html#SpecialKey",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics UI GLUT Callbacks Window",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "KeyNumLock",
          "package": "GLUT",
          "partial": "Key Num Lock",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Callbacks-Window.html#v:KeyNumLock"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "KeyPageDown",
          "package": "GLUT",
          "signature": "KeyPageDown",
          "source": "src/Graphics-UI-GLUT-Callbacks-Window.html#SpecialKey",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics UI GLUT Callbacks Window",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "KeyPageDown",
          "package": "GLUT",
          "partial": "Key Page Down",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Callbacks-Window.html#v:KeyPageDown"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "KeyPageUp",
          "package": "GLUT",
          "signature": "KeyPageUp",
          "source": "src/Graphics-UI-GLUT-Callbacks-Window.html#SpecialKey",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics UI GLUT Callbacks Window",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "KeyPageUp",
          "package": "GLUT",
          "partial": "Key Page Up",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Callbacks-Window.html#v:KeyPageUp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "KeyRight",
          "package": "GLUT",
          "signature": "KeyRight",
          "source": "src/Graphics-UI-GLUT-Callbacks-Window.html#SpecialKey",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics UI GLUT Callbacks Window",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "KeyRight",
          "package": "GLUT",
          "partial": "Key Right",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Callbacks-Window.html#v:KeyRight"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "KeyShiftL",
          "package": "GLUT",
          "signature": "KeyShiftL",
          "source": "src/Graphics-UI-GLUT-Callbacks-Window.html#SpecialKey",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics UI GLUT Callbacks Window",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "KeyShiftL",
          "package": "GLUT",
          "partial": "Key Shift",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Callbacks-Window.html#v:KeyShiftL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "KeyShiftR",
          "package": "GLUT",
          "signature": "KeyShiftR",
          "source": "src/Graphics-UI-GLUT-Callbacks-Window.html#SpecialKey",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics UI GLUT Callbacks Window",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "KeyShiftR",
          "package": "GLUT",
          "partial": "Key Shift",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Callbacks-Window.html#v:KeyShiftR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eYou should actually never encounter this value, it is\n just here as a safeguard against future changes in the\n native GLUT library.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "KeyUnknown",
          "package": "GLUT",
          "signature": "KeyUnknown Int",
          "source": "src/Graphics-UI-GLUT-Callbacks-Window.html#SpecialKey",
          "type": "function"
        },
        "index": {
          "description": "You should actually never encounter this value it is just here as safeguard against future changes in the native GLUT library",
          "hierarchy": "Graphics UI GLUT Callbacks Window",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "KeyUnknown",
          "package": "GLUT",
          "partial": "Key Unknown",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Callbacks-Window.html#v:KeyUnknown"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "KeyUp",
          "package": "GLUT",
          "signature": "KeyUp",
          "source": "src/Graphics-UI-GLUT-Callbacks-Window.html#SpecialKey",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics UI GLUT Callbacks Window",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "KeyUp",
          "package": "GLUT",
          "partial": "Key Up",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Callbacks-Window.html#v:KeyUp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "LeftButton",
          "package": "GLUT",
          "signature": "LeftButton",
          "source": "src/Graphics-UI-GLUT-Types.html#MouseButton",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics UI GLUT Callbacks Window",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "LeftButton",
          "package": "GLUT",
          "partial": "Left Button",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Callbacks-Window.html#v:LeftButton"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "MiddleButton",
          "package": "GLUT",
          "signature": "MiddleButton",
          "source": "src/Graphics-UI-GLUT-Types.html#MouseButton",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics UI GLUT Callbacks Window",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "MiddleButton",
          "package": "GLUT",
          "partial": "Middle Button",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Callbacks-Window.html#v:MiddleButton"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "Modifiers",
          "package": "GLUT",
          "signature": "Modifiers",
          "source": "src/Graphics-UI-GLUT-Callbacks-Window.html#Modifiers",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics UI GLUT Callbacks Window",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "Modifiers",
          "package": "GLUT",
          "partial": "Modifiers",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Callbacks-Window.html#v:Modifiers"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "MouseButton",
          "package": "GLUT",
          "signature": "MouseButton MouseButton",
          "source": "src/Graphics-UI-GLUT-Callbacks-Window.html#Key",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics UI GLUT Callbacks Window",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "MouseButton",
          "package": "GLUT",
          "partial": "Mouse Button",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Callbacks-Window.html#v:MouseButton"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eNo part of the \u003cem\u003ecurrent window\u003c/em\u003e is visible, i.e., until the\n   window's visibility changes, all further rendering to the\n   window is discarded.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "NotVisible",
          "package": "GLUT",
          "signature": "NotVisible",
          "source": "src/Graphics-UI-GLUT-Callbacks-Window.html#Visibility",
          "type": "function"
        },
        "index": {
          "description": "No part of the current window is visible i.e until the window visibility changes all further rendering to the window is discarded",
          "hierarchy": "Graphics UI GLUT Callbacks Window",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "NotVisible",
          "package": "GLUT",
          "partial": "Not Visible",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Callbacks-Window.html#v:NotVisible"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003cem\u003ecurrent window\u003c/em\u003e is partially obscured.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "PartiallyRetained",
          "package": "GLUT",
          "signature": "PartiallyRetained",
          "source": "src/Graphics-UI-GLUT-Callbacks-Window.html#WindowState",
          "type": "function"
        },
        "index": {
          "description": "The current window is partially obscured",
          "hierarchy": "Graphics UI GLUT Callbacks Window",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "PartiallyRetained",
          "package": "GLUT",
          "partial": "Partially Retained",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Callbacks-Window.html#v:PartiallyRetained"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "RightButton",
          "package": "GLUT",
          "signature": "RightButton",
          "source": "src/Graphics-UI-GLUT-Types.html#MouseButton",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics UI GLUT Callbacks Window",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "RightButton",
          "package": "GLUT",
          "partial": "Right Button",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Callbacks-Window.html#v:RightButton"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "SpaceballButton",
          "package": "GLUT",
          "signature": "SpaceballButton ButtonIndex KeyState",
          "source": "src/Graphics-UI-GLUT-Callbacks-Window.html#SpaceballInput",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics UI GLUT Callbacks Window",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "SpaceballButton",
          "package": "GLUT",
          "partial": "Spaceball Button",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Callbacks-Window.html#v:SpaceballButton"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "SpaceballMotion",
          "package": "GLUT",
          "signature": "SpaceballMotion SpaceballMotion SpaceballMotion SpaceballMotion",
          "source": "src/Graphics-UI-GLUT-Callbacks-Window.html#SpaceballInput",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics UI GLUT Callbacks Window",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "SpaceballMotion",
          "package": "GLUT",
          "partial": "Spaceball Motion",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Callbacks-Window.html#v:SpaceballMotion"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "SpaceballRotation",
          "package": "GLUT",
          "signature": "SpaceballRotation SpaceballRotation SpaceballRotation SpaceballRotation",
          "source": "src/Graphics-UI-GLUT-Callbacks-Window.html#SpaceballInput",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics UI GLUT Callbacks Window",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "SpaceballRotation",
          "package": "GLUT",
          "partial": "Spaceball Rotation",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Callbacks-Window.html#v:SpaceballRotation"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "SpecialKey",
          "package": "GLUT",
          "signature": "SpecialKey SpecialKey",
          "source": "src/Graphics-UI-GLUT-Callbacks-Window.html#Key",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics UI GLUT Callbacks Window",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "SpecialKey",
          "package": "GLUT",
          "partial": "Special Key",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Callbacks-Window.html#v:SpecialKey"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "TabletButton",
          "package": "GLUT",
          "signature": "TabletButton ButtonIndex KeyState",
          "source": "src/Graphics-UI-GLUT-Callbacks-Window.html#TabletInput",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics UI GLUT Callbacks Window",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "TabletButton",
          "package": "GLUT",
          "partial": "Tablet Button",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Callbacks-Window.html#v:TabletButton"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "TabletMotion",
          "package": "GLUT",
          "signature": "TabletMotion",
          "source": "src/Graphics-UI-GLUT-Callbacks-Window.html#TabletInput",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics UI GLUT Callbacks Window",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "TabletMotion",
          "package": "GLUT",
          "partial": "Tablet Motion",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Callbacks-Window.html#v:TabletMotion"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "TabletPosition",
          "package": "GLUT",
          "signature": "TabletPosition Int Int",
          "source": "src/Graphics-UI-GLUT-Callbacks-Window.html#TabletPosition",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics UI GLUT Callbacks Window",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "TabletPosition",
          "package": "GLUT",
          "partial": "Tablet Position",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Callbacks-Window.html#v:TabletPosition"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003cem\u003ecurrent window\u003c/em\u003e is unmapped.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "Unmapped",
          "package": "GLUT",
          "signature": "Unmapped",
          "source": "src/Graphics-UI-GLUT-Callbacks-Window.html#WindowState",
          "type": "function"
        },
        "index": {
          "description": "The current window is unmapped",
          "hierarchy": "Graphics UI GLUT Callbacks Window",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "Unmapped",
          "package": "GLUT",
          "partial": "Unmapped",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Callbacks-Window.html#v:Unmapped"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "Up",
          "package": "GLUT",
          "signature": "Up",
          "source": "src/Graphics-UI-GLUT-Callbacks-Window.html#KeyState",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics UI GLUT Callbacks Window",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "Up",
          "package": "GLUT",
          "partial": "Up",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Callbacks-Window.html#v:Up"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003cem\u003ecurrent window\u003c/em\u003e is totally or partially visible. GLUT\n   considers a window visible if any pixel of the window is\n   visible or any pixel of any descendant window is visible on\n   the screen.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "Visible",
          "package": "GLUT",
          "signature": "Visible",
          "source": "src/Graphics-UI-GLUT-Callbacks-Window.html#Visibility",
          "type": "function"
        },
        "index": {
          "description": "The current window is totally or partially visible GLUT considers window visible if any pixel of the window is visible or any pixel of any descendant window is visible on the screen",
          "hierarchy": "Graphics UI GLUT Callbacks Window",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "Visible",
          "package": "GLUT",
          "partial": "Visible",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Callbacks-Window.html#v:Visible"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "WheelDown",
          "package": "GLUT",
          "signature": "WheelDown",
          "source": "src/Graphics-UI-GLUT-Types.html#MouseButton",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics UI GLUT Callbacks Window",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "WheelDown",
          "package": "GLUT",
          "partial": "Wheel Down",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Callbacks-Window.html#v:WheelDown"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "WheelUp",
          "package": "GLUT",
          "signature": "WheelUp",
          "source": "src/Graphics-UI-GLUT-Types.html#MouseButton",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics UI GLUT Callbacks Window",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "WheelUp",
          "package": "GLUT",
          "partial": "Wheel Up",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Callbacks-Window.html#v:WheelUp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe mouse pointer has entered the \u003cem\u003ecurrent window.\u003c/em\u003e\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "WindowEntered",
          "package": "GLUT",
          "signature": "WindowEntered",
          "source": "src/Graphics-UI-GLUT-Callbacks-Window.html#Crossing",
          "type": "function"
        },
        "index": {
          "description": "The mouse pointer has entered the current window",
          "hierarchy": "Graphics UI GLUT Callbacks Window",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "WindowEntered",
          "package": "GLUT",
          "partial": "Window Entered",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Callbacks-Window.html#v:WindowEntered"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe mouse pointer has left the \u003cem\u003ecurrent window.\u003c/em\u003e\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "WindowLeft",
          "package": "GLUT",
          "signature": "WindowLeft",
          "source": "src/Graphics-UI-GLUT-Callbacks-Window.html#Crossing",
          "type": "function"
        },
        "index": {
          "description": "The mouse pointer has left the current window",
          "hierarchy": "Graphics UI GLUT Callbacks Window",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "WindowLeft",
          "package": "GLUT",
          "partial": "Window Left",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Callbacks-Window.html#v:WindowLeft"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "alt",
          "package": "GLUT",
          "signature": "KeyState",
          "source": "src/Graphics-UI-GLUT-Callbacks-Window.html#Modifiers",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics UI GLUT Callbacks Window",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "alt",
          "package": "GLUT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Callbacks-Window.html#v:alt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eControls the application status callback for the \u003cem\u003ecurrent window.\u003c/em\u003e\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "appStatusCallback",
          "package": "GLUT",
          "signature": "SettableStateVar (Maybe AppStatusCallback)",
          "source": "src/Graphics-UI-GLUT-Callbacks-Window.html#appStatusCallback",
          "type": "function"
        },
        "index": {
          "description": "Controls the application status callback for the current window",
          "hierarchy": "Graphics UI GLUT Callbacks Window",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "appStatusCallback",
          "package": "GLUT",
          "partial": "Status Callback",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Callbacks-Window.html#v:appStatusCallback"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eControls the window close callback for the \u003cem\u003ecurrent window\u003c/em\u003e.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "closeCallback",
          "package": "GLUT",
          "signature": "SettableStateVar (Maybe CloseCallback)",
          "source": "src/Graphics-UI-GLUT-Callbacks-Window.html#closeCallback",
          "type": "function"
        },
        "index": {
          "description": "Controls the window close callback for the current window",
          "hierarchy": "Graphics UI GLUT Callbacks Window",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "closeCallback",
          "package": "GLUT",
          "partial": "Callback",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Callbacks-Window.html#v:closeCallback"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eControls the mouse enter/leave callback for the \u003cem\u003ecurrent window.\u003c/em\u003e Note\n that some window systems may not generate accurate enter/leave callbacks.\n\u003c/p\u003e\u003cp\u003e\u003cem\u003eX Implementation Notes:\u003c/em\u003e An X implementation of GLUT should generate\n accurate enter/leave callbacks.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "crossingCallback",
          "package": "GLUT",
          "signature": "SettableStateVar (Maybe CrossingCallback)",
          "source": "src/Graphics-UI-GLUT-Callbacks-Window.html#crossingCallback",
          "type": "function"
        },
        "index": {
          "description": "Controls the mouse enter leave callback for the current window Note that some window systems may not generate accurate enter leave callbacks Implementation Notes An implementation of GLUT should generate accurate enter leave callbacks",
          "hierarchy": "Graphics UI GLUT Callbacks Window",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "crossingCallback",
          "package": "GLUT",
          "partial": "Callback",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Callbacks-Window.html#v:crossingCallback"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "ctrl",
          "package": "GLUT",
          "signature": "KeyState",
          "source": "src/Graphics-UI-GLUT-Callbacks-Window.html#Modifiers",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics UI GLUT Callbacks Window",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "ctrl",
          "package": "GLUT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Callbacks-Window.html#v:ctrl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eControls the dial & button box callback for the \u003cem\u003ecurrent window.\u003c/em\u003e The dial\n & button box button callback for a window is called when the window has dial\n & button box input focus (normally, when the mouse is in the window) and the\n user generates dial & button box button presses or dial changes. The number\n of available dial & button box buttons and dials can be determined with\n \u003ccode\u003e\u003ca\u003enumDialsAndButtons\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eRegistering a dial & button box callback when a dial & button box device is\n not available is ineffectual and not an error. In this case, no dial & button\n box button will be generated.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "dialAndButtonBoxCallback",
          "package": "GLUT",
          "signature": "SettableStateVar (Maybe DialAndButtonBoxCallback)",
          "source": "src/Graphics-UI-GLUT-Callbacks-Window.html#dialAndButtonBoxCallback",
          "type": "function"
        },
        "index": {
          "description": "Controls the dial button box callback for the current window The dial button box button callback for window is called when the window has dial button box input focus normally when the mouse is in the window and the user generates dial button box button presses or dial changes The number of available dial button box buttons and dials can be determined with numDialsAndButtons Registering dial button box callback when dial button box device is not available is ineffectual and not an error In this case no dial button box button will be generated",
          "hierarchy": "Graphics UI GLUT Callbacks Window",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "dialAndButtonBoxCallback",
          "package": "GLUT",
          "partial": "And Button Box Callback",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Callbacks-Window.html#v:dialAndButtonBoxCallback"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eControls the display callback for the \u003cem\u003ecurrent window.\u003c/em\u003e When GLUT determines\n that the normal plane for the window needs to be redisplayed, the display\n callback for the window is called. Before the callback, the \u003cem\u003ecurrent window\u003c/em\u003e\n is set to the window needing to be redisplayed and (if no overlay display\n callback is registered) the \u003cem\u003elayer in use\u003c/em\u003e is set to the normal plane. The\n entire normal plane region should be redisplayed in response to the callback\n (this includes ancillary buffers if your program depends on their state).\n\u003c/p\u003e\u003cp\u003eGLUT determines when the display callback should be triggered based on the\n window's redisplay state. The redisplay state for a window can be either set\n explicitly by calling \u003ccode\u003e\u003ca\u003epostRedisplay\u003c/a\u003e\u003c/code\u003e or implicitly\n as the result of window damage reported by the window system. Multiple posted\n redisplays for a window are coalesced by GLUT to minimize the number of\n display callbacks called.\n\u003c/p\u003e\u003cp\u003eWhen an overlay is established for a window, but there is no overlay display\n callback registered, the display callback is used for redisplaying both the\n overlay and normal plane (that is, it will be called if either the redisplay\n state or overlay redisplay state is set). In this case, the \u003cem\u003elayer in use\u003c/em\u003e is\n not implicitly changed on entry to the display callback.\n\u003c/p\u003e\u003cp\u003eSee \u003ccode\u003e\u003ca\u003eoverlayDisplayCallback\u003c/a\u003e\u003c/code\u003e to understand how distinct callbacks for the\n overlay and normal plane of a window may be established.\n\u003c/p\u003e\u003cp\u003eWhen a window is created, no display callback exists for the window. It is\n the responsibility of the programmer to install a display callback for the\n window before the window is shown. A display callback must be registered for\n any window that is shown. If a window becomes displayed without a display\n callback being registered, a fatal error occurs. There is no way to\n \"deregister\" a display callback (though another callback routine can always\n be registered).\n\u003c/p\u003e\u003cp\u003eUpon return from the display callback, the normal damaged state of the window\n (see \u003ccode\u003e\u003ca\u003edamaged\u003c/a\u003e\u003c/code\u003e) is cleared. If there is no overlay\n display callback registered the overlay damaged state of the window (see\n \u003ccode\u003e\u003ca\u003edamaged\u003c/a\u003e\u003c/code\u003e) is also cleared.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "displayCallback",
          "package": "GLUT",
          "signature": "SettableStateVar DisplayCallback",
          "source": "src/Graphics-UI-GLUT-Callbacks-Window.html#displayCallback",
          "type": "function"
        },
        "index": {
          "description": "Controls the display callback for the current window When GLUT determines that the normal plane for the window needs to be redisplayed the display callback for the window is called Before the callback the current window is set to the window needing to be redisplayed and if no overlay display callback is registered the layer in use is set to the normal plane The entire normal plane region should be redisplayed in response to the callback this includes ancillary buffers if your program depends on their state GLUT determines when the display callback should be triggered based on the window redisplay state The redisplay state for window can be either set explicitly by calling postRedisplay or implicitly as the result of window damage reported by the window system Multiple posted redisplays for window are coalesced by GLUT to minimize the number of display callbacks called When an overlay is established for window but there is no overlay display callback registered the display callback is used for redisplaying both the overlay and normal plane that is it will be called if either the redisplay state or overlay redisplay state is set In this case the layer in use is not implicitly changed on entry to the display callback See overlayDisplayCallback to understand how distinct callbacks for the overlay and normal plane of window may be established When window is created no display callback exists for the window It is the responsibility of the programmer to install display callback for the window before the window is shown display callback must be registered for any window that is shown If window becomes displayed without display callback being registered fatal error occurs There is no way to deregister display callback though another callback routine can always be registered Upon return from the display callback the normal damaged state of the window see damaged is cleared If there is no overlay display callback registered the overlay damaged state of the window see damaged is also cleared",
          "hierarchy": "Graphics UI GLUT Callbacks Window",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "displayCallback",
          "package": "GLUT",
          "partial": "Callback",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Callbacks-Window.html#v:displayCallback"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e(\u003cem\u003efreeglut only\u003c/em\u003e) Controls the initialize context callback for the /current\n window/.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "initContextCallback",
          "package": "GLUT",
          "signature": "SettableStateVar (Maybe InitContextCallback)",
          "source": "src/Graphics-UI-GLUT-Callbacks-Window.html#initContextCallback",
          "type": "function"
        },
        "index": {
          "description": "freeglut only Controls the initialize context callback for the current window",
          "hierarchy": "Graphics UI GLUT Callbacks Window",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "initContextCallback",
          "package": "GLUT",
          "partial": "Context Callback",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Callbacks-Window.html#v:initContextCallback"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "joystickButtonA",
          "package": "GLUT",
          "signature": "KeyState",
          "source": "src/Graphics-UI-GLUT-Callbacks-Window.html#JoystickButtons",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics UI GLUT Callbacks Window",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "joystickButtonA",
          "package": "GLUT",
          "partial": "Button",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Callbacks-Window.html#v:joystickButtonA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "joystickButtonB",
          "package": "GLUT",
          "signature": "KeyState",
          "source": "src/Graphics-UI-GLUT-Callbacks-Window.html#JoystickButtons",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics UI GLUT Callbacks Window",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "joystickButtonB",
          "package": "GLUT",
          "partial": "Button",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Callbacks-Window.html#v:joystickButtonB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "joystickButtonC",
          "package": "GLUT",
          "signature": "KeyState",
          "source": "src/Graphics-UI-GLUT-Callbacks-Window.html#JoystickButtons",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics UI GLUT Callbacks Window",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "joystickButtonC",
          "package": "GLUT",
          "partial": "Button",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Callbacks-Window.html#v:joystickButtonC"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "joystickButtonD",
          "package": "GLUT",
          "signature": "KeyState",
          "source": "src/Graphics-UI-GLUT-Callbacks-Window.html#JoystickButtons",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics UI GLUT Callbacks Window",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "joystickButtonD",
          "package": "GLUT",
          "partial": "Button",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Callbacks-Window.html#v:joystickButtonD"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eControls the joystick callback for the \u003cem\u003ecurrent window.\u003c/em\u003e The joystick\n callback is called either due to polling of the joystick at the uniform timer\n interval specified (if \u003e 0) or in response to an explicit call of\n \u003ccode\u003e\u003ca\u003eforceJoystickCallback\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003e\u003cem\u003eX Implementation Notes:\u003c/em\u003e Currently GLUT has no joystick support for X11.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "joystickCallback",
          "package": "GLUT",
          "signature": "SettableStateVar (Maybe (JoystickCallback, PollRate))",
          "source": "src/Graphics-UI-GLUT-Callbacks-Window.html#joystickCallback",
          "type": "function"
        },
        "index": {
          "description": "Controls the joystick callback for the current window The joystick callback is called either due to polling of the joystick at the uniform timer interval specified if or in response to an explicit call of forceJoystickCallback Implementation Notes Currently GLUT has no joystick support for X11",
          "hierarchy": "Graphics UI GLUT Callbacks Window",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "joystickCallback",
          "normalized": "SettableStateVar(Maybe(JoystickCallback,PollRate))",
          "package": "GLUT",
          "partial": "Callback",
          "signature": "SettableStateVar(Maybe(JoystickCallback,PollRate))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Callbacks-Window.html#v:joystickCallback"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eControls the keyboard callback for the \u003cem\u003ecurrent window\u003c/em\u003e. This is\n activated only when a key is pressed.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "keyboardCallback",
          "package": "GLUT",
          "signature": "SettableStateVar (Maybe KeyboardCallback)",
          "source": "src/Graphics-UI-GLUT-Callbacks-Window.html#keyboardCallback",
          "type": "function"
        },
        "index": {
          "description": "Controls the keyboard callback for the current window This is activated only when key is pressed",
          "hierarchy": "Graphics UI GLUT Callbacks Window",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "keyboardCallback",
          "package": "GLUT",
          "partial": "Callback",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Callbacks-Window.html#v:keyboardCallback"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eControls the keyboard/mouse callback for the \u003cem\u003ecurrent window.\u003c/em\u003e The\n keyboard/mouse callback for a window is called when the state of a key or\n mouse button changes. The callback parameters indicate the new state of the\n key/button, the state of the keyboard modifiers, and the mouse location in\n window relative coordinates.\n\u003c/p\u003e\u003cp\u003eNote that this is a convenience function that should not ordinarily be used\n in conjunction with \u003ccode\u003e\u003ca\u003ekeyboardCallback\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003ekeyboardUpCallback\u003c/a\u003e\u003c/code\u003e,\n \u003ccode\u003e\u003ca\u003especialCallback\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003especialUpCallback\u003c/a\u003e\u003c/code\u003e, or \u003ccode\u003e\u003ca\u003emouseCallback\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "keyboardMouseCallback",
          "package": "GLUT",
          "signature": "SettableStateVar (Maybe KeyboardMouseCallback)",
          "source": "src/Graphics-UI-GLUT-Callbacks-Window.html#keyboardMouseCallback",
          "type": "function"
        },
        "index": {
          "description": "Controls the keyboard mouse callback for the current window The keyboard mouse callback for window is called when the state of key or mouse button changes The callback parameters indicate the new state of the key button the state of the keyboard modifiers and the mouse location in window relative coordinates Note that this is convenience function that should not ordinarily be used in conjunction with keyboardCallback keyboardUpCallback specialCallback specialUpCallback or mouseCallback",
          "hierarchy": "Graphics UI GLUT Callbacks Window",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "keyboardMouseCallback",
          "package": "GLUT",
          "partial": "Mouse Callback",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Callbacks-Window.html#v:keyboardMouseCallback"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eControls the keyboard callback for the \u003cem\u003ecurrent window\u003c/em\u003e. This is\n activated only when a key is released.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "keyboardUpCallback",
          "package": "GLUT",
          "signature": "SettableStateVar (Maybe KeyboardCallback)",
          "source": "src/Graphics-UI-GLUT-Callbacks-Window.html#keyboardUpCallback",
          "type": "function"
        },
        "index": {
          "description": "Controls the keyboard callback for the current window This is activated only when key is released",
          "hierarchy": "Graphics UI GLUT Callbacks Window",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "keyboardUpCallback",
          "package": "GLUT",
          "partial": "Up Callback",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Callbacks-Window.html#v:keyboardUpCallback"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eControls the motion callback for the \u003cem\u003ecurrent window.\u003c/em\u003e The motion callback\n for a window is called when the mouse moves within the window while one or\n more mouse buttons are pressed. The callback parameter indicates the mouse\n location in window relative coordinates.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "motionCallback",
          "package": "GLUT",
          "signature": "SettableStateVar (Maybe MotionCallback)",
          "source": "src/Graphics-UI-GLUT-Callbacks-Window.html#motionCallback",
          "type": "function"
        },
        "index": {
          "description": "Controls the motion callback for the current window The motion callback for window is called when the mouse moves within the window while one or more mouse buttons are pressed The callback parameter indicates the mouse location in window relative coordinates",
          "hierarchy": "Graphics UI GLUT Callbacks Window",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "motionCallback",
          "package": "GLUT",
          "partial": "Callback",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Callbacks-Window.html#v:motionCallback"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eControls the mouse callback for the \u003cem\u003ecurrent window\u003c/em\u003e.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "mouseCallback",
          "package": "GLUT",
          "signature": "SettableStateVar (Maybe MouseCallback)",
          "source": "src/Graphics-UI-GLUT-Callbacks-Window.html#mouseCallback",
          "type": "function"
        },
        "index": {
          "description": "Controls the mouse callback for the current window",
          "hierarchy": "Graphics UI GLUT Callbacks Window",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "mouseCallback",
          "package": "GLUT",
          "partial": "Callback",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Callbacks-Window.html#v:mouseCallback"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e(\u003cem\u003efreeglut only\u003c/em\u003e) Controls the mouse wheel callback for the\n \u003cem\u003ecurrent window.\u003c/em\u003e The mouse wheel callback for a window is called when a\n mouse wheel is used and the wheel number is greater than or equal to\n \u003ccode\u003e\u003ca\u003enumMouseButtons\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "mouseWheelCallback",
          "package": "GLUT",
          "signature": "SettableStateVar (Maybe MouseWheelCallback)",
          "source": "src/Graphics-UI-GLUT-Callbacks-Window.html#mouseWheelCallback",
          "type": "function"
        },
        "index": {
          "description": "freeglut only Controls the mouse wheel callback for the current window The mouse wheel callback for window is called when mouse wheel is used and the wheel number is greater than or equal to numMouseButtons",
          "hierarchy": "Graphics UI GLUT Callbacks Window",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "mouseWheelCallback",
          "package": "GLUT",
          "partial": "Wheel Callback",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Callbacks-Window.html#v:mouseWheelCallback"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e(\u003cem\u003efreeglut only\u003c/em\u003e) A multi-touch variant of \u003ccode\u003e\u003ca\u003ecrossingCallback\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "multiCrossingCallback",
          "package": "GLUT",
          "signature": "SettableStateVar (Maybe MultiCrossingCallback)",
          "source": "src/Graphics-UI-GLUT-Callbacks-Window.html#multiCrossingCallback",
          "type": "function"
        },
        "index": {
          "description": "freeglut only multi-touch variant of crossingCallback",
          "hierarchy": "Graphics UI GLUT Callbacks Window",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "multiCrossingCallback",
          "package": "GLUT",
          "partial": "Crossing Callback",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Callbacks-Window.html#v:multiCrossingCallback"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e(\u003cem\u003efreeglut only\u003c/em\u003e) A multi-touch variant of \u003ccode\u003e\u003ca\u003emotionCallback\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "multiMotionCallback",
          "package": "GLUT",
          "signature": "SettableStateVar (Maybe MultiMotionCallback)",
          "source": "src/Graphics-UI-GLUT-Callbacks-Window.html#multiMotionCallback",
          "type": "function"
        },
        "index": {
          "description": "freeglut only multi-touch variant of motionCallback",
          "hierarchy": "Graphics UI GLUT Callbacks Window",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "multiMotionCallback",
          "package": "GLUT",
          "partial": "Motion Callback",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Callbacks-Window.html#v:multiMotionCallback"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e(\u003cem\u003efreeglut only\u003c/em\u003e) A multi-touch variant of \u003ccode\u003e\u003ca\u003emouseCallback\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "multiMouseCallback",
          "package": "GLUT",
          "signature": "SettableStateVar (Maybe MultiMouseCallback)",
          "source": "src/Graphics-UI-GLUT-Callbacks-Window.html#multiMouseCallback",
          "type": "function"
        },
        "index": {
          "description": "freeglut only multi-touch variant of mouseCallback",
          "hierarchy": "Graphics UI GLUT Callbacks Window",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "multiMouseCallback",
          "package": "GLUT",
          "partial": "Mouse Callback",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Callbacks-Window.html#v:multiMouseCallback"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e(\u003cem\u003efreeglut only\u003c/em\u003e) A multi-touch variant of \u003ccode\u003e\u003ca\u003epassiveMotionCallback\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "multiPassiveMotionCallback",
          "package": "GLUT",
          "signature": "SettableStateVar (Maybe MultiMotionCallback)",
          "source": "src/Graphics-UI-GLUT-Callbacks-Window.html#multiPassiveMotionCallback",
          "type": "function"
        },
        "index": {
          "description": "freeglut only multi-touch variant of passiveMotionCallback",
          "hierarchy": "Graphics UI GLUT Callbacks Window",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "multiPassiveMotionCallback",
          "package": "GLUT",
          "partial": "Passive Motion Callback",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Callbacks-Window.html#v:multiPassiveMotionCallback"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eControls the overlay display callback for the \u003cem\u003ecurrent window.\u003c/em\u003e The overlay\n display callback is functionally the same as the window's display callback\n except that the overlay display callback is used to redisplay the window's\n overlay.\n\u003c/p\u003e\u003cp\u003eWhen GLUT determines that the overlay plane for the window needs to be\n redisplayed, the overlay display callback for the window is called. Before\n the callback, the \u003cem\u003ecurrent window\u003c/em\u003e is set to the window needing to be\n redisplayed and the \u003cem\u003elayer in use\u003c/em\u003e is set to the overlay. The entire overlay\n region should be redisplayed in response to the callback (this includes\n ancillary buffers if your program depends on their state).\n\u003c/p\u003e\u003cp\u003eGLUT determines when the overlay display callback should be triggered based\n on the window's overlay redisplay state. The overlay redisplay state for a\n window can be either set explicitly by calling\n \u003ccode\u003e\u003ca\u003epostOverlayRedisplay\u003c/a\u003e\u003c/code\u003e or implicitly as the result\n of window damage reported by the window system. Multiple posted overlay\n redisplays for a window are coalesced by GLUT to minimize the number of\n overlay display callbacks called.\n\u003c/p\u003e\u003cp\u003eUpon return from the overlay display callback, the overlay damaged state of\n the window (see \u003ccode\u003e\u003ca\u003edamaged\u003c/a\u003e\u003c/code\u003e) is cleared.\n\u003c/p\u003e\u003cp\u003eInitially there is no overlay display callback registered when an overlay is\n established. See \u003ccode\u003e\u003ca\u003edisplayCallback\u003c/a\u003e\u003c/code\u003e to understand how the display callback\n alone is used if an overlay display callback is not registered.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "overlayDisplayCallback",
          "package": "GLUT",
          "signature": "SettableStateVar (Maybe DisplayCallback)",
          "source": "src/Graphics-UI-GLUT-Callbacks-Window.html#overlayDisplayCallback",
          "type": "function"
        },
        "index": {
          "description": "Controls the overlay display callback for the current window The overlay display callback is functionally the same as the window display callback except that the overlay display callback is used to redisplay the window overlay When GLUT determines that the overlay plane for the window needs to be redisplayed the overlay display callback for the window is called Before the callback the current window is set to the window needing to be redisplayed and the layer in use is set to the overlay The entire overlay region should be redisplayed in response to the callback this includes ancillary buffers if your program depends on their state GLUT determines when the overlay display callback should be triggered based on the window overlay redisplay state The overlay redisplay state for window can be either set explicitly by calling postOverlayRedisplay or implicitly as the result of window damage reported by the window system Multiple posted overlay redisplays for window are coalesced by GLUT to minimize the number of overlay display callbacks called Upon return from the overlay display callback the overlay damaged state of the window see damaged is cleared Initially there is no overlay display callback registered when an overlay is established See displayCallback to understand how the display callback alone is used if an overlay display callback is not registered",
          "hierarchy": "Graphics UI GLUT Callbacks Window",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "overlayDisplayCallback",
          "package": "GLUT",
          "partial": "Display Callback",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Callbacks-Window.html#v:overlayDisplayCallback"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eControls the passive motion callback for the \u003cem\u003ecurrent window.\u003c/em\u003e The passive\n motion callback for a window is called when the mouse moves within the window\n while \u003cem\u003eno\u003c/em\u003e mouse buttons are pressed. The callback parameter indicates the\n mouse location in window relative coordinates.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "passiveMotionCallback",
          "package": "GLUT",
          "signature": "SettableStateVar (Maybe MotionCallback)",
          "source": "src/Graphics-UI-GLUT-Callbacks-Window.html#passiveMotionCallback",
          "type": "function"
        },
        "index": {
          "description": "Controls the passive motion callback for the current window The passive motion callback for window is called when the mouse moves within the window while no mouse buttons are pressed The callback parameter indicates the mouse location in window relative coordinates",
          "hierarchy": "Graphics UI GLUT Callbacks Window",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "passiveMotionCallback",
          "package": "GLUT",
          "partial": "Motion Callback",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Callbacks-Window.html#v:passiveMotionCallback"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e(\u003cem\u003efreeglut only\u003c/em\u003e) Controls the position callback for the \u003cem\u003ecurrent window.\u003c/em\u003e\n The position callback for a window is called when the position of a window\n changes.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "positionCallback",
          "package": "GLUT",
          "signature": "SettableStateVar (Maybe PositionCallback)",
          "source": "src/Graphics-UI-GLUT-Callbacks-Window.html#positionCallback",
          "type": "function"
        },
        "index": {
          "description": "freeglut only Controls the position callback for the current window The position callback for window is called when the position of window changes",
          "hierarchy": "Graphics UI GLUT Callbacks Window",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "positionCallback",
          "package": "GLUT",
          "partial": "Callback",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Callbacks-Window.html#v:positionCallback"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eControls the reshape callback for the \u003cem\u003ecurrent window.\u003c/em\u003e The reshape callback\n is triggered when a window is reshaped. A reshape callback is also triggered\n immediately before a window's first display callback after a window is\n created or whenever an overlay for the window is established. The parameter\n of the callback specifies the new window size in pixels. Before the callback,\n the \u003cem\u003ecurrent window\u003c/em\u003e is set to the window that has been reshaped.\n\u003c/p\u003e\u003cp\u003eIf a reshape callback is not registered for a window or \u003ccode\u003e\u003ca\u003ereshapeCallback\u003c/a\u003e\u003c/code\u003e is\n set to \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e (to deregister a previously registered callback), the\n default reshape callback is used. This default callback will simply call\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003eviewport\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003ePosition\u003c/a\u003e\u003c/code\u003e 0 0) (\u003ccode\u003e\u003ca\u003eSize\u003c/a\u003e\u003c/code\u003e \u003cem\u003ewidth\u003c/em\u003e \u003cem\u003eheight\u003c/em\u003e)\n\u003c/pre\u003e\u003cp\u003eon the normal plane (and on the overlay if one exists).\n\u003c/p\u003e\u003cp\u003eIf an overlay is established for the window, a single reshape callback is\n generated. It is the callback's responsibility to update both the normal\n plane and overlay for the window (changing the layer in use as necessary).\n\u003c/p\u003e\u003cp\u003eWhen a top-level window is reshaped, subwindows are not reshaped. It is up to\n the GLUT program to manage the size and positions of subwindows within a\n top-level window. Still, reshape callbacks will be triggered for subwindows\n when their size is changed using \u003ccode\u003e\u003ca\u003ewindowSize\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "reshapeCallback",
          "package": "GLUT",
          "signature": "SettableStateVar (Maybe ReshapeCallback)",
          "source": "src/Graphics-UI-GLUT-Callbacks-Window.html#reshapeCallback",
          "type": "function"
        },
        "index": {
          "description": "Controls the reshape callback for the current window The reshape callback is triggered when window is reshaped reshape callback is also triggered immediately before window first display callback after window is created or whenever an overlay for the window is established The parameter of the callback specifies the new window size in pixels Before the callback the current window is set to the window that has been reshaped If reshape callback is not registered for window or reshapeCallback is set to Nothing to deregister previously registered callback the default reshape callback is used This default callback will simply call viewport Position Size width height on the normal plane and on the overlay if one exists If an overlay is established for the window single reshape callback is generated It is the callback responsibility to update both the normal plane and overlay for the window changing the layer in use as necessary When top-level window is reshaped subwindows are not reshaped It is up to the GLUT program to manage the size and positions of subwindows within top-level window Still reshape callbacks will be triggered for subwindows when their size is changed using windowSize",
          "hierarchy": "Graphics UI GLUT Callbacks Window",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "reshapeCallback",
          "package": "GLUT",
          "partial": "Callback",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Callbacks-Window.html#v:reshapeCallback"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "shift",
          "package": "GLUT",
          "signature": "KeyState",
          "source": "src/Graphics-UI-GLUT-Callbacks-Window.html#Modifiers",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics UI GLUT Callbacks Window",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "shift",
          "package": "GLUT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Callbacks-Window.html#v:shift"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eControls the Spaceball callback for the \u003cem\u003ecurrent window.\u003c/em\u003e The Spaceball\n callback for a window is called when the window has Spaceball input focus\n (normally, when the mouse is in the window) and the user generates Spaceball\n translations, rotations, or button presses. The number of available Spaceball\n buttons can be determined with \u003ccode\u003e\u003ca\u003enumSpaceballButtons\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eRegistering a Spaceball callback when a Spaceball device is not available has\n no effect and is not an error. In this case, no Spaceball callbacks will be\n generated.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "spaceballCallback",
          "package": "GLUT",
          "signature": "SettableStateVar (Maybe SpaceballCallback)",
          "source": "src/Graphics-UI-GLUT-Callbacks-Window.html#spaceballCallback",
          "type": "function"
        },
        "index": {
          "description": "Controls the Spaceball callback for the current window The Spaceball callback for window is called when the window has Spaceball input focus normally when the mouse is in the window and the user generates Spaceball translations rotations or button presses The number of available Spaceball buttons can be determined with numSpaceballButtons Registering Spaceball callback when Spaceball device is not available has no effect and is not an error In this case no Spaceball callbacks will be generated",
          "hierarchy": "Graphics UI GLUT Callbacks Window",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "spaceballCallback",
          "package": "GLUT",
          "partial": "Callback",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Callbacks-Window.html#v:spaceballCallback"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eControls the special key callback for the \u003cem\u003ecurrent window\u003c/em\u003e. This is\n activated only when a special key is pressed.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "specialCallback",
          "package": "GLUT",
          "signature": "SettableStateVar (Maybe SpecialCallback)",
          "source": "src/Graphics-UI-GLUT-Callbacks-Window.html#specialCallback",
          "type": "function"
        },
        "index": {
          "description": "Controls the special key callback for the current window This is activated only when special key is pressed",
          "hierarchy": "Graphics UI GLUT Callbacks Window",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "specialCallback",
          "package": "GLUT",
          "partial": "Callback",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Callbacks-Window.html#v:specialCallback"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eControls the special key callback for the \u003cem\u003ecurrent window\u003c/em\u003e. This is\n activated only when a special key is released.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "specialUpCallback",
          "package": "GLUT",
          "signature": "SettableStateVar (Maybe SpecialCallback)",
          "source": "src/Graphics-UI-GLUT-Callbacks-Window.html#specialUpCallback",
          "type": "function"
        },
        "index": {
          "description": "Controls the special key callback for the current window This is activated only when special key is released",
          "hierarchy": "Graphics UI GLUT Callbacks Window",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "specialUpCallback",
          "package": "GLUT",
          "partial": "Up Callback",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Callbacks-Window.html#v:specialUpCallback"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eControls the tablet callback for the \u003cem\u003ecurrent window.\u003c/em\u003e The tablet callback\n for a window is called when the window has tablet input focus (normally, when\n the mouse is in the window) and the user generates tablet motion or button\n presses. The number of available tablet buttons can be determined with\n \u003ccode\u003e\u003ca\u003enumTabletButtons\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eRegistering a tablet callback when a tablet device is not available is\n ineffectual and not an error. In this case, no tablet callbacks will be\n generated.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "tabletCallback",
          "package": "GLUT",
          "signature": "SettableStateVar (Maybe TabletCallback)",
          "source": "src/Graphics-UI-GLUT-Callbacks-Window.html#tabletCallback",
          "type": "function"
        },
        "index": {
          "description": "Controls the tablet callback for the current window The tablet callback for window is called when the window has tablet input focus normally when the mouse is in the window and the user generates tablet motion or button presses The number of available tablet buttons can be determined with numTabletButtons Registering tablet callback when tablet device is not available is ineffectual and not an error In this case no tablet callbacks will be generated",
          "hierarchy": "Graphics UI GLUT Callbacks Window",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "tabletCallback",
          "package": "GLUT",
          "partial": "Callback",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Callbacks-Window.html#v:tabletCallback"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eControls the visibility callback for the \u003cem\u003ecurrent window.\u003c/em\u003e The visibility\n callback for a window is called when the visibility of a window changes.\n\u003c/p\u003e\u003cp\u003eIf the visibility callback for a window is disabled and later re-enabled, the\n visibility status of the window is undefined; any change in window visibility\n will be reported, that is if you disable a visibility callback and re-enable\n the callback, you are guaranteed the next visibility change will be reported.\n\u003c/p\u003e\u003cp\u003eNote that you can either use \u003ccode\u003e\u003ca\u003evisibilityCallback\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003ewindowStateCallback\u003c/a\u003e\u003c/code\u003e,\n but not both, because the former is implemented via the latter.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "visibilityCallback",
          "package": "GLUT",
          "signature": "SettableStateVar (Maybe VisibilityCallback)",
          "source": "src/Graphics-UI-GLUT-Callbacks-Window.html#visibilityCallback",
          "type": "function"
        },
        "index": {
          "description": "Controls the visibility callback for the current window The visibility callback for window is called when the visibility of window changes If the visibility callback for window is disabled and later re-enabled the visibility status of the window is undefined any change in window visibility will be reported that is if you disable visibility callback and re-enable the callback you are guaranteed the next visibility change will be reported Note that you can either use visibilityCallback or windowStateCallback but not both because the former is implemented via the latter",
          "hierarchy": "Graphics UI GLUT Callbacks Window",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "visibilityCallback",
          "package": "GLUT",
          "partial": "Callback",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Callbacks-Window.html#v:visibilityCallback"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eControls the window state callback for the\n \u003cem\u003ecurrent window.\u003c/em\u003e The window state callback for a window is called when the\n window state of a window changes.\n\u003c/p\u003e\u003cp\u003eIf the window state callback for a window is disabled and later re-enabled,\n the window state state of the window is undefined; any change in the window\n state will be reported, that is if you disable a window state callback and\n re-enable the callback, you are guaranteed the next window state change will\n be reported.\n\u003c/p\u003e\u003cp\u003eNote that you can either use \u003ccode\u003e\u003ca\u003evisibilityCallback\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003ewindowStateCallback\u003c/a\u003e\u003c/code\u003e,\n but not both, because the former is implemented via the latter.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "windowStateCallback",
          "package": "GLUT",
          "signature": "SettableStateVar (Maybe WindowStateCallback)",
          "source": "src/Graphics-UI-GLUT-Callbacks-Window.html#windowStateCallback",
          "type": "function"
        },
        "index": {
          "description": "Controls the window state callback for the current window The window state callback for window is called when the window state of window changes If the window state callback for window is disabled and later re-enabled the window state state of the window is undefined any change in the window state will be reported that is if you disable window state callback and re-enable the callback you are guaranteed the next window state change will be reported Note that you can either use visibilityCallback or windowStateCallback but not both because the former is implemented via the latter",
          "hierarchy": "Graphics UI GLUT Callbacks Window",
          "module": "Graphics.UI.GLUT.Callbacks.Window",
          "name": "windowStateCallback",
          "package": "GLUT",
          "partial": "State Callback",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Callbacks-Window.html#v:windowStateCallback"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eGLUT supports a number of callbacks to respond to events. There are three\n types of callbacks: window, menu, and global. Window callbacks indicate when\n to redisplay or reshape a window, when the visibility of the window changes,\n and when input is available for the window. Menu callbacks are described in\n \u003ca\u003eGraphics.UI.GLUT.Menu\u003c/a\u003e. The global callbacks manage the passing of time and\n menu usage. The calling order of callbacks between different windows is\n undefined.\n\u003c/p\u003e\u003cp\u003eCallbacks for input events should be delivered to the window the event occurs\n in. Events should not propagate to parent windows.\n\u003c/p\u003e\u003cp\u003eA callback of type \u003ccode\u003eFoo\u003c/code\u003e can registered by setting \u003ccode\u003efooCallback\u003c/code\u003e to \u003ccode\u003e\u003ca\u003eJust\u003c/a\u003e\u003c/code\u003e\n the callback. Almost all callbacks can be de-registered by setting\n the corresponding \u003ccode\u003efooCallback\u003c/code\u003e to \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e, the only exceptions being\n \u003ccode\u003e\u003ca\u003eDisplayCallback\u003c/a\u003e\u003c/code\u003e (can only be\n re-registered) and \u003ccode\u003e\u003ca\u003eTimerCallback\u003c/a\u003e\u003c/code\u003e (can't\n be unregistered).\n\u003c/p\u003e\u003cp\u003e\u003cem\u003eX Implementation Notes:\u003c/em\u003e The X GLUT implementation uses the X Input\n extension to support sophisticated input devices: Spaceball, dial & button\n box, and digitizing tablet. Because the X Input extension  does not mandate\n how particular types of devices are advertised through the extension, it is\n possible GLUT for X may not correctly support input devices that would\n otherwise be of the correct type. The X GLUT implementation will support the\n Silicon Graphics Spaceball, dial & button box, and digitizing tablet as\n advertised through the X Input extension.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Graphics.UI.GLUT.Callbacks",
          "name": "Callbacks",
          "package": "GLUT",
          "source": "src/Graphics-UI-GLUT-Callbacks.html",
          "type": "module"
        },
        "index": {
          "description": "GLUT supports number of callbacks to respond to events There are three types of callbacks window menu and global Window callbacks indicate when to redisplay or reshape window when the visibility of the window changes and when input is available for the window Menu callbacks are described in Graphics.UI.GLUT.Menu The global callbacks manage the passing of time and menu usage The calling order of callbacks between different windows is undefined Callbacks for input events should be delivered to the window the event occurs in Events should not propagate to parent windows callback of type Foo can registered by setting fooCallback to Just the callback Almost all callbacks can be de-registered by setting the corresponding fooCallback to Nothing the only exceptions being DisplayCallback can only be re-registered and TimerCallback can be unregistered Implementation Notes The GLUT implementation uses the Input extension to support sophisticated input devices Spaceball dial button box and digitizing tablet Because the Input extension does not mandate how particular types of devices are advertised through the extension it is possible GLUT for may not correctly support input devices that would otherwise be of the correct type The GLUT implementation will support the Silicon Graphics Spaceball dial button box and digitizing tablet as advertised through the Input extension",
          "hierarchy": "Graphics UI GLUT Callbacks",
          "module": "Graphics.UI.GLUT.Callbacks",
          "name": "Callbacks",
          "package": "GLUT",
          "partial": "Callbacks",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Callbacks.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eOpenGL supports both RGBA and color index rendering. The RGBA mode is\n generally preferable to color index because more OpenGL rendering\n capabilities are available and color index mode requires the loading of\n colormap entries.\n\u003c/p\u003e\u003cp\u003eThe GLUT color index state variables are used to read and write entries in a\n window's color index colormap. Every GLUT color index window has its own\n logical color index colormap. The size of a window's colormap can be\n determined by reading \u003ccode\u003e\u003ca\u003enumColorMapEntries\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eGLUT color index windows within a program can attempt to share colormap\n resources by copying a single color index colormap to multiple windows using\n \u003ccode\u003e\u003ca\u003ecopyColormap\u003c/a\u003e\u003c/code\u003e. If possible GLUT will attempt to share the actual colormap.\n While copying colormaps using \u003ccode\u003e\u003ca\u003ecopyColormap\u003c/a\u003e\u003c/code\u003e can potentially allow sharing of\n physical colormap resources, logically each window has its own colormap. So\n changing a copied colormap of a window will force the duplication of the\n colormap. For this reason, color index programs should generally load a\n single color index colormap, copy it to all color index windows within the\n program, and then not modify any colormap cells.\n\u003c/p\u003e\u003cp\u003eUse of multiple colormaps is likely to result in colormap installation\n problems where some windows are displayed with an incorrect colormap due to\n limitations on colormap resources.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Graphics.UI.GLUT.Colormap",
          "name": "Colormap",
          "package": "GLUT",
          "source": "src/Graphics-UI-GLUT-Colormap.html",
          "type": "module"
        },
        "index": {
          "description": "OpenGL supports both RGBA and color index rendering The RGBA mode is generally preferable to color index because more OpenGL rendering capabilities are available and color index mode requires the loading of colormap entries The GLUT color index state variables are used to read and write entries in window color index colormap Every GLUT color index window has its own logical color index colormap The size of window colormap can be determined by reading numColorMapEntries GLUT color index windows within program can attempt to share colormap resources by copying single color index colormap to multiple windows using copyColormap If possible GLUT will attempt to share the actual colormap While copying colormaps using copyColormap can potentially allow sharing of physical colormap resources logically each window has its own colormap So changing copied colormap of window will force the duplication of the colormap For this reason color index programs should generally load single color index colormap copy it to all color index windows within the program and then not modify any colormap cells Use of multiple colormaps is likely to result in colormap installation problems where some windows are displayed with an incorrect colormap due to limitations on colormap resources",
          "hierarchy": "Graphics UI GLUT Colormap",
          "module": "Graphics.UI.GLUT.Colormap",
          "name": "Colormap",
          "package": "GLUT",
          "partial": "Colormap",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Colormap.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eControls the color index colormap entry of the \u003cem\u003ecurrent window\u003c/em\u003e's logical\n colormap for the \u003cem\u003elayer in use\u003c/em\u003e. The \u003cem\u003elayer in use\u003c/em\u003e of the \u003cem\u003ecurrent window\u003c/em\u003e\n should be a color index window. The color index should be zero or greater and\n less than the total number of colormap entries for the window (see\n \u003ccode\u003e\u003ca\u003enumColorMapEntries\u003c/a\u003e\u003c/code\u003e) and different from an overlay's transparent index (see\n \u003ccode\u003e\u003ca\u003etransparentIndex\u003c/a\u003e\u003c/code\u003e).\n\u003c/p\u003e\u003cp\u003eIf the \u003cem\u003elayer in use\u003c/em\u003e's colormap was copied by reference, setting a colormap\n entry will force the duplication of the colormap.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Colormap",
          "name": "colorMapEntry",
          "package": "GLUT",
          "signature": "Index1 GLint -\u003e StateVar (Color3 GLfloat)",
          "source": "src/Graphics-UI-GLUT-Colormap.html#colorMapEntry",
          "type": "function"
        },
        "index": {
          "description": "Controls the color index colormap entry of the current window logical colormap for the layer in use The layer in use of the current window should be color index window The color index should be zero or greater and less than the total number of colormap entries for the window see numColorMapEntries and different from an overlay transparent index see transparentIndex If the layer in use colormap was copied by reference setting colormap entry will force the duplication of the colormap",
          "hierarchy": "Graphics UI GLUT Colormap",
          "module": "Graphics.UI.GLUT.Colormap",
          "name": "colorMapEntry",
          "normalized": "Index GLint-\u003eStateVar(Color GLfloat)",
          "package": "GLUT",
          "partial": "Map Entry",
          "signature": "Index GLint-\u003eStateVar(Color GLfloat)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Colormap.html#v:colorMapEntry"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCopy (lazily if possible to promote sharing) the logical colormap from a\n specified window to the \u003cem\u003ecurrent window\u003c/em\u003e's \u003cem\u003elayer in use\u003c/em\u003e. The copy will be\n from the normal plane to the normal plane; or from the overlay to the overlay\n (never across different layers). Once a colormap has been copied, avoid\n setting cells in the colormap via \u003ccode\u003e\u003ca\u003ecolorMapEntry\u003c/a\u003e\u003c/code\u003e since that will force an\n actual copy of the colormap if it was previously copied by reference.\n \u003ccode\u003e\u003ca\u003ecopyColormap\u003c/a\u003e\u003c/code\u003e should only be called when both the \u003cem\u003ecurrent window\u003c/em\u003e and the\n specified window are color index windows.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Colormap",
          "name": "copyColormap",
          "package": "GLUT",
          "signature": "Window -\u003e IO ()",
          "source": "src/Graphics-UI-GLUT-Colormap.html#copyColormap",
          "type": "function"
        },
        "index": {
          "description": "Copy lazily if possible to promote sharing the logical colormap from specified window to the current window layer in use The copy will be from the normal plane to the normal plane or from the overlay to the overlay never across different layers Once colormap has been copied avoid setting cells in the colormap via colorMapEntry since that will force an actual copy of the colormap if it was previously copied by reference copyColormap should only be called when both the current window and the specified window are color index windows",
          "hierarchy": "Graphics UI GLUT Colormap",
          "module": "Graphics.UI.GLUT.Colormap",
          "name": "copyColormap",
          "normalized": "Window-\u003eIO()",
          "package": "GLUT",
          "partial": "Colormap",
          "signature": "Window-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Colormap.html#v:copyColormap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eContains the number of entries in the colormap of the \u003cem\u003ecurrent window\u003c/em\u003e's\n current layer (0 in RGBA mode).\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Colormap",
          "name": "numColorMapEntries",
          "package": "GLUT",
          "signature": "GettableStateVar GLint",
          "source": "src/Graphics-UI-GLUT-Colormap.html#numColorMapEntries",
          "type": "function"
        },
        "index": {
          "description": "Contains the number of entries in the colormap of the current window current layer in RGBA mode",
          "hierarchy": "Graphics UI GLUT Colormap",
          "module": "Graphics.UI.GLUT.Colormap",
          "name": "numColorMapEntries",
          "package": "GLUT",
          "partial": "Color Map Entries",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Colormap.html#v:numColorMapEntries"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eContains the transparent color index of the overlay of the \u003cem\u003ecurrent window\u003c/em\u003e\n or -1 if no overlay is in use.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Colormap",
          "name": "transparentIndex",
          "package": "GLUT",
          "signature": "GettableStateVar (Index1 GLint)",
          "source": "src/Graphics-UI-GLUT-Colormap.html#transparentIndex",
          "type": "function"
        },
        "index": {
          "description": "Contains the transparent color index of the overlay of the current window or if no overlay is in use",
          "hierarchy": "Graphics UI GLUT Colormap",
          "module": "Graphics.UI.GLUT.Colormap",
          "name": "transparentIndex",
          "package": "GLUT",
          "partial": "Index",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Colormap.html#v:transparentIndex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module contains a simple utility routine to report any pending GL\n errors.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Graphics.UI.GLUT.Debugging",
          "name": "Debugging",
          "package": "GLUT",
          "source": "src/Graphics-UI-GLUT-Debugging.html",
          "type": "module"
        },
        "index": {
          "description": "This module contains simple utility routine to report any pending GL errors",
          "hierarchy": "Graphics UI GLUT Debugging",
          "module": "Graphics.UI.GLUT.Debugging",
          "name": "Debugging",
          "package": "GLUT",
          "partial": "Debugging",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Debugging.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReport any pending GL errors to stderr (which is typically the console).\n If there are no pending errors, this routine does nothing. Note that the\n error flags are reset after this action, i.e. there are no pending errors\n left afterwards.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Debugging",
          "name": "reportErrors",
          "package": "GLUT",
          "signature": "IO ()",
          "source": "src/Graphics-UI-GLUT-Debugging.html#reportErrors",
          "type": "function"
        },
        "index": {
          "description": "Report any pending GL errors to stderr which is typically the console If there are no pending errors this routine does nothing Note that the error flags are reset after this action i.e there are no pending errors left afterwards",
          "hierarchy": "Graphics UI GLUT Debugging",
          "module": "Graphics.UI.GLUT.Debugging",
          "name": "reportErrors",
          "normalized": "IO()",
          "package": "GLUT",
          "partial": "Errors",
          "signature": "IO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Debugging.html#v:reportErrors"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eGLUT offers some routines for controlling the key repeat and polling the\n joystick.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Graphics.UI.GLUT.DeviceControl",
          "name": "DeviceControl",
          "package": "GLUT",
          "source": "src/Graphics-UI-GLUT-DeviceControl.html",
          "type": "module"
        },
        "index": {
          "description": "GLUT offers some routines for controlling the key repeat and polling the joystick",
          "hierarchy": "Graphics UI GLUT DeviceControl",
          "module": "Graphics.UI.GLUT.DeviceControl",
          "name": "DeviceControl",
          "package": "GLUT",
          "partial": "Device Control",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-DeviceControl.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe state of the global key repeat\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.DeviceControl",
          "name": "GlobalKeyRepeat",
          "package": "GLUT",
          "source": "src/Graphics-UI-GLUT-DeviceControl.html#GlobalKeyRepeat",
          "type": "data"
        },
        "index": {
          "description": "The state of the global key repeat",
          "hierarchy": "Graphics UI GLUT DeviceControl",
          "module": "Graphics.UI.GLUT.DeviceControl",
          "name": "GlobalKeyRepeat",
          "package": "GLUT",
          "partial": "Global Key Repeat",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-DeviceControl.html#t:GlobalKeyRepeat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe state of the per-window key repeat\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.DeviceControl",
          "name": "PerWindowKeyRepeat",
          "package": "GLUT",
          "source": "src/Graphics-UI-GLUT-DeviceControl.html#PerWindowKeyRepeat",
          "type": "data"
        },
        "index": {
          "description": "The state of the per-window key repeat",
          "hierarchy": "Graphics UI GLUT DeviceControl",
          "module": "Graphics.UI.GLUT.DeviceControl",
          "name": "PerWindowKeyRepeat",
          "package": "GLUT",
          "partial": "Per Window Key Repeat",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-DeviceControl.html#t:PerWindowKeyRepeat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.UI.GLUT.DeviceControl",
          "name": "GlobalKeyRepeatDefault",
          "package": "GLUT",
          "signature": "GlobalKeyRepeatDefault",
          "source": "src/Graphics-UI-GLUT-DeviceControl.html#GlobalKeyRepeat",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics UI GLUT DeviceControl",
          "module": "Graphics.UI.GLUT.DeviceControl",
          "name": "GlobalKeyRepeatDefault",
          "package": "GLUT",
          "partial": "Global Key Repeat Default",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-DeviceControl.html#v:GlobalKeyRepeatDefault"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.UI.GLUT.DeviceControl",
          "name": "GlobalKeyRepeatOff",
          "package": "GLUT",
          "signature": "GlobalKeyRepeatOff",
          "source": "src/Graphics-UI-GLUT-DeviceControl.html#GlobalKeyRepeat",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics UI GLUT DeviceControl",
          "module": "Graphics.UI.GLUT.DeviceControl",
          "name": "GlobalKeyRepeatOff",
          "package": "GLUT",
          "partial": "Global Key Repeat Off",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-DeviceControl.html#v:GlobalKeyRepeatOff"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.UI.GLUT.DeviceControl",
          "name": "GlobalKeyRepeatOn",
          "package": "GLUT",
          "signature": "GlobalKeyRepeatOn",
          "source": "src/Graphics-UI-GLUT-DeviceControl.html#GlobalKeyRepeat",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics UI GLUT DeviceControl",
          "module": "Graphics.UI.GLUT.DeviceControl",
          "name": "GlobalKeyRepeatOn",
          "package": "GLUT",
          "partial": "Global Key Repeat On",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-DeviceControl.html#v:GlobalKeyRepeatOn"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.UI.GLUT.DeviceControl",
          "name": "PerWindowKeyRepeatOff",
          "package": "GLUT",
          "signature": "PerWindowKeyRepeatOff",
          "source": "src/Graphics-UI-GLUT-DeviceControl.html#PerWindowKeyRepeat",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics UI GLUT DeviceControl",
          "module": "Graphics.UI.GLUT.DeviceControl",
          "name": "PerWindowKeyRepeatOff",
          "package": "GLUT",
          "partial": "Per Window Key Repeat Off",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-DeviceControl.html#v:PerWindowKeyRepeatOff"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.UI.GLUT.DeviceControl",
          "name": "PerWindowKeyRepeatOn",
          "package": "GLUT",
          "signature": "PerWindowKeyRepeatOn",
          "source": "src/Graphics-UI-GLUT-DeviceControl.html#PerWindowKeyRepeat",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics UI GLUT DeviceControl",
          "module": "Graphics.UI.GLUT.DeviceControl",
          "name": "PerWindowKeyRepeatOn",
          "package": "GLUT",
          "partial": "Per Window Key Repeat On",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-DeviceControl.html#v:PerWindowKeyRepeatOn"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExecute the joystick callback set by\n \u003ccode\u003e\u003ca\u003ejoystickCallback\u003c/a\u003e\u003c/code\u003e once (if one exists).\n This is done in a synchronous fashion within the current context, i.e. when\n \u003ccode\u003e\u003ca\u003eforceJoystickCallback\u003c/a\u003e\u003c/code\u003e returns, the callback will have already happened.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.DeviceControl",
          "name": "forceJoystickCallback",
          "package": "GLUT",
          "signature": "IO ()",
          "source": "src/Graphics-UI-GLUT-DeviceControl.html#forceJoystickCallback",
          "type": "function"
        },
        "index": {
          "description": "Execute the joystick callback set by joystickCallback once if one exists This is done in synchronous fashion within the current context i.e when forceJoystickCallback returns the callback will have already happened",
          "hierarchy": "Graphics UI GLUT DeviceControl",
          "module": "Graphics.UI.GLUT.DeviceControl",
          "name": "forceJoystickCallback",
          "normalized": "IO()",
          "package": "GLUT",
          "partial": "Joystick Callback",
          "signature": "IO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-DeviceControl.html#v:forceJoystickCallback"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eControls the key repeat mode for the window system on a global basis if\n possible. If supported by the window system, the key repeat can either be\n disabled, enabled, or set to the window system's default key repeat state.\n\u003c/p\u003e\u003cp\u003e\u003cem\u003eX Implementation Notes:\u003c/em\u003e X11 sends \u003ccode\u003eKeyPress\u003c/code\u003e events repeatedly when the\n window system's global auto repeat is enabled. \u003ccode\u003e\u003ca\u003eperWindowKeyRepeat\u003c/a\u003e\u003c/code\u003e can\n prevent these auto repeated keystrokes from being reported as keyboard or\n special callbacks, but there is still some minimal overhead by the X server\n to continually stream \u003ccode\u003eKeyPress\u003c/code\u003e events to the GLUT application. The\n \u003ccode\u003e\u003ca\u003eglobalKeyRepeat\u003c/a\u003e\u003c/code\u003e state variable can be used to actually disable the global\n sending of auto repeated \u003ccode\u003eKeyPress\u003c/code\u003e events. Note that \u003ccode\u003e\u003ca\u003eglobalKeyRepeat\u003c/a\u003e\u003c/code\u003e\n affects the global window system auto repeat state so other applications\n will not auto repeat if you disable auto repeat globally through\n \u003ccode\u003e\u003ca\u003eglobalKeyRepeat\u003c/a\u003e\u003c/code\u003e. GLUT applications using the X11 GLUT implementation\n should disable key repeat with \u003ccode\u003e\u003ca\u003eglobalKeyRepeat\u003c/a\u003e\u003c/code\u003e to disable key repeats most\n efficiently, but are responsible for explicitly restoring the default key\n repeat state on exit.\n\u003c/p\u003e\u003cp\u003e\u003cem\u003eWin32 Implementation Notes:\u003c/em\u003e The Win32 implementation of \u003ccode\u003e\u003ca\u003eglobalKeyRepeat\u003c/a\u003e\u003c/code\u003e\n does nothing. The \u003ccode\u003e\u003ca\u003eperWindowKeyRepeat\u003c/a\u003e\u003c/code\u003e can be used in the Win32 GLUT\n implementation to ignore repeated keys on a per-window basis without changing\n the global window system key repeat.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.DeviceControl",
          "name": "globalKeyRepeat",
          "package": "GLUT",
          "signature": "StateVar GlobalKeyRepeat",
          "source": "src/Graphics-UI-GLUT-DeviceControl.html#globalKeyRepeat",
          "type": "function"
        },
        "index": {
          "description": "Controls the key repeat mode for the window system on global basis if possible If supported by the window system the key repeat can either be disabled enabled or set to the window system default key repeat state Implementation Notes X11 sends KeyPress events repeatedly when the window system global auto repeat is enabled perWindowKeyRepeat can prevent these auto repeated keystrokes from being reported as keyboard or special callbacks but there is still some minimal overhead by the server to continually stream KeyPress events to the GLUT application The globalKeyRepeat state variable can be used to actually disable the global sending of auto repeated KeyPress events Note that globalKeyRepeat affects the global window system auto repeat state so other applications will not auto repeat if you disable auto repeat globally through globalKeyRepeat GLUT applications using the X11 GLUT implementation should disable key repeat with globalKeyRepeat to disable key repeats most efficiently but are responsible for explicitly restoring the default key repeat state on exit Win32 Implementation Notes The Win32 implementation of globalKeyRepeat does nothing The perWindowKeyRepeat can be used in the Win32 GLUT implementation to ignore repeated keys on per-window basis without changing the global window system key repeat",
          "hierarchy": "Graphics UI GLUT DeviceControl",
          "module": "Graphics.UI.GLUT.DeviceControl",
          "name": "globalKeyRepeat",
          "package": "GLUT",
          "partial": "Key Repeat",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-DeviceControl.html#v:globalKeyRepeat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eControls if auto repeat keystrokes are reported to the \u003cem\u003ecurrent window.\u003c/em\u003e\n Ignoring auto repeated keystrokes is generally done in conjunction with using\n the \u003ccode\u003e\u003ca\u003ekeyboardMouseCallback\u003c/a\u003e\u003c/code\u003e. If you do\n not ignore auto repeated keystrokes, your GLUT application will experience\n repeated release/press callbacks. Games using the keyboard will typically\n want to ignore key repeat.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.DeviceControl",
          "name": "perWindowKeyRepeat",
          "package": "GLUT",
          "signature": "StateVar PerWindowKeyRepeat",
          "source": "src/Graphics-UI-GLUT-DeviceControl.html#perWindowKeyRepeat",
          "type": "function"
        },
        "index": {
          "description": "Controls if auto repeat keystrokes are reported to the current window Ignoring auto repeated keystrokes is generally done in conjunction with using the keyboardMouseCallback If you do not ignore auto repeated keystrokes your GLUT application will experience repeated release press callbacks Games using the keyboard will typically want to ignore key repeat",
          "hierarchy": "Graphics UI GLUT DeviceControl",
          "module": "Graphics.UI.GLUT.DeviceControl",
          "name": "perWindowKeyRepeat",
          "package": "GLUT",
          "partial": "Window Key Repeat",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-DeviceControl.html#v:perWindowKeyRepeat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eGLUT supports two types of font rendering: stroke fonts, meaning each\n character is rendered as a set of line segments; and bitmap fonts, where each\n character is a bitmap generated with\n \u003ccode\u003e\u003ca\u003ebitmap\u003c/a\u003e\u003c/code\u003e. Stroke fonts have the\n advantage that because they are geometry, they can be arbitrarily scale and\n rendered. Bitmap fonts are less flexible since they are rendered as bitmaps\n but are usually faster than stroke fonts.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Graphics.UI.GLUT.Fonts",
          "name": "Fonts",
          "package": "GLUT",
          "source": "src/Graphics-UI-GLUT-Fonts.html",
          "type": "module"
        },
        "index": {
          "description": "GLUT supports two types of font rendering stroke fonts meaning each character is rendered as set of line segments and bitmap fonts where each character is bitmap generated with bitmap Stroke fonts have the advantage that because they are geometry they can be arbitrarily scale and rendered Bitmap fonts are less flexible since they are rendered as bitmaps but are usually faster than stroke fonts",
          "hierarchy": "Graphics UI GLUT Fonts",
          "module": "Graphics.UI.GLUT.Fonts",
          "name": "Fonts",
          "package": "GLUT",
          "partial": "Fonts",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Fonts.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe bitmap fonts available in GLUT. The exact bitmap to be used is\n defined by the standard X glyph bitmaps for the X font with the given name.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Fonts",
          "name": "BitmapFont",
          "package": "GLUT",
          "source": "src/Graphics-UI-GLUT-Raw-Fonts.html#BitmapFont",
          "type": "data"
        },
        "index": {
          "description": "The bitmap fonts available in GLUT The exact bitmap to be used is defined by the standard glyph bitmaps for the font with the given name",
          "hierarchy": "Graphics UI GLUT Fonts",
          "module": "Graphics.UI.GLUT.Fonts",
          "name": "BitmapFont",
          "package": "GLUT",
          "partial": "Bitmap Font",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Fonts.html#t:BitmapFont"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.UI.GLUT.Fonts",
          "name": "Font",
          "package": "GLUT",
          "source": "src/Graphics-UI-GLUT-Fonts.html#Font",
          "type": "class"
        },
        "index": {
          "hierarchy": "Graphics UI GLUT Fonts",
          "module": "Graphics.UI.GLUT.Fonts",
          "name": "Font",
          "package": "GLUT",
          "partial": "Font",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Fonts.html#t:Font"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe stroke fonts available in GLUT.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Fonts",
          "name": "StrokeFont",
          "package": "GLUT",
          "source": "src/Graphics-UI-GLUT-Raw-Fonts.html#StrokeFont",
          "type": "data"
        },
        "index": {
          "description": "The stroke fonts available in GLUT",
          "hierarchy": "Graphics UI GLUT Fonts",
          "module": "Graphics.UI.GLUT.Fonts",
          "name": "StrokeFont",
          "package": "GLUT",
          "partial": "Stroke Font",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Fonts.html#t:StrokeFont"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA fixed width font with every character fitting in an 8\n   by 13 pixel rectangle.\n   (\u003ccode\u003e-misc-fixed-medium-r-normal--13-120-75-75-C-80-iso8859-1\u003c/code\u003e)\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Fonts",
          "name": "Fixed8By13",
          "package": "GLUT",
          "signature": "Fixed8By13",
          "source": "src/Graphics-UI-GLUT-Raw-Fonts.html#BitmapFont",
          "type": "function"
        },
        "index": {
          "description": "fixed width font with every character fitting in an by pixel rectangle misc-fixed-medium-r-normal--13-120-75-75-C-80-iso8859-1",
          "hierarchy": "Graphics UI GLUT Fonts",
          "module": "Graphics.UI.GLUT.Fonts",
          "name": "Fixed8By13",
          "package": "GLUT",
          "partial": "Fixed By",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Fonts.html#v:Fixed8By13"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA fixed width font with every character fitting in an 9\n   by 15 pixel rectangle.\n   (\u003ccode\u003e-misc-fixed-medium-r-normal--15-140-75-75-C-90-iso8859-1\u003c/code\u003e)\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Fonts",
          "name": "Fixed9By15",
          "package": "GLUT",
          "signature": "Fixed9By15",
          "source": "src/Graphics-UI-GLUT-Raw-Fonts.html#BitmapFont",
          "type": "function"
        },
        "index": {
          "description": "fixed width font with every character fitting in an by pixel rectangle misc-fixed-medium-r-normal--15-140-75-75-C-90-iso8859-1",
          "hierarchy": "Graphics UI GLUT Fonts",
          "module": "Graphics.UI.GLUT.Fonts",
          "name": "Fixed9By15",
          "package": "GLUT",
          "partial": "Fixed By",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Fonts.html#v:Fixed9By15"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA 10-point proportional spaced Helvetica font.\n   (\u003ccode\u003e-adobe-helvetica-medium-r-normal--10-100-75-75-p-56-iso8859-1\u003c/code\u003e)\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Fonts",
          "name": "Helvetica10",
          "package": "GLUT",
          "signature": "Helvetica10",
          "source": "src/Graphics-UI-GLUT-Raw-Fonts.html#BitmapFont",
          "type": "function"
        },
        "index": {
          "description": "point proportional spaced Helvetica font adobe-helvetica-medium-r-normal--10-100-75-75-p-56-iso8859-1",
          "hierarchy": "Graphics UI GLUT Fonts",
          "module": "Graphics.UI.GLUT.Fonts",
          "name": "Helvetica10",
          "package": "GLUT",
          "partial": "Helvetica",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Fonts.html#v:Helvetica10"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA 12-point proportional spaced Helvetica font.\n   (\u003ccode\u003e-adobe-helvetica-medium-r-normal--12-120-75-75-p-67-iso8859-1\u003c/code\u003e)\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Fonts",
          "name": "Helvetica12",
          "package": "GLUT",
          "signature": "Helvetica12",
          "source": "src/Graphics-UI-GLUT-Raw-Fonts.html#BitmapFont",
          "type": "function"
        },
        "index": {
          "description": "point proportional spaced Helvetica font adobe-helvetica-medium-r-normal--12-120-75-75-p-67-iso8859-1",
          "hierarchy": "Graphics UI GLUT Fonts",
          "module": "Graphics.UI.GLUT.Fonts",
          "name": "Helvetica12",
          "package": "GLUT",
          "partial": "Helvetica",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Fonts.html#v:Helvetica12"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA 18-point proportional spaced Helvetica font.\n   (\u003ccode\u003e-adobe-helvetica-medium-r-normal--18-180-75-75-p-98-iso8859-1\u003c/code\u003e)\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Fonts",
          "name": "Helvetica18",
          "package": "GLUT",
          "signature": "Helvetica18",
          "source": "src/Graphics-UI-GLUT-Raw-Fonts.html#BitmapFont",
          "type": "function"
        },
        "index": {
          "description": "point proportional spaced Helvetica font adobe-helvetica-medium-r-normal--18-180-75-75-p-98-iso8859-1",
          "hierarchy": "Graphics UI GLUT Fonts",
          "module": "Graphics.UI.GLUT.Fonts",
          "name": "Helvetica18",
          "package": "GLUT",
          "partial": "Helvetica",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Fonts.html#v:Helvetica18"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA mono-spaced spaced Roman Simplex font (same characters as\n   \u003ccode\u003e\u003ca\u003eRoman\u003c/a\u003e\u003c/code\u003e) for ASCII characters 32 through 127. The maximum\n   top character in the font is 119.05 units; the bottom\n   descends 33.33 units. Each character is 104.76 units wide.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Fonts",
          "name": "MonoRoman",
          "package": "GLUT",
          "signature": "MonoRoman",
          "source": "src/Graphics-UI-GLUT-Raw-Fonts.html#StrokeFont",
          "type": "function"
        },
        "index": {
          "description": "mono-spaced spaced Roman Simplex font same characters as Roman for ASCII characters through The maximum top character in the font is units the bottom descends units Each character is units wide",
          "hierarchy": "Graphics UI GLUT Fonts",
          "module": "Graphics.UI.GLUT.Fonts",
          "name": "MonoRoman",
          "package": "GLUT",
          "partial": "Mono Roman",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Fonts.html#v:MonoRoman"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA proportionally spaced Roman Simplex font for ASCII\n   characters 32 through 127. The maximum top character in the\n   font is 119.05 units; the bottom descends 33.33 units.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Fonts",
          "name": "Roman",
          "package": "GLUT",
          "signature": "Roman",
          "source": "src/Graphics-UI-GLUT-Raw-Fonts.html#StrokeFont",
          "type": "function"
        },
        "index": {
          "description": "proportionally spaced Roman Simplex font for ASCII characters through The maximum top character in the font is units the bottom descends units",
          "hierarchy": "Graphics UI GLUT Fonts",
          "module": "Graphics.UI.GLUT.Fonts",
          "name": "Roman",
          "package": "GLUT",
          "partial": "Roman",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Fonts.html#v:Roman"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA 10-point proportional spaced Times Roman font.\n   (\u003ccode\u003e-adobe-times-medium-r-normal--10-100-75-75-p-54-iso8859-1\u003c/code\u003e)\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Fonts",
          "name": "TimesRoman10",
          "package": "GLUT",
          "signature": "TimesRoman10",
          "source": "src/Graphics-UI-GLUT-Raw-Fonts.html#BitmapFont",
          "type": "function"
        },
        "index": {
          "description": "point proportional spaced Times Roman font adobe-times-medium-r-normal--10-100-75-75-p-54-iso8859-1",
          "hierarchy": "Graphics UI GLUT Fonts",
          "module": "Graphics.UI.GLUT.Fonts",
          "name": "TimesRoman10",
          "package": "GLUT",
          "partial": "Times Roman",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Fonts.html#v:TimesRoman10"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA 24-point proportional spaced Times Roman font.\n   (\u003ccode\u003e-adobe-times-medium-r-normal--24-240-75-75-p-124-iso8859-1\u003c/code\u003e)\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Fonts",
          "name": "TimesRoman24",
          "package": "GLUT",
          "signature": "TimesRoman24",
          "source": "src/Graphics-UI-GLUT-Raw-Fonts.html#BitmapFont",
          "type": "function"
        },
        "index": {
          "description": "point proportional spaced Times Roman font adobe-times-medium-r-normal--24-240-75-75-p-124-iso8859-1",
          "hierarchy": "Graphics UI GLUT Fonts",
          "module": "Graphics.UI.GLUT.Fonts",
          "name": "TimesRoman24",
          "package": "GLUT",
          "partial": "Times Roman",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Fonts.html#v:TimesRoman24"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e(\u003cem\u003efreeglut only\u003c/em\u003e) For a bitmap font, return the maximum height of the\n characters in the given font measured in pixels. For a stroke font,\n return the width in units.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Fonts",
          "name": "fontHeight",
          "package": "GLUT",
          "signature": "a -\u003e IO GLfloat",
          "source": "src/Graphics-UI-GLUT-Fonts.html#fontHeight",
          "type": "method"
        },
        "index": {
          "description": "freeglut only For bitmap font return the maximum height of the characters in the given font measured in pixels For stroke font return the width in units",
          "hierarchy": "Graphics UI GLUT Fonts",
          "module": "Graphics.UI.GLUT.Fonts",
          "name": "fontHeight",
          "normalized": "a-\u003eIO GLfloat",
          "package": "GLUT",
          "partial": "Height",
          "signature": "a-\u003eIO GLfloat",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Fonts.html#v:fontHeight"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRender the string in the named font, without using any display lists.\n Rendering a nonexistent character has no effect.\n\u003c/p\u003e\u003cp\u003eIf the font is a bitmap font, \u003ccode\u003e\u003ca\u003erenderString\u003c/a\u003e\u003c/code\u003e automatically sets the OpenGL\n unpack pixel storage modes it needs appropriately and saves and restores\n the previous modes before returning. The generated call to\n \u003ccode\u003e\u003ca\u003ebitmap\u003c/a\u003e\u003c/code\u003e will adjust the current raster\n position based on the width of the string.\n If the font is a stroke font,\n \u003ccode\u003e\u003ca\u003etranslate\u003c/a\u003e\u003c/code\u003e is used to translate\n the current model view matrix to advance the width of the string.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Fonts",
          "name": "renderString",
          "package": "GLUT",
          "signature": "a -\u003e String -\u003e IO ()",
          "source": "src/Graphics-UI-GLUT-Fonts.html#renderString",
          "type": "method"
        },
        "index": {
          "description": "Render the string in the named font without using any display lists Rendering nonexistent character has no effect If the font is bitmap font renderString automatically sets the OpenGL unpack pixel storage modes it needs appropriately and saves and restores the previous modes before returning The generated call to bitmap will adjust the current raster position based on the width of the string If the font is stroke font translate is used to translate the current model view matrix to advance the width of the string",
          "hierarchy": "Graphics UI GLUT Fonts",
          "module": "Graphics.UI.GLUT.Fonts",
          "name": "renderString",
          "normalized": "a-\u003eString-\u003eIO()",
          "package": "GLUT",
          "partial": "String",
          "signature": "a-\u003eString-\u003eIO()",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Fonts.html#v:renderString"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFor a bitmap font, return the width in pixels of a string. For a stroke\n font, return the width in units. While the width of characters in a font\n may vary (though fixed width fonts do not vary), the maximum height\n characteristics of a particular font are fixed.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Fonts",
          "name": "stringWidth",
          "package": "GLUT",
          "signature": "a -\u003e String -\u003e IO GLint",
          "source": "src/Graphics-UI-GLUT-Fonts.html#stringWidth",
          "type": "method"
        },
        "index": {
          "description": "For bitmap font return the width in pixels of string For stroke font return the width in units While the width of characters in font may vary though fixed width fonts do not vary the maximum height characteristics of particular font are fixed",
          "hierarchy": "Graphics UI GLUT Fonts",
          "module": "Graphics.UI.GLUT.Fonts",
          "name": "stringWidth",
          "normalized": "a-\u003eString-\u003eIO GLint",
          "package": "GLUT",
          "partial": "Width",
          "signature": "a-\u003eString-\u003eIO GLint",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Fonts.html#v:stringWidth"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eIn addition to the functionality offered by\n \u003ccode\u003e\u003ca\u003efullScreen\u003c/a\u003e\u003c/code\u003e, GLUT offers an sub-API to change the\n screen resolution, color depth, and refresh rate of the display for a single\n full screen window. This mode of operation is called \u003cem\u003egame mode\u003c/em\u003e, and is\n restricted in various ways: No pop-up menus are allowed for this full screen\n window, no other (sub-)windows can be created, and all other applications are\n hidden.\n\u003c/p\u003e\u003cp\u003e\u003cem\u003eX Implementation Notes:\u003c/em\u003e Note that game mode is not fully supported in the\n original GLUT for X, it is essentially the same as using\n \u003ccode\u003e\u003ca\u003efullScreen\u003c/a\u003e\u003c/code\u003e. The GLUT clone freeglut\n (see \u003ca\u003ehttp://freeglut.sourceforge.net/\u003c/a\u003e) does not have this restriction.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Graphics.UI.GLUT.GameMode",
          "name": "GameMode",
          "package": "GLUT",
          "source": "src/Graphics-UI-GLUT-GameMode.html",
          "type": "module"
        },
        "index": {
          "description": "In addition to the functionality offered by fullScreen GLUT offers an sub-API to change the screen resolution color depth and refresh rate of the display for single full screen window This mode of operation is called game mode and is restricted in various ways No pop-up menus are allowed for this full screen window no other sub windows can be created and all other applications are hidden Implementation Notes Note that game mode is not fully supported in the original GLUT for it is essentially the same as using fullScreen The GLUT clone freeglut see http freeglut.sourceforge.net does not have this restriction",
          "hierarchy": "Graphics UI GLUT GameMode",
          "module": "Graphics.UI.GLUT.GameMode",
          "name": "GameMode",
          "package": "GLUT",
          "partial": "Game Mode",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-GameMode.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe color depth of the screen, measured in bits (e.g. 8, 16, 24, 32, ...)\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.GameMode",
          "name": "BitsPerPlane",
          "package": "GLUT",
          "source": "src/Graphics-UI-GLUT-GameMode.html#BitsPerPlane",
          "type": "type"
        },
        "index": {
          "description": "The color depth of the screen measured in bits e.g",
          "hierarchy": "Graphics UI GLUT GameMode",
          "module": "Graphics.UI.GLUT.GameMode",
          "name": "BitsPerPlane",
          "package": "GLUT",
          "partial": "Bits Per Plane",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-GameMode.html#t:BitsPerPlane"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCapabilities for \u003ccode\u003e\u003ca\u003egameModeCapabilities\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.GameMode",
          "name": "GameModeCapability",
          "package": "GLUT",
          "source": "src/Graphics-UI-GLUT-GameMode.html#GameModeCapability",
          "type": "data"
        },
        "index": {
          "description": "Capabilities for gameModeCapabilities",
          "hierarchy": "Graphics UI GLUT GameMode",
          "module": "Graphics.UI.GLUT.GameMode",
          "name": "GameModeCapability",
          "package": "GLUT",
          "partial": "Game Mode Capability",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-GameMode.html#t:GameModeCapability"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA single capability description for \u003ccode\u003e\u003ca\u003egameModeCapabilities\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.GameMode",
          "name": "GameModeCapabilityDescription",
          "package": "GLUT",
          "source": "src/Graphics-UI-GLUT-GameMode.html#GameModeCapabilityDescription",
          "type": "data"
        },
        "index": {
          "description": "single capability description for gameModeCapabilities",
          "hierarchy": "Graphics UI GLUT GameMode",
          "module": "Graphics.UI.GLUT.GameMode",
          "name": "GameModeCapabilityDescription",
          "package": "GLUT",
          "partial": "Game Mode Capability Description",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-GameMode.html#t:GameModeCapabilityDescription"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.UI.GLUT.GameMode",
          "name": "GameModeInfo",
          "package": "GLUT",
          "source": "src/Graphics-UI-GLUT-GameMode.html#GameModeInfo",
          "type": "data"
        },
        "index": {
          "hierarchy": "Graphics UI GLUT GameMode",
          "module": "Graphics.UI.GLUT.GameMode",
          "name": "GameModeInfo",
          "package": "GLUT",
          "partial": "Game Mode Info",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-GameMode.html#t:GameModeInfo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe refresh rate of the screen, measured in Hertz (e.g. 60, 75, 100, ...)\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.GameMode",
          "name": "RefreshRate",
          "package": "GLUT",
          "source": "src/Graphics-UI-GLUT-GameMode.html#RefreshRate",
          "type": "type"
        },
        "index": {
          "description": "The refresh rate of the screen measured in Hertz e.g",
          "hierarchy": "Graphics UI GLUT GameMode",
          "module": "Graphics.UI.GLUT.GameMode",
          "name": "RefreshRate",
          "package": "GLUT",
          "partial": "Refresh Rate",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-GameMode.html#t:RefreshRate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eColor depth of the screen in bits\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.GameMode",
          "name": "GameModeBitsPerPlane",
          "package": "GLUT",
          "signature": "GameModeBitsPerPlane",
          "source": "src/Graphics-UI-GLUT-GameMode.html#GameModeCapability",
          "type": "function"
        },
        "index": {
          "description": "Color depth of the screen in bits",
          "hierarchy": "Graphics UI GLUT GameMode",
          "module": "Graphics.UI.GLUT.GameMode",
          "name": "GameModeBitsPerPlane",
          "package": "GLUT",
          "partial": "Game Mode Bits Per Plane",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-GameMode.html#v:GameModeBitsPerPlane"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eHeight of the screen resolution in pixels\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.GameMode",
          "name": "GameModeHeight",
          "package": "GLUT",
          "signature": "GameModeHeight",
          "source": "src/Graphics-UI-GLUT-GameMode.html#GameModeCapability",
          "type": "function"
        },
        "index": {
          "description": "Height of the screen resolution in pixels",
          "hierarchy": "Graphics UI GLUT GameMode",
          "module": "Graphics.UI.GLUT.GameMode",
          "name": "GameModeHeight",
          "package": "GLUT",
          "partial": "Game Mode Height",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-GameMode.html#v:GameModeHeight"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.UI.GLUT.GameMode",
          "name": "GameModeInfo",
          "package": "GLUT",
          "signature": "GameModeInfo Size BitsPerPlane RefreshRate",
          "source": "src/Graphics-UI-GLUT-GameMode.html#GameModeInfo",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics UI GLUT GameMode",
          "module": "Graphics.UI.GLUT.GameMode",
          "name": "GameModeInfo",
          "package": "GLUT",
          "partial": "Game Mode Info",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-GameMode.html#v:GameModeInfo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMatch the Nth frame buffer configuration\n   compatible with the given capabilities\n   (numbering starts at 1)\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.GameMode",
          "name": "GameModeNum",
          "package": "GLUT",
          "signature": "GameModeNum",
          "source": "src/Graphics-UI-GLUT-GameMode.html#GameModeCapability",
          "type": "function"
        },
        "index": {
          "description": "Match the Nth frame buffer configuration compatible with the given capabilities numbering starts at",
          "hierarchy": "Graphics UI GLUT GameMode",
          "module": "Graphics.UI.GLUT.GameMode",
          "name": "GameModeNum",
          "package": "GLUT",
          "partial": "Game Mode Num",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-GameMode.html#v:GameModeNum"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRefresh rate in Hertz\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.GameMode",
          "name": "GameModeRefreshRate",
          "package": "GLUT",
          "signature": "GameModeRefreshRate",
          "source": "src/Graphics-UI-GLUT-GameMode.html#GameModeCapability",
          "type": "function"
        },
        "index": {
          "description": "Refresh rate in Hertz",
          "hierarchy": "Graphics UI GLUT GameMode",
          "module": "Graphics.UI.GLUT.GameMode",
          "name": "GameModeRefreshRate",
          "package": "GLUT",
          "partial": "Game Mode Refresh Rate",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-GameMode.html#v:GameModeRefreshRate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWidth of the screen resolution in pixels\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.GameMode",
          "name": "GameModeWidth",
          "package": "GLUT",
          "signature": "GameModeWidth",
          "source": "src/Graphics-UI-GLUT-GameMode.html#GameModeCapability",
          "type": "function"
        },
        "index": {
          "description": "Width of the screen resolution in pixels",
          "hierarchy": "Graphics UI GLUT GameMode",
          "module": "Graphics.UI.GLUT.GameMode",
          "name": "GameModeWidth",
          "package": "GLUT",
          "partial": "Game Mode Width",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-GameMode.html#v:GameModeWidth"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.UI.GLUT.GameMode",
          "name": "Where'",
          "package": "GLUT",
          "signature": "Where' GameModeCapability Relation Int",
          "source": "src/Graphics-UI-GLUT-GameMode.html#GameModeCapabilityDescription",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics UI GLUT GameMode",
          "module": "Graphics.UI.GLUT.GameMode",
          "name": "Where'",
          "package": "GLUT",
          "partial": "Where'",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-GameMode.html#v:Where-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEnter \u003cem\u003egame mode\u003c/em\u003e, trying to change resolution, refresh rate, etc., as\n specified by the current value of \u003ccode\u003e\u003ca\u003egameModeCapabilities\u003c/a\u003e\u003c/code\u003e. An identifier for\n the game mode window and a flag, indicating if the display mode actually\n changed, are returned. The game mode window is made the \u003cem\u003ecurrent window\u003c/em\u003e.\n\u003c/p\u003e\u003cp\u003eRe-entering \u003cem\u003egame mode\u003c/em\u003e is allowed, the previous game mode window gets\n destroyed by this, and a new one is created.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.GameMode",
          "name": "enterGameMode",
          "package": "GLUT",
          "signature": "IO (Window, Bool)",
          "source": "src/Graphics-UI-GLUT-GameMode.html#enterGameMode",
          "type": "function"
        },
        "index": {
          "description": "Enter game mode trying to change resolution refresh rate etc as specified by the current value of gameModeCapabilities An identifier for the game mode window and flag indicating if the display mode actually changed are returned The game mode window is made the current window Re-entering game mode is allowed the previous game mode window gets destroyed by this and new one is created",
          "hierarchy": "Graphics UI GLUT GameMode",
          "module": "Graphics.UI.GLUT.GameMode",
          "name": "enterGameMode",
          "normalized": "IO(Window,Bool)",
          "package": "GLUT",
          "partial": "Game Mode",
          "signature": "IO(Window,Bool)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-GameMode.html#v:enterGameMode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eContains \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e when the \u003cem\u003egame mode\u003c/em\u003e is active, \u003ccode\u003e\u003ca\u003eFalse\u003c/a\u003e\u003c/code\u003e otherwise.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.GameMode",
          "name": "gameModeActive",
          "package": "GLUT",
          "signature": "GettableStateVar Bool",
          "source": "src/Graphics-UI-GLUT-GameMode.html#gameModeActive",
          "type": "function"
        },
        "index": {
          "description": "Contains True when the game mode is active False otherwise",
          "hierarchy": "Graphics UI GLUT GameMode",
          "module": "Graphics.UI.GLUT.GameMode",
          "name": "gameModeActive",
          "package": "GLUT",
          "partial": "Mode Active",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-GameMode.html#v:gameModeActive"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eControls the \u003cem\u003egame mode\u003c/em\u003e to be used when \u003ccode\u003e\u003ca\u003eenterGameMode\u003c/a\u003e\u003c/code\u003e is called. It is\n described by a list of zero or more capability descriptions, which are\n translated into a set of criteria used to select the appropriate screen\n configuration. The criteria are matched in strict left to right order of\n precdence. That is, the first specified criterion (leftmost) takes precedence\n over the later criteria for non-exact criteria\n (\u003ccode\u003e\u003ca\u003eIsGreaterThan\u003c/a\u003e\u003c/code\u003e,\n \u003ccode\u003e\u003ca\u003eIsLessThan\u003c/a\u003e\u003c/code\u003e, etc.). Exact criteria\n (\u003ccode\u003e\u003ca\u003eIsEqualTo\u003c/a\u003e\u003c/code\u003e,\n \u003ccode\u003e\u003ca\u003eIsNotEqualTo\u003c/a\u003e\u003c/code\u003e) must match exactly so\n precedence is not relevant.\n\u003c/p\u003e\u003cp\u003eTo determine which configuration will actually be tried by \u003ccode\u003e\u003ca\u003eenterGameMode\u003c/a\u003e\u003c/code\u003e\n (if any), use \u003ccode\u003e\u003ca\u003egameModeInfo\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eNote that even for game mode the current values of\n \u003ccode\u003e\u003ca\u003einitialDisplayMode\u003c/a\u003e\u003c/code\u003eor\n \u003ccode\u003e\u003ca\u003einitialDisplayCapabilities\u003c/a\u003e\u003c/code\u003e will\n determine which buffers are available, if double buffering is used or not,\n etc.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.GameMode",
          "name": "gameModeCapabilities",
          "package": "GLUT",
          "signature": "SettableStateVar [GameModeCapabilityDescription]",
          "source": "src/Graphics-UI-GLUT-GameMode.html#gameModeCapabilities",
          "type": "function"
        },
        "index": {
          "description": "Controls the game mode to be used when enterGameMode is called It is described by list of zero or more capability descriptions which are translated into set of criteria used to select the appropriate screen configuration The criteria are matched in strict left to right order of precdence That is the first specified criterion leftmost takes precedence over the later criteria for non-exact criteria IsGreaterThan IsLessThan etc Exact criteria IsEqualTo IsNotEqualTo must match exactly so precedence is not relevant To determine which configuration will actually be tried by enterGameMode if any use gameModeInfo Note that even for game mode the current values of initialDisplayMode or initialDisplayCapabilities will determine which buffers are available if double buffering is used or not etc",
          "hierarchy": "Graphics UI GLUT GameMode",
          "module": "Graphics.UI.GLUT.GameMode",
          "name": "gameModeCapabilities",
          "normalized": "SettableStateVar[GameModeCapabilityDescription]",
          "package": "GLUT",
          "partial": "Mode Capabilities",
          "signature": "SettableStateVar[GameModeCapabilityDescription]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-GameMode.html#v:gameModeCapabilities"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn \u003ccode\u003e\u003ca\u003eJust\u003c/a\u003e\u003c/code\u003e the mode which would be tried by the next call to\n \u003ccode\u003e\u003ca\u003eenterGameMode\u003c/a\u003e\u003c/code\u003e. Returns \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e if the mode requested by the current value\n of \u003ccode\u003e\u003ca\u003egameModeCapabilities\u003c/a\u003e\u003c/code\u003e is not possible, in which case \u003ccode\u003e\u003ca\u003eenterGameMode\u003c/a\u003e\u003c/code\u003e\n would simply create a full screen window using the current mode.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.GameMode",
          "name": "gameModeInfo",
          "package": "GLUT",
          "signature": "GettableStateVar (Maybe GameModeInfo)",
          "source": "src/Graphics-UI-GLUT-GameMode.html#gameModeInfo",
          "type": "function"
        },
        "index": {
          "description": "Return Just the mode which would be tried by the next call to enterGameMode Returns Nothing if the mode requested by the current value of gameModeCapabilities is not possible in which case enterGameMode would simply create full screen window using the current mode",
          "hierarchy": "Graphics UI GLUT GameMode",
          "module": "Graphics.UI.GLUT.GameMode",
          "name": "gameModeInfo",
          "package": "GLUT",
          "partial": "Mode Info",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-GameMode.html#v:gameModeInfo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLeave \u003cem\u003egame mode\u003c/em\u003e, restoring the old display mode and destroying the game\n mode window.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.GameMode",
          "name": "leaveGameMode",
          "package": "GLUT",
          "signature": "IO ()",
          "source": "src/Graphics-UI-GLUT-GameMode.html#leaveGameMode",
          "type": "function"
        },
        "index": {
          "description": "Leave game mode restoring the old display mode and destroying the game mode window",
          "hierarchy": "Graphics UI GLUT GameMode",
          "module": "Graphics.UI.GLUT.GameMode",
          "name": "leaveGameMode",
          "normalized": "IO()",
          "package": "GLUT",
          "partial": "Game Mode",
          "signature": "IO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-GameMode.html#v:leaveGameMode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eActions and state variables in this module are used to initialize GLUT state.\n The primary initialization routine is \u003ccode\u003e\u003ca\u003einitialize\u003c/a\u003e\u003c/code\u003e, which should only be\n called exactly once in a GLUT program. No other GLUT or OpenGL actions should\n be called before \u003ccode\u003e\u003ca\u003einitialize\u003c/a\u003e\u003c/code\u003e, apart from getting or setting the state\n variables in this module.\n\u003c/p\u003e\u003cp\u003eThe reason is that these state variables can be used to set default window\n initialization state that might be modified by the command processing done in\n \u003ccode\u003e\u003ca\u003einitialize\u003c/a\u003e\u003c/code\u003e. For example, \u003ccode\u003e\u003ca\u003einitialWindowSize\u003c/a\u003e\u003c/code\u003e can be set to \u003ccode\u003e(\u003ccode\u003e\u003ca\u003eSize\u003c/a\u003e\u003c/code\u003e\n 400 400)\u003c/code\u003e before \u003ccode\u003e\u003ca\u003einitialize\u003c/a\u003e\u003c/code\u003e is called to indicate 400 by 400 is the\n program's default window size. Setting the initial window size or position\n before \u003ccode\u003e\u003ca\u003einitialize\u003c/a\u003e\u003c/code\u003e allows the GLUT program user to specify the initial size\n or position using command line arguments.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Graphics.UI.GLUT.Initialization",
          "name": "Initialization",
          "package": "GLUT",
          "source": "src/Graphics-UI-GLUT-Initialization.html",
          "type": "module"
        },
        "index": {
          "description": "Actions and state variables in this module are used to initialize GLUT state The primary initialization routine is initialize which should only be called exactly once in GLUT program No other GLUT or OpenGL actions should be called before initialize apart from getting or setting the state variables in this module The reason is that these state variables can be used to set default window initialization state that might be modified by the command processing done in initialize For example initialWindowSize can be set to Size before initialize is called to indicate by is the program default window size Setting the initial window size or position before initialize allows the GLUT program user to specify the initial size or position using command line arguments",
          "hierarchy": "Graphics UI GLUT Initialization",
          "module": "Graphics.UI.GLUT.Initialization",
          "name": "Initialization",
          "package": "GLUT",
          "partial": "Initialization",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Initialization.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA flag affecting the rendering context to create, used in conjunction\n with \u003ccode\u003e\u003ca\u003einitialContextFlags\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Initialization",
          "name": "ContextFlag",
          "package": "GLUT",
          "source": "src/Graphics-UI-GLUT-Initialization.html#ContextFlag",
          "type": "data"
        },
        "index": {
          "description": "flag affecting the rendering context to create used in conjunction with initialContextFlags",
          "hierarchy": "Graphics UI GLUT Initialization",
          "module": "Graphics.UI.GLUT.Initialization",
          "name": "ContextFlag",
          "package": "GLUT",
          "partial": "Context Flag",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Initialization.html#t:ContextFlag"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn OpenGL API profile, affecting the rendering context to create, used\n in conjunction with \u003ccode\u003e\u003ca\u003einitialContextProfile\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Initialization",
          "name": "ContextProfile",
          "package": "GLUT",
          "source": "src/Graphics-UI-GLUT-Initialization.html#ContextProfile",
          "type": "data"
        },
        "index": {
          "description": "An OpenGL API profile affecting the rendering context to create used in conjunction with initialContextProfile",
          "hierarchy": "Graphics UI GLUT Initialization",
          "module": "Graphics.UI.GLUT.Initialization",
          "name": "ContextProfile",
          "package": "GLUT",
          "partial": "Context Profile",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Initialization.html#t:ContextProfile"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe kind of GLX rendering context used. Direct rendering provides a\n performance advantage in some implementations. However, direct rendering\n contexts cannot be shared outside a single process, and they may be unable\n to render to GLX pixmaps.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Initialization",
          "name": "DirectRendering",
          "package": "GLUT",
          "source": "src/Graphics-UI-GLUT-Initialization.html#DirectRendering",
          "type": "data"
        },
        "index": {
          "description": "The kind of GLX rendering context used Direct rendering provides performance advantage in some implementations However direct rendering contexts cannot be shared outside single process and they may be unable to render to GLX pixmaps",
          "hierarchy": "Graphics UI GLUT Initialization",
          "module": "Graphics.UI.GLUT.Initialization",
          "name": "DirectRendering",
          "package": "GLUT",
          "partial": "Direct Rendering",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Initialization.html#t:DirectRendering"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCapabilities for \u003ccode\u003e\u003ca\u003einitialDisplayCapabilities\u003c/a\u003e\u003c/code\u003e, most of them are extensions\n of the constructors of \u003ccode\u003e\u003ca\u003eDisplayMode\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Initialization",
          "name": "DisplayCapability",
          "package": "GLUT",
          "source": "src/Graphics-UI-GLUT-Initialization.html#DisplayCapability",
          "type": "data"
        },
        "index": {
          "description": "Capabilities for initialDisplayCapabilities most of them are extensions of the constructors of DisplayMode",
          "hierarchy": "Graphics UI GLUT Initialization",
          "module": "Graphics.UI.GLUT.Initialization",
          "name": "DisplayCapability",
          "package": "GLUT",
          "partial": "Display Capability",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Initialization.html#t:DisplayCapability"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA single capability description for \u003ccode\u003e\u003ca\u003einitialDisplayCapabilities\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Initialization",
          "name": "DisplayCapabilityDescription",
          "package": "GLUT",
          "source": "src/Graphics-UI-GLUT-Initialization.html#DisplayCapabilityDescription",
          "type": "data"
        },
        "index": {
          "description": "single capability description for initialDisplayCapabilities",
          "hierarchy": "Graphics UI GLUT Initialization",
          "module": "Graphics.UI.GLUT.Initialization",
          "name": "DisplayCapabilityDescription",
          "package": "GLUT",
          "partial": "Display Capability Description",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Initialization.html#t:DisplayCapabilityDescription"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA single aspect of a window which is to be created, used in conjunction\n with \u003ccode\u003e\u003ca\u003einitialDisplayMode\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Initialization",
          "name": "DisplayMode",
          "package": "GLUT",
          "source": "src/Graphics-UI-GLUT-Initialization.html#DisplayMode",
          "type": "data"
        },
        "index": {
          "description": "single aspect of window which is to be created used in conjunction with initialDisplayMode",
          "hierarchy": "Graphics UI GLUT Initialization",
          "module": "Graphics.UI.GLUT.Initialization",
          "name": "DisplayMode",
          "package": "GLUT",
          "partial": "Display Mode",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Initialization.html#t:DisplayMode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA relation between a \u003ccode\u003e\u003ca\u003eDisplayCapability\u003c/a\u003e\u003c/code\u003e\n and a numeric value.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Initialization",
          "name": "Relation",
          "package": "GLUT",
          "source": "src/Graphics-UI-GLUT-Types.html#Relation",
          "type": "data"
        },
        "index": {
          "description": "relation between DisplayCapability and numeric value",
          "hierarchy": "Graphics UI GLUT Initialization",
          "module": "Graphics.UI.GLUT.Initialization",
          "name": "Relation",
          "package": "GLUT",
          "partial": "Relation",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Initialization.html#t:Relation"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eHow rendering context for new windows are created.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Initialization",
          "name": "RenderingContext",
          "package": "GLUT",
          "source": "src/Graphics-UI-GLUT-Initialization.html#RenderingContext",
          "type": "data"
        },
        "index": {
          "description": "How rendering context for new windows are created",
          "hierarchy": "Graphics UI GLUT Initialization",
          "module": "Graphics.UI.GLUT.Initialization",
          "name": "RenderingContext",
          "package": "GLUT",
          "partial": "Rendering Context",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Initialization.html#t:RenderingContext"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTry to use direct rendering, silently using indirect rendering if this\n is not possible.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Initialization",
          "name": "AllowDirectContext",
          "package": "GLUT",
          "signature": "AllowDirectContext",
          "source": "src/Graphics-UI-GLUT-Initialization.html#DirectRendering",
          "type": "function"
        },
        "index": {
          "description": "Try to use direct rendering silently using indirect rendering if this is not possible",
          "hierarchy": "Graphics UI GLUT Initialization",
          "module": "Graphics.UI.GLUT.Initialization",
          "name": "AllowDirectContext",
          "package": "GLUT",
          "partial": "Allow Direct Context",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Initialization.html#v:AllowDirectContext"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSelect a window without any borders (\u003cem\u003efreeglut only\u003c/em\u003e).\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Initialization",
          "name": "Borderless",
          "package": "GLUT",
          "signature": "Borderless",
          "source": "src/Graphics-UI-GLUT-Initialization.html#DisplayMode",
          "type": "function"
        },
        "index": {
          "description": "Select window without any borders freeglut only",
          "hierarchy": "Graphics UI GLUT Initialization",
          "module": "Graphics.UI.GLUT.Initialization",
          "name": "Borderless",
          "package": "GLUT",
          "partial": "Borderless",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Initialization.html#v:Borderless"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSelect a window without a caption (\u003cem\u003efreeglut only\u003c/em\u003e).\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Initialization",
          "name": "Captionless",
          "package": "GLUT",
          "signature": "Captionless",
          "source": "src/Graphics-UI-GLUT-Initialization.html#DisplayMode",
          "type": "function"
        },
        "index": {
          "description": "Select window without caption freeglut only",
          "hierarchy": "Graphics UI GLUT Initialization",
          "module": "Graphics.UI.GLUT.Initialization",
          "name": "Captionless",
          "package": "GLUT",
          "partial": "Captionless",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Initialization.html#v:Captionless"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe OpenGL \u003cem\u003ecompatibility\u003c/em\u003e profile, which is optional for OpenGL\n 3.2 implementations.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Initialization",
          "name": "CompatibilityProfile",
          "package": "GLUT",
          "signature": "CompatibilityProfile",
          "source": "src/Graphics-UI-GLUT-Initialization.html#ContextProfile",
          "type": "function"
        },
        "index": {
          "description": "The OpenGL compatibility profile which is optional for OpenGL implementations",
          "hierarchy": "Graphics UI GLUT Initialization",
          "module": "Graphics.UI.GLUT.Initialization",
          "name": "CompatibilityProfile",
          "package": "GLUT",
          "partial": "Compatibility Profile",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Initialization.html#v:CompatibilityProfile"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe OpenGL \u003cem\u003ecore\u003c/em\u003e profile, which all OpenGL 3.2 implementations\n are required to support.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Initialization",
          "name": "CoreProfile",
          "package": "GLUT",
          "signature": "CoreProfile",
          "source": "src/Graphics-UI-GLUT-Initialization.html#ContextProfile",
          "type": "function"
        },
        "index": {
          "description": "The OpenGL core profile which all OpenGL implementations are required to support",
          "hierarchy": "Graphics UI GLUT Initialization",
          "module": "Graphics.UI.GLUT.Initialization",
          "name": "CoreProfile",
          "package": "GLUT",
          "partial": "Core Profile",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Initialization.html#v:CoreProfile"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreate a new context via \u003ccode\u003eglXCreateContext\u003c/code\u003e or \u003ccode\u003ewglCreateContext\u003c/code\u003e\n   (default).\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Initialization",
          "name": "CreateNewContext",
          "package": "GLUT",
          "signature": "CreateNewContext",
          "source": "src/Graphics-UI-GLUT-Initialization.html#RenderingContext",
          "type": "function"
        },
        "index": {
          "description": "Create new context via glXCreateContext or wglCreateContext default",
          "hierarchy": "Graphics UI GLUT Initialization",
          "module": "Graphics.UI.GLUT.Initialization",
          "name": "CreateNewContext",
          "package": "GLUT",
          "partial": "Create New Context",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Initialization.html#v:CreateNewContext"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDebug contexts are intended for use during application development,\n and provide additional runtime checking, validation, and logging\n functionality while possibly incurring performance penalties. The\n additional functionality provided by debug contexts may vary according\n to the implementation. In some cases a debug context may be identical\n to a non-debug context.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Initialization",
          "name": "DebugContext",
          "package": "GLUT",
          "signature": "DebugContext",
          "source": "src/Graphics-UI-GLUT-Initialization.html#ContextFlag",
          "type": "function"
        },
        "index": {
          "description": "Debug contexts are intended for use during application development and provide additional runtime checking validation and logging functionality while possibly incurring performance penalties The additional functionality provided by debug contexts may vary according to the implementation In some cases debug context may be identical to non-debug context",
          "hierarchy": "Graphics UI GLUT Initialization",
          "module": "Graphics.UI.GLUT.Initialization",
          "name": "DebugContext",
          "package": "GLUT",
          "partial": "Debug Context",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Initialization.html#v:DebugContext"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRed, green, and green accumulation buffer precision in\n   bits and zero bits of alpha accumulation buffer precision.\n   Default is \"\u003ccode\u003e\u003ca\u003eIsAtLeast\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e1\u003c/code\u003e\" for red, green, and blue\n   capabilities, and \"\u003ccode\u003e\u003ca\u003eIsNotLessThan\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e0\u003c/code\u003e\" for the alpha\n   capability.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Initialization",
          "name": "DisplayAcc",
          "package": "GLUT",
          "signature": "DisplayAcc",
          "source": "src/Graphics-UI-GLUT-Initialization.html#DisplayCapability",
          "type": "function"
        },
        "index": {
          "description": "Red green and green accumulation buffer precision in bits and zero bits of alpha accumulation buffer precision Default is IsAtLeast for red green and blue capabilities and IsNotLessThan for the alpha capability",
          "hierarchy": "Graphics UI GLUT Initialization",
          "module": "Graphics.UI.GLUT.Initialization",
          "name": "DisplayAcc",
          "package": "GLUT",
          "partial": "Display Acc",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Initialization.html#v:DisplayAcc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRed, green, blue, and alpha accumulation buffer precision\n   in  bits. Default is \"\u003ccode\u003e\u003ca\u003eIsAtLeast\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e1\u003c/code\u003e\" for red, green,\n   blue, and alpha capabilities.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Initialization",
          "name": "DisplayAccA",
          "package": "GLUT",
          "signature": "DisplayAccA",
          "source": "src/Graphics-UI-GLUT-Initialization.html#DisplayCapability",
          "type": "function"
        },
        "index": {
          "description": "Red green blue and alpha accumulation buffer precision in bits Default is IsAtLeast for red green blue and alpha capabilities",
          "hierarchy": "Graphics UI GLUT Initialization",
          "module": "Graphics.UI.GLUT.Initialization",
          "name": "DisplayAccA",
          "package": "GLUT",
          "partial": "Display Acc",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Initialization.html#v:DisplayAccA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAlpha color buffer precision in bits. Default is\n   \"\u003ccode\u003e\u003ca\u003eIsAtLeast\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e1\u003c/code\u003e\".\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Initialization",
          "name": "DisplayAlpha",
          "package": "GLUT",
          "signature": "DisplayAlpha",
          "source": "src/Graphics-UI-GLUT-Initialization.html#DisplayCapability",
          "type": "function"
        },
        "index": {
          "description": "Alpha color buffer precision in bits Default is IsAtLeast",
          "hierarchy": "Graphics UI GLUT Initialization",
          "module": "Graphics.UI.GLUT.Initialization",
          "name": "DisplayAlpha",
          "package": "GLUT",
          "partial": "Display Alpha",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Initialization.html#v:DisplayAlpha"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e(\u003cem\u003efreeglut only\u003c/em\u003e) Number of auxiliary buffers. Default is\n   \"\u003ccode\u003e\u003ca\u003eIsEqualTo\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e1\u003c/code\u003e\".\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Initialization",
          "name": "DisplayAux",
          "package": "GLUT",
          "signature": "DisplayAux",
          "source": "src/Graphics-UI-GLUT-Initialization.html#DisplayCapability",
          "type": "function"
        },
        "index": {
          "description": "freeglut only Number of auxiliary buffers Default is IsEqualTo",
          "hierarchy": "Graphics UI GLUT Initialization",
          "module": "Graphics.UI.GLUT.Initialization",
          "name": "DisplayAux",
          "package": "GLUT",
          "partial": "Display Aux",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Initialization.html#v:DisplayAux"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eBlue color buffer precision in bits. Default is\n   \"\u003ccode\u003e\u003ca\u003eIsAtLeast\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e1\u003c/code\u003e\".\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Initialization",
          "name": "DisplayBlue",
          "package": "GLUT",
          "signature": "DisplayBlue",
          "source": "src/Graphics-UI-GLUT-Initialization.html#DisplayCapability",
          "type": "function"
        },
        "index": {
          "description": "Blue color buffer precision in bits Default is IsAtLeast",
          "hierarchy": "Graphics UI GLUT Initialization",
          "module": "Graphics.UI.GLUT.Initialization",
          "name": "DisplayBlue",
          "package": "GLUT",
          "partial": "Display Blue",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Initialization.html#v:DisplayBlue"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eNumber of bits in the color index color buffer. Default\n   is \"\u003ccode\u003e\u003ca\u003eIsAtLeast\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e1\u003c/code\u003e\".\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Initialization",
          "name": "DisplayBuffer",
          "package": "GLUT",
          "signature": "DisplayBuffer",
          "source": "src/Graphics-UI-GLUT-Initialization.html#DisplayCapability",
          "type": "function"
        },
        "index": {
          "description": "Number of bits in the color index color buffer Default is IsAtLeast",
          "hierarchy": "Graphics UI GLUT Initialization",
          "module": "Graphics.UI.GLUT.Initialization",
          "name": "DisplayBuffer",
          "package": "GLUT",
          "partial": "Display Buffer",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Initialization.html#v:DisplayBuffer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eBoolean indicating if the frame buffer configuration is\n   conformant or not. Conformance information is based on\n   GLX's \u003ccode\u003eEXT_visual_rating\u003c/code\u003e extension if supported. If the\n   extension is not supported, all visuals are assumed\n   conformant. Default is \"\u003ccode\u003e\u003ca\u003eIsEqualTo\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e1\u003c/code\u003e\".\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Initialization",
          "name": "DisplayConformant",
          "package": "GLUT",
          "signature": "DisplayConformant",
          "source": "src/Graphics-UI-GLUT-Initialization.html#DisplayCapability",
          "type": "function"
        },
        "index": {
          "description": "Boolean indicating if the frame buffer configuration is conformant or not Conformance information is based on GLX EXT visual rating extension if supported If the extension is not supported all visuals are assumed conformant Default is IsEqualTo",
          "hierarchy": "Graphics UI GLUT Initialization",
          "module": "Graphics.UI.GLUT.Initialization",
          "name": "DisplayConformant",
          "package": "GLUT",
          "partial": "Display Conformant",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Initialization.html#v:DisplayConformant"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eNumber of bits of precsion in the depth buffer. Default\n   is \"\u003ccode\u003e\u003ca\u003eIsAtLeast\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e12\u003c/code\u003e\".\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Initialization",
          "name": "DisplayDepth",
          "package": "GLUT",
          "signature": "DisplayDepth",
          "source": "src/Graphics-UI-GLUT-Initialization.html#DisplayCapability",
          "type": "function"
        },
        "index": {
          "description": "Number of bits of precsion in the depth buffer Default is IsAtLeast",
          "hierarchy": "Graphics UI GLUT Initialization",
          "module": "Graphics.UI.GLUT.Initialization",
          "name": "DisplayDepth",
          "package": "GLUT",
          "partial": "Display Depth",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Initialization.html#v:DisplayDepth"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eBoolean indicating if the color buffer is double\n   buffered. Default is \"\u003ccode\u003e\u003ca\u003eIsEqualTo\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e1\u003c/code\u003e\".\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Initialization",
          "name": "DisplayDouble",
          "package": "GLUT",
          "signature": "DisplayDouble",
          "source": "src/Graphics-UI-GLUT-Initialization.html#DisplayCapability",
          "type": "function"
        },
        "index": {
          "description": "Boolean indicating if the color buffer is double buffered Default is IsEqualTo",
          "hierarchy": "Graphics UI GLUT Initialization",
          "module": "Graphics.UI.GLUT.Initialization",
          "name": "DisplayDouble",
          "package": "GLUT",
          "partial": "Display Double",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Initialization.html#v:DisplayDouble"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGreen color buffer precision in bits. Default is\n   \"\u003ccode\u003e\u003ca\u003eIsAtLeast\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e1\u003c/code\u003e\".\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Initialization",
          "name": "DisplayGreen",
          "package": "GLUT",
          "signature": "DisplayGreen",
          "source": "src/Graphics-UI-GLUT-Initialization.html#DisplayCapability",
          "type": "function"
        },
        "index": {
          "description": "Green color buffer precision in bits Default is IsAtLeast",
          "hierarchy": "Graphics UI GLUT Initialization",
          "module": "Graphics.UI.GLUT.Initialization",
          "name": "DisplayGreen",
          "package": "GLUT",
          "partial": "Display Green",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Initialization.html#v:DisplayGreen"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eBoolean if the color model is color index or not. True is\n   color index. Default is \"\u003ccode\u003e\u003ca\u003eIsAtLeast\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e1\u003c/code\u003e\".\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Initialization",
          "name": "DisplayIndex",
          "package": "GLUT",
          "signature": "DisplayIndex",
          "source": "src/Graphics-UI-GLUT-Initialization.html#DisplayCapability",
          "type": "function"
        },
        "index": {
          "description": "Boolean if the color model is color index or not True is color index Default is IsAtLeast",
          "hierarchy": "Graphics UI GLUT Initialization",
          "module": "Graphics.UI.GLUT.Initialization",
          "name": "DisplayIndex",
          "package": "GLUT",
          "partial": "Display Index",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Initialization.html#v:DisplayIndex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eNumber of bits of red in the RGBA and zero bits of green,\n   blue (alpha not specified) of color buffer precision.\n   Default is \"\u003ccode\u003e\u003ca\u003eIsAtLeast\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e1\u003c/code\u003e\" for the red capabilitis,\n   and \"\u003ccode\u003e\u003ca\u003eIsEqualTo\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e0\u003c/code\u003e\" for the green and blue\n   capabilities, and \"\u003ccode\u003e\u003ca\u003eIsEqualTo\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e1\u003c/code\u003e\" for the RGBA color\n   model capability, and, for X11, \"\u003ccode\u003e\u003ca\u003eIsEqualTo\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e1\u003c/code\u003e\" for\n   the \u003ccode\u003e\u003ca\u003eDisplayXStaticGray\u003c/a\u003e\u003c/code\u003e capability. SGI InfiniteReality (and\n   other future machines) support a 16-bit luminance (single\n   channel) display mode (an additional 16-bit alpha channel\n   can also be requested). The red channel maps to gray\n   scale and green and blue channels are not available. A\n   16-bit precision luminance display mode is often\n   appropriate for medical imaging applications. Do not\n   expect many machines to support extended precision\n   luminance display modes.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Initialization",
          "name": "DisplayLuminance",
          "package": "GLUT",
          "signature": "DisplayLuminance",
          "source": "src/Graphics-UI-GLUT-Initialization.html#DisplayCapability",
          "type": "function"
        },
        "index": {
          "description": "Number of bits of red in the RGBA and zero bits of green blue alpha not specified of color buffer precision Default is IsAtLeast for the red capabilitis and IsEqualTo for the green and blue capabilities and IsEqualTo for the RGBA color model capability and for X11 IsEqualTo for the DisplayXStaticGray capability SGI InfiniteReality and other future machines support bit luminance single channel display mode an additional bit alpha channel can also be requested The red channel maps to gray scale and green and blue channels are not available bit precision luminance display mode is often appropriate for medical imaging applications Do not expect many machines to support extended precision luminance display modes",
          "hierarchy": "Graphics UI GLUT Initialization",
          "module": "Graphics.UI.GLUT.Initialization",
          "name": "DisplayLuminance",
          "package": "GLUT",
          "partial": "Display Luminance",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Initialization.html#v:DisplayLuminance"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA special capability name indicating where the value\n   represents the Nth frame buffer configuration matching\n   the description string. When not specified,\n   \u003ccode\u003e\u003ca\u003einitialDisplayCapabilities\u003c/a\u003e\u003c/code\u003e also uses the first\n   (best matching) configuration. \u003ccode\u003e\u003ca\u003eNum\u003c/a\u003e\u003c/code\u003e requires a relation\n   and numeric value.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Initialization",
          "name": "DisplayNum",
          "package": "GLUT",
          "signature": "DisplayNum",
          "source": "src/Graphics-UI-GLUT-Initialization.html#DisplayCapability",
          "type": "function"
        },
        "index": {
          "description": "special capability name indicating where the value represents the Nth frame buffer configuration matching the description string When not specified initialDisplayCapabilities also uses the first best matching configuration Num requires relation and numeric value",
          "hierarchy": "Graphics UI GLUT Initialization",
          "module": "Graphics.UI.GLUT.Initialization",
          "name": "DisplayNum",
          "package": "GLUT",
          "partial": "Display Num",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Initialization.html#v:DisplayNum"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eNumber of bits of red, green, and blue in the RGBA color\n   buffer and zero bits of alpha color buffer precision.\n   Default is \"\u003ccode\u003e\u003ca\u003eIsAtLeast\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e1\u003c/code\u003e\" for the red, green, and\n   blue capabilities, and \"\u003ccode\u003e\u003ca\u003eIsNotLessThan\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e0\u003c/code\u003e\" for alpha\n   capability, and \"\u003ccode\u003e\u003ca\u003eIsEqualTo\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e1\u003c/code\u003e\" for the RGBA color\n   model capability.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Initialization",
          "name": "DisplayRGB",
          "package": "GLUT",
          "signature": "DisplayRGB",
          "source": "src/Graphics-UI-GLUT-Initialization.html#DisplayCapability",
          "type": "function"
        },
        "index": {
          "description": "Number of bits of red green and blue in the RGBA color buffer and zero bits of alpha color buffer precision Default is IsAtLeast for the red green and blue capabilities and IsNotLessThan for alpha capability and IsEqualTo for the RGBA color model capability",
          "hierarchy": "Graphics UI GLUT Initialization",
          "module": "Graphics.UI.GLUT.Initialization",
          "name": "DisplayRGB",
          "package": "GLUT",
          "partial": "Display RGB",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Initialization.html#v:DisplayRGB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eNumber of bits of red, green, blue, and alpha in the RGBA\n   color buffer. Default is \"\u003ccode\u003e\u003ca\u003eIsAtLeast\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e1\u003c/code\u003e\" for red,\n   green, blue, and alpha capabilities, and \"\u003ccode\u003e\u003ca\u003eIsEqualTo\u003c/a\u003e\u003c/code\u003e\n   \u003ccode\u003e1\u003c/code\u003e\" for the RGBA color model capability.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Initialization",
          "name": "DisplayRGBA",
          "package": "GLUT",
          "signature": "DisplayRGBA",
          "source": "src/Graphics-UI-GLUT-Initialization.html#DisplayCapability",
          "type": "function"
        },
        "index": {
          "description": "Number of bits of red green blue and alpha in the RGBA color buffer Default is IsAtLeast for red green blue and alpha capabilities and IsEqualTo for the RGBA color model capability",
          "hierarchy": "Graphics UI GLUT Initialization",
          "module": "Graphics.UI.GLUT.Initialization",
          "name": "DisplayRGBA",
          "package": "GLUT",
          "partial": "Display RGBA",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Initialization.html#v:DisplayRGBA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRed color buffer precision in bits. Default is\n   \"\u003ccode\u003e\u003ca\u003eIsAtLeast\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e1\u003c/code\u003e\".\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Initialization",
          "name": "DisplayRed",
          "package": "GLUT",
          "signature": "DisplayRed",
          "source": "src/Graphics-UI-GLUT-Initialization.html#DisplayCapability",
          "type": "function"
        },
        "index": {
          "description": "Red color buffer precision in bits Default is IsAtLeast",
          "hierarchy": "Graphics UI GLUT Initialization",
          "module": "Graphics.UI.GLUT.Initialization",
          "name": "DisplayRed",
          "package": "GLUT",
          "partial": "Display Red",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Initialization.html#v:DisplayRed"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIndicates the number of multisamples to use based on\n   GLX's \u003ccode\u003eSGIS_multisample\u003c/code\u003e extension (for antialiasing).\n   Default is \"\u003ccode\u003e\u003ca\u003eIsNotGreaterThan\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e4\u003c/code\u003e\". This default means\n   that a GLUT application can request multisampling if\n   available by simply specifying \"\u003ccode\u003e\u003ca\u003eWith\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eDisplaySamples\u003c/a\u003e\u003c/code\u003e\".\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Initialization",
          "name": "DisplaySamples",
          "package": "GLUT",
          "signature": "DisplaySamples",
          "source": "src/Graphics-UI-GLUT-Initialization.html#DisplayCapability",
          "type": "function"
        },
        "index": {
          "description": "Indicates the number of multisamples to use based on GLX SGIS multisample extension for antialiasing Default is IsNotGreaterThan This default means that GLUT application can request multisampling if available by simply specifying With DisplaySamples",
          "hierarchy": "Graphics UI GLUT Initialization",
          "module": "Graphics.UI.GLUT.Initialization",
          "name": "DisplaySamples",
          "package": "GLUT",
          "partial": "Display Samples",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Initialization.html#v:DisplaySamples"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eBoolean indicate the color buffer is single buffered.\n   Default is \"\u003ccode\u003e\u003ca\u003eIsEqualTo\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e1\u003c/code\u003e\".\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Initialization",
          "name": "DisplaySingle",
          "package": "GLUT",
          "signature": "DisplaySingle",
          "source": "src/Graphics-UI-GLUT-Initialization.html#DisplayCapability",
          "type": "function"
        },
        "index": {
          "description": "Boolean indicate the color buffer is single buffered Default is IsEqualTo",
          "hierarchy": "Graphics UI GLUT Initialization",
          "module": "Graphics.UI.GLUT.Initialization",
          "name": "DisplaySingle",
          "package": "GLUT",
          "partial": "Display Single",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Initialization.html#v:DisplaySingle"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eBoolean indicating if the frame buffer configuration is\n   slow or not. Slowness information is based on GLX's\n   \u003ccode\u003eEXT_visual_rating\u003c/code\u003e extension if supported. If the\n   extension is not supported, all visuals are assumed fast.\n   Note that slowness is a relative designation relative to\n   other frame buffer configurations available. The intent\n   of the slow capability is to help programs avoid frame\n   buffer configurations that are slower (but perhaps higher\n   precision) for the current machine. Default is\n   \"\u003ccode\u003e\u003ca\u003eIsAtLeast\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e0\u003c/code\u003e\". This default means that slow visuals\n   are used in preference to fast visuals, but fast visuals\n   will still be allowed.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Initialization",
          "name": "DisplaySlow",
          "package": "GLUT",
          "signature": "DisplaySlow",
          "source": "src/Graphics-UI-GLUT-Initialization.html#DisplayCapability",
          "type": "function"
        },
        "index": {
          "description": "Boolean indicating if the frame buffer configuration is slow or not Slowness information is based on GLX EXT visual rating extension if supported If the extension is not supported all visuals are assumed fast Note that slowness is relative designation relative to other frame buffer configurations available The intent of the slow capability is to help programs avoid frame buffer configurations that are slower but perhaps higher precision for the current machine Default is IsAtLeast This default means that slow visuals are used in preference to fast visuals but fast visuals will still be allowed",
          "hierarchy": "Graphics UI GLUT Initialization",
          "module": "Graphics.UI.GLUT.Initialization",
          "name": "DisplaySlow",
          "package": "GLUT",
          "partial": "Display Slow",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Initialization.html#v:DisplaySlow"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eNumber of bits in the stencil buffer. Default is\n   \"\u003ccode\u003e\u003ca\u003eIsNotLessThan\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e1\u003c/code\u003e\".\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Initialization",
          "name": "DisplayStencil",
          "package": "GLUT",
          "signature": "DisplayStencil",
          "source": "src/Graphics-UI-GLUT-Initialization.html#DisplayCapability",
          "type": "function"
        },
        "index": {
          "description": "Number of bits in the stencil buffer Default is IsNotLessThan",
          "hierarchy": "Graphics UI GLUT Initialization",
          "module": "Graphics.UI.GLUT.Initialization",
          "name": "DisplayStencil",
          "package": "GLUT",
          "partial": "Display Stencil",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Initialization.html#v:DisplayStencil"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eBoolean indicating the color buffer is supports\n   OpenGL-style stereo. Default is \"\u003ccode\u003e\u003ca\u003eIsEqualTo\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e1\u003c/code\u003e\".\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Initialization",
          "name": "DisplayStereo",
          "package": "GLUT",
          "signature": "DisplayStereo",
          "source": "src/Graphics-UI-GLUT-Initialization.html#DisplayCapability",
          "type": "function"
        },
        "index": {
          "description": "Boolean indicating the color buffer is supports OpenGL-style stereo Default is IsEqualTo",
          "hierarchy": "Graphics UI GLUT Initialization",
          "module": "Graphics.UI.GLUT.Initialization",
          "name": "DisplayStereo",
          "package": "GLUT",
          "partial": "Display Stereo",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Initialization.html#v:DisplayStereo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eOnly recognized on GLUT implementations for Win32, this\n   capability name matches the Win32 Pixel Format Descriptor\n   by number. \u003ccode\u003e\u003ca\u003eDisplayWin32PFD\u003c/a\u003e\u003c/code\u003e can only be used with \u003ccode\u003e\u003ca\u003eWhere\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Initialization",
          "name": "DisplayWin32PFD",
          "package": "GLUT",
          "signature": "DisplayWin32PFD",
          "source": "src/Graphics-UI-GLUT-Initialization.html#DisplayCapability",
          "type": "function"
        },
        "index": {
          "description": "Only recognized on GLUT implementations for Win32 this capability name matches the Win32 Pixel Format Descriptor by number DisplayWin32PFD can only be used with Where",
          "hierarchy": "Graphics UI GLUT Initialization",
          "module": "Graphics.UI.GLUT.Initialization",
          "name": "DisplayWin32PFD",
          "package": "GLUT",
          "partial": "Display Win PFD",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Initialization.html#v:DisplayWin32PFD"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eOnly recongized on GLUT implementations for the X Window\n   System, boolean indicating if the frame buffer\n   configuration's X visual is of type \u003ccode\u003eDirectColor\u003c/code\u003e.\n   Default is \"\u003ccode\u003e\u003ca\u003eIsEqualTo\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e1\u003c/code\u003e\".\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Initialization",
          "name": "DisplayXDirectColor",
          "package": "GLUT",
          "signature": "DisplayXDirectColor",
          "source": "src/Graphics-UI-GLUT-Initialization.html#DisplayCapability",
          "type": "function"
        },
        "index": {
          "description": "Only recongized on GLUT implementations for the Window System boolean indicating if the frame buffer configuration visual is of type DirectColor Default is IsEqualTo",
          "hierarchy": "Graphics UI GLUT Initialization",
          "module": "Graphics.UI.GLUT.Initialization",
          "name": "DisplayXDirectColor",
          "package": "GLUT",
          "partial": "Display XDirect Color",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Initialization.html#v:DisplayXDirectColor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eOnly recongized on GLUT implementations for the X Window\n   System, boolean indicating if the frame buffer\n   configuration's X visual is of type \u003ccode\u003eGrayScale\u003c/code\u003e. Default\n   is \"\u003ccode\u003e\u003ca\u003eIsEqualTo\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e1\u003c/code\u003e\".\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Initialization",
          "name": "DisplayXGrayScale",
          "package": "GLUT",
          "signature": "DisplayXGrayScale",
          "source": "src/Graphics-UI-GLUT-Initialization.html#DisplayCapability",
          "type": "function"
        },
        "index": {
          "description": "Only recongized on GLUT implementations for the Window System boolean indicating if the frame buffer configuration visual is of type GrayScale Default is IsEqualTo",
          "hierarchy": "Graphics UI GLUT Initialization",
          "module": "Graphics.UI.GLUT.Initialization",
          "name": "DisplayXGrayScale",
          "package": "GLUT",
          "partial": "Display XGray Scale",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Initialization.html#v:DisplayXGrayScale"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eOnly recongized on GLUT implementations for the X Window\n   System, boolean indicating if the frame buffer\n   configuration's X visual is of type \u003ccode\u003ePsuedoColor\u003c/code\u003e.\n   Default is \"\u003ccode\u003e\u003ca\u003eIsEqualTo\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e1\u003c/code\u003e\".\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Initialization",
          "name": "DisplayXPseudoColor",
          "package": "GLUT",
          "signature": "DisplayXPseudoColor",
          "source": "src/Graphics-UI-GLUT-Initialization.html#DisplayCapability",
          "type": "function"
        },
        "index": {
          "description": "Only recongized on GLUT implementations for the Window System boolean indicating if the frame buffer configuration visual is of type PsuedoColor Default is IsEqualTo",
          "hierarchy": "Graphics UI GLUT Initialization",
          "module": "Graphics.UI.GLUT.Initialization",
          "name": "DisplayXPseudoColor",
          "package": "GLUT",
          "partial": "Display XPseudo Color",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Initialization.html#v:DisplayXPseudoColor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eOnly recongized on GLUT implementations for the X Window\n   System, boolean indicating if the frame buffer\n   configuration's X visual is of type \u003ccode\u003eStaticColor\u003c/code\u003e.\n   Default is \"\u003ccode\u003e\u003ca\u003eIsEqualTo\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e1\u003c/code\u003e\".\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Initialization",
          "name": "DisplayXStaticColor",
          "package": "GLUT",
          "signature": "DisplayXStaticColor",
          "source": "src/Graphics-UI-GLUT-Initialization.html#DisplayCapability",
          "type": "function"
        },
        "index": {
          "description": "Only recongized on GLUT implementations for the Window System boolean indicating if the frame buffer configuration visual is of type StaticColor Default is IsEqualTo",
          "hierarchy": "Graphics UI GLUT Initialization",
          "module": "Graphics.UI.GLUT.Initialization",
          "name": "DisplayXStaticColor",
          "package": "GLUT",
          "partial": "Display XStatic Color",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Initialization.html#v:DisplayXStaticColor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eOnly recongized on GLUT implementations for the X Window\n   System, boolean indicating if the frame buffer\n   configuration's X visual is of type \u003ccode\u003eStaticGray\u003c/code\u003e.\n   Default is \"\u003ccode\u003e\u003ca\u003eIsEqualTo\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e1\u003c/code\u003e\".\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Initialization",
          "name": "DisplayXStaticGray",
          "package": "GLUT",
          "signature": "DisplayXStaticGray",
          "source": "src/Graphics-UI-GLUT-Initialization.html#DisplayCapability",
          "type": "function"
        },
        "index": {
          "description": "Only recongized on GLUT implementations for the Window System boolean indicating if the frame buffer configuration visual is of type StaticGray Default is IsEqualTo",
          "hierarchy": "Graphics UI GLUT Initialization",
          "module": "Graphics.UI.GLUT.Initialization",
          "name": "DisplayXStaticGray",
          "package": "GLUT",
          "partial": "Display XStatic Gray",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Initialization.html#v:DisplayXStaticGray"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eOnly recongized on GLUT implementations for the X Window\n   System, boolean indicating if the frame buffer\n   configuration's X visual is of type \u003ccode\u003eTrueColor\u003c/code\u003e. Default\n   is \"\u003ccode\u003e\u003ca\u003eIsEqualTo\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e1\u003c/code\u003e\".\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Initialization",
          "name": "DisplayXTrueColor",
          "package": "GLUT",
          "signature": "DisplayXTrueColor",
          "source": "src/Graphics-UI-GLUT-Initialization.html#DisplayCapability",
          "type": "function"
        },
        "index": {
          "description": "Only recongized on GLUT implementations for the Window System boolean indicating if the frame buffer configuration visual is of type TrueColor Default is IsEqualTo",
          "hierarchy": "Graphics UI GLUT Initialization",
          "module": "Graphics.UI.GLUT.Initialization",
          "name": "DisplayXTrueColor",
          "package": "GLUT",
          "partial": "Display XTrue Color",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Initialization.html#v:DisplayXTrueColor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eOnly recongized on GLUT implementations for the X Window\n   System, this capability name matches the X visual ID by\n   number. \u003ccode\u003e\u003ca\u003eDisplayXVisual\u003c/a\u003e\u003c/code\u003e requires a relation and numeric value.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Initialization",
          "name": "DisplayXVisual",
          "package": "GLUT",
          "signature": "DisplayXVisual",
          "source": "src/Graphics-UI-GLUT-Initialization.html#DisplayCapability",
          "type": "function"
        },
        "index": {
          "description": "Only recongized on GLUT implementations for the Window System this capability name matches the visual ID by number DisplayXVisual requires relation and numeric value",
          "hierarchy": "Graphics UI GLUT Initialization",
          "module": "Graphics.UI.GLUT.Initialization",
          "name": "DisplayXVisual",
          "package": "GLUT",
          "partial": "Display XVisual",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Initialization.html#v:DisplayXVisual"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSelect a double buffered window. This overrides \u003ccode\u003e\u003ca\u003eSingleBuffered\u003c/a\u003e\u003c/code\u003e if it\n is also specified.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Initialization",
          "name": "DoubleBuffered",
          "package": "GLUT",
          "signature": "DoubleBuffered",
          "source": "src/Graphics-UI-GLUT-Initialization.html#DisplayMode",
          "type": "function"
        },
        "index": {
          "description": "Select double buffered window This overrides SingleBuffered if it is also specified",
          "hierarchy": "Graphics UI GLUT Initialization",
          "module": "Graphics.UI.GLUT.Initialization",
          "name": "DoubleBuffered",
          "package": "GLUT",
          "partial": "Double Buffered",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Initialization.html#v:DoubleBuffered"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTry to use direct rendering, issue an error and terminate the program\n if this is not possible.This corresponds to the command line argument\n \u003ccode\u003e-direct\u003c/code\u003e, see \u003ccode\u003e\u003ca\u003einitialize\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Initialization",
          "name": "ForceDirectContext",
          "package": "GLUT",
          "signature": "ForceDirectContext",
          "source": "src/Graphics-UI-GLUT-Initialization.html#DirectRendering",
          "type": "function"
        },
        "index": {
          "description": "Try to use direct rendering issue an error and terminate the program if this is not possible.This corresponds to the command line argument direct see initialize",
          "hierarchy": "Graphics UI GLUT Initialization",
          "module": "Graphics.UI.GLUT.Initialization",
          "name": "ForceDirectContext",
          "package": "GLUT",
          "partial": "Force Direct Context",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Initialization.html#v:ForceDirectContext"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRendering is always done through the X server. This corresponds to\n the command line argument \u003ccode\u003e-indirect\u003c/code\u003e, see \u003ccode\u003e\u003ca\u003einitialize\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Initialization",
          "name": "ForceIndirectContext",
          "package": "GLUT",
          "signature": "ForceIndirectContext",
          "source": "src/Graphics-UI-GLUT-Initialization.html#DirectRendering",
          "type": "function"
        },
        "index": {
          "description": "Rendering is always done through the server This corresponds to the command line argument indirect see initialize",
          "hierarchy": "Graphics UI GLUT Initialization",
          "module": "Graphics.UI.GLUT.Initialization",
          "name": "ForceIndirectContext",
          "package": "GLUT",
          "partial": "Force Indirect Context",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Initialization.html#v:ForceIndirectContext"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eForward-compatible contexts are defined only for OpenGL versions 3.0\n and later. They must not support functionality marked as \u003cem\u003edeprecated\u003c/em\u003e\n by that version of the API, while a non-forward-compatible context must\n support all functionality in that version, deprecated or not.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Initialization",
          "name": "ForwardCompatibleContext",
          "package": "GLUT",
          "signature": "ForwardCompatibleContext",
          "source": "src/Graphics-UI-GLUT-Initialization.html#ContextFlag",
          "type": "function"
        },
        "index": {
          "description": "Forward-compatible contexts are defined only for OpenGL versions and later They must not support functionality marked as deprecated by that version of the API while non-forward-compatible context must support all functionality in that version deprecated or not",
          "hierarchy": "Graphics UI GLUT Initialization",
          "module": "Graphics.UI.GLUT.Initialization",
          "name": "ForwardCompatibleContext",
          "package": "GLUT",
          "partial": "Forward Compatible Context",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Initialization.html#v:ForwardCompatibleContext"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSelect a color index mode window. This overrides \u003ccode\u003e\u003ca\u003eRGBAMode\u003c/a\u003e\u003c/code\u003e if it is\n also specified.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Initialization",
          "name": "IndexMode",
          "package": "GLUT",
          "signature": "IndexMode",
          "source": "src/Graphics-UI-GLUT-Initialization.html#DisplayMode",
          "type": "function"
        },
        "index": {
          "description": "Select color index mode window This overrides RGBAMode if it is also specified",
          "hierarchy": "Graphics UI GLUT Initialization",
          "module": "Graphics.UI.GLUT.Initialization",
          "name": "IndexMode",
          "package": "GLUT",
          "partial": "Index Mode",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Initialization.html#v:IndexMode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGreater than or equal and preferring more instead of\n   less. This relation is useful for allocating\n   resources like color precision or depth buffer\n   precision where the maximum precision is generally\n   preferred. Contrast with \u003ccode\u003e\u003ca\u003eIsNotLessThan\u003c/a\u003e\u003c/code\u003e relation.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Initialization",
          "name": "IsAtLeast",
          "package": "GLUT",
          "signature": "IsAtLeast",
          "source": "src/Graphics-UI-GLUT-Types.html#Relation",
          "type": "function"
        },
        "index": {
          "description": "Greater than or equal and preferring more instead of less This relation is useful for allocating resources like color precision or depth buffer precision where the maximum precision is generally preferred Contrast with IsNotLessThan relation",
          "hierarchy": "Graphics UI GLUT Initialization",
          "module": "Graphics.UI.GLUT.Initialization",
          "name": "IsAtLeast",
          "package": "GLUT",
          "partial": "Is At Least",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Initialization.html#v:IsAtLeast"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEqual.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Initialization",
          "name": "IsEqualTo",
          "package": "GLUT",
          "signature": "IsEqualTo",
          "source": "src/Graphics-UI-GLUT-Types.html#Relation",
          "type": "function"
        },
        "index": {
          "description": "Equal",
          "hierarchy": "Graphics UI GLUT Initialization",
          "module": "Graphics.UI.GLUT.Initialization",
          "name": "IsEqualTo",
          "package": "GLUT",
          "partial": "Is Equal To",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Initialization.html#v:IsEqualTo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGreater than and preferring larger differences (the\n   most is best).\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Initialization",
          "name": "IsGreaterThan",
          "package": "GLUT",
          "signature": "IsGreaterThan",
          "source": "src/Graphics-UI-GLUT-Types.html#Relation",
          "type": "function"
        },
        "index": {
          "description": "Greater than and preferring larger differences the most is best",
          "hierarchy": "Graphics UI GLUT Initialization",
          "module": "Graphics.UI.GLUT.Initialization",
          "name": "IsGreaterThan",
          "package": "GLUT",
          "partial": "Is Greater Than",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Initialization.html#v:IsGreaterThan"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLess than and preferring larger difference (the least\n   is best).\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Initialization",
          "name": "IsLessThan",
          "package": "GLUT",
          "signature": "IsLessThan",
          "source": "src/Graphics-UI-GLUT-Types.html#Relation",
          "type": "function"
        },
        "index": {
          "description": "Less than and preferring larger difference the least is best",
          "hierarchy": "Graphics UI GLUT Initialization",
          "module": "Graphics.UI.GLUT.Initialization",
          "name": "IsLessThan",
          "package": "GLUT",
          "partial": "Is Less Than",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Initialization.html#v:IsLessThan"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eNot equal.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Initialization",
          "name": "IsNotEqualTo",
          "package": "GLUT",
          "signature": "IsNotEqualTo",
          "source": "src/Graphics-UI-GLUT-Types.html#Relation",
          "type": "function"
        },
        "index": {
          "description": "Not equal",
          "hierarchy": "Graphics UI GLUT Initialization",
          "module": "Graphics.UI.GLUT.Initialization",
          "name": "IsNotEqualTo",
          "package": "GLUT",
          "partial": "Is Not Equal To",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Initialization.html#v:IsNotEqualTo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLess than or equal and preferring larger difference\n   (the least is best).\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Initialization",
          "name": "IsNotGreaterThan",
          "package": "GLUT",
          "signature": "IsNotGreaterThan",
          "source": "src/Graphics-UI-GLUT-Types.html#Relation",
          "type": "function"
        },
        "index": {
          "description": "Less than or equal and preferring larger difference the least is best",
          "hierarchy": "Graphics UI GLUT Initialization",
          "module": "Graphics.UI.GLUT.Initialization",
          "name": "IsNotGreaterThan",
          "package": "GLUT",
          "partial": "Is Not Greater Than",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Initialization.html#v:IsNotGreaterThan"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGreater than or equal but preferring less instead of\n   more. This relation is useful for allocating\n   resources such as stencil bits or auxillary color\n   buffers where you would rather not over-allocate.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Initialization",
          "name": "IsNotLessThan",
          "package": "GLUT",
          "signature": "IsNotLessThan",
          "source": "src/Graphics-UI-GLUT-Types.html#Relation",
          "type": "function"
        },
        "index": {
          "description": "Greater than or equal but preferring less instead of more This relation is useful for allocating resources such as stencil bits or auxillary color buffers where you would rather not over-allocate",
          "hierarchy": "Graphics UI GLUT Initialization",
          "module": "Graphics.UI.GLUT.Initialization",
          "name": "IsNotLessThan",
          "package": "GLUT",
          "partial": "Is Not Less Than",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Initialization.html#v:IsNotLessThan"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSelect a window with a \"luminance\" color model. This model provides\n the functionality of OpenGL's RGBA color model, but the green and blue\n components are not maintained in the frame buffer. Instead each pixel's\n red component is converted to an index between zero and\n  \u003ccode\u003e\u003ca\u003enumColorMapEntries\u003c/a\u003e\u003c/code\u003e and looked up in a\n per-window color map to determine the color of pixels within the window.\n The initial colormap of \u003ccode\u003e\u003ca\u003eLuminanceMode\u003c/a\u003e\u003c/code\u003e windows is initialized to be a\n linear gray ramp, but can be modified with GLUT's colormap actions.\n \u003cem\u003eImplementation Notes:\u003c/em\u003e \u003ccode\u003e\u003ca\u003eLuminanceMode\u003c/a\u003e\u003c/code\u003e is not supported on most OpenGL\n platforms.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Initialization",
          "name": "LuminanceMode",
          "package": "GLUT",
          "signature": "LuminanceMode",
          "source": "src/Graphics-UI-GLUT-Initialization.html#DisplayMode",
          "type": "function"
        },
        "index": {
          "description": "Select window with luminance color model This model provides the functionality of OpenGL RGBA color model but the green and blue components are not maintained in the frame buffer Instead each pixel red component is converted to an index between zero and numColorMapEntries and looked up in per-window color map to determine the color of pixels within the window The initial colormap of LuminanceMode windows is initialized to be linear gray ramp but can be modified with GLUT colormap actions Implementation Notes LuminanceMode is not supported on most OpenGL platforms",
          "hierarchy": "Graphics UI GLUT Initialization",
          "module": "Graphics.UI.GLUT.Initialization",
          "name": "LuminanceMode",
          "package": "GLUT",
          "partial": "Luminance Mode",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Initialization.html#v:LuminanceMode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSelect a window with multisampling support. If multisampling is not\n available, a non-multisampling window will automatically be chosen.\n Note: both the OpenGL client-side and server-side implementations must\n support the \u003ccode\u003eGLX_SAMPLE_SGIS\u003c/code\u003e extension for multisampling to be\n available. Deprecated, use \u003ccode\u003e\u003ca\u003eWithSamplesPerPixel\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Initialization",
          "name": "Multisampling",
          "package": "GLUT",
          "signature": "Multisampling",
          "source": "src/Graphics-UI-GLUT-Initialization.html#DisplayMode",
          "type": "function"
        },
        "index": {
          "description": "Select window with multisampling support If multisampling is not available non-multisampling window will automatically be chosen Note both the OpenGL client-side and server-side implementations must support the GLX SAMPLE SGIS extension for multisampling to be available Deprecated use WithSamplesPerPixel",
          "hierarchy": "Graphics UI GLUT Initialization",
          "module": "Graphics.UI.GLUT.Initialization",
          "name": "Multisampling",
          "package": "GLUT",
          "partial": "Multisampling",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Initialization.html#v:Multisampling"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSelect an RGBA mode window. This is the default if neither \u003ccode\u003e\u003ca\u003eRGBAMode\u003c/a\u003e\u003c/code\u003e\n nor \u003ccode\u003e\u003ca\u003eIndexMode\u003c/a\u003e\u003c/code\u003e are specified.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Initialization",
          "name": "RGBAMode",
          "package": "GLUT",
          "signature": "RGBAMode",
          "source": "src/Graphics-UI-GLUT-Initialization.html#DisplayMode",
          "type": "function"
        },
        "index": {
          "description": "Select an RGBA mode window This is the default if neither RGBAMode nor IndexMode are specified",
          "hierarchy": "Graphics UI GLUT Initialization",
          "module": "Graphics.UI.GLUT.Initialization",
          "name": "RGBAMode",
          "package": "GLUT",
          "partial": "RGBAMode",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Initialization.html#v:RGBAMode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn alias for \u003ccode\u003e\u003ca\u003eRGBAMode\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Initialization",
          "name": "RGBMode",
          "package": "GLUT",
          "signature": "RGBMode",
          "source": "src/Graphics-UI-GLUT-Initialization.html#DisplayMode",
          "type": "function"
        },
        "index": {
          "description": "An alias for RGBAMode",
          "hierarchy": "Graphics UI GLUT Initialization",
          "module": "Graphics.UI.GLUT.Initialization",
          "name": "RGBMode",
          "package": "GLUT",
          "partial": "RGBMode",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Initialization.html#v:RGBMode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSelect an sRGB mode window (\u003cem\u003efreeglut only\u003c/em\u003e).\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Initialization",
          "name": "SRGBMode",
          "package": "GLUT",
          "signature": "SRGBMode",
          "source": "src/Graphics-UI-GLUT-Initialization.html#DisplayMode",
          "type": "function"
        },
        "index": {
          "description": "Select an sRGB mode window freeglut only",
          "hierarchy": "Graphics UI GLUT Initialization",
          "module": "Graphics.UI.GLUT.Initialization",
          "name": "SRGBMode",
          "package": "GLUT",
          "partial": "SRGBMode",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Initialization.html#v:SRGBMode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSelect a single buffered window. This is the default if neither\n \u003ccode\u003e\u003ca\u003eDoubleBuffered\u003c/a\u003e\u003c/code\u003e nor \u003ccode\u003e\u003ca\u003eSingleBuffered\u003c/a\u003e\u003c/code\u003e are specified.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Initialization",
          "name": "SingleBuffered",
          "package": "GLUT",
          "signature": "SingleBuffered",
          "source": "src/Graphics-UI-GLUT-Initialization.html#DisplayMode",
          "type": "function"
        },
        "index": {
          "description": "Select single buffered window This is the default if neither DoubleBuffered nor SingleBuffered are specified",
          "hierarchy": "Graphics UI GLUT Initialization",
          "module": "Graphics.UI.GLUT.Initialization",
          "name": "SingleBuffered",
          "package": "GLUT",
          "partial": "Single Buffered",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Initialization.html#v:SingleBuffered"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSelect a stereo window.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Initialization",
          "name": "Stereoscopic",
          "package": "GLUT",
          "signature": "Stereoscopic",
          "source": "src/Graphics-UI-GLUT-Initialization.html#DisplayMode",
          "type": "function"
        },
        "index": {
          "description": "Select stereo window",
          "hierarchy": "Graphics UI GLUT Initialization",
          "module": "Graphics.UI.GLUT.Initialization",
          "name": "Stereoscopic",
          "package": "GLUT",
          "partial": "Stereoscopic",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Initialization.html#v:Stereoscopic"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTry to use direct rendering, issue a warning and use indirect\n rendering if this is not possible.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Initialization",
          "name": "TryDirectContext",
          "package": "GLUT",
          "signature": "TryDirectContext",
          "source": "src/Graphics-UI-GLUT-Initialization.html#DirectRendering",
          "type": "function"
        },
        "index": {
          "description": "Try to use direct rendering issue warning and use indirect rendering if this is not possible",
          "hierarchy": "Graphics UI GLUT Initialization",
          "module": "Graphics.UI.GLUT.Initialization",
          "name": "TryDirectContext",
          "package": "GLUT",
          "partial": "Try Direct Context",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Initialization.html#v:TryDirectContext"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRe-use the current rendering context.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Initialization",
          "name": "UseCurrentContext",
          "package": "GLUT",
          "signature": "UseCurrentContext",
          "source": "src/Graphics-UI-GLUT-Initialization.html#RenderingContext",
          "type": "function"
        },
        "index": {
          "description": "Re-use the current rendering context",
          "hierarchy": "Graphics UI GLUT Initialization",
          "module": "Graphics.UI.GLUT.Initialization",
          "name": "UseCurrentContext",
          "package": "GLUT",
          "partial": "Use Current Context",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Initialization.html#v:UseCurrentContext"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA description of a capability with a specific relation to a numeric\n   value.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Initialization",
          "name": "Where",
          "package": "GLUT",
          "signature": "Where DisplayCapability Relation Int",
          "source": "src/Graphics-UI-GLUT-Initialization.html#DisplayCapabilityDescription",
          "type": "function"
        },
        "index": {
          "description": "description of capability with specific relation to numeric value",
          "hierarchy": "Graphics UI GLUT Initialization",
          "module": "Graphics.UI.GLUT.Initialization",
          "name": "Where",
          "package": "GLUT",
          "partial": "Where",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Initialization.html#v:Where"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWhen the relation and numeric value are not specified, each capability\n   has a different default, see the different constructors of\n   \u003ccode\u003e\u003ca\u003eDisplayCapability\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Initialization",
          "name": "With",
          "package": "GLUT",
          "signature": "With DisplayCapability",
          "source": "src/Graphics-UI-GLUT-Initialization.html#DisplayCapabilityDescription",
          "type": "function"
        },
        "index": {
          "description": "When the relation and numeric value are not specified each capability has different default see the different constructors of DisplayCapability",
          "hierarchy": "Graphics UI GLUT Initialization",
          "module": "Graphics.UI.GLUT.Initialization",
          "name": "With",
          "package": "GLUT",
          "partial": "With",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Initialization.html#v:With"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSelect a window with an accumulation buffer.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Initialization",
          "name": "WithAccumBuffer",
          "package": "GLUT",
          "signature": "WithAccumBuffer",
          "source": "src/Graphics-UI-GLUT-Initialization.html#DisplayMode",
          "type": "function"
        },
        "index": {
          "description": "Select window with an accumulation buffer",
          "hierarchy": "Graphics UI GLUT Initialization",
          "module": "Graphics.UI.GLUT.Initialization",
          "name": "WithAccumBuffer",
          "package": "GLUT",
          "partial": "With Accum Buffer",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Initialization.html#v:WithAccumBuffer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSelect a window with an alpha component to the color buffer(s).\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Initialization",
          "name": "WithAlphaComponent",
          "package": "GLUT",
          "signature": "WithAlphaComponent",
          "source": "src/Graphics-UI-GLUT-Initialization.html#DisplayMode",
          "type": "function"
        },
        "index": {
          "description": "Select window with an alpha component to the color buffer",
          "hierarchy": "Graphics UI GLUT Initialization",
          "module": "Graphics.UI.GLUT.Initialization",
          "name": "WithAlphaComponent",
          "package": "GLUT",
          "partial": "With Alpha Component",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Initialization.html#v:WithAlphaComponent"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e(\u003cem\u003efreeglut only\u003c/em\u003e) Select a window with \u003cem\u003en\u003c/em\u003e (1 .. 4) auxiliary buffers.\n Any \u003cem\u003en\u003c/em\u003e outside the range 1 .. 4 is a fatal error.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Initialization",
          "name": "WithAuxBuffers",
          "package": "GLUT",
          "signature": "WithAuxBuffers Int",
          "source": "src/Graphics-UI-GLUT-Initialization.html#DisplayMode",
          "type": "function"
        },
        "index": {
          "description": "freeglut only Select window with auxiliary buffers Any outside the range is fatal error",
          "hierarchy": "Graphics UI GLUT Initialization",
          "module": "Graphics.UI.GLUT.Initialization",
          "name": "WithAuxBuffers",
          "package": "GLUT",
          "partial": "With Aux Buffers",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Initialization.html#v:WithAuxBuffers"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSelect a window with a depth buffer.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Initialization",
          "name": "WithDepthBuffer",
          "package": "GLUT",
          "signature": "WithDepthBuffer",
          "source": "src/Graphics-UI-GLUT-Initialization.html#DisplayMode",
          "type": "function"
        },
        "index": {
          "description": "Select window with depth buffer",
          "hierarchy": "Graphics UI GLUT Initialization",
          "module": "Graphics.UI.GLUT.Initialization",
          "name": "WithDepthBuffer",
          "package": "GLUT",
          "partial": "With Depth Buffer",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Initialization.html#v:WithDepthBuffer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSelect a window with multisampling, using the given samples per pixel.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Initialization",
          "name": "WithSamplesPerPixel",
          "package": "GLUT",
          "signature": "WithSamplesPerPixel Int",
          "source": "src/Graphics-UI-GLUT-Initialization.html#DisplayMode",
          "type": "function"
        },
        "index": {
          "description": "Select window with multisampling using the given samples per pixel",
          "hierarchy": "Graphics UI GLUT Initialization",
          "module": "Graphics.UI.GLUT.Initialization",
          "name": "WithSamplesPerPixel",
          "package": "GLUT",
          "partial": "With Samples Per Pixel",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Initialization.html#v:WithSamplesPerPixel"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSelect a window with a stencil buffer.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Initialization",
          "name": "WithStencilBuffer",
          "package": "GLUT",
          "signature": "WithStencilBuffer",
          "source": "src/Graphics-UI-GLUT-Initialization.html#DisplayMode",
          "type": "function"
        },
        "index": {
          "description": "Select window with stencil buffer",
          "hierarchy": "Graphics UI GLUT Initialization",
          "module": "Graphics.UI.GLUT.Initialization",
          "name": "WithStencilBuffer",
          "package": "GLUT",
          "partial": "With Stencil Buffer",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Initialization.html#v:WithStencilBuffer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e(\u003cem\u003efreeglut on X11 only\u003c/em\u003e) Controls which kind of rendering context is\n created when a new one is required.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Initialization",
          "name": "directRendering",
          "package": "GLUT",
          "signature": "StateVar DirectRendering",
          "source": "src/Graphics-UI-GLUT-Initialization.html#directRendering",
          "type": "function"
        },
        "index": {
          "description": "freeglut on X11 only Controls which kind of rendering context is created when new one is required",
          "hierarchy": "Graphics UI GLUT Initialization",
          "module": "Graphics.UI.GLUT.Initialization",
          "name": "directRendering",
          "package": "GLUT",
          "partial": "Rendering",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Initialization.html#v:directRendering"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eContains \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e if the \u003cem\u003ecurrent display mode\u003c/em\u003e is supported, \u003ccode\u003e\u003ca\u003eFalse\u003c/a\u003e\u003c/code\u003e\n otherwise.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Initialization",
          "name": "displayModePossible",
          "package": "GLUT",
          "signature": "GettableStateVar Bool",
          "source": "src/Graphics-UI-GLUT-Initialization.html#displayModePossible",
          "type": "function"
        },
        "index": {
          "description": "Contains True if the current display mode is supported False otherwise",
          "hierarchy": "Graphics UI GLUT Initialization",
          "module": "Graphics.UI.GLUT.Initialization",
          "name": "displayModePossible",
          "package": "GLUT",
          "partial": "Mode Possible",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Initialization.html#v:displayModePossible"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e(\u003cem\u003efreeglut only\u003c/em\u003e) De-initialize GLUT. After this, one has to use\n \u003ccode\u003e\u003ca\u003einitialize\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003egetArgsAndInitialize\u003c/a\u003e\u003c/code\u003e to initialize GLUT again.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Initialization",
          "name": "exit",
          "package": "GLUT",
          "signature": "IO ()",
          "source": "src/Graphics-UI-GLUT-Initialization.html#exit",
          "type": "function"
        },
        "index": {
          "description": "freeglut only De-initialize GLUT After this one has to use initialize or getArgsAndInitialize to initialize GLUT again",
          "hierarchy": "Graphics UI GLUT Initialization",
          "module": "Graphics.UI.GLUT.Initialization",
          "name": "exit",
          "normalized": "IO()",
          "package": "GLUT",
          "signature": "IO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Initialization.html#v:exit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvenience action: Initialize GLUT, returning the program name and any\n non-GLUT command line arguments.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Initialization",
          "name": "getArgsAndInitialize",
          "package": "GLUT",
          "signature": "IO (String, [String])",
          "source": "src/Graphics-UI-GLUT-Initialization.html#getArgsAndInitialize",
          "type": "function"
        },
        "index": {
          "description": "Convenience action Initialize GLUT returning the program name and any non-GLUT command line arguments",
          "hierarchy": "Graphics UI GLUT Initialization",
          "module": "Graphics.UI.GLUT.Initialization",
          "name": "getArgsAndInitialize",
          "normalized": "IO(String,[String])",
          "package": "GLUT",
          "partial": "Args And Initialize",
          "signature": "IO(String,[String])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Initialization.html#v:getArgsAndInitialize"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e(\u003cem\u003efreeglut only\u003c/em\u003e) Controls the set of flags for the rendering context.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Initialization",
          "name": "initialContextFlags",
          "package": "GLUT",
          "signature": "StateVar [ContextFlag]",
          "source": "src/Graphics-UI-GLUT-Initialization.html#initialContextFlags",
          "type": "function"
        },
        "index": {
          "description": "freeglut only Controls the set of flags for the rendering context",
          "hierarchy": "Graphics UI GLUT Initialization",
          "module": "Graphics.UI.GLUT.Initialization",
          "name": "initialContextFlags",
          "normalized": "StateVar[ContextFlag]",
          "package": "GLUT",
          "partial": "Context Flags",
          "signature": "StateVar[ContextFlag]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Initialization.html#v:initialContextFlags"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e(\u003cem\u003efreeglut only\u003c/em\u003e) Controls the set of profiles for the rendering context.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Initialization",
          "name": "initialContextProfile",
          "package": "GLUT",
          "signature": "StateVar [ContextProfile]",
          "source": "src/Graphics-UI-GLUT-Initialization.html#initialContextProfile",
          "type": "function"
        },
        "index": {
          "description": "freeglut only Controls the set of profiles for the rendering context",
          "hierarchy": "Graphics UI GLUT Initialization",
          "module": "Graphics.UI.GLUT.Initialization",
          "name": "initialContextProfile",
          "normalized": "StateVar[ContextProfile]",
          "package": "GLUT",
          "partial": "Context Profile",
          "signature": "StateVar[ContextProfile]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Initialization.html#v:initialContextProfile"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e(\u003cem\u003efreeglut only\u003c/em\u003e) Controls the API major/minor version of the OpenGL\n context. If a version less than or equal to 2.1 is requested, the context\n returned may implement any version no less than that requested and no\n greater than 2.1. If version 3.0 is requested, the context returned must\n implement exactly version 3.0. Versioning behavior once GL versions beyond\n 3.0 are defined will be defined by an amendment to the OpenGL specification\n to define dependencies on such GL versions.\n\u003c/p\u003e\u003cp\u003e\u003ccode\u003e\u003ca\u003eglVersion\u003c/a\u003e\u003c/code\u003e and\n \u003ccode\u003e\u003ca\u003emajorMinor\u003c/a\u003e\u003c/code\u003e will return the\n actual version supported by a context.\n\u003c/p\u003e\u003cp\u003eThe default context version is (1, 0), which will typically return an\n OpenGL 2.1 context, if one is available.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Initialization",
          "name": "initialContextVersion",
          "package": "GLUT",
          "signature": "StateVar (Int, Int)",
          "source": "src/Graphics-UI-GLUT-Initialization.html#initialContextVersion",
          "type": "function"
        },
        "index": {
          "description": "freeglut only Controls the API major minor version of the OpenGL context If version less than or equal to is requested the context returned may implement any version no less than that requested and no greater than If version is requested the context returned must implement exactly version Versioning behavior once GL versions beyond are defined will be defined by an amendment to the OpenGL specification to define dependencies on such GL versions glVersion and majorMinor will return the actual version supported by context The default context version is which will typically return an OpenGL context if one is available",
          "hierarchy": "Graphics UI GLUT Initialization",
          "module": "Graphics.UI.GLUT.Initialization",
          "name": "initialContextVersion",
          "normalized": "StateVar(Int,Int)",
          "package": "GLUT",
          "partial": "Context Version",
          "signature": "StateVar(Int,Int)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Initialization.html#v:initialContextVersion"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eControls the \u003cem\u003einitial display mode\u003c/em\u003e used when creating top-level windows,\n subwindows, and overlays to determine the OpenGL display mode for the\n to-be-created window or overlay. It is described by a list of zero or more\n capability descriptions, which are translated into a set of criteria used to\n select the appropriate frame buffer configuration. The criteria are matched\n in strict left to right order of precdence. That is, the first specified\n criterion (leftmost) takes precedence over the later criteria for non-exact\n criteria (\u003ccode\u003e\u003ca\u003eIsGreaterThan\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eIsLessThan\u003c/a\u003e\u003c/code\u003e, etc.). Exact criteria (\u003ccode\u003e\u003ca\u003eIsEqualTo\u003c/a\u003e\u003c/code\u003e,\n \u003ccode\u003e\u003ca\u003eIsNotEqualTo\u003c/a\u003e\u003c/code\u003e) must match exactly so precedence is not relevant.\n\u003c/p\u003e\u003cp\u003eUnspecified capability descriptions will result in unspecified criteria being\n generated. These unspecified criteria help \u003ccode\u003e\u003ca\u003einitialDisplayCapabilities\u003c/a\u003e\u003c/code\u003e\n behave sensibly with terse display mode descriptions.\n\u003c/p\u003e\u003cp\u003eHere is an example using \u003ccode\u003e\u003ca\u003einitialDisplayCapabilities\u003c/a\u003e\u003c/code\u003e:\n\u003c/p\u003e\u003cpre\u003e\n    initialDisplayCapabilities $= [ With  DisplayRGB,\n                                    Where DisplayDepth IsAtLeast 16,\n                                    With  DisplaySamples,\n                                    Where DisplayStencil IsNotLessThan 2,\n                                    With  DisplayDouble ]\n\u003c/pre\u003e\u003cp\u003eThe above call requests a window with an RGBA color model (but requesting\n no bits of alpha), a depth buffer with at least 16 bits of precision but\n preferring more, multisampling if available, at least 2 bits of stencil\n (favoring less stencil to more as long as 2 bits are available), and double\n buffering.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Initialization",
          "name": "initialDisplayCapabilities",
          "package": "GLUT",
          "signature": "SettableStateVar [DisplayCapabilityDescription]",
          "source": "src/Graphics-UI-GLUT-Initialization.html#initialDisplayCapabilities",
          "type": "function"
        },
        "index": {
          "description": "Controls the initial display mode used when creating top-level windows subwindows and overlays to determine the OpenGL display mode for the to-be-created window or overlay It is described by list of zero or more capability descriptions which are translated into set of criteria used to select the appropriate frame buffer configuration The criteria are matched in strict left to right order of precdence That is the first specified criterion leftmost takes precedence over the later criteria for non-exact criteria IsGreaterThan IsLessThan etc Exact criteria IsEqualTo IsNotEqualTo must match exactly so precedence is not relevant Unspecified capability descriptions will result in unspecified criteria being generated These unspecified criteria help initialDisplayCapabilities behave sensibly with terse display mode descriptions Here is an example using initialDisplayCapabilities initialDisplayCapabilities With DisplayRGB Where DisplayDepth IsAtLeast With DisplaySamples Where DisplayStencil IsNotLessThan With DisplayDouble The above call requests window with an RGBA color model but requesting no bits of alpha depth buffer with at least bits of precision but preferring more multisampling if available at least bits of stencil favoring less stencil to more as long as bits are available and double buffering",
          "hierarchy": "Graphics UI GLUT Initialization",
          "module": "Graphics.UI.GLUT.Initialization",
          "name": "initialDisplayCapabilities",
          "normalized": "SettableStateVar[DisplayCapabilityDescription]",
          "package": "GLUT",
          "partial": "Display Capabilities",
          "signature": "SettableStateVar[DisplayCapabilityDescription]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Initialization.html#v:initialDisplayCapabilities"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eControls the \u003cem\u003einitial display mode\u003c/em\u003e used when creating top-level windows,\n subwindows, and overlays to determine the OpenGL display mode for the\n to-be-created window or overlay.\n\u003c/p\u003e\u003cp\u003eNote that \u003ccode\u003e\u003ca\u003eRGBAMode\u003c/a\u003e\u003c/code\u003e selects the RGBA color model, but it does not request any\n bits of alpha (sometimes called an \u003cem\u003ealpha buffer\u003c/em\u003e or \u003cem\u003edestination alpha\u003c/em\u003e)\n be allocated. To request alpha, specify \u003ccode\u003e\u003ca\u003eWithAlphaComponent\u003c/a\u003e\u003c/code\u003e. The same\n applies to \u003ccode\u003e\u003ca\u003eLuminanceMode\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Initialization",
          "name": "initialDisplayMode",
          "package": "GLUT",
          "signature": "StateVar [DisplayMode]",
          "source": "src/Graphics-UI-GLUT-Initialization.html#initialDisplayMode",
          "type": "function"
        },
        "index": {
          "description": "Controls the initial display mode used when creating top-level windows subwindows and overlays to determine the OpenGL display mode for the to-be-created window or overlay Note that RGBAMode selects the RGBA color model but it does not request any bits of alpha sometimes called an alpha buffer or destination alpha be allocated To request alpha specify WithAlphaComponent The same applies to LuminanceMode",
          "hierarchy": "Graphics UI GLUT Initialization",
          "module": "Graphics.UI.GLUT.Initialization",
          "name": "initialDisplayMode",
          "normalized": "StateVar[DisplayMode]",
          "package": "GLUT",
          "partial": "Display Mode",
          "signature": "StateVar[DisplayMode]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Initialization.html#v:initialDisplayMode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eControls the \u003cem\u003einitial window position\u003c/em\u003e.  Windows created by\n \u003ccode\u003e\u003ca\u003ecreateWindow\u003c/a\u003e\u003c/code\u003e will be requested to be created with\n the current \u003cem\u003einitial window position\u003c/em\u003e. The initial value of the /initial\n window position/ GLUT state is \u003ccode\u003e\u003ccode\u003e\u003ca\u003ePosition\u003c/a\u003e\u003c/code\u003e (-1) (-1)\u003c/code\u003e. If either the X or Y\n component of the \u003cem\u003einitial window position\u003c/em\u003e is negative, the actual window\n position is left to the window system to determine.\n\u003c/p\u003e\u003cp\u003eThe intent of the \u003cem\u003einitial window position\u003c/em\u003e is to provide a suggestion to\n the window system for a window's initial position. The window system is\n not obligated to use this information. Therefore, GLUT programs should not\n assume the window was created at the specified position.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Initialization",
          "name": "initialWindowPosition",
          "package": "GLUT",
          "signature": "StateVar Position",
          "source": "src/Graphics-UI-GLUT-Initialization.html#initialWindowPosition",
          "type": "function"
        },
        "index": {
          "description": "Controls the initial window position Windows created by createWindow will be requested to be created with the current initial window position The initial value of the initial window position GLUT state is Position If either the or component of the initial window position is negative the actual window position is left to the window system to determine The intent of the initial window position is to provide suggestion to the window system for window initial position The window system is not obligated to use this information Therefore GLUT programs should not assume the window was created at the specified position",
          "hierarchy": "Graphics UI GLUT Initialization",
          "module": "Graphics.UI.GLUT.Initialization",
          "name": "initialWindowPosition",
          "package": "GLUT",
          "partial": "Window Position",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Initialization.html#v:initialWindowPosition"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eControls the \u003cem\u003einitial window size\u003c/em\u003e.  Windows created by\n \u003ccode\u003e\u003ca\u003ecreateWindow\u003c/a\u003e\u003c/code\u003e will be requested to be created with\n the current \u003cem\u003einitial window size\u003c/em\u003e. The initial value of the /initial window\n size/ GLUT state is \u003ccode\u003e\u003ccode\u003e\u003ca\u003eSize\u003c/a\u003e\u003c/code\u003e 300 300\u003c/code\u003e. If either the width or the height\n component of the \u003cem\u003einitial window size\u003c/em\u003e is non-positive, the actual window\n size is left to the window system to determine.\n\u003c/p\u003e\u003cp\u003eThe intent of the \u003cem\u003einitial window size\u003c/em\u003e is to provide a suggestion to the\n window system for a window's initial size. The window system is not\n obligated to use this information. Therefore, GLUT programs should not\n assume the window was created at the specified size. A GLUT program should\n use the window's reshape callback to determine the true size of the\n window.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Initialization",
          "name": "initialWindowSize",
          "package": "GLUT",
          "signature": "StateVar Size",
          "source": "src/Graphics-UI-GLUT-Initialization.html#initialWindowSize",
          "type": "function"
        },
        "index": {
          "description": "Controls the initial window size Windows created by createWindow will be requested to be created with the current initial window size The initial value of the initial window size GLUT state is Size If either the width or the height component of the initial window size is non-positive the actual window size is left to the window system to determine The intent of the initial window size is to provide suggestion to the window system for window initial size The window system is not obligated to use this information Therefore GLUT programs should not assume the window was created at the specified size GLUT program should use the window reshape callback to determine the true size of the window",
          "hierarchy": "Graphics UI GLUT Initialization",
          "module": "Graphics.UI.GLUT.Initialization",
          "name": "initialWindowSize",
          "package": "GLUT",
          "partial": "Window Size",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Initialization.html#v:initialWindowSize"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGiven the program name and command line arguments, initialize the GLUT\n library and negotiate a session with the window system. During this\n process, \u003ccode\u003e\u003ca\u003einitialize\u003c/a\u003e\u003c/code\u003e may cause the termination of the GLUT program with an\n error message to the user if GLUT cannot be properly initialized.\n Examples of this situation include the failure to connect to the window\n system, the lack of window system support for OpenGL, and invalid command\n line options.\n\u003c/p\u003e\u003cp\u003e\u003ccode\u003e\u003ca\u003einitialize\u003c/a\u003e\u003c/code\u003e also processes command line options, but the specific options\n parsed are window system dependent. Any command line arguments which are\n not GLUT-specific are returned.\n\u003c/p\u003e\u003cp\u003e\u003cem\u003eX Implementation Notes:\u003c/em\u003e The X Window System specific options parsed by\n \u003ccode\u003e\u003ca\u003einitialize\u003c/a\u003e\u003c/code\u003e are as follows:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e \u003ccode\u003e-display \u003cem\u003eDISPLAY\u003c/em\u003e\u003c/code\u003e: Specify the X server to connect to. If not specified,\n   the value of the \u003ccode\u003eDISPLAY\u003c/code\u003e environment variable is used.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e-geometry \u003cem\u003eWxH+X+Y\u003c/em\u003e\u003c/code\u003e: Determines where windows should be created on the\n   screen. The parameter following \u003ccode\u003e-geometry\u003c/code\u003e should be formatted as a\n   standard X geometry specification. The effect of using this option is to\n   change the GLUT initial size and initial position the same as if\n   \u003ccode\u003e\u003ca\u003einitialWindowSize\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003einitialWindowPosition\u003c/a\u003e\u003c/code\u003e were modified directly.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e-iconic\u003c/code\u003e: Requests all top-level windows be created in an iconic state.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e-indirect\u003c/code\u003e: Force the use of indirect OpenGL rendering contexts.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e-direct\u003c/code\u003e: Force the use of direct OpenGL rendering contexts (not all GLX\n   implementations support direct rendering contexts). A fatal error is\n   generated if direct rendering is not supported by the OpenGL\n   implementation. If neither \u003ccode\u003e-indirect\u003c/code\u003e or \u003ccode\u003e-direct\u003c/code\u003e are used to force a\n   particular behavior, GLUT will attempt to use direct rendering if\n   possible and otherwise fallback to indirect rendering.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e-gldebug\u003c/code\u003e: After processing callbacks and/or events, call\n   \u003ccode\u003e\u003ca\u003ereportErrors\u003c/a\u003e\u003c/code\u003e to check if there are any pending\n   OpenGL errors. Using this option is helpful in detecting OpenGL run-time\n   errors.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e-sync\u003c/code\u003e: Enable synchronous X protocol transactions. This option makes\n   it easier to track down potential X protocol errors.\n\u003c/li\u003e\u003c/ul\u003e",
          "module": "Graphics.UI.GLUT.Initialization",
          "name": "initialize",
          "package": "GLUT",
          "signature": "String-\u003e [String]-\u003e IO [String]",
          "type": "function"
        },
        "index": {
          "description": "Given the program name and command line arguments initialize the GLUT library and negotiate session with the window system During this process initialize may cause the termination of the GLUT program with an error message to the user if GLUT cannot be properly initialized Examples of this situation include the failure to connect to the window system the lack of window system support for OpenGL and invalid command line options initialize also processes command line options but the specific options parsed are window system dependent Any command line arguments which are not GLUT-specific are returned Implementation Notes The Window System specific options parsed by initialize are as follows display DISPLAY Specify the server to connect to If not specified the value of the DISPLAY environment variable is used geometry WxH Determines where windows should be created on the screen The parameter following geometry should be formatted as standard geometry specification The effect of using this option is to change the GLUT initial size and initial position the same as if initialWindowSize or initialWindowPosition were modified directly iconic Requests all top-level windows be created in an iconic state indirect Force the use of indirect OpenGL rendering contexts direct Force the use of direct OpenGL rendering contexts not all GLX implementations support direct rendering contexts fatal error is generated if direct rendering is not supported by the OpenGL implementation If neither indirect or direct are used to force particular behavior GLUT will attempt to use direct rendering if possible and otherwise fallback to indirect rendering gldebug After processing callbacks and or events call reportErrors to check if there are any pending OpenGL errors Using this option is helpful in detecting OpenGL run-time errors sync Enable synchronous protocol transactions This option makes it easier to track down potential protocol errors",
          "hierarchy": "Graphics UI GLUT Initialization",
          "module": "Graphics.UI.GLUT.Initialization",
          "name": "initialize",
          "normalized": "String-\u003e[String]-\u003eIO[String]",
          "package": "GLUT",
          "signature": "String-\u003e[String]-\u003eIO[String]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Initialization.html#v:initialize"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e(\u003cem\u003efreeglut only\u003c/em\u003e) Controls the creation of rendering contexts for new\n windows.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Initialization",
          "name": "renderingContext",
          "package": "GLUT",
          "signature": "StateVar RenderingContext",
          "source": "src/Graphics-UI-GLUT-Initialization.html#renderingContext",
          "type": "function"
        },
        "index": {
          "description": "freeglut only Controls the creation of rendering contexts for new windows",
          "hierarchy": "Graphics UI GLUT Initialization",
          "module": "Graphics.UI.GLUT.Initialization",
          "name": "renderingContext",
          "package": "GLUT",
          "partial": "Context",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Initialization.html#v:renderingContext"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eGLUT supports simple cascading pop-up menus. They are designed to let a user\n select various modes within a program. The functionality is simple and\n minimalistic and is meant to be that way. Do not mistake GLUT's pop-up menu\n facility with an attempt to create a full-featured user interface.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Graphics.UI.GLUT.Menu",
          "name": "Menu",
          "package": "GLUT",
          "source": "src/Graphics-UI-GLUT-Menu.html",
          "type": "module"
        },
        "index": {
          "description": "GLUT supports simple cascading pop-up menus They are designed to let user select various modes within program The functionality is simple and minimalistic and is meant to be that way Do not mistake GLUT pop-up menu facility with an attempt to create full-featured user interface",
          "hierarchy": "Graphics UI GLUT Menu",
          "module": "Graphics.UI.GLUT.Menu",
          "name": "Menu",
          "package": "GLUT",
          "partial": "Menu",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Menu.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA menu is simply a list of menu items, possibly with an associated font.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Menu",
          "name": "Menu",
          "package": "GLUT",
          "source": "src/Graphics-UI-GLUT-Menu.html#Menu",
          "type": "data"
        },
        "index": {
          "description": "menu is simply list of menu items possibly with an associated font",
          "hierarchy": "Graphics UI GLUT Menu",
          "module": "Graphics.UI.GLUT.Menu",
          "name": "Menu",
          "package": "GLUT",
          "partial": "Menu",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Menu.html#t:Menu"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.UI.GLUT.Menu",
          "name": "MenuCallback",
          "package": "GLUT",
          "source": "src/Graphics-UI-GLUT-Menu.html#MenuCallback",
          "type": "type"
        },
        "index": {
          "hierarchy": "Graphics UI GLUT Menu",
          "module": "Graphics.UI.GLUT.Menu",
          "name": "MenuCallback",
          "package": "GLUT",
          "partial": "Menu Callback",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Menu.html#t:MenuCallback"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA single item within a menu can either be a plain menu entry or a sub-menu\n entry, allowing for arbitrarily deep nested menus.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Menu",
          "name": "MenuItem",
          "package": "GLUT",
          "source": "src/Graphics-UI-GLUT-Menu.html#MenuItem",
          "type": "data"
        },
        "index": {
          "description": "single item within menu can either be plain menu entry or sub-menu entry allowing for arbitrarily deep nested menus",
          "hierarchy": "Graphics UI GLUT Menu",
          "module": "Graphics.UI.GLUT.Menu",
          "name": "MenuItem",
          "package": "GLUT",
          "partial": "Menu Item",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Menu.html#t:MenuItem"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.UI.GLUT.Menu",
          "name": "Menu",
          "package": "GLUT",
          "signature": "Menu [MenuItem]",
          "source": "src/Graphics-UI-GLUT-Menu.html#Menu",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics UI GLUT Menu",
          "module": "Graphics.UI.GLUT.Menu",
          "name": "Menu",
          "normalized": "Menu[MenuItem]",
          "package": "GLUT",
          "partial": "Menu",
          "signature": "Menu[MenuItem]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Menu.html#v:Menu"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA plain menu entry with an associated\n   callback, which is triggered when the\n   user selects the entry\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Menu",
          "name": "MenuEntry",
          "package": "GLUT",
          "signature": "MenuEntry String MenuCallback",
          "source": "src/Graphics-UI-GLUT-Menu.html#MenuItem",
          "type": "function"
        },
        "index": {
          "description": "plain menu entry with an associated callback which is triggered when the user selects the entry",
          "hierarchy": "Graphics UI GLUT Menu",
          "module": "Graphics.UI.GLUT.Menu",
          "name": "MenuEntry",
          "package": "GLUT",
          "partial": "Menu Entry",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Menu.html#v:MenuEntry"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.UI.GLUT.Menu",
          "name": "MenuWithFont",
          "package": "GLUT",
          "signature": "MenuWithFont BitmapFont [MenuItem]",
          "source": "src/Graphics-UI-GLUT-Menu.html#Menu",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics UI GLUT Menu",
          "module": "Graphics.UI.GLUT.Menu",
          "name": "MenuWithFont",
          "normalized": "MenuWithFont BitmapFont[MenuItem]",
          "package": "GLUT",
          "partial": "Menu With Font",
          "signature": "MenuWithFont BitmapFont[MenuItem]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Menu.html#v:MenuWithFont"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA sub-menu, which is cascaded when the\n   user selects the entry, allowing\n   sub-menu entries to be selected\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Menu",
          "name": "SubMenu",
          "package": "GLUT",
          "signature": "SubMenu String Menu",
          "source": "src/Graphics-UI-GLUT-Menu.html#MenuItem",
          "type": "function"
        },
        "index": {
          "description": "sub-menu which is cascaded when the user selects the entry allowing sub-menu entries to be selected",
          "hierarchy": "Graphics UI GLUT Menu",
          "module": "Graphics.UI.GLUT.Menu",
          "name": "SubMenu",
          "package": "GLUT",
          "partial": "Sub Menu",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Menu.html#v:SubMenu"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreate a new pop-up menu for the \u003cem\u003ecurrent window,\u003c/em\u003e attaching it to the\n given mouse button. A previously attached menu (if any), is detached before\n and won't receive callbacks anymore.\n\u003c/p\u003e\u003cp\u003eIt is illegal to call \u003ccode\u003e\u003ca\u003eattachMenu\u003c/a\u003e\u003c/code\u003e while any (sub-)menu is in use, i.e.\n popped up.\n\u003c/p\u003e\u003cp\u003e\u003cem\u003eX Implementation Notes:\u003c/em\u003e If available, GLUT for X will take advantage of\n overlay planes for implementing pop-up menus. The use of overlay planes can\n eliminate display callbacks when pop-up menus are deactivated. The\n \u003ccode\u003eSERVER_OVERLAY_VISUALS\u003c/code\u003e convention is used to determine if overlay visuals\n are available.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Menu",
          "name": "attachMenu",
          "package": "GLUT",
          "signature": "MouseButton -\u003e Menu -\u003e IO ()",
          "source": "src/Graphics-UI-GLUT-Menu.html#attachMenu",
          "type": "function"
        },
        "index": {
          "description": "Create new pop-up menu for the current window attaching it to the given mouse button previously attached menu if any is detached before and won receive callbacks anymore It is illegal to call attachMenu while any sub menu is in use i.e popped up Implementation Notes If available GLUT for will take advantage of overlay planes for implementing pop-up menus The use of overlay planes can eliminate display callbacks when pop-up menus are deactivated The SERVER OVERLAY VISUALS convention is used to determine if overlay visuals are available",
          "hierarchy": "Graphics UI GLUT Menu",
          "module": "Graphics.UI.GLUT.Menu",
          "name": "attachMenu",
          "normalized": "MouseButton-\u003eMenu-\u003eIO()",
          "package": "GLUT",
          "partial": "Menu",
          "signature": "MouseButton-\u003eMenu-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Menu.html#v:attachMenu"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eContains the number of menu items in the \u003cem\u003ecurrent menu.\u003c/em\u003e\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Menu",
          "name": "numMenuItems",
          "package": "GLUT",
          "signature": "GettableStateVar Int",
          "source": "src/Graphics-UI-GLUT-Menu.html#numMenuItems",
          "type": "function"
        },
        "index": {
          "description": "Contains the number of menu items in the current menu",
          "hierarchy": "Graphics UI GLUT Menu",
          "module": "Graphics.UI.GLUT.Menu",
          "name": "numMenuItems",
          "package": "GLUT",
          "partial": "Menu Items",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Menu.html#v:numMenuItems"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eGLUT includes a number of routines for generating easily recognizable 3D\n geometric objects. These routines reflect functionality available in the\n \u003ccode\u003eaux\u003c/code\u003e toolkit described in the \u003cem\u003eOpenGL Programmer\\'s Guide\u003c/em\u003e and are included\n in GLUT to allow the construction of simple GLUT programs that render\n recognizable objects. These routines can be implemented as pure OpenGL\n rendering routines. The routines do not generate display lists for the\n objects they create. The routines generate normals appropriate for lighting\n but do not generate texture coordinates (except for the solid teapot, teacup\n and teaspoon). If VBOs should be used instead of the fixed function pipeline,\n specify at least one of the attribute locations\n \u003ccode\u003e\u003ca\u003evertexAttribCoord3\u003c/a\u003e\u003c/code\u003e or\n \u003ccode\u003e\u003ca\u003evertexAttribNormal\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Graphics.UI.GLUT.Objects",
          "name": "Objects",
          "package": "GLUT",
          "source": "src/Graphics-UI-GLUT-Objects.html",
          "type": "module"
        },
        "index": {
          "description": "GLUT includes number of routines for generating easily recognizable geometric objects These routines reflect functionality available in the aux toolkit described in the OpenGL Programmer Guide and are included in GLUT to allow the construction of simple GLUT programs that render recognizable objects These routines can be implemented as pure OpenGL rendering routines The routines do not generate display lists for the objects they create The routines generate normals appropriate for lighting but do not generate texture coordinates except for the solid teapot teacup and teaspoon If VBOs should be used instead of the fixed function pipeline specify at least one of the attribute locations vertexAttribCoord3 or vertexAttribNormal",
          "hierarchy": "Graphics UI GLUT Objects",
          "module": "Graphics.UI.GLUT.Objects",
          "name": "Objects",
          "package": "GLUT",
          "partial": "Objects",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Objects.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFlavour of object rendering\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Objects",
          "name": "Flavour",
          "package": "GLUT",
          "source": "src/Graphics-UI-GLUT-Objects.html#Flavour",
          "type": "data"
        },
        "index": {
          "description": "Flavour of object rendering",
          "hierarchy": "Graphics UI GLUT Objects",
          "module": "Graphics.UI.GLUT.Objects",
          "name": "Flavour",
          "package": "GLUT",
          "partial": "Flavour",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Objects.html#t:Flavour"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.UI.GLUT.Objects",
          "name": "NumLevels",
          "package": "GLUT",
          "source": "src/Graphics-UI-GLUT-Objects.html#NumLevels",
          "type": "type"
        },
        "index": {
          "hierarchy": "Graphics UI GLUT Objects",
          "module": "Graphics.UI.GLUT.Objects",
          "name": "NumLevels",
          "package": "GLUT",
          "partial": "Num Levels",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Objects.html#t:NumLevels"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGLUT offers five types of objects:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e  The five Platonic solids, see\n    \u003ca\u003ehttp://mathworld.wolfram.com/PlatonicSolid.html\u003c/a\u003e.\n\u003c/li\u003e\u003cli\u003e A rhombic dodecahedron, see\n   \u003ca\u003ehttp://mathworld.wolfram.com/RhombicDodecahedron.html\u003c/a\u003e.\n\u003c/li\u003e\u003cli\u003e Approximations to rounded objects.\n\u003c/li\u003e\u003cli\u003e The classic teaset modeled by Martin Newell in 1975. Both surface normals\n   and texture coordinates for the teaset are generated.\n\u003c/li\u003e\u003cli\u003e A Sierpinski sponge, see\n   \u003ca\u003ehttp://mathworld.wolfram.com/Tetrix.html\u003c/a\u003e.\n\u003c/li\u003e\u003c/ul\u003e",
          "module": "Graphics.UI.GLUT.Objects",
          "name": "Object",
          "package": "GLUT",
          "source": "src/Graphics-UI-GLUT-Objects.html#Object",
          "type": "data"
        },
        "index": {
          "description": "GLUT offers five types of objects The five Platonic solids see http mathworld.wolfram.com PlatonicSolid.html rhombic dodecahedron see http mathworld.wolfram.com RhombicDodecahedron.html Approximations to rounded objects The classic teaset modeled by Martin Newell in Both surface normals and texture coordinates for the teaset are generated Sierpinski sponge see http mathworld.wolfram.com Tetrix.html",
          "hierarchy": "Graphics UI GLUT Objects",
          "module": "Graphics.UI.GLUT.Objects",
          "name": "Object",
          "package": "GLUT",
          "partial": "Object",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Objects.html#t:Object"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.UI.GLUT.Objects",
          "name": "Rings",
          "package": "GLUT",
          "source": "src/Graphics-UI-GLUT-Objects.html#Rings",
          "type": "type"
        },
        "index": {
          "hierarchy": "Graphics UI GLUT Objects",
          "module": "Graphics.UI.GLUT.Objects",
          "name": "Rings",
          "package": "GLUT",
          "partial": "Rings",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Objects.html#t:Rings"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.UI.GLUT.Objects",
          "name": "Sides",
          "package": "GLUT",
          "source": "src/Graphics-UI-GLUT-Objects.html#Sides",
          "type": "type"
        },
        "index": {
          "hierarchy": "Graphics UI GLUT Objects",
          "module": "Graphics.UI.GLUT.Objects",
          "name": "Sides",
          "package": "GLUT",
          "partial": "Sides",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Objects.html#t:Sides"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA cone oriented along the Z axis. The base of the cone is placed at Z\n   = 0, and the top at Z = the given height. The cone is subdivided\n   around the Z axis into slices, and along the Z axis into stacks.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Objects",
          "name": "Cone",
          "package": "GLUT",
          "signature": "Cone Radius Height Slices Stacks",
          "source": "src/Graphics-UI-GLUT-Objects.html#Object",
          "type": "function"
        },
        "index": {
          "description": "cone oriented along the axis The base of the cone is placed at and the top at the given height The cone is subdivided around the axis into slices and along the axis into stacks",
          "hierarchy": "Graphics UI GLUT Objects",
          "module": "Graphics.UI.GLUT.Objects",
          "name": "Cone",
          "package": "GLUT",
          "partial": "Cone",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Objects.html#v:Cone"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA cube centered at the modeling coordinates origin with sides of the\n   given length.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Objects",
          "name": "Cube",
          "package": "GLUT",
          "signature": "Cube Height",
          "source": "src/Graphics-UI-GLUT-Objects.html#Object",
          "type": "function"
        },
        "index": {
          "description": "cube centered at the modeling coordinates origin with sides of the given length",
          "hierarchy": "Graphics UI GLUT Objects",
          "module": "Graphics.UI.GLUT.Objects",
          "name": "Cube",
          "package": "GLUT",
          "partial": "Cube",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Objects.html#v:Cube"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e(\u003cem\u003efreeglut only\u003c/em\u003e) A cylinder oriented along the Z axis. The base of the\n  cylinder is placed at Z = 0, and the top at Z = the given height. The\n  cylinder is subdivided around the Z axis into slices, and along the Z\n axis into stacks.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Objects",
          "name": "Cylinder'",
          "package": "GLUT",
          "signature": "Cylinder' Radius Height Slices Stacks",
          "source": "src/Graphics-UI-GLUT-Objects.html#Object",
          "type": "function"
        },
        "index": {
          "description": "freeglut only cylinder oriented along the axis The base of the cylinder is placed at and the top at the given height The cylinder is subdivided around the axis into slices and along the axis into stacks",
          "hierarchy": "Graphics UI GLUT Objects",
          "module": "Graphics.UI.GLUT.Objects",
          "name": "Cylinder'",
          "package": "GLUT",
          "partial": "Cylinder'",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Objects.html#v:Cylinder-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA dodecahedron (12-sided regular solid) centered at the modeling\n   coordinates origin with a radius of \u003ccode\u003esqrt 3\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Objects",
          "name": "Dodecahedron",
          "package": "GLUT",
          "signature": "Dodecahedron",
          "source": "src/Graphics-UI-GLUT-Objects.html#Object",
          "type": "function"
        },
        "index": {
          "description": "dodecahedron sided regular solid centered at the modeling coordinates origin with radius of sqrt",
          "hierarchy": "Graphics UI GLUT Objects",
          "module": "Graphics.UI.GLUT.Objects",
          "name": "Dodecahedron",
          "package": "GLUT",
          "partial": "Dodecahedron",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Objects.html#v:Dodecahedron"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA icosahedron (20-sided regular solid) centered at the modeling\n   coordinates origin with a radius of 1.0.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Objects",
          "name": "Icosahedron",
          "package": "GLUT",
          "signature": "Icosahedron",
          "source": "src/Graphics-UI-GLUT-Objects.html#Object",
          "type": "function"
        },
        "index": {
          "description": "icosahedron sided regular solid centered at the modeling coordinates origin with radius of",
          "hierarchy": "Graphics UI GLUT Objects",
          "module": "Graphics.UI.GLUT.Objects",
          "name": "Icosahedron",
          "package": "GLUT",
          "partial": "Icosahedron",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Objects.html#v:Icosahedron"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRender a solid octahedron (8-sided regular solid) centered at the\n   modeling coordinates origin with a radius of 1.0.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Objects",
          "name": "Octahedron",
          "package": "GLUT",
          "signature": "Octahedron",
          "source": "src/Graphics-UI-GLUT-Objects.html#Object",
          "type": "function"
        },
        "index": {
          "description": "Render solid octahedron sided regular solid centered at the modeling coordinates origin with radius of",
          "hierarchy": "Graphics UI GLUT Objects",
          "module": "Graphics.UI.GLUT.Objects",
          "name": "Octahedron",
          "package": "GLUT",
          "partial": "Octahedron",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Objects.html#v:Octahedron"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e(\u003cem\u003efreeglut only\u003c/em\u003e) A rhombic dodecahedron whose corners are at most a\n distance of one from the origin. The rhombic dodecahedron has faces\n which are identical rhombi, but which have some vertices at which three\n faces meet and some vertices at which four faces meet. The length of\n each side is \u003ccode\u003e(sqrt 3)/2\u003c/code\u003e. Vertices at which four faces meet are found\n at \u003ccode\u003e(0, 0, +/-1)\u003c/code\u003e and \u003ccode\u003e(+/-(sqrt 2)/2, +/-(sqrt 2)/2, 0)\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Objects",
          "name": "RhombicDodecahedron",
          "package": "GLUT",
          "signature": "RhombicDodecahedron",
          "source": "src/Graphics-UI-GLUT-Objects.html#Object",
          "type": "function"
        },
        "index": {
          "description": "freeglut only rhombic dodecahedron whose corners are at most distance of one from the origin The rhombic dodecahedron has faces which are identical rhombi but which have some vertices at which three faces meet and some vertices at which four faces meet The length of each side is sqrt Vertices at which four faces meet are found at and sqrt sqrt",
          "hierarchy": "Graphics UI GLUT Objects",
          "module": "Graphics.UI.GLUT.Objects",
          "name": "RhombicDodecahedron",
          "package": "GLUT",
          "partial": "Rhombic Dodecahedron",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Objects.html#v:RhombicDodecahedron"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e(\u003cem\u003efreeglut only\u003c/em\u003e) A Sierpinski sponge of a given level, where a level\n 0 sponge is the same as a \u003ccode\u003e\u003ca\u003eTetrahedron\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Objects",
          "name": "SierpinskiSponge",
          "package": "GLUT",
          "signature": "SierpinskiSponge NumLevels",
          "source": "src/Graphics-UI-GLUT-Objects.html#Object",
          "type": "function"
        },
        "index": {
          "description": "freeglut only Sierpinski sponge of given level where level sponge is the same as Tetrahedron",
          "hierarchy": "Graphics UI GLUT Objects",
          "module": "Graphics.UI.GLUT.Objects",
          "name": "SierpinskiSponge",
          "package": "GLUT",
          "partial": "Sierpinski Sponge",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Objects.html#v:SierpinskiSponge"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eObject is rendered as a solid with shading and surface normals.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Objects",
          "name": "Solid",
          "package": "GLUT",
          "signature": "Solid",
          "source": "src/Graphics-UI-GLUT-Objects.html#Flavour",
          "type": "function"
        },
        "index": {
          "description": "Object is rendered as solid with shading and surface normals",
          "hierarchy": "Graphics UI GLUT Objects",
          "module": "Graphics.UI.GLUT.Objects",
          "name": "Solid",
          "package": "GLUT",
          "partial": "Solid",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Objects.html#v:Solid"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA sphere centered at the modeling coordinates origin of the specified\n   radius. The sphere is subdivided around the Z axis into slices\n   (similar to lines of longitude) and along the Z axis into stacks\n   (similar to lines of latitude).\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Objects",
          "name": "Sphere'",
          "package": "GLUT",
          "signature": "Sphere' Radius Slices Stacks",
          "source": "src/Graphics-UI-GLUT-Objects.html#Object",
          "type": "function"
        },
        "index": {
          "description": "sphere centered at the modeling coordinates origin of the specified radius The sphere is subdivided around the axis into slices similar to lines of longitude and along the axis into stacks similar to lines of latitude",
          "hierarchy": "Graphics UI GLUT Objects",
          "module": "Graphics.UI.GLUT.Objects",
          "name": "Sphere'",
          "package": "GLUT",
          "partial": "Sphere'",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Objects.html#v:Sphere-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e(\u003cem\u003efreeglut only\u003c/em\u003e) A teacup with a given relative size.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Objects",
          "name": "Teacup",
          "package": "GLUT",
          "signature": "Teacup Height",
          "source": "src/Graphics-UI-GLUT-Objects.html#Object",
          "type": "function"
        },
        "index": {
          "description": "freeglut only teacup with given relative size",
          "hierarchy": "Graphics UI GLUT Objects",
          "module": "Graphics.UI.GLUT.Objects",
          "name": "Teacup",
          "package": "GLUT",
          "partial": "Teacup",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Objects.html#v:Teacup"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA teapot with a given relative size.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Objects",
          "name": "Teapot",
          "package": "GLUT",
          "signature": "Teapot Height",
          "source": "src/Graphics-UI-GLUT-Objects.html#Object",
          "type": "function"
        },
        "index": {
          "description": "teapot with given relative size",
          "hierarchy": "Graphics UI GLUT Objects",
          "module": "Graphics.UI.GLUT.Objects",
          "name": "Teapot",
          "package": "GLUT",
          "partial": "Teapot",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Objects.html#v:Teapot"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e(\u003cem\u003efreeglut only\u003c/em\u003e) A teaspoon with a given relative size.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Objects",
          "name": "Teaspoon",
          "package": "GLUT",
          "signature": "Teaspoon Height",
          "source": "src/Graphics-UI-GLUT-Objects.html#Object",
          "type": "function"
        },
        "index": {
          "description": "freeglut only teaspoon with given relative size",
          "hierarchy": "Graphics UI GLUT Objects",
          "module": "Graphics.UI.GLUT.Objects",
          "name": "Teaspoon",
          "package": "GLUT",
          "partial": "Teaspoon",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Objects.html#v:Teaspoon"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRender a solid tetrahedron (4-sided regular solid) centered at the\n   modeling coordinates origin with a radius of \u003ccode\u003esqrt 3\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Objects",
          "name": "Tetrahedron",
          "package": "GLUT",
          "signature": "Tetrahedron",
          "source": "src/Graphics-UI-GLUT-Objects.html#Object",
          "type": "function"
        },
        "index": {
          "description": "Render solid tetrahedron sided regular solid centered at the modeling coordinates origin with radius of sqrt",
          "hierarchy": "Graphics UI GLUT Objects",
          "module": "Graphics.UI.GLUT.Objects",
          "name": "Tetrahedron",
          "package": "GLUT",
          "partial": "Tetrahedron",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Objects.html#v:Tetrahedron"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA torus (doughnut) centered at the modeling coordinates origin\n whose axis is aligned with the Z axis. The torus is described by its\n inner and outer radius, the number of sides for each radial section,\n and the number of radial divisions (rings).\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Objects",
          "name": "Torus",
          "package": "GLUT",
          "signature": "Torus Radius Radius Sides Rings",
          "source": "src/Graphics-UI-GLUT-Objects.html#Object",
          "type": "function"
        },
        "index": {
          "description": "torus doughnut centered at the modeling coordinates origin whose axis is aligned with the axis The torus is described by its inner and outer radius the number of sides for each radial section and the number of radial divisions rings",
          "hierarchy": "Graphics UI GLUT Objects",
          "module": "Graphics.UI.GLUT.Objects",
          "name": "Torus",
          "package": "GLUT",
          "partial": "Torus",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Objects.html#v:Torus"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eObject is rendered as a wireframe without surface normals.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Objects",
          "name": "Wireframe",
          "package": "GLUT",
          "signature": "Wireframe",
          "source": "src/Graphics-UI-GLUT-Objects.html#Flavour",
          "type": "function"
        },
        "index": {
          "description": "Object is rendered as wireframe without surface normals",
          "hierarchy": "Graphics UI GLUT Objects",
          "module": "Graphics.UI.GLUT.Objects",
          "name": "Wireframe",
          "package": "GLUT",
          "partial": "Wireframe",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Objects.html#v:Wireframe"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRender an object in the given flavour.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Objects",
          "name": "renderObject",
          "package": "GLUT",
          "signature": "Flavour -\u003e Object -\u003e IO ()",
          "source": "src/Graphics-UI-GLUT-Objects.html#renderObject",
          "type": "function"
        },
        "index": {
          "description": "Render an object in the given flavour",
          "hierarchy": "Graphics UI GLUT Objects",
          "module": "Graphics.UI.GLUT.Objects",
          "name": "renderObject",
          "normalized": "Flavour-\u003eObject-\u003eIO()",
          "package": "GLUT",
          "partial": "Object",
          "signature": "Flavour-\u003eObject-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Objects.html#v:renderObject"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eWhen  overlay hardware is available, GLUT provides a set of routines for\n establishing, using, and removing an overlay for GLUT windows. When an\n overlay is established, a separate OpenGL context is also established. A\n window's overlay OpenGL state is kept distinct from the normal planes'\n OpenGL state.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Graphics.UI.GLUT.Overlay",
          "name": "Overlay",
          "package": "GLUT",
          "source": "src/Graphics-UI-GLUT-Overlay.html",
          "type": "module"
        },
        "index": {
          "description": "When overlay hardware is available GLUT provides set of routines for establishing using and removing an overlay for GLUT windows When an overlay is established separate OpenGL context is also established window overlay OpenGL state is kept distinct from the normal planes OpenGL state",
          "hierarchy": "Graphics UI GLUT Overlay",
          "module": "Graphics.UI.GLUT.Overlay",
          "name": "Overlay",
          "package": "GLUT",
          "partial": "Overlay",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Overlay.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003cem\u003elayer in use\u003c/em\u003e.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Overlay",
          "name": "Layer",
          "package": "GLUT",
          "source": "src/Graphics-UI-GLUT-Overlay.html#Layer",
          "type": "data"
        },
        "index": {
          "description": "The layer in use",
          "hierarchy": "Graphics UI GLUT Overlay",
          "module": "Graphics.UI.GLUT.Overlay",
          "name": "Layer",
          "package": "GLUT",
          "partial": "Layer",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Overlay.html#t:Layer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe normal plane.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Overlay",
          "name": "Normal",
          "package": "GLUT",
          "signature": "Normal",
          "source": "src/Graphics-UI-GLUT-Overlay.html#Layer",
          "type": "function"
        },
        "index": {
          "description": "The normal plane",
          "hierarchy": "Graphics UI GLUT Overlay",
          "module": "Graphics.UI.GLUT.Overlay",
          "name": "Normal",
          "package": "GLUT",
          "partial": "Normal",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Overlay.html#v:Normal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe overlay.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Overlay",
          "name": "Overlay",
          "package": "GLUT",
          "signature": "Overlay",
          "source": "src/Graphics-UI-GLUT-Overlay.html#Layer",
          "type": "function"
        },
        "index": {
          "description": "The overlay",
          "hierarchy": "Graphics UI GLUT Overlay",
          "module": "Graphics.UI.GLUT.Overlay",
          "name": "Overlay",
          "package": "GLUT",
          "partial": "Overlay",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Overlay.html#v:Overlay"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eControls the overlay for the \u003cem\u003ecurrent window\u003c/em\u003e. The requested display mode\n for the overlay is determined by the \u003cem\u003einitial display mode\u003c/em\u003e.\n \u003ccode\u003e\u003ca\u003eoverlayPossible\u003c/a\u003e\u003c/code\u003e can be used to determine if an overlay is possible for the\n \u003cem\u003ecurrent window\u003c/em\u003e with the current \u003cem\u003einitial display mode\u003c/em\u003e. Do not attempt to\n establish an overlay when one is not possible; GLUT will terminate the\n program.\n\u003c/p\u003e\u003cp\u003eWhen \u003ccode\u003e\u003ca\u003ehasOverlay\u003c/a\u003e\u003c/code\u003e is set to \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e when an overlay already exists, the\n existing overlay is first removed, and then a new overlay is established. The\n state of the old overlay's OpenGL context is discarded. Implicitly, the\n window's \u003cem\u003elayer in use\u003c/em\u003e changes to the overlay immediately after the overlay\n is established.\n\u003c/p\u003e\u003cp\u003eThe initial display state of an overlay is shown, however the overlay is only\n actually shown if the overlay's window is shown.\n\u003c/p\u003e\u003cp\u003eSetting \u003ccode\u003e\u003ca\u003ehasOverlay\u003c/a\u003e\u003c/code\u003e to \u003ccode\u003e\u003ca\u003eFalse\u003c/a\u003e\u003c/code\u003e is safe even if no overlay is currently\n established, nothing happens in this case. Implicitly, the window's /layer\n in use/ changes to the normal plane immediately once the overlay is removed.\n\u003c/p\u003e\u003cp\u003eIf the program intends to re-establish the overlay later, it is typically\n faster and less resource intensive to use \u003ccode\u003e\u003ca\u003eoverlayVisible\u003c/a\u003e\u003c/code\u003e to simply change\n the display status of the overlay.\n\u003c/p\u003e\u003cp\u003e\u003cem\u003eX Implementation Notes:\u003c/em\u003e GLUT for X uses the \u003ccode\u003eSERVER_OVERLAY_VISUALS\u003c/code\u003e\n convention to determine if overlay visuals are available. While the\n convention allows for opaque overlays (no transparency) and overlays with the\n transparency specified as a bitmask, GLUT overlay management only provides\n access to transparent pixel overlays.\n\u003c/p\u003e\u003cp\u003eUntil RGBA overlays are better understood, GLUT only supports color index\n overlays.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Overlay",
          "name": "hasOverlay",
          "package": "GLUT",
          "signature": "StateVar Bool",
          "source": "src/Graphics-UI-GLUT-Overlay.html#hasOverlay",
          "type": "function"
        },
        "index": {
          "description": "Controls the overlay for the current window The requested display mode for the overlay is determined by the initial display mode overlayPossible can be used to determine if an overlay is possible for the current window with the current initial display mode Do not attempt to establish an overlay when one is not possible GLUT will terminate the program When hasOverlay is set to True when an overlay already exists the existing overlay is first removed and then new overlay is established The state of the old overlay OpenGL context is discarded Implicitly the window layer in use changes to the overlay immediately after the overlay is established The initial display state of an overlay is shown however the overlay is only actually shown if the overlay window is shown Setting hasOverlay to False is safe even if no overlay is currently established nothing happens in this case Implicitly the window layer in use changes to the normal plane immediately once the overlay is removed If the program intends to re-establish the overlay later it is typically faster and less resource intensive to use overlayVisible to simply change the display status of the overlay Implementation Notes GLUT for uses the SERVER OVERLAY VISUALS convention to determine if overlay visuals are available While the convention allows for opaque overlays no transparency and overlays with the transparency specified as bitmask GLUT overlay management only provides access to transparent pixel overlays Until RGBA overlays are better understood GLUT only supports color index overlays",
          "hierarchy": "Graphics UI GLUT Overlay",
          "module": "Graphics.UI.GLUT.Overlay",
          "name": "hasOverlay",
          "package": "GLUT",
          "partial": "Overlay",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Overlay.html#v:hasOverlay"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eControls the per-window \u003cem\u003elayer in use\u003c/em\u003e for the \u003cem\u003ecurrent window\u003c/em\u003e, which can\n either be the normal plane or the overlay. Selecting the overlay should only\n be done if an overlay exists, however windows without an overlay may still\n set the \u003cem\u003elayer in use\u003c/em\u003e to \u003ccode\u003e\u003ca\u003eNormal\u003c/a\u003e\u003c/code\u003e. OpenGL commands for the window are\n directed to the current \u003cem\u003elayer in use\u003c/em\u003e.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Overlay",
          "name": "layerInUse",
          "package": "GLUT",
          "signature": "StateVar Layer",
          "source": "src/Graphics-UI-GLUT-Overlay.html#layerInUse",
          "type": "function"
        },
        "index": {
          "description": "Controls the per-window layer in use for the current window which can either be the normal plane or the overlay Selecting the overlay should only be done if an overlay exists however windows without an overlay may still set the layer in use to Normal OpenGL commands for the window are directed to the current layer in use",
          "hierarchy": "Graphics UI GLUT Overlay",
          "module": "Graphics.UI.GLUT.Overlay",
          "name": "layerInUse",
          "package": "GLUT",
          "partial": "In Use",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Overlay.html#v:layerInUse"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eContains \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e if an overlay could be established for the \u003cem\u003ecurrent window\u003c/em\u003e\n given the current \u003cem\u003einitial display mode\u003c/em\u003e. If it contains \u003ccode\u003e\u003ca\u003eFalse\u003c/a\u003e\u003c/code\u003e, setting\n \u003ccode\u003e\u003ca\u003ehasOverlay\u003c/a\u003e\u003c/code\u003e will fail with a fatal error.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Overlay",
          "name": "overlayPossible",
          "package": "GLUT",
          "signature": "GettableStateVar Bool",
          "source": "src/Graphics-UI-GLUT-Overlay.html#overlayPossible",
          "type": "function"
        },
        "index": {
          "description": "Contains True if an overlay could be established for the current window given the current initial display mode If it contains False setting hasOverlay will fail with fatal error",
          "hierarchy": "Graphics UI GLUT Overlay",
          "module": "Graphics.UI.GLUT.Overlay",
          "name": "overlayPossible",
          "package": "GLUT",
          "partial": "Possible",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Overlay.html#v:overlayPossible"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eControls the visibility of the overlay of the \u003cem\u003ecurrent window\u003c/em\u003e.\n\u003c/p\u003e\u003cp\u003eThe effect of showing or hiding an overlay takes place immediately. Note that\n setting \u003ccode\u003e\u003ca\u003eoverlayVisible\u003c/a\u003e\u003c/code\u003e to \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e will not actually display the overlay\n unless the window is also shown (and even a shown window may be obscured by\n other windows, thereby obscuring the overlay). It is typically faster and\n less resource intensive to use the routines below to control the display\n status of an overlay as opposed to removing and re-establishing the overlay.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Overlay",
          "name": "overlayVisible",
          "package": "GLUT",
          "signature": "SettableStateVar Bool",
          "source": "src/Graphics-UI-GLUT-Overlay.html#overlayVisible",
          "type": "function"
        },
        "index": {
          "description": "Controls the visibility of the overlay of the current window The effect of showing or hiding an overlay takes place immediately Note that setting overlayVisible to True will not actually display the overlay unless the window is also shown and even shown window may be obscured by other windows thereby obscuring the overlay It is typically faster and less resource intensive to use the routines below to control the display status of an overlay as opposed to removing and re-establishing the overlay",
          "hierarchy": "Graphics UI GLUT Overlay",
          "module": "Graphics.UI.GLUT.Overlay",
          "name": "overlayVisible",
          "package": "GLUT",
          "partial": "Visible",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Overlay.html#v:overlayVisible"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMark the overlay of the given window (or the \u003cem\u003ecurrent window\u003c/em\u003e, if none is\n supplied) as needing to be redisplayed. The next iteration through\n \u003ccode\u003e\u003ca\u003emainLoop\u003c/a\u003e\u003c/code\u003e, the window's overlay display callback\n (or simply the display callback if no overlay display callback is registered)\n will be called to redisplay the window's overlay plane. Multiple calls to\n \u003ccode\u003e\u003ca\u003epostOverlayRedisplay\u003c/a\u003e\u003c/code\u003e before the next display callback opportunity (or\n overlay display callback opportunity if one is registered) generate only a\n single redisplay. \u003ccode\u003e\u003ca\u003epostOverlayRedisplay\u003c/a\u003e\u003c/code\u003e may be called within a window's\n display or overlay display callback to re-mark that window for redisplay.\n\u003c/p\u003e\u003cp\u003eLogically, overlay damage notification for a window is treated as a\n \u003ccode\u003e\u003ca\u003epostOverlayRedisplay\u003c/a\u003e\u003c/code\u003e on the damaged window. Unlike damage reported by the\n window system, \u003ccode\u003e\u003ca\u003epostOverlayRedisplay\u003c/a\u003e\u003c/code\u003e will not set to true the overlay's\n damaged status (see \u003ccode\u003e\u003ca\u003edamaged\u003c/a\u003e\u003c/code\u003e).\n\u003c/p\u003e\u003cp\u003eAlso, see \u003ccode\u003e\u003ca\u003epostRedisplay\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Overlay",
          "name": "postOverlayRedisplay",
          "package": "GLUT",
          "signature": "Maybe Window -\u003e IO ()",
          "source": "src/Graphics-UI-GLUT-Overlay.html#postOverlayRedisplay",
          "type": "function"
        },
        "index": {
          "description": "Mark the overlay of the given window or the current window if none is supplied as needing to be redisplayed The next iteration through mainLoop the window overlay display callback or simply the display callback if no overlay display callback is registered will be called to redisplay the window overlay plane Multiple calls to postOverlayRedisplay before the next display callback opportunity or overlay display callback opportunity if one is registered generate only single redisplay postOverlayRedisplay may be called within window display or overlay display callback to re-mark that window for redisplay Logically overlay damage notification for window is treated as postOverlayRedisplay on the damaged window Unlike damage reported by the window system postOverlayRedisplay will not set to true the overlay damaged status see damaged Also see postRedisplay",
          "hierarchy": "Graphics UI GLUT Overlay",
          "module": "Graphics.UI.GLUT.Overlay",
          "name": "postOverlayRedisplay",
          "normalized": "Maybe Window-\u003eIO()",
          "package": "GLUT",
          "partial": "Overlay Redisplay",
          "signature": "Maybe Window-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Overlay.html#v:postOverlayRedisplay"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eGLUT maintains a considerable amount of programmer visible state. Some (but\n not all) of this state may be directly retrieved.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Graphics.UI.GLUT.State",
          "name": "State",
          "package": "GLUT",
          "source": "src/Graphics-UI-GLUT-State.html",
          "type": "module"
        },
        "index": {
          "description": "GLUT maintains considerable amount of programmer visible state Some but not all of this state may be directly retrieved",
          "hierarchy": "Graphics UI GLUT State",
          "module": "Graphics.UI.GLUT.State",
          "name": "State",
          "package": "GLUT",
          "partial": "State",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-State.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eNumber of axes of a joystick\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.State",
          "name": "AxisCount",
          "package": "GLUT",
          "source": "src/Graphics-UI-GLUT-State.html#AxisCount",
          "type": "type"
        },
        "index": {
          "description": "Number of axes of joystick",
          "hierarchy": "Graphics UI GLUT State",
          "module": "Graphics.UI.GLUT.State",
          "name": "AxisCount",
          "package": "GLUT",
          "partial": "Axis Count",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-State.html#t:AxisCount"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eBit depth of a buffer\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.State",
          "name": "BufferDepth",
          "package": "GLUT",
          "source": "src/Graphics-UI-GLUT-State.html#BufferDepth",
          "type": "type"
        },
        "index": {
          "description": "Bit depth of buffer",
          "hierarchy": "Graphics UI GLUT State",
          "module": "Graphics.UI.GLUT.State",
          "name": "BufferDepth",
          "package": "GLUT",
          "partial": "Buffer Depth",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-State.html#t:BufferDepth"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eNumber of buttons of an input device\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.State",
          "name": "ButtonCount",
          "package": "GLUT",
          "source": "src/Graphics-UI-GLUT-State.html#ButtonCount",
          "type": "type"
        },
        "index": {
          "description": "Number of buttons of an input device",
          "hierarchy": "Graphics UI GLUT State",
          "module": "Graphics.UI.GLUT.State",
          "name": "ButtonCount",
          "package": "GLUT",
          "partial": "Button Count",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-State.html#t:ButtonCount"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eNumber of dials of a dial and button box\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.State",
          "name": "DialCount",
          "package": "GLUT",
          "source": "src/Graphics-UI-GLUT-State.html#DialCount",
          "type": "type"
        },
        "index": {
          "description": "Number of dials of dial and button box",
          "hierarchy": "Graphics UI GLUT State",
          "module": "Graphics.UI.GLUT.State",
          "name": "DialCount",
          "package": "GLUT",
          "partial": "Dial Count",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-State.html#t:DialCount"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe a rate at which a joystick is polled (in milliseconds)\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.State",
          "name": "PollRate",
          "package": "GLUT",
          "source": "src/Graphics-UI-GLUT-State.html#PollRate",
          "type": "type"
        },
        "index": {
          "description": "The rate at which joystick is polled in milliseconds",
          "hierarchy": "Graphics UI GLUT State",
          "module": "Graphics.UI.GLUT.State",
          "name": "PollRate",
          "package": "GLUT",
          "partial": "Poll Rate",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-State.html#t:PollRate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eNumber of samples for multisampling\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.State",
          "name": "SampleCount",
          "package": "GLUT",
          "source": "src/Graphics-UI-GLUT-State.html#SampleCount",
          "type": "type"
        },
        "index": {
          "description": "Number of samples for multisampling",
          "hierarchy": "Graphics UI GLUT State",
          "module": "Graphics.UI.GLUT.State",
          "name": "SampleCount",
          "package": "GLUT",
          "partial": "Sample Count",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-State.html#t:SampleCount"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eContains the number of red, green, blue, and alpha bits in the accumulation\n buffer of the \u003cem\u003ecurrent window\\'s\u003c/em\u003e current layer (0 in color index mode).\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.State",
          "name": "accumBufferDepths",
          "package": "GLUT",
          "signature": "GettableStateVar (BufferDepth, BufferDepth, BufferDepth, BufferDepth)",
          "source": "src/Graphics-UI-GLUT-State.html#accumBufferDepths",
          "type": "function"
        },
        "index": {
          "description": "Contains the number of red green blue and alpha bits in the accumulation buffer of the current window current layer in color index mode",
          "hierarchy": "Graphics UI GLUT State",
          "module": "Graphics.UI.GLUT.State",
          "name": "accumBufferDepths",
          "normalized": "GettableStateVar(BufferDepth,BufferDepth,BufferDepth,BufferDepth)",
          "package": "GLUT",
          "partial": "Buffer Depths",
          "signature": "GettableStateVar(BufferDepth,BufferDepth,BufferDepth,BufferDepth)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-State.html#v:accumBufferDepths"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eContains the total number of bits in the color buffer of the /current\n window's/ current layer. For an RGBA layer, this is the sum of the red,\n green, blue, and alpha bits. For an color index layer, this is the number\n of bits of the color indexes.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.State",
          "name": "colorBufferDepth",
          "package": "GLUT",
          "signature": "GettableStateVar BufferDepth",
          "source": "src/Graphics-UI-GLUT-State.html#colorBufferDepth",
          "type": "function"
        },
        "index": {
          "description": "Contains the total number of bits in the color buffer of the current window current layer For an RGBA layer this is the sum of the red green blue and alpha bits For an color index layer this is the number of bits of the color indexes",
          "hierarchy": "Graphics UI GLUT State",
          "module": "Graphics.UI.GLUT.State",
          "name": "colorBufferDepth",
          "package": "GLUT",
          "partial": "Buffer Depth",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-State.html#v:colorBufferDepth"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eContains \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e if the given plane of the \u003cem\u003ecurrent window\u003c/em\u003e has been\n damaged (by window system activity) since the last display callback was\n triggered. Calling \u003ccode\u003e\u003ca\u003epostRedisplay\u003c/a\u003e\u003c/code\u003e or\n \u003ccode\u003e\u003ca\u003epostOverlayRedisplay\u003c/a\u003e\u003c/code\u003e will not set this \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.State",
          "name": "damaged",
          "package": "GLUT",
          "signature": "Layer -\u003e GettableStateVar Bool",
          "source": "src/Graphics-UI-GLUT-State.html#damaged",
          "type": "function"
        },
        "index": {
          "description": "Contains True if the given plane of the current window has been damaged by window system activity since the last display callback was triggered Calling postRedisplay or postOverlayRedisplay will not set this True",
          "hierarchy": "Graphics UI GLUT State",
          "module": "Graphics.UI.GLUT.State",
          "name": "damaged",
          "normalized": "Layer-\u003eGettableStateVar Bool",
          "package": "GLUT",
          "signature": "Layer-\u003eGettableStateVar Bool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-State.html#v:damaged"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eContains the number of bits in the depth buffer of the \u003cem\u003ecurrent window\\'s\u003c/em\u003e\n current layer.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.State",
          "name": "depthBufferDepth",
          "package": "GLUT",
          "signature": "GettableStateVar BufferDepth",
          "source": "src/Graphics-UI-GLUT-State.html#depthBufferDepth",
          "type": "function"
        },
        "index": {
          "description": "Contains the number of bits in the depth buffer of the current window current layer",
          "hierarchy": "Graphics UI GLUT State",
          "module": "Graphics.UI.GLUT.State",
          "name": "depthBufferDepth",
          "package": "GLUT",
          "partial": "Buffer Depth",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-State.html#v:depthBufferDepth"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eContains \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e when the current layer of the \u003cem\u003ecurrent window\u003c/em\u003e is double\n buffered, \u003ccode\u003e\u003ca\u003eFalse\u003c/a\u003e\u003c/code\u003e otherwise.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.State",
          "name": "doubleBuffered",
          "package": "GLUT",
          "signature": "GettableStateVar Bool",
          "source": "src/Graphics-UI-GLUT-State.html#doubleBuffered",
          "type": "function"
        },
        "index": {
          "description": "Contains True when the current layer of the current window is double buffered False otherwise",
          "hierarchy": "Graphics UI GLUT State",
          "module": "Graphics.UI.GLUT.State",
          "name": "doubleBuffered",
          "package": "GLUT",
          "partial": "Buffered",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-State.html#v:doubleBuffered"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eContains the number of milliseconds since\n \u003ccode\u003e\u003ca\u003einitialize\u003c/a\u003e\u003c/code\u003e was called.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.State",
          "name": "elapsedTime",
          "package": "GLUT",
          "signature": "GettableStateVar Int",
          "source": "src/Graphics-UI-GLUT-State.html#elapsedTime",
          "type": "function"
        },
        "index": {
          "description": "Contains the number of milliseconds since initialize was called",
          "hierarchy": "Graphics UI GLUT State",
          "module": "Graphics.UI.GLUT.State",
          "name": "elapsedTime",
          "package": "GLUT",
          "partial": "Time",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-State.html#v:elapsedTime"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eContains the window system dependent format ID for the current layer of the\n \u003cem\u003ecurrent window\u003c/em\u003e. On X11 GLUT implementations, this is the X visual ID. On\n Win32 GLUT implementations, this is the Win32 Pixel Format Descriptor number.\n This value is returned for debugging, benchmarking, and testing ease.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.State",
          "name": "formatID",
          "package": "GLUT",
          "signature": "GettableStateVar Int",
          "source": "src/Graphics-UI-GLUT-State.html#formatID",
          "type": "function"
        },
        "index": {
          "description": "Contains the window system dependent format ID for the current layer of the current window On X11 GLUT implementations this is the visual ID On Win32 GLUT implementations this is the Win32 Pixel Format Descriptor number This value is returned for debugging benchmarking and testing ease",
          "hierarchy": "Graphics UI GLUT State",
          "module": "Graphics.UI.GLUT.State",
          "name": "formatID",
          "package": "GLUT",
          "partial": "ID",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-State.html#v:formatID"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e(\u003cem\u003efreeglut only\u003c/em\u003e) Contains \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e if the \u003cem\u003ecurrent window\u003c/em\u003e is in full screen\n mode, \u003ccode\u003e\u003ca\u003eFalse\u003c/a\u003e\u003c/code\u003e otherwise.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.State",
          "name": "fullScreenMode",
          "package": "GLUT",
          "signature": "StateVar Bool",
          "source": "src/Graphics-UI-GLUT-State.html#fullScreenMode",
          "type": "function"
        },
        "index": {
          "description": "freeglut only Contains True if the current window is in full screen mode False otherwise",
          "hierarchy": "Graphics UI GLUT State",
          "module": "Graphics.UI.GLUT.State",
          "name": "fullScreenMode",
          "package": "GLUT",
          "partial": "Screen Mode",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-State.html#v:fullScreenMode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e(\u003cem\u003efreeglut only\u003c/em\u003e) Controls if vectors representing the normals should be\n drawn, too, when objects are drawn.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.State",
          "name": "geometryVisualizeNormals",
          "package": "GLUT",
          "signature": "StateVar Bool",
          "source": "src/Graphics-UI-GLUT-State.html#geometryVisualizeNormals",
          "type": "function"
        },
        "index": {
          "description": "freeglut only Controls if vectors representing the normals should be drawn too when objects are drawn",
          "hierarchy": "Graphics UI GLUT State",
          "module": "Graphics.UI.GLUT.State",
          "name": "geometryVisualizeNormals",
          "package": "GLUT",
          "partial": "Visualize Normals",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-State.html#v:geometryVisualizeNormals"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eContains version of GLUT in the form of\n \u003ccode\u003e\u003cem\u003eflavour\u003c/em\u003e \u003cem\u003emajor\u003c/em\u003e.\u003cem\u003eminor\u003c/em\u003e.\u003cem\u003epatchlevel\u003c/em\u003e\u003c/code\u003e, where \u003ccode\u003e\u003cem\u003eflavour\u003c/em\u003e\u003c/code\u003e is one of\n \u003ccode\u003eGLUT\u003c/code\u003e, \u003ccode\u003efreeglut\u003c/code\u003e or \u003ccode\u003eOpenGLUT\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.State",
          "name": "glutVersion",
          "package": "GLUT",
          "signature": "GettableStateVar String",
          "source": "src/Graphics-UI-GLUT-State.html#glutVersion",
          "type": "function"
        },
        "index": {
          "description": "Contains version of GLUT in the form of flavour major minor patchlevel where flavour is one of GLUT freeglut or OpenGLUT",
          "hierarchy": "Graphics UI GLUT State",
          "module": "Graphics.UI.GLUT.State",
          "name": "glutVersion",
          "package": "GLUT",
          "partial": "Version",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-State.html#v:glutVersion"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eContains \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e if a keyboard is present, \u003ccode\u003e\u003ca\u003eFalse\u003c/a\u003e\u003c/code\u003e otherwise.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.State",
          "name": "hasKeyboard",
          "package": "GLUT",
          "signature": "GettableStateVar Bool",
          "source": "src/Graphics-UI-GLUT-State.html#hasKeyboard",
          "type": "function"
        },
        "index": {
          "description": "Contains True if keyboard is present False otherwise",
          "hierarchy": "Graphics UI GLUT State",
          "module": "Graphics.UI.GLUT.State",
          "name": "hasKeyboard",
          "package": "GLUT",
          "partial": "Keyboard",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-State.html#v:hasKeyboard"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e(\u003cem\u003efreeglut only\u003c/em\u003e) Contains \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e if GLUT has been initialized \n with \u003ccode\u003e\u003ca\u003einitialize\u003c/a\u003e\u003c/code\u003e or\n \u003ccode\u003e\u003ca\u003egetArgsAndInitialize\u003c/a\u003e\u003c/code\u003e has and not yet\n been de-initialized with \u003ccode\u003e\u003ca\u003eexit\u003c/a\u003e\u003c/code\u003e. Contains\n \u003ccode\u003e\u003ca\u003eFalse\u003c/a\u003e\u003c/code\u003e otherwise.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.State",
          "name": "initState",
          "package": "GLUT",
          "signature": "GettableStateVar Bool",
          "source": "src/Graphics-UI-GLUT-State.html#initState",
          "type": "function"
        },
        "index": {
          "description": "freeglut only Contains True if GLUT has been initialized with initialize or getArgsAndInitialize has and not yet been de-initialized with exit Contains False otherwise",
          "hierarchy": "Graphics UI GLUT State",
          "module": "Graphics.UI.GLUT.State",
          "name": "initState",
          "package": "GLUT",
          "partial": "State",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-State.html#v:initState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eContains \u003ccode\u003e\u003ca\u003eJust\u003c/a\u003e\u003c/code\u003e the number of buttons of an attached joystick, the number\n of joystick axes, and the rate at which the joystick is polled. Contains\n \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e if there is no joystick attached.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.State",
          "name": "joystickInfo",
          "package": "GLUT",
          "signature": "GettableStateVar (Maybe (ButtonCount, PollRate, AxisCount))",
          "source": "src/Graphics-UI-GLUT-State.html#joystickInfo",
          "type": "function"
        },
        "index": {
          "description": "Contains Just the number of buttons of an attached joystick the number of joystick axes and the rate at which the joystick is polled Contains Nothing if there is no joystick attached",
          "hierarchy": "Graphics UI GLUT State",
          "module": "Graphics.UI.GLUT.State",
          "name": "joystickInfo",
          "normalized": "GettableStateVar(Maybe(ButtonCount,PollRate,AxisCount))",
          "package": "GLUT",
          "partial": "Info",
          "signature": "GettableStateVar(Maybe(ButtonCount,PollRate,AxisCount))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-State.html#v:joystickInfo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eContains \u003ccode\u003e\u003ca\u003eJust\u003c/a\u003e\u003c/code\u003e the number of dials and buttons of an attached dial &\n button box or \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e if there is none.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.State",
          "name": "numDialsAndButtons",
          "package": "GLUT",
          "signature": "GettableStateVar (Maybe (DialCount, ButtonCount))",
          "source": "src/Graphics-UI-GLUT-State.html#numDialsAndButtons",
          "type": "function"
        },
        "index": {
          "description": "Contains Just the number of dials and buttons of an attached dial button box or Nothing if there is none",
          "hierarchy": "Graphics UI GLUT State",
          "module": "Graphics.UI.GLUT.State",
          "name": "numDialsAndButtons",
          "normalized": "GettableStateVar(Maybe(DialCount,ButtonCount))",
          "package": "GLUT",
          "partial": "Dials And Buttons",
          "signature": "GettableStateVar(Maybe(DialCount,ButtonCount))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-State.html#v:numDialsAndButtons"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eContains \u003ccode\u003e\u003ca\u003eJust\u003c/a\u003e\u003c/code\u003e the number of buttons of an attached mouse or \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e if\n there is none.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.State",
          "name": "numMouseButtons",
          "package": "GLUT",
          "signature": "GettableStateVar (Maybe ButtonCount)",
          "source": "src/Graphics-UI-GLUT-State.html#numMouseButtons",
          "type": "function"
        },
        "index": {
          "description": "Contains Just the number of buttons of an attached mouse or Nothing if there is none",
          "hierarchy": "Graphics UI GLUT State",
          "module": "Graphics.UI.GLUT.State",
          "name": "numMouseButtons",
          "package": "GLUT",
          "partial": "Mouse Buttons",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-State.html#v:numMouseButtons"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eContains \u003ccode\u003e\u003ca\u003eJust\u003c/a\u003e\u003c/code\u003e the number of buttons of the attached Spaceball or \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e\n if there is none.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.State",
          "name": "numSpaceballButtons",
          "package": "GLUT",
          "signature": "GettableStateVar (Maybe ButtonCount)",
          "source": "src/Graphics-UI-GLUT-State.html#numSpaceballButtons",
          "type": "function"
        },
        "index": {
          "description": "Contains Just the number of buttons of the attached Spaceball or Nothing if there is none",
          "hierarchy": "Graphics UI GLUT State",
          "module": "Graphics.UI.GLUT.State",
          "name": "numSpaceballButtons",
          "package": "GLUT",
          "partial": "Spaceball Buttons",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-State.html#v:numSpaceballButtons"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eContains \u003ccode\u003e\u003ca\u003eJust\u003c/a\u003e\u003c/code\u003e the number of buttons of an attached tablet or \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e if\n there is none.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.State",
          "name": "numTabletButtons",
          "package": "GLUT",
          "signature": "GettableStateVar (Maybe ButtonCount)",
          "source": "src/Graphics-UI-GLUT-State.html#numTabletButtons",
          "type": "function"
        },
        "index": {
          "description": "Contains Just the number of buttons of an attached tablet or Nothing if there is none",
          "hierarchy": "Graphics UI GLUT State",
          "module": "Graphics.UI.GLUT.State",
          "name": "numTabletButtons",
          "package": "GLUT",
          "partial": "Tablet Buttons",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-State.html#v:numTabletButtons"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eContains \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e when the current layer of the \u003cem\u003ecurrent window\u003c/em\u003e is in RGBA\n mode, \u003ccode\u003e\u003ca\u003eFalse\u003c/a\u003e\u003c/code\u003e means color index mode.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.State",
          "name": "rgba",
          "package": "GLUT",
          "signature": "GettableStateVar Bool",
          "source": "src/Graphics-UI-GLUT-State.html#rgba",
          "type": "function"
        },
        "index": {
          "description": "Contains True when the current layer of the current window is in RGBA mode False means color index mode",
          "hierarchy": "Graphics UI GLUT State",
          "module": "Graphics.UI.GLUT.State",
          "name": "rgba",
          "package": "GLUT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-State.html#v:rgba"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eContains the number of red, green, blue, and alpha bits in the color buffer\n of the \u003cem\u003ecurrent window\\'s\u003c/em\u003e current layer (0 in color index mode).\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.State",
          "name": "rgbaBufferDepths",
          "package": "GLUT",
          "signature": "GettableStateVar (BufferDepth, BufferDepth, BufferDepth, BufferDepth)",
          "source": "src/Graphics-UI-GLUT-State.html#rgbaBufferDepths",
          "type": "function"
        },
        "index": {
          "description": "Contains the number of red green blue and alpha bits in the color buffer of the current window current layer in color index mode",
          "hierarchy": "Graphics UI GLUT State",
          "module": "Graphics.UI.GLUT.State",
          "name": "rgbaBufferDepths",
          "normalized": "GettableStateVar(BufferDepth,BufferDepth,BufferDepth,BufferDepth)",
          "package": "GLUT",
          "partial": "Buffer Depths",
          "signature": "GettableStateVar(BufferDepth,BufferDepth,BufferDepth,BufferDepth)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-State.html#v:rgbaBufferDepths"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eContains the number of samples for multisampling for the \u003cem\u003ecurrent window.\u003c/em\u003e\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.State",
          "name": "sampleCount",
          "package": "GLUT",
          "signature": "GettableStateVar SampleCount",
          "source": "src/Graphics-UI-GLUT-State.html#sampleCount",
          "type": "function"
        },
        "index": {
          "description": "Contains the number of samples for multisampling for the current window",
          "hierarchy": "Graphics UI GLUT State",
          "module": "Graphics.UI.GLUT.State",
          "name": "sampleCount",
          "package": "GLUT",
          "partial": "Count",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-State.html#v:sampleCount"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe size of the screen in pixels.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.State",
          "name": "screenSize",
          "package": "GLUT",
          "signature": "GettableStateVar Size",
          "source": "src/Graphics-UI-GLUT-State.html#screenSize",
          "type": "function"
        },
        "index": {
          "description": "The size of the screen in pixels",
          "hierarchy": "Graphics UI GLUT State",
          "module": "Graphics.UI.GLUT.State",
          "name": "screenSize",
          "package": "GLUT",
          "partial": "Size",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-State.html#v:screenSize"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe size of the screen in millimeters.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.State",
          "name": "screenSizeMM",
          "package": "GLUT",
          "signature": "GettableStateVar Size",
          "source": "src/Graphics-UI-GLUT-State.html#screenSizeMM",
          "type": "function"
        },
        "index": {
          "description": "The size of the screen in millimeters",
          "hierarchy": "Graphics UI GLUT State",
          "module": "Graphics.UI.GLUT.State",
          "name": "screenSizeMM",
          "package": "GLUT",
          "partial": "Size MM",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-State.html#v:screenSizeMM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e(\u003cem\u003efreeglut on X11 only\u003c/em\u003e) Controls if all but the last motion event should\n be discarded.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.State",
          "name": "skipStaleMotionEvents",
          "package": "GLUT",
          "signature": "StateVar Bool",
          "source": "src/Graphics-UI-GLUT-State.html#skipStaleMotionEvents",
          "type": "function"
        },
        "index": {
          "description": "freeglut on X11 only Controls if all but the last motion event should be discarded",
          "hierarchy": "Graphics UI GLUT State",
          "module": "Graphics.UI.GLUT.State",
          "name": "skipStaleMotionEvents",
          "package": "GLUT",
          "partial": "Stale Motion Events",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-State.html#v:skipStaleMotionEvents"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eContains the number of bits in the stencil buffer of the /current\n window's/ current layer.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.State",
          "name": "stencilBufferDepth",
          "package": "GLUT",
          "signature": "GettableStateVar BufferDepth",
          "source": "src/Graphics-UI-GLUT-State.html#stencilBufferDepth",
          "type": "function"
        },
        "index": {
          "description": "Contains the number of bits in the stencil buffer of the current window current layer",
          "hierarchy": "Graphics UI GLUT State",
          "module": "Graphics.UI.GLUT.State",
          "name": "stencilBufferDepth",
          "package": "GLUT",
          "partial": "Buffer Depth",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-State.html#v:stencilBufferDepth"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eContains \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e when the current layer of the \u003cem\u003ecurrent window\u003c/em\u003e is stereo,\n \u003ccode\u003e\u003ca\u003eFalse\u003c/a\u003e\u003c/code\u003e otherwise.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.State",
          "name": "stereo",
          "package": "GLUT",
          "signature": "GettableStateVar Bool",
          "source": "src/Graphics-UI-GLUT-State.html#stereo",
          "type": "function"
        },
        "index": {
          "description": "Contains True when the current layer of the current window is stereo False otherwise",
          "hierarchy": "Graphics UI GLUT State",
          "module": "Graphics.UI.GLUT.State",
          "name": "stereo",
          "package": "GLUT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-State.html#v:stereo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e(\u003cem\u003efreeglut only\u003c/em\u003e) Contains a list of the number of auxiliary buffers\n supported, in increasing order.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.State",
          "name": "supportedNumAuxBuffers",
          "package": "GLUT",
          "signature": "GettableStateVar [Int]",
          "source": "src/Graphics-UI-GLUT-State.html#supportedNumAuxBuffers",
          "type": "function"
        },
        "index": {
          "description": "freeglut only Contains list of the number of auxiliary buffers supported in increasing order",
          "hierarchy": "Graphics UI GLUT State",
          "module": "Graphics.UI.GLUT.State",
          "name": "supportedNumAuxBuffers",
          "normalized": "GettableStateVar[Int]",
          "package": "GLUT",
          "partial": "Num Aux Buffers",
          "signature": "GettableStateVar[Int]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-State.html#v:supportedNumAuxBuffers"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e(\u003cem\u003efreeglut only\u003c/em\u003e) Contains a list of the number of samples per pixel\n supported for multisampling, in increasing order.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.State",
          "name": "supportedSamplesPerPixel",
          "package": "GLUT",
          "signature": "GettableStateVar [SampleCount]",
          "source": "src/Graphics-UI-GLUT-State.html#supportedSamplesPerPixel",
          "type": "function"
        },
        "index": {
          "description": "freeglut only Contains list of the number of samples per pixel supported for multisampling in increasing order",
          "hierarchy": "Graphics UI GLUT State",
          "module": "Graphics.UI.GLUT.State",
          "name": "supportedSamplesPerPixel",
          "normalized": "GettableStateVar[SampleCount]",
          "package": "GLUT",
          "partial": "Samples Per Pixel",
          "signature": "GettableStateVar[SampleCount]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-State.html#v:supportedSamplesPerPixel"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e(\u003cem\u003efreeglut only\u003c/em\u003e) If \u003ccode\u003e\u003ca\u003evertexAttribCoord3\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003evertexAttribNormal\u003c/a\u003e\u003c/code\u003e both\n contain \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e, the fixed function pipeline is used to draw\n objects. Otherwise VBOs are used and the coordinates are passed via \u003ccode\u003e\u003ca\u003eJust\u003c/a\u003e\u003c/code\u003e\n this attribute location (for a vec3).\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.State",
          "name": "vertexAttribCoord3",
          "package": "GLUT",
          "signature": "SettableStateVar (Maybe AttribLocation)",
          "source": "src/Graphics-UI-GLUT-State.html#vertexAttribCoord3",
          "type": "function"
        },
        "index": {
          "description": "freeglut only If vertexAttribCoord3 and vertexAttribNormal both contain Nothing the fixed function pipeline is used to draw objects Otherwise VBOs are used and the coordinates are passed via Just this attribute location for vec3",
          "hierarchy": "Graphics UI GLUT State",
          "module": "Graphics.UI.GLUT.State",
          "name": "vertexAttribCoord3",
          "package": "GLUT",
          "partial": "Attrib Coord",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-State.html#v:vertexAttribCoord3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e(\u003cem\u003efreeglut only\u003c/em\u003e) If \u003ccode\u003e\u003ca\u003evertexAttribCoord3\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003evertexAttribNormal\u003c/a\u003e\u003c/code\u003e both\n contain \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e, the fixed function pipeline is used to draw\n objects. Otherwise VBOs are used and the normals are passed via \u003ccode\u003e\u003ca\u003eJust\u003c/a\u003e\u003c/code\u003e this\n attribute location (for a vec3).\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.State",
          "name": "vertexAttribNormal",
          "package": "GLUT",
          "signature": "SettableStateVar (Maybe AttribLocation)",
          "source": "src/Graphics-UI-GLUT-State.html#vertexAttribNormal",
          "type": "function"
        },
        "index": {
          "description": "freeglut only If vertexAttribCoord3 and vertexAttribNormal both contain Nothing the fixed function pipeline is used to draw objects Otherwise VBOs are used and the normals are passed via Just this attribute location for vec3",
          "hierarchy": "Graphics UI GLUT State",
          "module": "Graphics.UI.GLUT.State",
          "name": "vertexAttribNormal",
          "package": "GLUT",
          "partial": "Attrib Normal",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-State.html#v:vertexAttribNormal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e(\u003cem\u003efreeglut only\u003c/em\u003e) If VBOs are used to draw objects (controlled via\n \u003ccode\u003e\u003ca\u003evertexAttribCoord3\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003evertexAttribNormal\u003c/a\u003e\u003c/code\u003e), the texture coordinates are\n passed via \u003ccode\u003e\u003ca\u003eJust\u003c/a\u003e\u003c/code\u003e this attribute location (for a vec2).\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.State",
          "name": "vertexAttribTexCoord2",
          "package": "GLUT",
          "signature": "SettableStateVar (Maybe AttribLocation)",
          "source": "src/Graphics-UI-GLUT-State.html#vertexAttribTexCoord2",
          "type": "function"
        },
        "index": {
          "description": "freeglut only If VBOs are used to draw objects controlled via vertexAttribCoord3 and vertexAttribNormal the texture coordinates are passed via Just this attribute location for vec2",
          "hierarchy": "Graphics UI GLUT State",
          "module": "Graphics.UI.GLUT.State",
          "name": "vertexAttribTexCoord2",
          "package": "GLUT",
          "partial": "Attrib Tex Coord",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-State.html#v:vertexAttribTexCoord2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e(\u003cem\u003efreeglut only\u003c/em\u003e) Contains the thickness of the sizing border around the\n perimeter of a window that can be resized, in pixels.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.State",
          "name": "windowBorderWidth",
          "package": "GLUT",
          "signature": "GettableStateVar Int",
          "source": "src/Graphics-UI-GLUT-State.html#windowBorderWidth",
          "type": "function"
        },
        "index": {
          "description": "freeglut only Contains the thickness of the sizing border around the perimeter of window that can be resized in pixels",
          "hierarchy": "Graphics UI GLUT State",
          "module": "Graphics.UI.GLUT.State",
          "name": "windowBorderWidth",
          "package": "GLUT",
          "partial": "Border Width",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-State.html#v:windowBorderWidth"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e(\u003cem\u003efreeglut only\u003c/em\u003e) Contains the height of the header/caption area of a\n window in pixels.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.State",
          "name": "windowHeaderHeight",
          "package": "GLUT",
          "signature": "GettableStateVar Int",
          "source": "src/Graphics-UI-GLUT-State.html#windowHeaderHeight",
          "type": "function"
        },
        "index": {
          "description": "freeglut only Contains the height of the header caption area of window in pixels",
          "hierarchy": "Graphics UI GLUT State",
          "module": "Graphics.UI.GLUT.State",
          "name": "windowHeaderHeight",
          "package": "GLUT",
          "partial": "Header Height",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-State.html#v:windowHeaderHeight"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eGLUT supports two types of windows: top-level windows and subwindows. Both\n types support OpenGL rendering and GLUT callbacks. There is a single\n identifier space for both types of windows.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Graphics.UI.GLUT.Window",
          "name": "Window",
          "package": "GLUT",
          "source": "src/Graphics-UI-GLUT-Window.html",
          "type": "module"
        },
        "index": {
          "description": "GLUT supports two types of windows top-level windows and subwindows Both types support OpenGL rendering and GLUT callbacks There is single identifier space for both types of windows",
          "hierarchy": "Graphics UI GLUT Window",
          "module": "Graphics.UI.GLUT.Window",
          "name": "Window",
          "package": "GLUT",
          "partial": "Window",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Window.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe different cursor images GLUT supports.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Window",
          "name": "Cursor",
          "package": "GLUT",
          "source": "src/Graphics-UI-GLUT-Window.html#Cursor",
          "type": "data"
        },
        "index": {
          "description": "The different cursor images GLUT supports",
          "hierarchy": "Graphics UI GLUT Window",
          "module": "Graphics.UI.GLUT.Window",
          "name": "Cursor",
          "package": "GLUT",
          "partial": "Cursor",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Window.html#t:Cursor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn opaque identifier for a top-level window or a subwindow.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Window",
          "name": "Window",
          "package": "GLUT",
          "source": "src/Graphics-UI-GLUT-Types.html#Window",
          "type": "data"
        },
        "index": {
          "description": "An opaque identifier for top-level window or subwindow",
          "hierarchy": "Graphics UI GLUT Window",
          "module": "Graphics.UI.GLUT.Window",
          "name": "Window",
          "package": "GLUT",
          "partial": "Window",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Window.html#t:Window"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe display status of a window.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Window",
          "name": "WindowStatus",
          "package": "GLUT",
          "source": "src/Graphics-UI-GLUT-Window.html#WindowStatus",
          "type": "data"
        },
        "index": {
          "description": "The display status of window",
          "hierarchy": "Graphics UI GLUT Window",
          "module": "Graphics.UI.GLUT.Window",
          "name": "WindowStatus",
          "package": "GLUT",
          "partial": "Window Status",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Window.html#t:WindowStatus"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eArrow pointing to bottom-right corner.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Window",
          "name": "BottomLeftCorner",
          "package": "GLUT",
          "signature": "BottomLeftCorner",
          "source": "src/Graphics-UI-GLUT-Window.html#Cursor",
          "type": "function"
        },
        "index": {
          "description": "Arrow pointing to bottom-right corner",
          "hierarchy": "Graphics UI GLUT Window",
          "module": "Graphics.UI.GLUT.Window",
          "name": "BottomLeftCorner",
          "package": "GLUT",
          "partial": "Bottom Left Corner",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Window.html#v:BottomLeftCorner"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eArrow pointing to bottom-left corner.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Window",
          "name": "BottomRightCorner",
          "package": "GLUT",
          "signature": "BottomRightCorner",
          "source": "src/Graphics-UI-GLUT-Window.html#Cursor",
          "type": "function"
        },
        "index": {
          "description": "Arrow pointing to bottom-left corner",
          "hierarchy": "Graphics UI GLUT Window",
          "module": "Graphics.UI.GLUT.Window",
          "name": "BottomRightCorner",
          "package": "GLUT",
          "partial": "Bottom Right Corner",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Window.html#v:BottomRightCorner"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eArrow pointing to bottom side.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Window",
          "name": "BottomSide",
          "package": "GLUT",
          "signature": "BottomSide",
          "source": "src/Graphics-UI-GLUT-Window.html#Cursor",
          "type": "function"
        },
        "index": {
          "description": "Arrow pointing to bottom side",
          "hierarchy": "Graphics UI GLUT Window",
          "module": "Graphics.UI.GLUT.Window",
          "name": "BottomSide",
          "package": "GLUT",
          "partial": "Bottom Side",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Window.html#v:BottomSide"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSimple cross-hair.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Window",
          "name": "Crosshair",
          "package": "GLUT",
          "signature": "Crosshair",
          "source": "src/Graphics-UI-GLUT-Window.html#Cursor",
          "type": "function"
        },
        "index": {
          "description": "Simple cross-hair",
          "hierarchy": "Graphics UI GLUT Window",
          "module": "Graphics.UI.GLUT.Window",
          "name": "Crosshair",
          "package": "GLUT",
          "partial": "Crosshair",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Window.html#v:Crosshair"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eArrows rotating in a circle.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Window",
          "name": "Cycle",
          "package": "GLUT",
          "signature": "Cycle",
          "source": "src/Graphics-UI-GLUT-Window.html#Cursor",
          "type": "function"
        },
        "index": {
          "description": "Arrows rotating in circle",
          "hierarchy": "Graphics UI GLUT Window",
          "module": "Graphics.UI.GLUT.Window",
          "name": "Cycle",
          "package": "GLUT",
          "partial": "Cycle",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Window.html#v:Cycle"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSkull & cross bones.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Window",
          "name": "Destroy",
          "package": "GLUT",
          "signature": "Destroy",
          "source": "src/Graphics-UI-GLUT-Window.html#Cursor",
          "type": "function"
        },
        "index": {
          "description": "Skull cross bones",
          "hierarchy": "Graphics UI GLUT Window",
          "module": "Graphics.UI.GLUT.Window",
          "name": "Destroy",
          "package": "GLUT",
          "partial": "Destroy",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Window.html#v:Destroy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFull-screen cross-hair cursor (if possible, otherwise \u003ccode\u003e\u003ca\u003eCrosshair\u003c/a\u003e\u003c/code\u003e).\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Window",
          "name": "FullCrosshair",
          "package": "GLUT",
          "signature": "FullCrosshair",
          "source": "src/Graphics-UI-GLUT-Window.html#Cursor",
          "type": "function"
        },
        "index": {
          "description": "Full-screen cross-hair cursor if possible otherwise Crosshair",
          "hierarchy": "Graphics UI GLUT Window",
          "module": "Graphics.UI.GLUT.Window",
          "name": "FullCrosshair",
          "package": "GLUT",
          "partial": "Full Crosshair",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Window.html#v:FullCrosshair"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eQuestion mark.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Window",
          "name": "Help",
          "package": "GLUT",
          "signature": "Help",
          "source": "src/Graphics-UI-GLUT-Window.html#Cursor",
          "type": "function"
        },
        "index": {
          "description": "Question mark",
          "hierarchy": "Graphics UI GLUT Window",
          "module": "Graphics.UI.GLUT.Window",
          "name": "Help",
          "package": "GLUT",
          "partial": "Help",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Window.html#v:Help"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.UI.GLUT.Window",
          "name": "Hidden",
          "package": "GLUT",
          "signature": "Hidden",
          "source": "src/Graphics-UI-GLUT-Window.html#WindowStatus",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics UI GLUT Window",
          "module": "Graphics.UI.GLUT.Window",
          "name": "Hidden",
          "package": "GLUT",
          "partial": "Hidden",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Window.html#v:Hidden"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.UI.GLUT.Window",
          "name": "Iconified",
          "package": "GLUT",
          "signature": "Iconified",
          "source": "src/Graphics-UI-GLUT-Window.html#WindowStatus",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics UI GLUT Window",
          "module": "Graphics.UI.GLUT.Window",
          "name": "Iconified",
          "package": "GLUT",
          "partial": "Iconified",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Window.html#v:Iconified"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePointing hand.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Window",
          "name": "Info",
          "package": "GLUT",
          "signature": "Info",
          "source": "src/Graphics-UI-GLUT-Window.html#Cursor",
          "type": "function"
        },
        "index": {
          "description": "Pointing hand",
          "hierarchy": "Graphics UI GLUT Window",
          "module": "Graphics.UI.GLUT.Window",
          "name": "Info",
          "package": "GLUT",
          "partial": "Info",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Window.html#v:Info"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUse parent's cursor.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Window",
          "name": "Inherit",
          "package": "GLUT",
          "signature": "Inherit",
          "source": "src/Graphics-UI-GLUT-Window.html#Cursor",
          "type": "function"
        },
        "index": {
          "description": "Use parent cursor",
          "hierarchy": "Graphics UI GLUT Window",
          "module": "Graphics.UI.GLUT.Window",
          "name": "Inherit",
          "package": "GLUT",
          "partial": "Inherit",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Window.html#v:Inherit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eArrow pointing up and to the left.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Window",
          "name": "LeftArrow",
          "package": "GLUT",
          "signature": "LeftArrow",
          "source": "src/Graphics-UI-GLUT-Window.html#Cursor",
          "type": "function"
        },
        "index": {
          "description": "Arrow pointing up and to the left",
          "hierarchy": "Graphics UI GLUT Window",
          "module": "Graphics.UI.GLUT.Window",
          "name": "LeftArrow",
          "package": "GLUT",
          "partial": "Left Arrow",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Window.html#v:LeftArrow"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eBi-directional pointing left & right.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Window",
          "name": "LeftRight",
          "package": "GLUT",
          "signature": "LeftRight",
          "source": "src/Graphics-UI-GLUT-Window.html#Cursor",
          "type": "function"
        },
        "index": {
          "description": "Bi-directional pointing left right",
          "hierarchy": "Graphics UI GLUT Window",
          "module": "Graphics.UI.GLUT.Window",
          "name": "LeftRight",
          "package": "GLUT",
          "partial": "Left Right",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Window.html#v:LeftRight"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eArrow pointing to left side.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Window",
          "name": "LeftSide",
          "package": "GLUT",
          "signature": "LeftSide",
          "source": "src/Graphics-UI-GLUT-Window.html#Cursor",
          "type": "function"
        },
        "index": {
          "description": "Arrow pointing to left side",
          "hierarchy": "Graphics UI GLUT Window",
          "module": "Graphics.UI.GLUT.Window",
          "name": "LeftSide",
          "package": "GLUT",
          "partial": "Left Side",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Window.html#v:LeftSide"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInvisible cursor.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Window",
          "name": "None",
          "package": "GLUT",
          "signature": "None",
          "source": "src/Graphics-UI-GLUT-Window.html#Cursor",
          "type": "function"
        },
        "index": {
          "description": "Invisible cursor",
          "hierarchy": "Graphics UI GLUT Window",
          "module": "Graphics.UI.GLUT.Window",
          "name": "None",
          "package": "GLUT",
          "partial": "None",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Window.html#v:None"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eArrow pointing up and to the right.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Window",
          "name": "RightArrow",
          "package": "GLUT",
          "signature": "RightArrow",
          "source": "src/Graphics-UI-GLUT-Window.html#Cursor",
          "type": "function"
        },
        "index": {
          "description": "Arrow pointing up and to the right",
          "hierarchy": "Graphics UI GLUT Window",
          "module": "Graphics.UI.GLUT.Window",
          "name": "RightArrow",
          "package": "GLUT",
          "partial": "Right Arrow",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Window.html#v:RightArrow"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eArrow pointing to right side.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Window",
          "name": "RightSide",
          "package": "GLUT",
          "signature": "RightSide",
          "source": "src/Graphics-UI-GLUT-Window.html#Cursor",
          "type": "function"
        },
        "index": {
          "description": "Arrow pointing to right side",
          "hierarchy": "Graphics UI GLUT Window",
          "module": "Graphics.UI.GLUT.Window",
          "name": "RightSide",
          "package": "GLUT",
          "partial": "Right Side",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Window.html#v:RightSide"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.UI.GLUT.Window",
          "name": "Shown",
          "package": "GLUT",
          "signature": "Shown",
          "source": "src/Graphics-UI-GLUT-Window.html#WindowStatus",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics UI GLUT Window",
          "module": "Graphics.UI.GLUT.Window",
          "name": "Shown",
          "package": "GLUT",
          "partial": "Shown",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Window.html#v:Shown"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSpray can.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Window",
          "name": "Spray",
          "package": "GLUT",
          "signature": "Spray",
          "source": "src/Graphics-UI-GLUT-Window.html#Cursor",
          "type": "function"
        },
        "index": {
          "description": "Spray can",
          "hierarchy": "Graphics UI GLUT Window",
          "module": "Graphics.UI.GLUT.Window",
          "name": "Spray",
          "package": "GLUT",
          "partial": "Spray",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Window.html#v:Spray"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInsertion point cursor for text.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Window",
          "name": "Text",
          "package": "GLUT",
          "signature": "Text",
          "source": "src/Graphics-UI-GLUT-Window.html#Cursor",
          "type": "function"
        },
        "index": {
          "description": "Insertion point cursor for text",
          "hierarchy": "Graphics UI GLUT Window",
          "module": "Graphics.UI.GLUT.Window",
          "name": "Text",
          "package": "GLUT",
          "partial": "Text",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Window.html#v:Text"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eArrow pointing to top-left corner.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Window",
          "name": "TopLeftCorner",
          "package": "GLUT",
          "signature": "TopLeftCorner",
          "source": "src/Graphics-UI-GLUT-Window.html#Cursor",
          "type": "function"
        },
        "index": {
          "description": "Arrow pointing to top-left corner",
          "hierarchy": "Graphics UI GLUT Window",
          "module": "Graphics.UI.GLUT.Window",
          "name": "TopLeftCorner",
          "package": "GLUT",
          "partial": "Top Left Corner",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Window.html#v:TopLeftCorner"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eArrow pointing to top-right corner.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Window",
          "name": "TopRightCorner",
          "package": "GLUT",
          "signature": "TopRightCorner",
          "source": "src/Graphics-UI-GLUT-Window.html#Cursor",
          "type": "function"
        },
        "index": {
          "description": "Arrow pointing to top-right corner",
          "hierarchy": "Graphics UI GLUT Window",
          "module": "Graphics.UI.GLUT.Window",
          "name": "TopRightCorner",
          "package": "GLUT",
          "partial": "Top Right Corner",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Window.html#v:TopRightCorner"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eArrow pointing to top side.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Window",
          "name": "TopSide",
          "package": "GLUT",
          "signature": "TopSide",
          "source": "src/Graphics-UI-GLUT-Window.html#Cursor",
          "type": "function"
        },
        "index": {
          "description": "Arrow pointing to top side",
          "hierarchy": "Graphics UI GLUT Window",
          "module": "Graphics.UI.GLUT.Window",
          "name": "TopSide",
          "package": "GLUT",
          "partial": "Top Side",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Window.html#v:TopSide"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eBi-directional pointing up & down.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Window",
          "name": "UpDown",
          "package": "GLUT",
          "signature": "UpDown",
          "source": "src/Graphics-UI-GLUT-Window.html#Cursor",
          "type": "function"
        },
        "index": {
          "description": "Bi-directional pointing up down",
          "hierarchy": "Graphics UI GLUT Window",
          "module": "Graphics.UI.GLUT.Window",
          "name": "UpDown",
          "package": "GLUT",
          "partial": "Up Down",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Window.html#v:UpDown"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWrist watch.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Window",
          "name": "Wait",
          "package": "GLUT",
          "signature": "Wait",
          "source": "src/Graphics-UI-GLUT-Window.html#Cursor",
          "type": "function"
        },
        "index": {
          "description": "Wrist watch",
          "hierarchy": "Graphics UI GLUT Window",
          "module": "Graphics.UI.GLUT.Window",
          "name": "Wait",
          "package": "GLUT",
          "partial": "Wait",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Window.html#v:Wait"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreate a subwindow of the identified window with the given relative\n position and size. Implicitly, the \u003cem\u003ecurrent window\u003c/em\u003e is set to the\n newly created subwindow. Subwindows can be nested arbitrarily deep.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Window",
          "name": "createSubWindow",
          "package": "GLUT",
          "signature": "Window-\u003e Position-\u003e Size-\u003e IO Window",
          "type": "function"
        },
        "index": {
          "description": "Create subwindow of the identified window with the given relative position and size Implicitly the current window is set to the newly created subwindow Subwindows can be nested arbitrarily deep",
          "hierarchy": "Graphics UI GLUT Window",
          "module": "Graphics.UI.GLUT.Window",
          "name": "createSubWindow",
          "normalized": "Window-\u003ePosition-\u003eSize-\u003eIO Window",
          "package": "GLUT",
          "partial": "Sub Window",
          "signature": "Window-\u003ePosition-\u003eSize-\u003eIO Window",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Window.html#v:createSubWindow"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreate a top-level window. The given name will be provided to the window\n system as the window's name. The intent is that the window system will label\n the window with the name.Implicitly, the \u003cem\u003ecurrent window\u003c/em\u003e is set to the newly\n created window.\n\u003c/p\u003e\u003cp\u003e\u003cem\u003eX Implementation Notes:\u003c/em\u003e The proper X Inter-Client Communication Conventions\n Manual (ICCCM) top-level properties are established. The \u003ccode\u003eWM_COMMAND\u003c/code\u003e\n property that lists the command line used to invoke the GLUT program is only\n established for the first window created.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Window",
          "name": "createWindow",
          "package": "GLUT",
          "signature": "String-\u003e IO Window",
          "type": "function"
        },
        "index": {
          "description": "Create top-level window The given name will be provided to the window system as the window name The intent is that the window system will label the window with the name.Implicitly the current window is set to the newly created window Implementation Notes The proper Inter-Client Communication Conventions Manual ICCCM top-level properties are established The WM COMMAND property that lists the command line used to invoke the GLUT program is only established for the first window created",
          "hierarchy": "Graphics UI GLUT Window",
          "module": "Graphics.UI.GLUT.Window",
          "name": "createWindow",
          "normalized": "String-\u003eIO Window",
          "package": "GLUT",
          "partial": "Window",
          "signature": "String-\u003eIO Window",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Window.html#v:createWindow"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eControls the \u003cem\u003ecurrent window\u003c/em\u003e. It does \u003cem\u003enot\u003c/em\u003e affect the \u003cem\u003elayer in use\u003c/em\u003e for\n the window; this is done using \u003ccode\u003e\u003ca\u003elayerInUse\u003c/a\u003e\u003c/code\u003e.\n Contains \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e if no windows exist or the previously \u003cem\u003ecurrent window\u003c/em\u003e was\n destroyed. Setting the \u003cem\u003ecurrent window\u003c/em\u003e to \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e is a no-op.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Window",
          "name": "currentWindow",
          "package": "GLUT",
          "signature": "StateVar (Maybe Window)",
          "source": "src/Graphics-UI-GLUT-Window.html#currentWindow",
          "type": "function"
        },
        "index": {
          "description": "Controls the current window It does not affect the layer in use for the window this is done using layerInUse Contains Nothing if no windows exist or the previously current window was destroyed Setting the current window to Nothing is no-op",
          "hierarchy": "Graphics UI GLUT Window",
          "module": "Graphics.UI.GLUT.Window",
          "name": "currentWindow",
          "package": "GLUT",
          "partial": "Window",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Window.html#v:currentWindow"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eChange the cursor image of the \u003cem\u003ecurrent window\u003c/em\u003e. Each call requests the\n window system change the cursor appropriately. The cursor image when a window\n is created is \u003ccode\u003e\u003ca\u003eInherit\u003c/a\u003e\u003c/code\u003e. The exact cursor images used are implementation\n dependent. The intent is for the image to convey the meaning of the cursor\n name. For a top-level window, \u003ccode\u003e\u003ca\u003eInherit\u003c/a\u003e\u003c/code\u003e uses the default window system\n cursor.\n\u003c/p\u003e\u003cp\u003e\u003cem\u003eX Implementation Notes:\u003c/em\u003e GLUT for X uses SGI's \u003ccode\u003e_SGI_CROSSHAIR_CURSOR\u003c/code\u003e\n convention to access a full-screen cross-hair cursor if possible.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Window",
          "name": "cursor",
          "package": "GLUT",
          "signature": "StateVar Cursor",
          "source": "src/Graphics-UI-GLUT-Window.html#cursor",
          "type": "function"
        },
        "index": {
          "description": "Change the cursor image of the current window Each call requests the window system change the cursor appropriately The cursor image when window is created is Inherit The exact cursor images used are implementation dependent The intent is for the image to convey the meaning of the cursor name For top-level window Inherit uses the default window system cursor Implementation Notes GLUT for uses SGI SGI CROSSHAIR CURSOR convention to access full-screen cross-hair cursor if possible",
          "hierarchy": "Graphics UI GLUT Window",
          "module": "Graphics.UI.GLUT.Window",
          "name": "cursor",
          "package": "GLUT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Window.html#v:cursor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDestroy the specified window and the window's associated OpenGL context,\n logical colormap (if the window is color index), and overlay and related\n state (if an overlay has been established). Any subwindows of the destroyed\n window are also destroyed by \u003ccode\u003e\u003ca\u003edestroyWindow\u003c/a\u003e\u003c/code\u003e. If the specified window was the\n \u003cem\u003ecurrent window\u003c/em\u003e, the \u003cem\u003ecurrent window\u003c/em\u003e becomes invalid (\u003ccode\u003e\u003ca\u003ecurrentWindow\u003c/a\u003e\u003c/code\u003e will\n contain \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e).\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Window",
          "name": "destroyWindow",
          "package": "GLUT",
          "signature": "Window -\u003e IO ()",
          "source": "src/Graphics-UI-GLUT-Window.html#destroyWindow",
          "type": "function"
        },
        "index": {
          "description": "Destroy the specified window and the window associated OpenGL context logical colormap if the window is color index and overlay and related state if an overlay has been established Any subwindows of the destroyed window are also destroyed by destroyWindow If the specified window was the current window the current window becomes invalid currentWindow will contain Nothing",
          "hierarchy": "Graphics UI GLUT Window",
          "module": "Graphics.UI.GLUT.Window",
          "name": "destroyWindow",
          "normalized": "Window-\u003eIO()",
          "package": "GLUT",
          "partial": "Window",
          "signature": "Window-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Window.html#v:destroyWindow"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRequest that the \u003cem\u003ecurrent window\u003c/em\u003e be made full screen. The exact semantics\n of what full screen means may vary by window system. The intent is to make\n the window as large as possible and disable any window decorations or borders\n added the window system. The window width and height are not guaranteed to be\n the same as the screen width and height, but that is the intent of making a\n window full screen.\n\u003c/p\u003e\u003cp\u003e\u003ccode\u003e\u003ca\u003efullScreen\u003c/a\u003e\u003c/code\u003e is defined to work only on top-level windows.\n\u003c/p\u003e\u003cp\u003e\u003cem\u003eX Implementation Notes:\u003c/em\u003e In the X implementation of GLUT, full screen is\n implemented by sizing and positioning the window to cover the entire screen\n and posting the \u003ccode\u003e_MOTIF_WM_HINTS\u003c/code\u003e property on the window requesting\n absolutely no decorations. Non-Motif window managers may not respond to\n \u003ccode\u003e_MOTIF_WM_HINTS\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Window",
          "name": "fullScreen",
          "package": "GLUT",
          "signature": "IO ()",
          "source": "src/Graphics-UI-GLUT-Window.html#fullScreen",
          "type": "function"
        },
        "index": {
          "description": "Request that the current window be made full screen The exact semantics of what full screen means may vary by window system The intent is to make the window as large as possible and disable any window decorations or borders added the window system The window width and height are not guaranteed to be the same as the screen width and height but that is the intent of making window full screen fullScreen is defined to work only on top-level windows Implementation Notes In the implementation of GLUT full screen is implemented by sizing and positioning the window to cover the entire screen and posting the MOTIF WM HINTS property on the window requesting absolutely no decorations Non-Motif window managers may not respond to MOTIF WM HINTS",
          "hierarchy": "Graphics UI GLUT Window",
          "module": "Graphics.UI.GLUT.Window",
          "name": "fullScreen",
          "normalized": "IO()",
          "package": "GLUT",
          "partial": "Screen",
          "signature": "IO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Window.html#v:fullScreen"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e(\u003cem\u003efreeglut only\u003c/em\u003e) Toggle between windowed and full screen mode.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Window",
          "name": "fullScreenToggle",
          "package": "GLUT",
          "signature": "IO ()",
          "source": "src/Graphics-UI-GLUT-Window.html#fullScreenToggle",
          "type": "function"
        },
        "index": {
          "description": "freeglut only Toggle between windowed and full screen mode",
          "hierarchy": "Graphics UI GLUT Window",
          "module": "Graphics.UI.GLUT.Window",
          "name": "fullScreenToggle",
          "normalized": "IO()",
          "package": "GLUT",
          "partial": "Screen Toggle",
          "signature": "IO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Window.html#v:fullScreenToggle"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eControls the icon title of the \u003cem\u003ecurrent top-level window\u003c/em\u003e.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Window",
          "name": "iconTitle",
          "package": "GLUT",
          "signature": "SettableStateVar String",
          "source": "src/Graphics-UI-GLUT-Window.html#iconTitle",
          "type": "function"
        },
        "index": {
          "description": "Controls the icon title of the current top-level window",
          "hierarchy": "Graphics UI GLUT Window",
          "module": "Graphics.UI.GLUT.Window",
          "name": "iconTitle",
          "package": "GLUT",
          "partial": "Title",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Window.html#v:iconTitle"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e(\u003cem\u003efreeglut only\u003c/em\u003e) If we are in full screen mode, resize the current window\n back to its original size.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Window",
          "name": "leaveFullScreen",
          "package": "GLUT",
          "signature": "IO ()",
          "source": "src/Graphics-UI-GLUT-Window.html#leaveFullScreen",
          "type": "function"
        },
        "index": {
          "description": "freeglut only If we are in full screen mode resize the current window back to its original size",
          "hierarchy": "Graphics UI GLUT Window",
          "module": "Graphics.UI.GLUT.Window",
          "name": "leaveFullScreen",
          "normalized": "IO()",
          "package": "GLUT",
          "partial": "Full Screen",
          "signature": "IO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Window.html#v:leaveFullScreen"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eContains the number of subwindows the \u003cem\u003ecurrent window\u003c/em\u003e has, not counting\n children of children.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Window",
          "name": "numSubWindows",
          "package": "GLUT",
          "signature": "GettableStateVar Int",
          "source": "src/Graphics-UI-GLUT-Window.html#numSubWindows",
          "type": "function"
        },
        "index": {
          "description": "Contains the number of subwindows the current window has not counting children of children",
          "hierarchy": "Graphics UI GLUT Window",
          "module": "Graphics.UI.GLUT.Window",
          "name": "numSubWindows",
          "package": "GLUT",
          "partial": "Sub Windows",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Window.html#v:numSubWindows"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eContains the \u003cem\u003ecurrent window\\'s\u003c/em\u003e parent. If the \u003cem\u003ecurrent window\u003c/em\u003e is a\n top-level window, \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e is returned.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Window",
          "name": "parentWindow",
          "package": "GLUT",
          "signature": "GettableStateVar (Maybe Window)",
          "source": "src/Graphics-UI-GLUT-Window.html#parentWindow",
          "type": "function"
        },
        "index": {
          "description": "Contains the current window parent If the current window is top-level window Nothing is returned",
          "hierarchy": "Graphics UI GLUT Window",
          "module": "Graphics.UI.GLUT.Window",
          "name": "parentWindow",
          "package": "GLUT",
          "partial": "Window",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Window.html#v:parentWindow"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSetting \u003ccode\u003e\u003ca\u003epointerPosition\u003c/a\u003e\u003c/code\u003e warps the window system's pointer to a new\n location relative to the origin of the \u003cem\u003ecurrent window\u003c/em\u003e by the specified\n pixel offset, which may be negative. The warp is done immediately.\n\u003c/p\u003e\u003cp\u003eIf the pointer would be warped outside the screen's frame buffer region, the\n location will be clamped to the nearest screen edge. The window system is\n allowed to further constrain the pointer's location in window system\n dependent ways.\n\u003c/p\u003e\u003cp\u003eGood advice from Xlib's \u003ccode\u003eXWarpPointer\u003c/code\u003e man page: \"There is seldom any\n reason for calling this function. The pointer should normally be left to the\n user.\"\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Window",
          "name": "pointerPosition",
          "package": "GLUT",
          "signature": "SettableStateVar Position",
          "source": "src/Graphics-UI-GLUT-Window.html#pointerPosition",
          "type": "function"
        },
        "index": {
          "description": "Setting pointerPosition warps the window system pointer to new location relative to the origin of the current window by the specified pixel offset which may be negative The warp is done immediately If the pointer would be warped outside the screen frame buffer region the location will be clamped to the nearest screen edge The window system is allowed to further constrain the pointer location in window system dependent ways Good advice from Xlib XWarpPointer man page There is seldom any reason for calling this function The pointer should normally be left to the user",
          "hierarchy": "Graphics UI GLUT Window",
          "module": "Graphics.UI.GLUT.Window",
          "name": "pointerPosition",
          "package": "GLUT",
          "partial": "Position",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Window.html#v:pointerPosition"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eChange the stacking order of the \u003cem\u003ecurrent window\u003c/em\u003e relative to its siblings,\n bringing the \u003cem\u003ecurrent window\u003c/em\u003e closer to the top.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Window",
          "name": "popWindow",
          "package": "GLUT",
          "signature": "IO ()",
          "source": "src/Graphics-UI-GLUT-Window.html#popWindow",
          "type": "function"
        },
        "index": {
          "description": "Change the stacking order of the current window relative to its siblings bringing the current window closer to the top",
          "hierarchy": "Graphics UI GLUT Window",
          "module": "Graphics.UI.GLUT.Window",
          "name": "popWindow",
          "normalized": "IO()",
          "package": "GLUT",
          "partial": "Window",
          "signature": "IO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Window.html#v:popWindow"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMark the normal plane of given window (or the \u003cem\u003ecurrent window\u003c/em\u003e, if none\n is supplied) as needing to be redisplayed. The next iteration through\n \u003ccode\u003e\u003ca\u003emainLoop\u003c/a\u003e\u003c/code\u003e, the window's display callback will be\n called to redisplay the window's normal plane. Multiple calls to\n \u003ccode\u003e\u003ca\u003epostRedisplay\u003c/a\u003e\u003c/code\u003e before the next display callback opportunity generates only a\n single redisplay callback. \u003ccode\u003e\u003ca\u003epostRedisplay\u003c/a\u003e\u003c/code\u003e may be called within a window's\n display or overlay display callback to re-mark that window for redisplay.\n\u003c/p\u003e\u003cp\u003eLogically, normal plane damage notification for a window is treated as a\n \u003ccode\u003e\u003ca\u003epostRedisplay\u003c/a\u003e\u003c/code\u003e on the damaged window. Unlike damage reported by the window\n system, \u003ccode\u003e\u003ca\u003epostRedisplay\u003c/a\u003e\u003c/code\u003e will \u003cem\u003enot\u003c/em\u003e set to true the normal plane's damaged\n status (see \u003ccode\u003e\u003ca\u003edamaged\u003c/a\u003e\u003c/code\u003e).\n\u003c/p\u003e\u003cp\u003eAlso, see \u003ccode\u003e\u003ca\u003epostOverlayRedisplay\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Window",
          "name": "postRedisplay",
          "package": "GLUT",
          "signature": "Maybe Window -\u003e IO ()",
          "source": "src/Graphics-UI-GLUT-Window.html#postRedisplay",
          "type": "function"
        },
        "index": {
          "description": "Mark the normal plane of given window or the current window if none is supplied as needing to be redisplayed The next iteration through mainLoop the window display callback will be called to redisplay the window normal plane Multiple calls to postRedisplay before the next display callback opportunity generates only single redisplay callback postRedisplay may be called within window display or overlay display callback to re-mark that window for redisplay Logically normal plane damage notification for window is treated as postRedisplay on the damaged window Unlike damage reported by the window system postRedisplay will not set to true the normal plane damaged status see damaged Also see postOverlayRedisplay",
          "hierarchy": "Graphics UI GLUT Window",
          "module": "Graphics.UI.GLUT.Window",
          "name": "postRedisplay",
          "normalized": "Maybe Window-\u003eIO()",
          "package": "GLUT",
          "partial": "Redisplay",
          "signature": "Maybe Window-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Window.html#v:postRedisplay"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eChange the stacking order of the \u003cem\u003ecurrent window\u003c/em\u003e relative to its siblings\n (lowering it).\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Window",
          "name": "pushWindow",
          "package": "GLUT",
          "signature": "IO ()",
          "source": "src/Graphics-UI-GLUT-Window.html#pushWindow",
          "type": "function"
        },
        "index": {
          "description": "Change the stacking order of the current window relative to its siblings lowering it",
          "hierarchy": "Graphics UI GLUT Window",
          "module": "Graphics.UI.GLUT.Window",
          "name": "pushWindow",
          "normalized": "IO()",
          "package": "GLUT",
          "partial": "Window",
          "signature": "IO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Window.html#v:pushWindow"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMark the normal plane of the given window as needing to be redisplayed,\n otherwise the same as \u003ccode\u003e\u003ca\u003epostRedisplay\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eThe advantage of this routine is that it saves the cost of using\n \u003ccode\u003e\u003ca\u003ecurrentWindow\u003c/a\u003e\u003c/code\u003e (entailing an expensive OpenGL context switch), which is\n particularly useful when multiple windows need redisplays posted at the same\n time.\n\u003c/p\u003e\u003cp\u003ePerform a buffer swap on the \u003cem\u003elayer in use\u003c/em\u003e for the \u003cem\u003ecurrent window\u003c/em\u003e.\n Specifically, \u003ccode\u003e\u003ca\u003eswapBuffers\u003c/a\u003e\u003c/code\u003e promotes the contents of the back buffer of the\n \u003cem\u003elayer in use\u003c/em\u003e of the \u003cem\u003ecurrent window\u003c/em\u003e to become the contents of the front\n buffer. The contents of the back buffer then become undefined. The update\n typically takes place during the vertical retrace of the monitor, rather than\n immediately after \u003ccode\u003e\u003ca\u003eswapBuffers\u003c/a\u003e\u003c/code\u003e is called.\n\u003c/p\u003e\u003cp\u003eAn implicit \u003ccode\u003e\u003ca\u003eflush\u003c/a\u003e\u003c/code\u003e is done by\n \u003ccode\u003e\u003ca\u003eswapBuffers\u003c/a\u003e\u003c/code\u003e before it returns. Subsequent OpenGL commands can be issued\n immediately after calling \u003ccode\u003e\u003ca\u003eswapBuffers\u003c/a\u003e\u003c/code\u003e, but are not executed until the\n buffer exchange is completed.\n\u003c/p\u003e\u003cp\u003eIf the \u003cem\u003elayer in use\u003c/em\u003e is not double buffered, \u003ccode\u003e\u003ca\u003eswapBuffers\u003c/a\u003e\u003c/code\u003e has no effect.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Window",
          "name": "swapBuffers",
          "package": "GLUT",
          "signature": "IO ()",
          "source": "src/Graphics-UI-GLUT-Window.html#swapBuffers",
          "type": "function"
        },
        "index": {
          "description": "Mark the normal plane of the given window as needing to be redisplayed otherwise the same as postRedisplay The advantage of this routine is that it saves the cost of using currentWindow entailing an expensive OpenGL context switch which is particularly useful when multiple windows need redisplays posted at the same time Perform buffer swap on the layer in use for the current window Specifically swapBuffers promotes the contents of the back buffer of the layer in use of the current window to become the contents of the front buffer The contents of the back buffer then become undefined The update typically takes place during the vertical retrace of the monitor rather than immediately after swapBuffers is called An implicit flush is done by swapBuffers before it returns Subsequent OpenGL commands can be issued immediately after calling swapBuffers but are not executed until the buffer exchange is completed If the layer in use is not double buffered swapBuffers has no effect",
          "hierarchy": "Graphics UI GLUT Window",
          "module": "Graphics.UI.GLUT.Window",
          "name": "swapBuffers",
          "normalized": "IO()",
          "package": "GLUT",
          "partial": "Buffers",
          "signature": "IO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Window.html#v:swapBuffers"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eControls the position of the \u003cem\u003ecurrent window\u003c/em\u003e. For top-level windows,\n parameters of \u003ccode\u003e\u003ca\u003ePosition\u003c/a\u003e\u003c/code\u003e are pixel offsets from the screen origin. For\n subwindows, the parameters are pixel offsets from the window's parent window\n origin.\n\u003c/p\u003e\u003cp\u003eIn the case of top-level windows, setting \u003ccode\u003e\u003ca\u003ewindowPosition\u003c/a\u003e\u003c/code\u003e is considered only\n a request for positioning the window. The window system is free to apply its\n own policies to top-level window placement. The intent is that top-level\n windows should be repositioned according to the value of \u003ccode\u003e\u003ca\u003ewindowPosition\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Window",
          "name": "windowPosition",
          "package": "GLUT",
          "signature": "StateVar Position",
          "source": "src/Graphics-UI-GLUT-Window.html#windowPosition",
          "type": "function"
        },
        "index": {
          "description": "Controls the position of the current window For top-level windows parameters of Position are pixel offsets from the screen origin For subwindows the parameters are pixel offsets from the window parent window origin In the case of top-level windows setting windowPosition is considered only request for positioning the window The window system is free to apply its own policies to top-level window placement The intent is that top-level windows should be repositioned according to the value of windowPosition",
          "hierarchy": "Graphics UI GLUT Window",
          "module": "Graphics.UI.GLUT.Window",
          "name": "windowPosition",
          "package": "GLUT",
          "partial": "Position",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Window.html#v:windowPosition"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eControls the size of the \u003cem\u003ecurrent window\u003c/em\u003e. The parameters of \u003ccode\u003e\u003ca\u003eSize\u003c/a\u003e\u003c/code\u003e are\n size extents in pixels. The width and height must be positive values.\n\u003c/p\u003e\u003cp\u003eIn the case of top-level windows, setting \u003ccode\u003e\u003ca\u003ewindowSize\u003c/a\u003e\u003c/code\u003e is considered only a\n request for sizing the window. The window system is free to apply its own\n policies to top-level window sizing. The intent is that top-level windows\n should be reshaped according to the value of \u003ccode\u003e\u003ca\u003ewindowSize\u003c/a\u003e\u003c/code\u003e. Whether a reshape\n actually takes effect and, if so, the reshaped dimensions are reported to the\n program by a reshape callback.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Window",
          "name": "windowSize",
          "package": "GLUT",
          "signature": "StateVar Size",
          "source": "src/Graphics-UI-GLUT-Window.html#windowSize",
          "type": "function"
        },
        "index": {
          "description": "Controls the size of the current window The parameters of Size are size extents in pixels The width and height must be positive values In the case of top-level windows setting windowSize is considered only request for sizing the window The window system is free to apply its own policies to top-level window sizing The intent is that top-level windows should be reshaped according to the value of windowSize Whether reshape actually takes effect and if so the reshaped dimensions are reported to the program by reshape callback",
          "hierarchy": "Graphics UI GLUT Window",
          "module": "Graphics.UI.GLUT.Window",
          "name": "windowSize",
          "package": "GLUT",
          "partial": "Size",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Window.html#v:windowSize"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eControls the display status of the \u003cem\u003ecurrent window\u003c/em\u003e.\n\u003c/p\u003e\u003cp\u003eNote that the effect of showing, hiding, and iconifying windows does not take\n place immediately. Instead the requests are saved for execution upon return\n to the GLUT event loop. Subsequent show, hide, or iconification requests on a\n window replace the previously saved request for that window. The effect of\n hiding, showing, or iconifying top-level windows is subject to the window\n system's policy for displaying windows. Subwindows can't be iconified.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Window",
          "name": "windowStatus",
          "package": "GLUT",
          "signature": "SettableStateVar WindowStatus",
          "source": "src/Graphics-UI-GLUT-Window.html#windowStatus",
          "type": "function"
        },
        "index": {
          "description": "Controls the display status of the current window Note that the effect of showing hiding and iconifying windows does not take place immediately Instead the requests are saved for execution upon return to the GLUT event loop Subsequent show hide or iconification requests on window replace the previously saved request for that window The effect of hiding showing or iconifying top-level windows is subject to the window system policy for displaying windows Subwindows can be iconified",
          "hierarchy": "Graphics UI GLUT Window",
          "module": "Graphics.UI.GLUT.Window",
          "name": "windowStatus",
          "package": "GLUT",
          "partial": "Status",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Window.html#v:windowStatus"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eControls the window title of the \u003cem\u003ecurrent top-level window\u003c/em\u003e.\n\u003c/p\u003e",
          "module": "Graphics.UI.GLUT.Window",
          "name": "windowTitle",
          "package": "GLUT",
          "signature": "SettableStateVar String",
          "source": "src/Graphics-UI-GLUT-Window.html#windowTitle",
          "type": "function"
        },
        "index": {
          "description": "Controls the window title of the current top-level window",
          "hierarchy": "Graphics UI GLUT Window",
          "module": "Graphics.UI.GLUT.Window",
          "name": "windowTitle",
          "package": "GLUT",
          "partial": "Title",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT-Window.html#v:windowTitle"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eA Haskell binding for GLUT, the OpenGL Utility Toolkit, a window system\n independent toolkit for writing OpenGL programs. It includes support for\n the extended functionality available in freeglut (see\n \u003ca\u003ehttp://freeglut.sourceforge.net/\u003c/a\u003e) and OpenGLUT (see\n \u003ca\u003ehttp://openglut.sourceforge.net/\u003c/a\u003e), too.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Graphics.UI.GLUT",
          "name": "GLUT",
          "package": "GLUT",
          "source": "src/Graphics-UI-GLUT.html",
          "type": "module"
        },
        "index": {
          "description": "Haskell binding for GLUT the OpenGL Utility Toolkit window system independent toolkit for writing OpenGL programs It includes support for the extended functionality available in freeglut see http freeglut.sourceforge.net and OpenGLUT see http openglut.sourceforge.net too",
          "hierarchy": "Graphics UI GLUT",
          "module": "Graphics.UI.GLUT",
          "name": "GLUT",
          "package": "GLUT",
          "partial": "GLUT",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/GLUT/docs/Graphics-UI-GLUT.html#"
      }
    }
  ]
]