[
  {
    "cmd": "delete-by-query",
    "query": {
      "contexts": [
        "package"
      ],
      "query": {
        "op": "case",
        "type": "word",
        "word": "liboleg"
      },
      "type": "context"
    }
  },
  [
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eA general-purpose TIFF library\n\u003c/p\u003e\u003cp\u003e\u003ca\u003ehttp://okmij.org/ftp/Streams.html#random-bin-IO\u003c/a\u003e\n\u003c/p\u003e\u003cp\u003eThe library gives the user the TIFF dictionary, which the user\n can search for specific tags and obtain the values associated with \n the tags, including the pixel matrix.\n\u003c/p\u003e\u003cp\u003eThe overarching theme is incremental processing: initially,\n only the TIFF dictionary is read. The value associated with a tag\n is read only when that tag is looked up (unless the value was short\n and was packed in the TIFF dictionary entry). The pixel matrix\n (let alone the whole TIFF file) is not loaded in memory -- \n the pixel matrix is not even located before it is needed.\n The matrix is processed incrementally, by a user-supplied \n iteratee.\n\u003c/p\u003e\u003cp\u003eThe incremental processing is accomplished by iteratees and enumerators.\n The enumerators are indeed first-class, they are stored\n in the interned TIFF dictionary data structure. These enumerators\n represent the values associated with tags; the values will be read\n on demand, when the enumerator is applied to a user-given iteratee.\n\u003c/p\u003e\u003cp\u003eThe library extensively uses nested streams, tacitly converting the \n stream of raw bytes from the file into streams of integers, \n rationals and other user-friendly items. The pixel matrix is\n presented as a contiguous stream, regardless of its segmentation\n into strips and physical arrangement.\n The library exhibits random IO and binary parsing, reading\n of multi-byte numeric data in big- or little-endian formats.\n The library can be easily adopted for AIFF, RIFF and other\n IFF formats.\n\u003c/p\u003e\u003cp\u003eWe show a representative application of the library: reading a sample\n TIFF file, printing selected values from the TIFF dictionary,\n verifying the values of selected pixels and computing the histogram\n of pixel values. The pixel verification procedure stops reading the\n pixel matrix as soon as all specified pixel values are verified.\n The histogram accumulation does read the entire matrix, but\n incrementally. Neither pixel matrix processing procedure loads\n the whole matrix in memory. In fact, we never read and retain\n more than the IO-buffer-full of raw data.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Codec.Image.Tiff",
          "name": "Tiff",
          "package": "liboleg",
          "source": "src/Codec-Image-Tiff.html",
          "type": "module"
        },
        "index": {
          "description": "general-purpose TIFF library http okmij.org ftp Streams.html random-bin-IO The library gives the user the TIFF dictionary which the user can search for specific tags and obtain the values associated with the tags including the pixel matrix The overarching theme is incremental processing initially only the TIFF dictionary is read The value associated with tag is read only when that tag is looked up unless the value was short and was packed in the TIFF dictionary entry The pixel matrix let alone the whole TIFF file is not loaded in memory the pixel matrix is not even located before it is needed The matrix is processed incrementally by user-supplied iteratee The incremental processing is accomplished by iteratees and enumerators The enumerators are indeed first-class they are stored in the interned TIFF dictionary data structure These enumerators represent the values associated with tags the values will be read on demand when the enumerator is applied to user-given iteratee The library extensively uses nested streams tacitly converting the stream of raw bytes from the file into streams of integers rationals and other user-friendly items The pixel matrix is presented as contiguous stream regardless of its segmentation into strips and physical arrangement The library exhibits random IO and binary parsing reading of multi-byte numeric data in big or little-endian formats The library can be easily adopted for AIFF RIFF and other IFF formats We show representative application of the library reading sample TIFF file printing selected values from the TIFF dictionary verifying the values of selected pixels and computing the histogram of pixel values The pixel verification procedure stops reading the pixel matrix as soon as all specified pixel values are verified The histogram accumulation does read the entire matrix but incrementally Neither pixel matrix processing procedure loads the whole matrix in memory In fact we never read and retain more than the IO-buffer-full of raw data",
          "hierarchy": "Codec Image Tiff",
          "module": "Codec.Image.Tiff",
          "name": "Tiff",
          "package": "liboleg",
          "partial": "Tiff",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Codec-Image-Tiff.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAnother sample processor of the pixel matrix: verifying values of\n some pixels\n This processor does not read the whole matrix; it stops as soon\n as everything is verified or the error is detected\n\u003c/p\u003e\u003cp\u003eTIFF library code\n\u003c/p\u003e\u003cp\u003eWe need a more general enumerator type: enumerator that maps\n streams (not necessarily in lock-step). This is\n a flattened (`joinI-ed') EnumeratorN elfrom elto m a\n\u003c/p\u003e",
          "module": "Codec.Image.Tiff",
          "name": "EnumeratorGMM",
          "package": "liboleg",
          "source": "src/Codec-Image-Tiff.html#EnumeratorGMM",
          "type": "type"
        },
        "index": {
          "description": "Another sample processor of the pixel matrix verifying values of some pixels This processor does not read the whole matrix it stops as soon as everything is verified or the error is detected TIFF library code We need more general enumerator type enumerator that maps streams not necessarily in lock-step This is flattened joinI-ed EnumeratorN elfrom elto",
          "hierarchy": "Codec Image Tiff",
          "module": "Codec.Image.Tiff",
          "name": "EnumeratorGMM",
          "package": "liboleg",
          "partial": "Enumerator GMM",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Codec-Image-Tiff.html#t:EnumeratorGMM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Codec.Image.Tiff",
          "name": "TIFFDE",
          "package": "liboleg",
          "source": "src/Codec-Image-Tiff.html#TIFFDE",
          "type": "data"
        },
        "index": {
          "hierarchy": "Codec Image Tiff",
          "module": "Codec.Image.Tiff",
          "name": "TIFFDE",
          "package": "liboleg",
          "partial": "TIFFDE",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Codec-Image-Tiff.html#t:TIFFDE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Codec.Image.Tiff",
          "name": "TIFFDE_ENUM",
          "package": "liboleg",
          "source": "src/Codec-Image-Tiff.html#TIFFDE_ENUM",
          "type": "data"
        },
        "index": {
          "hierarchy": "Codec Image Tiff",
          "module": "Codec.Image.Tiff",
          "name": "TIFFDE_ENUM",
          "package": "liboleg",
          "partial": "TIFFDE ENUM",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Codec-Image-Tiff.html#t:TIFFDE_ENUM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA TIFF directory is a finite map associating a TIFF tag with\n a record TIFFDE\n\u003c/p\u003e",
          "module": "Codec.Image.Tiff",
          "name": "TIFFDict",
          "package": "liboleg",
          "source": "src/Codec-Image-Tiff.html#TIFFDict",
          "type": "type"
        },
        "index": {
          "description": "TIFF directory is finite map associating TIFF tag with record TIFFDE",
          "hierarchy": "Codec Image Tiff",
          "module": "Codec.Image.Tiff",
          "name": "TIFFDict",
          "package": "liboleg",
          "partial": "TIFFDict",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Codec-Image-Tiff.html#t:TIFFDict"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eStandard TIFF tags\n\u003c/p\u003e",
          "module": "Codec.Image.Tiff",
          "name": "TIFF_TAG",
          "package": "liboleg",
          "source": "src/Codec-Image-Tiff.html#TIFF_TAG",
          "type": "data"
        },
        "index": {
          "description": "Standard TIFF tags",
          "hierarchy": "Codec Image Tiff",
          "module": "Codec.Image.Tiff",
          "name": "TIFF_TAG",
          "package": "liboleg",
          "partial": "TIFF TAG",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Codec-Image-Tiff.html#t:TIFF_TAG"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eStandard TIFF data types\n\u003c/p\u003e",
          "module": "Codec.Image.Tiff",
          "name": "TIFF_TYPE",
          "package": "liboleg",
          "source": "src/Codec-Image-Tiff.html#TIFF_TYPE",
          "type": "data"
        },
        "index": {
          "description": "Standard TIFF data types",
          "hierarchy": "Codec Image Tiff",
          "module": "Codec.Image.Tiff",
          "name": "TIFF_TYPE",
          "package": "liboleg",
          "partial": "TIFF TYPE",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Codec-Image-Tiff.html#t:TIFF_TYPE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Codec.Image.Tiff",
          "name": "TEN_BYTE",
          "package": "liboleg",
          "signature": "TEN_BYTE (forall a.  EnumeratorGMM Word8 Word8 RBIO a)",
          "source": "src/Codec-Image-Tiff.html#TIFFDE_ENUM",
          "type": "function"
        },
        "index": {
          "hierarchy": "Codec Image Tiff",
          "module": "Codec.Image.Tiff",
          "name": "TEN_BYTE",
          "package": "liboleg",
          "partial": "TEN BYTE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Codec-Image-Tiff.html#v:TEN_BYTE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Codec.Image.Tiff",
          "name": "TEN_CHAR",
          "package": "liboleg",
          "signature": "TEN_CHAR (forall a.  EnumeratorGMM Word8 Char RBIO a)",
          "source": "src/Codec-Image-Tiff.html#TIFFDE_ENUM",
          "type": "function"
        },
        "index": {
          "hierarchy": "Codec Image Tiff",
          "module": "Codec.Image.Tiff",
          "name": "TEN_CHAR",
          "package": "liboleg",
          "partial": "TEN CHAR",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Codec-Image-Tiff.html#v:TEN_CHAR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Codec.Image.Tiff",
          "name": "TEN_INT",
          "package": "liboleg",
          "signature": "TEN_INT (forall a.  EnumeratorGMM Word8 Integer RBIO a)",
          "source": "src/Codec-Image-Tiff.html#TIFFDE_ENUM",
          "type": "function"
        },
        "index": {
          "hierarchy": "Codec Image Tiff",
          "module": "Codec.Image.Tiff",
          "name": "TEN_INT",
          "package": "liboleg",
          "partial": "TEN INT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Codec-Image-Tiff.html#v:TEN_INT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Codec.Image.Tiff",
          "name": "TEN_RAT",
          "package": "liboleg",
          "signature": "TEN_RAT (forall a.  EnumeratorGMM Word8 Rational RBIO a)",
          "source": "src/Codec-Image-Tiff.html#TIFFDE_ENUM",
          "type": "function"
        },
        "index": {
          "hierarchy": "Codec Image Tiff",
          "module": "Codec.Image.Tiff",
          "name": "TEN_RAT",
          "package": "liboleg",
          "partial": "TEN RAT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Codec-Image-Tiff.html#v:TEN_RAT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Codec.Image.Tiff",
          "name": "TG_ARTIST",
          "package": "liboleg",
          "signature": "TG_ARTIST",
          "source": "src/Codec-Image-Tiff.html#TIFF_TAG",
          "type": "function"
        },
        "index": {
          "hierarchy": "Codec Image Tiff",
          "module": "Codec.Image.Tiff",
          "name": "TG_ARTIST",
          "package": "liboleg",
          "partial": "TG ARTIST",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Codec-Image-Tiff.html#v:TG_ARTIST"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Codec.Image.Tiff",
          "name": "TG_BADFAXLINES",
          "package": "liboleg",
          "signature": "TG_BADFAXLINES",
          "source": "src/Codec-Image-Tiff.html#TIFF_TAG",
          "type": "function"
        },
        "index": {
          "hierarchy": "Codec Image Tiff",
          "module": "Codec.Image.Tiff",
          "name": "TG_BADFAXLINES",
          "package": "liboleg",
          "partial": "TG BADFAXLINES",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Codec-Image-Tiff.html#v:TG_BADFAXLINES"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Codec.Image.Tiff",
          "name": "TG_BITSPERSAMPLE",
          "package": "liboleg",
          "signature": "TG_BITSPERSAMPLE",
          "source": "src/Codec-Image-Tiff.html#TIFF_TAG",
          "type": "function"
        },
        "index": {
          "hierarchy": "Codec Image Tiff",
          "module": "Codec.Image.Tiff",
          "name": "TG_BITSPERSAMPLE",
          "package": "liboleg",
          "partial": "TG BITSPERSAMPLE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Codec-Image-Tiff.html#v:TG_BITSPERSAMPLE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Codec.Image.Tiff",
          "name": "TG_CELLLENGTH",
          "package": "liboleg",
          "signature": "TG_CELLLENGTH",
          "source": "src/Codec-Image-Tiff.html#TIFF_TAG",
          "type": "function"
        },
        "index": {
          "hierarchy": "Codec Image Tiff",
          "module": "Codec.Image.Tiff",
          "name": "TG_CELLLENGTH",
          "package": "liboleg",
          "partial": "TG CELLLENGTH",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Codec-Image-Tiff.html#v:TG_CELLLENGTH"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Codec.Image.Tiff",
          "name": "TG_CELLWIDTH",
          "package": "liboleg",
          "signature": "TG_CELLWIDTH",
          "source": "src/Codec-Image-Tiff.html#TIFF_TAG",
          "type": "function"
        },
        "index": {
          "hierarchy": "Codec Image Tiff",
          "module": "Codec.Image.Tiff",
          "name": "TG_CELLWIDTH",
          "package": "liboleg",
          "partial": "TG CELLWIDTH",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Codec-Image-Tiff.html#v:TG_CELLWIDTH"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Codec.Image.Tiff",
          "name": "TG_CLEANFAXDATA",
          "package": "liboleg",
          "signature": "TG_CLEANFAXDATA",
          "source": "src/Codec-Image-Tiff.html#TIFF_TAG",
          "type": "function"
        },
        "index": {
          "hierarchy": "Codec Image Tiff",
          "module": "Codec.Image.Tiff",
          "name": "TG_CLEANFAXDATA",
          "package": "liboleg",
          "partial": "TG CLEANFAXDATA",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Codec-Image-Tiff.html#v:TG_CLEANFAXDATA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Codec.Image.Tiff",
          "name": "TG_COLORMAP",
          "package": "liboleg",
          "signature": "TG_COLORMAP",
          "source": "src/Codec-Image-Tiff.html#TIFF_TAG",
          "type": "function"
        },
        "index": {
          "hierarchy": "Codec Image Tiff",
          "module": "Codec.Image.Tiff",
          "name": "TG_COLORMAP",
          "package": "liboleg",
          "partial": "TG COLORMAP",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Codec-Image-Tiff.html#v:TG_COLORMAP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Codec.Image.Tiff",
          "name": "TG_COLORRESPONSECURVE",
          "package": "liboleg",
          "signature": "TG_COLORRESPONSECURVE",
          "source": "src/Codec-Image-Tiff.html#TIFF_TAG",
          "type": "function"
        },
        "index": {
          "hierarchy": "Codec Image Tiff",
          "module": "Codec.Image.Tiff",
          "name": "TG_COLORRESPONSECURVE",
          "package": "liboleg",
          "partial": "TG COLORRESPONSECURVE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Codec-Image-Tiff.html#v:TG_COLORRESPONSECURVE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Codec.Image.Tiff",
          "name": "TG_COLORRESPONSEUNIT",
          "package": "liboleg",
          "signature": "TG_COLORRESPONSEUNIT",
          "source": "src/Codec-Image-Tiff.html#TIFF_TAG",
          "type": "function"
        },
        "index": {
          "hierarchy": "Codec Image Tiff",
          "module": "Codec.Image.Tiff",
          "name": "TG_COLORRESPONSEUNIT",
          "package": "liboleg",
          "partial": "TG COLORRESPONSEUNIT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Codec-Image-Tiff.html#v:TG_COLORRESPONSEUNIT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Codec.Image.Tiff",
          "name": "TG_COMPRESSION",
          "package": "liboleg",
          "signature": "TG_COMPRESSION",
          "source": "src/Codec-Image-Tiff.html#TIFF_TAG",
          "type": "function"
        },
        "index": {
          "hierarchy": "Codec Image Tiff",
          "module": "Codec.Image.Tiff",
          "name": "TG_COMPRESSION",
          "package": "liboleg",
          "partial": "TG COMPRESSION",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Codec-Image-Tiff.html#v:TG_COMPRESSION"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Codec.Image.Tiff",
          "name": "TG_CONSECUTIVEBADFAXLINES",
          "package": "liboleg",
          "signature": "TG_CONSECUTIVEBADFAXLINES",
          "source": "src/Codec-Image-Tiff.html#TIFF_TAG",
          "type": "function"
        },
        "index": {
          "hierarchy": "Codec Image Tiff",
          "module": "Codec.Image.Tiff",
          "name": "TG_CONSECUTIVEBADFAXLINES",
          "package": "liboleg",
          "partial": "TG CONSECUTIVEBADFAXLINES",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Codec-Image-Tiff.html#v:TG_CONSECUTIVEBADFAXLINES"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Codec.Image.Tiff",
          "name": "TG_DATETIME",
          "package": "liboleg",
          "signature": "TG_DATETIME",
          "source": "src/Codec-Image-Tiff.html#TIFF_TAG",
          "type": "function"
        },
        "index": {
          "hierarchy": "Codec Image Tiff",
          "module": "Codec.Image.Tiff",
          "name": "TG_DATETIME",
          "package": "liboleg",
          "partial": "TG DATETIME",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Codec-Image-Tiff.html#v:TG_DATETIME"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Codec.Image.Tiff",
          "name": "TG_DOCUMENTNAME",
          "package": "liboleg",
          "signature": "TG_DOCUMENTNAME",
          "source": "src/Codec-Image-Tiff.html#TIFF_TAG",
          "type": "function"
        },
        "index": {
          "hierarchy": "Codec Image Tiff",
          "module": "Codec.Image.Tiff",
          "name": "TG_DOCUMENTNAME",
          "package": "liboleg",
          "partial": "TG DOCUMENTNAME",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Codec-Image-Tiff.html#v:TG_DOCUMENTNAME"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Codec.Image.Tiff",
          "name": "TG_FILLORDER",
          "package": "liboleg",
          "signature": "TG_FILLORDER",
          "source": "src/Codec-Image-Tiff.html#TIFF_TAG",
          "type": "function"
        },
        "index": {
          "hierarchy": "Codec Image Tiff",
          "module": "Codec.Image.Tiff",
          "name": "TG_FILLORDER",
          "package": "liboleg",
          "partial": "TG FILLORDER",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Codec-Image-Tiff.html#v:TG_FILLORDER"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Codec.Image.Tiff",
          "name": "TG_FREEBYTECOUNTS",
          "package": "liboleg",
          "signature": "TG_FREEBYTECOUNTS",
          "source": "src/Codec-Image-Tiff.html#TIFF_TAG",
          "type": "function"
        },
        "index": {
          "hierarchy": "Codec Image Tiff",
          "module": "Codec.Image.Tiff",
          "name": "TG_FREEBYTECOUNTS",
          "package": "liboleg",
          "partial": "TG FREEBYTECOUNTS",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Codec-Image-Tiff.html#v:TG_FREEBYTECOUNTS"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Codec.Image.Tiff",
          "name": "TG_FREEOFFSETS",
          "package": "liboleg",
          "signature": "TG_FREEOFFSETS",
          "source": "src/Codec-Image-Tiff.html#TIFF_TAG",
          "type": "function"
        },
        "index": {
          "hierarchy": "Codec Image Tiff",
          "module": "Codec.Image.Tiff",
          "name": "TG_FREEOFFSETS",
          "package": "liboleg",
          "partial": "TG FREEOFFSETS",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Codec-Image-Tiff.html#v:TG_FREEOFFSETS"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Codec.Image.Tiff",
          "name": "TG_GRAYRESPONSECURVE",
          "package": "liboleg",
          "signature": "TG_GRAYRESPONSECURVE",
          "source": "src/Codec-Image-Tiff.html#TIFF_TAG",
          "type": "function"
        },
        "index": {
          "hierarchy": "Codec Image Tiff",
          "module": "Codec.Image.Tiff",
          "name": "TG_GRAYRESPONSECURVE",
          "package": "liboleg",
          "partial": "TG GRAYRESPONSECURVE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Codec-Image-Tiff.html#v:TG_GRAYRESPONSECURVE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Codec.Image.Tiff",
          "name": "TG_GRAYRESPONSEUNIT",
          "package": "liboleg",
          "signature": "TG_GRAYRESPONSEUNIT",
          "source": "src/Codec-Image-Tiff.html#TIFF_TAG",
          "type": "function"
        },
        "index": {
          "hierarchy": "Codec Image Tiff",
          "module": "Codec.Image.Tiff",
          "name": "TG_GRAYRESPONSEUNIT",
          "package": "liboleg",
          "partial": "TG GRAYRESPONSEUNIT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Codec-Image-Tiff.html#v:TG_GRAYRESPONSEUNIT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Codec.Image.Tiff",
          "name": "TG_GROUP3OPTIONS",
          "package": "liboleg",
          "signature": "TG_GROUP3OPTIONS",
          "source": "src/Codec-Image-Tiff.html#TIFF_TAG",
          "type": "function"
        },
        "index": {
          "hierarchy": "Codec Image Tiff",
          "module": "Codec.Image.Tiff",
          "name": "TG_GROUP3OPTIONS",
          "package": "liboleg",
          "partial": "TG GROUP OPTIONS",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Codec-Image-Tiff.html#v:TG_GROUP3OPTIONS"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Codec.Image.Tiff",
          "name": "TG_GROUP4OPTIONS",
          "package": "liboleg",
          "signature": "TG_GROUP4OPTIONS",
          "source": "src/Codec-Image-Tiff.html#TIFF_TAG",
          "type": "function"
        },
        "index": {
          "hierarchy": "Codec Image Tiff",
          "module": "Codec.Image.Tiff",
          "name": "TG_GROUP4OPTIONS",
          "package": "liboleg",
          "partial": "TG GROUP OPTIONS",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Codec-Image-Tiff.html#v:TG_GROUP4OPTIONS"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Codec.Image.Tiff",
          "name": "TG_HOSTCOMPUTER",
          "package": "liboleg",
          "signature": "TG_HOSTCOMPUTER",
          "source": "src/Codec-Image-Tiff.html#TIFF_TAG",
          "type": "function"
        },
        "index": {
          "hierarchy": "Codec Image Tiff",
          "module": "Codec.Image.Tiff",
          "name": "TG_HOSTCOMPUTER",
          "package": "liboleg",
          "partial": "TG HOSTCOMPUTER",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Codec-Image-Tiff.html#v:TG_HOSTCOMPUTER"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Codec.Image.Tiff",
          "name": "TG_IMAGEDESCRIPTION",
          "package": "liboleg",
          "signature": "TG_IMAGEDESCRIPTION",
          "source": "src/Codec-Image-Tiff.html#TIFF_TAG",
          "type": "function"
        },
        "index": {
          "hierarchy": "Codec Image Tiff",
          "module": "Codec.Image.Tiff",
          "name": "TG_IMAGEDESCRIPTION",
          "package": "liboleg",
          "partial": "TG IMAGEDESCRIPTION",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Codec-Image-Tiff.html#v:TG_IMAGEDESCRIPTION"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Codec.Image.Tiff",
          "name": "TG_IMAGELENGTH",
          "package": "liboleg",
          "signature": "TG_IMAGELENGTH",
          "source": "src/Codec-Image-Tiff.html#TIFF_TAG",
          "type": "function"
        },
        "index": {
          "hierarchy": "Codec Image Tiff",
          "module": "Codec.Image.Tiff",
          "name": "TG_IMAGELENGTH",
          "package": "liboleg",
          "partial": "TG IMAGELENGTH",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Codec-Image-Tiff.html#v:TG_IMAGELENGTH"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Codec.Image.Tiff",
          "name": "TG_IMAGEWIDTH",
          "package": "liboleg",
          "signature": "TG_IMAGEWIDTH",
          "source": "src/Codec-Image-Tiff.html#TIFF_TAG",
          "type": "function"
        },
        "index": {
          "hierarchy": "Codec Image Tiff",
          "module": "Codec.Image.Tiff",
          "name": "TG_IMAGEWIDTH",
          "package": "liboleg",
          "partial": "TG IMAGEWIDTH",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Codec-Image-Tiff.html#v:TG_IMAGEWIDTH"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Codec.Image.Tiff",
          "name": "TG_MAKE",
          "package": "liboleg",
          "signature": "TG_MAKE",
          "source": "src/Codec-Image-Tiff.html#TIFF_TAG",
          "type": "function"
        },
        "index": {
          "hierarchy": "Codec Image Tiff",
          "module": "Codec.Image.Tiff",
          "name": "TG_MAKE",
          "package": "liboleg",
          "partial": "TG MAKE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Codec-Image-Tiff.html#v:TG_MAKE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Codec.Image.Tiff",
          "name": "TG_MATTEING",
          "package": "liboleg",
          "signature": "TG_MATTEING",
          "source": "src/Codec-Image-Tiff.html#TIFF_TAG",
          "type": "function"
        },
        "index": {
          "hierarchy": "Codec Image Tiff",
          "module": "Codec.Image.Tiff",
          "name": "TG_MATTEING",
          "package": "liboleg",
          "partial": "TG MATTEING",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Codec-Image-Tiff.html#v:TG_MATTEING"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Codec.Image.Tiff",
          "name": "TG_MAXSAMPLEVALUE",
          "package": "liboleg",
          "signature": "TG_MAXSAMPLEVALUE",
          "source": "src/Codec-Image-Tiff.html#TIFF_TAG",
          "type": "function"
        },
        "index": {
          "hierarchy": "Codec Image Tiff",
          "module": "Codec.Image.Tiff",
          "name": "TG_MAXSAMPLEVALUE",
          "package": "liboleg",
          "partial": "TG MAXSAMPLEVALUE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Codec-Image-Tiff.html#v:TG_MAXSAMPLEVALUE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Codec.Image.Tiff",
          "name": "TG_MINSAMPLEVALUE",
          "package": "liboleg",
          "signature": "TG_MINSAMPLEVALUE",
          "source": "src/Codec-Image-Tiff.html#TIFF_TAG",
          "type": "function"
        },
        "index": {
          "hierarchy": "Codec Image Tiff",
          "module": "Codec.Image.Tiff",
          "name": "TG_MINSAMPLEVALUE",
          "package": "liboleg",
          "partial": "TG MINSAMPLEVALUE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Codec-Image-Tiff.html#v:TG_MINSAMPLEVALUE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Codec.Image.Tiff",
          "name": "TG_MODEL",
          "package": "liboleg",
          "signature": "TG_MODEL",
          "source": "src/Codec-Image-Tiff.html#TIFF_TAG",
          "type": "function"
        },
        "index": {
          "hierarchy": "Codec Image Tiff",
          "module": "Codec.Image.Tiff",
          "name": "TG_MODEL",
          "package": "liboleg",
          "partial": "TG MODEL",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Codec-Image-Tiff.html#v:TG_MODEL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Codec.Image.Tiff",
          "name": "TG_ORIENTATION",
          "package": "liboleg",
          "signature": "TG_ORIENTATION",
          "source": "src/Codec-Image-Tiff.html#TIFF_TAG",
          "type": "function"
        },
        "index": {
          "hierarchy": "Codec Image Tiff",
          "module": "Codec.Image.Tiff",
          "name": "TG_ORIENTATION",
          "package": "liboleg",
          "partial": "TG ORIENTATION",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Codec-Image-Tiff.html#v:TG_ORIENTATION"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Codec.Image.Tiff",
          "name": "TG_OSUBFILETYPE",
          "package": "liboleg",
          "signature": "TG_OSUBFILETYPE",
          "source": "src/Codec-Image-Tiff.html#TIFF_TAG",
          "type": "function"
        },
        "index": {
          "hierarchy": "Codec Image Tiff",
          "module": "Codec.Image.Tiff",
          "name": "TG_OSUBFILETYPE",
          "package": "liboleg",
          "partial": "TG OSUBFILETYPE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Codec-Image-Tiff.html#v:TG_OSUBFILETYPE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Codec.Image.Tiff",
          "name": "TG_PAGENAME",
          "package": "liboleg",
          "signature": "TG_PAGENAME",
          "source": "src/Codec-Image-Tiff.html#TIFF_TAG",
          "type": "function"
        },
        "index": {
          "hierarchy": "Codec Image Tiff",
          "module": "Codec.Image.Tiff",
          "name": "TG_PAGENAME",
          "package": "liboleg",
          "partial": "TG PAGENAME",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Codec-Image-Tiff.html#v:TG_PAGENAME"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Codec.Image.Tiff",
          "name": "TG_PAGENUMBER",
          "package": "liboleg",
          "signature": "TG_PAGENUMBER",
          "source": "src/Codec-Image-Tiff.html#TIFF_TAG",
          "type": "function"
        },
        "index": {
          "hierarchy": "Codec Image Tiff",
          "module": "Codec.Image.Tiff",
          "name": "TG_PAGENUMBER",
          "package": "liboleg",
          "partial": "TG PAGENUMBER",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Codec-Image-Tiff.html#v:TG_PAGENUMBER"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Codec.Image.Tiff",
          "name": "TG_PHOTOMETRIC",
          "package": "liboleg",
          "signature": "TG_PHOTOMETRIC",
          "source": "src/Codec-Image-Tiff.html#TIFF_TAG",
          "type": "function"
        },
        "index": {
          "hierarchy": "Codec Image Tiff",
          "module": "Codec.Image.Tiff",
          "name": "TG_PHOTOMETRIC",
          "package": "liboleg",
          "partial": "TG PHOTOMETRIC",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Codec-Image-Tiff.html#v:TG_PHOTOMETRIC"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Codec.Image.Tiff",
          "name": "TG_PLANARCONFIG",
          "package": "liboleg",
          "signature": "TG_PLANARCONFIG",
          "source": "src/Codec-Image-Tiff.html#TIFF_TAG",
          "type": "function"
        },
        "index": {
          "hierarchy": "Codec Image Tiff",
          "module": "Codec.Image.Tiff",
          "name": "TG_PLANARCONFIG",
          "package": "liboleg",
          "partial": "TG PLANARCONFIG",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Codec-Image-Tiff.html#v:TG_PLANARCONFIG"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Codec.Image.Tiff",
          "name": "TG_PREDICTOR",
          "package": "liboleg",
          "signature": "TG_PREDICTOR",
          "source": "src/Codec-Image-Tiff.html#TIFF_TAG",
          "type": "function"
        },
        "index": {
          "hierarchy": "Codec Image Tiff",
          "module": "Codec.Image.Tiff",
          "name": "TG_PREDICTOR",
          "package": "liboleg",
          "partial": "TG PREDICTOR",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Codec-Image-Tiff.html#v:TG_PREDICTOR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Codec.Image.Tiff",
          "name": "TG_PRIMARYCHROMATICITIES",
          "package": "liboleg",
          "signature": "TG_PRIMARYCHROMATICITIES",
          "source": "src/Codec-Image-Tiff.html#TIFF_TAG",
          "type": "function"
        },
        "index": {
          "hierarchy": "Codec Image Tiff",
          "module": "Codec.Image.Tiff",
          "name": "TG_PRIMARYCHROMATICITIES",
          "package": "liboleg",
          "partial": "TG PRIMARYCHROMATICITIES",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Codec-Image-Tiff.html#v:TG_PRIMARYCHROMATICITIES"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Codec.Image.Tiff",
          "name": "TG_RESOLUTIONUNIT",
          "package": "liboleg",
          "signature": "TG_RESOLUTIONUNIT",
          "source": "src/Codec-Image-Tiff.html#TIFF_TAG",
          "type": "function"
        },
        "index": {
          "hierarchy": "Codec Image Tiff",
          "module": "Codec.Image.Tiff",
          "name": "TG_RESOLUTIONUNIT",
          "package": "liboleg",
          "partial": "TG RESOLUTIONUNIT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Codec-Image-Tiff.html#v:TG_RESOLUTIONUNIT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Codec.Image.Tiff",
          "name": "TG_ROWSPERSTRIP",
          "package": "liboleg",
          "signature": "TG_ROWSPERSTRIP",
          "source": "src/Codec-Image-Tiff.html#TIFF_TAG",
          "type": "function"
        },
        "index": {
          "hierarchy": "Codec Image Tiff",
          "module": "Codec.Image.Tiff",
          "name": "TG_ROWSPERSTRIP",
          "package": "liboleg",
          "partial": "TG ROWSPERSTRIP",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Codec-Image-Tiff.html#v:TG_ROWSPERSTRIP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Codec.Image.Tiff",
          "name": "TG_SAMPLESPERPIXEL",
          "package": "liboleg",
          "signature": "TG_SAMPLESPERPIXEL",
          "source": "src/Codec-Image-Tiff.html#TIFF_TAG",
          "type": "function"
        },
        "index": {
          "hierarchy": "Codec Image Tiff",
          "module": "Codec.Image.Tiff",
          "name": "TG_SAMPLESPERPIXEL",
          "package": "liboleg",
          "partial": "TG SAMPLESPERPIXEL",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Codec-Image-Tiff.html#v:TG_SAMPLESPERPIXEL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Codec.Image.Tiff",
          "name": "TG_SOFTWARE",
          "package": "liboleg",
          "signature": "TG_SOFTWARE",
          "source": "src/Codec-Image-Tiff.html#TIFF_TAG",
          "type": "function"
        },
        "index": {
          "hierarchy": "Codec Image Tiff",
          "module": "Codec.Image.Tiff",
          "name": "TG_SOFTWARE",
          "package": "liboleg",
          "partial": "TG SOFTWARE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Codec-Image-Tiff.html#v:TG_SOFTWARE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Codec.Image.Tiff",
          "name": "TG_STRIPBYTECOUNTS",
          "package": "liboleg",
          "signature": "TG_STRIPBYTECOUNTS",
          "source": "src/Codec-Image-Tiff.html#TIFF_TAG",
          "type": "function"
        },
        "index": {
          "hierarchy": "Codec Image Tiff",
          "module": "Codec.Image.Tiff",
          "name": "TG_STRIPBYTECOUNTS",
          "package": "liboleg",
          "partial": "TG STRIPBYTECOUNTS",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Codec-Image-Tiff.html#v:TG_STRIPBYTECOUNTS"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Codec.Image.Tiff",
          "name": "TG_STRIPOFFSETS",
          "package": "liboleg",
          "signature": "TG_STRIPOFFSETS",
          "source": "src/Codec-Image-Tiff.html#TIFF_TAG",
          "type": "function"
        },
        "index": {
          "hierarchy": "Codec Image Tiff",
          "module": "Codec.Image.Tiff",
          "name": "TG_STRIPOFFSETS",
          "package": "liboleg",
          "partial": "TG STRIPOFFSETS",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Codec-Image-Tiff.html#v:TG_STRIPOFFSETS"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Codec.Image.Tiff",
          "name": "TG_SUBFILETYPE",
          "package": "liboleg",
          "signature": "TG_SUBFILETYPE",
          "source": "src/Codec-Image-Tiff.html#TIFF_TAG",
          "type": "function"
        },
        "index": {
          "hierarchy": "Codec Image Tiff",
          "module": "Codec.Image.Tiff",
          "name": "TG_SUBFILETYPE",
          "package": "liboleg",
          "partial": "TG SUBFILETYPE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Codec-Image-Tiff.html#v:TG_SUBFILETYPE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Codec.Image.Tiff",
          "name": "TG_THRESHOLDING",
          "package": "liboleg",
          "signature": "TG_THRESHOLDING",
          "source": "src/Codec-Image-Tiff.html#TIFF_TAG",
          "type": "function"
        },
        "index": {
          "hierarchy": "Codec Image Tiff",
          "module": "Codec.Image.Tiff",
          "name": "TG_THRESHOLDING",
          "package": "liboleg",
          "partial": "TG THRESHOLDING",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Codec-Image-Tiff.html#v:TG_THRESHOLDING"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Codec.Image.Tiff",
          "name": "TG_WHITEPOINT",
          "package": "liboleg",
          "signature": "TG_WHITEPOINT",
          "source": "src/Codec-Image-Tiff.html#TIFF_TAG",
          "type": "function"
        },
        "index": {
          "hierarchy": "Codec Image Tiff",
          "module": "Codec.Image.Tiff",
          "name": "TG_WHITEPOINT",
          "package": "liboleg",
          "partial": "TG WHITEPOINT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Codec-Image-Tiff.html#v:TG_WHITEPOINT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Codec.Image.Tiff",
          "name": "TG_XPOSITION",
          "package": "liboleg",
          "signature": "TG_XPOSITION",
          "source": "src/Codec-Image-Tiff.html#TIFF_TAG",
          "type": "function"
        },
        "index": {
          "hierarchy": "Codec Image Tiff",
          "module": "Codec.Image.Tiff",
          "name": "TG_XPOSITION",
          "package": "liboleg",
          "partial": "TG XPOSITION",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Codec-Image-Tiff.html#v:TG_XPOSITION"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Codec.Image.Tiff",
          "name": "TG_XRESOLUTION",
          "package": "liboleg",
          "signature": "TG_XRESOLUTION",
          "source": "src/Codec-Image-Tiff.html#TIFF_TAG",
          "type": "function"
        },
        "index": {
          "hierarchy": "Codec Image Tiff",
          "module": "Codec.Image.Tiff",
          "name": "TG_XRESOLUTION",
          "package": "liboleg",
          "partial": "TG XRESOLUTION",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Codec-Image-Tiff.html#v:TG_XRESOLUTION"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Codec.Image.Tiff",
          "name": "TG_YPOSITION",
          "package": "liboleg",
          "signature": "TG_YPOSITION",
          "source": "src/Codec-Image-Tiff.html#TIFF_TAG",
          "type": "function"
        },
        "index": {
          "hierarchy": "Codec Image Tiff",
          "module": "Codec.Image.Tiff",
          "name": "TG_YPOSITION",
          "package": "liboleg",
          "partial": "TG YPOSITION",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Codec-Image-Tiff.html#v:TG_YPOSITION"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Codec.Image.Tiff",
          "name": "TG_YRESOLUTION",
          "package": "liboleg",
          "signature": "TG_YRESOLUTION",
          "source": "src/Codec-Image-Tiff.html#TIFF_TAG",
          "type": "function"
        },
        "index": {
          "hierarchy": "Codec Image Tiff",
          "module": "Codec.Image.Tiff",
          "name": "TG_YRESOLUTION",
          "package": "liboleg",
          "partial": "TG YRESOLUTION",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Codec-Image-Tiff.html#v:TG_YRESOLUTION"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Codec.Image.Tiff",
          "name": "TG_other",
          "package": "liboleg",
          "signature": "TG_other Int",
          "source": "src/Codec-Image-Tiff.html#TIFF_TAG",
          "type": "function"
        },
        "index": {
          "hierarchy": "Codec Image Tiff",
          "module": "Codec.Image.Tiff",
          "name": "TG_other",
          "package": "liboleg",
          "partial": "TG",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Codec-Image-Tiff.html#v:TG_other"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Codec.Image.Tiff",
          "name": "TIFFDE",
          "package": "liboleg",
          "signature": "TIFFDE",
          "source": "src/Codec-Image-Tiff.html#TIFFDE",
          "type": "function"
        },
        "index": {
          "hierarchy": "Codec Image Tiff",
          "module": "Codec.Image.Tiff",
          "name": "TIFFDE",
          "package": "liboleg",
          "partial": "TIFFDE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Codec-Image-Tiff.html#v:TIFFDE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Codec.Image.Tiff",
          "name": "TT_NONE",
          "package": "liboleg",
          "signature": "TT_NONE",
          "source": "src/Codec-Image-Tiff.html#TIFF_TYPE",
          "type": "function"
        },
        "index": {
          "hierarchy": "Codec Image Tiff",
          "module": "Codec.Image.Tiff",
          "name": "TT_NONE",
          "package": "liboleg",
          "partial": "TT NONE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Codec-Image-Tiff.html#v:TT_NONE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Codec.Image.Tiff",
          "name": "TT_ascii",
          "package": "liboleg",
          "signature": "TT_ascii",
          "source": "src/Codec-Image-Tiff.html#TIFF_TYPE",
          "type": "function"
        },
        "index": {
          "hierarchy": "Codec Image Tiff",
          "module": "Codec.Image.Tiff",
          "name": "TT_ascii",
          "package": "liboleg",
          "partial": "TT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Codec-Image-Tiff.html#v:TT_ascii"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Codec.Image.Tiff",
          "name": "TT_byte",
          "package": "liboleg",
          "signature": "TT_byte",
          "source": "src/Codec-Image-Tiff.html#TIFF_TYPE",
          "type": "function"
        },
        "index": {
          "hierarchy": "Codec Image Tiff",
          "module": "Codec.Image.Tiff",
          "name": "TT_byte",
          "package": "liboleg",
          "partial": "TT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Codec-Image-Tiff.html#v:TT_byte"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Codec.Image.Tiff",
          "name": "TT_double",
          "package": "liboleg",
          "signature": "TT_double",
          "source": "src/Codec-Image-Tiff.html#TIFF_TYPE",
          "type": "function"
        },
        "index": {
          "hierarchy": "Codec Image Tiff",
          "module": "Codec.Image.Tiff",
          "name": "TT_double",
          "package": "liboleg",
          "partial": "TT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Codec-Image-Tiff.html#v:TT_double"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Codec.Image.Tiff",
          "name": "TT_float",
          "package": "liboleg",
          "signature": "TT_float",
          "source": "src/Codec-Image-Tiff.html#TIFF_TYPE",
          "type": "function"
        },
        "index": {
          "hierarchy": "Codec Image Tiff",
          "module": "Codec.Image.Tiff",
          "name": "TT_float",
          "package": "liboleg",
          "partial": "TT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Codec-Image-Tiff.html#v:TT_float"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Codec.Image.Tiff",
          "name": "TT_long",
          "package": "liboleg",
          "signature": "TT_long",
          "source": "src/Codec-Image-Tiff.html#TIFF_TYPE",
          "type": "function"
        },
        "index": {
          "hierarchy": "Codec Image Tiff",
          "module": "Codec.Image.Tiff",
          "name": "TT_long",
          "package": "liboleg",
          "partial": "TT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Codec-Image-Tiff.html#v:TT_long"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Codec.Image.Tiff",
          "name": "TT_rational",
          "package": "liboleg",
          "signature": "TT_rational",
          "source": "src/Codec-Image-Tiff.html#TIFF_TYPE",
          "type": "function"
        },
        "index": {
          "hierarchy": "Codec Image Tiff",
          "module": "Codec.Image.Tiff",
          "name": "TT_rational",
          "package": "liboleg",
          "partial": "TT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Codec-Image-Tiff.html#v:TT_rational"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Codec.Image.Tiff",
          "name": "TT_sbyte",
          "package": "liboleg",
          "signature": "TT_sbyte",
          "source": "src/Codec-Image-Tiff.html#TIFF_TYPE",
          "type": "function"
        },
        "index": {
          "hierarchy": "Codec Image Tiff",
          "module": "Codec.Image.Tiff",
          "name": "TT_sbyte",
          "package": "liboleg",
          "partial": "TT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Codec-Image-Tiff.html#v:TT_sbyte"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Codec.Image.Tiff",
          "name": "TT_short",
          "package": "liboleg",
          "signature": "TT_short",
          "source": "src/Codec-Image-Tiff.html#TIFF_TYPE",
          "type": "function"
        },
        "index": {
          "hierarchy": "Codec Image Tiff",
          "module": "Codec.Image.Tiff",
          "name": "TT_short",
          "package": "liboleg",
          "partial": "TT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Codec-Image-Tiff.html#v:TT_short"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Codec.Image.Tiff",
          "name": "TT_slong",
          "package": "liboleg",
          "signature": "TT_slong",
          "source": "src/Codec-Image-Tiff.html#TIFF_TYPE",
          "type": "function"
        },
        "index": {
          "hierarchy": "Codec Image Tiff",
          "module": "Codec.Image.Tiff",
          "name": "TT_slong",
          "package": "liboleg",
          "partial": "TT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Codec-Image-Tiff.html#v:TT_slong"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Codec.Image.Tiff",
          "name": "TT_srational",
          "package": "liboleg",
          "signature": "TT_srational",
          "source": "src/Codec-Image-Tiff.html#TIFF_TYPE",
          "type": "function"
        },
        "index": {
          "hierarchy": "Codec Image Tiff",
          "module": "Codec.Image.Tiff",
          "name": "TT_srational",
          "package": "liboleg",
          "partial": "TT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Codec-Image-Tiff.html#v:TT_srational"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Codec.Image.Tiff",
          "name": "TT_sshort",
          "package": "liboleg",
          "signature": "TT_sshort",
          "source": "src/Codec-Image-Tiff.html#TIFF_TYPE",
          "type": "function"
        },
        "index": {
          "hierarchy": "Codec Image Tiff",
          "module": "Codec.Image.Tiff",
          "name": "TT_sshort",
          "package": "liboleg",
          "partial": "TT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Codec-Image-Tiff.html#v:TT_sshort"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Codec.Image.Tiff",
          "name": "TT_undefined",
          "package": "liboleg",
          "signature": "TT_undefined",
          "source": "src/Codec-Image-Tiff.html#TIFF_TYPE",
          "type": "function"
        },
        "index": {
          "hierarchy": "Codec Image Tiff",
          "module": "Codec.Image.Tiff",
          "name": "TT_undefined",
          "package": "liboleg",
          "partial": "TT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Codec-Image-Tiff.html#v:TT_undefined"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSample TIFF user code\n The following is sample code using the TIFF library (whose implementation\n is in the second part of this file).\n Our sample code prints interesting information from the TIFF\n dictionary (such as the dimensions, the resolution and the name\n of the image)\n\u003c/p\u003e\u003cp\u003eThe sample file is a GNU logo (from http:\u003cem/\u003ewww.gnu.org)\n converted from JPG to TIFF. Copyleft by GNU.\n\u003c/p\u003e\u003cp\u003eThe main user function. tiff_reader is the library function,\n which builds the TIFF dictionary.\n process_tiff is the user function, to extract useful data\n from the dictionary\n\u003c/p\u003e\u003cp\u003eSample TIFF processing function\n\u003c/p\u003e\u003cp\u003esample processing of the pixel matrix: computing the histogram\n\u003c/p\u003e",
          "module": "Codec.Image.Tiff",
          "name": "compute_hist",
          "package": "liboleg",
          "signature": "TIFFDict -\u003e IterateeGM Word8 RBIO (Int, IntMap Int)",
          "source": "src/Codec-Image-Tiff.html#compute_hist",
          "type": "function"
        },
        "index": {
          "description": "Sample TIFF user code The following is sample code using the TIFF library whose implementation is in the second part of this file Our sample code prints interesting information from the TIFF dictionary such as the dimensions the resolution and the name of the image The sample file is GNU logo from http www.gnu.org converted from JPG to TIFF Copyleft by GNU The main user function tiff reader is the library function which builds the TIFF dictionary process tiff is the user function to extract useful data from the dictionary Sample TIFF processing function sample processing of the pixel matrix computing the histogram",
          "hierarchy": "Codec Image Tiff",
          "module": "Codec.Image.Tiff",
          "name": "compute_hist",
          "normalized": "TIFFDict-\u003eIterateeGM Word RBIO(Int,IntMap Int)",
          "package": "liboleg",
          "signature": "TIFFDict-\u003eIterateeGM Word RBIO(Int,IntMap Int)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Codec-Image-Tiff.html#v:compute_hist"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA few helpers for getting data from TIFF dictionary\n\u003c/p\u003e",
          "module": "Codec.Image.Tiff",
          "name": "dict_read_int",
          "package": "liboleg",
          "signature": "TIFF_TAG -\u003e TIFFDict -\u003e IterateeGM Word8 RBIO (Maybe Integer)",
          "source": "src/Codec-Image-Tiff.html#dict_read_int",
          "type": "function"
        },
        "index": {
          "description": "few helpers for getting data from TIFF dictionary",
          "hierarchy": "Codec Image Tiff",
          "module": "Codec.Image.Tiff",
          "name": "dict_read_int",
          "normalized": "TIFF_TAG-\u003eTIFFDict-\u003eIterateeGM Word RBIO(Maybe Integer)",
          "package": "liboleg",
          "signature": "TIFF_TAG-\u003eTIFFDict-\u003eIterateeGM Word RBIO(Maybe Integer)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Codec-Image-Tiff.html#v:dict_read_int"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Codec.Image.Tiff",
          "name": "dict_read_ints",
          "package": "liboleg",
          "signature": "TIFF_TAG -\u003e TIFFDict -\u003e IterateeGM Word8 RBIO (Maybe [Integer])",
          "source": "src/Codec-Image-Tiff.html#dict_read_ints",
          "type": "function"
        },
        "index": {
          "hierarchy": "Codec Image Tiff",
          "module": "Codec.Image.Tiff",
          "name": "dict_read_ints",
          "normalized": "TIFF_TAG-\u003eTIFFDict-\u003eIterateeGM Word RBIO(Maybe[Integer])",
          "package": "liboleg",
          "signature": "TIFF_TAG-\u003eTIFFDict-\u003eIterateeGM Word RBIO(Maybe[Integer])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Codec-Image-Tiff.html#v:dict_read_ints"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Codec.Image.Tiff",
          "name": "dict_read_rat",
          "package": "liboleg",
          "signature": "TIFF_TAG -\u003e TIFFDict -\u003e IterateeGM Word8 RBIO (Maybe Rational)",
          "source": "src/Codec-Image-Tiff.html#dict_read_rat",
          "type": "function"
        },
        "index": {
          "hierarchy": "Codec Image Tiff",
          "module": "Codec.Image.Tiff",
          "name": "dict_read_rat",
          "normalized": "TIFF_TAG-\u003eTIFFDict-\u003eIterateeGM Word RBIO(Maybe Rational)",
          "package": "liboleg",
          "signature": "TIFF_TAG-\u003eTIFFDict-\u003eIterateeGM Word RBIO(Maybe Rational)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Codec-Image-Tiff.html#v:dict_read_rat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Codec.Image.Tiff",
          "name": "dict_read_string",
          "package": "liboleg",
          "signature": "TIFF_TAG -\u003e TIFFDict -\u003e IterateeGM Word8 RBIO (Maybe String)",
          "source": "src/Codec-Image-Tiff.html#dict_read_string",
          "type": "function"
        },
        "index": {
          "hierarchy": "Codec Image Tiff",
          "module": "Codec.Image.Tiff",
          "name": "dict_read_string",
          "normalized": "TIFF_TAG-\u003eTIFFDict-\u003eIterateeGM Word RBIO(Maybe String)",
          "package": "liboleg",
          "signature": "TIFF_TAG-\u003eTIFFDict-\u003eIterateeGM Word RBIO(Maybe String)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Codec-Image-Tiff.html#v:dict_read_string"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Codec.Image.Tiff",
          "name": "int_to_tag",
          "package": "liboleg",
          "signature": "Int -\u003e TIFF_TAG",
          "source": "src/Codec-Image-Tiff.html#int_to_tag",
          "type": "function"
        },
        "index": {
          "hierarchy": "Codec Image Tiff",
          "module": "Codec.Image.Tiff",
          "name": "int_to_tag",
          "normalized": "Int-\u003eTIFF_TAG",
          "package": "liboleg",
          "signature": "Int-\u003eTIFF_TAG",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Codec-Image-Tiff.html#v:int_to_tag"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn internal function to load the dictionary. It assumes that the stream\n is positioned to read the dictionary\n\u003c/p\u003e",
          "module": "Codec.Image.Tiff",
          "name": "load_dict",
          "package": "liboleg",
          "signature": "IterateeGM Word8 RBIO (Maybe TIFFDict)",
          "source": "src/Codec-Image-Tiff.html#load_dict",
          "type": "function"
        },
        "index": {
          "description": "An internal function to load the dictionary It assumes that the stream is positioned to read the dictionary",
          "hierarchy": "Codec Image Tiff",
          "module": "Codec.Image.Tiff",
          "name": "load_dict",
          "package": "liboleg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Codec-Image-Tiff.html#v:load_dict"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Codec.Image.Tiff",
          "name": "note",
          "package": "liboleg",
          "signature": "[String] -\u003e IterateeGM el RBIO ()",
          "source": "src/Codec-Image-Tiff.html#note",
          "type": "function"
        },
        "index": {
          "hierarchy": "Codec Image Tiff",
          "module": "Codec.Image.Tiff",
          "name": "note",
          "normalized": "[String]-\u003eIterateeGM a RBIO()",
          "package": "liboleg",
          "signature": "[String]-\u003eIterateeGM el RBIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Codec-Image-Tiff.html#v:note"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReading the pixel matrix\n For simplicity, we assume no compression and 8-bit pixels\n\u003c/p\u003e",
          "module": "Codec.Image.Tiff",
          "name": "pixel_matrix_enum",
          "package": "liboleg",
          "signature": "TIFFDict -\u003e EnumeratorN Word8 Word8 RBIO a",
          "source": "src/Codec-Image-Tiff.html#pixel_matrix_enum",
          "type": "function"
        },
        "index": {
          "description": "Reading the pixel matrix For simplicity we assume no compression and bit pixels",
          "hierarchy": "Codec Image Tiff",
          "module": "Codec.Image.Tiff",
          "name": "pixel_matrix_enum",
          "normalized": "TIFFDict-\u003eEnumeratorN Word Word RBIO a",
          "package": "liboleg",
          "signature": "TIFFDict-\u003eEnumeratorN Word Word RBIO a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Codec-Image-Tiff.html#v:pixel_matrix_enum"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Codec.Image.Tiff",
          "name": "tag_to_int",
          "package": "liboleg",
          "signature": "TIFF_TAG -\u003e Int",
          "source": "src/Codec-Image-Tiff.html#tag_to_int",
          "type": "function"
        },
        "index": {
          "hierarchy": "Codec Image Tiff",
          "module": "Codec.Image.Tiff",
          "name": "tag_to_int",
          "normalized": "TIFF_TAG-\u003eInt",
          "package": "liboleg",
          "signature": "TIFF_TAG-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Codec-Image-Tiff.html#v:tag_to_int"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe library function to read the TIFF dictionary\n\u003c/p\u003e",
          "module": "Codec.Image.Tiff",
          "name": "tiff_reader",
          "package": "liboleg",
          "signature": "IterateeGM Word8 RBIO (Maybe TIFFDict)",
          "source": "src/Codec-Image-Tiff.html#tiff_reader",
          "type": "function"
        },
        "index": {
          "description": "The library function to read the TIFF dictionary",
          "hierarchy": "Codec Image Tiff",
          "module": "Codec.Image.Tiff",
          "name": "tiff_reader",
          "package": "liboleg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Codec-Image-Tiff.html#v:tiff_reader"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Codec.Image.Tiff",
          "name": "tiffde_count",
          "package": "liboleg",
          "signature": "Int",
          "source": "src/Codec-Image-Tiff.html#TIFFDE",
          "type": "function"
        },
        "index": {
          "hierarchy": "Codec Image Tiff",
          "module": "Codec.Image.Tiff",
          "name": "tiffde_count",
          "package": "liboleg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Codec-Image-Tiff.html#v:tiffde_count"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Codec.Image.Tiff",
          "name": "tiffde_enum",
          "package": "liboleg",
          "signature": "TIFFDE_ENUM",
          "source": "src/Codec-Image-Tiff.html#TIFFDE",
          "type": "function"
        },
        "index": {
          "hierarchy": "Codec Image Tiff",
          "module": "Codec.Image.Tiff",
          "name": "tiffde_enum",
          "package": "liboleg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Codec-Image-Tiff.html#v:tiffde_enum"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Codec.Image.Tiff",
          "name": "u16_to_s16",
          "package": "liboleg",
          "signature": "Word16 -\u003e Int16",
          "source": "src/Codec-Image-Tiff.html#u16_to_s16",
          "type": "function"
        },
        "index": {
          "hierarchy": "Codec Image Tiff",
          "module": "Codec.Image.Tiff",
          "name": "u16_to_s16",
          "normalized": "Word-\u003eInt",
          "package": "liboleg",
          "signature": "Word-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Codec-Image-Tiff.html#v:u16_to_s16"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA few conversion procedures\n\u003c/p\u003e",
          "module": "Codec.Image.Tiff",
          "name": "u32_to_float",
          "package": "liboleg",
          "signature": "Word32 -\u003e Double",
          "source": "src/Codec-Image-Tiff.html#u32_to_float",
          "type": "function"
        },
        "index": {
          "description": "few conversion procedures",
          "hierarchy": "Codec Image Tiff",
          "module": "Codec.Image.Tiff",
          "name": "u32_to_float",
          "normalized": "Word-\u003eDouble",
          "package": "liboleg",
          "signature": "Word-\u003eDouble",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Codec-Image-Tiff.html#v:u32_to_float"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Codec.Image.Tiff",
          "name": "u32_to_s32",
          "package": "liboleg",
          "signature": "Word32 -\u003e Int32",
          "source": "src/Codec-Image-Tiff.html#u32_to_s32",
          "type": "function"
        },
        "index": {
          "hierarchy": "Codec Image Tiff",
          "module": "Codec.Image.Tiff",
          "name": "u32_to_s32",
          "normalized": "Word-\u003eInt",
          "package": "liboleg",
          "signature": "Word-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Codec-Image-Tiff.html#v:u32_to_s32"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Codec.Image.Tiff",
          "name": "u8_to_s8",
          "package": "liboleg",
          "signature": "Word8 -\u003e Int8",
          "source": "src/Codec-Image-Tiff.html#u8_to_s8",
          "type": "function"
        },
        "index": {
          "hierarchy": "Codec Image Tiff",
          "module": "Codec.Image.Tiff",
          "name": "u8_to_s8",
          "normalized": "Word-\u003eInt",
          "package": "liboleg",
          "signature": "Word-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Codec-Image-Tiff.html#v:u8_to_s8"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.CCCxe",
          "name": "CCCxe",
          "package": "liboleg",
          "source": "src/Control-CCCxe.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Control CCCxe",
          "module": "Control.CCCxe",
          "name": "CCCxe",
          "package": "liboleg",
          "partial": "CCCxe",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-CCCxe.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDelimited-continuation monad transformer\n It is parameterized by the prompt flavor p\n The first argument is the regular (success) continuation,\n the second argument is the bubble, or a resumable exception\n\u003c/p\u003e",
          "module": "Control.CCCxe",
          "name": "CC",
          "package": "liboleg",
          "source": "src/Control-CCCxe.html#CC",
          "type": "data"
        },
        "index": {
          "description": "Delimited-continuation monad transformer It is parameterized by the prompt flavor The first argument is the regular success continuation the second argument is the bubble or resumable exception",
          "hierarchy": "Control CCCxe",
          "module": "Control.CCCxe",
          "name": "CC",
          "package": "liboleg",
          "partial": "CC",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-CCCxe.html#t:CC"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe type of control operator's body\n\u003c/p\u003e",
          "module": "Control.CCCxe",
          "name": "CCT",
          "package": "liboleg",
          "source": "src/Control-CCCxe.html#CCT",
          "type": "type"
        },
        "index": {
          "description": "The type of control operator body",
          "hierarchy": "Control CCCxe",
          "module": "Control.CCCxe",
          "name": "CCT",
          "package": "liboleg",
          "partial": "CCT",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-CCCxe.html#t:CCT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePrompts for the closed set of answer-types\n The following prompt flavor P2, for two answer-types w1 and w2,\n is given as an example. Typically, a programmer would define their\n own variant data type with variants for the answer-types that occur\n in their program.\n\u003c/p\u003e",
          "module": "Control.CCCxe",
          "name": "P2",
          "package": "liboleg",
          "source": "src/Control-CCCxe.html#P2",
          "type": "data"
        },
        "index": {
          "description": "Prompts for the closed set of answer-types The following prompt flavor P2 for two answer-types w1 and w2 is given as an example Typically programmer would define their own variant data type with variants for the answer-types that occur in their program",
          "hierarchy": "Control CCCxe",
          "module": "Control.CCCxe",
          "name": "P2",
          "package": "liboleg",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-CCCxe.html#t:P2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eOpen set of answer types, with an additional distinction (given by\n integer identifiers)\n This prompt flavor corresponds to the prompts in the Dybvig, Peyton-Jones,\n Sabry framework (modulo the Typeable constraint).\n\u003c/p\u003e",
          "module": "Control.CCCxe",
          "name": "PD",
          "package": "liboleg",
          "source": "src/Control-CCCxe.html#PD",
          "type": "data"
        },
        "index": {
          "description": "Open set of answer types with an additional distinction given by integer identifiers This prompt flavor corresponds to the prompts in the Dybvig Peyton-Jones Sabry framework modulo the Typeable constraint",
          "hierarchy": "Control CCCxe",
          "module": "Control.CCCxe",
          "name": "PD",
          "package": "liboleg",
          "partial": "PD",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-CCCxe.html#t:PD"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe same as PP but with the phantom parameter c\n The parameter is useful to statically enforce various constrains\n (statically pass some information between shift and reset)\n The prompt PP is too \u003ccode\u003edynamic\u003c/code\u003e: all errors are detected dynamically\n See Generator2.hs for an example\n\u003c/p\u003e",
          "module": "Control.CCCxe",
          "name": "PM",
          "package": "liboleg",
          "source": "src/Control-CCCxe.html#PM",
          "type": "data"
        },
        "index": {
          "description": "The same as PP but with the phantom parameter The parameter is useful to statically enforce various constrains statically pass some information between shift and reset The prompt PP is too dynamic all errors are detected dynamically See Generator2.hs for an example",
          "hierarchy": "Control CCCxe",
          "module": "Control.CCCxe",
          "name": "PM",
          "package": "liboleg",
          "partial": "PM",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-CCCxe.html#t:PM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePrompts for the open set of answer-types\n\u003c/p\u003e",
          "module": "Control.CCCxe",
          "name": "PP",
          "package": "liboleg",
          "source": "src/Control-CCCxe.html#PP",
          "type": "data"
        },
        "index": {
          "description": "Prompts for the open set of answer-types",
          "hierarchy": "Control CCCxe",
          "module": "Control.CCCxe",
          "name": "PP",
          "package": "liboleg",
          "partial": "PP",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-CCCxe.html#t:PP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe extreme case: prompts for the single answer-type w.\n The monad (CC PS) then is the monad for regular (single-prompt) \n delimited continuations\n\u003c/p\u003e",
          "module": "Control.CCCxe",
          "name": "PS",
          "package": "liboleg",
          "source": "src/Control-CCCxe.html#PS",
          "type": "data"
        },
        "index": {
          "description": "The extreme case prompts for the single answer-type The monad CC PS then is the monad for regular single-prompt delimited continuations",
          "hierarchy": "Control CCCxe",
          "module": "Control.CCCxe",
          "name": "PS",
          "package": "liboleg",
          "partial": "PS",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-CCCxe.html#t:PS"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGeneralized prompts for the answer-type w: an injection-projection pair\n\u003c/p\u003e",
          "module": "Control.CCCxe",
          "name": "Prompt",
          "package": "liboleg",
          "source": "src/Control-CCCxe.html#Prompt",
          "type": "type"
        },
        "index": {
          "description": "Generalized prompts for the answer-type an injection-projection pair",
          "hierarchy": "Control CCCxe",
          "module": "Control.CCCxe",
          "name": "Prompt",
          "package": "liboleg",
          "partial": "Prompt",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-CCCxe.html#t:Prompt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe captured sub-continuation\n\u003c/p\u003e",
          "module": "Control.CCCxe",
          "name": "SubCont",
          "package": "liboleg",
          "source": "src/Control-CCCxe.html#SubCont",
          "type": "type"
        },
        "index": {
          "description": "The captured sub-continuation",
          "hierarchy": "Control CCCxe",
          "module": "Control.CCCxe",
          "name": "SubCont",
          "package": "liboleg",
          "partial": "Sub Cont",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-CCCxe.html#t:SubCont"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUseful derived operations\n\u003c/p\u003e",
          "module": "Control.CCCxe",
          "name": "abortP",
          "package": "liboleg",
          "signature": "Prompt p m w -\u003e CC p m w -\u003e CC p m any",
          "source": "src/Control-CCCxe.html#abortP",
          "type": "function"
        },
        "index": {
          "description": "Useful derived operations",
          "hierarchy": "Control CCCxe",
          "module": "Control.CCCxe",
          "name": "abortP",
          "normalized": "Prompt a b c-\u003eCC a b c-\u003eCC a b d",
          "package": "liboleg",
          "signature": "Prompt p m w-\u003eCC p m w-\u003eCC p m any",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-CCCxe.html#v:abortP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIt is often helpful, for clarity of error messages, to specify the \n answer-type associated with the prompt explicitly (rather than relying \n on the type inference to figure that out). The following function\n is useful for that purpose.\n\u003c/p\u003e",
          "module": "Control.CCCxe",
          "name": "as_prompt_type",
          "package": "liboleg",
          "signature": "Prompt p m w -\u003e w -\u003e Prompt p m w",
          "source": "src/Control-CCCxe.html#as_prompt_type",
          "type": "function"
        },
        "index": {
          "description": "It is often helpful for clarity of error messages to specify the answer-type associated with the prompt explicitly rather than relying on the type inference to figure that out The following function is useful for that purpose",
          "hierarchy": "Control CCCxe",
          "module": "Control.CCCxe",
          "name": "as_prompt_type",
          "normalized": "Prompt a b c-\u003ec-\u003ePrompt a b c",
          "package": "liboleg",
          "signature": "Prompt p m w-\u003ew-\u003ePrompt p m w",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-CCCxe.html#v:as_prompt_type"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.CCCxe",
          "name": "controlP",
          "package": "liboleg",
          "signature": "Prompt p m w -\u003e ((a -\u003e CC p m w) -\u003e CC p m w) -\u003e CC p m a",
          "source": "src/Control-CCCxe.html#controlP",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control CCCxe",
          "module": "Control.CCCxe",
          "name": "controlP",
          "normalized": "Prompt a b c-\u003e((d-\u003eCC a b c)-\u003eCC a b c)-\u003eCC a b d",
          "package": "liboleg",
          "signature": "Prompt p m w-\u003e((a-\u003eCC p m w)-\u003eCC p m w)-\u003eCC p m a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-CCCxe.html#v:controlP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.CCCxe",
          "name": "newPrompt",
          "package": "liboleg",
          "signature": "Int -\u003e Prompt PD m w",
          "source": "src/Control-CCCxe.html#newPrompt",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control CCCxe",
          "module": "Control.CCCxe",
          "name": "newPrompt",
          "normalized": "Int-\u003ePrompt PD a b",
          "package": "liboleg",
          "partial": "Prompt",
          "signature": "Int-\u003ePrompt PD m w",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-CCCxe.html#v:newPrompt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThere are two generalized prompts of the flavor P2\n\u003c/p\u003e",
          "module": "Control.CCCxe",
          "name": "p2L",
          "package": "liboleg",
          "signature": "Prompt (P2 w1 w2) m w1",
          "source": "src/Control-CCCxe.html#p2L",
          "type": "function"
        },
        "index": {
          "description": "There are two generalized prompts of the flavor P2",
          "hierarchy": "Control CCCxe",
          "module": "Control.CCCxe",
          "name": "p2L",
          "package": "liboleg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-CCCxe.html#v:p2L"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.CCCxe",
          "name": "p2R",
          "package": "liboleg",
          "signature": "Prompt (P2 w1 w2) m w2",
          "source": "src/Control-CCCxe.html#p2R",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control CCCxe",
          "module": "Control.CCCxe",
          "name": "p2R",
          "package": "liboleg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-CCCxe.html#v:p2R"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.CCCxe",
          "name": "pm",
          "package": "liboleg",
          "signature": "Prompt (PM c) m w",
          "source": "src/Control-CCCxe.html#pm",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control CCCxe",
          "module": "Control.CCCxe",
          "name": "pm",
          "package": "liboleg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-CCCxe.html#v:pm"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.CCCxe",
          "name": "pp",
          "package": "liboleg",
          "signature": "Prompt PP m w",
          "source": "src/Control-CCCxe.html#pp",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control CCCxe",
          "module": "Control.CCCxe",
          "name": "pp",
          "package": "liboleg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-CCCxe.html#v:pp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThere is only one generalized prompt of the flavor PS for a\n given answer-type w. It is defined below\n\u003c/p\u003e",
          "module": "Control.CCCxe",
          "name": "ps",
          "package": "liboleg",
          "signature": "Prompt (PS w) m w",
          "source": "src/Control-CCCxe.html#ps",
          "type": "function"
        },
        "index": {
          "description": "There is only one generalized prompt of the flavor PS for given answer-type It is defined below",
          "hierarchy": "Control CCCxe",
          "module": "Control.CCCxe",
          "name": "ps",
          "package": "liboleg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-CCCxe.html#v:ps"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eBasic Operations of the delimited control interface\n\u003c/p\u003e",
          "module": "Control.CCCxe",
          "name": "pushPrompt",
          "package": "liboleg",
          "signature": "Prompt p m w -\u003e CC p m w -\u003e CC p m w",
          "source": "src/Control-CCCxe.html#pushPrompt",
          "type": "function"
        },
        "index": {
          "description": "Basic Operations of the delimited control interface",
          "hierarchy": "Control CCCxe",
          "module": "Control.CCCxe",
          "name": "pushPrompt",
          "normalized": "Prompt a b c-\u003eCC a b c-\u003eCC a b c",
          "package": "liboleg",
          "partial": "Prompt",
          "signature": "Prompt p m w-\u003eCC p m w-\u003eCC p m w",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-CCCxe.html#v:pushPrompt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eApply the captured continuation\n\u003c/p\u003e",
          "module": "Control.CCCxe",
          "name": "pushSubCont",
          "package": "liboleg",
          "signature": "SubCont p m a b -\u003e CC p m a -\u003e CC p m b",
          "source": "src/Control-CCCxe.html#pushSubCont",
          "type": "function"
        },
        "index": {
          "description": "Apply the captured continuation",
          "hierarchy": "Control CCCxe",
          "module": "Control.CCCxe",
          "name": "pushSubCont",
          "normalized": "SubCont a b c d-\u003eCC a b c-\u003eCC a b d",
          "package": "liboleg",
          "partial": "Sub Cont",
          "signature": "SubCont p m a b-\u003eCC p m a-\u003eCC p m b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-CCCxe.html#v:pushSubCont"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.CCCxe",
          "name": "runCC",
          "package": "liboleg",
          "signature": "(* -\u003e *) -\u003e * -\u003e *) m a -\u003e m a",
          "source": "src/Control-CCCxe.html#runCC",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control CCCxe",
          "module": "Control.CCCxe",
          "name": "runCC",
          "normalized": "(*-\u003e*)-\u003e*-\u003e*)a b-\u003ea b",
          "package": "liboleg",
          "partial": "CC",
          "signature": "(*-\u003e*)-\u003e*-\u003e*)m a-\u003em a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-CCCxe.html#v:runCC"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.CCCxe",
          "name": "shift0P",
          "package": "liboleg",
          "signature": "Prompt p m w -\u003e ((a -\u003e CC p m w) -\u003e CC p m w) -\u003e CC p m a",
          "source": "src/Control-CCCxe.html#shift0P",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control CCCxe",
          "module": "Control.CCCxe",
          "name": "shift0P",
          "normalized": "Prompt a b c-\u003e((d-\u003eCC a b c)-\u003eCC a b c)-\u003eCC a b d",
          "package": "liboleg",
          "signature": "Prompt p m w-\u003e((a-\u003eCC p m w)-\u003eCC p m w)-\u003eCC p m a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-CCCxe.html#v:shift0P"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.CCCxe",
          "name": "shiftP",
          "package": "liboleg",
          "signature": "Prompt p m w -\u003e ((a -\u003e CC p m w) -\u003e CC p m w) -\u003e CC p m a",
          "source": "src/Control-CCCxe.html#shiftP",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control CCCxe",
          "module": "Control.CCCxe",
          "name": "shiftP",
          "normalized": "Prompt a b c-\u003e((d-\u003eCC a b c)-\u003eCC a b c)-\u003eCC a b d",
          "package": "liboleg",
          "signature": "Prompt p m w-\u003e((a-\u003eCC p m w)-\u003eCC p m w)-\u003eCC p m a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-CCCxe.html#v:shiftP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreate the initial bubble\n\u003c/p\u003e",
          "module": "Control.CCCxe",
          "name": "takeSubCont",
          "package": "liboleg",
          "signature": "Prompt p m w -\u003e CCT p m x w -\u003e CC p m x",
          "source": "src/Control-CCCxe.html#takeSubCont",
          "type": "function"
        },
        "index": {
          "description": "Create the initial bubble",
          "hierarchy": "Control CCCxe",
          "module": "Control.CCCxe",
          "name": "takeSubCont",
          "normalized": "Prompt a b c-\u003eCCT a b d c-\u003eCC a b d",
          "package": "liboleg",
          "partial": "Sub Cont",
          "signature": "Prompt p m w-\u003eCCT p m x w-\u003eCC p m x",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-CCCxe.html#v:takeSubCont"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eMonad transformer for multi-prompt delimited control\n It implements the superset of the interface described in\n\u003c/p\u003e\u003cp\u003e\u003ca\u003ehttp://okmij.org/ftp/continuations/implementations.html#CC-monads\u003c/a\u003e\n\u003c/p\u003e\u003cpre\u003e A Monadic Framework for Delimited Continuations\n R. Kent Dybvig, Simon Peyton Jones, and Amr Sabry\n JFP, v17, N6, pp. 687--730, 2007.\n http://www.cs.indiana.edu/cgi-bin/techreports/TRNNN.cgi?trnum=TR615\n\u003c/pre\u003e\u003cp\u003eThe first main difference is the use of generalized prompts, which\n do not have to be created with new_prompt and therefore can be defined\n at top level. That removes one of the main practical drawbacks of\n Dybvig et al implementations: the necessity to carry around the prompts\n throughout all the code.\n\u003c/p\u003e\u003cp\u003eThe delimited continuation monad is parameterized by the flavor\n of generalized prompts. The end of this code defines several flavors;\n the library users may define their own. User-defined flavors are \n especially useful when user's code uses a small closed set of answer-types. \n Flavors PP and PD below are more general, assuming the set of possible\n answer-types is open and Typeable. If the user wishes to create several\n distinct prompts with the same answer-types, the user should use\n the flavor of prompts accepting an integral prompt identifier, such as PD.\n Prompts of the flavor PD correspond to the prompts in Dybvig, Peyton Jones,\n Sabry framework. If the user wishes to generate unique prompts, the user\n should arrange himself for the generation of unique integers\n (using a state monad, for example). On the other hand, the user\n can differentiate answer-types using `newtype.' The latter can\n only produce the set of distinct prompts that is fixed at run-time.\n Sometimes that is sufficient. There is not need to create a gensym\n monad then.\n\u003c/p\u003e\u003cp\u003eThe second feature of our implementation is the use of the \n bubble-up semantics:\n See page 57 of \u003ca\u003ehttp://okmij.org/ftp/gengo/CAG-talk.pdf\u003c/a\u003e\n This present code implements, for the first time, the delimited \n continuation monad CC *without* the use of the continuation monad. \n This code implements CC in direct-style, so to speak.\n Instead of continuations, we rely on exceptions. Our code has a lot\n in common with the Error monad. In fact, our code implements\n an Error monad for resumable exceptions.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Control.CCExc",
          "name": "CCExc",
          "package": "liboleg",
          "source": "src/Control-CCExc.html",
          "type": "module"
        },
        "index": {
          "description": "Monad transformer for multi-prompt delimited control It implements the superset of the interface described in http okmij.org ftp continuations implementations.html CC-monads Monadic Framework for Delimited Continuations Kent Dybvig Simon Peyton Jones and Amr Sabry JFP v17 N6 pp http www.cs.indiana.edu cgi-bin techreports TRNNN.cgi trnum TR615 The first main difference is the use of generalized prompts which do not have to be created with new prompt and therefore can be defined at top level That removes one of the main practical drawbacks of Dybvig et al implementations the necessity to carry around the prompts throughout all the code The delimited continuation monad is parameterized by the flavor of generalized prompts The end of this code defines several flavors the library users may define their own User-defined flavors are especially useful when user code uses small closed set of answer-types Flavors PP and PD below are more general assuming the set of possible answer-types is open and Typeable If the user wishes to create several distinct prompts with the same answer-types the user should use the flavor of prompts accepting an integral prompt identifier such as PD Prompts of the flavor PD correspond to the prompts in Dybvig Peyton Jones Sabry framework If the user wishes to generate unique prompts the user should arrange himself for the generation of unique integers using state monad for example On the other hand the user can differentiate answer-types using newtype The latter can only produce the set of distinct prompts that is fixed at run-time Sometimes that is sufficient There is not need to create gensym monad then The second feature of our implementation is the use of the bubble-up semantics See page of http okmij.org ftp gengo CAG-talk.pdf This present code implements for the first time the delimited continuation monad CC without the use of the continuation monad This code implements CC in direct-style so to speak Instead of continuations we rely on exceptions Our code has lot in common with the Error monad In fact our code implements an Error monad for resumable exceptions",
          "hierarchy": "Control CCExc",
          "module": "Control.CCExc",
          "name": "CCExc",
          "package": "liboleg",
          "partial": "CCExc",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-CCExc.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDelimited-continuation monad transformer\n It is parameterized by the prompt flavor p\n\u003c/p\u003e",
          "module": "Control.CCExc",
          "name": "CC",
          "package": "liboleg",
          "source": "src/Control-CCExc.html#CC",
          "type": "data"
        },
        "index": {
          "description": "Delimited-continuation monad transformer It is parameterized by the prompt flavor",
          "hierarchy": "Control CCExc",
          "module": "Control.CCExc",
          "name": "CC",
          "package": "liboleg",
          "partial": "CC",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-CCExc.html#t:CC"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe type of control operator's body\n\u003c/p\u003e",
          "module": "Control.CCExc",
          "name": "CCT",
          "package": "liboleg",
          "source": "src/Control-CCExc.html#CCT",
          "type": "type"
        },
        "index": {
          "description": "The type of control operator body",
          "hierarchy": "Control CCExc",
          "module": "Control.CCExc",
          "name": "CCT",
          "package": "liboleg",
          "partial": "CCT",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-CCExc.html#t:CCT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePrompts for the closed set of answer-types\n The following prompt flavor P2, for two answer-types w1 and w2,\n is given as an example. Typically, a programmer would define their\n own variant data type with variants for the answer-types that occur\n in their program.\n\u003c/p\u003e",
          "module": "Control.CCExc",
          "name": "P2",
          "package": "liboleg",
          "source": "src/Control-CCExc.html#P2",
          "type": "data"
        },
        "index": {
          "description": "Prompts for the closed set of answer-types The following prompt flavor P2 for two answer-types w1 and w2 is given as an example Typically programmer would define their own variant data type with variants for the answer-types that occur in their program",
          "hierarchy": "Control CCExc",
          "module": "Control.CCExc",
          "name": "P2",
          "package": "liboleg",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-CCExc.html#t:P2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eOpen set of answer types, with an additional distinction (given by\n integer identifiers)\n This prompt flavor corresponds to the prompts in the Dybvig, Peyton-Jones,\n Sabry framework (modulo the Typeable constraint).\n\u003c/p\u003e",
          "module": "Control.CCExc",
          "name": "PD",
          "package": "liboleg",
          "source": "src/Control-CCExc.html#PD",
          "type": "data"
        },
        "index": {
          "description": "Open set of answer types with an additional distinction given by integer identifiers This prompt flavor corresponds to the prompts in the Dybvig Peyton-Jones Sabry framework modulo the Typeable constraint",
          "hierarchy": "Control CCExc",
          "module": "Control.CCExc",
          "name": "PD",
          "package": "liboleg",
          "partial": "PD",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-CCExc.html#t:PD"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe same as PP but with the phantom parameter c\n The parameter is useful to statically enforce various constrains\n (statically pass some information between shift and reset)\n The prompt PP is too \u003ccode\u003edynamic\u003c/code\u003e: all errors are detected dynamically\n See Generator2.hs for an example\n\u003c/p\u003e",
          "module": "Control.CCExc",
          "name": "PM",
          "package": "liboleg",
          "source": "src/Control-CCExc.html#PM",
          "type": "data"
        },
        "index": {
          "description": "The same as PP but with the phantom parameter The parameter is useful to statically enforce various constrains statically pass some information between shift and reset The prompt PP is too dynamic all errors are detected dynamically See Generator2.hs for an example",
          "hierarchy": "Control CCExc",
          "module": "Control.CCExc",
          "name": "PM",
          "package": "liboleg",
          "partial": "PM",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-CCExc.html#t:PM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePrompts for the open set of answer-types\n\u003c/p\u003e",
          "module": "Control.CCExc",
          "name": "PP",
          "package": "liboleg",
          "source": "src/Control-CCExc.html#PP",
          "type": "data"
        },
        "index": {
          "description": "Prompts for the open set of answer-types",
          "hierarchy": "Control CCExc",
          "module": "Control.CCExc",
          "name": "PP",
          "package": "liboleg",
          "partial": "PP",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-CCExc.html#t:PP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe extreme case: prompts for the single answer-type w.\n The monad (CC PS) then is the monad for regular (single-prompt) \n delimited continuations\n\u003c/p\u003e",
          "module": "Control.CCExc",
          "name": "PS",
          "package": "liboleg",
          "source": "src/Control-CCExc.html#PS",
          "type": "data"
        },
        "index": {
          "description": "The extreme case prompts for the single answer-type The monad CC PS then is the monad for regular single-prompt delimited continuations",
          "hierarchy": "Control CCExc",
          "module": "Control.CCExc",
          "name": "PS",
          "package": "liboleg",
          "partial": "PS",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-CCExc.html#t:PS"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGeneralized prompts for the answer-type w: an injection-projection pair\n\u003c/p\u003e",
          "module": "Control.CCExc",
          "name": "Prompt",
          "package": "liboleg",
          "source": "src/Control-CCExc.html#Prompt",
          "type": "type"
        },
        "index": {
          "description": "Generalized prompts for the answer-type an injection-projection pair",
          "hierarchy": "Control CCExc",
          "module": "Control.CCExc",
          "name": "Prompt",
          "package": "liboleg",
          "partial": "Prompt",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-CCExc.html#t:Prompt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe captured sub-continuation\n\u003c/p\u003e",
          "module": "Control.CCExc",
          "name": "SubCont",
          "package": "liboleg",
          "source": "src/Control-CCExc.html#SubCont",
          "type": "type"
        },
        "index": {
          "description": "The captured sub-continuation",
          "hierarchy": "Control CCExc",
          "module": "Control.CCExc",
          "name": "SubCont",
          "package": "liboleg",
          "partial": "Sub Cont",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-CCExc.html#t:SubCont"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUseful derived operations\n\u003c/p\u003e",
          "module": "Control.CCExc",
          "name": "abortP",
          "package": "liboleg",
          "signature": "Prompt p m w -\u003e CC p m w -\u003e CC p m any",
          "source": "src/Control-CCExc.html#abortP",
          "type": "function"
        },
        "index": {
          "description": "Useful derived operations",
          "hierarchy": "Control CCExc",
          "module": "Control.CCExc",
          "name": "abortP",
          "normalized": "Prompt a b c-\u003eCC a b c-\u003eCC a b d",
          "package": "liboleg",
          "signature": "Prompt p m w-\u003eCC p m w-\u003eCC p m any",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-CCExc.html#v:abortP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIt is often helpful, for clarity of error messages, to specify the \n answer-type associated with the prompt explicitly (rather than relying \n on the type inference to figure that out). The following function\n is useful for that purpose.\n\u003c/p\u003e",
          "module": "Control.CCExc",
          "name": "as_prompt_type",
          "package": "liboleg",
          "signature": "Prompt p m w -\u003e w -\u003e Prompt p m w",
          "source": "src/Control-CCExc.html#as_prompt_type",
          "type": "function"
        },
        "index": {
          "description": "It is often helpful for clarity of error messages to specify the answer-type associated with the prompt explicitly rather than relying on the type inference to figure that out The following function is useful for that purpose",
          "hierarchy": "Control CCExc",
          "module": "Control.CCExc",
          "name": "as_prompt_type",
          "normalized": "Prompt a b c-\u003ec-\u003ePrompt a b c",
          "package": "liboleg",
          "signature": "Prompt p m w-\u003ew-\u003ePrompt p m w",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-CCExc.html#v:as_prompt_type"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.CCExc",
          "name": "controlP",
          "package": "liboleg",
          "signature": "Prompt p m w -\u003e ((a -\u003e CC p m w) -\u003e CC p m w) -\u003e CC p m a",
          "source": "src/Control-CCExc.html#controlP",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control CCExc",
          "module": "Control.CCExc",
          "name": "controlP",
          "normalized": "Prompt a b c-\u003e((d-\u003eCC a b c)-\u003eCC a b c)-\u003eCC a b d",
          "package": "liboleg",
          "signature": "Prompt p m w-\u003e((a-\u003eCC p m w)-\u003eCC p m w)-\u003eCC p m a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-CCExc.html#v:controlP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.CCExc",
          "name": "newPrompt",
          "package": "liboleg",
          "signature": "Int -\u003e Prompt PD m w",
          "source": "src/Control-CCExc.html#newPrompt",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control CCExc",
          "module": "Control.CCExc",
          "name": "newPrompt",
          "normalized": "Int-\u003ePrompt PD a b",
          "package": "liboleg",
          "partial": "Prompt",
          "signature": "Int-\u003ePrompt PD m w",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-CCExc.html#v:newPrompt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThere are two generalized prompts of the flavor P2\n\u003c/p\u003e",
          "module": "Control.CCExc",
          "name": "p2L",
          "package": "liboleg",
          "signature": "Prompt (P2 w1 w2) m w1",
          "source": "src/Control-CCExc.html#p2L",
          "type": "function"
        },
        "index": {
          "description": "There are two generalized prompts of the flavor P2",
          "hierarchy": "Control CCExc",
          "module": "Control.CCExc",
          "name": "p2L",
          "package": "liboleg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-CCExc.html#v:p2L"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.CCExc",
          "name": "p2R",
          "package": "liboleg",
          "signature": "Prompt (P2 w1 w2) m w2",
          "source": "src/Control-CCExc.html#p2R",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control CCExc",
          "module": "Control.CCExc",
          "name": "p2R",
          "package": "liboleg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-CCExc.html#v:p2R"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.CCExc",
          "name": "pm",
          "package": "liboleg",
          "signature": "Prompt (PM c) m w",
          "source": "src/Control-CCExc.html#pm",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control CCExc",
          "module": "Control.CCExc",
          "name": "pm",
          "package": "liboleg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-CCExc.html#v:pm"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.CCExc",
          "name": "pp",
          "package": "liboleg",
          "signature": "Prompt PP m w",
          "source": "src/Control-CCExc.html#pp",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control CCExc",
          "module": "Control.CCExc",
          "name": "pp",
          "package": "liboleg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-CCExc.html#v:pp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThere is only one generalized prompt of the flavor PS for a\n given answer-type w. It is defined below\n\u003c/p\u003e",
          "module": "Control.CCExc",
          "name": "ps",
          "package": "liboleg",
          "signature": "Prompt (PS w) m w",
          "source": "src/Control-CCExc.html#ps",
          "type": "function"
        },
        "index": {
          "description": "There is only one generalized prompt of the flavor PS for given answer-type It is defined below",
          "hierarchy": "Control CCExc",
          "module": "Control.CCExc",
          "name": "ps",
          "package": "liboleg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-CCExc.html#v:ps"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eBasic Operations of the delimited control interface\n\u003c/p\u003e",
          "module": "Control.CCExc",
          "name": "pushPrompt",
          "package": "liboleg",
          "signature": "Prompt p m w -\u003e CC p m w -\u003e CC p m w",
          "source": "src/Control-CCExc.html#pushPrompt",
          "type": "function"
        },
        "index": {
          "description": "Basic Operations of the delimited control interface",
          "hierarchy": "Control CCExc",
          "module": "Control.CCExc",
          "name": "pushPrompt",
          "normalized": "Prompt a b c-\u003eCC a b c-\u003eCC a b c",
          "package": "liboleg",
          "partial": "Prompt",
          "signature": "Prompt p m w-\u003eCC p m w-\u003eCC p m w",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-CCExc.html#v:pushPrompt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.CCExc",
          "name": "pushSubCont",
          "package": "liboleg",
          "signature": "SubCont p m a b -\u003e CC p m a -\u003e CC p m b",
          "source": "src/Control-CCExc.html#pushSubCont",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control CCExc",
          "module": "Control.CCExc",
          "name": "pushSubCont",
          "normalized": "SubCont a b c d-\u003eCC a b c-\u003eCC a b d",
          "package": "liboleg",
          "partial": "Sub Cont",
          "signature": "SubCont p m a b-\u003eCC p m a-\u003eCC p m b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-CCExc.html#v:pushSubCont"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.CCExc",
          "name": "runCC",
          "package": "liboleg",
          "signature": "(* -\u003e *) -\u003e * -\u003e *) m a -\u003e m a",
          "source": "src/Control-CCExc.html#runCC",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control CCExc",
          "module": "Control.CCExc",
          "name": "runCC",
          "normalized": "(*-\u003e*)-\u003e*-\u003e*)a b-\u003ea b",
          "package": "liboleg",
          "partial": "CC",
          "signature": "(*-\u003e*)-\u003e*-\u003e*)m a-\u003em a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-CCExc.html#v:runCC"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.CCExc",
          "name": "shift0P",
          "package": "liboleg",
          "signature": "Prompt p m w -\u003e ((a -\u003e CC p m w) -\u003e CC p m w) -\u003e CC p m a",
          "source": "src/Control-CCExc.html#shift0P",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control CCExc",
          "module": "Control.CCExc",
          "name": "shift0P",
          "normalized": "Prompt a b c-\u003e((d-\u003eCC a b c)-\u003eCC a b c)-\u003eCC a b d",
          "package": "liboleg",
          "signature": "Prompt p m w-\u003e((a-\u003eCC p m w)-\u003eCC p m w)-\u003eCC p m a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-CCExc.html#v:shift0P"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.CCExc",
          "name": "shiftP",
          "package": "liboleg",
          "signature": "Prompt p m w -\u003e ((a -\u003e CC p m w) -\u003e CC p m w) -\u003e CC p m a",
          "source": "src/Control-CCExc.html#shiftP",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control CCExc",
          "module": "Control.CCExc",
          "name": "shiftP",
          "normalized": "Prompt a b c-\u003e((d-\u003eCC a b c)-\u003eCC a b c)-\u003eCC a b d",
          "package": "liboleg",
          "signature": "Prompt p m w-\u003e((a-\u003eCC p m w)-\u003eCC p m w)-\u003eCC p m a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-CCExc.html#v:shiftP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreate the initial bubble\n\u003c/p\u003e",
          "module": "Control.CCExc",
          "name": "takeSubCont",
          "package": "liboleg",
          "signature": "Prompt p m w -\u003e CCT p m x w -\u003e CC p m x",
          "source": "src/Control-CCExc.html#takeSubCont",
          "type": "function"
        },
        "index": {
          "description": "Create the initial bubble",
          "hierarchy": "Control CCExc",
          "module": "Control.CCExc",
          "name": "takeSubCont",
          "normalized": "Prompt a b c-\u003eCCT a b d c-\u003eCC a b d",
          "package": "liboleg",
          "partial": "Sub Cont",
          "signature": "Prompt p m w-\u003eCCT p m x w-\u003eCC p m x",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-CCExc.html#v:takeSubCont"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eMonad transformer for multi-prompt delimited control\n\u003c/p\u003e\u003cp\u003eThis library implements the superset of the interface described in\n\u003c/p\u003e\u003cpre\u003e A Monadic Framework for Delimited Continuations\n R. Kent Dybvig, Simon Peyton Jones, and Amr Sabry\n JFP, v17, N6, pp. 687--730, 2007.\n http://www.cs.indiana.edu/cgi-bin/techreports/TRNNN.cgi?trnum=TR615\n\u003c/pre\u003e\u003cp\u003eThis code is the straightforward implementation of the\n definitional machine described in the above paper. To be precise,\n we implement an equivalent machine, where captured continuations are\n always sandwiched between two prompts. This equivalence as\n well as the trick to make it all well-typed are described in\n the FLOPS 2010 paper. Therefore, to the great extent\n this code is the straightforward translation of delimcc from OCaml.\n The parallel stack of delimcc is the \u003ccode\u003ereal\u003c/code\u003e stack now (containing\n parts of the real continuation, that is).\n\u003c/p\u003e\u003cp\u003eThis code implements, in CPS, what amounts to a segmented stack\n (the technique of implementing call/cc efficiently, first described in\n Hieb, Dybvig and Bruggeman's PLDI 1990 paper).\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Control.CCRef",
          "name": "CCRef",
          "package": "liboleg",
          "source": "src/Control-CCRef.html",
          "type": "module"
        },
        "index": {
          "description": "Monad transformer for multi-prompt delimited control This library implements the superset of the interface described in Monadic Framework for Delimited Continuations Kent Dybvig Simon Peyton Jones and Amr Sabry JFP v17 N6 pp http www.cs.indiana.edu cgi-bin techreports TRNNN.cgi trnum TR615 This code is the straightforward implementation of the definitional machine described in the above paper To be precise we implement an equivalent machine where captured continuations are always sandwiched between two prompts This equivalence as well as the trick to make it all well-typed are described in the FLOPS paper Therefore to the great extent this code is the straightforward translation of delimcc from OCaml The parallel stack of delimcc is the real stack now containing parts of the real continuation that is This code implements in CPS what amounts to segmented stack the technique of implementing call cc efficiently first described in Hieb Dybvig and Bruggeman PLDI paper",
          "hierarchy": "Control CCRef",
          "module": "Control.CCRef",
          "name": "CCRef",
          "package": "liboleg",
          "partial": "CCRef",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-CCRef.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDelimited-continuation monad transformer\n The (CC m) monad is the Cont monad with the answer-type (),\n combined with the persistent-state monad. The state PTop is the\n `parallel stack' of delimcc, which is the real stack now. \n The base monad m must support reference cells, that is,\n be a member of the type class Mutation.\n Since we need reference cells anyway, we represent the persistent\n state as a reference cell PTop, which is passed as the environment.\n\u003c/p\u003e",
          "module": "Control.CCRef",
          "name": "CC",
          "package": "liboleg",
          "source": "src/Control-CCRef.html#CC",
          "type": "data"
        },
        "index": {
          "description": "Delimited-continuation monad transformer The CC monad is the Cont monad with the answer-type combined with the persistent-state monad The state PTop is the parallel stack of delimcc which is the real stack now The base monad must support reference cells that is be member of the type class Mutation Since we need reference cells anyway we represent the persistent state as reference cell PTop which is passed as the environment",
          "hierarchy": "Control CCRef",
          "module": "Control.CCRef",
          "name": "CC",
          "package": "liboleg",
          "partial": "CC",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-CCRef.html#t:CC"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWe manipulate portions of the stack between two exception frames.\n The type of the exception DelimCCE is ()\n\u003c/p\u003e\u003cp\u003eThe type of prompts is just like that in OCaml's delimcc\n\u003c/p\u003e",
          "module": "Control.CCRef",
          "name": "Prompt",
          "package": "liboleg",
          "source": "src/Control-CCRef.html#Prompt",
          "type": "data"
        },
        "index": {
          "description": "We manipulate portions of the stack between two exception frames The type of the exception DelimCCE is The type of prompts is just like that in OCaml delimcc",
          "hierarchy": "Control CCRef",
          "module": "Control.CCRef",
          "name": "Prompt",
          "package": "liboleg",
          "partial": "Prompt",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-CCRef.html#t:Prompt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe context between two exception frames: The captured sub-continuation\n It is a fragment of the parallel stack: a list of PFrames in inverse order.\n Since we are in the Cont monad, there is no \u003ccode\u003ereal\u003c/code\u003e stack:\n the type Ekfragment  is ()\n\u003c/p\u003e",
          "module": "Control.CCRef",
          "name": "SubCont",
          "package": "liboleg",
          "source": "src/Control-CCRef.html#SubCont",
          "type": "data"
        },
        "index": {
          "description": "The context between two exception frames The captured sub-continuation It is fragment of the parallel stack list of PFrames in inverse order Since we are in the Cont monad there is no real stack the type Ekfragment is",
          "hierarchy": "Control CCRef",
          "module": "Control.CCRef",
          "name": "SubCont",
          "package": "liboleg",
          "partial": "Sub Cont",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-CCRef.html#t:SubCont"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn efficient variation of take_subcont, which does not capture\n any continuation.\n This code makes it clear that abort is essentially raise.\n\u003c/p\u003e",
          "module": "Control.CCRef",
          "name": "abortP",
          "package": "liboleg",
          "signature": "Prompt m w -\u003e CC m w -\u003e CC m any",
          "source": "src/Control-CCRef.html#abortP",
          "type": "function"
        },
        "index": {
          "description": "An efficient variation of take subcont which does not capture any continuation This code makes it clear that abort is essentially raise",
          "hierarchy": "Control CCRef",
          "module": "Control.CCRef",
          "name": "abortP",
          "normalized": "Prompt a b-\u003eCC a b-\u003eCC a c",
          "package": "liboleg",
          "signature": "Prompt m w-\u003eCC m w-\u003eCC m any",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-CCRef.html#v:abortP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.CCRef",
          "name": "controlP",
          "package": "liboleg",
          "signature": "Prompt m w -\u003e ((a -\u003e CC m w) -\u003e CC m w) -\u003e CC m a",
          "source": "src/Control-CCRef.html#controlP",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control CCRef",
          "module": "Control.CCRef",
          "name": "controlP",
          "normalized": "Prompt a b-\u003e((c-\u003eCC a b)-\u003eCC a b)-\u003eCC a c",
          "package": "liboleg",
          "signature": "Prompt m w-\u003e((a-\u003eCC m w)-\u003eCC m w)-\u003eCC m a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-CCRef.html#v:controlP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCheck to see if a prompt is set\n\u003c/p\u003e",
          "module": "Control.CCRef",
          "name": "isPromptSet",
          "package": "liboleg",
          "signature": "Prompt m w -\u003e CC m Bool",
          "source": "src/Control-CCRef.html#isPromptSet",
          "type": "function"
        },
        "index": {
          "description": "Check to see if prompt is set",
          "hierarchy": "Control CCRef",
          "module": "Control.CCRef",
          "name": "isPromptSet",
          "normalized": "Prompt a b-\u003eCC a Bool",
          "package": "liboleg",
          "partial": "Prompt Set",
          "signature": "Prompt m w-\u003eCC m Bool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-CCRef.html#v:isPromptSet"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eBasic Operations of the delimited control interface\n All control operators in the end jump to the exception frame\n\u003c/p\u003e\u003cpre\u003e (in delimcc, that was `raise DelimCCE'; here it is `pfr_ek h')\n\u003c/pre\u003e",
          "module": "Control.CCRef",
          "name": "newPrompt",
          "package": "liboleg",
          "signature": "CC m (Prompt m a)",
          "source": "src/Control-CCRef.html#newPrompt",
          "type": "function"
        },
        "index": {
          "description": "Basic Operations of the delimited control interface All control operators in the end jump to the exception frame in delimcc that was raise DelimCCE here it is pfr ek",
          "hierarchy": "Control CCRef",
          "module": "Control.CCRef",
          "name": "newPrompt",
          "package": "liboleg",
          "partial": "Prompt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-CCRef.html#v:newPrompt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn optimization: pushing the _delimited_ continuation.\n This is the optimization of the pattern\n\u003c/p\u003e\u003cpre\u003e    pushPrompt (subcont_pb sk) (pushSubcont sk m)\n\u003c/pre\u003e\u003cp\u003ecorresponding to pushing the continuation captured by shift/shift0. \n The latter continuation always has the delimiter at the end.\n Indeed shift can be implemented more efficiently as a primitive\n rather than via push_prompt/control combination...\n\u003c/p\u003e",
          "module": "Control.CCRef",
          "name": "pushDelimSubCont",
          "package": "liboleg",
          "signature": "SubCont m a b -\u003e CC m a -\u003e CC m b",
          "source": "src/Control-CCRef.html#pushDelimSubCont",
          "type": "function"
        },
        "index": {
          "description": "An optimization pushing the delimited continuation This is the optimization of the pattern pushPrompt subcont pb sk pushSubcont sk corresponding to pushing the continuation captured by shift shift0 The latter continuation always has the delimiter at the end Indeed shift can be implemented more efficiently as primitive rather than via push prompt control combination",
          "hierarchy": "Control CCRef",
          "module": "Control.CCRef",
          "name": "pushDelimSubCont",
          "normalized": "SubCont a b c-\u003eCC a b-\u003eCC a c",
          "package": "liboleg",
          "partial": "Delim Sub Cont",
          "signature": "SubCont m a b-\u003eCC m a-\u003eCC m b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-CCRef.html#v:pushDelimSubCont"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.CCRef",
          "name": "pushPrompt",
          "package": "liboleg",
          "signature": "Prompt m w -\u003e CC m w -\u003e CC m w",
          "source": "src/Control-CCRef.html#pushPrompt",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control CCRef",
          "module": "Control.CCRef",
          "name": "pushPrompt",
          "normalized": "Prompt a b-\u003eCC a b-\u003eCC a b",
          "package": "liboleg",
          "partial": "Prompt",
          "signature": "Prompt m w-\u003eCC m w-\u003eCC m w",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-CCRef.html#v:pushPrompt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.CCRef",
          "name": "pushSubCont",
          "package": "liboleg",
          "signature": "SubCont m a b -\u003e CC m a -\u003e CC m b",
          "source": "src/Control-CCRef.html#pushSubCont",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control CCRef",
          "module": "Control.CCRef",
          "name": "pushSubCont",
          "normalized": "SubCont a b c-\u003eCC a b-\u003eCC a c",
          "package": "liboleg",
          "partial": "Sub Cont",
          "signature": "SubCont m a b-\u003eCC m a-\u003eCC m b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-CCRef.html#v:pushSubCont"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.CCRef",
          "name": "runCC",
          "package": "liboleg",
          "signature": "CC m a -\u003e m a",
          "source": "src/Control-CCRef.html#runCC",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control CCRef",
          "module": "Control.CCRef",
          "name": "runCC",
          "normalized": "CC a b-\u003ea b",
          "package": "liboleg",
          "partial": "CC",
          "signature": "CC m a-\u003em a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-CCRef.html#v:runCC"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.CCRef",
          "name": "shift0P",
          "package": "liboleg",
          "signature": "Prompt m w -\u003e ((a -\u003e CC m w) -\u003e CC m w) -\u003e CC m a",
          "source": "src/Control-CCRef.html#shift0P",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control CCRef",
          "module": "Control.CCRef",
          "name": "shift0P",
          "normalized": "Prompt a b-\u003e((c-\u003eCC a b)-\u003eCC a b)-\u003eCC a c",
          "package": "liboleg",
          "signature": "Prompt m w-\u003e((a-\u003eCC m w)-\u003eCC m w)-\u003eCC m a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-CCRef.html#v:shift0P"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUseful derived operations\n\u003c/p\u003e",
          "module": "Control.CCRef",
          "name": "shiftP",
          "package": "liboleg",
          "signature": "Prompt m w -\u003e ((a -\u003e CC m w) -\u003e CC m w) -\u003e CC m a",
          "source": "src/Control-CCRef.html#shiftP",
          "type": "function"
        },
        "index": {
          "description": "Useful derived operations",
          "hierarchy": "Control CCRef",
          "module": "Control.CCRef",
          "name": "shiftP",
          "normalized": "Prompt a b-\u003e((c-\u003eCC a b)-\u003eCC a b)-\u003eCC a c",
          "package": "liboleg",
          "signature": "Prompt m w-\u003e((a-\u003eCC m w)-\u003eCC m w)-\u003eCC m a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-CCRef.html#v:shiftP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.CCRef",
          "name": "takeSubCont",
          "package": "liboleg",
          "signature": "Prompt m b -\u003e (SubCont m a b -\u003e CC m b) -\u003e CC m a",
          "source": "src/Control-CCRef.html#takeSubCont",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control CCRef",
          "module": "Control.CCRef",
          "name": "takeSubCont",
          "normalized": "Prompt a b-\u003e(SubCont a c b-\u003eCC a b)-\u003eCC a c",
          "package": "liboleg",
          "partial": "Sub Cont",
          "signature": "Prompt m b-\u003e(SubCont m a b-\u003eCC m b)-\u003eCC m a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-CCRef.html#v:takeSubCont"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003e\u003ca\u003ehttp://okmij.org/ftp/Haskell/misc.html#catch-MonadIO\u003c/a\u003e\n\u003c/p\u003e\u003cp\u003eThe ability to use functions \u003ccode\u003e\u003ca\u003ecatch\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003ebracket\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003ecatchDyn\u003c/a\u003e\u003c/code\u003e, etc. in\n MonadIO other than IO itself has been a fairly frequently requested\n feature:\n\u003c/p\u003e\u003cp\u003e\u003ca\u003ehttp://www.haskell.org/pipermail/glasgow-haskell-users/2003-September/005660.html\u003c/a\u003e\n\u003c/p\u003e\u003cp\u003e\u003ca\u003e http://haskell.org/pipermail/libraries/2003-February/000774.html\u003c/a\u003e\n\u003c/p\u003e\u003cp\u003eThe reason it is not implemented is because these functions cannot be\n defined for a general MonadIO. However, these functions can be easily\n defined for a large and interesting subset of MonadIO. The following\n code demonstrates that. It uses no extensions (other than those needed\n for the Monad Transformer Library itself), patches no compilers, and\n proposes no extensions. The generic catch has been useful in a\n database library (Takusen), where many operations work in a monad\n (ReaderT Session IO): IO with the environment containing the database\n session data. Many other foreign libraries have a pattern of passing\n around various handles, which are better hidden in a monad. Still, we\n should be able to handle IO errors and user exceptions that arise in\n these computations.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Control.CaughtMonadIO",
          "name": "CaughtMonadIO",
          "package": "liboleg",
          "source": "src/Control-CaughtMonadIO.html",
          "type": "module"
        },
        "index": {
          "description": "http okmij.org ftp Haskell misc.html catch-MonadIO The ability to use functions catch bracket catchDyn etc in MonadIO other than IO itself has been fairly frequently requested feature http www.haskell.org pipermail glasgow-haskell-users September html http haskell.org pipermail libraries February html The reason it is not implemented is because these functions cannot be defined for general MonadIO However these functions can be easily defined for large and interesting subset of MonadIO The following code demonstrates that It uses no extensions other than those needed for the Monad Transformer Library itself patches no compilers and proposes no extensions The generic catch has been useful in database library Takusen where many operations work in monad ReaderT Session IO IO with the environment containing the database session data Many other foreign libraries have pattern of passing around various handles which are better hidden in monad Still we should be able to handle IO errors and user exceptions that arise in these computations",
          "hierarchy": "Control CaughtMonadIO",
          "module": "Control.CaughtMonadIO",
          "name": "CaughtMonadIO",
          "package": "liboleg",
          "partial": "Caught Monad IO",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-CaughtMonadIO.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe implementation is quite trivial.\n\u003c/p\u003e",
          "module": "Control.CaughtMonadIO",
          "name": "CaughtMonadIO",
          "package": "liboleg",
          "source": "src/Control-CaughtMonadIO.html#CaughtMonadIO",
          "type": "class"
        },
        "index": {
          "description": "The implementation is quite trivial",
          "hierarchy": "Control CaughtMonadIO",
          "module": "Control.CaughtMonadIO",
          "name": "CaughtMonadIO",
          "package": "liboleg",
          "partial": "Caught Monad IO",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-CaughtMonadIO.html#t:CaughtMonadIO"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.CaughtMonadIO",
          "name": "MyException",
          "package": "liboleg",
          "source": "src/Control-CaughtMonadIO.html#MyException",
          "type": "data"
        },
        "index": {
          "hierarchy": "Control CaughtMonadIO",
          "module": "Control.CaughtMonadIO",
          "name": "MyException",
          "package": "liboleg",
          "partial": "My Exception",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-CaughtMonadIO.html#t:MyException"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.CaughtMonadIO",
          "name": "MyException",
          "package": "liboleg",
          "signature": "MyException String",
          "source": "src/Control-CaughtMonadIO.html#MyException",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control CaughtMonadIO",
          "module": "Control.CaughtMonadIO",
          "name": "MyException",
          "package": "liboleg",
          "partial": "My Exception",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-CaughtMonadIO.html#v:MyException"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.CaughtMonadIO",
          "name": "catchDyn",
          "package": "liboleg",
          "signature": "m a -\u003e (e -\u003e m a) -\u003e m a",
          "source": "src/Control-CaughtMonadIO.html#catchDyn",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control CaughtMonadIO",
          "module": "Control.CaughtMonadIO",
          "name": "catchDyn",
          "normalized": "a b-\u003e(c-\u003ea b)-\u003ea b",
          "package": "liboleg",
          "partial": "Dyn",
          "signature": "m a-\u003e(e-\u003em a)-\u003em a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-CaughtMonadIO.html#v:catchDyn"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.CaughtMonadIO",
          "name": "gcatch",
          "package": "liboleg",
          "signature": "m a -\u003e (Exception -\u003e m a) -\u003e m a",
          "source": "src/Control-CaughtMonadIO.html#gcatch",
          "type": "method"
        },
        "index": {
          "hierarchy": "Control CaughtMonadIO",
          "module": "Control.CaughtMonadIO",
          "name": "gcatch",
          "normalized": "a b-\u003e(Exception-\u003ea b)-\u003ea b",
          "package": "liboleg",
          "signature": "m a-\u003e(Exception-\u003em a)-\u003em a",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-CaughtMonadIO.html#v:gcatch"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eExtensible Denotational Semantics\n\u003c/p\u003e\u003cp\u003eThis work is a generalization of \n   /Extensible Denotational Language Specifications\n    Robert Cartwright, Matthias Felleisen\n    Theor. Aspects of Computer Software, 1994/\n    \u003ca\u003ehttp://citeseer.ist.psu.edu/69837.html\u003c/a\u003e\n\u003c/p\u003e\u003cp\u003eto be referred to as EDLS.\n\u003c/p\u003e\u003cp\u003eWe implement the enhanced EDLS in Haskell and add delimited control.\n To be precise, we implement the Base interpreter (whose sole\n operations are Loop and Error) and the following extensions: CBV\n lambda-calculus, Arithmetic, Storage, Control. The extensions can be\n added to the Base interpreter in any order and in any combination.\n\u003c/p\u003e\u003cp\u003eOur implementation has the following advantages over EDLS:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e support for delimited control\n * support for a local storage (including `thread-local' storage and\n   general delimited dynamic binding)\n * extensions do not have to be composed explicitly, and so the\n   composition order truly does not matter.  In the\n   original EDLS, one\n   had to write interpreter composition explicitly. In our approach, an\n   extension is pulled in automatically if the program includes the\n   corresponding syntactic forms. For example, if a program contains\n   storage cell creation and dereference operations, the Storage extension\n   will automatically be used to interpret the program.\n\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eOur main departure from EDLS is is the removal of the `central\n authority'. There is no semantic \u003ccode\u003eadmin\u003c/code\u003e function. Rather, admin is\n part of the source language and can be used at any place in the\n code. The `central authority' of EDLS must be an extensible function,\n requiring meta-language facilities to implement (such as quite\n non-standard Scheme modules). We do not have central\n authority. Rather, we have bureaucracy: each specific effect handler\n interprets its own effects as it can, throwing the rest \u003ccode\u003eupstairs\u003c/code\u003e for\n higher-level bureaucrats to deal with. Extensibility arises\n automatically.\n\u003c/p\u003e\u003cp\u003eWe take the meaning of a program to be the union of Values and\n (unfulfilled) Actions. If the meaning of the program is a (non-bottom)\n value, the program is terminating. If the meaning of the program is an\n Action -- the program finished with an error, such as an action to\n access a non-existing storage cell, or shift without reset, or a\n user-raised error.\n\u003c/p\u003e\u003cp\u003eIncidentally, EDLS stresses on p. 2 (the last full paragraph) that\n their schema critically relies on the distinction between a complete\n program and a nested program phrase. Our contribution (which is the\n consequence of removing the central admin, making it first-class) is\n eliminating such a distinction! EDLS says, at the very top of p. 3,\n that the handle in the effect message ``is roughly a conventional\n continuation.'' Because the admin of EDLS is \u003ccode\u003eoutside\u003c/code\u003e of the program\n (at the point of infinity, so to speak), its continuation indeed\n appears undelimited. By making our \u003ccode\u003eadmin\u003c/code\u003e a part of the source\n language, we recognize the handle in the effect message for what it\n is: a _delimited_ continuation.\n\u003c/p\u003e\u003cp\u003eAs we see below, the Control aspect is orthogonal to the CBV\n aspect. So, we can just as easily replace the CBV extension with the\n CBN extension, which will give us the denotation of delimited control\n in CBN.\n\u003c/p\u003e\u003cp\u003eWe shall be using Haskell to express denotations, taking advantage of\n the fact that Haskell values are \u003ccode\u003elifted\u003c/code\u003e. See also the remark on p21\n of EDLS: someone (ref. [4]) showed that sets and partial functions can\n suffice...\n\u003c/p\u003e\u003cp\u003eOur program denotations are stable: they have the same form regardless\n of a particular composition of modular interpreters.  See Section 3.5\n of EDLS for precise formulation (and the last paragraph of Section 3.4\n for concise informal statement of stability). Also see the comparison\n with the monads on p. 20: different monads assign numeral radically\n different meanings, depending on the monad. But in EDLS, a numeral has\n exactly the same denotation.\n\u003c/p\u003e\u003cp\u003eThe meaning of an expression is also the same and stable, no matter\n what the interpreter is: it is a function from Env to Computations\n (the latter being the union of values and unfulfilled effects -- the\n same union mentioned above).\n\u003c/p\u003e\u003cp\u003eHowever, by using handlers, some effect messages can be subtracted:\n so, strictly speaking, the denotation of a fragment is V +\n effect-message-issued - effect-messages handled.  There seem to be a\n connection with effect systems.\n\u003c/p\u003e\u003cp\u003eAdditional notes on EDLS:\n\u003c/p\u003e\u003cp\u003eThe abstract and p. 2 (especially the last full paragraph) are\n so well-written!\n\u003c/p\u003e\u003cp\u003ep. 5, bottom: ``It [ref x.x, where ref means what it does in ML] \n is a closed expression that does not diverge, is not a value, and\n cannot be reduced to a value without affecting the context. We refer\n to such results as _effects_.''\n\u003c/p\u003e\u003cp\u003eBeginning of Section 3 and App A give a very good introduction\n to the denotational semantics.\n\u003c/p\u003e\u003cp\u003ep. 6: ``Algebraically speaking, the interpreter is (roughly) a\n homomorphism from syntax to semantics''\n\u003c/p\u003e\u003cp\u003e``A straightforward representation of an evaluation context is a\n function from values to computations, which directly corresponds to\n its operational usage as a function from syntactic values to\n expressions.'' (p. 8). EDLS then notices that the \u003ccode\u003ehandle\u003c/code\u003e has\n the same type as the denotation of a context. Footnote 6 notes that\n handler is roughly the composition combinator for functions from values\n to computations [contexts!] and it superficially relates to [bind]\n but does not satisfy all monad laws.\n\u003c/p\u003e\u003cp\u003eThe last of EDLS Sec 3.5, p. 15: ``Informally speaking, this property\n [stable denotations] asserts that in the framework of extensible\n semantics, the addition of a programming construct corresponds to the\n addition of a new `\u003ccode\u003edimension'\u003c/code\u003e to the space of meaning. [The\n equations, featuring injection and projection functions, make that\n precise and clear.] The reader may want to contrast this general\n statement with the numerous papers on the relationship between direct\n and continuation semantics.''\n\u003c/p\u003e\u003cp\u003eThe practical consequence of the lack of stability of denotations for\n monads is that monadic transformers put layers upon layers of thunks,\n which have to be carried over _in full_ from one sub-expression into\n the other, even if no single subexpression uses all of the features.\n\u003c/p\u003e\u003cp\u003eThe present code is not written in idiomatic Haskell and does not take\n advantage of types at all. The ubiquitous projections from the\n universal domain tantamount to ``dynamic typing.''  The code is\n intentionally written to be close to the EDLS paper, emphasizing\n denotational semantics (whose domains are untyped). One can certainly\n do better, for example, employ user-defined datatypes for tagged\n values, avoiding the ugly string-tagged VT.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Control.ExtensibleDS",
          "name": "ExtensibleDS",
          "package": "liboleg",
          "source": "src/Control-ExtensibleDS.html",
          "type": "module"
        },
        "index": {
          "description": "Extensible Denotational Semantics This work is generalization of Extensible Denotational Language Specifications Robert Cartwright Matthias Felleisen Theor Aspects of Computer Software http citeseer.ist.psu.edu html to be referred to as EDLS We implement the enhanced EDLS in Haskell and add delimited control To be precise we implement the Base interpreter whose sole operations are Loop and Error and the following extensions CBV lambda-calculus Arithmetic Storage Control The extensions can be added to the Base interpreter in any order and in any combination Our implementation has the following advantages over EDLS support for delimited control support for local storage including thread-local storage and general delimited dynamic binding extensions do not have to be composed explicitly and so the composition order truly does not matter In the original EDLS one had to write interpreter composition explicitly In our approach an extension is pulled in automatically if the program includes the corresponding syntactic forms For example if program contains storage cell creation and dereference operations the Storage extension will automatically be used to interpret the program Our main departure from EDLS is is the removal of the central authority There is no semantic admin function Rather admin is part of the source language and can be used at any place in the code The central authority of EDLS must be an extensible function requiring meta-language facilities to implement such as quite non-standard Scheme modules We do not have central authority Rather we have bureaucracy each specific effect handler interprets its own effects as it can throwing the rest upstairs for higher-level bureaucrats to deal with Extensibility arises automatically We take the meaning of program to be the union of Values and unfulfilled Actions If the meaning of the program is non-bottom value the program is terminating If the meaning of the program is an Action the program finished with an error such as an action to access non-existing storage cell or shift without reset or user-raised error Incidentally EDLS stresses on the last full paragraph that their schema critically relies on the distinction between complete program and nested program phrase Our contribution which is the consequence of removing the central admin making it first-class is eliminating such distinction EDLS says at the very top of that the handle in the effect message is roughly conventional continuation Because the admin of EDLS is outside of the program at the point of infinity so to speak its continuation indeed appears undelimited By making our admin part of the source language we recognize the handle in the effect message for what it is delimited continuation As we see below the Control aspect is orthogonal to the CBV aspect So we can just as easily replace the CBV extension with the CBN extension which will give us the denotation of delimited control in CBN We shall be using Haskell to express denotations taking advantage of the fact that Haskell values are lifted See also the remark on p21 of EDLS someone ref showed that sets and partial functions can suffice Our program denotations are stable they have the same form regardless of particular composition of modular interpreters See Section of EDLS for precise formulation and the last paragraph of Section for concise informal statement of stability Also see the comparison with the monads on different monads assign numeral radically different meanings depending on the monad But in EDLS numeral has exactly the same denotation The meaning of an expression is also the same and stable no matter what the interpreter is it is function from Env to Computations the latter being the union of values and unfulfilled effects the same union mentioned above However by using handlers some effect messages can be subtracted so strictly speaking the denotation of fragment is effect-message-issued effect-messages handled There seem to be connection with effect systems Additional notes on EDLS The abstract and especially the last full paragraph are so well-written bottom It ref x.x where ref means what it does in ML is closed expression that does not diverge is not value and cannot be reduced to value without affecting the context We refer to such results as effects Beginning of Section and App give very good introduction to the denotational semantics Algebraically speaking the interpreter is roughly homomorphism from syntax to semantics straightforward representation of an evaluation context is function from values to computations which directly corresponds to its operational usage as function from syntactic values to expressions EDLS then notices that the handle has the same type as the denotation of context Footnote notes that handler is roughly the composition combinator for functions from values to computations contexts and it superficially relates to bind but does not satisfy all monad laws The last of EDLS Sec Informally speaking this property stable denotations asserts that in the framework of extensible semantics the addition of programming construct corresponds to the addition of new dimension to the space of meaning The equations featuring injection and projection functions make that precise and clear The reader may want to contrast this general statement with the numerous papers on the relationship between direct and continuation semantics The practical consequence of the lack of stability of denotations for monads is that monadic transformers put layers upon layers of thunks which have to be carried over in full from one sub-expression into the other even if no single subexpression uses all of the features The present code is not written in idiomatic Haskell and does not take advantage of types at all The ubiquitous projections from the universal domain tantamount to dynamic typing The code is intentionally written to be close to the EDLS paper emphasizing denotational semantics whose domains are untyped One can certainly do better for example employ user-defined datatypes for tagged values avoiding the ugly string-tagged VT",
          "hierarchy": "Control ExtensibleDS",
          "module": "Control.ExtensibleDS",
          "name": "ExtensibleDS",
          "package": "liboleg",
          "partial": "Extensible DS",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-ExtensibleDS.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.ExtensibleDS",
          "name": "Action",
          "package": "liboleg",
          "source": "src/Control-ExtensibleDS.html#Action",
          "type": "type"
        },
        "index": {
          "hierarchy": "Control ExtensibleDS",
          "module": "Control.ExtensibleDS",
          "name": "Action",
          "package": "liboleg",
          "partial": "Action",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-ExtensibleDS.html#t:Action"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.ExtensibleDS",
          "name": "Add1",
          "package": "liboleg",
          "source": "src/Control-ExtensibleDS.html#Add1",
          "type": "data"
        },
        "index": {
          "hierarchy": "Control ExtensibleDS",
          "module": "Control.ExtensibleDS",
          "name": "Add1",
          "package": "liboleg",
          "partial": "Add",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-ExtensibleDS.html#t:Add1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.ExtensibleDS",
          "name": "App",
          "package": "liboleg",
          "source": "src/Control-ExtensibleDS.html#App",
          "type": "data"
        },
        "index": {
          "hierarchy": "Control ExtensibleDS",
          "module": "Control.ExtensibleDS",
          "name": "App",
          "package": "liboleg",
          "partial": "App",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-ExtensibleDS.html#t:App"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe base language has only two expressions: omega and error\n See Fig. 3 (p. 7) of EDLS\n\u003c/p\u003e",
          "module": "Control.ExtensibleDS",
          "name": "BE_err",
          "package": "liboleg",
          "source": "src/Control-ExtensibleDS.html#BE_err",
          "type": "data"
        },
        "index": {
          "description": "The base language has only two expressions omega and error See Fig of EDLS",
          "hierarchy": "Control ExtensibleDS",
          "module": "Control.ExtensibleDS",
          "name": "BE_err",
          "package": "liboleg",
          "partial": "BE",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-ExtensibleDS.html#t:BE_err"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.ExtensibleDS",
          "name": "BE_omega",
          "package": "liboleg",
          "source": "src/Control-ExtensibleDS.html#BE_omega",
          "type": "data"
        },
        "index": {
          "hierarchy": "Control ExtensibleDS",
          "module": "Control.ExtensibleDS",
          "name": "BE_omega",
          "package": "liboleg",
          "partial": "BE",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-ExtensibleDS.html#t:BE_omega"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eComputations: just like in EDLS\n The strictness of inV guarantees that inV bottom = bottom, as\n on Fig. 3 of EDLS\n Error is always a part of the computation\n\u003c/p\u003e",
          "module": "Control.ExtensibleDS",
          "name": "Comp",
          "package": "liboleg",
          "source": "src/Control-ExtensibleDS.html#Comp",
          "type": "data"
        },
        "index": {
          "description": "Computations just like in EDLS The strictness of inV guarantees that inV bottom bottom as on Fig of EDLS Error is always part of the computation",
          "hierarchy": "Control ExtensibleDS",
          "module": "Control.ExtensibleDS",
          "name": "Comp",
          "package": "liboleg",
          "partial": "Comp",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-ExtensibleDS.html#t:Comp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.ExtensibleDS",
          "name": "Control",
          "package": "liboleg",
          "source": "src/Control-ExtensibleDS.html#Control",
          "type": "data"
        },
        "index": {
          "hierarchy": "Control ExtensibleDS",
          "module": "Control.ExtensibleDS",
          "name": "Control",
          "package": "liboleg",
          "partial": "Control",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-ExtensibleDS.html#t:Control"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.ExtensibleDS",
          "name": "ControlAdmin",
          "package": "liboleg",
          "source": "src/Control-ExtensibleDS.html#ControlAdmin",
          "type": "data"
        },
        "index": {
          "hierarchy": "Control ExtensibleDS",
          "module": "Control.ExtensibleDS",
          "name": "ControlAdmin",
          "package": "liboleg",
          "partial": "Control Admin",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-ExtensibleDS.html#t:ControlAdmin"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.ExtensibleDS",
          "name": "Deref",
          "package": "liboleg",
          "source": "src/Control-ExtensibleDS.html#Deref",
          "type": "data"
        },
        "index": {
          "hierarchy": "Control ExtensibleDS",
          "module": "Control.ExtensibleDS",
          "name": "Deref",
          "package": "liboleg",
          "partial": "Deref",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-ExtensibleDS.html#t:Deref"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.ExtensibleDS",
          "name": "Env",
          "package": "liboleg",
          "source": "src/Control-ExtensibleDS.html#Env",
          "type": "type"
        },
        "index": {
          "hierarchy": "Control ExtensibleDS",
          "module": "Control.ExtensibleDS",
          "name": "Env",
          "package": "liboleg",
          "partial": "Env",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-ExtensibleDS.html#t:Env"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.ExtensibleDS",
          "name": "IntC",
          "package": "liboleg",
          "source": "src/Control-ExtensibleDS.html#IntC",
          "type": "data"
        },
        "index": {
          "hierarchy": "Control ExtensibleDS",
          "module": "Control.ExtensibleDS",
          "name": "IntC",
          "package": "liboleg",
          "partial": "Int",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-ExtensibleDS.html#t:IntC"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eNote that inV is essentially the identity \u003ccode\u003epartial\u003c/code\u003e continuation\n\u003c/p\u003e\u003cp\u003eThe error \u003ccode\u003eraise\u003c/code\u003e action and its tag\n\u003c/p\u003e\u003cp\u003eThe universal handler of actions\n It propagates the action request InFX up.\n Since we do case-analysis on the first argument, v, the handler\n is strict in that argument. That is, handler bottom ==\u003e bottom,\n as required by Fig. 3 of EDLS.\n The last clause is essentially the denotation of a `control channel'\n\u003c/p\u003e\u003cp\u003eExpressions and their interpretations\n This is an open data type and an open function. Haskell typeclasses\n are ideal for that.\n\u003c/p\u003e\u003cp\u003eThis is the function curlyM of EDLS\n\u003c/p\u003e",
          "module": "Control.ExtensibleDS",
          "name": "Interpretor",
          "package": "liboleg",
          "source": "src/Control-ExtensibleDS.html#Interpretor",
          "type": "class"
        },
        "index": {
          "description": "Note that inV is essentially the identity partial continuation The error raise action and its tag The universal handler of actions It propagates the action request InFX up Since we do case-analysis on the first argument the handler is strict in that argument That is handler bottom bottom as required by Fig of EDLS The last clause is essentially the denotation of control channel Expressions and their interpretations This is an open data type and an open function Haskell typeclasses are ideal for that This is the function curlyM of EDLS",
          "hierarchy": "Control ExtensibleDS",
          "module": "Control.ExtensibleDS",
          "name": "Interpretor",
          "package": "liboleg",
          "partial": "Interpretor",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-ExtensibleDS.html#t:Interpretor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.ExtensibleDS",
          "name": "Lam",
          "package": "liboleg",
          "source": "src/Control-ExtensibleDS.html#Lam",
          "type": "data"
        },
        "index": {
          "hierarchy": "Control ExtensibleDS",
          "module": "Control.ExtensibleDS",
          "name": "Lam",
          "package": "liboleg",
          "partial": "Lam",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-ExtensibleDS.html#t:Lam"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExtension: State: see Fig. 5 of EDLS \n\u003c/p\u003e",
          "module": "Control.ExtensibleDS",
          "name": "Loc",
          "package": "liboleg",
          "source": "src/Control-ExtensibleDS.html#Loc",
          "type": "newtype"
        },
        "index": {
          "description": "Extension State see Fig of EDLS",
          "hierarchy": "Control ExtensibleDS",
          "module": "Control.ExtensibleDS",
          "name": "Loc",
          "package": "liboleg",
          "partial": "Loc",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-ExtensibleDS.html#t:Loc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.ExtensibleDS",
          "name": "PL",
          "package": "liboleg",
          "source": "src/Control-ExtensibleDS.html#PL",
          "type": "class"
        },
        "index": {
          "hierarchy": "Control ExtensibleDS",
          "module": "Control.ExtensibleDS",
          "name": "PL",
          "package": "liboleg",
          "partial": "PL",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-ExtensibleDS.html#t:PL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExtension: Arithmetic: see a part Fig. 4 of EDLS \n\u003c/p\u003e",
          "module": "Control.ExtensibleDS",
          "name": "PN",
          "package": "liboleg",
          "source": "src/Control-ExtensibleDS.html#PN",
          "type": "class"
        },
        "index": {
          "description": "Extension Arithmetic see part Fig of EDLS",
          "hierarchy": "Control ExtensibleDS",
          "module": "Control.ExtensibleDS",
          "name": "PN",
          "package": "liboleg",
          "partial": "PN",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-ExtensibleDS.html#t:PN"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.ExtensibleDS",
          "name": "PV",
          "package": "liboleg",
          "source": "src/Control-ExtensibleDS.html#PV",
          "type": "class"
        },
        "index": {
          "hierarchy": "Control ExtensibleDS",
          "module": "Control.ExtensibleDS",
          "name": "PV",
          "package": "liboleg",
          "partial": "PV",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-ExtensibleDS.html#t:PV"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe meaning of a program\n\u003c/p\u003e\u003cp\u003eExtension: Call-by-Value: see a part Fig. 4 of EDLS (or, Fig. 8)\n\u003c/p\u003e\u003cp\u003eWe add closures (procedures) to the Base\n\u003c/p\u003e",
          "module": "Control.ExtensibleDS",
          "name": "Proc",
          "package": "liboleg",
          "source": "src/Control-ExtensibleDS.html#Proc",
          "type": "type"
        },
        "index": {
          "description": "The meaning of program Extension Call-by-Value see part Fig of EDLS or Fig We add closures procedures to the Base",
          "hierarchy": "Control ExtensibleDS",
          "module": "Control.ExtensibleDS",
          "name": "Proc",
          "package": "liboleg",
          "partial": "Proc",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-ExtensibleDS.html#t:Proc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003enew expressions\n\u003c/p\u003e",
          "module": "Control.ExtensibleDS",
          "name": "Ref",
          "package": "liboleg",
          "source": "src/Control-ExtensibleDS.html#Ref",
          "type": "data"
        },
        "index": {
          "description": "new expressions",
          "hierarchy": "Control ExtensibleDS",
          "module": "Control.ExtensibleDS",
          "name": "Ref",
          "package": "liboleg",
          "partial": "Ref",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-ExtensibleDS.html#t:Ref"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.ExtensibleDS",
          "name": "Set",
          "package": "liboleg",
          "source": "src/Control-ExtensibleDS.html#Set",
          "type": "data"
        },
        "index": {
          "hierarchy": "Control ExtensibleDS",
          "module": "Control.ExtensibleDS",
          "name": "Set",
          "package": "liboleg",
          "partial": "Set",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-ExtensibleDS.html#t:Set"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ea better idea is Loc -\u003e Maybe Value, so that when lookup fails,\n we can re-throw that Deref or Set message. That would make the\n storage extensible...\n The first component of the pair is the allocation counter\n\u003c/p\u003e",
          "module": "Control.ExtensibleDS",
          "name": "Sto",
          "package": "liboleg",
          "source": "src/Control-ExtensibleDS.html#Sto",
          "type": "type"
        },
        "index": {
          "description": "better idea is Loc Maybe Value so that when lookup fails we can re-throw that Deref or Set message That would make the storage extensible The first component of the pair is the allocation counter",
          "hierarchy": "Control ExtensibleDS",
          "module": "Control.ExtensibleDS",
          "name": "Sto",
          "package": "liboleg",
          "partial": "Sto",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-ExtensibleDS.html#t:Sto"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eNow we need a storage admin\n It is treated as an expression in the source language!\n\u003c/p\u003e",
          "module": "Control.ExtensibleDS",
          "name": "StoAdmin",
          "package": "liboleg",
          "source": "src/Control-ExtensibleDS.html#StoAdmin",
          "type": "data"
        },
        "index": {
          "description": "Now we need storage admin It is treated as an expression in the source language",
          "hierarchy": "Control ExtensibleDS",
          "module": "Control.ExtensibleDS",
          "name": "StoAdmin",
          "package": "liboleg",
          "partial": "Sto Admin",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-ExtensibleDS.html#t:StoAdmin"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.ExtensibleDS",
          "name": "Tag",
          "package": "liboleg",
          "source": "src/Control-ExtensibleDS.html#Tag",
          "type": "type"
        },
        "index": {
          "hierarchy": "Control ExtensibleDS",
          "module": "Control.ExtensibleDS",
          "name": "Tag",
          "package": "liboleg",
          "partial": "Tag",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-ExtensibleDS.html#t:Tag"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAuxiliary functions\n\u003c/p\u003e",
          "module": "Control.ExtensibleDS",
          "name": "V",
          "package": "liboleg",
          "source": "src/Control-ExtensibleDS.html#V",
          "type": "newtype"
        },
        "index": {
          "description": "Auxiliary functions",
          "hierarchy": "Control ExtensibleDS",
          "module": "Control.ExtensibleDS",
          "name": "V",
          "package": "liboleg",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-ExtensibleDS.html#t:V"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe universal domain\n Yes, it is untyped... But Denot semantics is like this anyway...\n Bottom is the implicit member of this domain.\n\u003c/p\u003e",
          "module": "Control.ExtensibleDS",
          "name": "Value",
          "package": "liboleg",
          "source": "src/Control-ExtensibleDS.html#Value",
          "type": "data"
        },
        "index": {
          "description": "The universal domain Yes it is untyped But Denot semantics is like this anyway Bottom is the implicit member of this domain",
          "hierarchy": "Control ExtensibleDS",
          "module": "Control.ExtensibleDS",
          "name": "Value",
          "package": "liboleg",
          "partial": "Value",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-ExtensibleDS.html#t:Value"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.ExtensibleDS",
          "name": "Var",
          "package": "liboleg",
          "source": "src/Control-ExtensibleDS.html#Var",
          "type": "type"
        },
        "index": {
          "hierarchy": "Control ExtensibleDS",
          "module": "Control.ExtensibleDS",
          "name": "Var",
          "package": "liboleg",
          "partial": "Var",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-ExtensibleDS.html#t:Var"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.ExtensibleDS",
          "name": ":@",
          "package": "liboleg",
          "signature": "e1 :@ e2",
          "source": "src/Control-ExtensibleDS.html#App",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control ExtensibleDS",
          "module": "Control.ExtensibleDS",
          "name": ":@",
          "package": "liboleg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-ExtensibleDS.html#v::-64-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.ExtensibleDS",
          "name": "Add1",
          "package": "liboleg",
          "signature": "Add1",
          "source": "src/Control-ExtensibleDS.html#Add1",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control ExtensibleDS",
          "module": "Control.ExtensibleDS",
          "name": "Add1",
          "package": "liboleg",
          "partial": "Add",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-ExtensibleDS.html#v:Add1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.ExtensibleDS",
          "name": "BE_err",
          "package": "liboleg",
          "signature": "BE_err",
          "source": "src/Control-ExtensibleDS.html#BE_err",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control ExtensibleDS",
          "module": "Control.ExtensibleDS",
          "name": "BE_err",
          "package": "liboleg",
          "partial": "BE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-ExtensibleDS.html#v:BE_err"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.ExtensibleDS",
          "name": "BE_omega",
          "package": "liboleg",
          "signature": "BE_omega",
          "source": "src/Control-ExtensibleDS.html#BE_omega",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control ExtensibleDS",
          "module": "Control.ExtensibleDS",
          "name": "BE_omega",
          "package": "liboleg",
          "partial": "BE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-ExtensibleDS.html#v:BE_omega"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.ExtensibleDS",
          "name": "Control",
          "package": "liboleg",
          "signature": "Control e",
          "source": "src/Control-ExtensibleDS.html#Control",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control ExtensibleDS",
          "module": "Control.ExtensibleDS",
          "name": "Control",
          "package": "liboleg",
          "partial": "Control",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-ExtensibleDS.html#v:Control"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.ExtensibleDS",
          "name": "ControlAdmin",
          "package": "liboleg",
          "signature": "ControlAdmin e",
          "source": "src/Control-ExtensibleDS.html#ControlAdmin",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control ExtensibleDS",
          "module": "Control.ExtensibleDS",
          "name": "ControlAdmin",
          "package": "liboleg",
          "partial": "Control Admin",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-ExtensibleDS.html#v:ControlAdmin"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.ExtensibleDS",
          "name": "Deref",
          "package": "liboleg",
          "signature": "Deref e",
          "source": "src/Control-ExtensibleDS.html#Deref",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control ExtensibleDS",
          "module": "Control.ExtensibleDS",
          "name": "Deref",
          "package": "liboleg",
          "partial": "Deref",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-ExtensibleDS.html#v:Deref"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.ExtensibleDS",
          "name": "InFX",
          "package": "liboleg",
          "signature": "InFX (Value -\u003e Comp) Action",
          "source": "src/Control-ExtensibleDS.html#Comp",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control ExtensibleDS",
          "module": "Control.ExtensibleDS",
          "name": "InFX",
          "normalized": "InFX(Value-\u003eComp)Action",
          "package": "liboleg",
          "partial": "In FX",
          "signature": "InFX(Value-\u003eComp)Action",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-ExtensibleDS.html#v:InFX"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.ExtensibleDS",
          "name": "InV",
          "package": "liboleg",
          "signature": "InV !Value",
          "source": "src/Control-ExtensibleDS.html#Comp",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control ExtensibleDS",
          "module": "Control.ExtensibleDS",
          "name": "InV",
          "package": "liboleg",
          "partial": "In",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-ExtensibleDS.html#v:InV"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.ExtensibleDS",
          "name": "IntC",
          "package": "liboleg",
          "signature": "IntC Int",
          "source": "src/Control-ExtensibleDS.html#IntC",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control ExtensibleDS",
          "module": "Control.ExtensibleDS",
          "name": "IntC",
          "package": "liboleg",
          "partial": "Int",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-ExtensibleDS.html#v:IntC"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.ExtensibleDS",
          "name": "Lam",
          "package": "liboleg",
          "signature": "Lam V e",
          "source": "src/Control-ExtensibleDS.html#Lam",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control ExtensibleDS",
          "module": "Control.ExtensibleDS",
          "name": "Lam",
          "package": "liboleg",
          "partial": "Lam",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-ExtensibleDS.html#v:Lam"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.ExtensibleDS",
          "name": "Loc",
          "package": "liboleg",
          "signature": "Loc Int",
          "source": "src/Control-ExtensibleDS.html#Loc",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control ExtensibleDS",
          "module": "Control.ExtensibleDS",
          "name": "Loc",
          "package": "liboleg",
          "partial": "Loc",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-ExtensibleDS.html#v:Loc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.ExtensibleDS",
          "name": "Ref",
          "package": "liboleg",
          "signature": "Ref e",
          "source": "src/Control-ExtensibleDS.html#Ref",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control ExtensibleDS",
          "module": "Control.ExtensibleDS",
          "name": "Ref",
          "package": "liboleg",
          "partial": "Ref",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-ExtensibleDS.html#v:Ref"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.ExtensibleDS",
          "name": "Set",
          "package": "liboleg",
          "signature": "Set e1 e2",
          "source": "src/Control-ExtensibleDS.html#Set",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control ExtensibleDS",
          "module": "Control.ExtensibleDS",
          "name": "Set",
          "package": "liboleg",
          "partial": "Set",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-ExtensibleDS.html#v:Set"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.ExtensibleDS",
          "name": "StoAdmin",
          "package": "liboleg",
          "signature": "StoAdmin Sto e",
          "source": "src/Control-ExtensibleDS.html#StoAdmin",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control ExtensibleDS",
          "module": "Control.ExtensibleDS",
          "name": "StoAdmin",
          "package": "liboleg",
          "partial": "Sto Admin",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-ExtensibleDS.html#v:StoAdmin"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.ExtensibleDS",
          "name": "V",
          "package": "liboleg",
          "signature": "V String",
          "source": "src/Control-ExtensibleDS.html#V",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control ExtensibleDS",
          "module": "Control.ExtensibleDS",
          "name": "V",
          "package": "liboleg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-ExtensibleDS.html#v:V"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.ExtensibleDS",
          "name": "VF",
          "package": "liboleg",
          "signature": "VF (Value -\u003e Value)",
          "source": "src/Control-ExtensibleDS.html#Value",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control ExtensibleDS",
          "module": "Control.ExtensibleDS",
          "name": "VF",
          "normalized": "VF(Value-\u003eValue)",
          "package": "liboleg",
          "partial": "VF",
          "signature": "VF(Value-\u003eValue)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-ExtensibleDS.html#v:VF"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.ExtensibleDS",
          "name": "VI",
          "package": "liboleg",
          "signature": "VI Int",
          "source": "src/Control-ExtensibleDS.html#Value",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control ExtensibleDS",
          "module": "Control.ExtensibleDS",
          "name": "VI",
          "package": "liboleg",
          "partial": "VI",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-ExtensibleDS.html#v:VI"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.ExtensibleDS",
          "name": "VP",
          "package": "liboleg",
          "signature": "VP Value Value",
          "source": "src/Control-ExtensibleDS.html#Value",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control ExtensibleDS",
          "module": "Control.ExtensibleDS",
          "name": "VP",
          "package": "liboleg",
          "partial": "VP",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-ExtensibleDS.html#v:VP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.ExtensibleDS",
          "name": "VS",
          "package": "liboleg",
          "signature": "VS String",
          "source": "src/Control-ExtensibleDS.html#Value",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control ExtensibleDS",
          "module": "Control.ExtensibleDS",
          "name": "VS",
          "package": "liboleg",
          "partial": "VS",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-ExtensibleDS.html#v:VS"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.ExtensibleDS",
          "name": "VT",
          "package": "liboleg",
          "signature": "VT Tag Value",
          "source": "src/Control-ExtensibleDS.html#Value",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control ExtensibleDS",
          "module": "Control.ExtensibleDS",
          "name": "VT",
          "package": "liboleg",
          "partial": "VT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-ExtensibleDS.html#v:VT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDenotations of the new actions (inj\u003cem\u003eproj to\u003c/em\u003efrom the Universal Domain)\n\u003c/p\u003e\u003cp\u003einject and project computations\n\u003c/p\u003e",
          "module": "Control.ExtensibleDS",
          "name": "inComp",
          "package": "liboleg",
          "signature": "Comp -\u003e Value",
          "source": "src/Control-ExtensibleDS.html#inComp",
          "type": "function"
        },
        "index": {
          "description": "Denotations of the new actions inj proj to from the Universal Domain inject and project computations",
          "hierarchy": "Control ExtensibleDS",
          "module": "Control.ExtensibleDS",
          "name": "inComp",
          "normalized": "Comp-\u003eValue",
          "package": "liboleg",
          "partial": "Comp",
          "signature": "Comp-\u003eValue",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-ExtensibleDS.html#v:inComp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.ExtensibleDS",
          "name": "inControl",
          "package": "liboleg",
          "signature": "(Value -\u003e Comp) -\u003e Value",
          "source": "src/Control-ExtensibleDS.html#inControl",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control ExtensibleDS",
          "module": "Control.ExtensibleDS",
          "name": "inControl",
          "normalized": "(Value-\u003eComp)-\u003eValue",
          "package": "liboleg",
          "partial": "Control",
          "signature": "(Value-\u003eComp)-\u003eValue",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-ExtensibleDS.html#v:inControl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.ExtensibleDS",
          "name": "inL",
          "package": "liboleg",
          "signature": "Loc -\u003e u",
          "source": "src/Control-ExtensibleDS.html#inL",
          "type": "method"
        },
        "index": {
          "hierarchy": "Control ExtensibleDS",
          "module": "Control.ExtensibleDS",
          "name": "inL",
          "normalized": "Loc-\u003ea",
          "package": "liboleg",
          "signature": "Loc-\u003eu",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-ExtensibleDS.html#v:inL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.ExtensibleDS",
          "name": "inN",
          "package": "liboleg",
          "signature": "Int -\u003e u",
          "source": "src/Control-ExtensibleDS.html#inN",
          "type": "method"
        },
        "index": {
          "hierarchy": "Control ExtensibleDS",
          "module": "Control.ExtensibleDS",
          "name": "inN",
          "normalized": "Int-\u003ea",
          "package": "liboleg",
          "signature": "Int-\u003eu",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-ExtensibleDS.html#v:inN"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.ExtensibleDS",
          "name": "inP",
          "package": "liboleg",
          "signature": "Proc -\u003e u",
          "source": "src/Control-ExtensibleDS.html#inP",
          "type": "method"
        },
        "index": {
          "hierarchy": "Control ExtensibleDS",
          "module": "Control.ExtensibleDS",
          "name": "inP",
          "normalized": "Proc-\u003ea",
          "package": "liboleg",
          "signature": "Proc-\u003eu",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-ExtensibleDS.html#v:inP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.ExtensibleDS",
          "name": "inSto",
          "package": "liboleg",
          "signature": "Sto -\u003e Value",
          "source": "src/Control-ExtensibleDS.html#inSto",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control ExtensibleDS",
          "module": "Control.ExtensibleDS",
          "name": "inSto",
          "normalized": "Sto-\u003eValue",
          "package": "liboleg",
          "partial": "Sto",
          "signature": "Sto-\u003eValue",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-ExtensibleDS.html#v:inSto"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.ExtensibleDS",
          "name": "init_sto",
          "package": "liboleg",
          "signature": "Sto",
          "source": "src/Control-ExtensibleDS.html#init_sto",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control ExtensibleDS",
          "module": "Control.ExtensibleDS",
          "name": "init_sto",
          "package": "liboleg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-ExtensibleDS.html#v:init_sto"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.ExtensibleDS",
          "name": "interpret",
          "package": "liboleg",
          "signature": "exp -\u003e Env Value -\u003e Comp",
          "source": "src/Control-ExtensibleDS.html#interpret",
          "type": "method"
        },
        "index": {
          "hierarchy": "Control ExtensibleDS",
          "module": "Control.ExtensibleDS",
          "name": "interpret",
          "normalized": "a-\u003eEnv Value-\u003eComp",
          "package": "liboleg",
          "signature": "exp-\u003eEnv Value-\u003eComp",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-ExtensibleDS.html#v:interpret"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.ExtensibleDS",
          "name": "prComp",
          "package": "liboleg",
          "signature": "Value -\u003e Maybe Comp",
          "source": "src/Control-ExtensibleDS.html#prComp",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control ExtensibleDS",
          "module": "Control.ExtensibleDS",
          "name": "prComp",
          "normalized": "Value-\u003eMaybe Comp",
          "package": "liboleg",
          "partial": "Comp",
          "signature": "Value-\u003eMaybe Comp",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-ExtensibleDS.html#v:prComp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.ExtensibleDS",
          "name": "prControl",
          "package": "liboleg",
          "signature": "Value -\u003e Maybe (Value -\u003e Comp)",
          "source": "src/Control-ExtensibleDS.html#prControl",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control ExtensibleDS",
          "module": "Control.ExtensibleDS",
          "name": "prControl",
          "normalized": "Value-\u003eMaybe(Value-\u003eComp)",
          "package": "liboleg",
          "partial": "Control",
          "signature": "Value-\u003eMaybe(Value-\u003eComp)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-ExtensibleDS.html#v:prControl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.ExtensibleDS",
          "name": "prL",
          "package": "liboleg",
          "signature": "u -\u003e Maybe Loc",
          "source": "src/Control-ExtensibleDS.html#prL",
          "type": "method"
        },
        "index": {
          "hierarchy": "Control ExtensibleDS",
          "module": "Control.ExtensibleDS",
          "name": "prL",
          "normalized": "a-\u003eMaybe Loc",
          "package": "liboleg",
          "signature": "u-\u003eMaybe Loc",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-ExtensibleDS.html#v:prL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.ExtensibleDS",
          "name": "prN",
          "package": "liboleg",
          "signature": "u -\u003e Maybe Int",
          "source": "src/Control-ExtensibleDS.html#prN",
          "type": "method"
        },
        "index": {
          "hierarchy": "Control ExtensibleDS",
          "module": "Control.ExtensibleDS",
          "name": "prN",
          "normalized": "a-\u003eMaybe Int",
          "package": "liboleg",
          "signature": "u-\u003eMaybe Int",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-ExtensibleDS.html#v:prN"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.ExtensibleDS",
          "name": "prP",
          "package": "liboleg",
          "signature": "u -\u003e Maybe Proc",
          "source": "src/Control-ExtensibleDS.html#prP",
          "type": "method"
        },
        "index": {
          "hierarchy": "Control ExtensibleDS",
          "module": "Control.ExtensibleDS",
          "name": "prP",
          "normalized": "a-\u003eMaybe Proc",
          "package": "liboleg",
          "signature": "u-\u003eMaybe Proc",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-ExtensibleDS.html#v:prP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.ExtensibleDS",
          "name": "prSto",
          "package": "liboleg",
          "signature": "Value -\u003e Maybe Sto",
          "source": "src/Control-ExtensibleDS.html#prSto",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control ExtensibleDS",
          "module": "Control.ExtensibleDS",
          "name": "prSto",
          "normalized": "Value-\u003eMaybe Sto",
          "package": "liboleg",
          "partial": "Sto",
          "signature": "Value-\u003eMaybe Sto",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-ExtensibleDS.html#v:prSto"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.ExtensibleDS",
          "name": "vf",
          "package": "liboleg",
          "signature": "Var",
          "source": "src/Control-ExtensibleDS.html#vf",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control ExtensibleDS",
          "module": "Control.ExtensibleDS",
          "name": "vf",
          "package": "liboleg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-ExtensibleDS.html#v:vf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.ExtensibleDS",
          "name": "vr",
          "package": "liboleg",
          "signature": "Var",
          "source": "src/Control-ExtensibleDS.html#vr",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control ExtensibleDS",
          "module": "Control.ExtensibleDS",
          "name": "vr",
          "package": "liboleg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-ExtensibleDS.html#v:vr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.ExtensibleDS",
          "name": "vx",
          "package": "liboleg",
          "signature": "Var",
          "source": "src/Control-ExtensibleDS.html#vx",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control ExtensibleDS",
          "module": "Control.ExtensibleDS",
          "name": "vx",
          "package": "liboleg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-ExtensibleDS.html#v:vx"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreate a few variables for use in examples\n\u003c/p\u003e",
          "module": "Control.ExtensibleDS",
          "name": "vy",
          "package": "liboleg",
          "signature": "Var",
          "source": "src/Control-ExtensibleDS.html#vy",
          "type": "function"
        },
        "index": {
          "description": "Create few variables for use in examples",
          "hierarchy": "Control ExtensibleDS",
          "module": "Control.ExtensibleDS",
          "name": "vy",
          "package": "liboleg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-ExtensibleDS.html#v:vy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eGenerators in Haskell\n\u003c/p\u003e\u003cp\u003eWe translate the in-order tree traversal example from an old article\n   Generators in Icon, Python, and Scheme, 2004.\n\u003c/p\u003e\u003cp\u003e\u003ca\u003ehttp://okmij.org/ftp/Scheme/enumerators-callcc.html#Generators\u003c/a\u003e\n\u003c/p\u003e\u003cp\u003eusing Haskell and delimited continuations rather than call/cc + mutation.\n The code is shorter, and it even types.\n To be honest, we actually translate the OCaml code generator.ml\n\u003c/p\u003e\u003cp\u003eIn this code, we use a single global prompt (that is, ordinary shift0)\n Generator2.hs shows the need for several prompts.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Control.Generator1",
          "name": "Generator1",
          "package": "liboleg",
          "source": "src/Control-Generator1.html",
          "type": "module"
        },
        "index": {
          "description": "Generators in Haskell We translate the in-order tree traversal example from an old article Generators in Icon Python and Scheme http okmij.org ftp Scheme enumerators-callcc.html Generators using Haskell and delimited continuations rather than call cc mutation The code is shorter and it even types To be honest we actually translate the OCaml code generator.ml In this code we use single global prompt that is ordinary shift0 Generator2.hs shows the need for several prompts",
          "hierarchy": "Control Generator1",
          "module": "Control.Generator1",
          "name": "Generator1",
          "package": "liboleg",
          "partial": "Generator",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-Generator1.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA few preliminaries: define the tree and build a sample tree\n\u003c/p\u003e",
          "module": "Control.Generator1",
          "name": "Label",
          "package": "liboleg",
          "source": "src/Control-Generator1.html#Label",
          "type": "type"
        },
        "index": {
          "description": "few preliminaries define the tree and build sample tree",
          "hierarchy": "Control Generator1",
          "module": "Control.Generator1",
          "name": "Label",
          "package": "liboleg",
          "partial": "Label",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-Generator1.html#t:Label"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIn Python, \u003ccode\u003e\u003ca\u003eyield\u003c/a\u003e\u003c/code\u003e is a keyword. In Haskell, it is a regular function.\n Furthermore, it is a user-defined function, in one line of code.\n To get generators there is no need to extend a language.\n\u003c/p\u003e",
          "module": "Control.Generator1",
          "name": "P",
          "package": "liboleg",
          "source": "src/Control-Generator1.html#P",
          "type": "type"
        },
        "index": {
          "description": "In Python yield is keyword In Haskell it is regular function Furthermore it is user-defined function in one line of code To get generators there is no need to extend language",
          "hierarchy": "Control Generator1",
          "module": "Control.Generator1",
          "name": "P",
          "package": "liboleg",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-Generator1.html#t:P"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Generator1",
          "name": "Res",
          "package": "liboleg",
          "source": "src/Control-Generator1.html#Res",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "Control Generator1",
          "module": "Control.Generator1",
          "name": "Res",
          "package": "liboleg",
          "partial": "Res",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-Generator1.html#t:Res"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Generator1",
          "name": "Tree",
          "package": "liboleg",
          "source": "src/Control-Generator1.html#Tree",
          "type": "data"
        },
        "index": {
          "hierarchy": "Control Generator1",
          "module": "Control.Generator1",
          "name": "Tree",
          "package": "liboleg",
          "partial": "Tree",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-Generator1.html#t:Tree"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Generator1",
          "name": "Leaf",
          "package": "liboleg",
          "signature": "Leaf",
          "source": "src/Control-Generator1.html#Tree",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Generator1",
          "module": "Control.Generator1",
          "name": "Leaf",
          "package": "liboleg",
          "partial": "Leaf",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-Generator1.html#v:Leaf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Generator1",
          "name": "Node",
          "package": "liboleg",
          "signature": "Node Label Tree Tree",
          "source": "src/Control-Generator1.html#Tree",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Generator1",
          "module": "Control.Generator1",
          "name": "Node",
          "package": "liboleg",
          "partial": "Node",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-Generator1.html#v:Node"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Generator1",
          "name": "Res",
          "package": "liboleg",
          "signature": "Res ((a -\u003e CC (P m a) m ()) -\u003e CC (P m a) m ())",
          "source": "src/Control-Generator1.html#Res",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Generator1",
          "module": "Control.Generator1",
          "name": "Res",
          "normalized": "Res((a-\u003eCC(P b a)b())-\u003eCC(P b a)b())",
          "package": "liboleg",
          "partial": "Res",
          "signature": "Res((a-\u003eCC(P m a)m())-\u003eCC(P m a)m())",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-Generator1.html#v:Res"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe enumerator: the for-loop essentially\n\u003c/p\u003e\u003cp\u003eThe in_order function itself: compare with the Python version\n\u003c/p\u003e",
          "module": "Control.Generator1",
          "name": "in_order",
          "package": "liboleg",
          "signature": "Tree -\u003e CC (P m Label) m ()",
          "source": "src/Control-Generator1.html#in_order",
          "type": "function"
        },
        "index": {
          "description": "The enumerator the for-loop essentially The in order function itself compare with the Python version",
          "hierarchy": "Control Generator1",
          "module": "Control.Generator1",
          "name": "in_order",
          "normalized": "Tree-\u003eCC(P a Label)a()",
          "package": "liboleg",
          "signature": "Tree-\u003eCC(P m Label)m()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-Generator1.html#v:in_order"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Generator1",
          "name": "make_full_tree",
          "package": "liboleg",
          "signature": "Int -\u003e Tree",
          "source": "src/Control-Generator1.html#make_full_tree",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Generator1",
          "module": "Control.Generator1",
          "name": "make_full_tree",
          "normalized": "Int-\u003eTree",
          "package": "liboleg",
          "signature": "Int-\u003eTree",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-Generator1.html#v:make_full_tree"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePrint out the result of the in-order traversal\n\u003c/p\u003e",
          "module": "Control.Generator1",
          "name": "test_io",
          "package": "liboleg",
          "signature": "IO ()",
          "source": "src/Control-Generator1.html#test_io",
          "type": "function"
        },
        "index": {
          "description": "Print out the result of the in-order traversal",
          "hierarchy": "Control Generator1",
          "module": "Control.Generator1",
          "name": "test_io",
          "normalized": "IO()",
          "package": "liboleg",
          "signature": "IO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-Generator1.html#v:test_io"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eOr return it as a pure list; the effects are encapsulated\n\u003c/p\u003e",
          "module": "Control.Generator1",
          "name": "test_st",
          "package": "liboleg",
          "signature": "[Label]",
          "source": "src/Control-Generator1.html#test_st",
          "type": "function"
        },
        "index": {
          "description": "Or return it as pure list the effects are encapsulated",
          "hierarchy": "Control Generator1",
          "module": "Control.Generator1",
          "name": "test_st",
          "normalized": "[Label]",
          "package": "liboleg",
          "signature": "[Label]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-Generator1.html#v:test_st"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Generator1",
          "name": "yield",
          "package": "liboleg",
          "signature": "a -\u003e CC (P m a) m ()",
          "source": "src/Control-Generator1.html#yield",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Generator1",
          "module": "Control.Generator1",
          "name": "yield",
          "normalized": "a-\u003eCC(P b a)b()",
          "package": "liboleg",
          "signature": "a-\u003eCC(P m a)m()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-Generator1.html#v:yield"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eGenerators in Haskell\n\u003c/p\u003e\u003cp\u003eWe translate the in-order tree traversal example from an old article\n   Generators in Icon, Python, and Scheme, 2004.\n\u003c/p\u003e\u003cpre\u003e http://okmij.org/ftp/Scheme/enumerators-callcc.html#Generators\n\u003c/pre\u003e\u003cp\u003eusing Haskell and delimited continuations rather than call/cc + mutation.\n The code is shorter, and it even types.\n To be honest, we actually translate the OCaml code generator.ml\n\u003c/p\u003e\u003cp\u003eThis code is the extension of Generator1.hs; we use delimited\n control not only to implement the generator. We also use delimited\n control to accumulate the results in a list. We need two different\n prompts then (with two different answer-types, as it happens).\n This file illustrates the prompt flavors PP and PM, using newtypes\n to define private global prompts (global prompts that are private to\n the current module).\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Control.Generator2",
          "name": "Generator2",
          "package": "liboleg",
          "source": "src/Control-Generator2.html",
          "type": "module"
        },
        "index": {
          "description": "Generators in Haskell We translate the in-order tree traversal example from an old article Generators in Icon Python and Scheme http okmij.org ftp Scheme enumerators-callcc.html Generators using Haskell and delimited continuations rather than call cc mutation The code is shorter and it even types To be honest we actually translate the OCaml code generator.ml This code is the extension of Generator1.hs we use delimited control not only to implement the generator We also use delimited control to accumulate the results in list We need two different prompts then with two different answer-types as it happens This file illustrates the prompt flavors PP and PM using newtypes to define private global prompts global prompts that are private to the current module",
          "hierarchy": "Control Generator2",
          "module": "Control.Generator2",
          "name": "Generator2",
          "package": "liboleg",
          "partial": "Generator",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-Generator2.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe second application of control: accumulating the results in a list\n\u003c/p\u003e\u003cp\u003eThe answer-type for the second prompt. We use newtype for identification\n\u003c/p\u003e",
          "module": "Control.Generator2",
          "name": "Acc",
          "package": "liboleg",
          "source": "src/Control-Generator2.html#Acc",
          "type": "newtype"
        },
        "index": {
          "description": "The second application of control accumulating the results in list The answer-type for the second prompt We use newtype for identification",
          "hierarchy": "Control Generator2",
          "module": "Control.Generator2",
          "name": "Acc",
          "package": "liboleg",
          "partial": "Acc",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-Generator2.html#t:Acc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTo avoid importing mtl, we define Identity on our own\n\u003c/p\u003e",
          "module": "Control.Generator2",
          "name": "Identity",
          "package": "liboleg",
          "source": "src/Control-Generator2.html#Identity",
          "type": "newtype"
        },
        "index": {
          "description": "To avoid importing mtl we define Identity on our own",
          "hierarchy": "Control Generator2",
          "module": "Control.Generator2",
          "name": "Identity",
          "package": "liboleg",
          "partial": "Identity",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-Generator2.html#t:Identity"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA few preliminaries: define the tree and build a sample tree\n\u003c/p\u003e",
          "module": "Control.Generator2",
          "name": "Label",
          "package": "liboleg",
          "source": "src/Control-Generator2.html#Label",
          "type": "type"
        },
        "index": {
          "description": "few preliminaries define the tree and build sample tree",
          "hierarchy": "Control Generator2",
          "module": "Control.Generator2",
          "name": "Label",
          "package": "liboleg",
          "partial": "Label",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-Generator2.html#t:Label"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUsing the prompt flavor PM\n\u003c/p\u003e\u003cp\u003eThe above code works. We can define the second pair of operators\n to accummulate the result into a list. Yet, the solution is\n not very satisfactory. We notice that the prompt type ppy is\n polymorphic over a, the elements we yield. What ensures that\n \u003ccode\u003e\u003ca\u003eyieldP\u003c/a\u003e\u003c/code\u003e yields elements of the same type that enumerateP can pass to the\n body of the loop? Nothing, actually, at compile time. If yieldP and\n enumerateP do not agree on the type of the elements, a run-time\n error will occur.\n This is where the PM prompt type comes in handy. It has a phantom\n type parameter c, which can be used to communicate between\n producers and consumers of the effect. We use the type parameter c\n to communicate the type of elements, between yield and enumerate.\n Since the parameter is phantom, it costs us nothing at run-time.\n\u003c/p\u003e\u003cp\u003eThe answer-type for one of the prompts\n\u003c/p\u003e",
          "module": "Control.Generator2",
          "name": "Res",
          "package": "liboleg",
          "source": "src/Control-Generator2.html#Res",
          "type": "newtype"
        },
        "index": {
          "description": "Using the prompt flavor PM The above code works We can define the second pair of operators to accummulate the result into list Yet the solution is not very satisfactory We notice that the prompt type ppy is polymorphic over the elements we yield What ensures that yieldP yields elements of the same type that enumerateP can pass to the body of the loop Nothing actually at compile time If yieldP and enumerateP do not agree on the type of the elements run-time error will occur This is where the PM prompt type comes in handy It has phantom type parameter which can be used to communicate between producers and consumers of the effect We use the type parameter to communicate the type of elements between yield and enumerate Since the parameter is phantom it costs us nothing at run-time The answer-type for one of the prompts",
          "hierarchy": "Control Generator2",
          "module": "Control.Generator2",
          "name": "Res",
          "package": "liboleg",
          "partial": "Res",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-Generator2.html#t:Res"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIn Python, \u003ccode\u003e\u003ca\u003eyield\u003c/a\u003e\u003c/code\u003e is a keyword. In Haskell, it is a regular function.\n Furthermore, it is a user-defined function, in one line of code.\n To get generators there is no need to extend a language.\n\u003c/p\u003e\u003cp\u003eFirst, we try the prompt flavor PP\n\u003c/p\u003e\u003cp\u003eThe answer-type for one of the prompts\n\u003c/p\u003e",
          "module": "Control.Generator2",
          "name": "ResP",
          "package": "liboleg",
          "source": "src/Control-Generator2.html#ResP",
          "type": "newtype"
        },
        "index": {
          "description": "In Python yield is keyword In Haskell it is regular function Furthermore it is user-defined function in one line of code To get generators there is no need to extend language First we try the prompt flavor PP The answer-type for one of the prompts",
          "hierarchy": "Control Generator2",
          "module": "Control.Generator2",
          "name": "ResP",
          "package": "liboleg",
          "partial": "Res",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-Generator2.html#t:ResP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Generator2",
          "name": "Tree",
          "package": "liboleg",
          "source": "src/Control-Generator2.html#Tree",
          "type": "data"
        },
        "index": {
          "hierarchy": "Control Generator2",
          "module": "Control.Generator2",
          "name": "Tree",
          "package": "liboleg",
          "partial": "Tree",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-Generator2.html#t:Tree"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Generator2",
          "name": "Acc",
          "package": "liboleg",
          "signature": "Acc [a]",
          "source": "src/Control-Generator2.html#Acc",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Generator2",
          "module": "Control.Generator2",
          "name": "Acc",
          "normalized": "Acc[a]",
          "package": "liboleg",
          "partial": "Acc",
          "signature": "Acc[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-Generator2.html#v:Acc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Generator2",
          "name": "Identity",
          "package": "liboleg",
          "signature": "Identity",
          "source": "src/Control-Generator2.html#Identity",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Generator2",
          "module": "Control.Generator2",
          "name": "Identity",
          "package": "liboleg",
          "partial": "Identity",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-Generator2.html#v:Identity"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Generator2",
          "name": "Leaf",
          "package": "liboleg",
          "signature": "Leaf",
          "source": "src/Control-Generator2.html#Tree",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Generator2",
          "module": "Control.Generator2",
          "name": "Leaf",
          "package": "liboleg",
          "partial": "Leaf",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-Generator2.html#v:Leaf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Generator2",
          "name": "Node",
          "package": "liboleg",
          "signature": "Node Label Tree Tree",
          "source": "src/Control-Generator2.html#Tree",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Generator2",
          "module": "Control.Generator2",
          "name": "Node",
          "package": "liboleg",
          "partial": "Node",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-Generator2.html#v:Node"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Generator2",
          "name": "Res",
          "package": "liboleg",
          "signature": "Res ((a -\u003e CC (PM a) m ()) -\u003e CC (PM a) m ())",
          "source": "src/Control-Generator2.html#Res",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Generator2",
          "module": "Control.Generator2",
          "name": "Res",
          "normalized": "Res((a-\u003eCC(PM a)b())-\u003eCC(PM a)b())",
          "package": "liboleg",
          "partial": "Res",
          "signature": "Res((a-\u003eCC(PM a)m())-\u003eCC(PM a)m())",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-Generator2.html#v:Res"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Generator2",
          "name": "ResP",
          "package": "liboleg",
          "signature": "ResP ((a -\u003e CC PP m ()) -\u003e CC PP m ())",
          "source": "src/Control-Generator2.html#ResP",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Generator2",
          "module": "Control.Generator2",
          "name": "ResP",
          "normalized": "ResP((a-\u003eCC PP b())-\u003eCC PP b())",
          "package": "liboleg",
          "partial": "Res",
          "signature": "ResP((a-\u003eCC PP m())-\u003eCC PP m())",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-Generator2.html#v:ResP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Generator2",
          "name": "acc",
          "package": "liboleg",
          "signature": "a -\u003e CC (PM a) m ()",
          "source": "src/Control-Generator2.html#acc",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Generator2",
          "module": "Control.Generator2",
          "name": "acc",
          "normalized": "a-\u003eCC(PM a)b()",
          "package": "liboleg",
          "signature": "a-\u003eCC(PM a)m()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-Generator2.html#v:acc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Generator2",
          "name": "accumulated",
          "package": "liboleg",
          "signature": "CC (PM a) m () -\u003e CC (PM a) m [a]",
          "source": "src/Control-Generator2.html#accumulated",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Generator2",
          "module": "Control.Generator2",
          "name": "accumulated",
          "normalized": "CC(PM a)b()-\u003eCC(PM a)b[a]",
          "package": "liboleg",
          "signature": "CC(PM a)m()-\u003eCC(PM a)m[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-Generator2.html#v:accumulated"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe enumerator: the for-loop essentially\n\u003c/p\u003e",
          "module": "Control.Generator2",
          "name": "enumerate",
          "package": "liboleg",
          "signature": "CC (PM a) m () -\u003e (a -\u003e CC (PM a) m ()) -\u003e CC (PM a) m ()",
          "source": "src/Control-Generator2.html#enumerate",
          "type": "function"
        },
        "index": {
          "description": "The enumerator the for-loop essentially",
          "hierarchy": "Control Generator2",
          "module": "Control.Generator2",
          "name": "enumerate",
          "normalized": "CC(PM a)b()-\u003e(a-\u003eCC(PM a)b())-\u003eCC(PM a)b()",
          "package": "liboleg",
          "signature": "CC(PM a)m()-\u003e(a-\u003eCC(PM a)m())-\u003eCC(PM a)m()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-Generator2.html#v:enumerate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe enumerator: the for-loop essentially\n\u003c/p\u003e",
          "module": "Control.Generator2",
          "name": "enumerateP",
          "package": "liboleg",
          "signature": "CC PP m () -\u003e (a -\u003e CC PP m ()) -\u003e CC PP m ()",
          "source": "src/Control-Generator2.html#enumerateP",
          "type": "function"
        },
        "index": {
          "description": "The enumerator the for-loop essentially",
          "hierarchy": "Control Generator2",
          "module": "Control.Generator2",
          "name": "enumerateP",
          "normalized": "CC PP a()-\u003e(b-\u003eCC PP a())-\u003eCC PP a()",
          "package": "liboleg",
          "signature": "CC PP m()-\u003e(a-\u003eCC PP m())-\u003eCC PP m()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-Generator2.html#v:enumerateP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe in_order function itself: compare with the Python version\n\u003c/p\u003e",
          "module": "Control.Generator2",
          "name": "in_order",
          "package": "liboleg",
          "signature": "Tree -\u003e CC (PM Label) m ()",
          "source": "src/Control-Generator2.html#in_order",
          "type": "function"
        },
        "index": {
          "description": "The in order function itself compare with the Python version",
          "hierarchy": "Control Generator2",
          "module": "Control.Generator2",
          "name": "in_order",
          "normalized": "Tree-\u003eCC(PM Label)a()",
          "package": "liboleg",
          "signature": "Tree-\u003eCC(PM Label)m()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-Generator2.html#v:in_order"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe in_order function itself: compare with the Python version\n\u003c/p\u003e",
          "module": "Control.Generator2",
          "name": "in_orderP",
          "package": "liboleg",
          "signature": "Tree -\u003e CC PP m ()",
          "source": "src/Control-Generator2.html#in_orderP",
          "type": "function"
        },
        "index": {
          "description": "The in order function itself compare with the Python version",
          "hierarchy": "Control Generator2",
          "module": "Control.Generator2",
          "name": "in_orderP",
          "normalized": "Tree-\u003eCC PP a()",
          "package": "liboleg",
          "signature": "Tree-\u003eCC PP m()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-Generator2.html#v:in_orderP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Generator2",
          "name": "make_full_tree",
          "package": "liboleg",
          "signature": "Int -\u003e Tree",
          "source": "src/Control-Generator2.html#make_full_tree",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Generator2",
          "module": "Control.Generator2",
          "name": "make_full_tree",
          "normalized": "Int-\u003eTree",
          "package": "liboleg",
          "signature": "Int-\u003eTree",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-Generator2.html#v:make_full_tree"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe second prompt, used by the acc/accumulated pair\n Again we use the mark of PM to communicate the type of the elements\n between \u003ccode\u003e\u003ca\u003eacc\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003eaccumulated\u003c/a\u003e\u003c/code\u003e. It happens to be the same type used\n by yield/enumetrate.\n If that was not the case, we could have easily arranged for a type-level\n record (see HList or the TFP paper).\n\u003c/p\u003e",
          "module": "Control.Generator2",
          "name": "pa",
          "package": "liboleg",
          "signature": "Prompt (PM a) m (Acc a)",
          "source": "src/Control-Generator2.html#pa",
          "type": "function"
        },
        "index": {
          "description": "The second prompt used by the acc accumulated pair Again we use the mark of PM to communicate the type of the elements between acc and accumulated It happens to be the same type used by yield enumetrate If that was not the case we could have easily arranged for type-level record see HList or the TFP paper",
          "hierarchy": "Control Generator2",
          "module": "Control.Generator2",
          "name": "pa",
          "package": "liboleg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-Generator2.html#v:pa"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eOne prompt, used by the generator (the yield/enumerate pair)\n We instantiate the global pp to the desired answer-type.\n\u003c/p\u003e",
          "module": "Control.Generator2",
          "name": "ppy",
          "package": "liboleg",
          "signature": "Prompt PP m (ResP m a)",
          "source": "src/Control-Generator2.html#ppy",
          "type": "function"
        },
        "index": {
          "description": "One prompt used by the generator the yield enumerate pair We instantiate the global pp to the desired answer-type",
          "hierarchy": "Control Generator2",
          "module": "Control.Generator2",
          "name": "ppy",
          "package": "liboleg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-Generator2.html#v:ppy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eOne prompt, used by the generator (the yield/enumerate pair)\n\u003c/p\u003e",
          "module": "Control.Generator2",
          "name": "py",
          "package": "liboleg",
          "signature": "Prompt (PM a) m (Res m a)",
          "source": "src/Control-Generator2.html#py",
          "type": "function"
        },
        "index": {
          "description": "One prompt used by the generator the yield enumerate pair",
          "hierarchy": "Control Generator2",
          "module": "Control.Generator2",
          "name": "py",
          "package": "liboleg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-Generator2.html#v:py"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Generator2",
          "name": "runIdentity",
          "package": "liboleg",
          "signature": "a",
          "source": "src/Control-Generator2.html#Identity",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Generator2",
          "module": "Control.Generator2",
          "name": "runIdentity",
          "package": "liboleg",
          "partial": "Identity",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-Generator2.html#v:runIdentity"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Generator2",
          "name": "test_acc",
          "package": "liboleg",
          "signature": "[Label]",
          "source": "src/Control-Generator2.html#test_acc",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Generator2",
          "module": "Control.Generator2",
          "name": "test_acc",
          "normalized": "[Label]",
          "package": "liboleg",
          "signature": "[Label]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-Generator2.html#v:test_acc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePrint out the result of the in-order traversal\n\u003c/p\u003e",
          "module": "Control.Generator2",
          "name": "test_io",
          "package": "liboleg",
          "signature": "IO ()",
          "source": "src/Control-Generator2.html#test_io",
          "type": "function"
        },
        "index": {
          "description": "Print out the result of the in-order traversal",
          "hierarchy": "Control Generator2",
          "module": "Control.Generator2",
          "name": "test_io",
          "normalized": "IO()",
          "package": "liboleg",
          "signature": "IO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-Generator2.html#v:test_io"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePrint out the result of the in-order traversal\n\u003c/p\u003e",
          "module": "Control.Generator2",
          "name": "test_ioP",
          "package": "liboleg",
          "signature": "IO ()",
          "source": "src/Control-Generator2.html#test_ioP",
          "type": "function"
        },
        "index": {
          "description": "Print out the result of the in-order traversal",
          "hierarchy": "Control Generator2",
          "module": "Control.Generator2",
          "name": "test_ioP",
          "normalized": "IO()",
          "package": "liboleg",
          "signature": "IO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-Generator2.html#v:test_ioP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe rest of the code, up to test_io, is the same as that in Generator1.hs\n\u003c/p\u003e",
          "module": "Control.Generator2",
          "name": "yield",
          "package": "liboleg",
          "signature": "a -\u003e CC (PM a) m ()",
          "source": "src/Control-Generator2.html#yield",
          "type": "function"
        },
        "index": {
          "description": "The rest of the code up to test io is the same as that in Generator1.hs",
          "hierarchy": "Control Generator2",
          "module": "Control.Generator2",
          "name": "yield",
          "normalized": "a-\u003eCC(PM a)b()",
          "package": "liboleg",
          "signature": "a-\u003eCC(PM a)m()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-Generator2.html#v:yield"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe rest of the code, up to test_io, is the same as that in Generator1.hs\n\u003c/p\u003e",
          "module": "Control.Generator2",
          "name": "yieldP",
          "package": "liboleg",
          "signature": "a -\u003e CC PP m ()",
          "source": "src/Control-Generator2.html#yieldP",
          "type": "function"
        },
        "index": {
          "description": "The rest of the code up to test io is the same as that in Generator1.hs",
          "hierarchy": "Control Generator2",
          "module": "Control.Generator2",
          "name": "yieldP",
          "normalized": "a-\u003eCC PP b()",
          "package": "liboleg",
          "signature": "a-\u003eCC PP m()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-Generator2.html#v:yieldP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis file is part of the code accompanying the paper\n `Fun with type functions'\n Joint work with Simon Peyton Jones and Chung-chieh Shan\n See the paper for explanations.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Control.Mutation",
          "name": "Mutation",
          "package": "liboleg",
          "source": "src/Control-Mutation.html",
          "type": "module"
        },
        "index": {
          "description": "This file is part of the code accompanying the paper Fun with type functions Joint work with Simon Peyton Jones and Chung-chieh Shan See the paper for explanations",
          "hierarchy": "Control Mutation",
          "module": "Control.Mutation",
          "name": "Mutation",
          "package": "liboleg",
          "partial": "Mutation",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-Mutation.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eStart basic\n\u003c/p\u003e",
          "module": "Control.Mutation",
          "name": "Mutation",
          "package": "liboleg",
          "source": "src/Control-Mutation.html#Mutation",
          "type": "class"
        },
        "index": {
          "description": "Start basic",
          "hierarchy": "Control Mutation",
          "module": "Control.Mutation",
          "name": "Mutation",
          "package": "liboleg",
          "partial": "Mutation",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-Mutation.html#t:Mutation"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Mutation",
          "name": "newRef",
          "package": "liboleg",
          "signature": "a -\u003e m (Ref m a)",
          "source": "src/Control-Mutation.html#newRef",
          "type": "method"
        },
        "index": {
          "hierarchy": "Control Mutation",
          "module": "Control.Mutation",
          "name": "newRef",
          "normalized": "a-\u003eb(Ref b a)",
          "package": "liboleg",
          "partial": "Ref",
          "signature": "a-\u003em(Ref m a)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-Mutation.html#v:newRef"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Mutation",
          "name": "readRef",
          "package": "liboleg",
          "signature": "Ref m a -\u003e m a",
          "source": "src/Control-Mutation.html#readRef",
          "type": "method"
        },
        "index": {
          "hierarchy": "Control Mutation",
          "module": "Control.Mutation",
          "name": "readRef",
          "normalized": "Ref a b-\u003ea b",
          "package": "liboleg",
          "partial": "Ref",
          "signature": "Ref m a-\u003em a",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-Mutation.html#v:readRef"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Mutation",
          "name": "writeRef",
          "package": "liboleg",
          "signature": "Ref m a -\u003e a -\u003e m ()",
          "source": "src/Control-Mutation.html#writeRef",
          "type": "method"
        },
        "index": {
          "hierarchy": "Control Mutation",
          "module": "Control.Mutation",
          "name": "writeRef",
          "normalized": "Ref a b-\u003eb-\u003ea()",
          "package": "liboleg",
          "partial": "Ref",
          "signature": "Ref m a-\u003ea-\u003em()",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-Mutation.html#v:writeRef"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eType-class overloaded functions: second-order typeclass programming\n with backtracking\n\u003c/p\u003e\u003cp\u003e\u003ca\u003ehttp://okmij.org/ftp/Haskell/types.html#poly2\u003c/a\u003e\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Control.Poly2",
          "name": "Poly2",
          "package": "liboleg",
          "source": "src/Control-Poly2.html",
          "type": "module"
        },
        "index": {
          "description": "Type-class overloaded functions second-order typeclass programming with backtracking http okmij.org ftp Haskell types.html poly2",
          "hierarchy": "Control Poly2",
          "module": "Control.Poly2",
          "name": "Poly2",
          "package": "liboleg",
          "partial": "Poly",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-Poly2.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Poly2",
          "name": ":*:",
          "package": "liboleg",
          "source": "src/Control-Poly2.html#%3A%2A%3A",
          "type": "data"
        },
        "index": {
          "hierarchy": "Control Poly2",
          "module": "Control.Poly2",
          "name": ":*:",
          "package": "liboleg",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-Poly2.html#t::-42-:"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Poly2",
          "name": "AllOf",
          "package": "liboleg",
          "source": "src/Control-Poly2.html#AllOf",
          "type": "data"
        },
        "index": {
          "hierarchy": "Control Poly2",
          "module": "Control.Poly2",
          "name": "AllOf",
          "package": "liboleg",
          "partial": "All Of",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-Poly2.html#t:AllOf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Poly2",
          "name": "AllOfBut",
          "package": "liboleg",
          "source": "src/Control-Poly2.html#AllOfBut",
          "type": "data"
        },
        "index": {
          "hierarchy": "Control Poly2",
          "module": "Control.Poly2",
          "name": "AllOfBut",
          "package": "liboleg",
          "partial": "All Of But",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-Poly2.html#t:AllOfBut"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Poly2",
          "name": "Apply",
          "package": "liboleg",
          "source": "src/Control-Poly2.html#Apply",
          "type": "class"
        },
        "index": {
          "hierarchy": "Control Poly2",
          "module": "Control.Poly2",
          "name": "Apply",
          "package": "liboleg",
          "partial": "Apply",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-Poly2.html#t:Apply"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Poly2",
          "name": "ApproxEq",
          "package": "liboleg",
          "source": "src/Control-Poly2.html#ApproxEq",
          "type": "data"
        },
        "index": {
          "hierarchy": "Control Poly2",
          "module": "Control.Poly2",
          "name": "ApproxEq",
          "package": "liboleg",
          "partial": "Approx Eq",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-Poly2.html#t:ApproxEq"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Poly2",
          "name": "ApproxEq'",
          "package": "liboleg",
          "source": "src/Control-Poly2.html#ApproxEq%27",
          "type": "data"
        },
        "index": {
          "hierarchy": "Control Poly2",
          "module": "Control.Poly2",
          "name": "ApproxEq'",
          "package": "liboleg",
          "partial": "Approx Eq'",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-Poly2.html#t:ApproxEq-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Poly2",
          "name": "Eqs",
          "package": "liboleg",
          "source": "src/Control-Poly2.html#Eqs",
          "type": "type"
        },
        "index": {
          "hierarchy": "Control Poly2",
          "module": "Control.Poly2",
          "name": "Eqs",
          "package": "liboleg",
          "partial": "Eqs",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-Poly2.html#t:Eqs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe classes of types used in the examples below\n\u003c/p\u003e",
          "module": "Control.Poly2",
          "name": "Fractionals",
          "package": "liboleg",
          "source": "src/Control-Poly2.html#Fractionals",
          "type": "type"
        },
        "index": {
          "description": "The classes of types used in the examples below",
          "hierarchy": "Control Poly2",
          "module": "Control.Poly2",
          "name": "Fractionals",
          "package": "liboleg",
          "partial": "Fractionals",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-Poly2.html#t:Fractionals"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA type class for instance guards and back-tracking\n Here, pred and f are labels and n is of a kind numeral.\n\u003c/p\u003e",
          "module": "Control.Poly2",
          "name": "GFN",
          "package": "liboleg",
          "source": "src/Control-Poly2.html#GFN",
          "type": "class"
        },
        "index": {
          "description": "type class for instance guards and back-tracking Here pred and are labels and is of kind numeral",
          "hierarchy": "Control Poly2",
          "module": "Control.Poly2",
          "name": "GFN",
          "package": "liboleg",
          "partial": "GFN",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-Poly2.html#t:GFN"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Poly2",
          "name": "GFn",
          "package": "liboleg",
          "source": "src/Control-Poly2.html#GFn",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "Control Poly2",
          "module": "Control.Poly2",
          "name": "GFn",
          "package": "liboleg",
          "partial": "GFn",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-Poly2.html#t:GFn"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Poly2",
          "name": "GFnA",
          "package": "liboleg",
          "source": "src/Control-Poly2.html#GFnA",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "Control Poly2",
          "module": "Control.Poly2",
          "name": "GFnA",
          "package": "liboleg",
          "partial": "GFn",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-Poly2.html#t:GFnA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Poly2",
          "name": "GFnTest",
          "package": "liboleg",
          "source": "src/Control-Poly2.html#GFnTest",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "Control Poly2",
          "module": "Control.Poly2",
          "name": "GFnTest",
          "package": "liboleg",
          "partial": "GFn Test",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-Poly2.html#t:GFnTest"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Poly2",
          "name": "HFalse",
          "package": "liboleg",
          "source": "src/Control-Poly2.html#HFalse",
          "type": "data"
        },
        "index": {
          "hierarchy": "Control Poly2",
          "module": "Control.Poly2",
          "name": "HFalse",
          "package": "liboleg",
          "partial": "HFalse",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-Poly2.html#t:HFalse"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Poly2",
          "name": "HNil",
          "package": "liboleg",
          "source": "src/Control-Poly2.html#HNil",
          "type": "data"
        },
        "index": {
          "hierarchy": "Control Poly2",
          "module": "Control.Poly2",
          "name": "HNil",
          "package": "liboleg",
          "partial": "HNil",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-Poly2.html#t:HNil"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Poly2",
          "name": "HTrue",
          "package": "liboleg",
          "source": "src/Control-Poly2.html#HTrue",
          "type": "data"
        },
        "index": {
          "hierarchy": "Control Poly2",
          "module": "Control.Poly2",
          "name": "HTrue",
          "package": "liboleg",
          "partial": "HTrue",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-Poly2.html#t:HTrue"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA generic function that tests if its argument is a member of Eqs\n\u003c/p\u003e",
          "module": "Control.Poly2",
          "name": "IsAnEq",
          "package": "liboleg",
          "source": "src/Control-Poly2.html#IsAnEq",
          "type": "data"
        },
        "index": {
          "description": "generic function that tests if its argument is member of Eqs",
          "hierarchy": "Control Poly2",
          "module": "Control.Poly2",
          "name": "IsAnEq",
          "package": "liboleg",
          "partial": "Is An Eq",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-Poly2.html#t:IsAnEq"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Poly2",
          "name": "MemApp",
          "package": "liboleg",
          "source": "src/Control-Poly2.html#MemApp",
          "type": "class"
        },
        "index": {
          "hierarchy": "Control Poly2",
          "module": "Control.Poly2",
          "name": "MemApp",
          "package": "liboleg",
          "partial": "Mem App",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-Poly2.html#t:MemApp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ewe avoid defining a new class like MemApp above.\n I guess, after Apply, we don't need a single class ever?\n\u003c/p\u003e",
          "module": "Control.Poly2",
          "name": "MemCase2",
          "package": "liboleg",
          "source": "src/Control-Poly2.html#MemCase2",
          "type": "data"
        },
        "index": {
          "description": "we avoid defining new class like MemApp above guess after Apply we don need single class ever",
          "hierarchy": "Control Poly2",
          "module": "Control.Poly2",
          "name": "MemCase2",
          "package": "liboleg",
          "partial": "Mem Case",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-Poly2.html#t:MemCase2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDeciding the membership in a closed class, specified\n by enumeration, union and difference\n\u003c/p\u003e",
          "module": "Control.Poly2",
          "name": "Member",
          "package": "liboleg",
          "source": "src/Control-Poly2.html#Member",
          "type": "data"
        },
        "index": {
          "description": "Deciding the membership in closed class specified by enumeration union and difference",
          "hierarchy": "Control Poly2",
          "module": "Control.Poly2",
          "name": "Member",
          "package": "liboleg",
          "partial": "Member",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-Poly2.html#t:Member"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Poly2",
          "name": "Nums",
          "package": "liboleg",
          "source": "src/Control-Poly2.html#Nums",
          "type": "type"
        },
        "index": {
          "hierarchy": "Control Poly2",
          "module": "Control.Poly2",
          "name": "Nums",
          "package": "liboleg",
          "partial": "Nums",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-Poly2.html#t:Nums"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe Fractionals, Nums and Ords above are closed. But Eqs is open\n (i.e., extensible), due to the following:\n\u003c/p\u003e",
          "module": "Control.Poly2",
          "name": "OpenEqs",
          "package": "liboleg",
          "source": "src/Control-Poly2.html#OpenEqs",
          "type": "data"
        },
        "index": {
          "description": "The Fractionals Nums and Ords above are closed But Eqs is open i.e extensible due to the following",
          "hierarchy": "Control Poly2",
          "module": "Control.Poly2",
          "name": "OpenEqs",
          "package": "liboleg",
          "partial": "Open Eqs",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-Poly2.html#t:OpenEqs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Poly2",
          "name": "Ords",
          "package": "liboleg",
          "source": "src/Control-Poly2.html#Ords",
          "type": "type"
        },
        "index": {
          "hierarchy": "Control Poly2",
          "module": "Control.Poly2",
          "name": "Ords",
          "package": "liboleg",
          "partial": "Ords",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-Poly2.html#t:Ords"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe guard that always succeeds (cf. \u003ccode\u003e\u003ca\u003eotherwise\u003c/a\u003e\u003c/code\u003e in Haskell)\n\u003c/p\u003e",
          "module": "Control.Poly2",
          "name": "Otherwise",
          "package": "liboleg",
          "source": "src/Control-Poly2.html#Otherwise",
          "type": "data"
        },
        "index": {
          "description": "The guard that always succeeds cf otherwise in Haskell",
          "hierarchy": "Control Poly2",
          "module": "Control.Poly2",
          "name": "Otherwise",
          "package": "liboleg",
          "partial": "Otherwise",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-Poly2.html#t:Otherwise"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe main test: approximate equality. See the article for\n the description.\n\u003c/p\u003e",
          "module": "Control.Poly2",
          "name": "PairOf",
          "package": "liboleg",
          "source": "src/Control-Poly2.html#PairOf",
          "type": "data"
        },
        "index": {
          "description": "The main test approximate equality See the article for the description",
          "hierarchy": "Control Poly2",
          "module": "Control.Poly2",
          "name": "PairOf",
          "package": "liboleg",
          "partial": "Pair Of",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-Poly2.html#t:PairOf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Poly2",
          "name": "Russel",
          "package": "liboleg",
          "source": "src/Control-Poly2.html#Russel",
          "type": "type"
        },
        "index": {
          "hierarchy": "Control Poly2",
          "module": "Control.Poly2",
          "name": "Russel",
          "package": "liboleg",
          "partial": "Russel",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-Poly2.html#t:Russel"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWhy we call Nums etc. a type class rather than a type set?\n The following does not work: type synonyms can't be recursive.\n\u003c/p\u003e\u003cpre\u003e type Russel = AllOfBut () Russel :*: HNil\n\u003c/pre\u003e\u003cp\u003eBut the more elaborate version does, with the expected result:\n\u003c/p\u003e",
          "module": "Control.Poly2",
          "name": "RusselC",
          "package": "liboleg",
          "source": "src/Control-Poly2.html#RusselC",
          "type": "data"
        },
        "index": {
          "description": "Why we call Nums etc type class rather than type set The following does not work type synonyms can be recursive type Russel AllOfBut Russel HNil But the more elaborate version does with the expected result",
          "hierarchy": "Control Poly2",
          "module": "Control.Poly2",
          "name": "RusselC",
          "package": "liboleg",
          "partial": "Russel",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-Poly2.html#t:RusselC"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Poly2",
          "name": "S",
          "package": "liboleg",
          "source": "src/Control-Poly2.html#S",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "Control Poly2",
          "module": "Control.Poly2",
          "name": "S",
          "package": "liboleg",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-Poly2.html#t:S"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Poly2",
          "name": "TypeCast",
          "package": "liboleg",
          "source": "src/Control-Poly2.html#TypeCast",
          "type": "class"
        },
        "index": {
          "hierarchy": "Control Poly2",
          "module": "Control.Poly2",
          "name": "TypeCast",
          "package": "liboleg",
          "partial": "Type Cast",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-Poly2.html#t:TypeCast"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Poly2",
          "name": "TypeCast'",
          "package": "liboleg",
          "source": "src/Control-Poly2.html#TypeCast%27",
          "type": "class"
        },
        "index": {
          "hierarchy": "Control Poly2",
          "module": "Control.Poly2",
          "name": "TypeCast'",
          "package": "liboleg",
          "partial": "Type Cast'",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-Poly2.html#t:TypeCast-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Poly2",
          "name": "TypeCast''",
          "package": "liboleg",
          "source": "src/Control-Poly2.html#TypeCast%27%27",
          "type": "class"
        },
        "index": {
          "hierarchy": "Control Poly2",
          "module": "Control.Poly2",
          "name": "TypeCast''",
          "package": "liboleg",
          "partial": "Type Cast''",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-Poly2.html#t:TypeCast-39--39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Poly2",
          "name": "TypeCl",
          "package": "liboleg",
          "source": "src/Control-Poly2.html#TypeCl",
          "type": "data"
        },
        "index": {
          "hierarchy": "Control Poly2",
          "module": "Control.Poly2",
          "name": "TypeCl",
          "package": "liboleg",
          "partial": "Type Cl",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-Poly2.html#t:TypeCl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eClassifies if the type x belongs to the open class labeled l\n The result r is either HTrue or HFalse\n\u003c/p\u003e",
          "module": "Control.Poly2",
          "name": "TypeCls",
          "package": "liboleg",
          "source": "src/Control-Poly2.html#TypeCls",
          "type": "class"
        },
        "index": {
          "description": "Classifies if the type belongs to the open class labeled The result is either HTrue or HFalse",
          "hierarchy": "Control Poly2",
          "module": "Control.Poly2",
          "name": "TypeCls",
          "package": "liboleg",
          "partial": "Type Cls",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-Poly2.html#t:TypeCls"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Poly2",
          "name": "TypeEq",
          "package": "liboleg",
          "source": "src/Control-Poly2.html#TypeEq",
          "type": "class"
        },
        "index": {
          "hierarchy": "Control Poly2",
          "module": "Control.Poly2",
          "name": "TypeEq",
          "package": "liboleg",
          "partial": "Type Eq",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-Poly2.html#t:TypeEq"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Poly2",
          "name": "Z",
          "package": "liboleg",
          "source": "src/Control-Poly2.html#Z",
          "type": "data"
        },
        "index": {
          "hierarchy": "Control Poly2",
          "module": "Control.Poly2",
          "name": "Z",
          "package": "liboleg",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-Poly2.html#t:Z"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Poly2",
          "name": ":*:",
          "package": "liboleg",
          "signature": "a :*: b",
          "source": "src/Control-Poly2.html#%3A%2A%3A",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Poly2",
          "module": "Control.Poly2",
          "name": ":*:",
          "package": "liboleg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-Poly2.html#v::-42-:"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Poly2",
          "name": "ApproxEq",
          "package": "liboleg",
          "signature": "ApproxEq",
          "source": "src/Control-Poly2.html#ApproxEq",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Poly2",
          "module": "Control.Poly2",
          "name": "ApproxEq",
          "package": "liboleg",
          "partial": "Approx Eq",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-Poly2.html#v:ApproxEq"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Poly2",
          "name": "ApproxEq'",
          "package": "liboleg",
          "signature": "ApproxEq'",
          "source": "src/Control-Poly2.html#ApproxEq%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Poly2",
          "module": "Control.Poly2",
          "name": "ApproxEq'",
          "package": "liboleg",
          "partial": "Approx Eq'",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-Poly2.html#v:ApproxEq-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Poly2",
          "name": "GFn",
          "package": "liboleg",
          "signature": "GFn f",
          "source": "src/Control-Poly2.html#GFn",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Poly2",
          "module": "Control.Poly2",
          "name": "GFn",
          "package": "liboleg",
          "partial": "GFn",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-Poly2.html#v:GFn"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Poly2",
          "name": "GFnA",
          "package": "liboleg",
          "signature": "GFnA f",
          "source": "src/Control-Poly2.html#GFnA",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Poly2",
          "module": "Control.Poly2",
          "name": "GFnA",
          "package": "liboleg",
          "partial": "GFn",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-Poly2.html#v:GFnA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Poly2",
          "name": "GFnTest",
          "package": "liboleg",
          "signature": "GFnTest f",
          "source": "src/Control-Poly2.html#GFnTest",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Poly2",
          "module": "Control.Poly2",
          "name": "GFnTest",
          "package": "liboleg",
          "partial": "GFn Test",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-Poly2.html#v:GFnTest"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Poly2",
          "name": "HNil",
          "package": "liboleg",
          "signature": "HNil",
          "source": "src/Control-Poly2.html#HNil",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Poly2",
          "module": "Control.Poly2",
          "name": "HNil",
          "package": "liboleg",
          "partial": "HNil",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-Poly2.html#v:HNil"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Poly2",
          "name": "IsAnEq",
          "package": "liboleg",
          "signature": "IsAnEq",
          "source": "src/Control-Poly2.html#IsAnEq",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Poly2",
          "module": "Control.Poly2",
          "name": "IsAnEq",
          "package": "liboleg",
          "partial": "Is An Eq",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-Poly2.html#v:IsAnEq"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Poly2",
          "name": "S",
          "package": "liboleg",
          "signature": "S n",
          "source": "src/Control-Poly2.html#S",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Poly2",
          "module": "Control.Poly2",
          "name": "S",
          "package": "liboleg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-Poly2.html#v:S"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Poly2",
          "name": "Z",
          "package": "liboleg",
          "signature": "Z",
          "source": "src/Control-Poly2.html#Z",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Poly2",
          "module": "Control.Poly2",
          "name": "Z",
          "package": "liboleg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-Poly2.html#v:Z"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Poly2",
          "name": "apply",
          "package": "liboleg",
          "signature": "f -\u003e a -\u003e r",
          "source": "src/Control-Poly2.html#apply",
          "type": "method"
        },
        "index": {
          "hierarchy": "Control Poly2",
          "module": "Control.Poly2",
          "name": "apply",
          "normalized": "a-\u003eb-\u003ec",
          "package": "liboleg",
          "signature": "f-\u003ea-\u003er",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-Poly2.html#v:apply"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Poly2",
          "name": "typeCast",
          "package": "liboleg",
          "signature": "a -\u003e b",
          "source": "src/Control-Poly2.html#typeCast",
          "type": "method"
        },
        "index": {
          "hierarchy": "Control Poly2",
          "module": "Control.Poly2",
          "name": "typeCast",
          "normalized": "a-\u003eb",
          "package": "liboleg",
          "partial": "Cast",
          "signature": "a-\u003eb",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-Poly2.html#v:typeCast"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Poly2",
          "name": "typeCast'",
          "package": "liboleg",
          "signature": "t -\u003e a -\u003e b",
          "source": "src/Control-Poly2.html#typeCast%27",
          "type": "method"
        },
        "index": {
          "hierarchy": "Control Poly2",
          "module": "Control.Poly2",
          "name": "typeCast'",
          "normalized": "a-\u003eb-\u003ec",
          "package": "liboleg",
          "partial": "Cast'",
          "signature": "t-\u003ea-\u003eb",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-Poly2.html#v:typeCast-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Poly2",
          "name": "typeCast''",
          "package": "liboleg",
          "signature": "t -\u003e a -\u003e b",
          "source": "src/Control-Poly2.html#typeCast%27%27",
          "type": "method"
        },
        "index": {
          "hierarchy": "Control Poly2",
          "module": "Control.Poly2",
          "name": "typeCast''",
          "normalized": "a-\u003eb-\u003ec",
          "package": "liboleg",
          "partial": "Cast''",
          "signature": "t-\u003ea-\u003eb",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-Poly2.html#v:typeCast-39--39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eImplementation of the calculus lambda-sr-let\n\u003c/p\u003e\u003cpre\u003e Polymorphic delimited continuations\n Asai and Kameyama, APLAS 2007\n http://logic.cs.tsukuba.ac.jp/~kam/paper/aplas07.pdf\n hereafter, AK07\n\u003c/pre\u003e\u003cp\u003eThis embedding of the AK07 calculus into Haskell is another\n proof that AK07 admit type inference algorithm.\n In all the tests below, all the types are inferred.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Control.ShiftResetGenuine",
          "name": "ShiftResetGenuine",
          "package": "liboleg",
          "source": "src/Control-ShiftResetGenuine.html",
          "type": "module"
        },
        "index": {
          "description": "Implementation of the calculus lambda-sr-let Polymorphic delimited continuations Asai and Kameyama APLAS http logic.cs.tsukuba.ac.jp kam paper aplas07.pdf hereafter AK07 This embedding of the AK07 calculus into Haskell is another proof that AK07 admit type inference algorithm In all the tests below all the types are inferred",
          "hierarchy": "Control ShiftResetGenuine",
          "module": "Control.ShiftResetGenuine",
          "name": "ShiftResetGenuine",
          "package": "liboleg",
          "partial": "Shift Reset Genuine",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-ShiftResetGenuine.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003esome syntactic sugar\n\u003c/p\u003e\u003cp\u003eThe continuation monad parameterized by two answer types\n We represent the the effectful expression e, whose type is\n characterized by the judgement\n\u003c/p\u003e\u003cpre\u003e\tGamma; a |- e:tau; b\n\u003c/pre\u003e\u003cp\u003eas a parameterized monad C a b tau. We represent an effectful function\n type sigma\u003cem\u003ea -\u003e tau\u003c/em\u003eb of the calculus as an arrow type \n sigma -\u003e C a b tau.\n Incidentally, this notational \u003ccode\u003econvention\u003c/code\u003e expresses the rule \u003ccode\u003efun\u003c/code\u003e in AK07\n\u003c/p\u003e",
          "module": "Control.ShiftResetGenuine",
          "name": "C",
          "package": "liboleg",
          "source": "src/Control-ShiftResetGenuine.html#C",
          "type": "newtype"
        },
        "index": {
          "description": "some syntactic sugar The continuation monad parameterized by two answer types We represent the the effectful expression whose type is characterized by the judgement Gamma tau as parameterized monad tau We represent an effectful function type sigma tau of the calculus as an arrow type sigma tau Incidentally this notational convention expresses the rule fun in AK07",
          "hierarchy": "Control ShiftResetGenuine",
          "module": "Control.ShiftResetGenuine",
          "name": "C",
          "package": "liboleg",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-ShiftResetGenuine.html#t:C"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInject regular monads to be monadish things too\n\u003c/p\u003e",
          "module": "Control.ShiftResetGenuine",
          "name": "MW",
          "package": "liboleg",
          "source": "src/Control-ShiftResetGenuine.html#MW",
          "type": "newtype"
        },
        "index": {
          "description": "Inject regular monads to be monadish things too",
          "hierarchy": "Control ShiftResetGenuine",
          "module": "Control.ShiftResetGenuine",
          "name": "MW",
          "package": "liboleg",
          "partial": "MW",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-ShiftResetGenuine.html#t:MW"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eParameterized monad. This is almost the same monad used in \n the Region-IO and TFP07 paper\n See also\n\u003c/p\u003e\u003cpre\u003e  Robert Atkey, Parameterised Notions of Computation, Msfp2006\n  http://homepages.inf.ed.ac.uk/ratkey/param-notions.pdf\n\u003c/pre\u003e\u003cp\u003eand\n\u003c/p\u003e\u003cpre\u003e  http://www.haskell.org/pipermail/haskell/2006-December/018917.html\n\u003c/pre\u003e",
          "module": "Control.ShiftResetGenuine",
          "name": "Monadish",
          "package": "liboleg",
          "source": "src/Control-ShiftResetGenuine.html#Monadish",
          "type": "class"
        },
        "index": {
          "description": "Parameterized monad This is almost the same monad used in the Region-IO and TFP07 paper See also Robert Atkey Parameterised Notions of Computation Msfp2006 http homepages.inf.ed.ac.uk ratkey param-notions.pdf and http www.haskell.org pipermail haskell December html",
          "hierarchy": "Control ShiftResetGenuine",
          "module": "Control.ShiftResetGenuine",
          "name": "Monadish",
          "package": "liboleg",
          "partial": "Monadish",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-ShiftResetGenuine.html#t:Monadish"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.ShiftResetGenuine",
          "name": "C",
          "package": "liboleg",
          "signature": "C",
          "source": "src/Control-ShiftResetGenuine.html#C",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control ShiftResetGenuine",
          "module": "Control.ShiftResetGenuine",
          "name": "C",
          "package": "liboleg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-ShiftResetGenuine.html#v:C"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.ShiftResetGenuine",
          "name": "MW",
          "package": "liboleg",
          "signature": "MW",
          "source": "src/Control-ShiftResetGenuine.html#MW",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control ShiftResetGenuine",
          "module": "Control.ShiftResetGenuine",
          "name": "MW",
          "package": "liboleg",
          "partial": "MW",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-ShiftResetGenuine.html#v:MW"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.ShiftResetGenuine",
          "name": "bind",
          "package": "liboleg",
          "signature": "m b g sigma -\u003e (sigma -\u003e m a b tau) -\u003e m a g tau",
          "source": "src/Control-ShiftResetGenuine.html#bind",
          "type": "method"
        },
        "index": {
          "hierarchy": "Control ShiftResetGenuine",
          "module": "Control.ShiftResetGenuine",
          "name": "bind",
          "normalized": "a b c d-\u003e(d-\u003ea e b f)-\u003ea e c f",
          "package": "liboleg",
          "signature": "m b g sigma-\u003e(sigma-\u003em a b tau)-\u003em a g tau",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-ShiftResetGenuine.html#v:bind"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe append example from AK07, section 2.1\n\u003c/p\u003e\u003cp\u003eThe sprintf test: Sec 2.3 of AK07\n The paper argues this test requires both the changing of the answer type\n and polymorphism (fmt is used polymorphically in stest3)\n\u003c/p\u003e",
          "module": "Control.ShiftResetGenuine",
          "name": "int",
          "package": "liboleg",
          "signature": "Int -\u003e String",
          "source": "src/Control-ShiftResetGenuine.html#int",
          "type": "function"
        },
        "index": {
          "description": "The append example from AK07 section The sprintf test Sec of AK07 The paper argues this test requires both the changing of the answer type and polymorphism fmt is used polymorphically in stest3",
          "hierarchy": "Control ShiftResetGenuine",
          "module": "Control.ShiftResetGenuine",
          "name": "int",
          "normalized": "Int-\u003eString",
          "package": "liboleg",
          "signature": "Int-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-ShiftResetGenuine.html#v:int"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe rules from AK07 as they are (see Fig 3)\n\u003c/p\u003e",
          "module": "Control.ShiftResetGenuine",
          "name": "reset",
          "package": "liboleg",
          "signature": "C sigma tau sigma -\u003e C a a tau",
          "source": "src/Control-ShiftResetGenuine.html#reset",
          "type": "function"
        },
        "index": {
          "description": "The rules from AK07 as they are see Fig",
          "hierarchy": "Control ShiftResetGenuine",
          "module": "Control.ShiftResetGenuine",
          "name": "reset",
          "normalized": "C a b a-\u003eC c c b",
          "package": "liboleg",
          "signature": "C sigma tau sigma-\u003eC a a tau",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-ShiftResetGenuine.html#v:reset"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.ShiftResetGenuine",
          "name": "ret",
          "package": "liboleg",
          "signature": "tau -\u003e m a a tau",
          "source": "src/Control-ShiftResetGenuine.html#ret",
          "type": "method"
        },
        "index": {
          "hierarchy": "Control ShiftResetGenuine",
          "module": "Control.ShiftResetGenuine",
          "name": "ret",
          "normalized": "a-\u003eb c c a",
          "package": "liboleg",
          "signature": "tau-\u003em a a tau",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-ShiftResetGenuine.html#v:ret"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.ShiftResetGenuine",
          "name": "run",
          "package": "liboleg",
          "signature": "C tau tau tau -\u003e tau",
          "source": "src/Control-ShiftResetGenuine.html#run",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control ShiftResetGenuine",
          "module": "Control.ShiftResetGenuine",
          "name": "run",
          "normalized": "C a a a-\u003ea",
          "package": "liboleg",
          "signature": "C tau tau tau-\u003etau",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-ShiftResetGenuine.html#v:run"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eshift.\n\u003c/p\u003e",
          "module": "Control.ShiftResetGenuine",
          "name": "shift",
          "package": "liboleg",
          "signature": "((tau -\u003e C t t a) -\u003e C s b s) -\u003e C a b tau",
          "source": "src/Control-ShiftResetGenuine.html#shift",
          "type": "function"
        },
        "index": {
          "description": "shift",
          "hierarchy": "Control ShiftResetGenuine",
          "module": "Control.ShiftResetGenuine",
          "name": "shift",
          "normalized": "((a-\u003eC b b c)-\u003eC d e d)-\u003eC c e a",
          "package": "liboleg",
          "signature": "((tau-\u003eC t t a)-\u003eC s b s)-\u003eC a b tau",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-ShiftResetGenuine.html#v:shift"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.ShiftResetGenuine",
          "name": "str",
          "package": "liboleg",
          "signature": "String -\u003e String",
          "source": "src/Control-ShiftResetGenuine.html#str",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control ShiftResetGenuine",
          "module": "Control.ShiftResetGenuine",
          "name": "str",
          "normalized": "String-\u003eString",
          "package": "liboleg",
          "signature": "String-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-ShiftResetGenuine.html#v:str"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.ShiftResetGenuine",
          "name": "unC",
          "package": "liboleg",
          "signature": "(tau -\u003e a) -\u003e b",
          "source": "src/Control-ShiftResetGenuine.html#C",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control ShiftResetGenuine",
          "module": "Control.ShiftResetGenuine",
          "name": "unC",
          "normalized": "(a-\u003eb)-\u003ec",
          "package": "liboleg",
          "signature": "(tau-\u003ea)-\u003eb",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-ShiftResetGenuine.html#v:unC"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.ShiftResetGenuine",
          "name": "unMW",
          "package": "liboleg",
          "signature": "m a",
          "source": "src/Control-ShiftResetGenuine.html#MW",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control ShiftResetGenuine",
          "module": "Control.ShiftResetGenuine",
          "name": "unMW",
          "package": "liboleg",
          "partial": "MW",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-ShiftResetGenuine.html#v:unMW"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eImplementing the State Monad as a term algebra\n\u003c/p\u003e\u003cp\u003e\u003ca\u003ehttp://okmij.org/ftp/Haskell/types.html#state-algebra\u003c/a\u003e\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Control.StateAlgebra",
          "name": "StateAlgebra",
          "package": "liboleg",
          "source": "src/Control-StateAlgebra.html",
          "type": "module"
        },
        "index": {
          "description": "Implementing the State Monad as term algebra http okmij.org ftp Haskell types.html state-algebra",
          "hierarchy": "Control StateAlgebra",
          "module": "Control.StateAlgebra",
          "name": "StateAlgebra",
          "package": "liboleg",
          "partial": "State Algebra",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-StateAlgebra.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMonadic actions are terms composed from the following constructors\n\u003c/p\u003e",
          "module": "Control.StateAlgebra",
          "name": "Bind",
          "package": "liboleg",
          "source": "src/Control-StateAlgebra.html#Bind",
          "type": "data"
        },
        "index": {
          "description": "Monadic actions are terms composed from the following constructors",
          "hierarchy": "Control StateAlgebra",
          "module": "Control.StateAlgebra",
          "name": "Bind",
          "package": "liboleg",
          "partial": "Bind",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-StateAlgebra.html#t:Bind"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.StateAlgebra",
          "name": "Get",
          "package": "liboleg",
          "source": "src/Control-StateAlgebra.html#Get",
          "type": "data"
        },
        "index": {
          "hierarchy": "Control StateAlgebra",
          "module": "Control.StateAlgebra",
          "name": "Get",
          "package": "liboleg",
          "partial": "Get",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-StateAlgebra.html#t:Get"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.StateAlgebra",
          "name": "Put",
          "package": "liboleg",
          "source": "src/Control-StateAlgebra.html#Put",
          "type": "data"
        },
        "index": {
          "hierarchy": "Control StateAlgebra",
          "module": "Control.StateAlgebra",
          "name": "Put",
          "package": "liboleg",
          "partial": "Put",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-StateAlgebra.html#t:Put"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.StateAlgebra",
          "name": "Return",
          "package": "liboleg",
          "source": "src/Control-StateAlgebra.html#Return",
          "type": "data"
        },
        "index": {
          "hierarchy": "Control StateAlgebra",
          "module": "Control.StateAlgebra",
          "name": "Return",
          "package": "liboleg",
          "partial": "Return",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-StateAlgebra.html#t:Return"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInterpretation of the Bind action requires an auxiliary class\n This is due to the polymorphism of the monadic bind, which has the \n type  \n\u003c/p\u003e\u003cpre\u003e m a -\u003e (a -\u003e m b) -\u003e m b\n\u003c/pre\u003e\u003cp\u003eNote the polymorphism both in \u003ccode\u003ea\u003c/code\u003e (value type of the input monadic\n action) and \u003ccode\u003eb\u003c/code\u003e (value type of the resulting action)\n\u003c/p\u003e",
          "module": "Control.StateAlgebra",
          "name": "RunBind",
          "package": "liboleg",
          "source": "src/Control-StateAlgebra.html#RunBind",
          "type": "class"
        },
        "index": {
          "description": "Interpretation of the Bind action requires an auxiliary class This is due to the polymorphism of the monadic bind which has the type Note the polymorphism both in value type of the input monadic action and value type of the resulting action",
          "hierarchy": "Control StateAlgebra",
          "module": "Control.StateAlgebra",
          "name": "RunBind",
          "package": "liboleg",
          "partial": "Run Bind",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-StateAlgebra.html#t:RunBind"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eexamples of terms\n\u003c/p\u003e\u003cp\u003eAn example of an ill-formed term\n\u003c/p\u003e\u003cp\u003eAn example of an ill-typed term\n The following term is ill-typed because it attempts to store both\n a boolean and a character in the state. Our state can have only one type.\n\u003c/p\u003e\u003cp\u003eThe interpreter of monadic actions\n It takes the term \u003ccode\u003et\u003c/code\u003e and the initial state of the type \u003ccode\u003es\u003c/code\u003e\n and returns the final state and the resulting value. The type\n of the result, \u003ccode\u003ea\u003c/code\u003e, is uniquely determined by the term and the state\n\u003c/p\u003e",
          "module": "Control.StateAlgebra",
          "name": "RunState",
          "package": "liboleg",
          "source": "src/Control-StateAlgebra.html#RunState",
          "type": "class"
        },
        "index": {
          "description": "examples of terms An example of an ill-formed term An example of an ill-typed term The following term is ill-typed because it attempts to store both boolean and character in the state Our state can have only one type The interpreter of monadic actions It takes the term and the initial state of the type and returns the final state and the resulting value The type of the result is uniquely determined by the term and the state",
          "hierarchy": "Control StateAlgebra",
          "module": "Control.StateAlgebra",
          "name": "RunState",
          "package": "liboleg",
          "partial": "Run State",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-StateAlgebra.html#t:RunState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWe can now run (interpret) our sample terms\n\u003c/p\u003e\u003cp\u003eterm2 denoted the action of negating the current state and returning\n the original state\n\u003c/p\u003e\u003cp\u003eNow, we show that our term representation of the state monad \n is an instance of MonadState\n\u003c/p\u003e",
          "module": "Control.StateAlgebra",
          "name": "Statte",
          "package": "liboleg",
          "source": "src/Control-StateAlgebra.html#Statte",
          "type": "data"
        },
        "index": {
          "description": "We can now run interpret our sample terms term2 denoted the action of negating the current state and returning the original state Now we show that our term representation of the state monad is an instance of MonadState",
          "hierarchy": "Control StateAlgebra",
          "module": "Control.StateAlgebra",
          "name": "Statte",
          "package": "liboleg",
          "partial": "Statte",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-StateAlgebra.html#t:Statte"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.StateAlgebra",
          "name": "Bind",
          "package": "liboleg",
          "signature": "Bind t f",
          "source": "src/Control-StateAlgebra.html#Bind",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control StateAlgebra",
          "module": "Control.StateAlgebra",
          "name": "Bind",
          "package": "liboleg",
          "partial": "Bind",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-StateAlgebra.html#v:Bind"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.StateAlgebra",
          "name": "Get",
          "package": "liboleg",
          "signature": "Get",
          "source": "src/Control-StateAlgebra.html#Get",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control StateAlgebra",
          "module": "Control.StateAlgebra",
          "name": "Get",
          "package": "liboleg",
          "partial": "Get",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-StateAlgebra.html#v:Get"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.StateAlgebra",
          "name": "Put",
          "package": "liboleg",
          "signature": "Put v",
          "source": "src/Control-StateAlgebra.html#Put",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control StateAlgebra",
          "module": "Control.StateAlgebra",
          "name": "Put",
          "package": "liboleg",
          "partial": "Put",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-StateAlgebra.html#v:Put"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.StateAlgebra",
          "name": "Return",
          "package": "liboleg",
          "signature": "Return v",
          "source": "src/Control-StateAlgebra.html#Return",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control StateAlgebra",
          "module": "Control.StateAlgebra",
          "name": "Return",
          "package": "liboleg",
          "partial": "Return",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-StateAlgebra.html#v:Return"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.StateAlgebra",
          "name": "Statte",
          "package": "liboleg",
          "signature": "Statte t",
          "source": "src/Control-StateAlgebra.html#Statte",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control StateAlgebra",
          "module": "Control.StateAlgebra",
          "name": "Statte",
          "package": "liboleg",
          "partial": "Statte",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-StateAlgebra.html#v:Statte"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWe can write computations expressed by term1 and term2 using\n the normal monadic syntax\n\u003c/p\u003e\u003cp\u003eThe following identity function is to resolve polymorphism, to tell\n that monadic terms below should use our representation of MonadState\n\u003c/p\u003e",
          "module": "Control.StateAlgebra",
          "name": "as_statte",
          "package": "liboleg",
          "signature": "Statte s a -\u003e Statte s a",
          "source": "src/Control-StateAlgebra.html#as_statte",
          "type": "function"
        },
        "index": {
          "description": "We can write computations expressed by term1 and term2 using the normal monadic syntax The following identity function is to resolve polymorphism to tell that monadic terms below should use our representation of MonadState",
          "hierarchy": "Control StateAlgebra",
          "module": "Control.StateAlgebra",
          "name": "as_statte",
          "normalized": "Statte a b-\u003eStatte a b",
          "package": "liboleg",
          "signature": "Statte s a-\u003eStatte s a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-StateAlgebra.html#v:as_statte"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.StateAlgebra",
          "name": "runbind",
          "package": "liboleg",
          "signature": "m -\u003e (a -\u003e t) -\u003e s -\u003e (s, b)",
          "source": "src/Control-StateAlgebra.html#runbind",
          "type": "method"
        },
        "index": {
          "hierarchy": "Control StateAlgebra",
          "module": "Control.StateAlgebra",
          "name": "runbind",
          "normalized": "a-\u003e(b-\u003ec)-\u003ed-\u003e(d,e)",
          "package": "liboleg",
          "signature": "m-\u003e(a-\u003et)-\u003es-\u003e(s,b)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-StateAlgebra.html#v:runbind"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.StateAlgebra",
          "name": "runst",
          "package": "liboleg",
          "signature": "t -\u003e s -\u003e (s, a)",
          "source": "src/Control-StateAlgebra.html#runst",
          "type": "method"
        },
        "index": {
          "hierarchy": "Control StateAlgebra",
          "module": "Control.StateAlgebra",
          "name": "runst",
          "normalized": "a-\u003eb-\u003e(b,c)",
          "package": "liboleg",
          "signature": "t-\u003es-\u003e(s,a)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-StateAlgebra.html#v:runst"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eVariable state monad\n\u003c/p\u003e\u003cp\u003e\u003ca\u003ehttp://okmij.org/ftp/Computation/monads.html#param-monad\u003c/a\u003e\n\u003c/p\u003e\u003cp\u003eThe familiar State monad lets us represent computations with a state that can be queried and\n  updated. The state must have the same type during the entire computation however. One sometimes\n  wants to express a computation where not only the value but also the type of the state can be\n  updated -- while maintaining static typing. We wish for a parameterized \u003ccode\u003emonad\u003c/code\u003e that indexes each\n  monadic type by an initial (type)state and a final (type)state. The effect of an effectful\n  computation thus becomes apparent in the type of the computation, and so can be statically\n  reasoned about.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Control.VarStateM",
          "name": "VarStateM",
          "package": "liboleg",
          "source": "src/Control-VarStateM.html",
          "type": "module"
        },
        "index": {
          "description": "Variable state monad http okmij.org ftp Computation monads.html param-monad The familiar State monad lets us represent computations with state that can be queried and updated The state must have the same type during the entire computation however One sometimes wants to express computation where not only the value but also the type of the state can be updated while maintaining static typing We wish for parameterized monad that indexes each monadic type by an initial type state and final type state The effect of an effectful computation thus becomes apparent in the type of the computation and so can be statically reasoned about",
          "hierarchy": "Control VarStateM",
          "module": "Control.VarStateM",
          "name": "VarStateM",
          "package": "liboleg",
          "partial": "Var State",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-VarStateM.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.VarStateM",
          "name": "LIO",
          "package": "liboleg",
          "source": "src/Control-VarStateM.html#LIO",
          "type": "data"
        },
        "index": {
          "hierarchy": "Control VarStateM",
          "module": "Control.VarStateM",
          "name": "LIO",
          "package": "liboleg",
          "partial": "LIO",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-VarStateM.html#t:LIO"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAnother example, to illustrate locking and static reasoning about\n the locking state\n\u003c/p\u003e",
          "module": "Control.VarStateM",
          "name": "Locked",
          "package": "liboleg",
          "source": "src/Control-VarStateM.html#Locked",
          "type": "data"
        },
        "index": {
          "description": "Another example to illustrate locking and static reasoning about the locking state",
          "hierarchy": "Control VarStateM",
          "module": "Control.VarStateM",
          "name": "Locked",
          "package": "liboleg",
          "partial": "Locked",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-VarStateM.html#t:Locked"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInject regular monads to be monadish things too\n\u003c/p\u003e",
          "module": "Control.VarStateM",
          "name": "MW",
          "package": "liboleg",
          "source": "src/Control-VarStateM.html#MW",
          "type": "newtype"
        },
        "index": {
          "description": "Inject regular monads to be monadish things too",
          "hierarchy": "Control VarStateM",
          "module": "Control.VarStateM",
          "name": "MW",
          "package": "liboleg",
          "partial": "MW",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-VarStateM.html#t:MW"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA parameterized \u003ccode\u003emonad\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Control.VarStateM",
          "name": "Monadish",
          "package": "liboleg",
          "source": "src/Control-VarStateM.html#Monadish",
          "type": "class"
        },
        "index": {
          "description": "parameterized monad",
          "hierarchy": "Control VarStateM",
          "module": "Control.VarStateM",
          "name": "Monadish",
          "package": "liboleg",
          "partial": "Monadish",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-VarStateM.html#t:Monadish"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.VarStateM",
          "name": "Unlocked",
          "package": "liboleg",
          "source": "src/Control-VarStateM.html#Unlocked",
          "type": "data"
        },
        "index": {
          "hierarchy": "Control VarStateM",
          "module": "Control.VarStateM",
          "name": "Unlocked",
          "package": "liboleg",
          "partial": "Unlocked",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-VarStateM.html#t:Unlocked"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFirst, use the regular Monad.State\n\u003c/p\u003e\u003cp\u003eNow, wrap in MW\n\u003c/p\u003e\u003cp\u003eIntroduce the variable-type state\n\u003c/p\u003e",
          "module": "Control.VarStateM",
          "name": "VST",
          "package": "liboleg",
          "source": "src/Control-VarStateM.html#VST",
          "type": "newtype"
        },
        "index": {
          "description": "First use the regular Monad.State Now wrap in MW Introduce the variable-type state",
          "hierarchy": "Control VarStateM",
          "module": "Control.VarStateM",
          "name": "VST",
          "package": "liboleg",
          "partial": "VST",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-VarStateM.html#t:VST"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.VarStateM",
          "name": "LIO",
          "package": "liboleg",
          "signature": "LIO",
          "source": "src/Control-VarStateM.html#LIO",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control VarStateM",
          "module": "Control.VarStateM",
          "name": "LIO",
          "package": "liboleg",
          "partial": "LIO",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-VarStateM.html#v:LIO"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.VarStateM",
          "name": "Locked",
          "package": "liboleg",
          "signature": "Locked",
          "source": "src/Control-VarStateM.html#Locked",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control VarStateM",
          "module": "Control.VarStateM",
          "name": "Locked",
          "package": "liboleg",
          "partial": "Locked",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-VarStateM.html#v:Locked"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.VarStateM",
          "name": "MW",
          "package": "liboleg",
          "signature": "MW",
          "source": "src/Control-VarStateM.html#MW",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control VarStateM",
          "module": "Control.VarStateM",
          "name": "MW",
          "package": "liboleg",
          "partial": "MW",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-VarStateM.html#v:MW"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.VarStateM",
          "name": "Unlocked",
          "package": "liboleg",
          "signature": "Unlocked",
          "source": "src/Control-VarStateM.html#Unlocked",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control VarStateM",
          "module": "Control.VarStateM",
          "name": "Unlocked",
          "package": "liboleg",
          "partial": "Unlocked",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-VarStateM.html#v:Unlocked"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.VarStateM",
          "name": "VST",
          "package": "liboleg",
          "signature": "VST",
          "source": "src/Control-VarStateM.html#VST",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control VarStateM",
          "module": "Control.VarStateM",
          "name": "VST",
          "package": "liboleg",
          "partial": "VST",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-VarStateM.html#v:VST"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTry polymorphic recursion, over the state.\n crec1 invokes itself, and changes the type of the state from\n some si to Bool.\n\u003c/p\u003e",
          "module": "Control.VarStateM",
          "name": "crec1",
          "package": "liboleg",
          "signature": "VST m si si Int",
          "source": "src/Control-VarStateM.html#crec1",
          "type": "function"
        },
        "index": {
          "description": "Try polymorphic recursion over the state crec1 invokes itself and changes the type of the state from some si to Bool",
          "hierarchy": "Control VarStateM",
          "module": "Control.VarStateM",
          "name": "crec1",
          "package": "liboleg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-VarStateM.html#v:crec1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.VarStateM",
          "name": "gbind",
          "package": "liboleg",
          "signature": "m p q a -\u003e (a -\u003e m q r b) -\u003e m p r b",
          "source": "src/Control-VarStateM.html#gbind",
          "type": "method"
        },
        "index": {
          "hierarchy": "Control VarStateM",
          "module": "Control.VarStateM",
          "name": "gbind",
          "normalized": "a b c d-\u003e(d-\u003ea c e f)-\u003ea b e f",
          "package": "liboleg",
          "signature": "m p q a-\u003e(a-\u003em q r b)-\u003em p r b",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-VarStateM.html#v:gbind"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.VarStateM",
          "name": "gret",
          "package": "liboleg",
          "signature": "a -\u003e m p p a",
          "source": "src/Control-VarStateM.html#gret",
          "type": "method"
        },
        "index": {
          "hierarchy": "Control VarStateM",
          "module": "Control.VarStateM",
          "name": "gret",
          "normalized": "a-\u003eb c c a",
          "package": "liboleg",
          "signature": "a-\u003em p p a",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-VarStateM.html#v:gret"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.VarStateM",
          "name": "lget",
          "package": "liboleg",
          "signature": "LIO p p String",
          "source": "src/Control-VarStateM.html#lget",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control VarStateM",
          "module": "Control.VarStateM",
          "name": "lget",
          "package": "liboleg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-VarStateM.html#v:lget"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.VarStateM",
          "name": "lock",
          "package": "liboleg",
          "signature": "LIO Unlocked Locked ()",
          "source": "src/Control-VarStateM.html#lock",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control VarStateM",
          "module": "Control.VarStateM",
          "name": "lock",
          "normalized": "LIO Unlocked Locked()",
          "package": "liboleg",
          "signature": "LIO Unlocked Locked()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-VarStateM.html#v:lock"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.VarStateM",
          "name": "lput",
          "package": "liboleg",
          "signature": "String -\u003e LIO p p ()",
          "source": "src/Control-VarStateM.html#lput",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control VarStateM",
          "module": "Control.VarStateM",
          "name": "lput",
          "normalized": "String-\u003eLIO a a()",
          "package": "liboleg",
          "signature": "String-\u003eLIO p p()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-VarStateM.html#v:lput"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.VarStateM",
          "name": "runVST",
          "package": "liboleg",
          "signature": "si -\u003e m (so, v)",
          "source": "src/Control-VarStateM.html#VST",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control VarStateM",
          "module": "Control.VarStateM",
          "name": "runVST",
          "normalized": "a-\u003eb(c,d)",
          "package": "liboleg",
          "partial": "VST",
          "signature": "si-\u003em(so,v)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-VarStateM.html#v:runVST"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.VarStateM",
          "name": "unLIO",
          "package": "liboleg",
          "signature": "IO a",
          "source": "src/Control-VarStateM.html#LIO",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control VarStateM",
          "module": "Control.VarStateM",
          "name": "unLIO",
          "package": "liboleg",
          "partial": "LIO",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-VarStateM.html#v:unLIO"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.VarStateM",
          "name": "unMW",
          "package": "liboleg",
          "signature": "m a",
          "source": "src/Control-VarStateM.html#MW",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control VarStateM",
          "module": "Control.VarStateM",
          "name": "unMW",
          "package": "liboleg",
          "partial": "MW",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-VarStateM.html#v:unMW"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.VarStateM",
          "name": "unlock",
          "package": "liboleg",
          "signature": "LIO Locked Unlocked ()",
          "source": "src/Control-VarStateM.html#unlock",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control VarStateM",
          "module": "Control.VarStateM",
          "name": "unlock",
          "normalized": "LIO Locked Unlocked()",
          "package": "liboleg",
          "signature": "LIO Locked Unlocked()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-VarStateM.html#v:unlock"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.VarStateM",
          "name": "vsget",
          "package": "liboleg",
          "signature": "VST m si si si",
          "source": "src/Control-VarStateM.html#vsget",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control VarStateM",
          "module": "Control.VarStateM",
          "name": "vsget",
          "package": "liboleg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-VarStateM.html#v:vsget"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.VarStateM",
          "name": "vsput",
          "package": "liboleg",
          "signature": "so -\u003e VST m si so ()",
          "source": "src/Control-VarStateM.html#vsput",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control VarStateM",
          "module": "Control.VarStateM",
          "name": "vsput",
          "normalized": "a-\u003eVST b c a()",
          "package": "liboleg",
          "signature": "so-\u003eVST m si so()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Control-VarStateM.html#v:vsput"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eHaskell with only one typeclass\n\u003c/p\u003e\u003cp\u003e\u003ca\u003ehttp://okmij.org/ftp/Haskell/Haskell1/Class1.hs\u003c/a\u003e\n\u003c/p\u003e\u003cp\u003e\u003ca\u003ehttp://okmij.org/ftp/Haskell/types.html#Haskell1\u003c/a\u003e\n\u003c/p\u003e\u003cp\u003eHow to make ad hoc overloading less ad hoc while defining no\n type classes.\n  For clarity, we call as Haskell1 the language Haskell98\n  with no typeclass declarations but with a single, pre-defined typeclass C\n  (which has two parameters related by a functional dependency).\n  The programmers may not declare any typeclasses; but they\n  may add instances to C and use them. We show on a series of examples that\n  despite the lack of typeclass declarations, Haskell1 can express all\n  the typeclass code of Haskell98 plus multi-parameter type classes\n  and even some (most useful?) functional dependencies.\n\u003c/p\u003e\u003cp\u003eHaskell1 is not a new language and requires no new compilers;\n  rather, it is a subset of the current Haskell. The \u003ccode\u003eremoval\u003c/code\u003e of typeclass\n  declarations is merely the matter of discipline.  \n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.Class1",
          "name": "Class1",
          "package": "liboleg",
          "source": "src/Data-Class1.html",
          "type": "module"
        },
        "index": {
          "description": "Haskell with only one typeclass http okmij.org ftp Haskell Haskell1 Class1.hs http okmij.org ftp Haskell types.html Haskell1 How to make ad hoc overloading less ad hoc while defining no type classes For clarity we call as Haskell1 the language Haskell98 with no typeclass declarations but with single pre-defined typeclass which has two parameters related by functional dependency The programmers may not declare any typeclasses but they may add instances to and use them We show on series of examples that despite the lack of typeclass declarations Haskell1 can express all the typeclass code of Haskell98 plus multi-parameter type classes and even some most useful functional dependencies Haskell1 is not new language and requires no new compilers rather it is subset of the current Haskell The removal of typeclass declarations is merely the matter of discipline",
          "hierarchy": "Data Class1",
          "module": "Data.Class1",
          "name": "Class1",
          "package": "liboleg",
          "partial": "Class",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Data-Class1.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExample 1: Building overloaded numeric functions, the analogue of Num.\n The following defines overloaded numeric functions `a la carte'. We\n shall see how to bundle such methods into what Haskell98 calls \u003ccode\u003eclasses\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Data.Class1",
          "name": "Add",
          "package": "liboleg",
          "source": "src/Data-Class1.html#Add",
          "type": "data"
        },
        "index": {
          "description": "Example Building overloaded numeric functions the analogue of Num The following defines overloaded numeric functions la carte We shall see how to bundle such methods into what Haskell98 calls classes",
          "hierarchy": "Data Class1",
          "module": "Data.Class1",
          "name": "Add",
          "package": "liboleg",
          "partial": "Add",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Data-Class1.html#t:Add"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Class1",
          "name": "BIND",
          "package": "liboleg",
          "source": "src/Data-Class1.html#BIND",
          "type": "data"
        },
        "index": {
          "hierarchy": "Data Class1",
          "module": "Data.Class1",
          "name": "BIND",
          "package": "liboleg",
          "partial": "BIND",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Data-Class1.html#t:BIND"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe one and only type class present in Haskell1\n\u003c/p\u003e",
          "module": "Data.Class1",
          "name": "C",
          "package": "liboleg",
          "source": "src/Data-Class1.html#C",
          "type": "class"
        },
        "index": {
          "description": "The one and only type class present in Haskell1",
          "hierarchy": "Data Class1",
          "module": "Data.Class1",
          "name": "C",
          "package": "liboleg",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Data-Class1.html#t:C"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWe now illustrate overloading over datatypes other than basic ones.\n We define dual numbers (see Wikipedia)\n\u003c/p\u003e",
          "module": "Data.Class1",
          "name": "Dual",
          "package": "liboleg",
          "source": "src/Data-Class1.html#Dual",
          "type": "data"
        },
        "index": {
          "description": "We now illustrate overloading over datatypes other than basic ones We define dual numbers see Wikipedia",
          "hierarchy": "Data Class1",
          "module": "Data.Class1",
          "name": "Dual",
          "package": "liboleg",
          "partial": "Dual",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Data-Class1.html#t:Dual"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Class1",
          "name": "FromInteger",
          "package": "liboleg",
          "source": "src/Data-Class1.html#FromInteger",
          "type": "data"
        },
        "index": {
          "hierarchy": "Data Class1",
          "module": "Data.Class1",
          "name": "FromInteger",
          "package": "liboleg",
          "partial": "From Integer",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Data-Class1.html#t:FromInteger"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFinally, we demonstrate overloading of non-functional values, such as\n minBound and maxBound. These are not \u003ccode\u003emethods\u003c/code\u003e in the classical sense.\n\u003c/p\u003e",
          "module": "Data.Class1",
          "name": "MinBound",
          "package": "liboleg",
          "source": "src/Data-Class1.html#MinBound",
          "type": "data"
        },
        "index": {
          "description": "Finally we demonstrate overloading of non-functional values such as minBound and maxBound These are not methods in the classical sense",
          "hierarchy": "Data Class1",
          "module": "Data.Class1",
          "name": "MinBound",
          "package": "liboleg",
          "partial": "Min Bound",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Data-Class1.html#t:MinBound"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Class1",
          "name": "Mul",
          "package": "liboleg",
          "source": "src/Data-Class1.html#Mul",
          "type": "data"
        },
        "index": {
          "hierarchy": "Data Class1",
          "module": "Data.Class1",
          "name": "Mul",
          "package": "liboleg",
          "partial": "Mul",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Data-Class1.html#t:Mul"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWe are defining a super-set of monads, so called `restricted monads'.\n Restricted monads include all ordinary monads; in addition, we can\n define a SET monad. See \n    \u003ca\u003ehttp://okmij.org/ftp/Haskell/types.html#restricted-datatypes\u003c/a\u003e\n\u003c/p\u003e",
          "module": "Data.Class1",
          "name": "RET",
          "package": "liboleg",
          "source": "src/Data-Class1.html#RET",
          "type": "data"
        },
        "index": {
          "description": "We are defining super-set of monads so called restricted monads Restricted monads include all ordinary monads in addition we can define SET monad See http okmij.org ftp Haskell types.html restricted-datatypes",
          "hierarchy": "Data Class1",
          "module": "Data.Class1",
          "name": "RET",
          "package": "liboleg",
          "partial": "RET",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Data-Class1.html#t:RET"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWe can define generic function at will, using already defined overloaded\n functions. For example,\n\u003c/p\u003e",
          "module": "Data.Class1",
          "name": "SHOW",
          "package": "liboleg",
          "source": "src/Data-Class1.html#SHOW",
          "type": "data"
        },
        "index": {
          "description": "We can define generic function at will using already defined overloaded functions For example",
          "hierarchy": "Data Class1",
          "module": "Data.Class1",
          "name": "SHOW",
          "package": "liboleg",
          "partial": "SHOW",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Data-Class1.html#t:SHOW"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWe can now define the generic addition. We use the operation +$\n to avoid the confusion with Prelude.(+)\n\u003c/p\u003e\u003cp\u003eIn H98, the overloaded addition was a method. In Haskell1, it is an\n ordinary (bounded polymorphic) function\n The signature looks a bit ugly; we'll see how to simplify it a bit\n\u003c/p\u003e",
          "module": "Data.Class1",
          "name": "(+$)",
          "package": "liboleg",
          "signature": "a -\u003e a -\u003e a",
          "source": "src/Data-Class1.html#%2B%24",
          "type": "function"
        },
        "index": {
          "description": "We can now define the generic addition We use the operation to avoid the confusion with Prelude In H98 the overloaded addition was method In Haskell1 it is an ordinary bounded polymorphic function The signature looks bit ugly we ll see how to simplify it bit",
          "hierarchy": "Data Class1",
          "module": "Data.Class1",
          "name": "(+$) +$",
          "normalized": "a-\u003ea-\u003ea",
          "package": "liboleg",
          "signature": "a-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Data-Class1.html#v:-43--36-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Class1",
          "name": "Dual",
          "package": "liboleg",
          "signature": "Dual a a",
          "source": "src/Data-Class1.html#Dual",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Class1",
          "module": "Data.Class1",
          "name": "Dual",
          "package": "liboleg",
          "partial": "Dual",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Data-Class1.html#v:Dual"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Class1",
          "name": "ac",
          "package": "liboleg",
          "signature": "l -\u003e t",
          "source": "src/Data-Class1.html#ac",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Class1",
          "module": "Data.Class1",
          "name": "ac",
          "normalized": "a-\u003eb",
          "package": "liboleg",
          "signature": "l-\u003et",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Data-Class1.html#v:ac"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Class1",
          "name": "bind",
          "package": "liboleg",
          "signature": "m a -\u003e (a -\u003e m b) -\u003e m b",
          "source": "src/Data-Class1.html#bind",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Class1",
          "module": "Data.Class1",
          "name": "bind",
          "normalized": "a b-\u003e(b-\u003ea c)-\u003ea c",
          "package": "liboleg",
          "signature": "m a-\u003e(a-\u003em b)-\u003em b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Data-Class1.html#v:bind"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eand the corresponding overloaded function (which in Haskell98 was a method)\n Again, we chose a slightly different name to avoid the confusion with\n the Prelude\n\u003c/p\u003e",
          "module": "Data.Class1",
          "name": "frmInteger",
          "package": "liboleg",
          "signature": "Integer -\u003e a",
          "source": "src/Data-Class1.html#frmInteger",
          "type": "function"
        },
        "index": {
          "description": "and the corresponding overloaded function which in Haskell98 was method Again we chose slightly different name to avoid the confusion with the Prelude",
          "hierarchy": "Data Class1",
          "module": "Data.Class1",
          "name": "frmInteger",
          "normalized": "Integer-\u003ea",
          "package": "liboleg",
          "partial": "Integer",
          "signature": "Integer-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Data-Class1.html#v:frmInteger"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Class1",
          "name": "mnBound",
          "package": "liboleg",
          "signature": "a",
          "source": "src/Data-Class1.html#mnBound",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Class1",
          "module": "Data.Class1",
          "name": "mnBound",
          "package": "liboleg",
          "partial": "Bound",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Data-Class1.html#v:mnBound"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Class1",
          "name": "mul_as",
          "package": "liboleg",
          "signature": "a -\u003e Mul a",
          "source": "src/Data-Class1.html#mul_as",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Class1",
          "module": "Data.Class1",
          "name": "mul_as",
          "normalized": "a-\u003eMul a",
          "package": "liboleg",
          "signature": "a-\u003eMul a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Data-Class1.html#v:mul_as"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eHere is a different, perhaps simpler, way of defining signatures of\n overloaded functions. The constraint C is inferred and no longer has\n to be mentioned explicitly\n\u003c/p\u003e",
          "module": "Data.Class1",
          "name": "mul_sig",
          "package": "liboleg",
          "signature": "a -\u003e a -\u003e a",
          "source": "src/Data-Class1.html#mul_sig",
          "type": "function"
        },
        "index": {
          "description": "Here is different perhaps simpler way of defining signatures of overloaded functions The constraint is inferred and no longer has to be mentioned explicitly",
          "hierarchy": "Data Class1",
          "module": "Data.Class1",
          "name": "mul_sig",
          "normalized": "a-\u003ea-\u003ea",
          "package": "liboleg",
          "signature": "a-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Data-Class1.html#v:mul_sig"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Class1",
          "name": "ret",
          "package": "liboleg",
          "signature": "a -\u003e m a",
          "source": "src/Data-Class1.html#ret",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Class1",
          "module": "Data.Class1",
          "name": "ret",
          "normalized": "a-\u003eb a",
          "package": "liboleg",
          "signature": "a-\u003em a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Data-Class1.html#v:ret"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Class1",
          "name": "shw",
          "package": "liboleg",
          "signature": "a -\u003e String",
          "source": "src/Data-Class1.html#shw",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Class1",
          "module": "Data.Class1",
          "name": "shw",
          "normalized": "a-\u003eString",
          "package": "liboleg",
          "signature": "a-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Data-Class1.html#v:shw"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eHaskell with only one typeclass\n\u003c/p\u003e\u003cp\u003e\u003ca\u003ehttp://okmij.org/ftp/Haskell/Haskell1/Class2.hs\u003c/a\u003e\n\u003c/p\u003e\u003cp\u003e\u003ca\u003ehttp://okmij.org/ftp/Haskell/types.html#Haskell1\u003c/a\u003e\n\u003c/p\u003e\u003cp\u003eHow to make ad hoc overloading less ad hoc while defining no\n type classes.\n Haskell1' -- the extension of Haskell1 with functional dependencies,\n and bounded-polymorphic higher-rank types\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.Class2",
          "name": "Class2",
          "package": "liboleg",
          "source": "src/Data-Class2.html",
          "type": "module"
        },
        "index": {
          "description": "Haskell with only one typeclass http okmij.org ftp Haskell Haskell1 Class2.hs http okmij.org ftp Haskell types.html Haskell1 How to make ad hoc overloading less ad hoc while defining no type classes Haskell1 the extension of Haskell1 with functional dependencies and bounded-polymorphic higher-rank types",
          "hierarchy": "Data Class2",
          "module": "Data.Class2",
          "name": "Class2",
          "package": "liboleg",
          "partial": "Class",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Data-Class2.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Class2",
          "name": "CLS",
          "package": "liboleg",
          "source": "src/Data-Class2.html#CLS",
          "type": "data"
        },
        "index": {
          "hierarchy": "Data Class2",
          "module": "Data.Class2",
          "name": "CLS",
          "package": "liboleg",
          "partial": "CLS",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Data-Class2.html#t:CLS"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Class2",
          "name": "CatchError",
          "package": "liboleg",
          "source": "src/Data-Class2.html#CatchError",
          "type": "data"
        },
        "index": {
          "hierarchy": "Data Class2",
          "module": "Data.Class2",
          "name": "CatchError",
          "package": "liboleg",
          "partial": "Catch Error",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Data-Class2.html#t:CatchError"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSome functional dependencies: implementing Monad Error\n As it turns out, some functional dependencies are expressible already\n in Haskell1. The example is MonadError, which in Haskell' has the form\n\u003c/p\u003e",
          "module": "Data.Class2",
          "name": "ERROR",
          "package": "liboleg",
          "source": "src/Data-Class2.html#ERROR",
          "type": "data"
        },
        "index": {
          "description": "Some functional dependencies implementing Monad Error As it turns out some functional dependencies are expressible already in Haskell1 The example is MonadError which in Haskell has the form",
          "hierarchy": "Data Class2",
          "module": "Data.Class2",
          "name": "ERROR",
          "package": "liboleg",
          "partial": "ERROR",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Data-Class2.html#t:ERROR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Class2",
          "name": "FC1",
          "package": "liboleg",
          "source": "src/Data-Class2.html#FC1",
          "type": "data"
        },
        "index": {
          "hierarchy": "Data Class2",
          "module": "Data.Class2",
          "name": "FC1",
          "package": "liboleg",
          "partial": "FC",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Data-Class2.html#t:FC1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Class2",
          "name": "FC2",
          "package": "liboleg",
          "source": "src/Data-Class2.html#FC2",
          "type": "data"
        },
        "index": {
          "hierarchy": "Data Class2",
          "module": "Data.Class2",
          "name": "FC2",
          "package": "liboleg",
          "partial": "FC",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Data-Class2.html#t:FC2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Class2",
          "name": "FC3",
          "package": "liboleg",
          "source": "src/Data-Class2.html#FC3",
          "type": "data"
        },
        "index": {
          "hierarchy": "Data Class2",
          "module": "Data.Class2",
          "name": "FC3",
          "package": "liboleg",
          "partial": "FC",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Data-Class2.html#t:FC3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Class2",
          "name": "FromList",
          "package": "liboleg",
          "source": "src/Data-Class2.html#FromList",
          "type": "data"
        },
        "index": {
          "hierarchy": "Data Class2",
          "module": "Data.Class2",
          "name": "FromList",
          "package": "liboleg",
          "partial": "From List",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Data-Class2.html#t:FromList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Class2",
          "name": "Index",
          "package": "liboleg",
          "source": "src/Data-Class2.html#Index",
          "type": "data"
        },
        "index": {
          "hierarchy": "Data Class2",
          "module": "Data.Class2",
          "name": "Index",
          "package": "liboleg",
          "partial": "Index",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Data-Class2.html#t:Index"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Class2",
          "name": "NUM",
          "package": "liboleg",
          "source": "src/Data-Class2.html#NUM",
          "type": "data"
        },
        "index": {
          "hierarchy": "Data Class2",
          "module": "Data.Class2",
          "name": "NUM",
          "package": "liboleg",
          "partial": "NUM",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Data-Class2.html#t:NUM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Class2",
          "name": "PACK",
          "package": "liboleg",
          "source": "src/Data-Class2.html#PACK",
          "type": "data"
        },
        "index": {
          "hierarchy": "Data Class2",
          "module": "Data.Class2",
          "name": "PACK",
          "package": "liboleg",
          "partial": "PACK",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Data-Class2.html#t:PACK"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Class2",
          "name": "ThrowError",
          "package": "liboleg",
          "source": "src/Data-Class2.html#ThrowError",
          "type": "data"
        },
        "index": {
          "hierarchy": "Data Class2",
          "module": "Data.Class2",
          "name": "ThrowError",
          "package": "liboleg",
          "partial": "Throw Error",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Data-Class2.html#t:ThrowError"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Class2",
          "name": "TypeCast",
          "package": "liboleg",
          "source": "src/Data-Class2.html#TypeCast",
          "type": "class"
        },
        "index": {
          "hierarchy": "Data Class2",
          "module": "Data.Class2",
          "name": "TypeCast",
          "package": "liboleg",
          "partial": "Type Cast",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Data-Class2.html#t:TypeCast"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Class2",
          "name": "TypeCast'",
          "package": "liboleg",
          "source": "src/Data-Class2.html#TypeCast%27",
          "type": "class"
        },
        "index": {
          "hierarchy": "Data Class2",
          "module": "Data.Class2",
          "name": "TypeCast'",
          "package": "liboleg",
          "partial": "Type Cast'",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Data-Class2.html#t:TypeCast-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Class2",
          "name": "TypeCast''",
          "package": "liboleg",
          "source": "src/Data-Class2.html#TypeCast%27%27",
          "type": "class"
        },
        "index": {
          "hierarchy": "Data Class2",
          "module": "Data.Class2",
          "name": "TypeCast''",
          "package": "liboleg",
          "partial": "Type Cast''",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Data-Class2.html#t:TypeCast-39--39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Class2",
          "name": "(*$$)",
          "package": "liboleg",
          "signature": "a -\u003e a -\u003e a",
          "source": "src/Data-Class2.html#%2A%24%24",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Class2",
          "module": "Data.Class2",
          "name": "(*$$) *$$",
          "normalized": "a-\u003ea-\u003ea",
          "package": "liboleg",
          "signature": "a-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Data-Class2.html#v:-42--36--36-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Class2",
          "name": "(+$$)",
          "package": "liboleg",
          "signature": "a -\u003e a -\u003e a",
          "source": "src/Data-Class2.html#%2B%24%24",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Class2",
          "module": "Data.Class2",
          "name": "(+$$) +$$",
          "normalized": "a-\u003ea-\u003ea",
          "package": "liboleg",
          "signature": "a-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Data-Class2.html#v:-43--36--36-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Class2",
          "name": "NUM",
          "package": "liboleg",
          "signature": "NUM",
          "source": "src/Data-Class2.html#NUM",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Class2",
          "module": "Data.Class2",
          "name": "NUM",
          "package": "liboleg",
          "partial": "NUM",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Data-Class2.html#v:NUM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Class2",
          "name": "PACK",
          "package": "liboleg",
          "signature": "PACK a",
          "source": "src/Data-Class2.html#PACK",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Class2",
          "module": "Data.Class2",
          "name": "PACK",
          "package": "liboleg",
          "partial": "PACK",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Data-Class2.html#v:PACK"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Class2",
          "name": "catchError",
          "package": "liboleg",
          "signature": "m a -\u003e (e -\u003e m a) -\u003e m a",
          "source": "src/Data-Class2.html#catchError",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Class2",
          "module": "Data.Class2",
          "name": "catchError",
          "normalized": "a b-\u003e(c-\u003ea b)-\u003ea b",
          "package": "liboleg",
          "partial": "Error",
          "signature": "m a-\u003e(e-\u003em a)-\u003em a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Data-Class2.html#v:catchError"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Class2",
          "name": "fc1",
          "package": "liboleg",
          "signature": "a -\u003e b -\u003e c",
          "source": "src/Data-Class2.html#fc1",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Class2",
          "module": "Data.Class2",
          "name": "fc1",
          "normalized": "a-\u003eb-\u003ec",
          "package": "liboleg",
          "signature": "a-\u003eb-\u003ec",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Data-Class2.html#v:fc1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Class2",
          "name": "fc2",
          "package": "liboleg",
          "signature": "a -\u003e b -\u003e c",
          "source": "src/Data-Class2.html#fc2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Class2",
          "module": "Data.Class2",
          "name": "fc2",
          "normalized": "a-\u003eb-\u003ec",
          "package": "liboleg",
          "signature": "a-\u003eb-\u003ec",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Data-Class2.html#v:fc2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Class2",
          "name": "fc3",
          "package": "liboleg",
          "signature": "a -\u003e b -\u003e c",
          "source": "src/Data-Class2.html#fc3",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Class2",
          "module": "Data.Class2",
          "name": "fc3",
          "normalized": "a-\u003eb-\u003ec",
          "package": "liboleg",
          "signature": "a-\u003eb-\u003ec",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Data-Class2.html#v:fc3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Class2",
          "name": "fromList",
          "package": "liboleg",
          "signature": "Int -\u003e [e] -\u003e array",
          "source": "src/Data-Class2.html#fromList",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Class2",
          "module": "Data.Class2",
          "name": "fromList",
          "normalized": "Int-\u003e[a]-\u003eb",
          "package": "liboleg",
          "partial": "List",
          "signature": "Int-\u003e[e]-\u003earray",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Data-Class2.html#v:fromList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Class2",
          "name": "indexA",
          "package": "liboleg",
          "signature": "array -\u003e Int -\u003e e",
          "source": "src/Data-Class2.html#indexA",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Class2",
          "module": "Data.Class2",
          "name": "indexA",
          "normalized": "a-\u003eInt-\u003eb",
          "package": "liboleg",
          "signature": "array-\u003eInt-\u003ee",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Data-Class2.html#v:indexA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Class2",
          "name": "nfromI",
          "package": "liboleg",
          "signature": "Integer -\u003e a",
          "source": "src/Data-Class2.html#nfromI",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Class2",
          "module": "Data.Class2",
          "name": "nfromI",
          "normalized": "Integer-\u003ea",
          "package": "liboleg",
          "signature": "Integer-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Data-Class2.html#v:nfromI"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Class2",
          "name": "nm_add",
          "package": "liboleg",
          "signature": "a -\u003e a -\u003e a",
          "source": "src/Data-Class2.html#NUM",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Class2",
          "module": "Data.Class2",
          "name": "nm_add",
          "normalized": "a-\u003ea-\u003ea",
          "package": "liboleg",
          "signature": "a-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Data-Class2.html#v:nm_add"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Class2",
          "name": "nm_fromInteger",
          "package": "liboleg",
          "signature": "Integer -\u003e a",
          "source": "src/Data-Class2.html#NUM",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Class2",
          "module": "Data.Class2",
          "name": "nm_fromInteger",
          "normalized": "Integer-\u003ea",
          "package": "liboleg",
          "partial": "Integer",
          "signature": "Integer-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Data-Class2.html#v:nm_fromInteger"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Class2",
          "name": "nm_mul",
          "package": "liboleg",
          "signature": "a -\u003e a -\u003e a",
          "source": "src/Data-Class2.html#NUM",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Class2",
          "module": "Data.Class2",
          "name": "nm_mul",
          "normalized": "a-\u003ea-\u003ea",
          "package": "liboleg",
          "signature": "a-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Data-Class2.html#v:nm_mul"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Class2",
          "name": "nm_show",
          "package": "liboleg",
          "signature": "a -\u003e String",
          "source": "src/Data-Class2.html#NUM",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Class2",
          "module": "Data.Class2",
          "name": "nm_show",
          "normalized": "a-\u003eString",
          "package": "liboleg",
          "signature": "a-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Data-Class2.html#v:nm_show"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Class2",
          "name": "nshw",
          "package": "liboleg",
          "signature": "a -\u003e String",
          "source": "src/Data-Class2.html#nshw",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Class2",
          "module": "Data.Class2",
          "name": "nshw",
          "normalized": "a-\u003eString",
          "package": "liboleg",
          "signature": "a-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Data-Class2.html#v:nshw"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Class2",
          "name": "strMsg",
          "package": "liboleg",
          "signature": "String -\u003e a",
          "source": "src/Data-Class2.html#strMsg",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Class2",
          "module": "Data.Class2",
          "name": "strMsg",
          "normalized": "String-\u003ea",
          "package": "liboleg",
          "partial": "Msg",
          "signature": "String-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Data-Class2.html#v:strMsg"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Class2",
          "name": "throwError",
          "package": "liboleg",
          "signature": "e -\u003e m a",
          "source": "src/Data-Class2.html#throwError",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Class2",
          "module": "Data.Class2",
          "name": "throwError",
          "normalized": "a-\u003eb c",
          "package": "liboleg",
          "partial": "Error",
          "signature": "e-\u003em a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Data-Class2.html#v:throwError"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Class2",
          "name": "typeCast",
          "package": "liboleg",
          "signature": "a -\u003e b",
          "source": "src/Data-Class2.html#typeCast",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Class2",
          "module": "Data.Class2",
          "name": "typeCast",
          "normalized": "a-\u003eb",
          "package": "liboleg",
          "partial": "Cast",
          "signature": "a-\u003eb",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Data-Class2.html#v:typeCast"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Class2",
          "name": "typeCast'",
          "package": "liboleg",
          "signature": "t -\u003e a -\u003e b",
          "source": "src/Data-Class2.html#typeCast%27",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Class2",
          "module": "Data.Class2",
          "name": "typeCast'",
          "normalized": "a-\u003eb-\u003ec",
          "package": "liboleg",
          "partial": "Cast'",
          "signature": "t-\u003ea-\u003eb",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Data-Class2.html#v:typeCast-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Class2",
          "name": "typeCast''",
          "package": "liboleg",
          "signature": "t -\u003e a -\u003e b",
          "source": "src/Data-Class2.html#typeCast%27%27",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Class2",
          "module": "Data.Class2",
          "name": "typeCast''",
          "normalized": "a-\u003eb-\u003ec",
          "package": "liboleg",
          "partial": "Cast''",
          "signature": "t-\u003ea-\u003eb",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Data-Class2.html#v:typeCast-39--39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eHaskell98\n\u003c/p\u003e\u003cp\u003e\u003ca\u003ehttp://okmij.org/ftp/Algorithms.html#pure-cyclic-list\u003c/a\u003e\n\u003c/p\u003e\u003cp\u003ePure functional, mutation-free, constant-time-access double-linked\n lists\n\u003c/p\u003e\u003cp\u003eNote that insertions, deletions, lookups have\n a worst-case complexity of O(min(n,W)), where W is either 32 or 64\n (depending on the paltform). That means the access time is bounded\n by a small constant (32 or 64). \n\u003c/p\u003e\u003cp\u003e\u003cem\u003ePure functional, mutation-free, efficient double-linked lists\u003c/em\u003e\n\u003c/p\u003e\u003cp\u003eIt is always an interesting challenge to write a pure functional and efficient implementation of\n     an imperative algorithm destructively operating a data structure. The functional implementation\n     has a significant benefit of equational reasoning and modularity. We can comprehend the algorithm\n     without keeping the implicit global state in mind. The mutation-free, functional realization has\n     practical benefits: the ease of adding checkpointing, undo and redo. The absence of mutations\n     makes the code multi-threading-safe and helps in porting to distributed or non-shared-memory\n     parallel architectures. On the other hand, an imperative implementation has the advantage of\n     optimality: mutating a component in a complex data structure is a constant-time operation, at\n     least on conventional architectures. Imperative code makes sharing explicit, and so permits\n     efficient implementation of cyclic data structures.\n\u003c/p\u003e\u003cp\u003eWe show a simple example of achieving all the benefits of an imperative data structure --\n     including sharing and the efficiency of updates -- in a pure functional program. Our data\n     structure is a doubly-linked, possibly cyclic list, with the standard operations of adding,\n     deleting and updating elements; traversing the list in both directions; iterating over the list,\n     with cycle detection. The code:\n\u003c/p\u003e\u003cp\u003e uniformly handles both cyclic and terminated lists;\n        does not rebuild the whole list on updates;\n        updates the value in the current node in time bound by a small constant;\n        does not use or mention any monads;\n        does not use any IORef, STRef, TVars, or any other destructive updates;\n        permits the logging, undoing and redoing of updates, checkpointing;\n        easily generalizes to two-dimensional meshes.\n\u003c/p\u003e\u003cp\u003eThe algorithm is essentially imperative, thus permitting identity checking and in-place\n     \u003ccode\u003eupdates\u003c/code\u003e, but implemented purely functionally. Although the code uses many local, type safe\n     \u003ccode\u003eheaps\u003c/code\u003e, there is emphatically no global heap and no global state.\n\u003c/p\u003e\u003cp\u003eVersion: The current version is 1.2, Jan 7, 2009.\n\u003c/p\u003e\u003cp\u003eReferences\n\u003c/p\u003e\u003cp\u003eHaskell-Cafe discussion ``Updating doubly linked lists''. January 2009\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.FDList",
          "name": "FDList",
          "package": "liboleg",
          "source": "src/Data-FDList.html",
          "type": "module"
        },
        "index": {
          "description": "Haskell98 http okmij.org ftp Algorithms.html pure-cyclic-list Pure functional mutation-free constant-time-access double-linked lists Note that insertions deletions lookups have worst-case complexity of min where is either or depending on the paltform That means the access time is bounded by small constant or Pure functional mutation-free efficient double-linked lists It is always an interesting challenge to write pure functional and efficient implementation of an imperative algorithm destructively operating data structure The functional implementation has significant benefit of equational reasoning and modularity We can comprehend the algorithm without keeping the implicit global state in mind The mutation-free functional realization has practical benefits the ease of adding checkpointing undo and redo The absence of mutations makes the code multi-threading-safe and helps in porting to distributed or non-shared-memory parallel architectures On the other hand an imperative implementation has the advantage of optimality mutating component in complex data structure is constant-time operation at least on conventional architectures Imperative code makes sharing explicit and so permits efficient implementation of cyclic data structures We show simple example of achieving all the benefits of an imperative data structure including sharing and the efficiency of updates in pure functional program Our data structure is doubly-linked possibly cyclic list with the standard operations of adding deleting and updating elements traversing the list in both directions iterating over the list with cycle detection The code uniformly handles both cyclic and terminated lists does not rebuild the whole list on updates updates the value in the current node in time bound by small constant does not use or mention any monads does not use any IORef STRef TVars or any other destructive updates permits the logging undoing and redoing of updates checkpointing easily generalizes to two-dimensional meshes The algorithm is essentially imperative thus permitting identity checking and in-place updates but implemented purely functionally Although the code uses many local type safe heaps there is emphatically no global heap and no global state Version The current version is Jan References Haskell-Cafe discussion Updating doubly linked lists January",
          "hierarchy": "Data FDList",
          "module": "Data.FDList",
          "name": "FDList",
          "package": "liboleg",
          "partial": "FDList",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Data-FDList.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eBecause DList contains the \u003ccode\u003epointer\u003c/code\u003e to the current element, DList\n is also a Zipper\n\u003c/p\u003e",
          "module": "Data.FDList",
          "name": "DList",
          "package": "liboleg",
          "source": "src/Data-FDList.html#DList",
          "type": "data"
        },
        "index": {
          "description": "Because DList contains the pointer to the current element DList is also Zipper",
          "hierarchy": "Data FDList",
          "module": "Data.FDList",
          "name": "DList",
          "package": "liboleg",
          "partial": "DList",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Data-FDList.html#t:DList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.FDList",
          "name": "Node",
          "package": "liboleg",
          "source": "src/Data-FDList.html#Node",
          "type": "data"
        },
        "index": {
          "hierarchy": "Data FDList",
          "module": "Data.FDList",
          "name": "Node",
          "package": "liboleg",
          "partial": "Node",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Data-FDList.html#t:Node"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRepresentation of the double-linked list\n\u003c/p\u003e",
          "module": "Data.FDList",
          "name": "Ref",
          "package": "liboleg",
          "source": "src/Data-FDList.html#Ref",
          "type": "type"
        },
        "index": {
          "description": "Representation of the double-linked list",
          "hierarchy": "Data FDList",
          "module": "Data.FDList",
          "name": "Ref",
          "package": "liboleg",
          "partial": "Ref",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Data-FDList.html#t:Ref"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.FDList",
          "name": "DList",
          "package": "liboleg",
          "signature": "DList",
          "source": "src/Data-FDList.html#DList",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data FDList",
          "module": "Data.FDList",
          "name": "DList",
          "package": "liboleg",
          "partial": "DList",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Data-FDList.html#v:DList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.FDList",
          "name": "Node",
          "package": "liboleg",
          "signature": "Node",
          "source": "src/Data-FDList.html#Node",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data FDList",
          "module": "Data.FDList",
          "name": "Node",
          "package": "liboleg",
          "partial": "Node",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Data-FDList.html#v:Node"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDelete the current element from a non-empty list\n We can handle both cyclic and terminated lists\n The right node becomes the current node.\n If the right node does not exists, the left node becomes current\n\u003c/p\u003e",
          "module": "Data.FDList",
          "name": "delete",
          "package": "liboleg",
          "signature": "DList a -\u003e DList a",
          "source": "src/Data-FDList.html#delete",
          "type": "function"
        },
        "index": {
          "description": "Delete the current element from non-empty list We can handle both cyclic and terminated lists The right node becomes the current node If the right node does not exists the left node becomes current",
          "hierarchy": "Data FDList",
          "module": "Data.FDList",
          "name": "delete",
          "normalized": "DList a-\u003eDList a",
          "package": "liboleg",
          "signature": "DList a-\u003eDList a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Data-FDList.html#v:delete"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.FDList",
          "name": "dl_counter",
          "package": "liboleg",
          "signature": "Ref",
          "source": "src/Data-FDList.html#DList",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data FDList",
          "module": "Data.FDList",
          "name": "dl_counter",
          "package": "liboleg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Data-FDList.html#v:dl_counter"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.FDList",
          "name": "dl_current",
          "package": "liboleg",
          "signature": "Ref",
          "source": "src/Data-FDList.html#DList",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data FDList",
          "module": "Data.FDList",
          "name": "dl_current",
          "package": "liboleg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Data-FDList.html#v:dl_current"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.FDList",
          "name": "dl_mem",
          "package": "liboleg",
          "signature": "IntMap (Node a)",
          "source": "src/Data-FDList.html#DList",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data FDList",
          "module": "Data.FDList",
          "name": "dl_mem",
          "package": "liboleg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Data-FDList.html#v:dl_mem"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eOperations on the DList a\n\u003c/p\u003e",
          "module": "Data.FDList",
          "name": "empty",
          "package": "liboleg",
          "signature": "DList a",
          "source": "src/Data-FDList.html#empty",
          "type": "function"
        },
        "index": {
          "description": "Operations on the DList",
          "hierarchy": "Data FDList",
          "module": "Data.FDList",
          "name": "empty",
          "package": "liboleg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Data-FDList.html#v:empty"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.FDList",
          "name": "fromList",
          "package": "liboleg",
          "signature": "[a] -\u003e DList a",
          "source": "src/Data-FDList.html#fromList",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data FDList",
          "module": "Data.FDList",
          "name": "fromList",
          "normalized": "[a]-\u003eDList a",
          "package": "liboleg",
          "partial": "List",
          "signature": "[a]-\u003eDList a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Data-FDList.html#v:fromList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.FDList",
          "name": "get_curr",
          "package": "liboleg",
          "signature": "DList a -\u003e a",
          "source": "src/Data-FDList.html#get_curr",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data FDList",
          "module": "Data.FDList",
          "name": "get_curr",
          "normalized": "DList a-\u003ea",
          "package": "liboleg",
          "signature": "DList a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Data-FDList.html#v:get_curr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eauxiliary function\n\u003c/p\u003e",
          "module": "Data.FDList",
          "name": "get_curr_node",
          "package": "liboleg",
          "signature": "DList a -\u003e Node a",
          "source": "src/Data-FDList.html#get_curr_node",
          "type": "function"
        },
        "index": {
          "description": "auxiliary function",
          "hierarchy": "Data FDList",
          "module": "Data.FDList",
          "name": "get_curr_node",
          "normalized": "DList a-\u003eNode a",
          "package": "liboleg",
          "signature": "DList a-\u003eNode a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Data-FDList.html#v:get_curr_node"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe insert operation below makes a cyclic list\n The other operations don't care\n Insert to the right of the current element, if any\n Return the DL where the inserted node is the current one\n\u003c/p\u003e",
          "module": "Data.FDList",
          "name": "insert_right",
          "package": "liboleg",
          "signature": "a -\u003e DList a -\u003e DList a",
          "source": "src/Data-FDList.html#insert_right",
          "type": "function"
        },
        "index": {
          "description": "The insert operation below makes cyclic list The other operations don care Insert to the right of the current element if any Return the DL where the inserted node is the current one",
          "hierarchy": "Data FDList",
          "module": "Data.FDList",
          "name": "insert_right",
          "normalized": "a-\u003eDList a-\u003eDList a",
          "package": "liboleg",
          "signature": "a-\u003eDList a-\u003eDList a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Data-FDList.html#v:insert_right"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.FDList",
          "name": "is_empty",
          "package": "liboleg",
          "signature": "DList a -\u003e Bool",
          "source": "src/Data-FDList.html#is_empty",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data FDList",
          "module": "Data.FDList",
          "name": "is_empty",
          "normalized": "DList a-\u003eBool",
          "package": "liboleg",
          "signature": "DList a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Data-FDList.html#v:is_empty"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.FDList",
          "name": "move_left",
          "package": "liboleg",
          "signature": "DList a -\u003e Maybe (DList a)",
          "source": "src/Data-FDList.html#move_left",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data FDList",
          "module": "Data.FDList",
          "name": "move_left",
          "normalized": "DList a-\u003eMaybe(DList a)",
          "package": "liboleg",
          "signature": "DList a-\u003eMaybe(DList a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Data-FDList.html#v:move_left"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIf no left, just stay inplace\n\u003c/p\u003e",
          "module": "Data.FDList",
          "name": "move_left'",
          "package": "liboleg",
          "signature": "DList a -\u003e DList a",
          "source": "src/Data-FDList.html#move_left%27",
          "type": "function"
        },
        "index": {
          "description": "If no left just stay inplace",
          "hierarchy": "Data FDList",
          "module": "Data.FDList",
          "name": "move_left'",
          "normalized": "DList a-\u003eDList a",
          "package": "liboleg",
          "signature": "DList a-\u003eDList a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Data-FDList.html#v:move_left-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.FDList",
          "name": "move_right",
          "package": "liboleg",
          "signature": "DList a -\u003e Maybe (DList a)",
          "source": "src/Data-FDList.html#move_right",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data FDList",
          "module": "Data.FDList",
          "name": "move_right",
          "normalized": "DList a-\u003eMaybe(DList a)",
          "package": "liboleg",
          "signature": "DList a-\u003eMaybe(DList a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Data-FDList.html#v:move_right"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIf no right, just stay inplace\n\u003c/p\u003e",
          "module": "Data.FDList",
          "name": "move_right'",
          "package": "liboleg",
          "signature": "DList a -\u003e DList a",
          "source": "src/Data-FDList.html#move_right%27",
          "type": "function"
        },
        "index": {
          "description": "If no right just stay inplace",
          "hierarchy": "Data FDList",
          "module": "Data.FDList",
          "name": "move_right'",
          "normalized": "DList a-\u003eDList a",
          "package": "liboleg",
          "signature": "DList a-\u003eDList a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Data-FDList.html#v:move_right-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.FDList",
          "name": "node_left",
          "package": "liboleg",
          "signature": "Ref",
          "source": "src/Data-FDList.html#Node",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data FDList",
          "module": "Data.FDList",
          "name": "node_left",
          "package": "liboleg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Data-FDList.html#v:node_left"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.FDList",
          "name": "node_right",
          "package": "liboleg",
          "signature": "Ref",
          "source": "src/Data-FDList.html#Node",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data FDList",
          "module": "Data.FDList",
          "name": "node_right",
          "package": "liboleg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Data-FDList.html#v:node_right"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.FDList",
          "name": "node_val",
          "package": "liboleg",
          "signature": "a",
          "source": "src/Data-FDList.html#Node",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data FDList",
          "module": "Data.FDList",
          "name": "node_val",
          "package": "liboleg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Data-FDList.html#v:node_val"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe following does not anticipate cycles (deliberately)\n\u003c/p\u003e",
          "module": "Data.FDList",
          "name": "takeDL",
          "package": "liboleg",
          "signature": "Int -\u003e DList a -\u003e [a]",
          "source": "src/Data-FDList.html#takeDL",
          "type": "function"
        },
        "index": {
          "description": "The following does not anticipate cycles deliberately",
          "hierarchy": "Data FDList",
          "module": "Data.FDList",
          "name": "takeDL",
          "normalized": "Int-\u003eDList a-\u003e[a]",
          "package": "liboleg",
          "partial": "DL",
          "signature": "Int-\u003eDList a-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Data-FDList.html#v:takeDL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReverse taking: we move left\n\u003c/p\u003e",
          "module": "Data.FDList",
          "name": "takeDLrev",
          "package": "liboleg",
          "signature": "Int -\u003e DList a -\u003e [a]",
          "source": "src/Data-FDList.html#takeDLrev",
          "type": "function"
        },
        "index": {
          "description": "Reverse taking we move left",
          "hierarchy": "Data FDList",
          "module": "Data.FDList",
          "name": "takeDLrev",
          "normalized": "Int-\u003eDList a-\u003e[a]",
          "package": "liboleg",
          "partial": "DLrev",
          "signature": "Int-\u003eDList a-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Data-FDList.html#v:takeDLrev"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis one watches for a cycle and terminates when it detects one\n\u003c/p\u003e",
          "module": "Data.FDList",
          "name": "toList",
          "package": "liboleg",
          "signature": "DList a -\u003e [a]",
          "source": "src/Data-FDList.html#toList",
          "type": "function"
        },
        "index": {
          "description": "This one watches for cycle and terminates when it detects one",
          "hierarchy": "Data FDList",
          "module": "Data.FDList",
          "name": "toList",
          "normalized": "DList a-\u003e[a]",
          "package": "liboleg",
          "partial": "List",
          "signature": "DList a-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Data-FDList.html#v:toList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUpdate the current node \u003ccode\u003einplace\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Data.FDList",
          "name": "update",
          "package": "liboleg",
          "signature": "a -\u003e DList a -\u003e DList a",
          "source": "src/Data-FDList.html#update",
          "type": "function"
        },
        "index": {
          "description": "Update the current node inplace",
          "hierarchy": "Data FDList",
          "module": "Data.FDList",
          "name": "update",
          "normalized": "a-\u003eDList a-\u003eDList a",
          "package": "liboleg",
          "signature": "a-\u003eDList a-\u003eDList a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Data-FDList.html#v:update"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIn a well-formed list, dl_current must point to a valid node\n All operations below preserve well-formedness\n\u003c/p\u003e",
          "module": "Data.FDList",
          "name": "well_formed",
          "package": "liboleg",
          "signature": "DList a -\u003e Bool",
          "source": "src/Data-FDList.html#well_formed",
          "type": "function"
        },
        "index": {
          "description": "In well-formed list dl current must point to valid node All operations below preserve well-formedness",
          "hierarchy": "Data FDList",
          "module": "Data.FDList",
          "name": "well_formed",
          "normalized": "DList a-\u003eBool",
          "package": "liboleg",
          "signature": "DList a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Data-FDList.html#v:well_formed"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eIllustration of the 2-order lambda-calculus, \n using Church numerals as an example.\n The example shows limited impredicativity\n\u003c/p\u003e\u003cp\u003e\u003ca\u003ehttp://okmij.org/ftp/Haskell/types.html#some-impredicativity\u003c/a\u003e\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.Numerals",
          "name": "Numerals",
          "package": "liboleg",
          "source": "src/Data-Numerals.html",
          "type": "module"
        },
        "index": {
          "description": "Illustration of the order lambda-calculus using Church numerals as an example The example shows limited impredicativity http okmij.org ftp Haskell types.html some-impredicativity",
          "hierarchy": "Data Numerals",
          "module": "Data.Numerals",
          "name": "Numerals",
          "package": "liboleg",
          "partial": "Numerals",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Data-Numerals.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Numerals",
          "name": "N",
          "package": "liboleg",
          "source": "src/Data-Numerals.html#N",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "Data Numerals",
          "module": "Data.Numerals",
          "name": "N",
          "package": "liboleg",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Data-Numerals.html#t:N"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Numerals",
          "name": "W",
          "package": "liboleg",
          "source": "src/Data-Numerals.html#W",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "Data Numerals",
          "module": "Data.Numerals",
          "name": "W",
          "package": "liboleg",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Data-Numerals.html#t:W"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Numerals",
          "name": "N",
          "package": "liboleg",
          "signature": "N (forall a.  (a -\u003e a) -\u003e a -\u003e a)",
          "source": "src/Data-Numerals.html#N",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Numerals",
          "module": "Data.Numerals",
          "name": "N",
          "normalized": "N(a b(c-\u003ec)-\u003ec-\u003ec)",
          "package": "liboleg",
          "signature": "N(forall a.(a-\u003ea)-\u003ea-\u003ea)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Data-Numerals.html#v:N"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Numerals",
          "name": "W",
          "package": "liboleg",
          "signature": "W",
          "source": "src/Data-Numerals.html#W",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Numerals",
          "module": "Data.Numerals",
          "name": "W",
          "package": "liboleg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Data-Numerals.html#v:W"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Numerals",
          "name": "add",
          "package": "liboleg",
          "signature": "N -\u003e N -\u003e N",
          "source": "src/Data-Numerals.html#add",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Numerals",
          "module": "Data.Numerals",
          "name": "add",
          "normalized": "N-\u003eN-\u003eN",
          "package": "liboleg",
          "signature": "N-\u003eN-\u003eN",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Data-Numerals.html#v:add"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Numerals",
          "name": "exp",
          "package": "liboleg",
          "signature": "N -\u003e N -\u003e N",
          "source": "src/Data-Numerals.html#exp",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Numerals",
          "module": "Data.Numerals",
          "name": "exp",
          "normalized": "N-\u003eN-\u003eN",
          "package": "liboleg",
          "signature": "N-\u003eN-\u003eN",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Data-Numerals.html#v:exp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Numerals",
          "name": "exp2",
          "package": "liboleg",
          "signature": "N -\u003e N -\u003e N",
          "source": "src/Data-Numerals.html#exp2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Numerals",
          "module": "Data.Numerals",
          "name": "exp2",
          "normalized": "N-\u003eN-\u003eN",
          "package": "liboleg",
          "signature": "N-\u003eN-\u003eN",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Data-Numerals.html#v:exp2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSimpler illustrations of impredicativity\n\u003c/p\u003e",
          "module": "Data.Numerals",
          "name": "f1",
          "package": "liboleg",
          "signature": "(forall a.  a -\u003e a) -\u003e b -\u003e b",
          "source": "src/Data-Numerals.html#f1",
          "type": "function"
        },
        "index": {
          "description": "Simpler illustrations of impredicativity",
          "hierarchy": "Data Numerals",
          "module": "Data.Numerals",
          "name": "f1",
          "normalized": "(a b c-\u003ec)-\u003ed-\u003ed",
          "package": "liboleg",
          "signature": "(forall a. a-\u003ea)-\u003eb-\u003eb",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Data-Numerals.html#v:f1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Numerals",
          "name": "f2",
          "package": "liboleg",
          "signature": "W -\u003e b -\u003e b",
          "source": "src/Data-Numerals.html#f2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Numerals",
          "module": "Data.Numerals",
          "name": "f2",
          "normalized": "W-\u003ea-\u003ea",
          "package": "liboleg",
          "signature": "W-\u003eb-\u003eb",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Data-Numerals.html#v:f2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Numerals",
          "name": "foo",
          "package": "liboleg",
          "signature": "forall c notimportant.  (c -\u003e c) -\u003e notimportant",
          "source": "src/Data-Numerals.html#foo",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Numerals",
          "module": "Data.Numerals",
          "name": "foo",
          "normalized": "a b c(b-\u003eb)-\u003ed",
          "package": "liboleg",
          "signature": "forall c notimportant.(c-\u003ec)-\u003enotimportant",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Data-Numerals.html#v:foo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Numerals",
          "name": "mul",
          "package": "liboleg",
          "signature": "N -\u003e N -\u003e N",
          "source": "src/Data-Numerals.html#mul",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Numerals",
          "module": "Data.Numerals",
          "name": "mul",
          "normalized": "N-\u003eN-\u003eN",
          "package": "liboleg",
          "signature": "N-\u003eN-\u003eN",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Data-Numerals.html#v:mul"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Numerals",
          "name": "one",
          "package": "liboleg",
          "signature": "N",
          "source": "src/Data-Numerals.html#one",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Numerals",
          "module": "Data.Numerals",
          "name": "one",
          "package": "liboleg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Data-Numerals.html#v:one"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Numerals",
          "name": "succ",
          "package": "liboleg",
          "signature": "N -\u003e N",
          "source": "src/Data-Numerals.html#succ",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Numerals",
          "module": "Data.Numerals",
          "name": "succ",
          "normalized": "N-\u003eN",
          "package": "liboleg",
          "signature": "N-\u003eN",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Data-Numerals.html#v:succ"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Numerals",
          "name": "unW",
          "package": "liboleg",
          "signature": "forall a.  a -\u003e a",
          "source": "src/Data-Numerals.html#W",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Numerals",
          "module": "Data.Numerals",
          "name": "unW",
          "normalized": "a b c-\u003ec",
          "package": "liboleg",
          "signature": "forall a. a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Data-Numerals.html#v:unW"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Numerals",
          "name": "zero",
          "package": "liboleg",
          "signature": "N",
          "source": "src/Data-Numerals.html#zero",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Numerals",
          "module": "Data.Numerals",
          "name": "zero",
          "package": "liboleg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Data-Numerals.html#v:zero"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eReify the (compiled) code to its typed TH representation \n (or, the dictionary *view*, to be precise) and reflect/compile that code.\n We must spread the code through several modules, due to the\n particular requirement of the Template Haskell.\n See DiffTest.hs for reflection of the differentiated TH code back\n into (machine) code.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.Symbolic.Diff",
          "name": "Diff",
          "package": "liboleg",
          "source": "src/Data-Symbolic-Diff.html",
          "type": "module"
        },
        "index": {
          "description": "Reify the compiled code to its typed TH representation or the dictionary view to be precise and reflect compile that code We must spread the code through several modules due to the particular requirement of the Template Haskell See DiffTest.hs for reflection of the differentiated TH code back into machine code",
          "hierarchy": "Data Symbolic Diff",
          "module": "Data.Symbolic.Diff",
          "name": "Diff",
          "package": "liboleg",
          "partial": "Diff",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Data-Symbolic-Diff.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWe can define a function\n\u003c/p\u003e\u003cp\u003ewe can even compile it. At any point, we can reify it, into\n a `dictionary view'\n The result is the TH code, which we can print, and compile back\n to the code. We can also differentiate the TH code, simplify it,\n partially evaluate it, etc.\n\u003c/p\u003e\u003cp\u003eSymbolic Differentiation of the reified, typed TH code expressions\n The derivative over the code is a type preserving operation\n\u003c/p\u003e",
          "module": "Data.Symbolic.Diff",
          "name": "diffC",
          "package": "liboleg",
          "signature": "Var b -\u003e Code a -\u003e Code a",
          "source": "src/Data-Symbolic-Diff.html#diffC",
          "type": "function"
        },
        "index": {
          "description": "We can define function we can even compile it At any point we can reify it into dictionary view The result is the TH code which we can print and compile back to the code We can also differentiate the TH code simplify it partially evaluate it etc Symbolic Differentiation of the reified typed TH code expressions The derivative over the code is type preserving operation",
          "hierarchy": "Data Symbolic Diff",
          "module": "Data.Symbolic.Diff",
          "name": "diffC",
          "normalized": "Var a-\u003eCode b-\u003eCode b",
          "package": "liboleg",
          "signature": "Var b-\u003eCode a-\u003eCode a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Data-Symbolic-Diff.html#v:diffC"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAnd that's about it. Putting it all together gives us:\n\u003c/p\u003e",
          "module": "Data.Symbolic.Diff",
          "name": "diff_fn",
          "package": "liboleg",
          "signature": "a -\u003e a) -\u003e QCode (b -\u003e b)",
          "source": "src/Data-Symbolic-Diff.html#diff_fn",
          "type": "function"
        },
        "index": {
          "description": "And that about it Putting it all together gives us",
          "hierarchy": "Data Symbolic Diff",
          "module": "Data.Symbolic.Diff",
          "name": "diff_fn",
          "normalized": "a-\u003ea)-\u003eQCode(b-\u003eb)",
          "package": "liboleg",
          "signature": "a-\u003ea)-\u003eQCode(b-\u003eb)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Data-Symbolic-Diff.html#v:diff_fn"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis is a useful helper to show us the code of the function in question\n\u003c/p\u003e",
          "module": "Data.Symbolic.Diff",
          "name": "show_fn",
          "package": "liboleg",
          "signature": "a -\u003e a) -\u003e IO ()",
          "source": "src/Data-Symbolic-Diff.html#show_fn",
          "type": "function"
        },
        "index": {
          "description": "This is useful helper to show us the code of the function in question",
          "hierarchy": "Data Symbolic Diff",
          "module": "Data.Symbolic.Diff",
          "name": "show_fn",
          "normalized": "a-\u003ea)-\u003eIO()",
          "package": "liboleg",
          "signature": "a-\u003ea)-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Data-Symbolic-Diff.html#v:show_fn"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSimplification rules\n simplification is type-preserving\n obviously, simplification is an `open-ended' problem:\n we could even recognize common sub-expressions and simplify them\n by introducing let binding.\n In the following however, we do trivial simplification only.\n One can always add more simplification rules later.\n\u003c/p\u003e",
          "module": "Data.Symbolic.Diff",
          "name": "simpleC",
          "package": "liboleg",
          "signature": "Var b -\u003e Code a -\u003e Code a",
          "source": "src/Data-Symbolic-Diff.html#simpleC",
          "type": "function"
        },
        "index": {
          "description": "Simplification rules simplification is type-preserving obviously simplification is an open-ended problem we could even recognize common sub-expressions and simplify them by introducing let binding In the following however we do trivial simplification only One can always add more simplification rules later",
          "hierarchy": "Data Symbolic Diff",
          "module": "Data.Symbolic.Diff",
          "name": "simpleC",
          "normalized": "Var a-\u003eCode b-\u003eCode b",
          "package": "liboleg",
          "signature": "Var b-\u003eCode a-\u003eCode a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Data-Symbolic-Diff.html#v:simpleC"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003erepeat until no simplifications are made\n\u003c/p\u003e",
          "module": "Data.Symbolic.Diff",
          "name": "simpleCL",
          "package": "liboleg",
          "signature": "Var b -\u003e Code a -\u003e Maybe (Code a)",
          "source": "src/Data-Symbolic-Diff.html#simpleCL",
          "type": "function"
        },
        "index": {
          "description": "repeat until no simplifications are made",
          "hierarchy": "Data Symbolic Diff",
          "module": "Data.Symbolic.Diff",
          "name": "simpleCL",
          "normalized": "Var a-\u003eCode b-\u003eMaybe(Code b)",
          "package": "liboleg",
          "partial": "CL",
          "signature": "Var b-\u003eCode a-\u003eMaybe(Code a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Data-Symbolic-Diff.html#v:simpleCL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Symbolic.Diff",
          "name": "testf1",
          "package": "liboleg",
          "signature": "a",
          "source": "src/Data-Symbolic-Diff.html#testf1",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Symbolic Diff",
          "module": "Data.Symbolic.Diff",
          "name": "testf1",
          "package": "liboleg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Data-Symbolic-Diff.html#v:testf1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eRunning the splicing tests from Diff.hs.\n Due to the TH requirement, this code must be in a separate module.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.Symbolic.DiffTest",
          "name": "DiffTest",
          "package": "liboleg",
          "source": "src/Data-Symbolic-DiffTest.html",
          "type": "module"
        },
        "index": {
          "description": "Running the splicing tests from Diff.hs Due to the TH requirement this code must be in separate module",
          "hierarchy": "Data Symbolic DiffTest",
          "module": "Data.Symbolic.DiffTest",
          "name": "DiffTest",
          "package": "liboleg",
          "partial": "Diff Test",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Data-Symbolic-DiffTest.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eTemplate Haskell code is untyped, which is a bummer and leads to late\n error reporting. We make code expressions typed, at least for our particular\n domain.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.Symbolic.TypedCode",
          "name": "TypedCode",
          "package": "liboleg",
          "source": "src/Data-Symbolic-TypedCode.html",
          "type": "module"
        },
        "index": {
          "description": "Template Haskell code is untyped which is bummer and leads to late error reporting We make code expressions typed at least for our particular domain",
          "hierarchy": "Data Symbolic TypedCode",
          "module": "Data.Symbolic.TypedCode",
          "name": "TypedCode",
          "package": "liboleg",
          "partial": "Typed Code",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Data-Symbolic-TypedCode.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe data type of a typed TH code experssion. The phantom parameter \u003ccode\u003ea\u003c/code\u003e\n is the type.\n\u003c/p\u003e",
          "module": "Data.Symbolic.TypedCode",
          "name": "Code",
          "package": "liboleg",
          "source": "src/Data-Symbolic-TypedCode.html#Code",
          "type": "data"
        },
        "index": {
          "description": "The data type of typed TH code experssion The phantom parameter is the type",
          "hierarchy": "Data Symbolic TypedCode",
          "module": "Data.Symbolic.TypedCode",
          "name": "Code",
          "package": "liboleg",
          "partial": "Code",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Data-Symbolic-TypedCode.html#t:Code"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Symbolic.TypedCode",
          "name": "QCode",
          "package": "liboleg",
          "source": "src/Data-Symbolic-TypedCode.html#QCode",
          "type": "type"
        },
        "index": {
          "hierarchy": "Data Symbolic TypedCode",
          "module": "Data.Symbolic.TypedCode",
          "name": "QCode",
          "package": "liboleg",
          "partial": "QCode",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Data-Symbolic-TypedCode.html#t:QCode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Symbolic.TypedCode",
          "name": "Var",
          "package": "liboleg",
          "source": "src/Data-Symbolic-TypedCode.html#Var",
          "type": "data"
        },
        "index": {
          "hierarchy": "Data Symbolic TypedCode",
          "module": "Data.Symbolic.TypedCode",
          "name": "Var",
          "package": "liboleg",
          "partial": "Var",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Data-Symbolic-TypedCode.html#t:Var"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCode expression combinators \n\u003c/p\u003e",
          "module": "Data.Symbolic.TypedCode",
          "name": "appC",
          "package": "liboleg",
          "signature": "Code (a -\u003e b) -\u003e Code a -\u003e Code b",
          "source": "src/Data-Symbolic-TypedCode.html#appC",
          "type": "function"
        },
        "index": {
          "description": "Code expression combinators",
          "hierarchy": "Data Symbolic TypedCode",
          "module": "Data.Symbolic.TypedCode",
          "name": "appC",
          "normalized": "Code(a-\u003eb)-\u003eCode a-\u003eCode b",
          "package": "liboleg",
          "signature": "Code(a-\u003eb)-\u003eCode a-\u003eCode b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Data-Symbolic-TypedCode.html#v:appC"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLifting from primitive datatypes to Code\n\u003c/p\u003e",
          "module": "Data.Symbolic.TypedCode",
          "name": "integerC",
          "package": "liboleg",
          "signature": "Integer -\u003e Code a",
          "source": "src/Data-Symbolic-TypedCode.html#integerC",
          "type": "function"
        },
        "index": {
          "description": "Lifting from primitive datatypes to Code",
          "hierarchy": "Data Symbolic TypedCode",
          "module": "Data.Symbolic.TypedCode",
          "name": "integerC",
          "normalized": "Integer-\u003eCode a",
          "package": "liboleg",
          "signature": "Integer-\u003eCode a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Data-Symbolic-TypedCode.html#v:integerC"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA distinguished variable (over which we differentiate)\n\u003c/p\u003e",
          "module": "Data.Symbolic.TypedCode",
          "name": "new'diffVar",
          "package": "liboleg",
          "signature": "Q (Var a)",
          "source": "src/Data-Symbolic-TypedCode.html#new%27diffVar",
          "type": "function"
        },
        "index": {
          "description": "distinguished variable over which we differentiate",
          "hierarchy": "Data Symbolic TypedCode",
          "module": "Data.Symbolic.TypedCode",
          "name": "new'diffVar",
          "package": "liboleg",
          "partial": "Var",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Data-Symbolic-TypedCode.html#v:new-39-diffVar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Symbolic.TypedCode",
          "name": "on'1opC",
          "package": "liboleg",
          "signature": "Code (a -\u003e b) -\u003e Code d -\u003e Maybe (Code a)",
          "source": "src/Data-Symbolic-TypedCode.html#on%271opC",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Symbolic TypedCode",
          "module": "Data.Symbolic.TypedCode",
          "name": "on'1opC",
          "normalized": "Code(a-\u003eb)-\u003eCode c-\u003eMaybe(Code a)",
          "package": "liboleg",
          "signature": "Code(a-\u003eb)-\u003eCode d-\u003eMaybe(Code a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Data-Symbolic-TypedCode.html#v:on-39-1opC"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Symbolic.TypedCode",
          "name": "on'2opC",
          "package": "liboleg",
          "signature": "Code (a -\u003e b -\u003e c) -\u003e Code d -\u003e Maybe (Code a, Code b)",
          "source": "src/Data-Symbolic-TypedCode.html#on%272opC",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Symbolic TypedCode",
          "module": "Data.Symbolic.TypedCode",
          "name": "on'2opC",
          "normalized": "Code(a-\u003eb-\u003ec)-\u003eCode d-\u003eMaybe(Code a,Code b)",
          "package": "liboleg",
          "signature": "Code(a-\u003eb-\u003ec)-\u003eCode d-\u003eMaybe(Code a,Code b)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Data-Symbolic-TypedCode.html#v:on-39-2opC"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIntensional code analysis\n Alas, TH.Exp is not a GADT. So, we have to do their emulation...\n\u003c/p\u003e",
          "module": "Data.Symbolic.TypedCode",
          "name": "on'litC",
          "package": "liboleg",
          "signature": "Code a -\u003e Maybe (Code a)",
          "source": "src/Data-Symbolic-TypedCode.html#on%27litC",
          "type": "function"
        },
        "index": {
          "description": "Intensional code analysis Alas TH.Exp is not GADT So we have to do their emulation",
          "hierarchy": "Data Symbolic TypedCode",
          "module": "Data.Symbolic.TypedCode",
          "name": "on'litC",
          "normalized": "Code a-\u003eMaybe(Code a)",
          "package": "liboleg",
          "signature": "Code a-\u003eMaybe(Code a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Data-Symbolic-TypedCode.html#v:on-39-litC"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Symbolic.TypedCode",
          "name": "on'litRationalC",
          "package": "liboleg",
          "signature": "Code a -\u003e Maybe Rational",
          "source": "src/Data-Symbolic-TypedCode.html#on%27litRationalC",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Symbolic TypedCode",
          "module": "Data.Symbolic.TypedCode",
          "name": "on'litRationalC",
          "normalized": "Code a-\u003eMaybe Rational",
          "package": "liboleg",
          "partial": "Rational",
          "signature": "Code a-\u003eMaybe Rational",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Data-Symbolic-TypedCode.html#v:on-39-litRationalC"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Symbolic.TypedCode",
          "name": "on'varC",
          "package": "liboleg",
          "signature": "Var a -\u003e Code b -\u003e Maybe (Either (Var a) (Var b))",
          "source": "src/Data-Symbolic-TypedCode.html#on%27varC",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Symbolic TypedCode",
          "module": "Data.Symbolic.TypedCode",
          "name": "on'varC",
          "normalized": "Var a-\u003eCode b-\u003eMaybe(Either(Var a)(Var b))",
          "package": "liboleg",
          "signature": "Var a-\u003eCode b-\u003eMaybe(Either(Var a)(Var b))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Data-Symbolic-TypedCode.html#v:on-39-varC"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTyped primitive operations\n\u003c/p\u003e",
          "module": "Data.Symbolic.TypedCode",
          "name": "op'add",
          "package": "liboleg",
          "signature": "Code (a -\u003e a -\u003e a)",
          "source": "src/Data-Symbolic-TypedCode.html#op%27add",
          "type": "function"
        },
        "index": {
          "description": "Typed primitive operations",
          "hierarchy": "Data Symbolic TypedCode",
          "module": "Data.Symbolic.TypedCode",
          "name": "op'add",
          "normalized": "Code(a-\u003ea-\u003ea)",
          "package": "liboleg",
          "signature": "Code(a-\u003ea-\u003ea)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Data-Symbolic-TypedCode.html#v:op-39-add"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Symbolic.TypedCode",
          "name": "op'cos",
          "package": "liboleg",
          "signature": "Code (a -\u003e a)",
          "source": "src/Data-Symbolic-TypedCode.html#op%27cos",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Symbolic TypedCode",
          "module": "Data.Symbolic.TypedCode",
          "name": "op'cos",
          "normalized": "Code(a-\u003ea)",
          "package": "liboleg",
          "signature": "Code(a-\u003ea)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Data-Symbolic-TypedCode.html#v:op-39-cos"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Symbolic.TypedCode",
          "name": "op'div",
          "package": "liboleg",
          "signature": "Code (a -\u003e a -\u003e a)",
          "source": "src/Data-Symbolic-TypedCode.html#op%27div",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Symbolic TypedCode",
          "module": "Data.Symbolic.TypedCode",
          "name": "op'div",
          "normalized": "Code(a-\u003ea-\u003ea)",
          "package": "liboleg",
          "signature": "Code(a-\u003ea-\u003ea)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Data-Symbolic-TypedCode.html#v:op-39-div"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Symbolic.TypedCode",
          "name": "op'mul",
          "package": "liboleg",
          "signature": "Code (a -\u003e a -\u003e a)",
          "source": "src/Data-Symbolic-TypedCode.html#op%27mul",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Symbolic TypedCode",
          "module": "Data.Symbolic.TypedCode",
          "name": "op'mul",
          "normalized": "Code(a-\u003ea-\u003ea)",
          "package": "liboleg",
          "signature": "Code(a-\u003ea-\u003ea)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Data-Symbolic-TypedCode.html#v:op-39-mul"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Symbolic.TypedCode",
          "name": "op'negate",
          "package": "liboleg",
          "signature": "Code (a -\u003e a)",
          "source": "src/Data-Symbolic-TypedCode.html#op%27negate",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Symbolic TypedCode",
          "module": "Data.Symbolic.TypedCode",
          "name": "op'negate",
          "normalized": "Code(a-\u003ea)",
          "package": "liboleg",
          "signature": "Code(a-\u003ea)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Data-Symbolic-TypedCode.html#v:op-39-negate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Symbolic.TypedCode",
          "name": "op'pi",
          "package": "liboleg",
          "signature": "Code a",
          "source": "src/Data-Symbolic-TypedCode.html#op%27pi",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Symbolic TypedCode",
          "module": "Data.Symbolic.TypedCode",
          "name": "op'pi",
          "package": "liboleg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Data-Symbolic-TypedCode.html#v:op-39-pi"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Symbolic.TypedCode",
          "name": "op'recip",
          "package": "liboleg",
          "signature": "Code (a -\u003e a)",
          "source": "src/Data-Symbolic-TypedCode.html#op%27recip",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Symbolic TypedCode",
          "module": "Data.Symbolic.TypedCode",
          "name": "op'recip",
          "normalized": "Code(a-\u003ea)",
          "package": "liboleg",
          "signature": "Code(a-\u003ea)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Data-Symbolic-TypedCode.html#v:op-39-recip"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Symbolic.TypedCode",
          "name": "op'sin",
          "package": "liboleg",
          "signature": "Code (a -\u003e a)",
          "source": "src/Data-Symbolic-TypedCode.html#op%27sin",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Symbolic TypedCode",
          "module": "Data.Symbolic.TypedCode",
          "name": "op'sin",
          "normalized": "Code(a-\u003ea)",
          "package": "liboleg",
          "signature": "Code(a-\u003ea)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Data-Symbolic-TypedCode.html#v:op-39-sin"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Symbolic.TypedCode",
          "name": "op'sub",
          "package": "liboleg",
          "signature": "Code (a -\u003e a -\u003e a)",
          "source": "src/Data-Symbolic-TypedCode.html#op%27sub",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Symbolic TypedCode",
          "module": "Data.Symbolic.TypedCode",
          "name": "op'sub",
          "normalized": "Code(a-\u003ea-\u003ea)",
          "package": "liboleg",
          "signature": "Code(a-\u003ea-\u003ea)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Data-Symbolic-TypedCode.html#v:op-39-sub"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Symbolic.TypedCode",
          "name": "rationalC",
          "package": "liboleg",
          "signature": "Rational -\u003e Code a",
          "source": "src/Data-Symbolic-TypedCode.html#rationalC",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Symbolic TypedCode",
          "module": "Data.Symbolic.TypedCode",
          "name": "rationalC",
          "normalized": "Rational-\u003eCode a",
          "package": "liboleg",
          "signature": "Rational-\u003eCode a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Data-Symbolic-TypedCode.html#v:rationalC"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Symbolic.TypedCode",
          "name": "reflectDF",
          "package": "liboleg",
          "signature": "Var a -\u003e Code a -\u003e QCode (a -\u003e a)",
          "source": "src/Data-Symbolic-TypedCode.html#reflectDF",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Symbolic TypedCode",
          "module": "Data.Symbolic.TypedCode",
          "name": "reflectDF",
          "normalized": "Var a-\u003eCode a-\u003eQCode(a-\u003ea)",
          "package": "liboleg",
          "partial": "DF",
          "signature": "Var a-\u003eCode a-\u003eQCode(a-\u003ea)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Data-Symbolic-TypedCode.html#v:reflectDF"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function is useful when splicing code expressions\n See DiffTest.hs for the examples of its use.\n\u003c/p\u003e",
          "module": "Data.Symbolic.TypedCode",
          "name": "reflectQC",
          "package": "liboleg",
          "signature": "Q (Code a) -\u003e Q Exp",
          "source": "src/Data-Symbolic-TypedCode.html#reflectQC",
          "type": "function"
        },
        "index": {
          "description": "This function is useful when splicing code expressions See DiffTest.hs for the examples of its use",
          "hierarchy": "Data Symbolic TypedCode",
          "module": "Data.Symbolic.TypedCode",
          "name": "reflectQC",
          "normalized": "Q(Code a)-\u003eQ Exp",
          "package": "liboleg",
          "partial": "QC",
          "signature": "Q(Code a)-\u003eQ Exp",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Data-Symbolic-TypedCode.html#v:reflectQC"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Symbolic.TypedCode",
          "name": "showQC",
          "package": "liboleg",
          "signature": "Q (Code a) -\u003e IO ()",
          "source": "src/Data-Symbolic-TypedCode.html#showQC",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Symbolic TypedCode",
          "module": "Data.Symbolic.TypedCode",
          "name": "showQC",
          "normalized": "Q(Code a)-\u003eIO()",
          "package": "liboleg",
          "partial": "QC",
          "signature": "Q(Code a)-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Data-Symbolic-TypedCode.html#v:showQC"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLift this variable to Code\n\u003c/p\u003e",
          "module": "Data.Symbolic.TypedCode",
          "name": "var'exp",
          "package": "liboleg",
          "signature": "Var a -\u003e Code a",
          "source": "src/Data-Symbolic-TypedCode.html#var%27exp",
          "type": "function"
        },
        "index": {
          "description": "Lift this variable to Code",
          "hierarchy": "Data Symbolic TypedCode",
          "module": "Data.Symbolic.TypedCode",
          "name": "var'exp",
          "normalized": "Var a-\u003eCode a",
          "package": "liboleg",
          "signature": "Var a-\u003eCode a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Data-Symbolic-TypedCode.html#v:var-39-exp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eObtain the Name that corresponds to a top-level (Prelude-level)\n Haskell identifier.\n Given an expression such as [e| (+) |] we return the expression\n that is the application of mkNameG_v to the correct strings.\n That expression, when spliced in, will compute exactly the same\n name that corresponds to the one we started with, that is, (+).\n Note that (+) was the identifier, not the name.\n The result of splicing reifyName can be used in splices\n (see the Diff.hs for examples).\n We essentially apply the TH to itself and emulate more than one stage\n of computation.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.Symbolic.TypedCodeAux",
          "name": "TypedCodeAux",
          "package": "liboleg",
          "source": "src/Data-Symbolic-TypedCodeAux.html",
          "type": "module"
        },
        "index": {
          "description": "Obtain the Name that corresponds to top-level Prelude-level Haskell identifier Given an expression such as we return the expression that is the application of mkNameG to the correct strings That expression when spliced in will compute exactly the same name that corresponds to the one we started with that is Note that was the identifier not the name The result of splicing reifyName can be used in splices see the Diff.hs for examples We essentially apply the TH to itself and emulate more than one stage of computation",
          "hierarchy": "Data Symbolic TypedCodeAux",
          "module": "Data.Symbolic.TypedCodeAux",
          "name": "TypedCodeAux",
          "package": "liboleg",
          "partial": "Typed Code Aux",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Data-Symbolic-TypedCodeAux.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Symbolic.TypedCodeAux",
          "name": "reifyName",
          "package": "liboleg",
          "signature": "Q Exp -\u003e Q Exp",
          "source": "src/Data-Symbolic-TypedCodeAux.html#reifyName",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Symbolic TypedCodeAux",
          "module": "Data.Symbolic.TypedCodeAux",
          "name": "reifyName",
          "normalized": "Q Exp-\u003eQ Exp",
          "package": "liboleg",
          "partial": "Name",
          "signature": "Q Exp-\u003eQ Exp",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Data-Symbolic-TypedCodeAux.html#v:reifyName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eCombinatorial Categorical Grammar (CCG)\n\u003c/p\u003e\u003cp\u003e\u003ca\u003ehttp://okmij.org/ftp/gengo/NASSLLI10\u003c/a\u003e\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Lambda.CCG",
          "name": "CCG",
          "package": "liboleg",
          "source": "src/Lambda-CCG.html",
          "type": "module"
        },
        "index": {
          "description": "Combinatorial Categorical Grammar CCG http okmij.org ftp gengo NASSLLI10",
          "hierarchy": "Lambda CCG",
          "module": "Lambda.CCG",
          "name": "CCG",
          "package": "liboleg",
          "partial": "CCG",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Lambda-CCG.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambda.CCG",
          "name": ":/",
          "package": "liboleg",
          "source": "src/Lambda-CCG.html#%3A%2F",
          "type": "data"
        },
        "index": {
          "hierarchy": "Lambda CCG",
          "module": "Lambda.CCG",
          "name": ":/",
          "package": "liboleg",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Lambda-CCG.html#t::-47-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambda.CCG",
          "name": ":\\\\",
          "package": "liboleg",
          "source": "src/Lambda-CCG.html#%3A%5C%5C",
          "type": "data"
        },
        "index": {
          "hierarchy": "Lambda CCG",
          "module": "Lambda.CCG",
          "name": ":\\\\",
          "package": "liboleg",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Lambda-CCG.html#t::-92--92-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eshow the inferred types, as well as the inferred types for\n phrases like\n\u003c/p\u003e\u003cp\u003eThe first sample sentence, or CCG derivation\n The inferred type is S. So, sen1 is a derivations of\n a complete sentence.\n\u003c/p\u003e\u003cp\u003eWe now define the first interpretation of a CCG derivations:\n We interpret the derivation to give the parsed string.\n That is, we generate a yield of a CCG derivation,\n in English.\n\u003c/p\u003e\u003cp\u003eWe represent each node in the derivation tree\n by an English phrase\n\u003c/p\u003e",
          "module": "Lambda.CCG",
          "name": "EN",
          "package": "liboleg",
          "source": "src/Lambda-CCG.html#EN",
          "type": "data"
        },
        "index": {
          "description": "show the inferred types as well as the inferred types for phrases like The first sample sentence or CCG derivation The inferred type is So sen1 is derivations of complete sentence We now define the first interpretation of CCG derivations We interpret the derivation to give the parsed string That is we generate yield of CCG derivation in English We represent each node in the derivation tree by an English phrase",
          "hierarchy": "Lambda CCG",
          "module": "Lambda.CCG",
          "name": "EN",
          "package": "liboleg",
          "partial": "EN",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Lambda-CCG.html#t:EN"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWe can now see the semantics of sen1\n\u003c/p\u003e\u003cp\u003eComputing the yield in Japanese\n\u003c/p\u003e\u003cp\u003eThe type family TJ defines the types of\n sentential forms corresponding to syntactic categories.\n\u003c/p\u003e\u003cp\u003eWe represent each node in the derivation tree\n by a Japanese phrase or a Japanese \u003ca\u003esentential form\u003c/a\u003e\n (that is, a phrase with holes). Contrast with the EN\n interpreter above.\n\u003c/p\u003e",
          "module": "Lambda.CCG",
          "name": "JA",
          "package": "liboleg",
          "source": "src/Lambda-CCG.html#JA",
          "type": "data"
        },
        "index": {
          "description": "We can now see the semantics of sen1 Computing the yield in Japanese The type family TJ defines the types of sentential forms corresponding to syntactic categories We represent each node in the derivation tree by Japanese phrase or Japanese sentential form that is phrase with holes Contrast with the EN interpreter above",
          "hierarchy": "Lambda CCG",
          "module": "Lambda.CCG",
          "name": "JA",
          "package": "liboleg",
          "partial": "JA",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Lambda-CCG.html#t:JA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambda.CCG",
          "name": "NP",
          "package": "liboleg",
          "source": "src/Lambda-CCG.html#NP",
          "type": "data"
        },
        "index": {
          "hierarchy": "Lambda CCG",
          "module": "Lambda.CCG",
          "name": "NP",
          "package": "liboleg",
          "partial": "NP",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Lambda-CCG.html#t:NP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe translation is certainly different: \u003ca\u003elike\u003c/a\u003e corresponds\n to an adjective in Japanese.\n\u003c/p\u003e\u003cp\u003eAdding quantification; one way\n\u003c/p\u003e",
          "module": "Lambda.CCG",
          "name": "QNP",
          "package": "liboleg",
          "source": "src/Lambda-CCG.html#QNP",
          "type": "type"
        },
        "index": {
          "description": "The translation is certainly different like corresponds to an adjective in Japanese Adding quantification one way",
          "hierarchy": "Lambda CCG",
          "module": "Lambda.CCG",
          "name": "QNP",
          "package": "liboleg",
          "partial": "QNP",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Lambda-CCG.html#t:QNP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWe extend our earlier fragment with quantifiers everyone, someone\n We also add a combinator for raising the first argument of a TV\n\u003c/p\u003e",
          "module": "Lambda.CCG",
          "name": "Quantifier",
          "package": "liboleg",
          "source": "src/Lambda-CCG.html#Quantifier",
          "type": "class"
        },
        "index": {
          "description": "We extend our earlier fragment with quantifiers everyone someone We also add combinator for raising the first argument of TV",
          "hierarchy": "Lambda CCG",
          "module": "Lambda.CCG",
          "name": "Quantifier",
          "package": "liboleg",
          "partial": "Quantifier",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Lambda-CCG.html#t:Quantifier"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSyntactic categories: non-terminals of CCG\n\u003c/p\u003e",
          "module": "Lambda.CCG",
          "name": "S",
          "package": "liboleg",
          "source": "src/Lambda-CCG.html#S",
          "type": "data"
        },
        "index": {
          "description": "Syntactic categories non-terminals of CCG",
          "hierarchy": "Lambda CCG",
          "module": "Lambda.CCG",
          "name": "S",
          "package": "liboleg",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Lambda-CCG.html#t:S"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambda.CCG",
          "name": "Sem",
          "package": "liboleg",
          "source": "src/Lambda-CCG.html#Sem",
          "type": "data"
        },
        "index": {
          "hierarchy": "Lambda CCG",
          "module": "Lambda.CCG",
          "name": "Sem",
          "package": "liboleg",
          "partial": "Sem",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Lambda-CCG.html#t:Sem"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis class defines the syntax of our fragment (the grammar,\n essentially). Its instances will show interpretations\n of the grammar, or \u003ccode\u003esemantics\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Lambda.CCG",
          "name": "Symantics",
          "package": "liboleg",
          "source": "src/Lambda-CCG.html#Symantics",
          "type": "class"
        },
        "index": {
          "description": "This class defines the syntax of our fragment the grammar essentially Its instances will show interpretations of the grammar or semantics",
          "hierarchy": "Lambda CCG",
          "module": "Lambda.CCG",
          "name": "Symantics",
          "package": "liboleg",
          "partial": "Symantics",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Lambda-CCG.html#t:Symantics"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Lambda.CCG\",\"Lambda.CFGJ\"]",
          "name": "TJ",
          "package": "liboleg",
          "signature": "TJ",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/liboleg/docs/Lambda-CCG.html#t:TJ\",\"http://hackage.haskell.org/package/liboleg/docs/Lambda-CFGJ.html#t:TJ\"]"
        },
        "index": {
          "hierarchy": "Lambda CCG",
          "module": "Lambda.CCG",
          "name": "TJ",
          "package": "liboleg",
          "partial": "TJ",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Lambda-CCG.html#t:TJ"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eShow the English form of sen1\n\u003c/p\u003e\u003cp\u003eWe now define semantics of a phrase represented\n by a derivation. It is a different interpretation\n of the phrase and its types.\n\u003c/p\u003e\u003cp\u003eWe first interpret syntactic types (NP, slashes, etc)\n in terms of the types of the language of\n logic formulas. \n The type class Lambda defines the language\n of logic formulas (STT, or higher-order logic)\n with types Entity, Bool, and the arrows.\n\u003c/p\u003e",
          "module": "Lambda.CCG",
          "name": "Tr",
          "package": "liboleg",
          "signature": "Tr",
          "type": "function"
        },
        "index": {
          "description": "Show the English form of sen1 We now define semantics of phrase represented by derivation It is different interpretation of the phrase and its types We first interpret syntactic types NP slashes etc in terms of the types of the language of logic formulas The type class Lambda defines the language of logic formulas STT or higher-order logic with types Entity Bool and the arrows",
          "hierarchy": "Lambda CCG",
          "module": "Lambda.CCG",
          "name": "Tr",
          "package": "liboleg",
          "partial": "Tr",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Lambda-CCG.html#t:Tr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambda.CCG",
          "name": "(/)",
          "package": "liboleg",
          "signature": "repr (b :/ a) -\u003e repr a -\u003e repr b",
          "source": "src/Lambda-CCG.html#%2F",
          "type": "method"
        },
        "index": {
          "hierarchy": "Lambda CCG",
          "module": "Lambda.CCG",
          "name": "(/) /",
          "normalized": "a(b c)-\u003ea c-\u003ea b",
          "package": "liboleg",
          "signature": "repr(b a)-\u003erepr a-\u003erepr b",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Lambda-CCG.html#v:-47-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambda.CCG",
          "name": "(\\\\)",
          "package": "liboleg",
          "signature": "repr a -\u003e repr (a :\\\\ b) -\u003e repr b",
          "source": "src/Lambda-CCG.html#%5C%5C",
          "type": "method"
        },
        "index": {
          "hierarchy": "Lambda CCG",
          "module": "Lambda.CCG",
          "name": "(\\\\) \\\\",
          "normalized": "a b-\u003ea(b c)-\u003ea c",
          "package": "liboleg",
          "signature": "repr a-\u003erepr(a b)-\u003erepr b",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Lambda-CCG.html#v:-92--92-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambda.CCG",
          "name": "EN",
          "package": "liboleg",
          "signature": "EN",
          "source": "src/Lambda-CCG.html#EN",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambda CCG",
          "module": "Lambda.CCG",
          "name": "EN",
          "package": "liboleg",
          "partial": "EN",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Lambda-CCG.html#v:EN"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambda.CCG",
          "name": "JA",
          "package": "liboleg",
          "signature": "JA",
          "source": "src/Lambda-CCG.html#JA",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambda CCG",
          "module": "Lambda.CCG",
          "name": "JA",
          "package": "liboleg",
          "partial": "JA",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Lambda-CCG.html#v:JA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambda.CCG",
          "name": "Sem",
          "package": "liboleg",
          "signature": "Sem",
          "source": "src/Lambda-CCG.html#Sem",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambda CCG",
          "module": "Lambda.CCG",
          "name": "Sem",
          "package": "liboleg",
          "partial": "Sem",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Lambda-CCG.html#v:Sem"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambda.CCG",
          "name": "everyone",
          "package": "liboleg",
          "signature": "repr QNP",
          "source": "src/Lambda-CCG.html#everyone",
          "type": "method"
        },
        "index": {
          "hierarchy": "Lambda CCG",
          "module": "Lambda.CCG",
          "name": "everyone",
          "package": "liboleg",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Lambda-CCG.html#v:everyone"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambda.CCG",
          "name": "john",
          "package": "liboleg",
          "signature": "repr NP",
          "source": "src/Lambda-CCG.html#john",
          "type": "method"
        },
        "index": {
          "hierarchy": "Lambda CCG",
          "module": "Lambda.CCG",
          "name": "john",
          "package": "liboleg",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Lambda-CCG.html#v:john"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambda.CCG",
          "name": "lift_vt",
          "package": "liboleg",
          "signature": "repr ((NP :\\\\ S) :/ NP) -\u003e repr ((NP :\\\\ S) :/ QNP)",
          "source": "src/Lambda-CCG.html#lift_vt",
          "type": "method"
        },
        "index": {
          "hierarchy": "Lambda CCG",
          "module": "Lambda.CCG",
          "name": "lift_vt",
          "normalized": "a((NP S)NP)-\u003ea((NP S)QNP)",
          "package": "liboleg",
          "signature": "repr((NP S)NP)-\u003erepr((NP S)QNP)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Lambda-CCG.html#v:lift_vt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambda.CCG",
          "name": "like",
          "package": "liboleg",
          "signature": "repr ((NP :\\\\ S) :/ NP)",
          "source": "src/Lambda-CCG.html#like",
          "type": "method"
        },
        "index": {
          "hierarchy": "Lambda CCG",
          "module": "Lambda.CCG",
          "name": "like",
          "package": "liboleg",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Lambda-CCG.html#v:like"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambda.CCG",
          "name": "mary",
          "package": "liboleg",
          "signature": "repr NP",
          "source": "src/Lambda-CCG.html#mary",
          "type": "method"
        },
        "index": {
          "hierarchy": "Lambda CCG",
          "module": "Lambda.CCG",
          "name": "mary",
          "package": "liboleg",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Lambda-CCG.html#v:mary"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambda.CCG",
          "name": "someone",
          "package": "liboleg",
          "signature": "repr QNP",
          "source": "src/Lambda-CCG.html#someone",
          "type": "method"
        },
        "index": {
          "hierarchy": "Lambda CCG",
          "module": "Lambda.CCG",
          "name": "someone",
          "package": "liboleg",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Lambda-CCG.html#v:someone"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambda.CCG",
          "name": "unEN",
          "package": "liboleg",
          "signature": "String",
          "source": "src/Lambda-CCG.html#EN",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambda CCG",
          "module": "Lambda.CCG",
          "name": "unEN",
          "package": "liboleg",
          "partial": "EN",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Lambda-CCG.html#v:unEN"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambda.CCG",
          "name": "unJA",
          "package": "liboleg",
          "signature": "TJ a",
          "source": "src/Lambda-CCG.html#JA",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambda CCG",
          "module": "Lambda.CCG",
          "name": "unJA",
          "package": "liboleg",
          "partial": "JA",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Lambda-CCG.html#v:unJA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambda.CCG",
          "name": "unSem",
          "package": "liboleg",
          "signature": "lrepr (Tr a)",
          "source": "src/Lambda-CCG.html#Sem",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambda CCG",
          "module": "Lambda.CCG",
          "name": "unSem",
          "package": "liboleg",
          "partial": "Sem",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Lambda-CCG.html#v:unSem"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eContext-free grammars, in the tagless-final style\n\u003c/p\u003e\u003cp\u003e\u003ca\u003ehttp://okmij.org/ftp/gengo/NASSLLI10/\u003c/a\u003e\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Lambda.CFG",
          "name": "CFG",
          "package": "liboleg",
          "source": "src/Lambda-CFG.html",
          "type": "module"
        },
        "index": {
          "description": "Context-free grammars in the tagless-final style http okmij.org ftp gengo NASSLLI10",
          "hierarchy": "Lambda CFG",
          "module": "Lambda.CFG",
          "name": "CFG",
          "package": "liboleg",
          "partial": "CFG",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Lambda-CFG.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eshow the inferred types, as well as the inferred types for\n the phrases like\n\u003c/p\u003e\u003cp\u003eThe first sample sentence, or CFG derivation\n The inferred type is S. So, sen1 is a derivations of\n a complete sentence.\n\u003c/p\u003e\u003cp\u003eWe now define the first interpretation of a CFG derivations:\n We interpret the derivation to give the parsed string.\n That is, we generate a yield of a CFG derivation,\n in English.\n\u003c/p\u003e\u003cp\u003eWe represent each node in the derivation tree\n by an English phrase\n\u003c/p\u003e",
          "module": "Lambda.CFG",
          "name": "EN",
          "package": "liboleg",
          "source": "src/Lambda-CFG.html#EN",
          "type": "data"
        },
        "index": {
          "description": "show the inferred types as well as the inferred types for the phrases like The first sample sentence or CFG derivation The inferred type is So sen1 is derivations of complete sentence We now define the first interpretation of CFG derivations We interpret the derivation to give the parsed string That is we generate yield of CFG derivation in English We represent each node in the derivation tree by an English phrase",
          "hierarchy": "Lambda CFG",
          "module": "Lambda.CFG",
          "name": "EN",
          "package": "liboleg",
          "partial": "EN",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Lambda-CFG.html#t:EN"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambda.CFG",
          "name": "NP",
          "package": "liboleg",
          "source": "src/Lambda-CFG.html#NP",
          "type": "data"
        },
        "index": {
          "hierarchy": "Lambda CFG",
          "module": "Lambda.CFG",
          "name": "NP",
          "package": "liboleg",
          "partial": "NP",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Lambda-CFG.html#t:NP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSyntactic categories: non-terminals of CFG\n\u003c/p\u003e",
          "module": "Lambda.CFG",
          "name": "S",
          "package": "liboleg",
          "source": "src/Lambda-CFG.html#S",
          "type": "data"
        },
        "index": {
          "description": "Syntactic categories non-terminals of CFG",
          "hierarchy": "Lambda CFG",
          "module": "Lambda.CFG",
          "name": "S",
          "package": "liboleg",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Lambda-CFG.html#t:S"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambda.CFG",
          "name": "Sem",
          "package": "liboleg",
          "source": "src/Lambda-CFG.html#Sem",
          "type": "data"
        },
        "index": {
          "hierarchy": "Lambda CFG",
          "module": "Lambda.CFG",
          "name": "Sem",
          "package": "liboleg",
          "partial": "Sem",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Lambda-CFG.html#t:Sem"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis class defines the syntax of our fragment (the grammar,\n essentially). Its instances will show interpretations\n of the grammar, or \u003ccode\u003esemantics\u003c/code\u003e\n\u003c/p\u003e\u003cp\u003eThe names r1, r2, etc. are the labels of CFG rules.\n These names are evocative of Montague\n\u003c/p\u003e",
          "module": "Lambda.CFG",
          "name": "Symantics",
          "package": "liboleg",
          "source": "src/Lambda-CFG.html#Symantics",
          "type": "class"
        },
        "index": {
          "description": "This class defines the syntax of our fragment the grammar essentially Its instances will show interpretations of the grammar or semantics The names r1 r2 etc are the labels of CFG rules These names are evocative of Montague",
          "hierarchy": "Lambda CFG",
          "module": "Lambda.CFG",
          "name": "Symantics",
          "package": "liboleg",
          "partial": "Symantics",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Lambda-CFG.html#t:Symantics"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambda.CFG",
          "name": "TV",
          "package": "liboleg",
          "source": "src/Lambda-CFG.html#TV",
          "type": "data"
        },
        "index": {
          "hierarchy": "Lambda CFG",
          "module": "Lambda.CFG",
          "name": "TV",
          "package": "liboleg",
          "partial": "TV",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Lambda-CFG.html#t:TV"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eShow the English form of sen1\n\u003c/p\u003e\u003cp\u003eWe now define semantics of a phrase represented\n by a derivation. It is a different interpretation\n of the phrase and its types.\n\u003c/p\u003e\u003cp\u003eWe first interpret syntactic types (NP, VP, etc)\n in terms of the types of the language of\n logic formulas. \n The type class Lambda defines the language\n of logic formulas (STT, or higher-order logic)\n with types Entity, Bool, and the arrows.\n\u003c/p\u003e",
          "module": "Lambda.CFG",
          "name": "Tr",
          "package": "liboleg",
          "signature": "Tr",
          "type": "function"
        },
        "index": {
          "description": "Show the English form of sen1 We now define semantics of phrase represented by derivation It is different interpretation of the phrase and its types We first interpret syntactic types NP VP etc in terms of the types of the language of logic formulas The type class Lambda defines the language of logic formulas STT or higher-order logic with types Entity Bool and the arrows",
          "hierarchy": "Lambda CFG",
          "module": "Lambda.CFG",
          "name": "Tr",
          "package": "liboleg",
          "partial": "Tr",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Lambda-CFG.html#t:Tr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambda.CFG",
          "name": "VP",
          "package": "liboleg",
          "source": "src/Lambda-CFG.html#VP",
          "type": "data"
        },
        "index": {
          "hierarchy": "Lambda CFG",
          "module": "Lambda.CFG",
          "name": "VP",
          "package": "liboleg",
          "partial": "VP",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Lambda-CFG.html#t:VP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambda.CFG",
          "name": "EN",
          "package": "liboleg",
          "signature": "EN",
          "source": "src/Lambda-CFG.html#EN",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambda CFG",
          "module": "Lambda.CFG",
          "name": "EN",
          "package": "liboleg",
          "partial": "EN",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Lambda-CFG.html#v:EN"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambda.CFG",
          "name": "Sem",
          "package": "liboleg",
          "signature": "Sem",
          "source": "src/Lambda-CFG.html#Sem",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambda CFG",
          "module": "Lambda.CFG",
          "name": "Sem",
          "package": "liboleg",
          "partial": "Sem",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Lambda-CFG.html#v:Sem"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambda.CFG",
          "name": "john",
          "package": "liboleg",
          "signature": "repr NP",
          "source": "src/Lambda-CFG.html#john",
          "type": "method"
        },
        "index": {
          "hierarchy": "Lambda CFG",
          "module": "Lambda.CFG",
          "name": "john",
          "package": "liboleg",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Lambda-CFG.html#v:john"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambda.CFG",
          "name": "like",
          "package": "liboleg",
          "signature": "repr TV",
          "source": "src/Lambda-CFG.html#like",
          "type": "method"
        },
        "index": {
          "hierarchy": "Lambda CFG",
          "module": "Lambda.CFG",
          "name": "like",
          "package": "liboleg",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Lambda-CFG.html#v:like"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambda.CFG",
          "name": "mary",
          "package": "liboleg",
          "signature": "repr NP",
          "source": "src/Lambda-CFG.html#mary",
          "type": "method"
        },
        "index": {
          "hierarchy": "Lambda CFG",
          "module": "Lambda.CFG",
          "name": "mary",
          "package": "liboleg",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Lambda-CFG.html#v:mary"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambda.CFG",
          "name": "own",
          "package": "liboleg",
          "signature": "repr TV",
          "source": "src/Lambda-CFG.html#own",
          "type": "method"
        },
        "index": {
          "hierarchy": "Lambda CFG",
          "module": "Lambda.CFG",
          "name": "own",
          "package": "liboleg",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Lambda-CFG.html#v:own"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambda.CFG",
          "name": "r1",
          "package": "liboleg",
          "signature": "repr NP -\u003e repr VP -\u003e repr S",
          "source": "src/Lambda-CFG.html#r1",
          "type": "method"
        },
        "index": {
          "hierarchy": "Lambda CFG",
          "module": "Lambda.CFG",
          "name": "r1",
          "normalized": "a NP-\u003ea VP-\u003ea S",
          "package": "liboleg",
          "signature": "repr NP-\u003erepr VP-\u003erepr S",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Lambda-CFG.html#v:r1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambda.CFG",
          "name": "r2",
          "package": "liboleg",
          "signature": "repr TV -\u003e repr NP -\u003e repr VP",
          "source": "src/Lambda-CFG.html#r2",
          "type": "method"
        },
        "index": {
          "hierarchy": "Lambda CFG",
          "module": "Lambda.CFG",
          "name": "r2",
          "normalized": "a TV-\u003ea NP-\u003ea VP",
          "package": "liboleg",
          "signature": "repr TV-\u003erepr NP-\u003erepr VP",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Lambda-CFG.html#v:r2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambda.CFG",
          "name": "unEN",
          "package": "liboleg",
          "signature": "String",
          "source": "src/Lambda-CFG.html#EN",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambda CFG",
          "module": "Lambda.CFG",
          "name": "unEN",
          "package": "liboleg",
          "partial": "EN",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Lambda-CFG.html#v:unEN"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambda.CFG",
          "name": "unSem",
          "package": "liboleg",
          "signature": "lrepr (Tr a)",
          "source": "src/Lambda-CFG.html#Sem",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambda CFG",
          "module": "Lambda.CFG",
          "name": "unSem",
          "package": "liboleg",
          "partial": "Sem",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Lambda-CFG.html#v:unSem"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003e\u003ca\u003ehttp://okmij.org/ftp/gengo/NASSLLI10/\u003c/a\u003e\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Lambda.CFG1EN",
          "name": "CFG1EN",
          "package": "liboleg",
          "source": "src/Lambda-CFG1EN.html",
          "type": "module"
        },
        "index": {
          "description": "http okmij.org ftp gengo NASSLLI10",
          "hierarchy": "Lambda CFG1EN",
          "module": "Lambda.CFG1EN",
          "name": "CFG1EN",
          "package": "liboleg",
          "partial": "CFG EN",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Lambda-CFG1EN.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003e\u003ca\u003ehttp://okmij.org/ftp/gengo/NASSLLI10/\u003c/a\u003e\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Lambda.CFG1Sem",
          "name": "CFG1Sem",
          "package": "liboleg",
          "source": "src/Lambda-CFG1Sem.html",
          "type": "module"
        },
        "index": {
          "description": "http okmij.org ftp gengo NASSLLI10",
          "hierarchy": "Lambda CFG1Sem",
          "module": "Lambda.CFG1Sem",
          "name": "CFG1Sem",
          "package": "liboleg",
          "partial": "CFG Sem",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Lambda-CFG1Sem.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSemantic interpretation of a CFG derivation\n\u003c/p\u003e\u003cp\u003eIn conventional notation:\n\u003c/p\u003e\u003cpre\u003e D_e = {John, Mary}\n\u003c/pre\u003e",
          "module": "Lambda.CFG1Sem",
          "name": "Entity",
          "package": "liboleg",
          "source": "src/Lambda-CFG1Sem.html#Entity",
          "type": "data"
        },
        "index": {
          "description": "Semantic interpretation of CFG derivation In conventional notation John Mary",
          "hierarchy": "Lambda CFG1Sem",
          "module": "Lambda.CFG1Sem",
          "name": "Entity",
          "package": "liboleg",
          "partial": "Entity",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Lambda-CFG1Sem.html#t:Entity"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambda.CFG1Sem",
          "name": "John",
          "package": "liboleg",
          "signature": "John",
          "source": "src/Lambda-CFG1Sem.html#Entity",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambda CFG1Sem",
          "module": "Lambda.CFG1Sem",
          "name": "John",
          "package": "liboleg",
          "partial": "John",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Lambda-CFG1Sem.html#v:John"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambda.CFG1Sem",
          "name": "Mary",
          "package": "liboleg",
          "signature": "Mary",
          "source": "src/Lambda-CFG1Sem.html#Entity",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambda CFG1Sem",
          "module": "Lambda.CFG1Sem",
          "name": "Mary",
          "package": "liboleg",
          "partial": "Mary",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Lambda-CFG1Sem.html#v:Mary"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003e\u003ca\u003ehttp://okmij.org/ftp/gengo/NASSLLI10\u003c/a\u003e\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Lambda.CFG2EN",
          "name": "CFG2EN",
          "package": "liboleg",
          "source": "src/Lambda-CFG2EN.html",
          "type": "module"
        },
        "index": {
          "description": "http okmij.org ftp gengo NASSLLI10",
          "hierarchy": "Lambda CFG2EN",
          "module": "Lambda.CFG2EN",
          "name": "CFG2EN",
          "package": "liboleg",
          "partial": "CFG EN",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Lambda-CFG2EN.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUnfortunately, the following sentence is, too,\n accepted by the type checker.\n\u003c/p\u003e\u003cp\u003eWe shall later see how to build terms that correspond to\n all and only valid derivations.\n Invalid derivations will become ill-typed.\n\u003c/p\u003e",
          "module": "Lambda.CFG2EN",
          "name": "bad_sentence",
          "package": "liboleg",
          "signature": "String",
          "source": "src/Lambda-CFG2EN.html#bad_sentence",
          "type": "function"
        },
        "index": {
          "description": "Unfortunately the following sentence is too accepted by the type checker We shall later see how to build terms that correspond to all and only valid derivations Invalid derivations will become ill-typed",
          "hierarchy": "Lambda CFG2EN",
          "module": "Lambda.CFG2EN",
          "name": "bad_sentence",
          "package": "liboleg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Lambda-CFG2EN.html#v:bad_sentence"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambda.CFG2EN",
          "name": "john",
          "package": "liboleg",
          "signature": "String",
          "source": "src/Lambda-CFG2EN.html#john",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambda CFG2EN",
          "module": "Lambda.CFG2EN",
          "name": "john",
          "package": "liboleg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Lambda-CFG2EN.html#v:john"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambda.CFG2EN",
          "name": "like",
          "package": "liboleg",
          "signature": "String",
          "source": "src/Lambda-CFG2EN.html#like",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambda CFG2EN",
          "module": "Lambda.CFG2EN",
          "name": "like",
          "package": "liboleg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Lambda-CFG2EN.html#v:like"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eType annotations\n\u003c/p\u003e",
          "module": "Lambda.CFG2EN",
          "name": "mary",
          "package": "liboleg",
          "signature": "String",
          "source": "src/Lambda-CFG2EN.html#mary",
          "type": "function"
        },
        "index": {
          "description": "Type annotations",
          "hierarchy": "Lambda CFG2EN",
          "module": "Lambda.CFG2EN",
          "name": "mary",
          "package": "liboleg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Lambda-CFG2EN.html#v:mary"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambda.CFG2EN",
          "name": "r1",
          "package": "liboleg",
          "signature": "String -\u003e String -\u003e String",
          "source": "src/Lambda-CFG2EN.html#r1",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambda CFG2EN",
          "module": "Lambda.CFG2EN",
          "name": "r1",
          "normalized": "String-\u003eString-\u003eString",
          "package": "liboleg",
          "signature": "String-\u003eString-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Lambda-CFG2EN.html#v:r1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambda.CFG2EN",
          "name": "r2",
          "package": "liboleg",
          "signature": "String -\u003e String -\u003e String",
          "source": "src/Lambda-CFG2EN.html#r2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambda CFG2EN",
          "module": "Lambda.CFG2EN",
          "name": "r2",
          "normalized": "String-\u003eString-\u003eString",
          "package": "liboleg",
          "signature": "String-\u003eString-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Lambda-CFG2EN.html#v:r2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambda.CFG2EN",
          "name": "sentence",
          "package": "liboleg",
          "signature": "String",
          "source": "src/Lambda-CFG2EN.html#sentence",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambda CFG2EN",
          "module": "Lambda.CFG2EN",
          "name": "sentence",
          "package": "liboleg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Lambda-CFG2EN.html#v:sentence"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003e\u003ca\u003ehttp://okmij.org/ftp/gengo/NASSLLI10/\u003c/a\u003e\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Lambda.CFG2Sem",
          "name": "CFG2Sem",
          "package": "liboleg",
          "source": "src/Lambda-CFG2Sem.html",
          "type": "module"
        },
        "index": {
          "description": "http okmij.org ftp gengo NASSLLI10",
          "hierarchy": "Lambda CFG2Sem",
          "module": "Lambda.CFG2Sem",
          "name": "CFG2Sem",
          "package": "liboleg",
          "partial": "CFG Sem",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Lambda-CFG2Sem.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCFG1Sem with type annotations\n\u003c/p\u003e",
          "module": "Lambda.CFG2Sem",
          "name": "Entity",
          "package": "liboleg",
          "source": "src/Lambda-CFG2Sem.html#Entity",
          "type": "data"
        },
        "index": {
          "description": "CFG1Sem with type annotations",
          "hierarchy": "Lambda CFG2Sem",
          "module": "Lambda.CFG2Sem",
          "name": "Entity",
          "package": "liboleg",
          "partial": "Entity",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Lambda-CFG2Sem.html#t:Entity"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambda.CFG2Sem",
          "name": "John",
          "package": "liboleg",
          "signature": "John",
          "source": "src/Lambda-CFG2Sem.html#Entity",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambda CFG2Sem",
          "module": "Lambda.CFG2Sem",
          "name": "John",
          "package": "liboleg",
          "partial": "John",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Lambda-CFG2Sem.html#v:John"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambda.CFG2Sem",
          "name": "Mary",
          "package": "liboleg",
          "signature": "Mary",
          "source": "src/Lambda-CFG2Sem.html#Entity",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambda CFG2Sem",
          "module": "Lambda.CFG2Sem",
          "name": "Mary",
          "package": "liboleg",
          "partial": "Mary",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Lambda-CFG2Sem.html#v:Mary"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambda.CFG2Sem",
          "name": "john",
          "package": "liboleg",
          "signature": "Entity",
          "source": "src/Lambda-CFG2Sem.html#john",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambda CFG2Sem",
          "module": "Lambda.CFG2Sem",
          "name": "john",
          "package": "liboleg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Lambda-CFG2Sem.html#v:john"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambda.CFG2Sem",
          "name": "like",
          "package": "liboleg",
          "signature": "Entity -\u003e Entity -\u003e Bool",
          "source": "src/Lambda-CFG2Sem.html#like",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambda CFG2Sem",
          "module": "Lambda.CFG2Sem",
          "name": "like",
          "normalized": "Entity-\u003eEntity-\u003eBool",
          "package": "liboleg",
          "signature": "Entity-\u003eEntity-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Lambda-CFG2Sem.html#v:like"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambda.CFG2Sem",
          "name": "mary",
          "package": "liboleg",
          "signature": "Entity",
          "source": "src/Lambda-CFG2Sem.html#mary",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambda CFG2Sem",
          "module": "Lambda.CFG2Sem",
          "name": "mary",
          "package": "liboleg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Lambda-CFG2Sem.html#v:mary"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambda.CFG2Sem",
          "name": "r1",
          "package": "liboleg",
          "signature": "Entity -\u003e (Entity -\u003e Bool) -\u003e Bool",
          "source": "src/Lambda-CFG2Sem.html#r1",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambda CFG2Sem",
          "module": "Lambda.CFG2Sem",
          "name": "r1",
          "normalized": "Entity-\u003e(Entity-\u003eBool)-\u003eBool",
          "package": "liboleg",
          "signature": "Entity-\u003e(Entity-\u003eBool)-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Lambda-CFG2Sem.html#v:r1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambda.CFG2Sem",
          "name": "r2",
          "package": "liboleg",
          "signature": "(Entity -\u003e Entity -\u003e Bool) -\u003e Entity -\u003e Entity -\u003e Bool",
          "source": "src/Lambda-CFG2Sem.html#r2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambda CFG2Sem",
          "module": "Lambda.CFG2Sem",
          "name": "r2",
          "normalized": "(Entity-\u003eEntity-\u003eBool)-\u003eEntity-\u003eEntity-\u003eBool",
          "package": "liboleg",
          "signature": "(Entity-\u003eEntity-\u003eBool)-\u003eEntity-\u003eEntity-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Lambda-CFG2Sem.html#v:r2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA new notation for \u003ccode\u003e\u003ca\u003elike\u003c/a\u003e\u003c/code\u003e (which will be convenient later)\n\u003c/p\u003e",
          "module": "Lambda.CFG2Sem",
          "name": "sentence",
          "package": "liboleg",
          "signature": "Bool",
          "source": "src/Lambda-CFG2Sem.html#sentence",
          "type": "function"
        },
        "index": {
          "description": "new notation for like which will be convenient later",
          "hierarchy": "Lambda CFG2Sem",
          "module": "Lambda.CFG2Sem",
          "name": "sentence",
          "package": "liboleg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Lambda-CFG2Sem.html#v:sentence"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eIntroducing type constants\n\u003c/p\u003e\u003cp\u003eWe wish to outlaw terms such as bad_sentence in CFG2EN.hs,\n even though there may be an interpretation that accepts\n these bad terms.\n We really wish our terms represent all and only\n valid CFG derivations. We accomplish this goal here.\n Our approach is reminiscent of LCF.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Lambda.CFG3EN",
          "name": "CFG3EN",
          "package": "liboleg",
          "source": "src/Lambda-CFG3EN.html",
          "type": "module"
        },
        "index": {
          "description": "Introducing type constants We wish to outlaw terms such as bad sentence in CFG2EN.hs even though there may be an interpretation that accepts these bad terms We really wish our terms represent all and only valid CFG derivations We accomplish this goal here Our approach is reminiscent of LCF",
          "hierarchy": "Lambda CFG3EN",
          "module": "Lambda.CFG3EN",
          "name": "CFG3EN",
          "package": "liboleg",
          "partial": "CFG EN",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Lambda-CFG3EN.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eParameterized types: cf notation:\n\u003c/p\u003e\u003cpre\u003e \u003cstring,features\u003e in\n\u003c/pre\u003e\u003cp\u003ethe Minimalist Grammar\n\u003c/p\u003e",
          "module": "Lambda.CFG3EN",
          "name": "EN",
          "package": "liboleg",
          "source": "src/Lambda-CFG3EN.html#EN",
          "type": "data"
        },
        "index": {
          "description": "Parameterized types cf notation string features in the Minimalist Grammar",
          "hierarchy": "Lambda CFG3EN",
          "module": "Lambda.CFG3EN",
          "name": "EN",
          "package": "liboleg",
          "partial": "EN",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Lambda-CFG3EN.html#t:EN"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambda.CFG3EN",
          "name": "NP",
          "package": "liboleg",
          "source": "src/Lambda-CFG3EN.html#NP",
          "type": "data"
        },
        "index": {
          "hierarchy": "Lambda CFG3EN",
          "module": "Lambda.CFG3EN",
          "name": "NP",
          "package": "liboleg",
          "partial": "NP",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Lambda-CFG3EN.html#t:NP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambda.CFG3EN",
          "name": "S",
          "package": "liboleg",
          "source": "src/Lambda-CFG3EN.html#S",
          "type": "data"
        },
        "index": {
          "hierarchy": "Lambda CFG3EN",
          "module": "Lambda.CFG3EN",
          "name": "S",
          "package": "liboleg",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Lambda-CFG3EN.html#t:S"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambda.CFG3EN",
          "name": "TV",
          "package": "liboleg",
          "source": "src/Lambda-CFG3EN.html#TV",
          "type": "data"
        },
        "index": {
          "hierarchy": "Lambda CFG3EN",
          "module": "Lambda.CFG3EN",
          "name": "TV",
          "package": "liboleg",
          "partial": "TV",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Lambda-CFG3EN.html#t:TV"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambda.CFG3EN",
          "name": "VP",
          "package": "liboleg",
          "source": "src/Lambda-CFG3EN.html#VP",
          "type": "data"
        },
        "index": {
          "hierarchy": "Lambda CFG3EN",
          "module": "Lambda.CFG3EN",
          "name": "VP",
          "package": "liboleg",
          "partial": "VP",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Lambda-CFG3EN.html#t:VP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambda.CFG3EN",
          "name": "EN",
          "package": "liboleg",
          "signature": "EN",
          "source": "src/Lambda-CFG3EN.html#EN",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambda CFG3EN",
          "module": "Lambda.CFG3EN",
          "name": "EN",
          "package": "liboleg",
          "partial": "EN",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Lambda-CFG3EN.html#v:EN"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambda.CFG3EN",
          "name": "john",
          "package": "liboleg",
          "signature": "EN NP",
          "source": "src/Lambda-CFG3EN.html#john",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambda CFG3EN",
          "module": "Lambda.CFG3EN",
          "name": "john",
          "package": "liboleg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Lambda-CFG3EN.html#v:john"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambda.CFG3EN",
          "name": "like",
          "package": "liboleg",
          "signature": "EN TV",
          "source": "src/Lambda-CFG3EN.html#like",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambda CFG3EN",
          "module": "Lambda.CFG3EN",
          "name": "like",
          "package": "liboleg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Lambda-CFG3EN.html#v:like"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eOne may think of the above data declaration as defining an\n isomorphism between EN values and Strings. The functions\n EN and unEN (what is their type?) witness the isomorphism.\n It helps to look at their composition.\n\u003c/p\u003e",
          "module": "Lambda.CFG3EN",
          "name": "mary",
          "package": "liboleg",
          "signature": "EN NP",
          "source": "src/Lambda-CFG3EN.html#mary",
          "type": "function"
        },
        "index": {
          "description": "One may think of the above data declaration as defining an isomorphism between EN values and Strings The functions EN and unEN what is their type witness the isomorphism It helps to look at their composition",
          "hierarchy": "Lambda CFG3EN",
          "module": "Lambda.CFG3EN",
          "name": "mary",
          "package": "liboleg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Lambda-CFG3EN.html#v:mary"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambda.CFG3EN",
          "name": "r1",
          "package": "liboleg",
          "signature": "EN NP -\u003e EN VP -\u003e EN S",
          "source": "src/Lambda-CFG3EN.html#r1",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambda CFG3EN",
          "module": "Lambda.CFG3EN",
          "name": "r1",
          "normalized": "EN NP-\u003eEN VP-\u003eEN S",
          "package": "liboleg",
          "signature": "EN NP-\u003eEN VP-\u003eEN S",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Lambda-CFG3EN.html#v:r1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambda.CFG3EN",
          "name": "r2",
          "package": "liboleg",
          "signature": "EN TV -\u003e EN NP -\u003e EN VP",
          "source": "src/Lambda-CFG3EN.html#r2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambda CFG3EN",
          "module": "Lambda.CFG3EN",
          "name": "r2",
          "normalized": "EN TV-\u003eEN NP-\u003eEN VP",
          "package": "liboleg",
          "signature": "EN TV-\u003eEN NP-\u003eEN VP",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Lambda-CFG3EN.html#v:r2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambda.CFG3EN",
          "name": "sentence",
          "package": "liboleg",
          "signature": "EN S",
          "source": "src/Lambda-CFG3EN.html#sentence",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambda CFG3EN",
          "module": "Lambda.CFG3EN",
          "name": "sentence",
          "package": "liboleg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Lambda-CFG3EN.html#v:sentence"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambda.CFG3EN",
          "name": "unEN",
          "package": "liboleg",
          "signature": "String",
          "source": "src/Lambda-CFG3EN.html#EN",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambda CFG3EN",
          "module": "Lambda.CFG3EN",
          "name": "unEN",
          "package": "liboleg",
          "partial": "EN",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Lambda-CFG3EN.html#v:unEN"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eType functions: interpretations of the type constants\n\u003c/p\u003e\u003cp\u003e\u003ca\u003ehttp://okmij.org/ftp/gengo/NASSLLI10/\u003c/a\u003e\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Lambda.CFG3Sem",
          "name": "CFG3Sem",
          "package": "liboleg",
          "source": "src/Lambda-CFG3Sem.html",
          "type": "module"
        },
        "index": {
          "description": "Type functions interpretations of the type constants http okmij.org ftp gengo NASSLLI10",
          "hierarchy": "Lambda CFG3Sem",
          "module": "Lambda.CFG3Sem",
          "name": "CFG3Sem",
          "package": "liboleg",
          "partial": "CFG Sem",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Lambda-CFG3Sem.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambda.CFG3Sem",
          "name": "Entity",
          "package": "liboleg",
          "source": "src/Lambda-CFG3Sem.html#Entity",
          "type": "data"
        },
        "index": {
          "hierarchy": "Lambda CFG3Sem",
          "module": "Lambda.CFG3Sem",
          "name": "Entity",
          "package": "liboleg",
          "partial": "Entity",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Lambda-CFG3Sem.html#t:Entity"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambda.CFG3Sem",
          "name": "NP",
          "package": "liboleg",
          "source": "src/Lambda-CFG3Sem.html#NP",
          "type": "data"
        },
        "index": {
          "hierarchy": "Lambda CFG3Sem",
          "module": "Lambda.CFG3Sem",
          "name": "NP",
          "package": "liboleg",
          "partial": "NP",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Lambda-CFG3Sem.html#t:NP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambda.CFG3Sem",
          "name": "S",
          "package": "liboleg",
          "source": "src/Lambda-CFG3Sem.html#S",
          "type": "data"
        },
        "index": {
          "hierarchy": "Lambda CFG3Sem",
          "module": "Lambda.CFG3Sem",
          "name": "S",
          "package": "liboleg",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Lambda-CFG3Sem.html#t:S"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambda.CFG3Sem",
          "name": "Sem",
          "package": "liboleg",
          "source": "src/Lambda-CFG3Sem.html#Sem",
          "type": "data"
        },
        "index": {
          "hierarchy": "Lambda CFG3Sem",
          "module": "Lambda.CFG3Sem",
          "name": "Sem",
          "package": "liboleg",
          "partial": "Sem",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Lambda-CFG3Sem.html#t:Sem"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambda.CFG3Sem",
          "name": "TV",
          "package": "liboleg",
          "source": "src/Lambda-CFG3Sem.html#TV",
          "type": "data"
        },
        "index": {
          "hierarchy": "Lambda CFG3Sem",
          "module": "Lambda.CFG3Sem",
          "name": "TV",
          "package": "liboleg",
          "partial": "TV",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Lambda-CFG3Sem.html#t:TV"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Lambda.CFG3Sem\",\"Lambda.CFG4\"]",
          "name": "Tr",
          "package": "liboleg",
          "signature": "Tr",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/liboleg/docs/Lambda-CFG3Sem.html#t:Tr\",\"http://hackage.haskell.org/package/liboleg/docs/Lambda-CFG4.html#t:Tr\"]"
        },
        "index": {
          "hierarchy": "Lambda CFG3Sem",
          "module": "Lambda.CFG3Sem",
          "name": "Tr",
          "package": "liboleg",
          "partial": "Tr",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Lambda-CFG3Sem.html#t:Tr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambda.CFG3Sem",
          "name": "VP",
          "package": "liboleg",
          "source": "src/Lambda-CFG3Sem.html#VP",
          "type": "data"
        },
        "index": {
          "hierarchy": "Lambda CFG3Sem",
          "module": "Lambda.CFG3Sem",
          "name": "VP",
          "package": "liboleg",
          "partial": "VP",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Lambda-CFG3Sem.html#t:VP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambda.CFG3Sem",
          "name": "John",
          "package": "liboleg",
          "signature": "John",
          "source": "src/Lambda-CFG3Sem.html#Entity",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambda CFG3Sem",
          "module": "Lambda.CFG3Sem",
          "name": "John",
          "package": "liboleg",
          "partial": "John",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Lambda-CFG3Sem.html#v:John"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambda.CFG3Sem",
          "name": "Mary",
          "package": "liboleg",
          "signature": "Mary",
          "source": "src/Lambda-CFG3Sem.html#Entity",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambda CFG3Sem",
          "module": "Lambda.CFG3Sem",
          "name": "Mary",
          "package": "liboleg",
          "partial": "Mary",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Lambda-CFG3Sem.html#v:Mary"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambda.CFG3Sem",
          "name": "Sem",
          "package": "liboleg",
          "signature": "Sem",
          "source": "src/Lambda-CFG3Sem.html#Sem",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambda CFG3Sem",
          "module": "Lambda.CFG3Sem",
          "name": "Sem",
          "package": "liboleg",
          "partial": "Sem",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Lambda-CFG3Sem.html#v:Sem"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambda.CFG3Sem",
          "name": "john",
          "package": "liboleg",
          "signature": "Sem NP",
          "source": "src/Lambda-CFG3Sem.html#john",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambda CFG3Sem",
          "module": "Lambda.CFG3Sem",
          "name": "john",
          "package": "liboleg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Lambda-CFG3Sem.html#v:john"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambda.CFG3Sem",
          "name": "like",
          "package": "liboleg",
          "signature": "Sem TV",
          "source": "src/Lambda-CFG3Sem.html#like",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambda CFG3Sem",
          "module": "Lambda.CFG3Sem",
          "name": "like",
          "package": "liboleg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Lambda-CFG3Sem.html#v:like"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambda.CFG3Sem",
          "name": "mary",
          "package": "liboleg",
          "signature": "Sem NP",
          "source": "src/Lambda-CFG3Sem.html#mary",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambda CFG3Sem",
          "module": "Lambda.CFG3Sem",
          "name": "mary",
          "package": "liboleg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Lambda-CFG3Sem.html#v:mary"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambda.CFG3Sem",
          "name": "r1",
          "package": "liboleg",
          "signature": "Sem NP -\u003e Sem VP -\u003e Sem S",
          "source": "src/Lambda-CFG3Sem.html#r1",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambda CFG3Sem",
          "module": "Lambda.CFG3Sem",
          "name": "r1",
          "normalized": "Sem NP-\u003eSem VP-\u003eSem S",
          "package": "liboleg",
          "signature": "Sem NP-\u003eSem VP-\u003eSem S",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Lambda-CFG3Sem.html#v:r1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambda.CFG3Sem",
          "name": "r2",
          "package": "liboleg",
          "signature": "Sem TV -\u003e Sem NP -\u003e Sem VP",
          "source": "src/Lambda-CFG3Sem.html#r2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambda CFG3Sem",
          "module": "Lambda.CFG3Sem",
          "name": "r2",
          "normalized": "Sem TV-\u003eSem NP-\u003eSem VP",
          "package": "liboleg",
          "signature": "Sem TV-\u003eSem NP-\u003eSem VP",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Lambda-CFG3Sem.html#v:r2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambda.CFG3Sem",
          "name": "sentence",
          "package": "liboleg",
          "signature": "Sem S",
          "source": "src/Lambda-CFG3Sem.html#sentence",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambda CFG3Sem",
          "module": "Lambda.CFG3Sem",
          "name": "sentence",
          "package": "liboleg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Lambda-CFG3Sem.html#v:sentence"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambda.CFG3Sem",
          "name": "unSem",
          "package": "liboleg",
          "signature": "Tr a",
          "source": "src/Lambda-CFG3Sem.html#Sem",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambda CFG3Sem",
          "module": "Lambda.CFG3Sem",
          "name": "unSem",
          "package": "liboleg",
          "partial": "Sem",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Lambda-CFG3Sem.html#v:unSem"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eUnifying syntax with semantics\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Lambda.CFG4",
          "name": "CFG4",
          "package": "liboleg",
          "source": "src/Lambda-CFG4.html",
          "type": "module"
        },
        "index": {
          "description": "Unifying syntax with semantics",
          "hierarchy": "Lambda CFG4",
          "module": "Lambda.CFG4",
          "name": "CFG4",
          "package": "liboleg",
          "partial": "CFG",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Lambda-CFG4.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambda.CFG4",
          "name": "EN",
          "package": "liboleg",
          "source": "src/Lambda-CFG4.html#EN",
          "type": "data"
        },
        "index": {
          "hierarchy": "Lambda CFG4",
          "module": "Lambda.CFG4",
          "name": "EN",
          "package": "liboleg",
          "partial": "EN",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Lambda-CFG4.html#t:EN"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambda.CFG4",
          "name": "Entity",
          "package": "liboleg",
          "source": "src/Lambda-CFG4.html#Entity",
          "type": "data"
        },
        "index": {
          "hierarchy": "Lambda CFG4",
          "module": "Lambda.CFG4",
          "name": "Entity",
          "package": "liboleg",
          "partial": "Entity",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Lambda-CFG4.html#t:Entity"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambda.CFG4",
          "name": "NP",
          "package": "liboleg",
          "source": "src/Lambda-CFG4.html#NP",
          "type": "data"
        },
        "index": {
          "hierarchy": "Lambda CFG4",
          "module": "Lambda.CFG4",
          "name": "NP",
          "package": "liboleg",
          "partial": "NP",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Lambda-CFG4.html#t:NP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambda.CFG4",
          "name": "S",
          "package": "liboleg",
          "source": "src/Lambda-CFG4.html#S",
          "type": "data"
        },
        "index": {
          "hierarchy": "Lambda CFG4",
          "module": "Lambda.CFG4",
          "name": "S",
          "package": "liboleg",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Lambda-CFG4.html#t:S"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambda.CFG4",
          "name": "Sem",
          "package": "liboleg",
          "source": "src/Lambda-CFG4.html#Sem",
          "type": "data"
        },
        "index": {
          "hierarchy": "Lambda CFG4",
          "module": "Lambda.CFG4",
          "name": "Sem",
          "package": "liboleg",
          "partial": "Sem",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Lambda-CFG4.html#t:Sem"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambda.CFG4",
          "name": "Symantics",
          "package": "liboleg",
          "source": "src/Lambda-CFG4.html#Symantics",
          "type": "class"
        },
        "index": {
          "hierarchy": "Lambda CFG4",
          "module": "Lambda.CFG4",
          "name": "Symantics",
          "package": "liboleg",
          "partial": "Symantics",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Lambda-CFG4.html#t:Symantics"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambda.CFG4",
          "name": "TV",
          "package": "liboleg",
          "source": "src/Lambda-CFG4.html#TV",
          "type": "data"
        },
        "index": {
          "hierarchy": "Lambda CFG4",
          "module": "Lambda.CFG4",
          "name": "TV",
          "package": "liboleg",
          "partial": "TV",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Lambda-CFG4.html#t:TV"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambda.CFG4",
          "name": "VP",
          "package": "liboleg",
          "source": "src/Lambda-CFG4.html#VP",
          "type": "data"
        },
        "index": {
          "hierarchy": "Lambda CFG4",
          "module": "Lambda.CFG4",
          "name": "VP",
          "package": "liboleg",
          "partial": "VP",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Lambda-CFG4.html#t:VP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambda.CFG4",
          "name": "EN",
          "package": "liboleg",
          "signature": "EN",
          "source": "src/Lambda-CFG4.html#EN",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambda CFG4",
          "module": "Lambda.CFG4",
          "name": "EN",
          "package": "liboleg",
          "partial": "EN",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Lambda-CFG4.html#v:EN"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambda.CFG4",
          "name": "John",
          "package": "liboleg",
          "signature": "John",
          "source": "src/Lambda-CFG4.html#Entity",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambda CFG4",
          "module": "Lambda.CFG4",
          "name": "John",
          "package": "liboleg",
          "partial": "John",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Lambda-CFG4.html#v:John"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambda.CFG4",
          "name": "Mary",
          "package": "liboleg",
          "signature": "Mary",
          "source": "src/Lambda-CFG4.html#Entity",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambda CFG4",
          "module": "Lambda.CFG4",
          "name": "Mary",
          "package": "liboleg",
          "partial": "Mary",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Lambda-CFG4.html#v:Mary"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambda.CFG4",
          "name": "Sem",
          "package": "liboleg",
          "signature": "Sem",
          "source": "src/Lambda-CFG4.html#Sem",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambda CFG4",
          "module": "Lambda.CFG4",
          "name": "Sem",
          "package": "liboleg",
          "partial": "Sem",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Lambda-CFG4.html#v:Sem"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambda.CFG4",
          "name": "john",
          "package": "liboleg",
          "signature": "repr NP",
          "source": "src/Lambda-CFG4.html#john",
          "type": "method"
        },
        "index": {
          "hierarchy": "Lambda CFG4",
          "module": "Lambda.CFG4",
          "name": "john",
          "package": "liboleg",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Lambda-CFG4.html#v:john"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambda.CFG4",
          "name": "like",
          "package": "liboleg",
          "signature": "repr TV",
          "source": "src/Lambda-CFG4.html#like",
          "type": "method"
        },
        "index": {
          "hierarchy": "Lambda CFG4",
          "module": "Lambda.CFG4",
          "name": "like",
          "package": "liboleg",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Lambda-CFG4.html#v:like"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambda.CFG4",
          "name": "mary",
          "package": "liboleg",
          "signature": "repr NP",
          "source": "src/Lambda-CFG4.html#mary",
          "type": "method"
        },
        "index": {
          "hierarchy": "Lambda CFG4",
          "module": "Lambda.CFG4",
          "name": "mary",
          "package": "liboleg",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Lambda-CFG4.html#v:mary"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambda.CFG4",
          "name": "r1",
          "package": "liboleg",
          "signature": "repr NP -\u003e repr VP -\u003e repr S",
          "source": "src/Lambda-CFG4.html#r1",
          "type": "method"
        },
        "index": {
          "hierarchy": "Lambda CFG4",
          "module": "Lambda.CFG4",
          "name": "r1",
          "normalized": "a NP-\u003ea VP-\u003ea S",
          "package": "liboleg",
          "signature": "repr NP-\u003erepr VP-\u003erepr S",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Lambda-CFG4.html#v:r1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambda.CFG4",
          "name": "r2",
          "package": "liboleg",
          "signature": "repr TV -\u003e repr NP -\u003e repr VP",
          "source": "src/Lambda-CFG4.html#r2",
          "type": "method"
        },
        "index": {
          "hierarchy": "Lambda CFG4",
          "module": "Lambda.CFG4",
          "name": "r2",
          "normalized": "a TV-\u003ea NP-\u003ea VP",
          "package": "liboleg",
          "signature": "repr TV-\u003erepr NP-\u003erepr VP",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Lambda-CFG4.html#v:r2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambda.CFG4",
          "name": "unEN",
          "package": "liboleg",
          "signature": "String",
          "source": "src/Lambda-CFG4.html#EN",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambda CFG4",
          "module": "Lambda.CFG4",
          "name": "unEN",
          "package": "liboleg",
          "partial": "EN",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Lambda-CFG4.html#v:unEN"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambda.CFG4",
          "name": "unSem",
          "package": "liboleg",
          "signature": "Tr a",
          "source": "src/Lambda-CFG4.html#Sem",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambda CFG4",
          "module": "Lambda.CFG4",
          "name": "unSem",
          "package": "liboleg",
          "partial": "Sem",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Lambda-CFG4.html#v:unSem"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eInterpreting a CFG derivation as a string in Japanese.\n That is, we generate a yield of a CFG derivation,\n this time in Japanese.\n\u003c/p\u003e\u003cp\u003e\u003ca\u003ehttp://okmij.org/ftp/gengo/NASSLLI10/\u003c/a\u003e\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Lambda.CFGJ",
          "name": "CFGJ",
          "package": "liboleg",
          "source": "src/Lambda-CFGJ.html",
          "type": "module"
        },
        "index": {
          "description": "Interpreting CFG derivation as string in Japanese That is we generate yield of CFG derivation this time in Japanese http okmij.org ftp gengo NASSLLI10",
          "hierarchy": "Lambda CFGJ",
          "module": "Lambda.CFGJ",
          "name": "CFGJ",
          "package": "liboleg",
          "partial": "CFGJ",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Lambda-CFGJ.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA verb or a verb-like word (e.g., an i-adjective) require\n arguments of particular cases. We need a way for a verb\n to specify the desired case of its arguments.\n\u003c/p\u003e",
          "module": "Lambda.CFGJ",
          "name": "Case",
          "package": "liboleg",
          "source": "src/Lambda-CFGJ.html#Case",
          "type": "data"
        },
        "index": {
          "description": "verb or verb-like word e.g an i-adjective require arguments of particular cases We need way for verb to specify the desired case of its arguments",
          "hierarchy": "Lambda CFGJ",
          "module": "Lambda.CFGJ",
          "name": "Case",
          "package": "liboleg",
          "partial": "Case",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Lambda-CFGJ.html#t:Case"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWe represent each node in the derivation tree\n by a Japanese phrase or a Japanese \u003ca\u003esentential form\u003c/a\u003e\n (that is, a phrase with holes). Contrast with the EN\n interpreter in CFG.hs\n\u003c/p\u003e",
          "module": "Lambda.CFGJ",
          "name": "JA",
          "package": "liboleg",
          "source": "src/Lambda-CFGJ.html#JA",
          "type": "data"
        },
        "index": {
          "description": "We represent each node in the derivation tree by Japanese phrase or Japanese sentential form that is phrase with holes Contrast with the EN interpreter in CFG.hs",
          "hierarchy": "Lambda CFGJ",
          "module": "Lambda.CFGJ",
          "name": "JA",
          "package": "liboleg",
          "partial": "JA",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Lambda-CFGJ.html#t:JA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe type family TJ defines the types of\n sentential forms corresponding to syntactic categories.\n\u003c/p\u003e\u003cp\u003eAs we shall see in QCFGJ.hs, we are going to need\n high (raised) types of our NP. \n A verb will ask its argument to turn itself to the\n desired case.\n\u003c/p\u003e",
          "module": "Lambda.CFGJ",
          "name": "SK",
          "package": "liboleg",
          "source": "src/Lambda-CFGJ.html#SK",
          "type": "type"
        },
        "index": {
          "description": "The type family TJ defines the types of sentential forms corresponding to syntactic categories As we shall see in QCFGJ.hs we are going to need high raised types of our NP verb will ask its argument to turn itself to the desired case",
          "hierarchy": "Lambda CFGJ",
          "module": "Lambda.CFGJ",
          "name": "SK",
          "package": "liboleg",
          "partial": "SK",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Lambda-CFGJ.html#t:SK"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambda.CFGJ",
          "name": "Acc",
          "package": "liboleg",
          "signature": "Acc",
          "source": "src/Lambda-CFGJ.html#Case",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambda CFGJ",
          "module": "Lambda.CFGJ",
          "name": "Acc",
          "package": "liboleg",
          "partial": "Acc",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Lambda-CFGJ.html#v:Acc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambda.CFGJ",
          "name": "JA",
          "package": "liboleg",
          "signature": "JA",
          "source": "src/Lambda-CFGJ.html#JA",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambda CFGJ",
          "module": "Lambda.CFGJ",
          "name": "JA",
          "package": "liboleg",
          "partial": "JA",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Lambda-CFGJ.html#v:JA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambda.CFGJ",
          "name": "Nom",
          "package": "liboleg",
          "signature": "Nom",
          "source": "src/Lambda-CFGJ.html#Case",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambda CFGJ",
          "module": "Lambda.CFGJ",
          "name": "Nom",
          "package": "liboleg",
          "partial": "Nom",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Lambda-CFGJ.html#v:Nom"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambda.CFGJ",
          "name": "NomStrong",
          "package": "liboleg",
          "signature": "NomStrong",
          "source": "src/Lambda-CFGJ.html#Case",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambda CFGJ",
          "module": "Lambda.CFGJ",
          "name": "NomStrong",
          "package": "liboleg",
          "partial": "Nom Strong",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Lambda-CFGJ.html#v:NomStrong"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambda.CFGJ",
          "name": "case_particle",
          "package": "liboleg",
          "signature": "Case -\u003e String",
          "source": "src/Lambda-CFGJ.html#case_particle",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambda CFGJ",
          "module": "Lambda.CFGJ",
          "name": "case_particle",
          "normalized": "Case-\u003eString",
          "package": "liboleg",
          "signature": "Case-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Lambda-CFGJ.html#v:case_particle"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAuxiliary functions for the code below\n\u003c/p\u003e",
          "module": "Lambda.CFGJ",
          "name": "make_np",
          "package": "liboleg",
          "signature": "String -\u003e Case -\u003e SK",
          "source": "src/Lambda-CFGJ.html#make_np",
          "type": "function"
        },
        "index": {
          "description": "Auxiliary functions for the code below",
          "hierarchy": "Lambda CFGJ",
          "module": "Lambda.CFGJ",
          "name": "make_np",
          "normalized": "String-\u003eCase-\u003eSK",
          "package": "liboleg",
          "signature": "String-\u003eCase-\u003eSK",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Lambda-CFGJ.html#v:make_np"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambda.CFGJ",
          "name": "make_tv",
          "package": "liboleg",
          "signature": "String -\u003e Case -\u003e Case -\u003e (Case -\u003e SK) -\u003e (Case -\u003e SK) -\u003e String",
          "source": "src/Lambda-CFGJ.html#make_tv",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambda CFGJ",
          "module": "Lambda.CFGJ",
          "name": "make_tv",
          "normalized": "String-\u003eCase-\u003eCase-\u003e(Case-\u003eSK)-\u003e(Case-\u003eSK)-\u003eString",
          "package": "liboleg",
          "signature": "String-\u003eCase-\u003eCase-\u003e(Case-\u003eSK)-\u003e(Case-\u003eSK)-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Lambda-CFGJ.html#v:make_tv"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambda.CFGJ",
          "name": "unJA",
          "package": "liboleg",
          "signature": "TJ a",
          "source": "src/Lambda-CFGJ.html#JA",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambda CFGJ",
          "module": "Lambda.CFGJ",
          "name": "unJA",
          "package": "liboleg",
          "partial": "JA",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Lambda-CFGJ.html#v:unJA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003ePhilippe de Groote. 2010.  Dynamic logic: a type-theoretic view.\n Talk slides at `Le modle et l\u003ccode\u003ealgorithme\u003c/code\u003e, Rocquencourt.\n \u003ca\u003ehttp://www.inria.fr/rocquencourt/rendez-vous/modele-et-algo/dynamic-logic-a-type-theoretic-view\u003c/a\u003e\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Lambda.Dynamics",
          "name": "Dynamics",
          "package": "liboleg",
          "source": "src/Lambda-Dynamics.html",
          "type": "module"
        },
        "index": {
          "description": "Philippe de Groote Dynamic logic type-theoretic view Talk slides at Le modle et algorithme Rocquencourt http www.inria.fr rocquencourt rendez-vous modele-et-algo dynamic-logic-a-type-theoretic-view",
          "hierarchy": "Lambda Dynamics",
          "module": "Lambda.Dynamics",
          "name": "Dynamics",
          "package": "liboleg",
          "partial": "Dynamics",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Lambda-Dynamics.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambda.Dynamics",
          "name": "D",
          "package": "liboleg",
          "source": "src/Lambda-Dynamics.html#D",
          "type": "data"
        },
        "index": {
          "hierarchy": "Lambda Dynamics",
          "module": "Lambda.Dynamics",
          "name": "D",
          "package": "liboleg",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Lambda-Dynamics.html#t:D"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambda.Dynamics",
          "name": "Dynamic",
          "package": "liboleg",
          "signature": "Dynamic",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambda Dynamics",
          "module": "Lambda.Dynamics",
          "name": "Dynamic",
          "package": "liboleg",
          "partial": "Dynamic",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Lambda-Dynamics.html#t:Dynamic"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambda.Dynamics",
          "name": "Dynamics",
          "package": "liboleg",
          "source": "src/Lambda-Dynamics.html#Dynamics",
          "type": "class"
        },
        "index": {
          "hierarchy": "Lambda Dynamics",
          "module": "Lambda.Dynamics",
          "name": "Dynamics",
          "package": "liboleg",
          "partial": "Dynamics",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Lambda-Dynamics.html#t:Dynamics"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambda.Dynamics",
          "name": "Predicate",
          "package": "liboleg",
          "source": "src/Lambda-Dynamics.html#Predicate",
          "type": "class"
        },
        "index": {
          "hierarchy": "Lambda Dynamics",
          "module": "Lambda.Dynamics",
          "name": "Predicate",
          "package": "liboleg",
          "partial": "Predicate",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Lambda-Dynamics.html#t:Predicate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambda.Dynamics",
          "name": "Pronoun",
          "package": "liboleg",
          "source": "src/Lambda-Dynamics.html#Pronoun",
          "type": "class"
        },
        "index": {
          "hierarchy": "Lambda Dynamics",
          "module": "Lambda.Dynamics",
          "name": "Pronoun",
          "package": "liboleg",
          "partial": "Pronoun",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Lambda-Dynamics.html#t:Pronoun"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWe extend the Lambda language with state (of the type State)\n\u003c/p\u003e",
          "module": "Lambda.Dynamics",
          "name": "State",
          "package": "liboleg",
          "source": "src/Lambda-Dynamics.html#State",
          "type": "type"
        },
        "index": {
          "description": "We extend the Lambda language with state of the type State",
          "hierarchy": "Lambda Dynamics",
          "module": "Lambda.Dynamics",
          "name": "State",
          "package": "liboleg",
          "partial": "State",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Lambda-Dynamics.html#t:State"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambda.Dynamics",
          "name": "States",
          "package": "liboleg",
          "source": "src/Lambda-Dynamics.html#States",
          "type": "class"
        },
        "index": {
          "hierarchy": "Lambda Dynamics",
          "module": "Lambda.Dynamics",
          "name": "States",
          "package": "liboleg",
          "partial": "States",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Lambda-Dynamics.html#t:States"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambda.Dynamics",
          "name": "D",
          "package": "liboleg",
          "signature": "D",
          "source": "src/Lambda-Dynamics.html#D",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambda Dynamics",
          "module": "Lambda.Dynamics",
          "name": "D",
          "package": "liboleg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Lambda-Dynamics.html#v:D"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambda.Dynamics",
          "name": "dynamic",
          "package": "liboleg",
          "signature": "(lrepr State -\u003e lrepr a) -\u003e lrepr (Dynamic a)",
          "source": "src/Lambda-Dynamics.html#dynamic",
          "type": "method"
        },
        "index": {
          "hierarchy": "Lambda Dynamics",
          "module": "Lambda.Dynamics",
          "name": "dynamic",
          "normalized": "(a State-\u003ea b)-\u003ea(Dynamic b)",
          "package": "liboleg",
          "signature": "(lrepr State-\u003elrepr a)-\u003elrepr(Dynamic a)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Lambda-Dynamics.html#v:dynamic"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambda.Dynamics",
          "name": "it'",
          "package": "liboleg",
          "signature": "lrepr ((Entity -\u003e Bool) -\u003e Bool)",
          "source": "src/Lambda-Dynamics.html#it%27",
          "type": "method"
        },
        "index": {
          "hierarchy": "Lambda Dynamics",
          "module": "Lambda.Dynamics",
          "name": "it'",
          "normalized": "a((Entity-\u003eBool)-\u003eBool)",
          "package": "liboleg",
          "signature": "lrepr((Entity-\u003eBool)-\u003eBool)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Lambda-Dynamics.html#v:it-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambda.Dynamics",
          "name": "it_",
          "package": "liboleg",
          "signature": "repr QNP",
          "source": "src/Lambda-Dynamics.html#it_",
          "type": "method"
        },
        "index": {
          "hierarchy": "Lambda Dynamics",
          "module": "Lambda.Dynamics",
          "name": "it_",
          "package": "liboleg",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Lambda-Dynamics.html#v:it_"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambda.Dynamics",
          "name": "select",
          "package": "liboleg",
          "signature": "lrepr State -\u003e lrepr Entity",
          "source": "src/Lambda-Dynamics.html#select",
          "type": "method"
        },
        "index": {
          "hierarchy": "Lambda Dynamics",
          "module": "Lambda.Dynamics",
          "name": "select",
          "normalized": "a State-\u003ea Entity",
          "package": "liboleg",
          "signature": "lrepr State-\u003elrepr Entity",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Lambda-Dynamics.html#v:select"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambda.Dynamics",
          "name": "static",
          "package": "liboleg",
          "signature": "lrepr (Dynamic a) -\u003e lrepr State -\u003e lrepr a",
          "source": "src/Lambda-Dynamics.html#static",
          "type": "method"
        },
        "index": {
          "hierarchy": "Lambda Dynamics",
          "module": "Lambda.Dynamics",
          "name": "static",
          "normalized": "a(Dynamic b)-\u003ea State-\u003ea b",
          "package": "liboleg",
          "signature": "lrepr(Dynamic a)-\u003elrepr State-\u003elrepr a",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Lambda-Dynamics.html#v:static"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambda.Dynamics",
          "name": "unD",
          "package": "liboleg",
          "signature": "c (Dynamic a)",
          "source": "src/Lambda-Dynamics.html#D",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambda Dynamics",
          "module": "Lambda.Dynamics",
          "name": "unD",
          "package": "liboleg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Lambda-Dynamics.html#v:unD"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambda.Dynamics",
          "name": "update",
          "package": "liboleg",
          "signature": "lrepr Entity -\u003e lrepr State -\u003e lrepr State",
          "source": "src/Lambda-Dynamics.html#update",
          "type": "method"
        },
        "index": {
          "hierarchy": "Lambda Dynamics",
          "module": "Lambda.Dynamics",
          "name": "update",
          "normalized": "a Entity-\u003ea State-\u003ea State",
          "package": "liboleg",
          "signature": "lrepr Entity-\u003elrepr State-\u003elrepr State",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Lambda-Dynamics.html#v:update"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eContext-free grammar with quantifiers\n\u003c/p\u003e\u003cp\u003eWe extend CFG.hs to add quantified noun phrases\n in the tradition of Montague\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Lambda.QCFG",
          "name": "QCFG",
          "package": "liboleg",
          "source": "src/Lambda-QCFG.html",
          "type": "module"
        },
        "index": {
          "description": "Context-free grammar with quantifiers We extend CFG.hs to add quantified noun phrases in the tradition of Montague",
          "hierarchy": "Lambda QCFG",
          "module": "Lambda.QCFG",
          "name": "QCFG",
          "package": "liboleg",
          "partial": "QCFG",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Lambda-QCFG.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAdditional syntactic categories\n\u003c/p\u003e",
          "module": "Lambda.QCFG",
          "name": "CN",
          "package": "liboleg",
          "source": "src/Lambda-QCFG.html#CN",
          "type": "data"
        },
        "index": {
          "description": "Additional syntactic categories",
          "hierarchy": "Lambda QCFG",
          "module": "Lambda.QCFG",
          "name": "CN",
          "package": "liboleg",
          "partial": "CN",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Lambda-QCFG.html#t:CN"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambda.QCFG",
          "name": "QNP",
          "package": "liboleg",
          "source": "src/Lambda-QCFG.html#QNP",
          "type": "data"
        },
        "index": {
          "hierarchy": "Lambda QCFG",
          "module": "Lambda.QCFG",
          "name": "QNP",
          "package": "liboleg",
          "partial": "QNP",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Lambda-QCFG.html#t:QNP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWe extend our earlier fragment with common nouns farmer and donkey,\n and quantifiers everyone, someone, every farmer, a donkey, etc.\n Since we added two new categories (CN and QNP), we need to add rules\n to our CFG to be able to use the categories in derivations.\n\u003c/p\u003e\u003cp\u003eThe numbers 4 and 5 are due to Montague\n\u003c/p\u003e",
          "module": "Lambda.QCFG",
          "name": "Quantifier",
          "package": "liboleg",
          "source": "src/Lambda-QCFG.html#Quantifier",
          "type": "class"
        },
        "index": {
          "description": "We extend our earlier fragment with common nouns farmer and donkey and quantifiers everyone someone every farmer donkey etc Since we added two new categories CN and QNP we need to add rules to our CFG to be able to use the categories in derivations The numbers and are due to Montague",
          "hierarchy": "Lambda QCFG",
          "module": "Lambda.QCFG",
          "name": "Quantifier",
          "package": "liboleg",
          "partial": "Quantifier",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Lambda-QCFG.html#t:Quantifier"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambda.QCFG",
          "name": "a",
          "package": "liboleg",
          "signature": "repr CN -\u003e repr QNP",
          "source": "src/Lambda-QCFG.html#a",
          "type": "method"
        },
        "index": {
          "hierarchy": "Lambda QCFG",
          "module": "Lambda.QCFG",
          "name": "a",
          "normalized": "a CN-\u003ea QNP",
          "package": "liboleg",
          "signature": "repr CN-\u003erepr QNP",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Lambda-QCFG.html#v:a"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambda.QCFG",
          "name": "donkey",
          "package": "liboleg",
          "signature": "repr CN",
          "source": "src/Lambda-QCFG.html#donkey",
          "type": "method"
        },
        "index": {
          "hierarchy": "Lambda QCFG",
          "module": "Lambda.QCFG",
          "name": "donkey",
          "package": "liboleg",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Lambda-QCFG.html#v:donkey"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambda.QCFG",
          "name": "every",
          "package": "liboleg",
          "signature": "repr CN -\u003e repr QNP",
          "source": "src/Lambda-QCFG.html#every",
          "type": "method"
        },
        "index": {
          "hierarchy": "Lambda QCFG",
          "module": "Lambda.QCFG",
          "name": "every",
          "normalized": "a CN-\u003ea QNP",
          "package": "liboleg",
          "signature": "repr CN-\u003erepr QNP",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Lambda-QCFG.html#v:every"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambda.QCFG",
          "name": "everyone",
          "package": "liboleg",
          "signature": "repr QNP",
          "source": "src/Lambda-QCFG.html#everyone",
          "type": "method"
        },
        "index": {
          "hierarchy": "Lambda QCFG",
          "module": "Lambda.QCFG",
          "name": "everyone",
          "package": "liboleg",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Lambda-QCFG.html#v:everyone"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambda.QCFG",
          "name": "farmer",
          "package": "liboleg",
          "signature": "repr CN",
          "source": "src/Lambda-QCFG.html#farmer",
          "type": "method"
        },
        "index": {
          "hierarchy": "Lambda QCFG",
          "module": "Lambda.QCFG",
          "name": "farmer",
          "package": "liboleg",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Lambda-QCFG.html#v:farmer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambda.QCFG",
          "name": "r4",
          "package": "liboleg",
          "signature": "repr QNP -\u003e repr VP -\u003e repr S",
          "source": "src/Lambda-QCFG.html#r4",
          "type": "method"
        },
        "index": {
          "hierarchy": "Lambda QCFG",
          "module": "Lambda.QCFG",
          "name": "r4",
          "normalized": "a QNP-\u003ea VP-\u003ea S",
          "package": "liboleg",
          "signature": "repr QNP-\u003erepr VP-\u003erepr S",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Lambda-QCFG.html#v:r4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambda.QCFG",
          "name": "r5",
          "package": "liboleg",
          "signature": "repr TV -\u003e repr QNP -\u003e repr VP",
          "source": "src/Lambda-QCFG.html#r5",
          "type": "method"
        },
        "index": {
          "hierarchy": "Lambda QCFG",
          "module": "Lambda.QCFG",
          "name": "r5",
          "normalized": "a TV-\u003ea QNP-\u003ea VP",
          "package": "liboleg",
          "signature": "repr TV-\u003erepr QNP-\u003erepr VP",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Lambda-QCFG.html#v:r5"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambda.QCFG",
          "name": "someone",
          "package": "liboleg",
          "signature": "repr QNP",
          "source": "src/Lambda-QCFG.html#someone",
          "type": "method"
        },
        "index": {
          "hierarchy": "Lambda QCFG",
          "module": "Lambda.QCFG",
          "name": "someone",
          "package": "liboleg",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Lambda-QCFG.html#v:someone"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambda.QCFG",
          "name": "who",
          "package": "liboleg",
          "signature": "repr VP -\u003e repr CN -\u003e repr CN",
          "source": "src/Lambda-QCFG.html#who",
          "type": "method"
        },
        "index": {
          "hierarchy": "Lambda QCFG",
          "module": "Lambda.QCFG",
          "name": "who",
          "normalized": "a VP-\u003ea CN-\u003ea CN",
          "package": "liboleg",
          "signature": "repr VP-\u003erepr CN-\u003erepr CN",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Lambda-QCFG.html#v:who"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eInterpreting a CFG derivation with quantifiers\n as a string in Japanese.\n That is, we generate a yield of a CFG derivation,\n this time in Japanese.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Lambda.QCFGJ",
          "name": "QCFGJ",
          "package": "liboleg",
          "source": "src/Lambda-QCFGJ.html",
          "type": "module"
        },
        "index": {
          "description": "Interpreting CFG derivation with quantifiers as string in Japanese That is we generate yield of CFG derivation this time in Japanese",
          "hierarchy": "Lambda QCFGJ",
          "module": "Lambda.QCFGJ",
          "name": "QCFGJ",
          "package": "liboleg",
          "partial": "QCFGJ",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Lambda-QCFGJ.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eContext-free grammar with quantifiers\n A different ways to add quantification, via \n Higher-Order abstract syntax (HOAS).\n This is a \u003ca\u003erational reconstruction\u003c/a\u003e of Montague's\n general approach of `administrative pronouns', which\n later gave rise to the Quantifier Raising (QR)\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Lambda.QHCFG",
          "name": "QHCFG",
          "package": "liboleg",
          "source": "src/Lambda-QHCFG.html",
          "type": "module"
        },
        "index": {
          "description": "Context-free grammar with quantifiers different ways to add quantification via Higher-Order abstract syntax HOAS This is rational reconstruction of Montague general approach of administrative pronouns which later gave rise to the Quantifier Raising QR",
          "hierarchy": "Lambda QHCFG",
          "module": "Lambda.QHCFG",
          "name": "QHCFG",
          "package": "liboleg",
          "partial": "QHCFG",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Lambda-QHCFG.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eNo longer any need in a new syntactic category QNP\n We leave out CN as an exercise\n\u003c/p\u003e\u003cpre\u003e data CN                                      -- Common noun\n\u003c/pre\u003e\u003cp\u003eWe extend our earlier fragment with quantifiers everyone, someone.\n In contrast to QCFG.hs, we do not add any new syntactic category,\n so we don't need to add any rules to our CFG.\n\u003c/p\u003e",
          "module": "Lambda.QHCFG",
          "name": "Quantifier",
          "package": "liboleg",
          "source": "src/Lambda-QHCFG.html#Quantifier",
          "type": "class"
        },
        "index": {
          "description": "No longer any need in new syntactic category QNP We leave out CN as an exercise data CN Common noun We extend our earlier fragment with quantifiers everyone someone In contrast to QCFG.hs we do not add any new syntactic category so we don need to add any rules to our CFG",
          "hierarchy": "Lambda QHCFG",
          "module": "Lambda.QHCFG",
          "name": "Quantifier",
          "package": "liboleg",
          "partial": "Quantifier",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Lambda-QHCFG.html#t:Quantifier"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambda.QHCFG",
          "name": "everyone",
          "package": "liboleg",
          "signature": "(repr NP -\u003e repr S) -\u003e repr S",
          "source": "src/Lambda-QHCFG.html#everyone",
          "type": "method"
        },
        "index": {
          "hierarchy": "Lambda QHCFG",
          "module": "Lambda.QHCFG",
          "name": "everyone",
          "normalized": "(a NP-\u003ea S)-\u003ea S",
          "package": "liboleg",
          "signature": "(repr NP-\u003erepr S)-\u003erepr S",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Lambda-QHCFG.html#v:everyone"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambda.QHCFG",
          "name": "someone",
          "package": "liboleg",
          "signature": "(repr NP -\u003e repr S) -\u003e repr S",
          "source": "src/Lambda-QHCFG.html#someone",
          "type": "method"
        },
        "index": {
          "hierarchy": "Lambda QHCFG",
          "module": "Lambda.QHCFG",
          "name": "someone",
          "normalized": "(a NP-\u003ea S)-\u003ea S",
          "package": "liboleg",
          "signature": "(repr NP-\u003erepr S)-\u003erepr S",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Lambda-QHCFG.html#v:someone"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambda.Semantics",
          "name": "Semantics",
          "package": "liboleg",
          "source": "src/Lambda-Semantics.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Lambda Semantics",
          "module": "Lambda.Semantics",
          "name": "Semantics",
          "package": "liboleg",
          "partial": "Semantics",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Lambda-Semantics.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ca\u003eRunning\u003c/a\u003e the examples\n\u003c/p\u003e\u003cp\u003eWe now interpret Lambda terms as Strings, so we can show\n our formulas.\n Actually, not quite strings: we need a bit of _context_:\n the precedence and the number of variables already bound in the context.\n The latter number lets us generate unique variable names.\n\u003c/p\u003e",
          "module": "Lambda.Semantics",
          "name": "C",
          "package": "liboleg",
          "source": "src/Lambda-Semantics.html#C",
          "type": "data"
        },
        "index": {
          "description": "Running the examples We now interpret Lambda terms as Strings so we can show our formulas Actually not quite strings we need bit of context the precedence and the number of variables already bound in the context The latter number lets us generate unique variable names",
          "hierarchy": "Lambda Semantics",
          "module": "Lambda.Semantics",
          "name": "C",
          "package": "liboleg",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Lambda-Semantics.html#t:C"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eHere we encode the \u003ca\u003etarget language\u003c/a\u003e, the language\n to express denotations (or, meanings)\n Following Montague, our language for denotations\n is essentially Church's \u003ca\u003eSimple Theory of Types\u003c/a\u003e\n also known as simply-typed lambda-calculus\n It is a form of a higher-order predicate logic.\n\u003c/p\u003e",
          "module": "Lambda.Semantics",
          "name": "Entity",
          "package": "liboleg",
          "source": "src/Lambda-Semantics.html#Entity",
          "type": "data"
        },
        "index": {
          "description": "Here we encode the target language the language to express denotations or meanings Following Montague our language for denotations is essentially Church Simple Theory of Types also known as simply-typed lambda-calculus It is form of higher-order predicate logic",
          "hierarchy": "Lambda Semantics",
          "module": "Lambda.Semantics",
          "name": "Entity",
          "package": "liboleg",
          "partial": "Entity",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Lambda-Semantics.html#t:Entity"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWe can now see the examples\n\u003c/p\u003e\u003cp\u003eThe displayed difference between lsen4 and lsen4'\n shows that beta-redices have been reduced. NBE.\n\u003c/p\u003e\u003cp\u003eNormalizing the terms: performing the apparent redices\n\u003c/p\u003e",
          "module": "Lambda.Semantics",
          "name": "Known",
          "package": "liboleg",
          "signature": "Known",
          "type": "function"
        },
        "index": {
          "description": "We can now see the examples The displayed difference between lsen4 and lsen4 shows that beta-redices have been reduced NBE Normalizing the terms performing the apparent redices",
          "hierarchy": "Lambda Semantics",
          "module": "Lambda.Semantics",
          "name": "Known",
          "package": "liboleg",
          "partial": "Known",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Lambda-Semantics.html#t:Known"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWe define the grammar of the target language the same way\n we have defined the grammar for (source) fragment\n\u003c/p\u003e",
          "module": "Lambda.Semantics",
          "name": "Lambda",
          "package": "liboleg",
          "source": "src/Lambda-Semantics.html#Lambda",
          "type": "class"
        },
        "index": {
          "description": "We define the grammar of the target language the same way we have defined the grammar for source fragment",
          "hierarchy": "Lambda Semantics",
          "module": "Lambda.Semantics",
          "name": "Lambda",
          "package": "liboleg",
          "partial": "Lambda",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Lambda-Semantics.html#t:Lambda"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambda.Semantics",
          "name": "P",
          "package": "liboleg",
          "source": "src/Lambda-Semantics.html#P",
          "type": "data"
        },
        "index": {
          "hierarchy": "Lambda Semantics",
          "module": "Lambda.Semantics",
          "name": "P",
          "package": "liboleg",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Lambda-Semantics.html#t:P"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSyntactic sugar\n\u003c/p\u003e\u003cp\u003eThe first interpretation: evaluating in the world with John, Mary,\n and Bool as truth values.\n Lambda functions are interpreted as Haskell functions and Lambda\n applications are interpreted as Haskell applications.\n The interpreter R is metacircular (and so, efficient).\n\u003c/p\u003e",
          "module": "Lambda.Semantics",
          "name": "R",
          "package": "liboleg",
          "source": "src/Lambda-Semantics.html#R",
          "type": "data"
        },
        "index": {
          "description": "Syntactic sugar The first interpretation evaluating in the world with John Mary and Bool as truth values Lambda functions are interpreted as Haskell functions and Lambda applications are interpreted as Haskell applications The interpreter is metacircular and so efficient",
          "hierarchy": "Lambda Semantics",
          "module": "Lambda.Semantics",
          "name": "R",
          "package": "liboleg",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Lambda-Semantics.html#t:R"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambda.Semantics",
          "name": "C",
          "package": "liboleg",
          "signature": "C",
          "source": "src/Lambda-Semantics.html#C",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambda Semantics",
          "module": "Lambda.Semantics",
          "name": "C",
          "package": "liboleg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Lambda-Semantics.html#v:C"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambda.Semantics",
          "name": "John",
          "package": "liboleg",
          "signature": "John",
          "source": "src/Lambda-Semantics.html#Entity",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambda Semantics",
          "module": "Lambda.Semantics",
          "name": "John",
          "package": "liboleg",
          "partial": "John",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Lambda-Semantics.html#v:John"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambda.Semantics",
          "name": "Mary",
          "package": "liboleg",
          "signature": "Mary",
          "source": "src/Lambda-Semantics.html#Entity",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambda Semantics",
          "module": "Lambda.Semantics",
          "name": "Mary",
          "package": "liboleg",
          "partial": "Mary",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Lambda-Semantics.html#v:Mary"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambda.Semantics",
          "name": "P",
          "package": "liboleg",
          "signature": "P",
          "source": "src/Lambda-Semantics.html#P",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambda Semantics",
          "module": "Lambda.Semantics",
          "name": "P",
          "package": "liboleg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Lambda-Semantics.html#v:P"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambda.Semantics",
          "name": "R",
          "package": "liboleg",
          "signature": "R",
          "source": "src/Lambda-Semantics.html#R",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambda Semantics",
          "module": "Lambda.Semantics",
          "name": "R",
          "package": "liboleg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Lambda-Semantics.html#v:R"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambda.Semantics",
          "name": "app",
          "package": "liboleg",
          "signature": "lrepr (a -\u003e b) -\u003e lrepr a -\u003e lrepr b",
          "source": "src/Lambda-Semantics.html#app",
          "type": "method"
        },
        "index": {
          "hierarchy": "Lambda Semantics",
          "module": "Lambda.Semantics",
          "name": "app",
          "normalized": "a(b-\u003ec)-\u003ea b-\u003ea c",
          "package": "liboleg",
          "signature": "lrepr(a-\u003eb)-\u003elrepr a-\u003elrepr b",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Lambda-Semantics.html#v:app"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambda.Semantics",
          "name": "conj",
          "package": "liboleg",
          "signature": "lrepr Bool -\u003e lrepr Bool -\u003e lrepr Bool",
          "source": "src/Lambda-Semantics.html#conj",
          "type": "method"
        },
        "index": {
          "hierarchy": "Lambda Semantics",
          "module": "Lambda.Semantics",
          "name": "conj",
          "normalized": "a Bool-\u003ea Bool-\u003ea Bool",
          "package": "liboleg",
          "signature": "lrepr Bool-\u003elrepr Bool-\u003elrepr Bool",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Lambda-Semantics.html#v:conj"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambda.Semantics",
          "name": "donkey'",
          "package": "liboleg",
          "signature": "lrepr (Entity -\u003e Bool)",
          "source": "src/Lambda-Semantics.html#donkey%27",
          "type": "method"
        },
        "index": {
          "hierarchy": "Lambda Semantics",
          "module": "Lambda.Semantics",
          "name": "donkey'",
          "normalized": "a(Entity-\u003eBool)",
          "package": "liboleg",
          "signature": "lrepr(Entity-\u003eBool)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Lambda-Semantics.html#v:donkey-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambda.Semantics",
          "name": "exists",
          "package": "liboleg",
          "signature": "lrepr ((Entity -\u003e Bool) -\u003e Bool)",
          "source": "src/Lambda-Semantics.html#exists",
          "type": "method"
        },
        "index": {
          "hierarchy": "Lambda Semantics",
          "module": "Lambda.Semantics",
          "name": "exists",
          "normalized": "a((Entity-\u003eBool)-\u003eBool)",
          "package": "liboleg",
          "signature": "lrepr((Entity-\u003eBool)-\u003eBool)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Lambda-Semantics.html#v:exists"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambda.Semantics",
          "name": "farmer'",
          "package": "liboleg",
          "signature": "lrepr (Entity -\u003e Bool)",
          "source": "src/Lambda-Semantics.html#farmer%27",
          "type": "method"
        },
        "index": {
          "hierarchy": "Lambda Semantics",
          "module": "Lambda.Semantics",
          "name": "farmer'",
          "normalized": "a(Entity-\u003eBool)",
          "package": "liboleg",
          "signature": "lrepr(Entity-\u003eBool)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Lambda-Semantics.html#v:farmer-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambda.Semantics",
          "name": "john'",
          "package": "liboleg",
          "signature": "lrepr Entity",
          "source": "src/Lambda-Semantics.html#john%27",
          "type": "method"
        },
        "index": {
          "hierarchy": "Lambda Semantics",
          "module": "Lambda.Semantics",
          "name": "john'",
          "package": "liboleg",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Lambda-Semantics.html#v:john-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambda.Semantics",
          "name": "known",
          "package": "liboleg",
          "signature": "Maybe (Known lrepr a)",
          "source": "src/Lambda-Semantics.html#P",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambda Semantics",
          "module": "Lambda.Semantics",
          "name": "known",
          "package": "liboleg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Lambda-Semantics.html#v:known"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambda.Semantics",
          "name": "lam",
          "package": "liboleg",
          "signature": "(lrepr a -\u003e lrepr b) -\u003e lrepr (a -\u003e b)",
          "source": "src/Lambda-Semantics.html#lam",
          "type": "method"
        },
        "index": {
          "hierarchy": "Lambda Semantics",
          "module": "Lambda.Semantics",
          "name": "lam",
          "normalized": "(a b-\u003ea c)-\u003ea(b-\u003ec)",
          "package": "liboleg",
          "signature": "(lrepr a-\u003elrepr b)-\u003elrepr(a-\u003eb)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Lambda-Semantics.html#v:lam"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambda.Semantics",
          "name": "like'",
          "package": "liboleg",
          "signature": "lrepr (Entity -\u003e Entity -\u003e Bool)",
          "source": "src/Lambda-Semantics.html#like%27",
          "type": "method"
        },
        "index": {
          "hierarchy": "Lambda Semantics",
          "module": "Lambda.Semantics",
          "name": "like'",
          "normalized": "a(Entity-\u003eEntity-\u003eBool)",
          "package": "liboleg",
          "signature": "lrepr(Entity-\u003eEntity-\u003eBool)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Lambda-Semantics.html#v:like-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambda.Semantics",
          "name": "mary'",
          "package": "liboleg",
          "signature": "lrepr Entity",
          "source": "src/Lambda-Semantics.html#mary%27",
          "type": "method"
        },
        "index": {
          "hierarchy": "Lambda Semantics",
          "module": "Lambda.Semantics",
          "name": "mary'",
          "package": "liboleg",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Lambda-Semantics.html#v:mary-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambda.Semantics",
          "name": "neg",
          "package": "liboleg",
          "signature": "lrepr Bool -\u003e lrepr Bool",
          "source": "src/Lambda-Semantics.html#neg",
          "type": "method"
        },
        "index": {
          "hierarchy": "Lambda Semantics",
          "module": "Lambda.Semantics",
          "name": "neg",
          "normalized": "a Bool-\u003ea Bool",
          "package": "liboleg",
          "signature": "lrepr Bool-\u003elrepr Bool",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Lambda-Semantics.html#v:neg"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambda.Semantics",
          "name": "own'",
          "package": "liboleg",
          "signature": "lrepr (Entity -\u003e Entity -\u003e Bool)",
          "source": "src/Lambda-Semantics.html#own%27",
          "type": "method"
        },
        "index": {
          "hierarchy": "Lambda Semantics",
          "module": "Lambda.Semantics",
          "name": "own'",
          "normalized": "a(Entity-\u003eEntity-\u003eBool)",
          "package": "liboleg",
          "signature": "lrepr(Entity-\u003eEntity-\u003eBool)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Lambda-Semantics.html#v:own-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambda.Semantics",
          "name": "true",
          "package": "liboleg",
          "signature": "lrepr Bool",
          "source": "src/Lambda-Semantics.html#true",
          "type": "method"
        },
        "index": {
          "hierarchy": "Lambda Semantics",
          "module": "Lambda.Semantics",
          "name": "true",
          "package": "liboleg",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Lambda-Semantics.html#v:true"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambda.Semantics",
          "name": "unC",
          "package": "liboleg",
          "signature": "Int -\u003e Int -\u003e String",
          "source": "src/Lambda-Semantics.html#C",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambda Semantics",
          "module": "Lambda.Semantics",
          "name": "unC",
          "normalized": "Int-\u003eInt-\u003eString",
          "package": "liboleg",
          "signature": "Int-\u003eInt-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Lambda-Semantics.html#v:unC"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambda.Semantics",
          "name": "unP",
          "package": "liboleg",
          "signature": "lrepr a",
          "source": "src/Lambda-Semantics.html#P",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambda Semantics",
          "module": "Lambda.Semantics",
          "name": "unP",
          "package": "liboleg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Lambda-Semantics.html#v:unP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambda.Semantics",
          "name": "unR",
          "package": "liboleg",
          "signature": "a",
          "source": "src/Lambda-Semantics.html#R",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambda Semantics",
          "module": "Lambda.Semantics",
          "name": "unR",
          "package": "liboleg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Lambda-Semantics.html#v:unR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eEmbedding a higher-order domain-specific language (simply-typed\n lambda-calculus with constants) with a selectable evaluation order:\n Call-by-value, call-by-name, call-by-need in the same Final Tagless framework\n\u003c/p\u003e\u003cp\u003e\u003ca\u003ehttp://okmij.org/ftp/tagless-final/tagless-typed.html#call-by-any\u003c/a\u003e\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Language.CB",
          "name": "CB",
          "package": "liboleg",
          "source": "src/Language-CB.html",
          "type": "module"
        },
        "index": {
          "description": "Embedding higher-order domain-specific language simply-typed lambda-calculus with constants with selectable evaluation order Call-by-value call-by-name call-by-need in the same Final Tagless framework http okmij.org ftp tagless-final tagless-typed.html call-by-any",
          "hierarchy": "Language CB",
          "module": "Language.CB",
          "name": "CB",
          "package": "liboleg",
          "partial": "CB",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-CB.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.CB",
          "name": ":-\u003e",
          "package": "liboleg",
          "source": "src/Language-CB.html#%3A-%3E",
          "type": "data"
        },
        "index": {
          "hierarchy": "Language CB",
          "module": "Language.CB",
          "name": ":-\u003e",
          "package": "liboleg",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-CB.html#t::-45--62-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWe could have used Haskell's type Int and the arrow -\u003e constructor.\n We would like to emphasize however that EDSL types need not be identical\n to the host language types. To give the type system to EDSL, we merely\n need \u003ccode\u003elabels\u003c/code\u003e -- which is what IntT and :-\u003e are\n\u003c/p\u003e\u003cp\u003eThe (higher-order abstract) syntax of our DSL\n\u003c/p\u003e",
          "module": "Language.CB",
          "name": "EDSL",
          "package": "liboleg",
          "source": "src/Language-CB.html#EDSL",
          "type": "class"
        },
        "index": {
          "description": "We could have used Haskell type Int and the arrow constructor We would like to emphasize however that EDSL types need not be identical to the host language types To give the type system to EDSL we merely need labels which is what IntT and are The higher-order abstract syntax of our DSL",
          "hierarchy": "Language CB",
          "module": "Language.CB",
          "name": "EDSL",
          "package": "liboleg",
          "partial": "EDSL",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-CB.html#t:EDSL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eOur EDSL is typed. EDSL types are built from the following two\n type constructors:\n\u003c/p\u003e",
          "module": "Language.CB",
          "name": "IntT",
          "package": "liboleg",
          "source": "src/Language-CB.html#IntT",
          "type": "data"
        },
        "index": {
          "description": "Our EDSL is typed EDSL types are built from the following two type constructors",
          "hierarchy": "Language CB",
          "module": "Language.CB",
          "name": "IntT",
          "package": "liboleg",
          "partial": "Int",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-CB.html#t:IntT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.CB",
          "name": "Lazy",
          "package": "liboleg",
          "source": "src/Language-CB.html#Lazy",
          "type": "data"
        },
        "index": {
          "hierarchy": "Language CB",
          "module": "Language.CB",
          "name": "Lazy",
          "package": "liboleg",
          "partial": "Lazy",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-CB.html#t:Lazy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCall-by-name\n\u003c/p\u003e",
          "module": "Language.CB",
          "name": "Name",
          "package": "liboleg",
          "source": "src/Language-CB.html#Name",
          "type": "data"
        },
        "index": {
          "description": "Call-by-name",
          "hierarchy": "Language CB",
          "module": "Language.CB",
          "name": "Name",
          "package": "liboleg",
          "partial": "Name",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-CB.html#t:Name"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInterpretation of EDSL expressions as values of the host language (Haskell)\n An EDSL expression of the type a is interpreted as a Haskell value\n of the type S l m a, where m is a Monad (the parameter of the interpretation)\n and l is the label for the evaluation order (one of Name, Value, or Lazy).\n (S l m) is not quite a monad -- only up to the Sem interpretation\n\u003c/p\u003e",
          "module": "Language.CB",
          "name": "S",
          "package": "liboleg",
          "source": "src/Language-CB.html#S",
          "type": "newtype"
        },
        "index": {
          "description": "Interpretation of EDSL expressions as values of the host language Haskell An EDSL expression of the type is interpreted as Haskell value of the type where is Monad the parameter of the interpretation and is the label for the evaluation order one of Name Value or Lazy is not quite monad only up to the Sem interpretation",
          "hierarchy": "Language CB",
          "module": "Language.CB",
          "name": "S",
          "package": "liboleg",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-CB.html#t:S"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInterpretation of EDSL types as host language types\n The type interpretation function Sem is parameterized by \u003ccode\u003em\u003c/code\u003e,\n which is assumed to be a Monad.\n\u003c/p\u003e",
          "module": "Language.CB",
          "name": "Sem",
          "package": "liboleg",
          "signature": "Sem",
          "type": "function"
        },
        "index": {
          "description": "Interpretation of EDSL types as host language types The type interpretation function Sem is parameterized by which is assumed to be Monad",
          "hierarchy": "Language CB",
          "module": "Language.CB",
          "name": "Sem",
          "package": "liboleg",
          "partial": "Sem",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-CB.html#t:Sem"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe result of subtraction was not needed, and so it was not performed\n | OTH, (int 5 \u003ccode\u003e\u003ca\u003eadd\u003c/a\u003e\u003c/code\u003e int 5) was computed four times\n\u003c/p\u003e",
          "module": "Language.CB",
          "name": "Value",
          "package": "liboleg",
          "source": "src/Language-CB.html#Value",
          "type": "data"
        },
        "index": {
          "description": "The result of subtraction was not needed and so it was not performed OTH int add int was computed four times",
          "hierarchy": "Language CB",
          "module": "Language.CB",
          "name": "Value",
          "package": "liboleg",
          "partial": "Value",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-CB.html#t:Value"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.CB",
          "name": "S",
          "package": "liboleg",
          "signature": "S",
          "source": "src/Language-CB.html#S",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language CB",
          "module": "Language.CB",
          "name": "S",
          "package": "liboleg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-CB.html#v:S"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.CB",
          "name": "add",
          "package": "liboleg",
          "signature": "exp IntT -\u003e exp IntT -\u003e exp IntT",
          "source": "src/Language-CB.html#add",
          "type": "method"
        },
        "index": {
          "hierarchy": "Language CB",
          "module": "Language.CB",
          "name": "add",
          "normalized": "a IntT-\u003ea IntT-\u003ea IntT",
          "package": "liboleg",
          "signature": "exp IntT-\u003eexp IntT-\u003eexp IntT",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-CB.html#v:add"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.CB",
          "name": "app",
          "package": "liboleg",
          "signature": "exp (a :-\u003e b) -\u003e exp a -\u003e exp b",
          "source": "src/Language-CB.html#app",
          "type": "method"
        },
        "index": {
          "hierarchy": "Language CB",
          "module": "Language.CB",
          "name": "app",
          "normalized": "a(b-\u003ec)-\u003ea b-\u003ea c",
          "package": "liboleg",
          "signature": "exp(a-\u003eb)-\u003eexp a-\u003eexp b",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-CB.html#v:app"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.CB",
          "name": "int",
          "package": "liboleg",
          "signature": "Int -\u003e exp IntT",
          "source": "src/Language-CB.html#int",
          "type": "method"
        },
        "index": {
          "hierarchy": "Language CB",
          "module": "Language.CB",
          "name": "int",
          "normalized": "Int-\u003ea IntT",
          "package": "liboleg",
          "signature": "Int-\u003eexp IntT",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-CB.html#v:int"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.CB",
          "name": "lam",
          "package": "liboleg",
          "signature": "(exp a -\u003e exp b) -\u003e exp (a :-\u003e b)",
          "source": "src/Language-CB.html#lam",
          "type": "method"
        },
        "index": {
          "hierarchy": "Language CB",
          "module": "Language.CB",
          "name": "lam",
          "normalized": "(a b-\u003ea c)-\u003ea(b-\u003ec)",
          "package": "liboleg",
          "signature": "(exp a-\u003eexp b)-\u003eexp(a-\u003eb)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-CB.html#v:lam"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA convenient abbreviation\n\u003c/p\u003e",
          "module": "Language.CB",
          "name": "let_",
          "package": "liboleg",
          "signature": "exp a -\u003e (exp a -\u003e exp b) -\u003e exp b",
          "source": "src/Language-CB.html#let_",
          "type": "function"
        },
        "index": {
          "description": "convenient abbreviation",
          "hierarchy": "Language CB",
          "module": "Language.CB",
          "name": "let_",
          "normalized": "a b-\u003e(a b-\u003ea c)-\u003ea c",
          "package": "liboleg",
          "signature": "exp a-\u003e(exp a-\u003eexp b)-\u003eexp b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-CB.html#v:let_"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWe reuse most of EDSL (S Name) except for lam\n\u003c/p\u003e",
          "module": "Language.CB",
          "name": "ln",
          "package": "liboleg",
          "signature": "S Lazy m x -\u003e S Name m x",
          "source": "src/Language-CB.html#ln",
          "type": "function"
        },
        "index": {
          "description": "We reuse most of EDSL Name except for lam",
          "hierarchy": "Language CB",
          "module": "Language.CB",
          "name": "ln",
          "normalized": "S Lazy a b-\u003eS Name a b",
          "package": "liboleg",
          "signature": "S Lazy m x-\u003eS Name m x",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-CB.html#v:ln"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.CB",
          "name": "nl",
          "package": "liboleg",
          "signature": "S Name m x -\u003e S Lazy m x",
          "source": "src/Language-CB.html#nl",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language CB",
          "module": "Language.CB",
          "name": "nl",
          "normalized": "S Name a b-\u003eS Lazy a b",
          "package": "liboleg",
          "signature": "S Name m x-\u003eS Lazy m x",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-CB.html#v:nl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.CB",
          "name": "nv",
          "package": "liboleg",
          "signature": "S Name m x -\u003e S Value m x",
          "source": "src/Language-CB.html#nv",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language CB",
          "module": "Language.CB",
          "name": "nv",
          "normalized": "S Name a b-\u003eS Value a b",
          "package": "liboleg",
          "signature": "S Name m x-\u003eS Value m x",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-CB.html#v:nv"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.CB",
          "name": "runLazy",
          "package": "liboleg",
          "signature": "S Lazy m a -\u003e m (Sem m a)",
          "source": "src/Language-CB.html#runLazy",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language CB",
          "module": "Language.CB",
          "name": "runLazy",
          "normalized": "S Lazy a b-\u003ea(Sem a b)",
          "package": "liboleg",
          "partial": "Lazy",
          "signature": "S Lazy m a-\u003em(Sem m a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-CB.html#v:runLazy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.CB",
          "name": "runName",
          "package": "liboleg",
          "signature": "S Name m a -\u003e m (Sem m a)",
          "source": "src/Language-CB.html#runName",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language CB",
          "module": "Language.CB",
          "name": "runName",
          "normalized": "S Name a b-\u003ea(Sem a b)",
          "package": "liboleg",
          "partial": "Name",
          "signature": "S Name m a-\u003em(Sem m a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-CB.html#v:runName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.CB",
          "name": "runValue",
          "package": "liboleg",
          "signature": "S Value m a -\u003e m (Sem m a)",
          "source": "src/Language-CB.html#runValue",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language CB",
          "module": "Language.CB",
          "name": "runValue",
          "normalized": "S Value a b-\u003ea(Sem a b)",
          "package": "liboleg",
          "partial": "Value",
          "signature": "S Value m a-\u003em(Sem m a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-CB.html#v:runValue"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.CB",
          "name": "share",
          "package": "liboleg",
          "signature": "m a -\u003e m (m a)",
          "source": "src/Language-CB.html#share",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language CB",
          "module": "Language.CB",
          "name": "share",
          "normalized": "a b-\u003ea(a b)",
          "package": "liboleg",
          "signature": "m a-\u003em(m a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-CB.html#v:share"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.CB",
          "name": "sub",
          "package": "liboleg",
          "signature": "exp IntT -\u003e exp IntT -\u003e exp IntT",
          "source": "src/Language-CB.html#sub",
          "type": "method"
        },
        "index": {
          "hierarchy": "Language CB",
          "module": "Language.CB",
          "name": "sub",
          "normalized": "a IntT-\u003ea IntT-\u003ea IntT",
          "package": "liboleg",
          "signature": "exp IntT-\u003eexp IntT-\u003eexp IntT",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-CB.html#v:sub"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA sample EDSL term\n\u003c/p\u003e",
          "module": "Language.CB",
          "name": "t",
          "package": "liboleg",
          "signature": "exp IntT",
          "source": "src/Language-CB.html#t",
          "type": "function"
        },
        "index": {
          "description": "sample EDSL term",
          "hierarchy": "Language CB",
          "module": "Language.CB",
          "name": "t",
          "package": "liboleg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-CB.html#v:t"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEvaluating:\n\u003c/p\u003e\u003cpre\u003e t = (lam $ \\x -\u003e let_ (x `add` x)\n                      $ \\y -\u003e y `add` y) `app` int 10\n\u003c/pre\u003e\u003cp\u003eThe addition (x \u003ccode\u003e\u003ca\u003eadd\u003c/a\u003e\u003c/code\u003e x) is performed twice because y is bound\n to a computation, and y is evaluated twice\n\u003c/p\u003e",
          "module": "Language.CB",
          "name": "t1",
          "package": "liboleg",
          "signature": "exp IntT",
          "source": "src/Language-CB.html#t1",
          "type": "function"
        },
        "index": {
          "description": "Evaluating lam let add add app int The addition add is performed twice because is bound to computation and is evaluated twice",
          "hierarchy": "Language CB",
          "module": "Language.CB",
          "name": "t1",
          "package": "liboleg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-CB.html#v:t1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA better example\n\u003c/p\u003e",
          "module": "Language.CB",
          "name": "t2",
          "package": "liboleg",
          "signature": "exp IntT",
          "source": "src/Language-CB.html#t2",
          "type": "function"
        },
        "index": {
          "description": "better example",
          "hierarchy": "Language CB",
          "module": "Language.CB",
          "name": "t2",
          "package": "liboleg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-CB.html#v:t2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.CB",
          "name": "unS",
          "package": "liboleg",
          "signature": "m (Sem m a)",
          "source": "src/Language-CB.html#S",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language CB",
          "module": "Language.CB",
          "name": "unS",
          "package": "liboleg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-CB.html#v:unS"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWe reuse most of EDSL (S Name) except for lam\n\u003c/p\u003e",
          "module": "Language.CB",
          "name": "vn",
          "package": "liboleg",
          "signature": "S Value m x -\u003e S Name m x",
          "source": "src/Language-CB.html#vn",
          "type": "function"
        },
        "index": {
          "description": "We reuse most of EDSL Name except for lam",
          "hierarchy": "Language CB",
          "module": "Language.CB",
          "name": "vn",
          "normalized": "S Value a b-\u003eS Name a b",
          "package": "liboleg",
          "signature": "S Value m x-\u003eS Name m x",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-CB.html#v:vn"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eEmbedding a higher-order domain-specific language (simply-typed\n lambda-calculus with constants) with a selectable evaluation order:\n Call-by-value, call-by-name, call-by-need in the same Final Tagless framework\n This is the Haskell98 version of the code CB.hs located in the\n same directory as this file\n\u003c/p\u003e\u003cp\u003e\u003ca\u003ehttp://okmij.org/ftp/tagless-final/tagless-typed.html#call-by-any\u003c/a\u003e\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Language.CB98",
          "name": "CB98",
          "package": "liboleg",
          "source": "src/Language-CB98.html",
          "type": "module"
        },
        "index": {
          "description": "Embedding higher-order domain-specific language simply-typed lambda-calculus with constants with selectable evaluation order Call-by-value call-by-name call-by-need in the same Final Tagless framework This is the Haskell98 version of the code CB.hs located in the same directory as this file http okmij.org ftp tagless-final tagless-typed.html call-by-any",
          "hierarchy": "Language CB98",
          "module": "Language.CB98",
          "name": "CB98",
          "package": "liboleg",
          "partial": "CB",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-CB98.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe (higher-order abstract) syntax of our DSL\n\u003c/p\u003e",
          "module": "Language.CB98",
          "name": "Arr",
          "package": "liboleg",
          "source": "src/Language-CB98.html#Arr",
          "type": "type"
        },
        "index": {
          "description": "The higher-order abstract syntax of our DSL",
          "hierarchy": "Language CB98",
          "module": "Language.CB98",
          "name": "Arr",
          "package": "liboleg",
          "partial": "Arr",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-CB98.html#t:Arr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.CB98",
          "name": "EDSL",
          "package": "liboleg",
          "source": "src/Language-CB98.html#EDSL",
          "type": "class"
        },
        "index": {
          "hierarchy": "Language CB98",
          "module": "Language.CB98",
          "name": "EDSL",
          "package": "liboleg",
          "partial": "EDSL",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-CB98.html#t:EDSL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.CB98",
          "name": "SLazy",
          "package": "liboleg",
          "source": "src/Language-CB98.html#SLazy",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "Language CB98",
          "module": "Language.CB98",
          "name": "SLazy",
          "package": "liboleg",
          "partial": "SLazy",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-CB98.html#t:SLazy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInterpretation of EDSL expressions as values of the host language (Haskell)\n An EDSL expression of type a is interpreted as a Haskell value\n of the type SName m a, SValue m a or SLazy m a, where\n m is a Monad (the parameter of the interpretation).\n\u003c/p\u003e",
          "module": "Language.CB98",
          "name": "SName",
          "package": "liboleg",
          "source": "src/Language-CB98.html#SName",
          "type": "newtype"
        },
        "index": {
          "description": "Interpretation of EDSL expressions as values of the host language Haskell An EDSL expression of type is interpreted as Haskell value of the type SName SValue or SLazy where is Monad the parameter of the interpretation",
          "hierarchy": "Language CB98",
          "module": "Language.CB98",
          "name": "SName",
          "package": "liboleg",
          "partial": "SName",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-CB98.html#t:SName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe result of subtraction was not needed, and so it was not performed\n OTH, (int 5 \u003ccode\u003e\u003ca\u003eadd\u003c/a\u003e\u003c/code\u003e int 5) was computed four times\n\u003c/p\u003e\u003cp\u003eCall-by-value\n\u003c/p\u003e",
          "module": "Language.CB98",
          "name": "SValue",
          "package": "liboleg",
          "source": "src/Language-CB98.html#SValue",
          "type": "newtype"
        },
        "index": {
          "description": "The result of subtraction was not needed and so it was not performed OTH int add int was computed four times Call-by-value",
          "hierarchy": "Language CB98",
          "module": "Language.CB98",
          "name": "SValue",
          "package": "liboleg",
          "partial": "SValue",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-CB98.html#t:SValue"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.CB98",
          "name": "SL",
          "package": "liboleg",
          "signature": "SL",
          "source": "src/Language-CB98.html#SLazy",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language CB98",
          "module": "Language.CB98",
          "name": "SL",
          "package": "liboleg",
          "partial": "SL",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-CB98.html#v:SL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.CB98",
          "name": "SN",
          "package": "liboleg",
          "signature": "SN",
          "source": "src/Language-CB98.html#SName",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language CB98",
          "module": "Language.CB98",
          "name": "SN",
          "package": "liboleg",
          "partial": "SN",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-CB98.html#v:SN"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.CB98",
          "name": "SV",
          "package": "liboleg",
          "signature": "SV",
          "source": "src/Language-CB98.html#SValue",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language CB98",
          "module": "Language.CB98",
          "name": "SV",
          "package": "liboleg",
          "partial": "SV",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-CB98.html#v:SV"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.CB98",
          "name": "add",
          "package": "liboleg",
          "signature": "exp Int -\u003e exp Int -\u003e exp Int",
          "source": "src/Language-CB98.html#add",
          "type": "method"
        },
        "index": {
          "hierarchy": "Language CB98",
          "module": "Language.CB98",
          "name": "add",
          "normalized": "a Int-\u003ea Int-\u003ea Int",
          "package": "liboleg",
          "signature": "exp Int-\u003eexp Int-\u003eexp Int",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-CB98.html#v:add"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.CB98",
          "name": "app",
          "package": "liboleg",
          "signature": "exp (Arr exp a b) -\u003e exp a -\u003e exp b",
          "source": "src/Language-CB98.html#app",
          "type": "method"
        },
        "index": {
          "hierarchy": "Language CB98",
          "module": "Language.CB98",
          "name": "app",
          "normalized": "a(Arr a b c)-\u003ea b-\u003ea c",
          "package": "liboleg",
          "signature": "exp(Arr exp a b)-\u003eexp a-\u003eexp b",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-CB98.html#v:app"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.CB98",
          "name": "int",
          "package": "liboleg",
          "signature": "Int -\u003e exp Int",
          "source": "src/Language-CB98.html#int",
          "type": "method"
        },
        "index": {
          "hierarchy": "Language CB98",
          "module": "Language.CB98",
          "name": "int",
          "normalized": "Int-\u003ea Int",
          "package": "liboleg",
          "signature": "Int-\u003eexp Int",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-CB98.html#v:int"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.CB98",
          "name": "lam",
          "package": "liboleg",
          "signature": "(exp a -\u003e exp b) -\u003e exp (Arr exp a b)",
          "source": "src/Language-CB98.html#lam",
          "type": "method"
        },
        "index": {
          "hierarchy": "Language CB98",
          "module": "Language.CB98",
          "name": "lam",
          "normalized": "(a b-\u003ea c)-\u003ea(Arr a b c)",
          "package": "liboleg",
          "signature": "(exp a-\u003eexp b)-\u003eexp(Arr exp a b)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-CB98.html#v:lam"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA convenient abbreviation\n\u003c/p\u003e",
          "module": "Language.CB98",
          "name": "let_",
          "package": "liboleg",
          "signature": "exp a -\u003e (exp a -\u003e exp b) -\u003e exp b",
          "source": "src/Language-CB98.html#let_",
          "type": "function"
        },
        "index": {
          "description": "convenient abbreviation",
          "hierarchy": "Language CB98",
          "module": "Language.CB98",
          "name": "let_",
          "normalized": "a b-\u003e(a b-\u003ea c)-\u003ea c",
          "package": "liboleg",
          "signature": "exp a-\u003e(exp a-\u003eexp b)-\u003eexp b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-CB98.html#v:let_"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.CB98",
          "name": "ln",
          "package": "liboleg",
          "signature": "SLazy m x -\u003e SName m x",
          "source": "src/Language-CB98.html#ln",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language CB98",
          "module": "Language.CB98",
          "name": "ln",
          "normalized": "SLazy a b-\u003eSName a b",
          "package": "liboleg",
          "signature": "SLazy m x-\u003eSName m x",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-CB98.html#v:ln"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.CB98",
          "name": "nl",
          "package": "liboleg",
          "signature": "SName m x -\u003e SLazy m x",
          "source": "src/Language-CB98.html#nl",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language CB98",
          "module": "Language.CB98",
          "name": "nl",
          "normalized": "SName a b-\u003eSLazy a b",
          "package": "liboleg",
          "signature": "SName m x-\u003eSLazy m x",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-CB98.html#v:nl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.CB98",
          "name": "nv",
          "package": "liboleg",
          "signature": "SName m x -\u003e SValue m x",
          "source": "src/Language-CB98.html#nv",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language CB98",
          "module": "Language.CB98",
          "name": "nv",
          "normalized": "SName a b-\u003eSValue a b",
          "package": "liboleg",
          "signature": "SName m x-\u003eSValue m x",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-CB98.html#v:nv"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.CB98",
          "name": "runLazy",
          "package": "liboleg",
          "signature": "SLazy m a -\u003e m a",
          "source": "src/Language-CB98.html#runLazy",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language CB98",
          "module": "Language.CB98",
          "name": "runLazy",
          "normalized": "SLazy a b-\u003ea b",
          "package": "liboleg",
          "partial": "Lazy",
          "signature": "SLazy m a-\u003em a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-CB98.html#v:runLazy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.CB98",
          "name": "runName",
          "package": "liboleg",
          "signature": "SName m a -\u003e m a",
          "source": "src/Language-CB98.html#runName",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language CB98",
          "module": "Language.CB98",
          "name": "runName",
          "normalized": "SName a b-\u003ea b",
          "package": "liboleg",
          "partial": "Name",
          "signature": "SName m a-\u003em a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-CB98.html#v:runName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.CB98",
          "name": "runValue",
          "package": "liboleg",
          "signature": "SValue m a -\u003e m a",
          "source": "src/Language-CB98.html#runValue",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language CB98",
          "module": "Language.CB98",
          "name": "runValue",
          "normalized": "SValue a b-\u003ea b",
          "package": "liboleg",
          "partial": "Value",
          "signature": "SValue m a-\u003em a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-CB98.html#v:runValue"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWe now evaluate the previously written tests t, t1, t2\n under the new interpretation\n\u003c/p\u003e\u003cp\u003eCall-by-need\n\u003c/p\u003e",
          "module": "Language.CB98",
          "name": "share",
          "package": "liboleg",
          "signature": "m a -\u003e m (m a)",
          "source": "src/Language-CB98.html#share",
          "type": "function"
        },
        "index": {
          "description": "We now evaluate the previously written tests t1 t2 under the new interpretation Call-by-need",
          "hierarchy": "Language CB98",
          "module": "Language.CB98",
          "name": "share",
          "normalized": "a b-\u003ea(a b)",
          "package": "liboleg",
          "signature": "m a-\u003em(m a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-CB98.html#v:share"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.CB98",
          "name": "sub",
          "package": "liboleg",
          "signature": "exp Int -\u003e exp Int -\u003e exp Int",
          "source": "src/Language-CB98.html#sub",
          "type": "method"
        },
        "index": {
          "hierarchy": "Language CB98",
          "module": "Language.CB98",
          "name": "sub",
          "normalized": "a Int-\u003ea Int-\u003ea Int",
          "package": "liboleg",
          "signature": "exp Int-\u003eexp Int-\u003eexp Int",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-CB98.html#v:sub"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA sample EDSL term\n\u003c/p\u003e",
          "module": "Language.CB98",
          "name": "t",
          "package": "liboleg",
          "signature": "exp Int",
          "source": "src/Language-CB98.html#t",
          "type": "function"
        },
        "index": {
          "description": "sample EDSL term",
          "hierarchy": "Language CB98",
          "module": "Language.CB98",
          "name": "t",
          "package": "liboleg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-CB98.html#v:t"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe addition (x \u003ccode\u003e\u003ca\u003eadd\u003c/a\u003e\u003c/code\u003e x) is performed twice because y is bound\n to a computation, and y is evaluated twice\n\u003c/p\u003e\u003cp\u003eA more elaborate example\n\u003c/p\u003e",
          "module": "Language.CB98",
          "name": "t1",
          "package": "liboleg",
          "signature": "exp Int",
          "source": "src/Language-CB98.html#t1",
          "type": "function"
        },
        "index": {
          "description": "The addition add is performed twice because is bound to computation and is evaluated twice more elaborate example",
          "hierarchy": "Language CB98",
          "module": "Language.CB98",
          "name": "t1",
          "package": "liboleg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-CB98.html#v:t1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA better example\n\u003c/p\u003e",
          "module": "Language.CB98",
          "name": "t2",
          "package": "liboleg",
          "signature": "exp Int",
          "source": "src/Language-CB98.html#t2",
          "type": "function"
        },
        "index": {
          "description": "better example",
          "hierarchy": "Language CB98",
          "module": "Language.CB98",
          "name": "t2",
          "package": "liboleg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-CB98.html#v:t2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.CB98",
          "name": "unSL",
          "package": "liboleg",
          "signature": "m a",
          "source": "src/Language-CB98.html#SLazy",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language CB98",
          "module": "Language.CB98",
          "name": "unSL",
          "package": "liboleg",
          "partial": "SL",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-CB98.html#v:unSL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.CB98",
          "name": "unSN",
          "package": "liboleg",
          "signature": "m a",
          "source": "src/Language-CB98.html#SName",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language CB98",
          "module": "Language.CB98",
          "name": "unSN",
          "package": "liboleg",
          "partial": "SN",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-CB98.html#v:unSN"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.CB98",
          "name": "unSV",
          "package": "liboleg",
          "signature": "m a",
          "source": "src/Language-CB98.html#SValue",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language CB98",
          "module": "Language.CB98",
          "name": "unSV",
          "package": "liboleg",
          "partial": "SV",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-CB98.html#v:unSV"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWe reuse most of EDSL (SName) except for lam\n\u003c/p\u003e",
          "module": "Language.CB98",
          "name": "vn",
          "package": "liboleg",
          "signature": "SValue m x -\u003e SName m x",
          "source": "src/Language-CB98.html#vn",
          "type": "function"
        },
        "index": {
          "description": "We reuse most of EDSL SName except for lam",
          "hierarchy": "Language CB98",
          "module": "Language.CB98",
          "name": "vn",
          "normalized": "SValue a b-\u003eSName a b",
          "package": "liboleg",
          "signature": "SValue m x-\u003eSName m x",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-CB98.html#v:vn"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cul\u003e\u003cli\u003e Almost Haskell98. See CB98,hs for the genuine Haskell98 version\n Here we use a few extensions to make the code prettier\n\u003c/li\u003e\u003cli\u003e Embedding a higher-order domain-specific language (simply-typed\n * lambda-calculus with constants) with a selectable evaluation order:\n * Call-by-value, call-by-name, call-by-need\n\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e",
          "module": "Language.CBAny",
          "name": "CBAny",
          "package": "liboleg",
          "source": "src/Language-CBAny.html",
          "type": "module"
        },
        "index": {
          "description": "Almost Haskell98 See CB98 hs for the genuine Haskell98 version Here we use few extensions to make the code prettier Embedding higher-order domain-specific language simply-typed lambda-calculus with constants with selectable evaluation order Call-by-value call-by-name call-by-need",
          "hierarchy": "Language CBAny",
          "module": "Language.CBAny",
          "name": "CBAny",
          "package": "liboleg",
          "partial": "CBAny",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-CBAny.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe (higher-order abstract) syntax of our DSL\n\u003c/p\u003e",
          "module": "Language.CBAny",
          "name": "Arr",
          "package": "liboleg",
          "source": "src/Language-CBAny.html#Arr",
          "type": "type"
        },
        "index": {
          "description": "The higher-order abstract syntax of our DSL",
          "hierarchy": "Language CBAny",
          "module": "Language.CBAny",
          "name": "Arr",
          "package": "liboleg",
          "partial": "Arr",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-CBAny.html#t:Arr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.CBAny",
          "name": "EDSL",
          "package": "liboleg",
          "source": "src/Language-CBAny.html#EDSL",
          "type": "class"
        },
        "index": {
          "hierarchy": "Language CBAny",
          "module": "Language.CBAny",
          "name": "EDSL",
          "package": "liboleg",
          "partial": "EDSL",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-CBAny.html#t:EDSL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.CBAny",
          "name": "Lazy",
          "package": "liboleg",
          "source": "src/Language-CBAny.html#Lazy",
          "type": "data"
        },
        "index": {
          "hierarchy": "Language CBAny",
          "module": "Language.CBAny",
          "name": "Lazy",
          "package": "liboleg",
          "partial": "Lazy",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-CBAny.html#t:Lazy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.CBAny",
          "name": "Name",
          "package": "liboleg",
          "source": "src/Language-CBAny.html#Name",
          "type": "data"
        },
        "index": {
          "hierarchy": "Language CBAny",
          "module": "Language.CBAny",
          "name": "Name",
          "package": "liboleg",
          "partial": "Name",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-CBAny.html#t:Name"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.CBAny",
          "name": "S",
          "package": "liboleg",
          "source": "src/Language-CBAny.html#S",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "Language CBAny",
          "module": "Language.CBAny",
          "name": "S",
          "package": "liboleg",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-CBAny.html#t:S"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.CBAny",
          "name": "Value",
          "package": "liboleg",
          "source": "src/Language-CBAny.html#Value",
          "type": "data"
        },
        "index": {
          "hierarchy": "Language CBAny",
          "module": "Language.CBAny",
          "name": "Value",
          "package": "liboleg",
          "partial": "Value",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-CBAny.html#t:Value"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.CBAny",
          "name": "S",
          "package": "liboleg",
          "signature": "S",
          "source": "src/Language-CBAny.html#S",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language CBAny",
          "module": "Language.CBAny",
          "name": "S",
          "package": "liboleg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-CBAny.html#v:S"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.CBAny",
          "name": "add",
          "package": "liboleg",
          "signature": "exp Int -\u003e exp Int -\u003e exp Int",
          "source": "src/Language-CBAny.html#add",
          "type": "method"
        },
        "index": {
          "hierarchy": "Language CBAny",
          "module": "Language.CBAny",
          "name": "add",
          "normalized": "a Int-\u003ea Int-\u003ea Int",
          "package": "liboleg",
          "signature": "exp Int-\u003eexp Int-\u003eexp Int",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-CBAny.html#v:add"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.CBAny",
          "name": "app",
          "package": "liboleg",
          "signature": "exp (Arr exp a b) -\u003e exp a -\u003e exp b",
          "source": "src/Language-CBAny.html#app",
          "type": "method"
        },
        "index": {
          "hierarchy": "Language CBAny",
          "module": "Language.CBAny",
          "name": "app",
          "normalized": "a(Arr a b c)-\u003ea b-\u003ea c",
          "package": "liboleg",
          "signature": "exp(Arr exp a b)-\u003eexp a-\u003eexp b",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-CBAny.html#v:app"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.CBAny",
          "name": "int",
          "package": "liboleg",
          "signature": "Int -\u003e exp Int",
          "source": "src/Language-CBAny.html#int",
          "type": "method"
        },
        "index": {
          "hierarchy": "Language CBAny",
          "module": "Language.CBAny",
          "name": "int",
          "normalized": "Int-\u003ea Int",
          "package": "liboleg",
          "signature": "Int-\u003eexp Int",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-CBAny.html#v:int"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.CBAny",
          "name": "lam",
          "package": "liboleg",
          "signature": "(exp a -\u003e exp b) -\u003e exp (Arr exp a b)",
          "source": "src/Language-CBAny.html#lam",
          "type": "method"
        },
        "index": {
          "hierarchy": "Language CBAny",
          "module": "Language.CBAny",
          "name": "lam",
          "normalized": "(a b-\u003ea c)-\u003ea(Arr a b c)",
          "package": "liboleg",
          "signature": "(exp a-\u003eexp b)-\u003eexp(Arr exp a b)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-CBAny.html#v:lam"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA convenient abbreviation (could've been called \u003ccode\u003ebind\u003c/code\u003e)\n\u003c/p\u003e",
          "module": "Language.CBAny",
          "name": "let_",
          "package": "liboleg",
          "signature": "exp a -\u003e (exp a -\u003e exp b) -\u003e exp b",
          "source": "src/Language-CBAny.html#let_",
          "type": "function"
        },
        "index": {
          "description": "convenient abbreviation could ve been called bind",
          "hierarchy": "Language CBAny",
          "module": "Language.CBAny",
          "name": "let_",
          "normalized": "a b-\u003e(a b-\u003ea c)-\u003ea c",
          "package": "liboleg",
          "signature": "exp a-\u003e(exp a-\u003eexp b)-\u003eexp b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-CBAny.html#v:let_"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.CBAny",
          "name": "ln",
          "package": "liboleg",
          "signature": "S Lazy m x -\u003e S Name m x",
          "source": "src/Language-CBAny.html#ln",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language CBAny",
          "module": "Language.CBAny",
          "name": "ln",
          "normalized": "S Lazy a b-\u003eS Name a b",
          "package": "liboleg",
          "signature": "S Lazy m x-\u003eS Name m x",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-CBAny.html#v:ln"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.CBAny",
          "name": "nl",
          "package": "liboleg",
          "signature": "S Name m x -\u003e S Lazy m x",
          "source": "src/Language-CBAny.html#nl",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language CBAny",
          "module": "Language.CBAny",
          "name": "nl",
          "normalized": "S Name a b-\u003eS Lazy a b",
          "package": "liboleg",
          "signature": "S Name m x-\u003eS Lazy m x",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-CBAny.html#v:nl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.CBAny",
          "name": "nv",
          "package": "liboleg",
          "signature": "S Name m x -\u003e S Value m x",
          "source": "src/Language-CBAny.html#nv",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language CBAny",
          "module": "Language.CBAny",
          "name": "nv",
          "normalized": "S Name a b-\u003eS Value a b",
          "package": "liboleg",
          "signature": "S Name m x-\u003eS Value m x",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-CBAny.html#v:nv"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.CBAny",
          "name": "runLazy",
          "package": "liboleg",
          "signature": "S Lazy m a -\u003e m a",
          "source": "src/Language-CBAny.html#runLazy",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language CBAny",
          "module": "Language.CBAny",
          "name": "runLazy",
          "normalized": "S Lazy a b-\u003ea b",
          "package": "liboleg",
          "partial": "Lazy",
          "signature": "S Lazy m a-\u003em a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-CBAny.html#v:runLazy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.CBAny",
          "name": "runName",
          "package": "liboleg",
          "signature": "S Name m a -\u003e m a",
          "source": "src/Language-CBAny.html#runName",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language CBAny",
          "module": "Language.CBAny",
          "name": "runName",
          "normalized": "S Name a b-\u003ea b",
          "package": "liboleg",
          "partial": "Name",
          "signature": "S Name m a-\u003em a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-CBAny.html#v:runName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.CBAny",
          "name": "runValue",
          "package": "liboleg",
          "signature": "S Value m a -\u003e m a",
          "source": "src/Language-CBAny.html#runValue",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language CBAny",
          "module": "Language.CBAny",
          "name": "runValue",
          "normalized": "S Value a b-\u003ea b",
          "package": "liboleg",
          "partial": "Value",
          "signature": "S Value m a-\u003em a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-CBAny.html#v:runValue"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.CBAny",
          "name": "share",
          "package": "liboleg",
          "signature": "m a -\u003e m (m a)",
          "source": "src/Language-CBAny.html#share",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language CBAny",
          "module": "Language.CBAny",
          "name": "share",
          "normalized": "a b-\u003ea(a b)",
          "package": "liboleg",
          "signature": "m a-\u003em(m a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-CBAny.html#v:share"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.CBAny",
          "name": "sub",
          "package": "liboleg",
          "signature": "exp Int -\u003e exp Int -\u003e exp Int",
          "source": "src/Language-CBAny.html#sub",
          "type": "method"
        },
        "index": {
          "hierarchy": "Language CBAny",
          "module": "Language.CBAny",
          "name": "sub",
          "normalized": "a Int-\u003ea Int-\u003ea Int",
          "package": "liboleg",
          "signature": "exp Int-\u003eexp Int-\u003eexp Int",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-CBAny.html#v:sub"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA sample EDSL term\n\u003c/p\u003e",
          "module": "Language.CBAny",
          "name": "t",
          "package": "liboleg",
          "signature": "exp Int",
          "source": "src/Language-CBAny.html#t",
          "type": "function"
        },
        "index": {
          "description": "sample EDSL term",
          "hierarchy": "Language CBAny",
          "module": "Language.CBAny",
          "name": "t",
          "package": "liboleg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-CBAny.html#v:t"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA more elaborate example\n\u003c/p\u003e",
          "module": "Language.CBAny",
          "name": "t1",
          "package": "liboleg",
          "signature": "exp Int",
          "source": "src/Language-CBAny.html#t1",
          "type": "function"
        },
        "index": {
          "description": "more elaborate example",
          "hierarchy": "Language CBAny",
          "module": "Language.CBAny",
          "name": "t1",
          "package": "liboleg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-CBAny.html#v:t1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.CBAny",
          "name": "t2",
          "package": "liboleg",
          "signature": "exp Int",
          "source": "src/Language-CBAny.html#t2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language CBAny",
          "module": "Language.CBAny",
          "name": "t2",
          "package": "liboleg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-CBAny.html#v:t2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.CBAny",
          "name": "unS",
          "package": "liboleg",
          "signature": "m a",
          "source": "src/Language-CBAny.html#S",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language CBAny",
          "module": "Language.CBAny",
          "name": "unS",
          "package": "liboleg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-CBAny.html#v:unS"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.CBAny",
          "name": "vn",
          "package": "liboleg",
          "signature": "S Value m x -\u003e S Name m x",
          "source": "src/Language-CBAny.html#vn",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language CBAny",
          "module": "Language.CBAny",
          "name": "vn",
          "normalized": "S Value a b-\u003eS Name a b",
          "package": "liboleg",
          "signature": "S Value m x-\u003eS Name m x",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-CBAny.html#v:vn"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cul\u003e\u003cli\u003e\n \u003ca\u003ehttp://okmij.org/ftp/tagless-final/course/course.html#CPS\u003c/a\u003e\n\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eWe demonstrate ordinary and administrative-redex--less call-by-value\n Continuation Passing Style (CPS) transformation that assuredly produces\n well-typed terms and is patently total.\n\u003c/p\u003e\u003cp\u003eOur goal here is not to evaluate, view or serialize a tagless-final term, but\n to transform it to another one. The result is a tagless-final term, which we\n can interpret in multiple ways: evaluate, view, or transform again. We first\n came across transformations of tagless-final terms when we discussed pushing\n the negation down in the simple, unityped language of addition and negation.\n The general case is more complex. It is natural to require the result of\n transforming a well-typed term be well-typed. In the tagless-final approach\n that requirement is satisfied automatically: after all, only well-typed terms\n are expressible. We require instead that a tagless-final transformation be\n total. In particular, the fact that the transformation handles all possible\n cases of the source terms must be patently, syntactically clear. The complete\n coverage must be so clear that the metalanguage compiler should be able to see\n that, without the aid of extra tools.\n\u003c/p\u003e\u003cp\u003eSince the only thing we can do with tagless-final terms is to interpret them,\n the CPS transformer is written in the form of an interpreter. It interprets\n source terms yielding transformed terms, which can be interpreted in many ways.\n In particular, the terms can be interpreted by the CPS transformer again,\n yielding 2-CPS terms. CPS transformers are composable, as expected.\n\u003c/p\u003e\u003cp\u003eA particular complication of the CPS transform is that the type of the result\n is different from the type of the source term: the CPS transform translates not\n only terms but also types.  Moreover, the CPS type transform and the arrow type\n constructor do not commute. For that reason, we have to introduce an extended\n Symantics class, ESymantics, which makes the meaning of function types\n dependent on a particular interpreter. As it turns out, we do not have to\n re-write the existing Symantics terms: we can re-interpret any old terms in the\n extended Symantics.  Conversely, any extended Symantics term can be interpreted\n using any old, legacy, Symantics interpreter. The CPS transform is an extended\n Symantics interpreter proper.\n\u003c/p\u003e\u003cp\u003eThe ordinary (Fischer or Plotkin) CPS transform introduces many administrative\n redices, which make the result too hard to read. Danvy and Filinski proposed a\n one-pass CPS transform, which relies on the metalanguage to get rid of the\n administrative redices. The one-pass CPS transform can be regarded as an\n example of the normalization-by-evaluation.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Language.CPS",
          "name": "CPS",
          "package": "liboleg",
          "source": "src/Language-CPS.html",
          "type": "module"
        },
        "index": {
          "description": "http okmij.org ftp tagless-final course course.html CPS We demonstrate ordinary and administrative-redex--less call-by-value Continuation Passing Style CPS transformation that assuredly produces well-typed terms and is patently total Our goal here is not to evaluate view or serialize tagless-final term but to transform it to another one The result is tagless-final term which we can interpret in multiple ways evaluate view or transform again We first came across transformations of tagless-final terms when we discussed pushing the negation down in the simple unityped language of addition and negation The general case is more complex It is natural to require the result of transforming well-typed term be well-typed In the tagless-final approach that requirement is satisfied automatically after all only well-typed terms are expressible We require instead that tagless-final transformation be total In particular the fact that the transformation handles all possible cases of the source terms must be patently syntactically clear The complete coverage must be so clear that the metalanguage compiler should be able to see that without the aid of extra tools Since the only thing we can do with tagless-final terms is to interpret them the CPS transformer is written in the form of an interpreter It interprets source terms yielding transformed terms which can be interpreted in many ways In particular the terms can be interpreted by the CPS transformer again yielding CPS terms CPS transformers are composable as expected particular complication of the CPS transform is that the type of the result is different from the type of the source term the CPS transform translates not only terms but also types Moreover the CPS type transform and the arrow type constructor do not commute For that reason we have to introduce an extended Symantics class ESymantics which makes the meaning of function types dependent on particular interpreter As it turns out we do not have to re-write the existing Symantics terms we can re-interpret any old terms in the extended Symantics Conversely any extended Symantics term can be interpreted using any old legacy Symantics interpreter The CPS transform is an extended Symantics interpreter proper The ordinary Fischer or Plotkin CPS transform introduces many administrative redices which make the result too hard to read Danvy and Filinski proposed one-pass CPS transform which relies on the metalanguage to get rid of the administrative redices The one-pass CPS transform can be regarded as an example of the normalization-by-evaluation",
          "hierarchy": "Language CPS",
          "module": "Language.CPS",
          "name": "CPS",
          "package": "liboleg",
          "partial": "CPS",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-CPS.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.CPS",
          "name": "Arr",
          "package": "liboleg",
          "signature": "Arr",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language CPS",
          "module": "Language.CPS",
          "name": "Arr",
          "package": "liboleg",
          "partial": "Arr",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-CPS.html#t:Arr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.CPS",
          "name": "CPS",
          "package": "liboleg",
          "source": "src/Language-CPS.html#CPS",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "Language CPS",
          "module": "Language.CPS",
          "name": "CPS",
          "package": "liboleg",
          "partial": "CPS",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-CPS.html#t:CPS"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.CPS",
          "name": "CPS1",
          "package": "liboleg",
          "source": "src/Language-CPS.html#CPS1",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "Language CPS",
          "module": "Language.CPS",
          "name": "CPS1",
          "package": "liboleg",
          "partial": "CPS",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-CPS.html#t:CPS1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.CPS",
          "name": "ESymantics",
          "package": "liboleg",
          "source": "src/Language-CPS.html#ESymantics",
          "type": "class"
        },
        "index": {
          "hierarchy": "Language CPS",
          "module": "Language.CPS",
          "name": "ESymantics",
          "package": "liboleg",
          "partial": "ESymantics",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-CPS.html#t:ESymantics"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.CPS",
          "name": "ExtSym",
          "package": "liboleg",
          "source": "src/Language-CPS.html#ExtSym",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "Language CPS",
          "module": "Language.CPS",
          "name": "ExtSym",
          "package": "liboleg",
          "partial": "Ext Sym",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-CPS.html#t:ExtSym"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.CPS",
          "name": "GenArr",
          "package": "liboleg",
          "signature": "GenArr",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language CPS",
          "module": "Language.CPS",
          "name": "GenArr",
          "package": "liboleg",
          "partial": "Gen Arr",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-CPS.html#t:GenArr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.CPS",
          "name": "Lg",
          "package": "liboleg",
          "source": "src/Language-CPS.html#Lg",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "Language CPS",
          "module": "Language.CPS",
          "name": "Lg",
          "package": "liboleg",
          "partial": "Lg",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-CPS.html#t:Lg"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.CPS",
          "name": "CPS",
          "package": "liboleg",
          "signature": "CPS",
          "source": "src/Language-CPS.html#CPS",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language CPS",
          "module": "Language.CPS",
          "name": "CPS",
          "package": "liboleg",
          "partial": "CPS",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-CPS.html#v:CPS"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.CPS",
          "name": "CPS1",
          "package": "liboleg",
          "signature": "CPS1",
          "source": "src/Language-CPS.html#CPS1",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language CPS",
          "module": "Language.CPS",
          "name": "CPS1",
          "package": "liboleg",
          "partial": "CPS",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-CPS.html#v:CPS1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.CPS",
          "name": "ExtSym",
          "package": "liboleg",
          "signature": "ExtSym",
          "source": "src/Language-CPS.html#ExtSym",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language CPS",
          "module": "Language.CPS",
          "name": "ExtSym",
          "package": "liboleg",
          "partial": "Ext Sym",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-CPS.html#v:ExtSym"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.CPS",
          "name": "Lg",
          "package": "liboleg",
          "signature": "Lg",
          "source": "src/Language-CPS.html#Lg",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language CPS",
          "module": "Language.CPS",
          "name": "Lg",
          "package": "liboleg",
          "partial": "Lg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-CPS.html#v:Lg"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.CPS",
          "name": "add",
          "package": "liboleg",
          "signature": "repr Int -\u003e repr Int -\u003e repr Int",
          "source": "src/Language-CPS.html#add",
          "type": "method"
        },
        "index": {
          "hierarchy": "Language CPS",
          "module": "Language.CPS",
          "name": "add",
          "normalized": "a Int-\u003ea Int-\u003ea Int",
          "package": "liboleg",
          "signature": "repr Int-\u003erepr Int-\u003erepr Int",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-CPS.html#v:add"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.CPS",
          "name": "app",
          "package": "liboleg",
          "signature": "repr (Arr repr a b) -\u003e repr a -\u003e repr b",
          "source": "src/Language-CPS.html#app",
          "type": "method"
        },
        "index": {
          "hierarchy": "Language CPS",
          "module": "Language.CPS",
          "name": "app",
          "normalized": "a(Arr a b c)-\u003ea b-\u003ea c",
          "package": "liboleg",
          "signature": "repr(Arr repr a b)-\u003erepr a-\u003erepr b",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-CPS.html#v:app"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.CPS",
          "name": "appk",
          "package": "liboleg",
          "signature": "CPS repr w a -\u003e (repr a -\u003e repr w) -\u003e repr w",
          "source": "src/Language-CPS.html#appk",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language CPS",
          "module": "Language.CPS",
          "name": "appk",
          "normalized": "CPS a b c-\u003e(a c-\u003ea b)-\u003ea b",
          "package": "liboleg",
          "signature": "CPS repr w a-\u003e(repr a-\u003erepr w)-\u003erepr w",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-CPS.html#v:appk"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.CPS",
          "name": "cps1r",
          "package": "liboleg",
          "signature": "(repr a -\u003e repr w) -\u003e repr w",
          "source": "src/Language-CPS.html#CPS1",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language CPS",
          "module": "Language.CPS",
          "name": "cps1r",
          "normalized": "(a b-\u003ea c)-\u003ea c",
          "package": "liboleg",
          "signature": "(repr a-\u003erepr w)-\u003erepr w",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-CPS.html#v:cps1r"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.CPS",
          "name": "cps1v",
          "package": "liboleg",
          "signature": "repr a -\u003e CPS1 repr w a",
          "source": "src/Language-CPS.html#cps1v",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language CPS",
          "module": "Language.CPS",
          "name": "cps1v",
          "normalized": "a b-\u003eCPS a c b",
          "package": "liboleg",
          "signature": "repr a-\u003eCPS repr w a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-CPS.html#v:cps1v"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.CPS",
          "name": "cpsk",
          "package": "liboleg",
          "signature": "(repr (Arr repr a w) -\u003e repr w) -\u003e CPS repr w a",
          "source": "src/Language-CPS.html#cpsk",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language CPS",
          "module": "Language.CPS",
          "name": "cpsk",
          "normalized": "(a(Arr a b c)-\u003ea c)-\u003eCPS a c b",
          "package": "liboleg",
          "signature": "(repr(Arr repr a w)-\u003erepr w)-\u003eCPS repr w a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-CPS.html#v:cpsk"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.CPS",
          "name": "cpsr",
          "package": "liboleg",
          "signature": "repr (Arr repr (Arr repr a w) w)",
          "source": "src/Language-CPS.html#CPS",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language CPS",
          "module": "Language.CPS",
          "name": "cpsr",
          "package": "liboleg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-CPS.html#v:cpsr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.CPS",
          "name": "cpsv",
          "package": "liboleg",
          "signature": "repr a -\u003e CPS repr w a",
          "source": "src/Language-CPS.html#cpsv",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language CPS",
          "module": "Language.CPS",
          "name": "cpsv",
          "normalized": "a b-\u003eCPS a c b",
          "package": "liboleg",
          "signature": "repr a-\u003eCPS repr w a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-CPS.html#v:cpsv"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.CPS",
          "name": "int",
          "package": "liboleg",
          "signature": "Int -\u003e repr Int",
          "source": "src/Language-CPS.html#int",
          "type": "method"
        },
        "index": {
          "hierarchy": "Language CPS",
          "module": "Language.CPS",
          "name": "int",
          "normalized": "Int-\u003ea Int",
          "package": "liboleg",
          "signature": "Int-\u003erepr Int",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-CPS.html#v:int"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.CPS",
          "name": "lam",
          "package": "liboleg",
          "signature": "(repr a -\u003e repr b) -\u003e repr (Arr repr a b)",
          "source": "src/Language-CPS.html#lam",
          "type": "method"
        },
        "index": {
          "hierarchy": "Language CPS",
          "module": "Language.CPS",
          "name": "lam",
          "normalized": "(a b-\u003ea c)-\u003ea(Arr a b c)",
          "package": "liboleg",
          "signature": "(repr a-\u003erepr b)-\u003erepr(Arr repr a b)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-CPS.html#v:lam"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.CPS",
          "name": "legacy",
          "package": "liboleg",
          "signature": "(repr a -\u003e b) -\u003e Lg repr a -\u003e b",
          "source": "src/Language-CPS.html#legacy",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language CPS",
          "module": "Language.CPS",
          "name": "legacy",
          "normalized": "(a b-\u003ec)-\u003eLg a b-\u003ec",
          "package": "liboleg",
          "signature": "(repr a-\u003eb)-\u003eLg repr a-\u003eb",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-CPS.html#v:legacy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.CPS",
          "name": "reflect",
          "package": "liboleg",
          "signature": "((repr a -\u003e repr w) -\u003e repr w) -\u003e repr (Arr repr (Arr repr a w) w)",
          "source": "src/Language-CPS.html#reflect",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language CPS",
          "module": "Language.CPS",
          "name": "reflect",
          "normalized": "((a b-\u003ea c)-\u003ea c)-\u003ea(Arr a(Arr a b c)c)",
          "package": "liboleg",
          "signature": "((repr a-\u003erepr w)-\u003erepr w)-\u003erepr(Arr repr(Arr repr a w)w)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-CPS.html#v:reflect"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.CPS",
          "name": "unExtSym",
          "package": "liboleg",
          "signature": "repr (GenArr repr a)",
          "source": "src/Language-CPS.html#ExtSym",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language CPS",
          "module": "Language.CPS",
          "name": "unExtSym",
          "package": "liboleg",
          "partial": "Ext Sym",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-CPS.html#v:unExtSym"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.CPS",
          "name": "unLg",
          "package": "liboleg",
          "signature": "repr a",
          "source": "src/Language-CPS.html#Lg",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language CPS",
          "module": "Language.CPS",
          "name": "unLg",
          "package": "liboleg",
          "partial": "Lg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-CPS.html#v:unLg"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eA model of the evaluation of logic programs (i.e., resolving Horn clauses)\n\u003c/p\u003e\u003cp\u003eThe point is not to re-implement Prolog with all the conveniences\n but to formalize evaluation strategies such as SLD, SLD-interleaving, \n and others.\n The formalization is aimed at reasoning about termination and\n solution sequences. See App A and B of the full FLOPS 2008 paper \n (the file arithm.pdf in this directory).\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Language.DefinitionTree",
          "name": "DefinitionTree",
          "package": "liboleg",
          "source": "src/Language-DefinitionTree.html",
          "type": "module"
        },
        "index": {
          "description": "model of the evaluation of logic programs i.e resolving Horn clauses The point is not to re-implement Prolog with all the conveniences but to formalize evaluation strategies such as SLD SLD-interleaving and others The formalization is aimed at reasoning about termination and solution sequences See App and of the full FLOPS paper the file arithm.pdf in this directory",
          "hierarchy": "Language DefinitionTree",
          "module": "Language.DefinitionTree",
          "name": "DefinitionTree",
          "package": "liboleg",
          "partial": "Definition Tree",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-DefinitionTree.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.DefinitionTree",
          "name": "Body",
          "package": "liboleg",
          "source": "src/Language-DefinitionTree.html#Body",
          "type": "data"
        },
        "index": {
          "hierarchy": "Language DefinitionTree",
          "module": "Language.DefinitionTree",
          "name": "Body",
          "package": "liboleg",
          "partial": "Body",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-DefinitionTree.html#t:Body"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA clause is a guarded body; the latter is an AND-sequence of formulas\n\u003c/p\u003e",
          "module": "Language.DefinitionTree",
          "name": "Clause",
          "package": "liboleg",
          "source": "src/Language-DefinitionTree.html#Clause",
          "type": "data"
        },
        "index": {
          "description": "clause is guarded body the latter is an AND-sequence of formulas",
          "hierarchy": "Language DefinitionTree",
          "module": "Language.DefinitionTree",
          "name": "Clause",
          "package": "liboleg",
          "partial": "Clause",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-DefinitionTree.html#t:Clause"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFormulas \n\u003c/p\u003e\u003cp\u003eA formula describes a finite or _infinite_ AND-OR tree\n that encodes the logic-program clauses that may be needed to\n evaluate a particular goal.\n We represent a goal g(t1,...,tn) by a combination of the goal\n g(X1,...,Xn), whose arguments are distinct fresh logic\n variables, and a substitution {Xi=ti}. For a goal\n g(X1,...,Xn), a |Formula| encodes all the clauses of the\n logic program that could possibly prove g, in their order. Each\n clause \n\u003c/p\u003e\u003cpre\u003e g(t1,...,tn) :- b1(t11,...,t1m), ...\n\u003c/pre\u003e\u003cp\u003eis represented by the (guarding) substitution {Xi=ti, Ykj=tkj}\n and the sequence of the goals bk(Yk1,...,Ykm) in the body. \n Each of these goals is again encoded as a |Formula|. \n All variables in the clauses are renamed to ensure the standardization apart.\n\u003c/p\u003e\u003cp\u003eOur trees are similar to Antoy's definitional trees, used to encode\n rewriting rules and represent control strategies in\n term-rewriting systems and _functional logic_ programming.\n However, in definitional trees, function calls can be nested, \n and patterns are linear.\n\u003c/p\u003e\u003cp\u003eThe translation from Prolog is straightforward; the first step\n is to re-write clauses so that the arguments of each goal are \n logic variables:\n A fact \n\u003c/p\u003e\u003cpre\u003e    g(term).\n\u003c/pre\u003e\u003cp\u003eis converted to\n\u003c/p\u003e\u003cpre\u003e    g(X) :- X = term.\n\u003c/pre\u003e\u003cp\u003eA clause\n\u003c/p\u003e\u003cpre\u003e    g(term) :- g1(term1), g2(term2).\n\u003c/pre\u003e\u003cp\u003eis converted to\n\u003c/p\u003e\u003cpre\u003e    g(X) :- X = term, _V1 = term1, g1(_V1), _V2=term2, g2(_V2).\n\u003c/pre\u003e\u003cp\u003eSee the real examples at the end\n\u003c/p\u003e\u003cp\u003eA formula (parameterized by the domain of terms) is an OR-sequence\n of clauses\n\u003c/p\u003e",
          "module": "Language.DefinitionTree",
          "name": "Formula",
          "package": "liboleg",
          "source": "src/Language-DefinitionTree.html#Formula",
          "type": "data"
        },
        "index": {
          "description": "Formulas formula describes finite or infinite AND-OR tree that encodes the logic-program clauses that may be needed to evaluate particular goal We represent goal t1 tn by combination of the goal X1 Xn whose arguments are distinct fresh logic variables and substitution Xi ti For goal X1 Xn Formula encodes all the clauses of the logic program that could possibly prove in their order Each clause t1 tn b1 t11 t1m is represented by the guarding substitution Xi ti Ykj tkj and the sequence of the goals bk Yk1 Ykm in the body Each of these goals is again encoded as Formula All variables in the clauses are renamed to ensure the standardization apart Our trees are similar to Antoy definitional trees used to encode rewriting rules and represent control strategies in term-rewriting systems and functional logic programming However in definitional trees function calls can be nested and patterns are linear The translation from Prolog is straightforward the first step is to re-write clauses so that the arguments of each goal are logic variables fact term is converted to term clause term g1 term1 g2 term2 is converted to term V1 term1 g1 V1 V2 term2 g2 V2 See the real examples at the end formula parameterized by the domain of terms is an OR-sequence of clauses",
          "hierarchy": "Language DefinitionTree",
          "module": "Language.DefinitionTree",
          "name": "Formula",
          "package": "liboleg",
          "partial": "Formula",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-DefinitionTree.html#t:Formula"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.DefinitionTree",
          "name": "LogicVar",
          "package": "liboleg",
          "source": "src/Language-DefinitionTree.html#LogicVar",
          "type": "type"
        },
        "index": {
          "hierarchy": "Language DefinitionTree",
          "module": "Language.DefinitionTree",
          "name": "LogicVar",
          "package": "liboleg",
          "partial": "Logic Var",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-DefinitionTree.html#t:LogicVar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA finite map from vars to terms (parameterized over the domain of terms)\n\u003c/p\u003e",
          "module": "Language.DefinitionTree",
          "name": "Subst",
          "package": "liboleg",
          "source": "src/Language-DefinitionTree.html#Subst",
          "type": "type"
        },
        "index": {
          "description": "finite map from vars to terms parameterized over the domain of terms",
          "hierarchy": "Language DefinitionTree",
          "module": "Language.DefinitionTree",
          "name": "Subst",
          "package": "liboleg",
          "partial": "Subst",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-DefinitionTree.html#t:Subst"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUnary numerals\n\u003c/p\u003e",
          "module": "Language.DefinitionTree",
          "name": "UN",
          "package": "liboleg",
          "source": "src/Language-DefinitionTree.html#UN",
          "type": "data"
        },
        "index": {
          "description": "Unary numerals",
          "hierarchy": "Language DefinitionTree",
          "module": "Language.DefinitionTree",
          "name": "UN",
          "package": "liboleg",
          "partial": "UN",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-DefinitionTree.html#t:UN"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEvaluation, substitutions and unification are parametric over terms\n (term algebra), provided the following two operations are defined.\n We should be able to examine a term and determine if it is a variable\n or a constructor (represented by an integer) applied to a sequence of\n zero or more terms. Conversely, given a constructor (represented by an\n integer) and a list of terms-children we should be able to build a term.\n The two operations must satisfy the laws:\n\u003c/p\u003e\u003cpre\u003e either id build . classify === id\n classify . build === Right\n\u003c/pre\u003e",
          "module": "Language.DefinitionTree",
          "name": "Unifiable",
          "package": "liboleg",
          "source": "src/Language-DefinitionTree.html#Unifiable",
          "type": "class"
        },
        "index": {
          "description": "Evaluation substitutions and unification are parametric over terms term algebra provided the following two operations are defined We should be able to examine term and determine if it is variable or constructor represented by an integer applied to sequence of zero or more terms Conversely given constructor represented by an integer and list of terms-children we should be able to build term The two operations must satisfy the laws either id build classify id classify build Right",
          "hierarchy": "Language DefinitionTree",
          "module": "Language.DefinitionTree",
          "name": "Unifiable",
          "package": "liboleg",
          "partial": "Unifiable",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-DefinitionTree.html#t:Unifiable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA logic var is represented by a pair of an integer\n and a list of `predicate marks' (which are themselves\n integers). Such an odd representation is needed to\n ensure the standardization apart: different instances\n of a clause must have distinctly renamed variables.\n Unlike Claessen, we get by without the state monad\n to generate unique variable names (labels). See the\n discussion and examples in the \u003ccode\u003etests\u003c/code\u003e section below.\n Our main advantage is that we separate the naming of\n variables from the evaluation strategy. Evaluation\n no longer cares about generating fresh names, which\n notably simplifies the analysis of the strategies.\n Logic vars are typed, albeit phantomly.\n\u003c/p\u003e",
          "module": "Language.DefinitionTree",
          "name": "VStack",
          "package": "liboleg",
          "source": "src/Language-DefinitionTree.html#VStack",
          "type": "type"
        },
        "index": {
          "description": "logic var is represented by pair of an integer and list of predicate marks which are themselves integers Such an odd representation is needed to ensure the standardization apart different instances of clause must have distinctly renamed variables Unlike Claessen we get by without the state monad to generate unique variable names labels See the discussion and examples in the tests section below Our main advantage is that we separate the naming of variables from the evaluation strategy Evaluation no longer cares about generating fresh names which notably simplifies the analysis of the strategies Logic vars are typed albeit phantomly",
          "hierarchy": "Language DefinitionTree",
          "module": "Language.DefinitionTree",
          "name": "VStack",
          "package": "liboleg",
          "partial": "VStack",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-DefinitionTree.html#t:VStack"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.DefinitionTree",
          "name": ":*:",
          "package": "liboleg",
          "signature": "(Formula term) :*: (Body term)",
          "source": "src/Language-DefinitionTree.html#Body",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language DefinitionTree",
          "module": "Language.DefinitionTree",
          "name": ":*:",
          "package": "liboleg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-DefinitionTree.html#v::-42-:"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.DefinitionTree",
          "name": ":+:",
          "package": "liboleg",
          "signature": "(Clause term) :+: (Formula term)",
          "source": "src/Language-DefinitionTree.html#Formula",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language DefinitionTree",
          "module": "Language.DefinitionTree",
          "name": ":+:",
          "package": "liboleg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-DefinitionTree.html#v::-43-:"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.DefinitionTree",
          "name": "Fact",
          "package": "liboleg",
          "signature": "Fact",
          "source": "src/Language-DefinitionTree.html#Body",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language DefinitionTree",
          "module": "Language.DefinitionTree",
          "name": "Fact",
          "package": "liboleg",
          "partial": "Fact",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-DefinitionTree.html#v:Fact"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.DefinitionTree",
          "name": "Fail",
          "package": "liboleg",
          "signature": "Fail",
          "source": "src/Language-DefinitionTree.html#Formula",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language DefinitionTree",
          "module": "Language.DefinitionTree",
          "name": "Fail",
          "package": "liboleg",
          "partial": "Fail",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-DefinitionTree.html#v:Fail"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.DefinitionTree",
          "name": "G",
          "package": "liboleg",
          "signature": "G (Subst term) (Body term)",
          "source": "src/Language-DefinitionTree.html#Clause",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language DefinitionTree",
          "module": "Language.DefinitionTree",
          "name": "G",
          "package": "liboleg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-DefinitionTree.html#v:G"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.DefinitionTree",
          "name": "UNv",
          "package": "liboleg",
          "signature": "UNv (LogicVar UN)",
          "source": "src/Language-DefinitionTree.html#UN",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language DefinitionTree",
          "module": "Language.DefinitionTree",
          "name": "UNv",
          "package": "liboleg",
          "partial": "UNv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-DefinitionTree.html#v:UNv"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.DefinitionTree",
          "name": "US",
          "package": "liboleg",
          "signature": "US UN",
          "source": "src/Language-DefinitionTree.html#UN",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language DefinitionTree",
          "module": "Language.DefinitionTree",
          "name": "US",
          "package": "liboleg",
          "partial": "US",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-DefinitionTree.html#v:US"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.DefinitionTree",
          "name": "UZ",
          "package": "liboleg",
          "signature": "UZ",
          "source": "src/Language-DefinitionTree.html#UN",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language DefinitionTree",
          "module": "Language.DefinitionTree",
          "name": "UZ",
          "package": "liboleg",
          "partial": "UZ",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-DefinitionTree.html#v:UZ"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.DefinitionTree",
          "name": "add",
          "package": "liboleg",
          "signature": "VStack -\u003e Formula UN",
          "source": "src/Language-DefinitionTree.html#add",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language DefinitionTree",
          "module": "Language.DefinitionTree",
          "name": "add",
          "normalized": "VStack-\u003eFormula UN",
          "package": "liboleg",
          "signature": "VStack-\u003eFormula UN",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-DefinitionTree.html#v:add"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.DefinitionTree",
          "name": "build",
          "package": "liboleg",
          "signature": "(Int, [term]) -\u003e term",
          "source": "src/Language-DefinitionTree.html#build",
          "type": "method"
        },
        "index": {
          "hierarchy": "Language DefinitionTree",
          "module": "Language.DefinitionTree",
          "name": "build",
          "normalized": "(Int,[a])-\u003ea",
          "package": "liboleg",
          "signature": "(Int,[term])-\u003eterm",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-DefinitionTree.html#v:build"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ebuilding substitutions\n\u003c/p\u003e",
          "module": "Language.DefinitionTree",
          "name": "bv",
          "package": "liboleg",
          "signature": "LogicVar term -\u003e term -\u003e Subst term",
          "source": "src/Language-DefinitionTree.html#bv",
          "type": "function"
        },
        "index": {
          "description": "building substitutions",
          "hierarchy": "Language DefinitionTree",
          "module": "Language.DefinitionTree",
          "name": "bv",
          "normalized": "LogicVar a-\u003ea-\u003eSubst a",
          "package": "liboleg",
          "signature": "LogicVar term-\u003eterm-\u003eSubst term",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-DefinitionTree.html#v:bv"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.DefinitionTree",
          "name": "classify",
          "package": "liboleg",
          "signature": "term -\u003e Either (LogicVar term) (Int, [term])",
          "source": "src/Language-DefinitionTree.html#classify",
          "type": "method"
        },
        "index": {
          "hierarchy": "Language DefinitionTree",
          "module": "Language.DefinitionTree",
          "name": "classify",
          "normalized": "a-\u003eEither(LogicVar a)(Int,[a])",
          "package": "liboleg",
          "signature": "term-\u003eEither(LogicVar term)(Int,[term])",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-DefinitionTree.html#v:classify"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA different evaluator: Evaluate a tree to a stream (lazy list)\n given the initial substitution s.\n Here we use the SLD strategy.\n\u003c/p\u003e",
          "module": "Language.DefinitionTree",
          "name": "eval",
          "package": "liboleg",
          "signature": "Formula term -\u003e Subst term -\u003e [Subst term]",
          "source": "src/Language-DefinitionTree.html#eval",
          "type": "function"
        },
        "index": {
          "description": "different evaluator Evaluate tree to stream lazy list given the initial substitution Here we use the SLD strategy",
          "hierarchy": "Language DefinitionTree",
          "module": "Language.DefinitionTree",
          "name": "eval",
          "normalized": "Formula a-\u003eSubst a-\u003e[Subst a]",
          "package": "liboleg",
          "signature": "Formula term-\u003eSubst term-\u003e[Subst term]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-DefinitionTree.html#v:eval"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSame as above, using the SLD-interleaving strategy.\n See Definition 3.1 of the LogicT paper (ICFP05)\n\u003c/p\u003e",
          "module": "Language.DefinitionTree",
          "name": "evali",
          "package": "liboleg",
          "signature": "Formula term -\u003e Subst term -\u003e [Subst term]",
          "source": "src/Language-DefinitionTree.html#evali",
          "type": "function"
        },
        "index": {
          "description": "Same as above using the SLD-interleaving strategy See Definition of the LogicT paper ICFP05",
          "hierarchy": "Language DefinitionTree",
          "module": "Language.DefinitionTree",
          "name": "evali",
          "normalized": "Formula a-\u003eSubst a-\u003e[Subst a]",
          "package": "liboleg",
          "signature": "Formula term-\u003eSubst term-\u003e[Subst term]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-DefinitionTree.html#v:evali"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEncoding of variable names to ensure standardization apart.\n A clause such as genu(X) or add(X,Y,Z) may appear in the tree\n (infinitely) many times. We must ensure that each instance uses distinct\n logic variables. To this end, we name variables by a pair (Int, VStack)\n whose first component is the local label of a variable within a clause.\n VStack is a path from the root of the tree to the current occurrence\n of the clause in the tree. Each predicate along the path is represented\n by an integer label (0 for genu, 1 for add, 2 for mul, etc). \n To \u003ccode\u003epass\u003c/code\u003e arguments to a clause, we add to the current substitution\n the bindings for the variables of that clause. See the genu' example\n below: whereas (0,h) is the label of the variable X in the current\n instance of genu, (0,genu_mark:h) is X in the callee.\n\u003c/p\u003e\u003cp\u003eA logic program\n\u003c/p\u003e\u003cpre\u003e genu([]).\n genu([u|X]) :- genu(X).\n\u003c/pre\u003e\u003cp\u003eand the goal genu(X) are encoded as follows. The argument of genu' is\n the path of the current instance of genu' from the top of the AND-OR\n tree.\n\u003c/p\u003e",
          "module": "Language.DefinitionTree",
          "name": "genu",
          "package": "liboleg",
          "signature": "Formula UN",
          "source": "src/Language-DefinitionTree.html#genu",
          "type": "function"
        },
        "index": {
          "description": "Encoding of variable names to ensure standardization apart clause such as genu or add may appear in the tree infinitely many times We must ensure that each instance uses distinct logic variables To this end we name variables by pair Int VStack whose first component is the local label of variable within clause VStack is path from the root of the tree to the current occurrence of the clause in the tree Each predicate along the path is represented by an integer label for genu for add for mul etc To pass arguments to clause we add to the current substitution the bindings for the variables of that clause See the genu example below whereas is the label of the variable in the current instance of genu genu mark is in the callee logic program genu genu genu and the goal genu are encoded as follows The argument of genu is the path of the current instance of genu from the top of the AND-OR tree",
          "hierarchy": "Language DefinitionTree",
          "module": "Language.DefinitionTree",
          "name": "genu",
          "package": "liboleg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-DefinitionTree.html#v:genu"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.DefinitionTree",
          "name": "ins",
          "package": "liboleg",
          "signature": "Subst term -\u003e (LogicVar term, term) -\u003e Subst term",
          "source": "src/Language-DefinitionTree.html#ins",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language DefinitionTree",
          "module": "Language.DefinitionTree",
          "name": "ins",
          "normalized": "Subst a-\u003e(LogicVar a,a)-\u003eSubst a",
          "package": "liboleg",
          "signature": "Subst term-\u003e(LogicVar term,term)-\u003eSubst term",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-DefinitionTree.html#v:ins"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.DefinitionTree",
          "name": "mul",
          "package": "liboleg",
          "signature": "VStack -\u003e Formula UN",
          "source": "src/Language-DefinitionTree.html#mul",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language DefinitionTree",
          "module": "Language.DefinitionTree",
          "name": "mul",
          "normalized": "VStack-\u003eFormula UN",
          "package": "liboleg",
          "signature": "VStack-\u003eFormula UN",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-DefinitionTree.html#v:mul"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe evaluation process starts with a formula and the initial\n substitution, which together represent a goal.  The\n guarding substitution of the clause conjoins with the current\n substitution to yield the substitution for the evaluation of the body. \n The conjunction of substitutions may lead to a contradiction, \n in which case the clause is skipped (\u003ccode\u003epruned\u003c/code\u003e).\n\u003c/p\u003e\u003cp\u003eEvaluation as pruning: we traverse a tree and prune away failed branches\n\u003c/p\u003e",
          "module": "Language.DefinitionTree",
          "name": "prune",
          "package": "liboleg",
          "signature": "Formula term -\u003e Subst term -\u003e Formula term",
          "source": "src/Language-DefinitionTree.html#prune",
          "type": "function"
        },
        "index": {
          "description": "The evaluation process starts with formula and the initial substitution which together represent goal The guarding substitution of the clause conjoins with the current substitution to yield the substitution for the evaluation of the body The conjunction of substitutions may lead to contradiction in which case the clause is skipped pruned Evaluation as pruning we traverse tree and prune away failed branches",
          "hierarchy": "Language DefinitionTree",
          "module": "Language.DefinitionTree",
          "name": "prune",
          "normalized": "Formula a-\u003eSubst a-\u003eFormula a",
          "package": "liboleg",
          "signature": "Formula term-\u003eSubst term-\u003eFormula term",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-DefinitionTree.html#v:prune"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.DefinitionTree",
          "name": "prunec",
          "package": "liboleg",
          "signature": "Clause term -\u003e Subst term -\u003e Maybe (Clause term)",
          "source": "src/Language-DefinitionTree.html#prunec",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language DefinitionTree",
          "module": "Language.DefinitionTree",
          "name": "prunec",
          "normalized": "Clause a-\u003eSubst a-\u003eMaybe(Clause a)",
          "package": "liboleg",
          "signature": "Clause term-\u003eSubst term-\u003eMaybe(Clause term)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-DefinitionTree.html#v:prunec"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eApply a substitution to a term\n\u003c/p\u003e",
          "module": "Language.DefinitionTree",
          "name": "sapp",
          "package": "liboleg",
          "signature": "Subst term -\u003e term -\u003e term",
          "source": "src/Language-DefinitionTree.html#sapp",
          "type": "function"
        },
        "index": {
          "description": "Apply substitution to term",
          "hierarchy": "Language DefinitionTree",
          "module": "Language.DefinitionTree",
          "name": "sapp",
          "normalized": "Subst a-\u003ea-\u003ea",
          "package": "liboleg",
          "signature": "Subst term-\u003eterm-\u003eterm",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-DefinitionTree.html#v:sapp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSolve the equations using the naive realization of the \n Martelli and Montanari process\n\u003c/p\u003e",
          "module": "Language.DefinitionTree",
          "name": "solve",
          "package": "liboleg",
          "signature": "Subst term -\u003e [(Either (LogicVar term) term, term)] -\u003e Maybe (Subst term)",
          "source": "src/Language-DefinitionTree.html#solve",
          "type": "function"
        },
        "index": {
          "description": "Solve the equations using the naive realization of the Martelli and Montanari process",
          "hierarchy": "Language DefinitionTree",
          "module": "Language.DefinitionTree",
          "name": "solve",
          "normalized": "Subst a-\u003e[(Either(LogicVar a)a,a)]-\u003eMaybe(Subst a)",
          "package": "liboleg",
          "signature": "Subst term-\u003e[(Either(LogicVar term)term,term)]-\u003eMaybe(Subst term)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-DefinitionTree.html#v:solve"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConjoin two substitutions (see Defn 1 of the FLOPS 2008 paper).\n We merge two substitutions and solve the resulting set of equations, \n returning Nothing if the two original substitutions are contradictory.\n\u003c/p\u003e",
          "module": "Language.DefinitionTree",
          "name": "unify",
          "package": "liboleg",
          "signature": "Subst term -\u003e Subst term -\u003e Maybe (Subst term)",
          "source": "src/Language-DefinitionTree.html#unify",
          "type": "function"
        },
        "index": {
          "description": "Conjoin two substitutions see Defn of the FLOPS paper We merge two substitutions and solve the resulting set of equations returning Nothing if the two original substitutions are contradictory",
          "hierarchy": "Language DefinitionTree",
          "module": "Language.DefinitionTree",
          "name": "unify",
          "normalized": "Subst a-\u003eSubst a-\u003eMaybe(Subst a)",
          "package": "liboleg",
          "signature": "Subst term-\u003eSubst term-\u003eMaybe(Subst term)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-DefinitionTree.html#v:unify"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Fibration",
          "name": "Fibration",
          "package": "liboleg",
          "source": "src/Language-Fibration.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Language Fibration",
          "module": "Language.Fibration",
          "name": "Fibration",
          "package": "liboleg",
          "partial": "Fibration",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-Fibration.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Fibration",
          "name": "FN",
          "package": "liboleg",
          "source": "src/Language-Fibration.html#FN",
          "type": "class"
        },
        "index": {
          "hierarchy": "Language Fibration",
          "module": "Language.Fibration",
          "name": "FN",
          "package": "liboleg",
          "partial": "FN",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-Fibration.html#t:FN"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Fibration",
          "name": "L",
          "package": "liboleg",
          "source": "src/Language-Fibration.html#L",
          "type": "data"
        },
        "index": {
          "hierarchy": "Language Fibration",
          "module": "Language.Fibration",
          "name": "L",
          "package": "liboleg",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-Fibration.html#t:L"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Fibration",
          "name": "NFN",
          "package": "liboleg",
          "source": "src/Language-Fibration.html#NFN",
          "type": "class"
        },
        "index": {
          "hierarchy": "Language Fibration",
          "module": "Language.Fibration",
          "name": "NFN",
          "package": "liboleg",
          "partial": "NFN",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-Fibration.html#t:NFN"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Fibration",
          "name": "NFN1",
          "package": "liboleg",
          "source": "src/Language-Fibration.html#NFN1",
          "type": "class"
        },
        "index": {
          "hierarchy": "Language Fibration",
          "module": "Language.Fibration",
          "name": "NFN1",
          "package": "liboleg",
          "partial": "NFN",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-Fibration.html#t:NFN1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Fibration",
          "name": "NFN2",
          "package": "liboleg",
          "source": "src/Language-Fibration.html#NFN2",
          "type": "class"
        },
        "index": {
          "hierarchy": "Language Fibration",
          "module": "Language.Fibration",
          "name": "NFN2",
          "package": "liboleg",
          "partial": "NFN",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-Fibration.html#t:NFN2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Fibration",
          "name": "NFN3",
          "package": "liboleg",
          "source": "src/Language-Fibration.html#NFN3",
          "type": "class"
        },
        "index": {
          "hierarchy": "Language Fibration",
          "module": "Language.Fibration",
          "name": "NFN3",
          "package": "liboleg",
          "partial": "NFN",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-Fibration.html#t:NFN3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Fibration",
          "name": "L",
          "package": "liboleg",
          "signature": "L",
          "source": "src/Language-Fibration.html#L",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Fibration",
          "module": "Language.Fibration",
          "name": "L",
          "package": "liboleg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-Fibration.html#v:L"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Fibration",
          "name": "app",
          "package": "liboleg",
          "signature": "s -\u003e a -\u003e b",
          "source": "src/Language-Fibration.html#app",
          "type": "method"
        },
        "index": {
          "hierarchy": "Language Fibration",
          "module": "Language.Fibration",
          "name": "app",
          "normalized": "a-\u003eb-\u003ec",
          "package": "liboleg",
          "signature": "s-\u003ea-\u003eb",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-Fibration.html#v:app"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Fibration",
          "name": "napp",
          "package": "liboleg",
          "signature": "a -\u003e b",
          "source": "src/Language-Fibration.html#napp",
          "type": "method"
        },
        "index": {
          "hierarchy": "Language Fibration",
          "module": "Language.Fibration",
          "name": "napp",
          "normalized": "a-\u003eb",
          "package": "liboleg",
          "signature": "a-\u003eb",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-Fibration.html#v:napp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Fibration",
          "name": "napp1",
          "package": "liboleg",
          "signature": "t -\u003e a -\u003e b",
          "source": "src/Language-Fibration.html#napp1",
          "type": "method"
        },
        "index": {
          "hierarchy": "Language Fibration",
          "module": "Language.Fibration",
          "name": "napp1",
          "normalized": "a-\u003eb-\u003ec",
          "package": "liboleg",
          "signature": "t-\u003ea-\u003eb",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-Fibration.html#v:napp1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Fibration",
          "name": "napp2",
          "package": "liboleg",
          "signature": "(tl, t, tr) -\u003e a -\u003e b",
          "source": "src/Language-Fibration.html#napp2",
          "type": "method"
        },
        "index": {
          "hierarchy": "Language Fibration",
          "module": "Language.Fibration",
          "name": "napp2",
          "normalized": "(a,b,c)-\u003ed-\u003ee",
          "package": "liboleg",
          "signature": "(tl,t,tr)-\u003ea-\u003eb",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-Fibration.html#v:napp2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Fibration",
          "name": "napp3",
          "package": "liboleg",
          "signature": "((tll, tl, tlr), t, (trl, tr, trr)) -\u003e a -\u003e b",
          "source": "src/Language-Fibration.html#napp3",
          "type": "method"
        },
        "index": {
          "hierarchy": "Language Fibration",
          "module": "Language.Fibration",
          "name": "napp3",
          "normalized": "((a,b,c),d,(e,f,g))-\u003eh-\u003ei",
          "package": "liboleg",
          "signature": "((tll,tl,tlr),t,(trl,tr,trr))-\u003ea-\u003eb",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-Fibration.html#v:napp3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Fibration",
          "name": "test_nfn1",
          "package": "liboleg",
          "signature": "Integer",
          "source": "src/Language-Fibration.html#test_nfn1",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Fibration",
          "module": "Language.Fibration",
          "name": "test_nfn1",
          "package": "liboleg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-Fibration.html#v:test_nfn1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Fibration",
          "name": "test_nfn3",
          "package": "liboleg",
          "signature": "Integer",
          "source": "src/Language-Fibration.html#test_nfn3",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Fibration",
          "module": "Language.Fibration",
          "name": "test_nfn3",
          "package": "liboleg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-Fibration.html#v:test_nfn3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eTyped tagless-final interpreters for \n Linear Lambda Calculus\n de Bruijn indices\n\u003c/p\u003e\u003cp\u003eLinear lambda-calculus: each bound variable\n is referenced exactly once.\n\u003c/p\u003e\u003cp\u003eApplication: natural language semantics:\n (see for example, works by Michael Moortgat)\n In particular, linear lambda calculi are extensively\n used in Abstract Categorial Grammars.\n\u003c/p\u003e\u003cp\u003eThe following code would look better in ML: we can declare\n types F and U in a signature. They will be assumed distinct.\n Yet an implementation of the signature may conflate\n the F and U types; therefore, we can use the interpreter\n for the ordinary lambda calculus.\n Alas, this approach doesn't work for Haskell:\n If we use associated types to model type-class\n local types F and U, the type checker does not\n consider them necessarily distinct and generates equality\n constraint. That breaks the abstraction!\n Terms like tl2 below would not be rejected.\n\u003c/p\u003e\u003cp\u003e\u003ca\u003ehttp://okmij.org/ftp/tagless-final/course/course.html#linear\u003c/a\u003e\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Language.LinearLC",
          "name": "LinearLC",
          "package": "liboleg",
          "source": "src/Language-LinearLC.html",
          "type": "module"
        },
        "index": {
          "description": "Typed tagless-final interpreters for Linear Lambda Calculus de Bruijn indices Linear lambda-calculus each bound variable is referenced exactly once Application natural language semantics see for example works by Michael Moortgat In particular linear lambda calculi are extensively used in Abstract Categorial Grammars The following code would look better in ML we can declare types and in signature They will be assumed distinct Yet an implementation of the signature may conflate the and types therefore we can use the interpreter for the ordinary lambda calculus Alas this approach doesn work for Haskell If we use associated types to model type-class local types and the type checker does not consider them necessarily distinct and generates equality constraint That breaks the abstraction Terms like tl2 below would not be rejected http okmij.org ftp tagless-final course course.html linear",
          "hierarchy": "Language LinearLC",
          "module": "Language.LinearLC",
          "name": "LinearLC",
          "package": "liboleg",
          "partial": "Linear LC",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-LinearLC.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.LinearLC",
          "name": "F",
          "package": "liboleg",
          "source": "src/Language-LinearLC.html#F",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "Language LinearLC",
          "module": "Language.LinearLC",
          "name": "F",
          "package": "liboleg",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-LinearLC.html#t:F"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExtension: the ordinary lam\n\u003c/p\u003e",
          "module": "Language.LinearLC",
          "name": "G",
          "package": "liboleg",
          "source": "src/Language-LinearLC.html#G",
          "type": "newtype"
        },
        "index": {
          "description": "Extension the ordinary lam",
          "hierarchy": "Language LinearLC",
          "module": "Language.LinearLC",
          "name": "G",
          "package": "liboleg",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-LinearLC.html#t:G"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.LinearLC",
          "name": "GZ",
          "package": "liboleg",
          "source": "src/Language-LinearLC.html#GZ",
          "type": "class"
        },
        "index": {
          "hierarchy": "Language LinearLC",
          "module": "Language.LinearLC",
          "name": "GZ",
          "package": "liboleg",
          "partial": "GZ",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-LinearLC.html#t:GZ"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.LinearLC",
          "name": "GenL",
          "package": "liboleg",
          "source": "src/Language-LinearLC.html#GenL",
          "type": "class"
        },
        "index": {
          "hierarchy": "Language LinearLC",
          "module": "Language.LinearLC",
          "name": "GenL",
          "package": "liboleg",
          "partial": "Gen",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-LinearLC.html#t:GenL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInterpreting lam is quite more different\n Why?\n Why the simple approach does not work?\n We need to produce ho when the lambda-form is produced,\n not when it is applied. But ho of the lambda-form\n includes the ho for the body of lambda. The latter is\n the result of evaluating the body; but we get to evaluate\n the body of the lambda only when the lambda-form is applied.\n But we need that ho now. Fortunately, types are enough to\n produce ho. That's the purpose for the type class HiHo.\n\u003c/p\u003e",
          "module": "Language.LinearLC",
          "name": "HiHo",
          "package": "liboleg",
          "source": "src/Language-LinearLC.html#HiHo",
          "type": "class"
        },
        "index": {
          "description": "Interpreting lam is quite more different Why Why the simple approach does not work We need to produce ho when the lambda-form is produced not when it is applied But ho of the lambda-form includes the ho for the body of lambda The latter is the result of evaluating the body but we get to evaluate the body of the lambda only when the lambda-form is applied But we need that ho now Fortunately types are enough to produce ho That the purpose for the type class HiHo",
          "hierarchy": "Language LinearLC",
          "module": "Language.LinearLC",
          "name": "HiHo",
          "package": "liboleg",
          "partial": "Hi Ho",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-LinearLC.html#t:HiHo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis semantics assumes that all values (that is, substitutable\n things) are closed terms. This is the case in CBV or CBN\n calculi, which never evaluate under lambda.\n Therefore, we do not qualify the types of values by the env\n Otherwise, we have to qualify each type such as Int or\n a with its env.\n For the unextended linear lambda calculus below, we don't\n need to make this restriction as substitution of linear terms\n into linear terms doesn't violate the linearity. But that\n property is not stated syntactically below.\n Stating it syntactically does seem possible, but the\n code becomes quite more complex.\n\u003c/p\u003e",
          "module": "Language.LinearLC",
          "name": "LSymantics",
          "package": "liboleg",
          "source": "src/Language-LinearLC.html#LSymantics",
          "type": "class"
        },
        "index": {
          "description": "This semantics assumes that all values that is substitutable things are closed terms This is the case in CBV or CBN calculi which never evaluate under lambda Therefore we do not qualify the types of values by the env Otherwise we have to qualify each type such as Int or with its env For the unextended linear lambda calculus below we don need to make this restriction as substitution of linear terms into linear terms doesn violate the linearity But that property is not stated syntactically below Stating it syntactically does seem possible but the code becomes quite more complex",
          "hierarchy": "Language LinearLC",
          "module": "Language.LinearLC",
          "name": "LSymantics",
          "package": "liboleg",
          "partial": "LSymantics",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-LinearLC.html#t:LSymantics"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe reason we separate out \u003ccode\u003e\u003ca\u003elam\u003c/a\u003e\u003c/code\u003e is to expose the type variables\n hi and ho in the class head. A particular instance might be able to attach\n constraints to hi and ho. The instance for the R interpreter\n indeed attaches the HiHo constraint.\n\u003c/p\u003e",
          "module": "Language.LinearLC",
          "name": "LinearL",
          "package": "liboleg",
          "source": "src/Language-LinearLC.html#LinearL",
          "type": "class"
        },
        "index": {
          "description": "The reason we separate out lam is to expose the type variables hi and ho in the class head particular instance might be able to attach constraints to hi and ho The instance for the interpreter indeed attaches the HiHo constraint",
          "hierarchy": "Language LinearLC",
          "module": "Language.LinearLC",
          "name": "LinearL",
          "package": "liboleg",
          "partial": "Linear",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-LinearLC.html#t:LinearL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTyped and tagless evaluator\n  object term ==\u003e metalanguage value\n\u003c/p\u003e",
          "module": "Language.LinearLC",
          "name": "R",
          "package": "liboleg",
          "source": "src/Language-LinearLC.html#R",
          "type": "newtype"
        },
        "index": {
          "description": "Typed and tagless evaluator object term metalanguage value",
          "hierarchy": "Language LinearLC",
          "module": "Language.LinearLC",
          "name": "R",
          "package": "liboleg",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-LinearLC.html#t:R"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAnother interpreter\n Literally the same as Symantics.S\n Although I later decided to print linear lambdas as !x -\u003e ...\n\u003c/p\u003e",
          "module": "Language.LinearLC",
          "name": "S",
          "package": "liboleg",
          "source": "src/Language-LinearLC.html#S",
          "type": "newtype"
        },
        "index": {
          "description": "Another interpreter Literally the same as Symantics.S Although later decided to print linear lambdas as",
          "hierarchy": "Language LinearLC",
          "module": "Language.LinearLC",
          "name": "S",
          "package": "liboleg",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-LinearLC.html#t:S"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.LinearLC",
          "name": "U",
          "package": "liboleg",
          "source": "src/Language-LinearLC.html#U",
          "type": "data"
        },
        "index": {
          "hierarchy": "Language LinearLC",
          "module": "Language.LinearLC",
          "name": "U",
          "package": "liboleg",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-LinearLC.html#t:U"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.LinearLC",
          "name": "F",
          "package": "liboleg",
          "signature": "F a",
          "source": "src/Language-LinearLC.html#F",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language LinearLC",
          "module": "Language.LinearLC",
          "name": "F",
          "package": "liboleg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-LinearLC.html#v:F"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.LinearLC",
          "name": "G",
          "package": "liboleg",
          "signature": "G a",
          "source": "src/Language-LinearLC.html#G",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language LinearLC",
          "module": "Language.LinearLC",
          "name": "G",
          "package": "liboleg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-LinearLC.html#v:G"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.LinearLC",
          "name": "R",
          "package": "liboleg",
          "signature": "R",
          "source": "src/Language-LinearLC.html#R",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language LinearLC",
          "module": "Language.LinearLC",
          "name": "R",
          "package": "liboleg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-LinearLC.html#v:R"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.LinearLC",
          "name": "S",
          "package": "liboleg",
          "signature": "S",
          "source": "src/Language-LinearLC.html#S",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language LinearLC",
          "module": "Language.LinearLC",
          "name": "S",
          "package": "liboleg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-LinearLC.html#v:S"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.LinearLC",
          "name": "Used",
          "package": "liboleg",
          "signature": "Used",
          "source": "src/Language-LinearLC.html#U",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language LinearLC",
          "module": "Language.LinearLC",
          "name": "Used",
          "package": "liboleg",
          "partial": "Used",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-LinearLC.html#v:Used"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.LinearLC",
          "name": "add",
          "package": "liboleg",
          "signature": "repr hi h Int -\u003e repr h ho Int -\u003e repr hi ho Int",
          "source": "src/Language-LinearLC.html#add",
          "type": "method"
        },
        "index": {
          "hierarchy": "Language LinearLC",
          "module": "Language.LinearLC",
          "name": "add",
          "normalized": "a b c Int-\u003ea c d Int-\u003ea b d Int",
          "package": "liboleg",
          "signature": "repr hi h Int-\u003erepr h ho Int-\u003erepr hi ho Int",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-LinearLC.html#v:add"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.LinearLC",
          "name": "app",
          "package": "liboleg",
          "signature": "repr hi h (a -\u003e b) -\u003e repr h ho a -\u003e repr hi ho b",
          "source": "src/Language-LinearLC.html#app",
          "type": "method"
        },
        "index": {
          "hierarchy": "Language LinearLC",
          "module": "Language.LinearLC",
          "name": "app",
          "normalized": "a b c(d-\u003ee)-\u003ea c f d-\u003ea b f e",
          "package": "liboleg",
          "signature": "repr hi h(a-\u003eb)-\u003erepr h ho a-\u003erepr hi ho b",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-LinearLC.html#v:app"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.LinearLC",
          "name": "glam",
          "package": "liboleg",
          "signature": "repr (G a, hi) (G a, ho) b -\u003e repr hi ho (a -\u003e b)",
          "source": "src/Language-LinearLC.html#glam",
          "type": "method"
        },
        "index": {
          "hierarchy": "Language LinearLC",
          "module": "Language.LinearLC",
          "name": "glam",
          "normalized": "a(G b,c)(G b,d)e-\u003ea c d(b-\u003ee)",
          "package": "liboleg",
          "signature": "repr(G a,hi)(G a,ho)b-\u003erepr hi ho(a-\u003eb)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-LinearLC.html#v:glam"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.LinearLC",
          "name": "gz",
          "package": "liboleg",
          "signature": "repr (G a, hi) (G a, hi) a",
          "source": "src/Language-LinearLC.html#gz",
          "type": "method"
        },
        "index": {
          "hierarchy": "Language LinearLC",
          "module": "Language.LinearLC",
          "name": "gz",
          "normalized": "a(G b,c)(G b,c)b",
          "package": "liboleg",
          "signature": "repr(G a,hi)(G a,hi)a",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-LinearLC.html#v:gz"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.LinearLC",
          "name": "hiho",
          "package": "liboleg",
          "signature": "hi -\u003e ho",
          "source": "src/Language-LinearLC.html#hiho",
          "type": "method"
        },
        "index": {
          "hierarchy": "Language LinearLC",
          "module": "Language.LinearLC",
          "name": "hiho",
          "normalized": "a-\u003eb",
          "package": "liboleg",
          "signature": "hi-\u003eho",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-LinearLC.html#v:hiho"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.LinearLC",
          "name": "int",
          "package": "liboleg",
          "signature": "Int -\u003e repr hi hi Int",
          "source": "src/Language-LinearLC.html#int",
          "type": "method"
        },
        "index": {
          "hierarchy": "Language LinearLC",
          "module": "Language.LinearLC",
          "name": "int",
          "normalized": "Int-\u003ea b b Int",
          "package": "liboleg",
          "signature": "Int-\u003erepr hi hi Int",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-LinearLC.html#v:int"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.LinearLC",
          "name": "lam",
          "package": "liboleg",
          "signature": "repr (F a, hi) (U, ho) b -\u003e repr hi ho (a -\u003e b)",
          "source": "src/Language-LinearLC.html#lam",
          "type": "method"
        },
        "index": {
          "hierarchy": "Language LinearLC",
          "module": "Language.LinearLC",
          "name": "lam",
          "normalized": "a(F b,c)(U,d)e-\u003ea c d(b-\u003ee)",
          "package": "liboleg",
          "signature": "repr(F a,hi)(U,ho)b-\u003erepr hi ho(a-\u003eb)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-LinearLC.html#v:lam"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.LinearLC",
          "name": "s",
          "package": "liboleg",
          "signature": "repr hi ho a -\u003e repr (any, hi) (any, ho) a",
          "source": "src/Language-LinearLC.html#s",
          "type": "method"
        },
        "index": {
          "hierarchy": "Language LinearLC",
          "module": "Language.LinearLC",
          "name": "s",
          "normalized": "a b c d-\u003ea(e,b)(e,c)d",
          "package": "liboleg",
          "signature": "repr hi ho a-\u003erepr(any,hi)(any,ho)a",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-LinearLC.html#v:s"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.LinearLC",
          "name": "unR",
          "package": "liboleg",
          "signature": "hi -\u003e (a, ho)",
          "source": "src/Language-LinearLC.html#R",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language LinearLC",
          "module": "Language.LinearLC",
          "name": "unR",
          "normalized": "a-\u003e(b,c)",
          "package": "liboleg",
          "signature": "hi-\u003e(a,ho)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-LinearLC.html#v:unR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.LinearLC",
          "name": "unS",
          "package": "liboleg",
          "signature": "[String] -\u003e String",
          "source": "src/Language-LinearLC.html#S",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language LinearLC",
          "module": "Language.LinearLC",
          "name": "unS",
          "normalized": "[String]-\u003eString",
          "package": "liboleg",
          "signature": "[String]-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-LinearLC.html#v:unS"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.LinearLC",
          "name": "view",
          "package": "liboleg",
          "signature": "S () () a -\u003e String",
          "source": "src/Language-LinearLC.html#view",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language LinearLC",
          "module": "Language.LinearLC",
          "name": "view",
          "normalized": "S()()a-\u003eString",
          "package": "liboleg",
          "signature": "S()()a-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-LinearLC.html#v:view"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.LinearLC",
          "name": "z",
          "package": "liboleg",
          "signature": "repr (F a, h) (U, h) a",
          "source": "src/Language-LinearLC.html#z",
          "type": "method"
        },
        "index": {
          "hierarchy": "Language LinearLC",
          "module": "Language.LinearLC",
          "name": "z",
          "normalized": "a(F b,c)(U,c)b",
          "package": "liboleg",
          "signature": "repr(F a,h)(U,h)a",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-LinearLC.html#v:z"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis is the Haskell version of symantics1.ml, for comparison\n ACG with a more expressive semantic lexicon that includes\n multi-prompt delimited continuations and the notion of evaluation.\n Types are considered as a mere approximation rather than\n the complete specification of grammatical composition.\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e \u003ca\u003ehttp://okmij.org/ftp/gengo/index.html#CAG\u003c/a\u003e\n\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e",
          "module": "Language.Symantics1",
          "name": "Symantics1",
          "package": "liboleg",
          "source": "src/Language-Symantics1.html",
          "type": "module"
        },
        "index": {
          "description": "This is the Haskell version of symantics1.ml for comparison ACG with more expressive semantic lexicon that includes multi-prompt delimited continuations and the notion of evaluation Types are considered as mere approximation rather than the complete specification of grammatical composition http okmij.org ftp gengo index.html CAG",
          "hierarchy": "Language Symantics1",
          "module": "Language.Symantics1",
          "name": "Symantics1",
          "package": "liboleg",
          "partial": "Symantics",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-Symantics1.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Symantics1",
          "name": "Abstract",
          "package": "liboleg",
          "source": "src/Language-Symantics1.html#Abstract",
          "type": "class"
        },
        "index": {
          "hierarchy": "Language Symantics1",
          "module": "Language.Symantics1",
          "name": "Abstract",
          "package": "liboleg",
          "partial": "Abstract",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-Symantics1.html#t:Abstract"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSemantic forms\n\u003c/p\u003e",
          "module": "Language.Symantics1",
          "name": "E",
          "package": "liboleg",
          "source": "src/Language-Symantics1.html#E",
          "type": "data"
        },
        "index": {
          "description": "Semantic forms",
          "hierarchy": "Language Symantics1",
          "module": "Language.Symantics1",
          "name": "E",
          "package": "liboleg",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-Symantics1.html#t:E"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn interpretation of the base type btyp in the signature\n labeled by lab\n\u003c/p\u003e",
          "module": "Language.Symantics1",
          "name": "I",
          "package": "liboleg",
          "signature": "I",
          "type": "function"
        },
        "index": {
          "description": "An interpretation of the base type btyp in the signature labeled by lab",
          "hierarchy": "Language Symantics1",
          "module": "Language.Symantics1",
          "name": "I",
          "package": "liboleg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-Symantics1.html#t:I"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExample from Sec 4.3 of the ESSLLI Advanced ACG course.\n\u003c/p\u003e\u003cp\u003eAn interpretation of the abstract signature as the surface form: strings\n\u003c/p\u003e",
          "module": "Language.Symantics1",
          "name": "LString",
          "package": "liboleg",
          "source": "src/Language-Symantics1.html#LString",
          "type": "newtype"
        },
        "index": {
          "description": "Example from Sec of the ESSLLI Advanced ACG course An interpretation of the abstract signature as the surface form strings",
          "hierarchy": "Language Symantics1",
          "module": "Language.Symantics1",
          "name": "LString",
          "package": "liboleg",
          "partial": "LString",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-Symantics1.html#t:LString"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAbstract signature, which defines base types, constants and their types\n\u003c/p\u003e",
          "module": "Language.Symantics1",
          "name": "N",
          "package": "liboleg",
          "source": "src/Language-Symantics1.html#N",
          "type": "data"
        },
        "index": {
          "description": "Abstract signature which defines base types constants and their types",
          "hierarchy": "Language Symantics1",
          "module": "Language.Symantics1",
          "name": "N",
          "package": "liboleg",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-Symantics1.html#t:N"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Symantics1",
          "name": "NP",
          "package": "liboleg",
          "source": "src/Language-Symantics1.html#NP",
          "type": "data"
        },
        "index": {
          "hierarchy": "Language Symantics1",
          "module": "Language.Symantics1",
          "name": "NP",
          "package": "liboleg",
          "partial": "NP",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-Symantics1.html#t:NP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe order of quantification\n\u003c/p\u003e",
          "module": "Language.Symantics1",
          "name": "QuantOrder",
          "package": "liboleg",
          "source": "src/Language-Symantics1.html#QuantOrder",
          "type": "data"
        },
        "index": {
          "description": "The order of quantification",
          "hierarchy": "Language Symantics1",
          "module": "Language.Symantics1",
          "name": "QuantOrder",
          "package": "liboleg",
          "partial": "Quant Order",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-Symantics1.html#t:QuantOrder"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Symantics1",
          "name": "S",
          "package": "liboleg",
          "source": "src/Language-Symantics1.html#S",
          "type": "data"
        },
        "index": {
          "hierarchy": "Language Symantics1",
          "module": "Language.Symantics1",
          "name": "S",
          "package": "liboleg",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-Symantics1.html#t:S"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Symantics1",
          "name": "SM",
          "package": "liboleg",
          "source": "src/Language-Symantics1.html#SM",
          "type": "data"
        },
        "index": {
          "hierarchy": "Language Symantics1",
          "module": "Language.Symantics1",
          "name": "SM",
          "package": "liboleg",
          "partial": "SM",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-Symantics1.html#t:SM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Symantics1",
          "name": "SemEnv",
          "package": "liboleg",
          "source": "src/Language-Symantics1.html#SemEnv",
          "type": "data"
        },
        "index": {
          "hierarchy": "Language Symantics1",
          "module": "Language.Symantics1",
          "name": "SemEnv",
          "package": "liboleg",
          "partial": "Sem Env",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-Symantics1.html#t:SemEnv"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe Semantic monad\n\u003c/p\u003e",
          "module": "Language.Symantics1",
          "name": "SemM",
          "package": "liboleg",
          "source": "src/Language-Symantics1.html#SemM",
          "type": "newtype"
        },
        "index": {
          "description": "The Semantic monad",
          "hierarchy": "Language Symantics1",
          "module": "Language.Symantics1",
          "name": "SemM",
          "package": "liboleg",
          "partial": "Sem",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-Symantics1.html#t:SemM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Symantics1",
          "name": "T",
          "package": "liboleg",
          "source": "src/Language-Symantics1.html#T",
          "type": "data"
        },
        "index": {
          "hierarchy": "Language Symantics1",
          "module": "Language.Symantics1",
          "name": "T",
          "package": "liboleg",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-Symantics1.html#t:T"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Symantics1",
          "name": "Varname",
          "package": "liboleg",
          "source": "src/Language-Symantics1.html#Varname",
          "type": "type"
        },
        "index": {
          "hierarchy": "Language Symantics1",
          "module": "Language.Symantics1",
          "name": "Varname",
          "package": "liboleg",
          "partial": "Varname",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-Symantics1.html#t:Varname"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Symantics1",
          "name": "And",
          "package": "liboleg",
          "signature": "And T T",
          "source": "src/Language-Symantics1.html#T",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Symantics1",
          "module": "Language.Symantics1",
          "name": "And",
          "package": "liboleg",
          "partial": "And",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-Symantics1.html#v:And"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Symantics1",
          "name": "Exi_over_Uni",
          "package": "liboleg",
          "signature": "Exi_over_Uni",
          "source": "src/Language-Symantics1.html#QuantOrder",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Symantics1",
          "module": "Language.Symantics1",
          "name": "Exi_over_Uni",
          "package": "liboleg",
          "partial": "Exi Uni",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-Symantics1.html#v:Exi_over_Uni"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Symantics1",
          "name": "Exists",
          "package": "liboleg",
          "signature": "Exists Varname T",
          "source": "src/Language-Symantics1.html#T",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Symantics1",
          "module": "Language.Symantics1",
          "name": "Exists",
          "package": "liboleg",
          "partial": "Exists",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-Symantics1.html#v:Exists"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Symantics1",
          "name": "Forall",
          "package": "liboleg",
          "signature": "Forall Varname T",
          "source": "src/Language-Symantics1.html#T",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Symantics1",
          "module": "Language.Symantics1",
          "name": "Forall",
          "package": "liboleg",
          "partial": "Forall",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-Symantics1.html#v:Forall"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Symantics1",
          "name": "Imply",
          "package": "liboleg",
          "signature": "Imply T T",
          "source": "src/Language-Symantics1.html#T",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Symantics1",
          "module": "Language.Symantics1",
          "name": "Imply",
          "package": "liboleg",
          "partial": "Imply",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-Symantics1.html#v:Imply"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Symantics1",
          "name": "Ind",
          "package": "liboleg",
          "signature": "Ind String",
          "source": "src/Language-Symantics1.html#E",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Symantics1",
          "module": "Language.Symantics1",
          "name": "Ind",
          "package": "liboleg",
          "partial": "Ind",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-Symantics1.html#v:Ind"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Symantics1",
          "name": "LString",
          "package": "liboleg",
          "signature": "LString a",
          "source": "src/Language-Symantics1.html#LString",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Symantics1",
          "module": "Language.Symantics1",
          "name": "LString",
          "package": "liboleg",
          "partial": "LString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-Symantics1.html#v:LString"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Symantics1",
          "name": "Love",
          "package": "liboleg",
          "signature": "Love E E",
          "source": "src/Language-Symantics1.html#T",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Symantics1",
          "module": "Language.Symantics1",
          "name": "Love",
          "package": "liboleg",
          "partial": "Love",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-Symantics1.html#v:Love"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Symantics1",
          "name": "Man",
          "package": "liboleg",
          "signature": "Man E",
          "source": "src/Language-Symantics1.html#T",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Symantics1",
          "module": "Language.Symantics1",
          "name": "Man",
          "package": "liboleg",
          "partial": "Man",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-Symantics1.html#v:Man"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Symantics1",
          "name": "See",
          "package": "liboleg",
          "signature": "See E E",
          "source": "src/Language-Symantics1.html#T",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Symantics1",
          "module": "Language.Symantics1",
          "name": "See",
          "package": "liboleg",
          "partial": "See",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-Symantics1.html#v:See"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Symantics1",
          "name": "SemEnv",
          "package": "liboleg",
          "signature": "SemEnv",
          "source": "src/Language-Symantics1.html#SemEnv",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Symantics1",
          "module": "Language.Symantics1",
          "name": "SemEnv",
          "package": "liboleg",
          "partial": "Sem Env",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-Symantics1.html#v:SemEnv"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Symantics1",
          "name": "SemM",
          "package": "liboleg",
          "signature": "SemM (ReaderT (SemEnv r) (CC r) a)",
          "source": "src/Language-Symantics1.html#SemM",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Symantics1",
          "module": "Language.Symantics1",
          "name": "SemM",
          "package": "liboleg",
          "partial": "Sem",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-Symantics1.html#v:SemM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Symantics1",
          "name": "Uni_over_Exi",
          "package": "liboleg",
          "signature": "Uni_over_Exi",
          "source": "src/Language-Symantics1.html#QuantOrder",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Symantics1",
          "module": "Language.Symantics1",
          "name": "Uni_over_Exi",
          "package": "liboleg",
          "partial": "Uni Exi",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-Symantics1.html#v:Uni_over_Exi"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Symantics1",
          "name": "Woman",
          "package": "liboleg",
          "signature": "Woman E",
          "source": "src/Language-Symantics1.html#T",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Symantics1",
          "module": "Language.Symantics1",
          "name": "Woman",
          "package": "liboleg",
          "partial": "Woman",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-Symantics1.html#v:Woman"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eMovement\u003c/em\u003e into the position of the prompt selected by psel\n\u003c/p\u003e\u003cp\u003eLogical forms of sample terms in different semantic environment\n\u003c/p\u003e\u003cp\u003eAuxiliary functions\n\u003c/p\u003e",
          "module": "Language.Symantics1",
          "name": "app",
          "package": "liboleg",
          "signature": "m (a -\u003e m b) -\u003e m a -\u003e m b",
          "source": "src/Language-Symantics1.html#app",
          "type": "function"
        },
        "index": {
          "description": "Movement into the position of the prompt selected by psel Logical forms of sample terms in different semantic environment Auxiliary functions",
          "hierarchy": "Language Symantics1",
          "module": "Language.Symantics1",
          "name": "app",
          "normalized": "a(b-\u003ea c)-\u003ea b-\u003ea c",
          "package": "liboleg",
          "signature": "m(a-\u003em b)-\u003em a-\u003em b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-Symantics1.html#v:app"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Symantics1",
          "name": "bill",
          "package": "liboleg",
          "signature": "c (I c NP)",
          "source": "src/Language-Symantics1.html#bill",
          "type": "method"
        },
        "index": {
          "hierarchy": "Language Symantics1",
          "module": "Language.Symantics1",
          "name": "bill",
          "package": "liboleg",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-Symantics1.html#v:bill"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Symantics1",
          "name": "ccat",
          "package": "liboleg",
          "signature": "LString String -\u003e LString String -\u003e LString String",
          "source": "src/Language-Symantics1.html#ccat",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Symantics1",
          "module": "Language.Symantics1",
          "name": "ccat",
          "normalized": "LString String-\u003eLString String-\u003eLString String",
          "package": "liboleg",
          "signature": "LString String-\u003eLString String-\u003eLString String",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-Symantics1.html#v:ccat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Symantics1",
          "name": "dot",
          "package": "liboleg",
          "signature": "c (I c S) -\u003e c (I c SM)",
          "source": "src/Language-Symantics1.html#dot",
          "type": "method"
        },
        "index": {
          "hierarchy": "Language Symantics1",
          "module": "Language.Symantics1",
          "name": "dot",
          "normalized": "a(I a S)-\u003ea(I a SM)",
          "package": "liboleg",
          "signature": "c(I c S)-\u003ec(I c SM)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-Symantics1.html#v:dot"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Symantics1",
          "name": "every",
          "package": "liboleg",
          "signature": "c (I c N) -\u003e c (I c NP)",
          "source": "src/Language-Symantics1.html#every",
          "type": "method"
        },
        "index": {
          "hierarchy": "Language Symantics1",
          "module": "Language.Symantics1",
          "name": "every",
          "normalized": "a(I a N)-\u003ea(I a NP)",
          "package": "liboleg",
          "signature": "c(I c N)-\u003ec(I c NP)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-Symantics1.html#v:every"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGenerate a new variable name\n\u003c/p\u003e",
          "module": "Language.Symantics1",
          "name": "genvar",
          "package": "liboleg",
          "signature": "SemM r Varname",
          "source": "src/Language-Symantics1.html#genvar",
          "type": "function"
        },
        "index": {
          "description": "Generate new variable name",
          "hierarchy": "Language Symantics1",
          "module": "Language.Symantics1",
          "name": "genvar",
          "package": "liboleg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-Symantics1.html#v:genvar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Symantics1",
          "name": "john",
          "package": "liboleg",
          "signature": "c (I c NP)",
          "source": "src/Language-Symantics1.html#john",
          "type": "method"
        },
        "index": {
          "hierarchy": "Language Symantics1",
          "module": "Language.Symantics1",
          "name": "john",
          "package": "liboleg",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-Symantics1.html#v:john"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Symantics1",
          "name": "love",
          "package": "liboleg",
          "signature": "c (I c NP) -\u003e c (I c NP) -\u003e c (I c S)",
          "source": "src/Language-Symantics1.html#love",
          "type": "method"
        },
        "index": {
          "hierarchy": "Language Symantics1",
          "module": "Language.Symantics1",
          "name": "love",
          "normalized": "a(I a NP)-\u003ea(I a NP)-\u003ea(I a S)",
          "package": "liboleg",
          "signature": "c(I c NP)-\u003ec(I c NP)-\u003ec(I c S)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-Symantics1.html#v:love"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Symantics1",
          "name": "man",
          "package": "liboleg",
          "signature": "c (I c N)",
          "source": "src/Language-Symantics1.html#man",
          "type": "method"
        },
        "index": {
          "hierarchy": "Language Symantics1",
          "module": "Language.Symantics1",
          "name": "man",
          "package": "liboleg",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-Symantics1.html#v:man"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Symantics1",
          "name": "pcnt",
          "package": "liboleg",
          "signature": "Prompt r (Int -\u003e CC r T)",
          "source": "src/Language-Symantics1.html#SemEnv",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Symantics1",
          "module": "Language.Symantics1",
          "name": "pcnt",
          "normalized": "Prompt a(Int-\u003eCC a T)",
          "package": "liboleg",
          "signature": "Prompt r(Int-\u003eCC r T)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-Symantics1.html#v:pcnt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Symantics1",
          "name": "pexi",
          "package": "liboleg",
          "signature": "Prompt r T",
          "source": "src/Language-Symantics1.html#SemEnv",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Symantics1",
          "module": "Language.Symantics1",
          "name": "pexi",
          "package": "liboleg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-Symantics1.html#v:pexi"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Symantics1",
          "name": "puni",
          "package": "liboleg",
          "signature": "Prompt r T",
          "source": "src/Language-Symantics1.html#SemEnv",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Symantics1",
          "module": "Language.Symantics1",
          "name": "puni",
          "package": "liboleg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-Symantics1.html#v:puni"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Symantics1",
          "name": "quant_order",
          "package": "liboleg",
          "signature": "QuantOrder",
          "source": "src/Language-Symantics1.html#SemEnv",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Symantics1",
          "module": "Language.Symantics1",
          "name": "quant_order",
          "package": "liboleg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-Symantics1.html#v:quant_order"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Symantics1",
          "name": "runSem",
          "package": "liboleg",
          "signature": "QuantOrder -\u003e (forall r.  SemM r T) -\u003e T",
          "source": "src/Language-Symantics1.html#runSem",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Symantics1",
          "module": "Language.Symantics1",
          "name": "runSem",
          "normalized": "QuantOrder-\u003e(a b SemM c T)-\u003eT",
          "package": "liboleg",
          "partial": "Sem",
          "signature": "QuantOrder-\u003e(forall r. SemM r T)-\u003eT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-Symantics1.html#v:runSem"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Symantics1",
          "name": "see",
          "package": "liboleg",
          "signature": "c (I c NP) -\u003e c (I c NP) -\u003e c (I c S)",
          "source": "src/Language-Symantics1.html#see",
          "type": "method"
        },
        "index": {
          "hierarchy": "Language Symantics1",
          "module": "Language.Symantics1",
          "name": "see",
          "normalized": "a(I a NP)-\u003ea(I a NP)-\u003ea(I a S)",
          "package": "liboleg",
          "signature": "c(I c NP)-\u003ec(I c NP)-\u003ec(I c S)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-Symantics1.html#v:see"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Symantics1",
          "name": "shiftP",
          "package": "liboleg",
          "signature": "Prompt r b -\u003e ((a -\u003e CC r b) -\u003e CC r b) -\u003e CC r a",
          "source": "src/Language-Symantics1.html#shiftP",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Symantics1",
          "module": "Language.Symantics1",
          "name": "shiftP",
          "normalized": "Prompt a b-\u003e((c-\u003eCC a b)-\u003eCC a b)-\u003eCC a c",
          "package": "liboleg",
          "signature": "Prompt r b-\u003e((a-\u003eCC r b)-\u003eCC r b)-\u003eCC r a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-Symantics1.html#v:shiftP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Symantics1",
          "name": "some",
          "package": "liboleg",
          "signature": "c (I c N) -\u003e c (I c NP)",
          "source": "src/Language-Symantics1.html#some",
          "type": "method"
        },
        "index": {
          "hierarchy": "Language Symantics1",
          "module": "Language.Symantics1",
          "name": "some",
          "normalized": "a(I a N)-\u003ea(I a NP)",
          "package": "liboleg",
          "signature": "c(I c N)-\u003ec(I c NP)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-Symantics1.html#v:some"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Symantics1",
          "name": "unSem",
          "package": "liboleg",
          "signature": "SemM r a -\u003e SemEnv r -\u003e CC r a",
          "source": "src/Language-Symantics1.html#unSem",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Symantics1",
          "module": "Language.Symantics1",
          "name": "unSem",
          "normalized": "SemM a b-\u003eSemEnv a-\u003eCC a b",
          "package": "liboleg",
          "partial": "Sem",
          "signature": "SemM r a-\u003eSemEnv r-\u003eCC r a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-Symantics1.html#v:unSem"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Symantics1",
          "name": "woman",
          "package": "liboleg",
          "signature": "c (I c N)",
          "source": "src/Language-Symantics1.html#woman",
          "type": "method"
        },
        "index": {
          "hierarchy": "Language Symantics1",
          "module": "Language.Symantics1",
          "name": "woman",
          "package": "liboleg",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-Symantics1.html#v:woman"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eType-directed partial evaluation, Olivier Danvy, POPL96\n * \u003ca\u003ehttp://www.brics.dk/~danvy/tdpe-ln.pdf\u003c/a\u003e\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Language.TDPE",
          "name": "TDPE",
          "package": "liboleg",
          "source": "src/Language-TDPE.html",
          "type": "module"
        },
        "index": {
          "description": "Type-directed partial evaluation Olivier Danvy POPL96 http www.brics.dk danvy tdpe-ln.pdf",
          "hierarchy": "Language TDPE",
          "module": "Language.TDPE",
          "name": "TDPE",
          "package": "liboleg",
          "partial": "TDPE",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TDPE.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TDPE",
          "name": "RR",
          "package": "liboleg",
          "source": "src/Language-TDPE.html#RR",
          "type": "data"
        },
        "index": {
          "hierarchy": "Language TDPE",
          "module": "Language.TDPE",
          "name": "RR",
          "package": "liboleg",
          "partial": "RR",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TDPE.html#t:RR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TDPE",
          "name": "(--\u003e)",
          "package": "liboleg",
          "signature": "RR repr m1 o1 -\u003e RR repr m2 o2 -\u003e RR repr (m1 -\u003e m2) (o1 -\u003e o2)",
          "source": "src/Language-TDPE.html#--%3E",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language TDPE",
          "module": "Language.TDPE",
          "name": "(--\u003e) --\u003e",
          "normalized": "RR a b c-\u003eRR a b c-\u003eRR a(b-\u003eb)(c-\u003ec)",
          "package": "liboleg",
          "signature": "RR repr m o-\u003eRR repr m o-\u003eRR repr(m-\u003em)(o-\u003eo)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TDPE.html#v:-45--45--62-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TDPE",
          "name": "RR",
          "package": "liboleg",
          "signature": "RR",
          "source": "src/Language-TDPE.html#RR",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language TDPE",
          "module": "Language.TDPE",
          "name": "RR",
          "package": "liboleg",
          "partial": "RR",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TDPE.html#v:RR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TDPE",
          "name": "base",
          "package": "liboleg",
          "signature": "RR repr (repr a) a",
          "source": "src/Language-TDPE.html#base",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language TDPE",
          "module": "Language.TDPE",
          "name": "base",
          "package": "liboleg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TDPE.html#v:base"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TDPE",
          "name": "reflect",
          "package": "liboleg",
          "signature": "repr obj -\u003e meta",
          "source": "src/Language-TDPE.html#RR",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language TDPE",
          "module": "Language.TDPE",
          "name": "reflect",
          "normalized": "a b-\u003ec",
          "package": "liboleg",
          "signature": "repr obj-\u003emeta",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TDPE.html#v:reflect"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TDPE",
          "name": "reify",
          "package": "liboleg",
          "signature": "meta -\u003e repr obj",
          "source": "src/Language-TDPE.html#RR",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language TDPE",
          "module": "Language.TDPE",
          "name": "reify",
          "normalized": "a-\u003eb c",
          "package": "liboleg",
          "signature": "meta-\u003erepr obj",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TDPE.html#v:reify"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eUntyped (nominal) lambda-calculus with integers and the conditional\n\u003c/p\u003e\u003cp\u003e\u003ca\u003ehttp://okmij.org/ftp/Computation/Computation.html#teval\u003c/a\u003e\n\u003c/p\u003e\u003cdl\u003e\u003cdt\u003eThe Abstract of the lecture notes\u003c/dt\u003e\u003cdd\u003e\n    We expound a view of type checking as evaluation with `abstract values'. Whereas dynamic\n     semantics, evaluation, deals with (dynamic) values like 0, 1, etc., static semantics, type\n     checking, deals with approximations like int. A type system is sound if it correctly approximates\n     the dynamic behavior and predicts its outcome: if the static semantics predicts that a term has\n     the type int, the dynamic evaluation of the term, if it terminates, will yield an integer.\n\u003c/dd\u003e\u003c/dl\u003e\u003cp\u003eAs object language, we use simply-typed and let-polymorphic lambda calculi with integers and\n     integer operations as constants. We use Haskell as a metalanguage in which to write evaluators,\n     type checkers, type reconstructors and inferencers for the object language.\n\u003c/p\u003e\u003cp\u003eWe explore the deep relation between parametric polymorphism and \u003ccode\u003einlining\u003c/code\u003e. Polymorphic type\n     checking then is an optimization allowing us to type check a polymorphic term at the place of its\n     definition rather than at the places of its use.\n\u003c/p\u003e\u003cp\u003eJoint work with Chung-chieh Shan.\n\u003c/p\u003e\u003cp\u003eVersion\n     The current version is 1.1, July 2008.\n References\n     lecture.pdf [199K]\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Language.TEval.EvalN",
          "name": "EvalN",
          "package": "liboleg",
          "source": "src/Language-TEval-EvalN.html",
          "type": "module"
        },
        "index": {
          "description": "Untyped nominal lambda-calculus with integers and the conditional http okmij.org ftp Computation Computation.html teval The Abstract of the lecture notes We expound view of type checking as evaluation with abstract values Whereas dynamic semantics evaluation deals with dynamic values like etc static semantics type checking deals with approximations like int type system is sound if it correctly approximates the dynamic behavior and predicts its outcome if the static semantics predicts that term has the type int the dynamic evaluation of the term if it terminates will yield an integer As object language we use simply-typed and let-polymorphic lambda calculi with integers and integer operations as constants We use Haskell as metalanguage in which to write evaluators type checkers type reconstructors and inferencers for the object language We explore the deep relation between parametric polymorphism and inlining Polymorphic type checking then is an optimization allowing us to type check polymorphic term at the place of its definition rather than at the places of its use Joint work with Chung-chieh Shan Version The current version is July References lecture.pdf",
          "hierarchy": "Language TEval EvalN",
          "module": "Language.TEval.EvalN",
          "name": "EvalN",
          "package": "liboleg",
          "partial": "Eval",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-EvalN.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEnvironment: associating values with \u003ccode\u003efree\u003c/code\u003e variables\n\u003c/p\u003e",
          "module": "Language.TEval.EvalN",
          "name": "Env",
          "package": "liboleg",
          "source": "src/Language-TEval-EvalN.html#Env",
          "type": "type"
        },
        "index": {
          "description": "Environment associating values with free variables",
          "hierarchy": "Language TEval EvalN",
          "module": "Language.TEval.EvalN",
          "name": "Env",
          "package": "liboleg",
          "partial": "Env",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-EvalN.html#t:Env"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TEval.EvalN",
          "name": "Term",
          "package": "liboleg",
          "source": "src/Language-TEval-EvalN.html#Term",
          "type": "data"
        },
        "index": {
          "hierarchy": "Language TEval EvalN",
          "module": "Language.TEval.EvalN",
          "name": "Term",
          "package": "liboleg",
          "partial": "Term",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-EvalN.html#t:Term"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TEval.EvalN",
          "name": "Value",
          "package": "liboleg",
          "source": "src/Language-TEval-EvalN.html#Value",
          "type": "data"
        },
        "index": {
          "hierarchy": "Language TEval EvalN",
          "module": "Language.TEval.EvalN",
          "name": "Value",
          "package": "liboleg",
          "partial": "Value",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-EvalN.html#t:Value"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TEval.EvalN",
          "name": "VarName",
          "package": "liboleg",
          "source": "src/Language-TEval-EvalN.html#VarName",
          "type": "type"
        },
        "index": {
          "hierarchy": "Language TEval EvalN",
          "module": "Language.TEval.EvalN",
          "name": "VarName",
          "package": "liboleg",
          "partial": "Var Name",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-EvalN.html#t:VarName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TEval.EvalN",
          "name": ":+",
          "package": "liboleg",
          "signature": "Term :+ Term",
          "source": "src/Language-TEval-EvalN.html#Term",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language TEval EvalN",
          "module": "Language.TEval.EvalN",
          "name": ":+",
          "package": "liboleg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-EvalN.html#v::-43-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TEval.EvalN",
          "name": "A",
          "package": "liboleg",
          "signature": "A Term Term",
          "source": "src/Language-TEval-EvalN.html#Term",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language TEval EvalN",
          "module": "Language.TEval.EvalN",
          "name": "A",
          "package": "liboleg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-EvalN.html#v:A"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TEval.EvalN",
          "name": "I",
          "package": "liboleg",
          "signature": "I Int",
          "source": "src/Language-TEval-EvalN.html#Term",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language TEval EvalN",
          "module": "Language.TEval.EvalN",
          "name": "I",
          "package": "liboleg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-EvalN.html#v:I"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TEval.EvalN",
          "name": "IFZ",
          "package": "liboleg",
          "signature": "IFZ Term Term Term",
          "source": "src/Language-TEval-EvalN.html#Term",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language TEval EvalN",
          "module": "Language.TEval.EvalN",
          "name": "IFZ",
          "package": "liboleg",
          "partial": "IFZ",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-EvalN.html#v:IFZ"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TEval.EvalN",
          "name": "L",
          "package": "liboleg",
          "signature": "L VarName Term",
          "source": "src/Language-TEval-EvalN.html#Term",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language TEval EvalN",
          "module": "Language.TEval.EvalN",
          "name": "L",
          "package": "liboleg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-EvalN.html#v:L"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TEval.EvalN",
          "name": "V",
          "package": "liboleg",
          "signature": "V VarName",
          "source": "src/Language-TEval-EvalN.html#Term",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language TEval EvalN",
          "module": "Language.TEval.EvalN",
          "name": "V",
          "package": "liboleg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-EvalN.html#v:V"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TEval.EvalN",
          "name": "VC",
          "package": "liboleg",
          "signature": "VC (Value -\u003e Value)",
          "source": "src/Language-TEval-EvalN.html#Value",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language TEval EvalN",
          "module": "Language.TEval.EvalN",
          "name": "VC",
          "normalized": "VC(Value-\u003eValue)",
          "package": "liboleg",
          "partial": "VC",
          "signature": "VC(Value-\u003eValue)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-EvalN.html#v:VC"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TEval.EvalN",
          "name": "VI",
          "package": "liboleg",
          "signature": "VI Int",
          "source": "src/Language-TEval-EvalN.html#Value",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language TEval EvalN",
          "module": "Language.TEval.EvalN",
          "name": "VI",
          "package": "liboleg",
          "partial": "VI",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-EvalN.html#v:VI"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TEval.EvalN",
          "name": "env0",
          "package": "liboleg",
          "signature": "Env",
          "source": "src/Language-TEval-EvalN.html#env0",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language TEval EvalN",
          "module": "Language.TEval.EvalN",
          "name": "env0",
          "package": "liboleg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-EvalN.html#v:env0"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDenotational semantics. Why? How to make it operational?\n\u003c/p\u003e",
          "module": "Language.TEval.EvalN",
          "name": "eval",
          "package": "liboleg",
          "signature": "Env -\u003e Term -\u003e Value",
          "source": "src/Language-TEval-EvalN.html#eval",
          "type": "function"
        },
        "index": {
          "description": "Denotational semantics Why How to make it operational",
          "hierarchy": "Language TEval EvalN",
          "module": "Language.TEval.EvalN",
          "name": "eval",
          "normalized": "Env-\u003eTerm-\u003eValue",
          "package": "liboleg",
          "signature": "Env-\u003eTerm-\u003eValue",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-EvalN.html#v:eval"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TEval.EvalN",
          "name": "ext",
          "package": "liboleg",
          "signature": "Env -\u003e (VarName, Value) -\u003e Env",
          "source": "src/Language-TEval-EvalN.html#ext",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language TEval EvalN",
          "module": "Language.TEval.EvalN",
          "name": "ext",
          "normalized": "Env-\u003e(VarName,Value)-\u003eEnv",
          "package": "liboleg",
          "signature": "Env-\u003e(VarName,Value)-\u003eEnv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-EvalN.html#v:ext"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TEval.EvalN",
          "name": "lkup",
          "package": "liboleg",
          "signature": "Env -\u003e VarName -\u003e Value",
          "source": "src/Language-TEval-EvalN.html#lkup",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language TEval EvalN",
          "module": "Language.TEval.EvalN",
          "name": "lkup",
          "normalized": "Env-\u003eVarName-\u003eValue",
          "package": "liboleg",
          "signature": "Env-\u003eVarName-\u003eValue",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-EvalN.html#v:lkup"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eTagless Typed lambda-calculus with integers and the conditional\n in the higher-order abstract syntax.\n Haskell itself ensures the object terms are well-typed.\n Here we use the tagless final approach.\n\u003c/p\u003e\u003cp\u003e\u003ca\u003ehttp://okmij.org/ftp/Computation/Computation.html#teval\u003c/a\u003e\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Language.TEval.EvalTaglessF",
          "name": "EvalTaglessF",
          "package": "liboleg",
          "source": "src/Language-TEval-EvalTaglessF.html",
          "type": "module"
        },
        "index": {
          "description": "Tagless Typed lambda-calculus with integers and the conditional in the higher-order abstract syntax Haskell itself ensures the object terms are well-typed Here we use the tagless final approach http okmij.org ftp Computation Computation.html teval",
          "hierarchy": "Language TEval EvalTaglessF",
          "module": "Language.TEval.EvalTaglessF",
          "name": "EvalTaglessF",
          "package": "liboleg",
          "partial": "Eval Tagless",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-EvalTaglessF.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWe no longer need variables or the environment and we do\n normalization by evaluation.\n\u003c/p\u003e\u003cp\u003eDenotational semantics. Why?\n\u003c/p\u003e",
          "module": "Language.TEval.EvalTaglessF",
          "name": "D",
          "package": "liboleg",
          "source": "src/Language-TEval-EvalTaglessF.html#D",
          "type": "newtype"
        },
        "index": {
          "description": "We no longer need variables or the environment and we do normalization by evaluation Denotational semantics Why",
          "hierarchy": "Language TEval EvalTaglessF",
          "module": "Language.TEval.EvalTaglessF",
          "name": "D",
          "package": "liboleg",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-EvalTaglessF.html#t:D"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TEval.EvalTaglessF",
          "name": "S",
          "package": "liboleg",
          "source": "src/Language-TEval-EvalTaglessF.html#S",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "Language TEval EvalTaglessF",
          "module": "Language.TEval.EvalTaglessF",
          "name": "S",
          "package": "liboleg",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-EvalTaglessF.html#t:S"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TEval.EvalTaglessF",
          "name": "Symantics",
          "package": "liboleg",
          "source": "src/Language-TEval-EvalTaglessF.html#Symantics",
          "type": "class"
        },
        "index": {
          "hierarchy": "Language TEval EvalTaglessF",
          "module": "Language.TEval.EvalTaglessF",
          "name": "Symantics",
          "package": "liboleg",
          "partial": "Symantics",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-EvalTaglessF.html#t:Symantics"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSince we rely on the metalanguage for typechecking and hence\n type generalization, we have to use `let' of the metalanguage.\n\u003c/p\u003e\u003cp\u003eIt is quite challenging to show terms. Yet, in contrast to the GADT-based\n approach (EvalTaglessI.hs), we are able to do that, without\n extending our language with auxiliary syntactic forms.\n Incidentally, showing of terms is just another way of _evaluating_\n them, to strings.\n\u003c/p\u003e",
          "module": "Language.TEval.EvalTaglessF",
          "name": "VarCount",
          "package": "liboleg",
          "source": "src/Language-TEval-EvalTaglessF.html#VarCount",
          "type": "type"
        },
        "index": {
          "description": "Since we rely on the metalanguage for typechecking and hence type generalization we have to use let of the metalanguage It is quite challenging to show terms Yet in contrast to the GADT-based approach EvalTaglessI.hs we are able to do that without extending our language with auxiliary syntactic forms Incidentally showing of terms is just another way of evaluating them to strings",
          "hierarchy": "Language TEval EvalTaglessF",
          "module": "Language.TEval.EvalTaglessF",
          "name": "VarCount",
          "package": "liboleg",
          "partial": "Var Count",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-EvalTaglessF.html#t:VarCount"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TEval.EvalTaglessF",
          "name": "(+:)",
          "package": "liboleg",
          "signature": "repr Int -\u003e repr Int -\u003e repr Int",
          "source": "src/Language-TEval-EvalTaglessF.html#%2B%3A",
          "type": "method"
        },
        "index": {
          "hierarchy": "Language TEval EvalTaglessF",
          "module": "Language.TEval.EvalTaglessF",
          "name": "(+:) +:",
          "normalized": "a Int-\u003ea Int-\u003ea Int",
          "package": "liboleg",
          "signature": "repr Int-\u003erepr Int-\u003erepr Int",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-EvalTaglessF.html#v:-43-:"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TEval.EvalTaglessF",
          "name": "D",
          "package": "liboleg",
          "signature": "D t",
          "source": "src/Language-TEval-EvalTaglessF.html#D",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language TEval EvalTaglessF",
          "module": "Language.TEval.EvalTaglessF",
          "name": "D",
          "package": "liboleg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-EvalTaglessF.html#v:D"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TEval.EvalTaglessF",
          "name": "S",
          "package": "liboleg",
          "signature": "S (VarCount -\u003e (String, VarCount))",
          "source": "src/Language-TEval-EvalTaglessF.html#S",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language TEval EvalTaglessF",
          "module": "Language.TEval.EvalTaglessF",
          "name": "S",
          "normalized": "S(VarCount-\u003e(String,VarCount))",
          "package": "liboleg",
          "signature": "S(VarCount-\u003e(String,VarCount))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-EvalTaglessF.html#v:S"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TEval.EvalTaglessF",
          "name": "a",
          "package": "liboleg",
          "signature": "repr (t1 -\u003e t2) -\u003e repr t1 -\u003e repr t2",
          "source": "src/Language-TEval-EvalTaglessF.html#a",
          "type": "method"
        },
        "index": {
          "hierarchy": "Language TEval EvalTaglessF",
          "module": "Language.TEval.EvalTaglessF",
          "name": "a",
          "normalized": "a(b-\u003eb)-\u003ea b-\u003ea b",
          "package": "liboleg",
          "signature": "repr(t-\u003et)-\u003erepr t-\u003erepr t",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-EvalTaglessF.html#v:a"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TEval.EvalTaglessF",
          "name": "evald",
          "package": "liboleg",
          "signature": "D t -\u003e t",
          "source": "src/Language-TEval-EvalTaglessF.html#evald",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language TEval EvalTaglessF",
          "module": "Language.TEval.EvalTaglessF",
          "name": "evald",
          "normalized": "D a-\u003ea",
          "package": "liboleg",
          "signature": "D t-\u003et",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-EvalTaglessF.html#v:evald"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TEval.EvalTaglessF",
          "name": "fix",
          "package": "liboleg",
          "signature": "repr ((a -\u003e b) -\u003e a -\u003e b) -\u003e repr (a -\u003e b)",
          "source": "src/Language-TEval-EvalTaglessF.html#fix",
          "type": "method"
        },
        "index": {
          "hierarchy": "Language TEval EvalTaglessF",
          "module": "Language.TEval.EvalTaglessF",
          "name": "fix",
          "normalized": "a((b-\u003ec)-\u003eb-\u003ec)-\u003ea(b-\u003ec)",
          "package": "liboleg",
          "signature": "repr((a-\u003eb)-\u003ea-\u003eb)-\u003erepr(a-\u003eb)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-EvalTaglessF.html#v:fix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TEval.EvalTaglessF",
          "name": "i",
          "package": "liboleg",
          "signature": "Int -\u003e repr Int",
          "source": "src/Language-TEval-EvalTaglessF.html#i",
          "type": "method"
        },
        "index": {
          "hierarchy": "Language TEval EvalTaglessF",
          "module": "Language.TEval.EvalTaglessF",
          "name": "i",
          "normalized": "Int-\u003ea Int",
          "package": "liboleg",
          "signature": "Int-\u003erepr Int",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-EvalTaglessF.html#v:i"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TEval.EvalTaglessF",
          "name": "ifz",
          "package": "liboleg",
          "signature": "repr Int -\u003e repr t -\u003e repr t -\u003e repr t",
          "source": "src/Language-TEval-EvalTaglessF.html#ifz",
          "type": "method"
        },
        "index": {
          "hierarchy": "Language TEval EvalTaglessF",
          "module": "Language.TEval.EvalTaglessF",
          "name": "ifz",
          "normalized": "a Int-\u003ea b-\u003ea b-\u003ea b",
          "package": "liboleg",
          "signature": "repr Int-\u003erepr t-\u003erepr t-\u003erepr t",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-EvalTaglessF.html#v:ifz"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TEval.EvalTaglessF",
          "name": "l",
          "package": "liboleg",
          "signature": "(repr t1 -\u003e repr t2) -\u003e repr (t1 -\u003e t2)",
          "source": "src/Language-TEval-EvalTaglessF.html#l",
          "type": "method"
        },
        "index": {
          "hierarchy": "Language TEval EvalTaglessF",
          "module": "Language.TEval.EvalTaglessF",
          "name": "l",
          "normalized": "(a b-\u003ea b)-\u003ea(b-\u003eb)",
          "package": "liboleg",
          "signature": "(repr t-\u003erepr t)-\u003erepr(t-\u003et)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-EvalTaglessF.html#v:l"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eTagless Typed lambda-calculus with integers and the conditional\n in the higher-order abstract syntax.\n Haskell itself ensures the object terms are well-typed.\n Here we use GADT: This file is not in Haskell98\n\u003c/p\u003e\u003cp\u003e\u003ca\u003ehttp://okmij.org/ftp/Computation/Computation.html#teval\u003c/a\u003e\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Language.TEval.EvalTaglessI",
          "name": "EvalTaglessI",
          "package": "liboleg",
          "source": "src/Language-TEval-EvalTaglessI.html",
          "type": "module"
        },
        "index": {
          "description": "Tagless Typed lambda-calculus with integers and the conditional in the higher-order abstract syntax Haskell itself ensures the object terms are well-typed Here we use GADT This file is not in Haskell98 http okmij.org ftp Computation Computation.html teval",
          "hierarchy": "Language TEval EvalTaglessI",
          "module": "Language.TEval.EvalTaglessI",
          "name": "EvalTaglessI",
          "package": "liboleg",
          "partial": "Eval Tagless",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-EvalTaglessI.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TEval.EvalTaglessI",
          "name": "Term",
          "package": "liboleg",
          "source": "src/Language-TEval-EvalTaglessI.html#Term",
          "type": "data"
        },
        "index": {
          "hierarchy": "Language TEval EvalTaglessI",
          "module": "Language.TEval.EvalTaglessI",
          "name": "Term",
          "package": "liboleg",
          "partial": "Term",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-EvalTaglessI.html#t:Term"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TEval.EvalTaglessI",
          "name": ":+",
          "package": "liboleg",
          "signature": "Term Int -\u003e Term Int -\u003e Term Int",
          "source": "src/Language-TEval-EvalTaglessI.html#Term",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language TEval EvalTaglessI",
          "module": "Language.TEval.EvalTaglessI",
          "name": ":+",
          "normalized": "Term Int-\u003eTerm Int-\u003eTerm Int",
          "package": "liboleg",
          "signature": "Term Int-\u003eTerm Int-\u003eTerm Int",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-EvalTaglessI.html#v::-43-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TEval.EvalTaglessI",
          "name": "A",
          "package": "liboleg",
          "signature": "Term (t1 -\u003e t2) -\u003e Term t1 -\u003e Term t2",
          "source": "src/Language-TEval-EvalTaglessI.html#Term",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language TEval EvalTaglessI",
          "module": "Language.TEval.EvalTaglessI",
          "name": "A",
          "normalized": "Term(a-\u003ea)-\u003eTerm a-\u003eTerm a",
          "package": "liboleg",
          "signature": "Term(t-\u003et)-\u003eTerm t-\u003eTerm t",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-EvalTaglessI.html#v:A"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TEval.EvalTaglessI",
          "name": "Fix",
          "package": "liboleg",
          "signature": "Term ((a -\u003e b) -\u003e a -\u003e b) -\u003e Term (a -\u003e b)",
          "source": "src/Language-TEval-EvalTaglessI.html#Term",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language TEval EvalTaglessI",
          "module": "Language.TEval.EvalTaglessI",
          "name": "Fix",
          "normalized": "Term((a-\u003eb)-\u003ea-\u003eb)-\u003eTerm(a-\u003eb)",
          "package": "liboleg",
          "partial": "Fix",
          "signature": "Term((a-\u003eb)-\u003ea-\u003eb)-\u003eTerm(a-\u003eb)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-EvalTaglessI.html#v:Fix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TEval.EvalTaglessI",
          "name": "I",
          "package": "liboleg",
          "signature": "Int -\u003e Term Int",
          "source": "src/Language-TEval-EvalTaglessI.html#Term",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language TEval EvalTaglessI",
          "module": "Language.TEval.EvalTaglessI",
          "name": "I",
          "normalized": "Int-\u003eTerm Int",
          "package": "liboleg",
          "signature": "Int-\u003eTerm Int",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-EvalTaglessI.html#v:I"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TEval.EvalTaglessI",
          "name": "IFZ",
          "package": "liboleg",
          "signature": "Term Int -\u003e Term t -\u003e Term t -\u003e Term t",
          "source": "src/Language-TEval-EvalTaglessI.html#Term",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language TEval EvalTaglessI",
          "module": "Language.TEval.EvalTaglessI",
          "name": "IFZ",
          "normalized": "Term Int-\u003eTerm a-\u003eTerm a-\u003eTerm a",
          "package": "liboleg",
          "partial": "IFZ",
          "signature": "Term Int-\u003eTerm t-\u003eTerm t-\u003eTerm t",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-EvalTaglessI.html#v:IFZ"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TEval.EvalTaglessI",
          "name": "L",
          "package": "liboleg",
          "signature": "(Term t1 -\u003e Term t2) -\u003e Term (t1 -\u003e t2)",
          "source": "src/Language-TEval-EvalTaglessI.html#Term",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language TEval EvalTaglessI",
          "module": "Language.TEval.EvalTaglessI",
          "name": "L",
          "normalized": "(Term a-\u003eTerm a)-\u003eTerm(a-\u003ea)",
          "package": "liboleg",
          "signature": "(Term t-\u003eTerm t)-\u003eTerm(t-\u003et)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-EvalTaglessI.html#v:L"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TEval.EvalTaglessI",
          "name": "V",
          "package": "liboleg",
          "signature": "t -\u003e Term t",
          "source": "src/Language-TEval-EvalTaglessI.html#Term",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language TEval EvalTaglessI",
          "module": "Language.TEval.EvalTaglessI",
          "name": "V",
          "normalized": "a-\u003eTerm a",
          "package": "liboleg",
          "signature": "t-\u003eTerm t",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-EvalTaglessI.html#v:V"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWe no longer need variables or the environment and we do\n normalization by evaluation.\n\u003c/p\u003e\u003cp\u003eDenotational semantics. Why?\n\u003c/p\u003e",
          "module": "Language.TEval.EvalTaglessI",
          "name": "evald",
          "package": "liboleg",
          "signature": "Term t -\u003e t",
          "source": "src/Language-TEval-EvalTaglessI.html#evald",
          "type": "function"
        },
        "index": {
          "description": "We no longer need variables or the environment and we do normalization by evaluation Denotational semantics Why",
          "hierarchy": "Language TEval EvalTaglessI",
          "module": "Language.TEval.EvalTaglessI",
          "name": "evald",
          "normalized": "Term a-\u003ea",
          "package": "liboleg",
          "signature": "Term t-\u003et",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-EvalTaglessI.html#v:evald"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eOperational semantics. Why?\n GADT are still implemented imperfectly: we the default case in case \n statements (with cannot happen error), to avoid the warning about\n inexhaustive pattern match -- although these case-brances can never\n be executed. Why?\n\u003c/p\u003e",
          "module": "Language.TEval.EvalTaglessI",
          "name": "evalo",
          "package": "liboleg",
          "signature": "Term t -\u003e Term t",
          "source": "src/Language-TEval-EvalTaglessI.html#evalo",
          "type": "function"
        },
        "index": {
          "description": "Operational semantics Why GADT are still implemented imperfectly we the default case in case statements with cannot happen error to avoid the warning about inexhaustive pattern match although these case-brances can never be executed Why",
          "hierarchy": "Language TEval EvalTaglessI",
          "module": "Language.TEval.EvalTaglessI",
          "name": "evalo",
          "normalized": "Term a-\u003eTerm a",
          "package": "liboleg",
          "signature": "Term t-\u003eTerm t",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-EvalTaglessI.html#v:evalo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eSimply-typed Church-style (nominal) lambda-calculus\n with integers and zero-comparison\n Type checking\n\u003c/p\u003e\u003cp\u003e\u003ca\u003ehttp://okmij.org/ftp/Computation/Computation.html#teval\u003c/a\u003e\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Language.TEval.TEvalNC",
          "name": "TEvalNC",
          "package": "liboleg",
          "source": "src/Language-TEval-TEvalNC.html",
          "type": "module"
        },
        "index": {
          "description": "Simply-typed Church-style nominal lambda-calculus with integers and zero-comparison Type checking http okmij.org ftp Computation Computation.html teval",
          "hierarchy": "Language TEval TEvalNC",
          "module": "Language.TEval.TEvalNC",
          "name": "TEvalNC",
          "package": "liboleg",
          "partial": "TEval NC",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TEvalNC.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eType Environment: associating types with \u003ccode\u003efree\u003c/code\u003e variables\n\u003c/p\u003e",
          "module": "Language.TEval.TEvalNC",
          "name": "TEnv",
          "package": "liboleg",
          "source": "src/Language-TEval-TEvalNC.html#TEnv",
          "type": "type"
        },
        "index": {
          "description": "Type Environment associating types with free variables",
          "hierarchy": "Language TEval TEvalNC",
          "module": "Language.TEval.TEvalNC",
          "name": "TEnv",
          "package": "liboleg",
          "partial": "TEnv",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TEvalNC.html#t:TEnv"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TEval.TEvalNC",
          "name": "Term",
          "package": "liboleg",
          "source": "src/Language-TEval-TEvalNC.html#Term",
          "type": "data"
        },
        "index": {
          "hierarchy": "Language TEval TEvalNC",
          "module": "Language.TEval.TEvalNC",
          "name": "Term",
          "package": "liboleg",
          "partial": "Term",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TEvalNC.html#t:Term"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TEval.TEvalNC",
          "name": "Typ",
          "package": "liboleg",
          "source": "src/Language-TEval-TEvalNC.html#Typ",
          "type": "data"
        },
        "index": {
          "hierarchy": "Language TEval TEvalNC",
          "module": "Language.TEval.TEvalNC",
          "name": "Typ",
          "package": "liboleg",
          "partial": "Typ",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TEvalNC.html#t:Typ"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TEval.TEvalNC",
          "name": "VarName",
          "package": "liboleg",
          "source": "src/Language-TEval-TEvalNC.html#VarName",
          "type": "type"
        },
        "index": {
          "hierarchy": "Language TEval TEvalNC",
          "module": "Language.TEval.TEvalNC",
          "name": "VarName",
          "package": "liboleg",
          "partial": "Var Name",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TEvalNC.html#t:VarName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TEval.TEvalNC",
          "name": ":+",
          "package": "liboleg",
          "signature": "Term :+ Term",
          "source": "src/Language-TEval-TEvalNC.html#Term",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language TEval TEvalNC",
          "module": "Language.TEval.TEvalNC",
          "name": ":+",
          "package": "liboleg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TEvalNC.html#v::-43-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TEval.TEvalNC",
          "name": ":\u003e",
          "package": "liboleg",
          "signature": "Typ :\u003e !Typ",
          "source": "src/Language-TEval-TEvalNC.html#Typ",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language TEval TEvalNC",
          "module": "Language.TEval.TEvalNC",
          "name": ":\u003e",
          "package": "liboleg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TEvalNC.html#v::-62-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TEval.TEvalNC",
          "name": "A",
          "package": "liboleg",
          "signature": "A Term Term",
          "source": "src/Language-TEval-TEvalNC.html#Term",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language TEval TEvalNC",
          "module": "Language.TEval.TEvalNC",
          "name": "A",
          "package": "liboleg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TEvalNC.html#v:A"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TEval.TEvalNC",
          "name": "Fix",
          "package": "liboleg",
          "signature": "Fix Term",
          "source": "src/Language-TEval-TEvalNC.html#Term",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language TEval TEvalNC",
          "module": "Language.TEval.TEvalNC",
          "name": "Fix",
          "package": "liboleg",
          "partial": "Fix",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TEvalNC.html#v:Fix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TEval.TEvalNC",
          "name": "I",
          "package": "liboleg",
          "signature": "I Int",
          "source": "src/Language-TEval-TEvalNC.html#Term",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language TEval TEvalNC",
          "module": "Language.TEval.TEvalNC",
          "name": "I",
          "package": "liboleg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TEvalNC.html#v:I"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TEval.TEvalNC",
          "name": "IFZ",
          "package": "liboleg",
          "signature": "IFZ Term Term Term",
          "source": "src/Language-TEval-TEvalNC.html#Term",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language TEval TEvalNC",
          "module": "Language.TEval.TEvalNC",
          "name": "IFZ",
          "package": "liboleg",
          "partial": "IFZ",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TEvalNC.html#v:IFZ"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TEval.TEvalNC",
          "name": "L",
          "package": "liboleg",
          "signature": "L VarName Typ Term",
          "source": "src/Language-TEval-TEvalNC.html#Term",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language TEval TEvalNC",
          "module": "Language.TEval.TEvalNC",
          "name": "L",
          "package": "liboleg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TEvalNC.html#v:L"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TEval.TEvalNC",
          "name": "TInt",
          "package": "liboleg",
          "signature": "TInt",
          "source": "src/Language-TEval-TEvalNC.html#Typ",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language TEval TEvalNC",
          "module": "Language.TEval.TEvalNC",
          "name": "TInt",
          "package": "liboleg",
          "partial": "TInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TEvalNC.html#v:TInt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TEval.TEvalNC",
          "name": "V",
          "package": "liboleg",
          "signature": "V VarName",
          "source": "src/Language-TEval-TEvalNC.html#Term",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language TEval TEvalNC",
          "module": "Language.TEval.TEvalNC",
          "name": "V",
          "package": "liboleg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TEvalNC.html#v:V"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TEval.TEvalNC",
          "name": "env0",
          "package": "liboleg",
          "signature": "TEnv",
          "source": "src/Language-TEval-TEvalNC.html#env0",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language TEval TEvalNC",
          "module": "Language.TEval.TEvalNC",
          "name": "env0",
          "package": "liboleg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TEvalNC.html#v:env0"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TEval.TEvalNC",
          "name": "ext",
          "package": "liboleg",
          "signature": "TEnv -\u003e (VarName, Typ) -\u003e TEnv",
          "source": "src/Language-TEval-TEvalNC.html#ext",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language TEval TEvalNC",
          "module": "Language.TEval.TEvalNC",
          "name": "ext",
          "normalized": "TEnv-\u003e(VarName,Typ)-\u003eTEnv",
          "package": "liboleg",
          "signature": "TEnv-\u003e(VarName,Typ)-\u003eTEnv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TEvalNC.html#v:ext"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TEval.TEvalNC",
          "name": "lkup",
          "package": "liboleg",
          "signature": "TEnv -\u003e VarName -\u003e Typ",
          "source": "src/Language-TEval-TEvalNC.html#lkup",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language TEval TEvalNC",
          "module": "Language.TEval.TEvalNC",
          "name": "lkup",
          "normalized": "TEnv-\u003eVarName-\u003eTyp",
          "package": "liboleg",
          "signature": "TEnv-\u003eVarName-\u003eTyp",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TEvalNC.html#v:lkup"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eType reconstruction: abstract evaluation\n\u003c/p\u003e",
          "module": "Language.TEval.TEvalNC",
          "name": "teval",
          "package": "liboleg",
          "signature": "TEnv -\u003e Term -\u003e Typ",
          "source": "src/Language-TEval-TEvalNC.html#teval",
          "type": "function"
        },
        "index": {
          "description": "Type reconstruction abstract evaluation",
          "hierarchy": "Language TEval TEvalNC",
          "module": "Language.TEval.TEvalNC",
          "name": "teval",
          "normalized": "TEnv-\u003eTerm-\u003eTyp",
          "package": "liboleg",
          "signature": "TEnv-\u003eTerm-\u003eTyp",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TEvalNC.html#v:teval"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eSimply-typed Church-style (nominal) lambda-calculus\n with integers and zero-comparison\n Type reconstruction, for all subterms\n\u003c/p\u003e\u003cp\u003e\u003ca\u003ehttp://okmij.org/ftp/Computation/Computation.html#teval\u003c/a\u003e\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Language.TEval.TEvalNR",
          "name": "TEvalNR",
          "package": "liboleg",
          "source": "src/Language-TEval-TEvalNR.html",
          "type": "module"
        },
        "index": {
          "description": "Simply-typed Church-style nominal lambda-calculus with integers and zero-comparison Type reconstruction for all subterms http okmij.org ftp Computation Computation.html teval",
          "hierarchy": "Language TEval TEvalNR",
          "module": "Language.TEval.TEvalNR",
          "name": "TEvalNR",
          "package": "liboleg",
          "partial": "TEval NR",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TEvalNR.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eType Environment: associating types with \u003ccode\u003efree\u003c/code\u003e variables\n\u003c/p\u003e",
          "module": "Language.TEval.TEvalNR",
          "name": "TEnv",
          "package": "liboleg",
          "source": "src/Language-TEval-TEvalNR.html#TEnv",
          "type": "type"
        },
        "index": {
          "description": "Type Environment associating types with free variables",
          "hierarchy": "Language TEval TEvalNR",
          "module": "Language.TEval.TEvalNR",
          "name": "TEnv",
          "package": "liboleg",
          "partial": "TEnv",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TEvalNR.html#t:TEnv"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TEval.TEvalNR",
          "name": "Term",
          "package": "liboleg",
          "source": "src/Language-TEval-TEvalNR.html#Term",
          "type": "data"
        },
        "index": {
          "hierarchy": "Language TEval TEvalNR",
          "module": "Language.TEval.TEvalNR",
          "name": "Term",
          "package": "liboleg",
          "partial": "Term",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TEvalNR.html#t:Term"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA virtual typed AST: associating a type to each subterm\n\u003c/p\u003e",
          "module": "Language.TEval.TEvalNR",
          "name": "TermIndex",
          "package": "liboleg",
          "source": "src/Language-TEval-TEvalNR.html#TermIndex",
          "type": "type"
        },
        "index": {
          "description": "virtual typed AST associating type to each subterm",
          "hierarchy": "Language TEval TEvalNR",
          "module": "Language.TEval.TEvalNR",
          "name": "TermIndex",
          "package": "liboleg",
          "partial": "Term Index",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TEvalNR.html#t:TermIndex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TEval.TEvalNR",
          "name": "Typ",
          "package": "liboleg",
          "source": "src/Language-TEval-TEvalNR.html#Typ",
          "type": "data"
        },
        "index": {
          "hierarchy": "Language TEval TEvalNR",
          "module": "Language.TEval.TEvalNR",
          "name": "Typ",
          "package": "liboleg",
          "partial": "Typ",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TEvalNR.html#t:Typ"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TEval.TEvalNR",
          "name": "Typs",
          "package": "liboleg",
          "source": "src/Language-TEval-TEvalNR.html#Typs",
          "type": "type"
        },
        "index": {
          "hierarchy": "Language TEval TEvalNR",
          "module": "Language.TEval.TEvalNR",
          "name": "Typs",
          "package": "liboleg",
          "partial": "Typs",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TEvalNR.html#t:Typs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TEval.TEvalNR",
          "name": "VarName",
          "package": "liboleg",
          "source": "src/Language-TEval-TEvalNR.html#VarName",
          "type": "type"
        },
        "index": {
          "hierarchy": "Language TEval TEvalNR",
          "module": "Language.TEval.TEvalNR",
          "name": "VarName",
          "package": "liboleg",
          "partial": "Var Name",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TEvalNR.html#t:VarName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TEval.TEvalNR",
          "name": ":+",
          "package": "liboleg",
          "signature": "Term :+ Term",
          "source": "src/Language-TEval-TEvalNR.html#Term",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language TEval TEvalNR",
          "module": "Language.TEval.TEvalNR",
          "name": ":+",
          "package": "liboleg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TEvalNR.html#v::-43-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TEval.TEvalNR",
          "name": ":\u003e",
          "package": "liboleg",
          "signature": "Typ :\u003e !Typ",
          "source": "src/Language-TEval-TEvalNR.html#Typ",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language TEval TEvalNR",
          "module": "Language.TEval.TEvalNR",
          "name": ":\u003e",
          "package": "liboleg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TEvalNR.html#v::-62-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TEval.TEvalNR",
          "name": "A",
          "package": "liboleg",
          "signature": "A Term Term",
          "source": "src/Language-TEval-TEvalNR.html#Term",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language TEval TEvalNR",
          "module": "Language.TEval.TEvalNR",
          "name": "A",
          "package": "liboleg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TEvalNR.html#v:A"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TEval.TEvalNR",
          "name": "Fix",
          "package": "liboleg",
          "signature": "Fix Term",
          "source": "src/Language-TEval-TEvalNR.html#Term",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language TEval TEvalNR",
          "module": "Language.TEval.TEvalNR",
          "name": "Fix",
          "package": "liboleg",
          "partial": "Fix",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TEvalNR.html#v:Fix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TEval.TEvalNR",
          "name": "I",
          "package": "liboleg",
          "signature": "I Int",
          "source": "src/Language-TEval-TEvalNR.html#Term",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language TEval TEvalNR",
          "module": "Language.TEval.TEvalNR",
          "name": "I",
          "package": "liboleg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TEvalNR.html#v:I"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TEval.TEvalNR",
          "name": "IFZ",
          "package": "liboleg",
          "signature": "IFZ Term Term Term",
          "source": "src/Language-TEval-TEvalNR.html#Term",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language TEval TEvalNR",
          "module": "Language.TEval.TEvalNR",
          "name": "IFZ",
          "package": "liboleg",
          "partial": "IFZ",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TEvalNR.html#v:IFZ"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TEval.TEvalNR",
          "name": "L",
          "package": "liboleg",
          "signature": "L VarName Typ Term",
          "source": "src/Language-TEval-TEvalNR.html#Term",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language TEval TEvalNR",
          "module": "Language.TEval.TEvalNR",
          "name": "L",
          "package": "liboleg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TEvalNR.html#v:L"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TEval.TEvalNR",
          "name": "TInt",
          "package": "liboleg",
          "signature": "TInt",
          "source": "src/Language-TEval-TEvalNR.html#Typ",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language TEval TEvalNR",
          "module": "Language.TEval.TEvalNR",
          "name": "TInt",
          "package": "liboleg",
          "partial": "TInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TEvalNR.html#v:TInt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TEval.TEvalNR",
          "name": "V",
          "package": "liboleg",
          "signature": "V VarName",
          "source": "src/Language-TEval-TEvalNR.html#Term",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language TEval TEvalNR",
          "module": "Language.TEval.TEvalNR",
          "name": "V",
          "package": "liboleg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TEvalNR.html#v:V"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TEval.TEvalNR",
          "name": "env0",
          "package": "liboleg",
          "signature": "TEnv",
          "source": "src/Language-TEval-TEvalNR.html#env0",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language TEval TEvalNR",
          "module": "Language.TEval.TEvalNR",
          "name": "env0",
          "package": "liboleg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TEvalNR.html#v:env0"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TEval.TEvalNR",
          "name": "ext",
          "package": "liboleg",
          "signature": "TEnv -\u003e (VarName, Typ) -\u003e TEnv",
          "source": "src/Language-TEval-TEvalNR.html#ext",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language TEval TEvalNR",
          "module": "Language.TEval.TEvalNR",
          "name": "ext",
          "normalized": "TEnv-\u003e(VarName,Typ)-\u003eTEnv",
          "package": "liboleg",
          "signature": "TEnv-\u003e(VarName,Typ)-\u003eTEnv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TEvalNR.html#v:ext"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TEval.TEvalNR",
          "name": "lkup",
          "package": "liboleg",
          "signature": "TEnv -\u003e VarName -\u003e Typ",
          "source": "src/Language-TEval-TEvalNR.html#lkup",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language TEval TEvalNR",
          "module": "Language.TEval.TEvalNR",
          "name": "lkup",
          "normalized": "TEnv-\u003eVarName-\u003eTyp",
          "package": "liboleg",
          "signature": "TEnv-\u003eVarName-\u003eTyp",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TEvalNR.html#v:lkup"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TEval.TEvalNR",
          "name": "shift",
          "package": "liboleg",
          "signature": "Int -\u003e Typs -\u003e Typs",
          "source": "src/Language-TEval-TEvalNR.html#shift",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language TEval TEvalNR",
          "module": "Language.TEval.TEvalNR",
          "name": "shift",
          "normalized": "Int-\u003eTyps-\u003eTyps",
          "package": "liboleg",
          "signature": "Int-\u003eTyps-\u003eTyps",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TEvalNR.html#v:shift"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eType reconstruction: abstract evaluation\n\u003c/p\u003e",
          "module": "Language.TEval.TEvalNR",
          "name": "teval",
          "package": "liboleg",
          "signature": "TEnv -\u003e Term -\u003e Typs",
          "source": "src/Language-TEval-TEvalNR.html#teval",
          "type": "function"
        },
        "index": {
          "description": "Type reconstruction abstract evaluation",
          "hierarchy": "Language TEval TEvalNR",
          "module": "Language.TEval.TEvalNR",
          "name": "teval",
          "normalized": "TEnv-\u003eTerm-\u003eTyps",
          "package": "liboleg",
          "signature": "TEnv-\u003eTerm-\u003eTyps",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TEvalNR.html#v:teval"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TEval.TEvalNR",
          "name": "topterm",
          "package": "liboleg",
          "signature": "Typ -\u003e Typs",
          "source": "src/Language-TEval-TEvalNR.html#topterm",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language TEval TEvalNR",
          "module": "Language.TEval.TEvalNR",
          "name": "topterm",
          "normalized": "Typ-\u003eTyps",
          "package": "liboleg",
          "signature": "Typ-\u003eTyps",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TEvalNR.html#v:topterm"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TEval.TEvalNR",
          "name": "toptyp",
          "package": "liboleg",
          "signature": "Typs -\u003e Typ",
          "source": "src/Language-TEval-TEvalNR.html#toptyp",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language TEval TEvalNR",
          "module": "Language.TEval.TEvalNR",
          "name": "toptyp",
          "normalized": "Typs-\u003eTyp",
          "package": "liboleg",
          "signature": "Typs-\u003eTyp",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TEvalNR.html#v:toptyp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eSimply-typed Curry-style (nominal) lambda-calculus\n with integers and zero-comparison\n Let-polymorphism via inlining\n Type inference\n\u003c/p\u003e\u003cp\u003e\u003ca\u003ehttp://okmij.org/ftp/Computation/Computation.html#teval\u003c/a\u003e\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Language.TEval.TInfLetI",
          "name": "TInfLetI",
          "package": "liboleg",
          "source": "src/Language-TEval-TInfLetI.html",
          "type": "module"
        },
        "index": {
          "description": "Simply-typed Curry-style nominal lambda-calculus with integers and zero-comparison Let-polymorphism via inlining Type inference http okmij.org ftp Computation Computation.html teval",
          "hierarchy": "Language TEval TInfLetI",
          "module": "Language.TEval.TInfLetI",
          "name": "TInfLetI",
          "package": "liboleg",
          "partial": "TInf Let",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TInfLetI.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eType Environment: associating *would-be* types with \u003ccode\u003efree\u003c/code\u003e term variables\n\u003c/p\u003e",
          "module": "Language.TEval.TInfLetI",
          "name": "TEnv",
          "package": "liboleg",
          "source": "src/Language-TEval-TInfLetI.html#TEnv",
          "type": "type"
        },
        "index": {
          "description": "Type Environment associating would-be types with free term variables",
          "hierarchy": "Language TEval TInfLetI",
          "module": "Language.TEval.TInfLetI",
          "name": "TEnv",
          "package": "liboleg",
          "partial": "TEnv",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TInfLetI.html#t:TEnv"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eType Variable Environment: associating types with \u003ccode\u003efree\u003c/code\u003e type variables\n\u003c/p\u003e",
          "module": "Language.TEval.TInfLetI",
          "name": "TVE",
          "package": "liboleg",
          "source": "src/Language-TEval-TInfLetI.html#TVE",
          "type": "data"
        },
        "index": {
          "description": "Type Variable Environment associating types with free type variables",
          "hierarchy": "Language TEval TInfLetI",
          "module": "Language.TEval.TInfLetI",
          "name": "TVE",
          "package": "liboleg",
          "partial": "TVE",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TInfLetI.html#t:TVE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTVE is the state of a monadic computation\n\u003c/p\u003e",
          "module": "Language.TEval.TInfLetI",
          "name": "TVEM",
          "package": "liboleg",
          "source": "src/Language-TEval-TInfLetI.html#TVEM",
          "type": "type"
        },
        "index": {
          "description": "TVE is the state of monadic computation",
          "hierarchy": "Language TEval TInfLetI",
          "module": "Language.TEval.TInfLetI",
          "name": "TVEM",
          "package": "liboleg",
          "partial": "TVEM",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TInfLetI.html#t:TVEM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TEval.TInfLetI",
          "name": "TVarName",
          "package": "liboleg",
          "source": "src/Language-TEval-TInfLetI.html#TVarName",
          "type": "type"
        },
        "index": {
          "hierarchy": "Language TEval TInfLetI",
          "module": "Language.TEval.TInfLetI",
          "name": "TVarName",
          "package": "liboleg",
          "partial": "TVar Name",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TInfLetI.html#t:TVarName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TEval.TInfLetI",
          "name": "Term",
          "package": "liboleg",
          "source": "src/Language-TEval-TInfLetI.html#Term",
          "type": "data"
        },
        "index": {
          "hierarchy": "Language TEval TInfLetI",
          "module": "Language.TEval.TInfLetI",
          "name": "Term",
          "package": "liboleg",
          "partial": "Term",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TInfLetI.html#t:Term"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TEval.TInfLetI",
          "name": "Typ",
          "package": "liboleg",
          "source": "src/Language-TEval-TInfLetI.html#Typ",
          "type": "data"
        },
        "index": {
          "hierarchy": "Language TEval TInfLetI",
          "module": "Language.TEval.TInfLetI",
          "name": "Typ",
          "package": "liboleg",
          "partial": "Typ",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TInfLetI.html#t:Typ"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TEval.TInfLetI",
          "name": "VarName",
          "package": "liboleg",
          "source": "src/Language-TEval-TInfLetI.html#VarName",
          "type": "type"
        },
        "index": {
          "hierarchy": "Language TEval TInfLetI",
          "module": "Language.TEval.TInfLetI",
          "name": "VarName",
          "package": "liboleg",
          "partial": "Var Name",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TInfLetI.html#t:VarName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TEval.TInfLetI",
          "name": ":+",
          "package": "liboleg",
          "signature": "Term :+ Term",
          "source": "src/Language-TEval-TInfLetI.html#Term",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language TEval TInfLetI",
          "module": "Language.TEval.TInfLetI",
          "name": ":+",
          "package": "liboleg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TInfLetI.html#v::-43-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TEval.TInfLetI",
          "name": ":\u003e",
          "package": "liboleg",
          "signature": "Typ :\u003e !Typ",
          "source": "src/Language-TEval-TInfLetI.html#Typ",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language TEval TInfLetI",
          "module": "Language.TEval.TInfLetI",
          "name": ":\u003e",
          "package": "liboleg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TInfLetI.html#v::-62-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TEval.TInfLetI",
          "name": "A",
          "package": "liboleg",
          "signature": "A Term Term",
          "source": "src/Language-TEval-TInfLetI.html#Term",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language TEval TInfLetI",
          "module": "Language.TEval.TInfLetI",
          "name": "A",
          "package": "liboleg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TInfLetI.html#v:A"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TEval.TInfLetI",
          "name": "Fix",
          "package": "liboleg",
          "signature": "Fix Term",
          "source": "src/Language-TEval-TInfLetI.html#Term",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language TEval TInfLetI",
          "module": "Language.TEval.TInfLetI",
          "name": "Fix",
          "package": "liboleg",
          "partial": "Fix",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TInfLetI.html#v:Fix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TEval.TInfLetI",
          "name": "I",
          "package": "liboleg",
          "signature": "I Int",
          "source": "src/Language-TEval-TInfLetI.html#Term",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language TEval TInfLetI",
          "module": "Language.TEval.TInfLetI",
          "name": "I",
          "package": "liboleg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TInfLetI.html#v:I"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TEval.TInfLetI",
          "name": "IFZ",
          "package": "liboleg",
          "signature": "IFZ Term Term Term",
          "source": "src/Language-TEval-TInfLetI.html#Term",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language TEval TInfLetI",
          "module": "Language.TEval.TInfLetI",
          "name": "IFZ",
          "package": "liboleg",
          "partial": "IFZ",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TInfLetI.html#v:IFZ"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TEval.TInfLetI",
          "name": "L",
          "package": "liboleg",
          "signature": "L VarName Term",
          "source": "src/Language-TEval-TInfLetI.html#Term",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language TEval TInfLetI",
          "module": "Language.TEval.TInfLetI",
          "name": "L",
          "package": "liboleg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TInfLetI.html#v:L"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TEval.TInfLetI",
          "name": "Let",
          "package": "liboleg",
          "signature": "Let (VarName, Term) Term",
          "source": "src/Language-TEval-TInfLetI.html#Term",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language TEval TInfLetI",
          "module": "Language.TEval.TInfLetI",
          "name": "Let",
          "normalized": "Let(VarName,Term)Term",
          "package": "liboleg",
          "partial": "Let",
          "signature": "Let(VarName,Term)Term",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TInfLetI.html#v:Let"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TEval.TInfLetI",
          "name": "TInt",
          "package": "liboleg",
          "signature": "TInt",
          "source": "src/Language-TEval-TInfLetI.html#Typ",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language TEval TInfLetI",
          "module": "Language.TEval.TInfLetI",
          "name": "TInt",
          "package": "liboleg",
          "partial": "TInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TInfLetI.html#v:TInt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TEval.TInfLetI",
          "name": "TV",
          "package": "liboleg",
          "signature": "TV TVarName",
          "source": "src/Language-TEval-TInfLetI.html#Typ",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language TEval TInfLetI",
          "module": "Language.TEval.TInfLetI",
          "name": "TV",
          "package": "liboleg",
          "partial": "TV",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TInfLetI.html#v:TV"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TEval.TInfLetI",
          "name": "TVE",
          "package": "liboleg",
          "signature": "TVE Int (IntMap Typ)",
          "source": "src/Language-TEval-TInfLetI.html#TVE",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language TEval TInfLetI",
          "module": "Language.TEval.TInfLetI",
          "name": "TVE",
          "package": "liboleg",
          "partial": "TVE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TInfLetI.html#v:TVE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TEval.TInfLetI",
          "name": "V",
          "package": "liboleg",
          "signature": "V VarName",
          "source": "src/Language-TEval-TInfLetI.html#Term",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language TEval TInfLetI",
          "module": "Language.TEval.TInfLetI",
          "name": "V",
          "package": "liboleg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TInfLetI.html#v:V"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TEval.TInfLetI",
          "name": "env0",
          "package": "liboleg",
          "signature": "TEnv",
          "source": "src/Language-TEval-TInfLetI.html#env0",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language TEval TInfLetI",
          "module": "Language.TEval.TInfLetI",
          "name": "env0",
          "package": "liboleg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TInfLetI.html#v:env0"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TEval.TInfLetI",
          "name": "ext",
          "package": "liboleg",
          "signature": "TEnv -\u003e (VarName, TVEM Typ) -\u003e TEnv",
          "source": "src/Language-TEval-TInfLetI.html#ext",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language TEval TInfLetI",
          "module": "Language.TEval.TInfLetI",
          "name": "ext",
          "normalized": "TEnv-\u003e(VarName,TVEM Typ)-\u003eTEnv",
          "package": "liboleg",
          "signature": "TEnv-\u003e(VarName,TVEM Typ)-\u003eTEnv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TInfLetI.html#v:ext"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TEval.TInfLetI",
          "name": "lkup",
          "package": "liboleg",
          "signature": "TEnv -\u003e VarName -\u003e TVEM Typ",
          "source": "src/Language-TEval-TInfLetI.html#lkup",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language TEval TInfLetI",
          "module": "Language.TEval.TInfLetI",
          "name": "lkup",
          "normalized": "TEnv-\u003eVarName-\u003eTVEM Typ",
          "package": "liboleg",
          "signature": "TEnv-\u003eVarName-\u003eTVEM Typ",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TInfLetI.html#v:lkup"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAllocate a fresh type variable (see the first component of TVE)\n\u003c/p\u003e",
          "module": "Language.TEval.TInfLetI",
          "name": "newtv",
          "package": "liboleg",
          "signature": "TVEM Typ",
          "source": "src/Language-TEval-TInfLetI.html#newtv",
          "type": "function"
        },
        "index": {
          "description": "Allocate fresh type variable see the first component of TVE",
          "hierarchy": "Language TEval TInfLetI",
          "module": "Language.TEval.TInfLetI",
          "name": "newtv",
          "package": "liboleg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TInfLetI.html#v:newtv"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe occurs check: if v appears free in t\n\u003c/p\u003e",
          "module": "Language.TEval.TInfLetI",
          "name": "occurs",
          "package": "liboleg",
          "signature": "TVarName -\u003e Typ -\u003e TVE -\u003e Bool",
          "source": "src/Language-TEval-TInfLetI.html#occurs",
          "type": "function"
        },
        "index": {
          "description": "The occurs check if appears free in",
          "hierarchy": "Language TEval TInfLetI",
          "module": "Language.TEval.TInfLetI",
          "name": "occurs",
          "normalized": "TVarName-\u003eTyp-\u003eTVE-\u003eBool",
          "package": "liboleg",
          "signature": "TVarName-\u003eTyp-\u003eTVE-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TInfLetI.html#v:occurs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eResolve all type variables, as far as possible\n\u003c/p\u003e",
          "module": "Language.TEval.TInfLetI",
          "name": "teval",
          "package": "liboleg",
          "signature": "TEnv -\u003e Term -\u003e Typ",
          "source": "src/Language-TEval-TInfLetI.html#teval",
          "type": "function"
        },
        "index": {
          "description": "Resolve all type variables as far as possible",
          "hierarchy": "Language TEval TInfLetI",
          "module": "Language.TEval.TInfLetI",
          "name": "teval",
          "normalized": "TEnv-\u003eTerm-\u003eTyp",
          "package": "liboleg",
          "signature": "TEnv-\u003eTerm-\u003eTyp",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TInfLetI.html#v:teval"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eType reconstruction: abstract evaluation\n\u003c/p\u003e",
          "module": "Language.TEval.TInfLetI",
          "name": "teval'",
          "package": "liboleg",
          "signature": "TEnv -\u003e Term -\u003e TVEM Typ",
          "source": "src/Language-TEval-TInfLetI.html#teval%27",
          "type": "function"
        },
        "index": {
          "description": "Type reconstruction abstract evaluation",
          "hierarchy": "Language TEval TInfLetI",
          "module": "Language.TEval.TInfLetI",
          "name": "teval'",
          "normalized": "TEnv-\u003eTerm-\u003eTVEM Typ",
          "package": "liboleg",
          "signature": "TEnv-\u003eTerm-\u003eTVEM Typ",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TInfLetI.html#v:teval-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eshallow\u003c/code\u003e substitution; check if tv is bound to anything \u003ccode\u003esubstantial\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Language.TEval.TInfLetI",
          "name": "tvchase",
          "package": "liboleg",
          "signature": "TVE -\u003e Typ -\u003e Typ",
          "source": "src/Language-TEval-TInfLetI.html#tvchase",
          "type": "function"
        },
        "index": {
          "description": "shallow substitution check if tv is bound to anything substantial",
          "hierarchy": "Language TEval TInfLetI",
          "module": "Language.TEval.TInfLetI",
          "name": "tvchase",
          "normalized": "TVE-\u003eTyp-\u003eTyp",
          "package": "liboleg",
          "signature": "TVE-\u003eTyp-\u003eTyp",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TInfLetI.html#v:tvchase"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TEval.TInfLetI",
          "name": "tve0",
          "package": "liboleg",
          "signature": "TVE",
          "source": "src/Language-TEval-TInfLetI.html#tve0",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language TEval TInfLetI",
          "module": "Language.TEval.TInfLetI",
          "name": "tve0",
          "package": "liboleg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TInfLetI.html#v:tve0"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TEval.TInfLetI",
          "name": "tvext",
          "package": "liboleg",
          "signature": "TVE -\u003e (TVarName, Typ) -\u003e TVE",
          "source": "src/Language-TEval-TInfLetI.html#tvext",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language TEval TInfLetI",
          "module": "Language.TEval.TInfLetI",
          "name": "tvext",
          "normalized": "TVE-\u003e(TVarName,Typ)-\u003eTVE",
          "package": "liboleg",
          "signature": "TVE-\u003e(TVarName,Typ)-\u003eTVE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TInfLetI.html#v:tvext"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TEval.TInfLetI",
          "name": "tvlkup",
          "package": "liboleg",
          "signature": "TVE -\u003e TVarName -\u003e Maybe Typ",
          "source": "src/Language-TEval-TInfLetI.html#tvlkup",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language TEval TInfLetI",
          "module": "Language.TEval.TInfLetI",
          "name": "tvlkup",
          "normalized": "TVE-\u003eTVarName-\u003eMaybe Typ",
          "package": "liboleg",
          "signature": "TVE-\u003eTVarName-\u003eMaybe Typ",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TInfLetI.html#v:tvlkup"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eType variables are logic variables: hypothetical reasoning\n\u003c/p\u003e",
          "module": "Language.TEval.TInfLetI",
          "name": "tvsub",
          "package": "liboleg",
          "signature": "TVE -\u003e Typ -\u003e Typ",
          "source": "src/Language-TEval-TInfLetI.html#tvsub",
          "type": "function"
        },
        "index": {
          "description": "Type variables are logic variables hypothetical reasoning",
          "hierarchy": "Language TEval TInfLetI",
          "module": "Language.TEval.TInfLetI",
          "name": "tvsub",
          "normalized": "TVE-\u003eTyp-\u003eTyp",
          "package": "liboleg",
          "signature": "TVE-\u003eTyp-\u003eTyp",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TInfLetI.html#v:tvsub"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe unification. If unification failed, return the reason\n\u003c/p\u003e",
          "module": "Language.TEval.TInfLetI",
          "name": "unify",
          "package": "liboleg",
          "signature": "Typ -\u003e Typ -\u003e TVE -\u003e Either String TVE",
          "source": "src/Language-TEval-TInfLetI.html#unify",
          "type": "function"
        },
        "index": {
          "description": "The unification If unification failed return the reason",
          "hierarchy": "Language TEval TInfLetI",
          "module": "Language.TEval.TInfLetI",
          "name": "unify",
          "normalized": "Typ-\u003eTyp-\u003eTVE-\u003eEither String TVE",
          "package": "liboleg",
          "signature": "Typ-\u003eTyp-\u003eTVE-\u003eEither String TVE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TInfLetI.html#v:unify"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIf either t1 or t2 are type variables, they are definitely unbound\n\u003c/p\u003e",
          "module": "Language.TEval.TInfLetI",
          "name": "unify'",
          "package": "liboleg",
          "signature": "Typ -\u003e Typ -\u003e TVE -\u003e Either String TVE",
          "source": "src/Language-TEval-TInfLetI.html#unify%27",
          "type": "function"
        },
        "index": {
          "description": "If either t1 or t2 are type variables they are definitely unbound",
          "hierarchy": "Language TEval TInfLetI",
          "module": "Language.TEval.TInfLetI",
          "name": "unify'",
          "normalized": "Typ-\u003eTyp-\u003eTVE-\u003eEither String TVE",
          "package": "liboleg",
          "signature": "Typ-\u003eTyp-\u003eTVE-\u003eEither String TVE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TInfLetI.html#v:unify-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMonadic version of unify\n\u003c/p\u003e",
          "module": "Language.TEval.TInfLetI",
          "name": "unifyM",
          "package": "liboleg",
          "signature": "Typ -\u003e Typ -\u003e (String -\u003e String) -\u003e TVEM ()",
          "source": "src/Language-TEval-TInfLetI.html#unifyM",
          "type": "function"
        },
        "index": {
          "description": "Monadic version of unify",
          "hierarchy": "Language TEval TInfLetI",
          "module": "Language.TEval.TInfLetI",
          "name": "unifyM",
          "normalized": "Typ-\u003eTyp-\u003e(String-\u003eString)-\u003eTVEM()",
          "package": "liboleg",
          "signature": "Typ-\u003eTyp-\u003e(String-\u003eString)-\u003eTVEM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TInfLetI.html#v:unifyM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUnify a free variable v1 with t2\n\u003c/p\u003e",
          "module": "Language.TEval.TInfLetI",
          "name": "unifyv",
          "package": "liboleg",
          "signature": "TVarName -\u003e Typ -\u003e TVE -\u003e Either String TVE",
          "source": "src/Language-TEval-TInfLetI.html#unifyv",
          "type": "function"
        },
        "index": {
          "description": "Unify free variable v1 with t2",
          "hierarchy": "Language TEval TInfLetI",
          "module": "Language.TEval.TInfLetI",
          "name": "unifyv",
          "normalized": "TVarName-\u003eTyp-\u003eTVE-\u003eEither String TVE",
          "package": "liboleg",
          "signature": "TVarName-\u003eTyp-\u003eTVE-\u003eEither String TVE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TInfLetI.html#v:unifyv"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eSimply-typed Curry-style (nominal) lambda-calculus\n with integers and zero-comparison\n Let-polymorphism via type schemes\n Type inference\n\u003c/p\u003e\u003cp\u003e\u003ca\u003ehttp://okmij.org/ftp/Computation/Computation.html#teval\u003c/a\u003e\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Language.TEval.TInfLetP",
          "name": "TInfLetP",
          "package": "liboleg",
          "source": "src/Language-TEval-TInfLetP.html",
          "type": "module"
        },
        "index": {
          "description": "Simply-typed Curry-style nominal lambda-calculus with integers and zero-comparison Let-polymorphism via type schemes Type inference http okmij.org ftp Computation Computation.html teval",
          "hierarchy": "Language TEval TInfLetP",
          "module": "Language.TEval.TInfLetP",
          "name": "TInfLetP",
          "package": "liboleg",
          "partial": "TInf Let",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TInfLetP.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eType Environment: associating *would-be* types with \u003ccode\u003efree\u003c/code\u003e term variables\n\u003c/p\u003e",
          "module": "Language.TEval.TInfLetP",
          "name": "TEnv",
          "package": "liboleg",
          "source": "src/Language-TEval-TInfLetP.html#TEnv",
          "type": "type"
        },
        "index": {
          "description": "Type Environment associating would-be types with free term variables",
          "hierarchy": "Language TEval TInfLetP",
          "module": "Language.TEval.TInfLetP",
          "name": "TEnv",
          "package": "liboleg",
          "partial": "TEnv",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TInfLetP.html#t:TEnv"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eType Variable Environment: associating types with \u003ccode\u003efree\u003c/code\u003e type variables\n\u003c/p\u003e",
          "module": "Language.TEval.TInfLetP",
          "name": "TVE",
          "package": "liboleg",
          "source": "src/Language-TEval-TInfLetP.html#TVE",
          "type": "data"
        },
        "index": {
          "description": "Type Variable Environment associating types with free type variables",
          "hierarchy": "Language TEval TInfLetP",
          "module": "Language.TEval.TInfLetP",
          "name": "TVE",
          "package": "liboleg",
          "partial": "TVE",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TInfLetP.html#t:TVE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTVE is the state of a monadic computation\n\u003c/p\u003e",
          "module": "Language.TEval.TInfLetP",
          "name": "TVEM",
          "package": "liboleg",
          "source": "src/Language-TEval-TInfLetP.html#TVEM",
          "type": "type"
        },
        "index": {
          "description": "TVE is the state of monadic computation",
          "hierarchy": "Language TEval TInfLetP",
          "module": "Language.TEval.TInfLetP",
          "name": "TVEM",
          "package": "liboleg",
          "partial": "TVEM",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TInfLetP.html#t:TVEM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TEval.TInfLetP",
          "name": "TVarName",
          "package": "liboleg",
          "source": "src/Language-TEval-TInfLetP.html#TVarName",
          "type": "type"
        },
        "index": {
          "hierarchy": "Language TEval TInfLetP",
          "module": "Language.TEval.TInfLetP",
          "name": "TVarName",
          "package": "liboleg",
          "partial": "TVar Name",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TInfLetP.html#t:TVarName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TEval.TInfLetP",
          "name": "Term",
          "package": "liboleg",
          "source": "src/Language-TEval-TInfLetP.html#Term",
          "type": "data"
        },
        "index": {
          "hierarchy": "Language TEval TInfLetP",
          "module": "Language.TEval.TInfLetP",
          "name": "Term",
          "package": "liboleg",
          "partial": "Term",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TInfLetP.html#t:Term"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TEval.TInfLetP",
          "name": "Typ",
          "package": "liboleg",
          "source": "src/Language-TEval-TInfLetP.html#Typ",
          "type": "data"
        },
        "index": {
          "hierarchy": "Language TEval TInfLetP",
          "module": "Language.TEval.TInfLetP",
          "name": "Typ",
          "package": "liboleg",
          "partial": "Typ",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TInfLetP.html#t:Typ"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TEval.TInfLetP",
          "name": "TypS",
          "package": "liboleg",
          "source": "src/Language-TEval-TInfLetP.html#TypS",
          "type": "data"
        },
        "index": {
          "hierarchy": "Language TEval TInfLetP",
          "module": "Language.TEval.TInfLetP",
          "name": "TypS",
          "package": "liboleg",
          "partial": "Typ",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TInfLetP.html#t:TypS"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TEval.TInfLetP",
          "name": "VarName",
          "package": "liboleg",
          "source": "src/Language-TEval-TInfLetP.html#VarName",
          "type": "type"
        },
        "index": {
          "hierarchy": "Language TEval TInfLetP",
          "module": "Language.TEval.TInfLetP",
          "name": "VarName",
          "package": "liboleg",
          "partial": "Var Name",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TInfLetP.html#t:VarName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TEval.TInfLetP",
          "name": ":+",
          "package": "liboleg",
          "signature": "Term :+ Term",
          "source": "src/Language-TEval-TInfLetP.html#Term",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language TEval TInfLetP",
          "module": "Language.TEval.TInfLetP",
          "name": ":+",
          "package": "liboleg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TInfLetP.html#v::-43-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TEval.TInfLetP",
          "name": ":\u003e",
          "package": "liboleg",
          "signature": "Typ :\u003e !Typ",
          "source": "src/Language-TEval-TInfLetP.html#Typ",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language TEval TInfLetP",
          "module": "Language.TEval.TInfLetP",
          "name": ":\u003e",
          "package": "liboleg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TInfLetP.html#v::-62-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TEval.TInfLetP",
          "name": "A",
          "package": "liboleg",
          "signature": "A Term Term",
          "source": "src/Language-TEval-TInfLetP.html#Term",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language TEval TInfLetP",
          "module": "Language.TEval.TInfLetP",
          "name": "A",
          "package": "liboleg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TInfLetP.html#v:A"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TEval.TInfLetP",
          "name": "Fix",
          "package": "liboleg",
          "signature": "Fix Term",
          "source": "src/Language-TEval-TInfLetP.html#Term",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language TEval TInfLetP",
          "module": "Language.TEval.TInfLetP",
          "name": "Fix",
          "package": "liboleg",
          "partial": "Fix",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TInfLetP.html#v:Fix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TEval.TInfLetP",
          "name": "I",
          "package": "liboleg",
          "signature": "I Int",
          "source": "src/Language-TEval-TInfLetP.html#Term",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language TEval TInfLetP",
          "module": "Language.TEval.TInfLetP",
          "name": "I",
          "package": "liboleg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TInfLetP.html#v:I"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TEval.TInfLetP",
          "name": "IFZ",
          "package": "liboleg",
          "signature": "IFZ Term Term Term",
          "source": "src/Language-TEval-TInfLetP.html#Term",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language TEval TInfLetP",
          "module": "Language.TEval.TInfLetP",
          "name": "IFZ",
          "package": "liboleg",
          "partial": "IFZ",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TInfLetP.html#v:IFZ"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TEval.TInfLetP",
          "name": "L",
          "package": "liboleg",
          "signature": "L VarName Term",
          "source": "src/Language-TEval-TInfLetP.html#Term",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language TEval TInfLetP",
          "module": "Language.TEval.TInfLetP",
          "name": "L",
          "package": "liboleg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TInfLetP.html#v:L"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TEval.TInfLetP",
          "name": "Let",
          "package": "liboleg",
          "signature": "Let (VarName, Term) Term",
          "source": "src/Language-TEval-TInfLetP.html#Term",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language TEval TInfLetP",
          "module": "Language.TEval.TInfLetP",
          "name": "Let",
          "normalized": "Let(VarName,Term)Term",
          "package": "liboleg",
          "partial": "Let",
          "signature": "Let(VarName,Term)Term",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TInfLetP.html#v:Let"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TEval.TInfLetP",
          "name": "TInt",
          "package": "liboleg",
          "signature": "TInt",
          "source": "src/Language-TEval-TInfLetP.html#Typ",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language TEval TInfLetP",
          "module": "Language.TEval.TInfLetP",
          "name": "TInt",
          "package": "liboleg",
          "partial": "TInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TInfLetP.html#v:TInt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TEval.TInfLetP",
          "name": "TV",
          "package": "liboleg",
          "signature": "TV TVarName",
          "source": "src/Language-TEval-TInfLetP.html#Typ",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language TEval TInfLetP",
          "module": "Language.TEval.TInfLetP",
          "name": "TV",
          "package": "liboleg",
          "partial": "TV",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TInfLetP.html#v:TV"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TEval.TInfLetP",
          "name": "TVE",
          "package": "liboleg",
          "signature": "TVE Int (IntMap Typ)",
          "source": "src/Language-TEval-TInfLetP.html#TVE",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language TEval TInfLetP",
          "module": "Language.TEval.TInfLetP",
          "name": "TVE",
          "package": "liboleg",
          "partial": "TVE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TInfLetP.html#v:TVE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TEval.TInfLetP",
          "name": "TypS",
          "package": "liboleg",
          "signature": "TypS [TVarName] Typ",
          "source": "src/Language-TEval-TInfLetP.html#TypS",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language TEval TInfLetP",
          "module": "Language.TEval.TInfLetP",
          "name": "TypS",
          "normalized": "TypS[TVarName]Typ",
          "package": "liboleg",
          "partial": "Typ",
          "signature": "TypS[TVarName]Typ",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TInfLetP.html#v:TypS"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TEval.TInfLetP",
          "name": "V",
          "package": "liboleg",
          "signature": "V VarName",
          "source": "src/Language-TEval-TInfLetP.html#Term",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language TEval TInfLetP",
          "module": "Language.TEval.TInfLetP",
          "name": "V",
          "package": "liboleg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TInfLetP.html#v:V"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TEval.TInfLetP",
          "name": "env0",
          "package": "liboleg",
          "signature": "TEnv",
          "source": "src/Language-TEval-TInfLetP.html#env0",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language TEval TInfLetP",
          "module": "Language.TEval.TInfLetP",
          "name": "env0",
          "package": "liboleg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TInfLetP.html#v:env0"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TEval.TInfLetP",
          "name": "ext",
          "package": "liboleg",
          "signature": "TEnv -\u003e (VarName, TypS) -\u003e TEnv",
          "source": "src/Language-TEval-TInfLetP.html#ext",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language TEval TInfLetP",
          "module": "Language.TEval.TInfLetP",
          "name": "ext",
          "normalized": "TEnv-\u003e(VarName,TypS)-\u003eTEnv",
          "package": "liboleg",
          "signature": "TEnv-\u003e(VarName,TypS)-\u003eTEnv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TInfLetP.html#v:ext"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn the list of type variables in t (possibly with duplicates)\n\u003c/p\u003e",
          "module": "Language.TEval.TInfLetP",
          "name": "freevars",
          "package": "liboleg",
          "signature": "Typ -\u003e [TVarName]",
          "source": "src/Language-TEval-TInfLetP.html#freevars",
          "type": "function"
        },
        "index": {
          "description": "Return the list of type variables in possibly with duplicates",
          "hierarchy": "Language TEval TInfLetP",
          "module": "Language.TEval.TInfLetP",
          "name": "freevars",
          "normalized": "Typ-\u003e[TVarName]",
          "package": "liboleg",
          "signature": "Typ-\u003e[TVarName]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TInfLetP.html#v:freevars"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGiven a typechecking action ta yielding the type t, return the type\n scheme quantifying over _truly free_ type variables in t\n with respect to TVE that existed before the typechecking action began.\n Let tve_before is TVE before the type checking action is executed, \n and tve_after is TVE after the action. A type variable tv\n is truly free if it is free in tve_after and remains free if the \n typechecking action were executed in any tve extending tve_before\n with arbitrary binding to type variables free in tve_before.\n To be more precise, a type variable tv is truly free with respect\n to tve_before if:\n    tv notin domain(tve_after)\n    forall tvb in fv(tve_before). tv notin fv(tvsub(tve_after,tvb))\n In other words, tv is truly free if it is free and \u003ccode\u003eindependent\u003c/code\u003e of\n tve_before.\n\u003c/p\u003e\u003cp\u003eOur goal is to reproduce the behavior in TInfLetI.hs:\n generalize/instantiate should mimic multiple executions of\n the typechecking action. That means we should quantify over all\n type variables created by ta that are independent of the type environment\n in which the action may be executed.\n\u003c/p\u003e",
          "module": "Language.TEval.TInfLetP",
          "name": "generalize",
          "package": "liboleg",
          "signature": "TVEM Typ -\u003e TVEM TypS",
          "source": "src/Language-TEval-TInfLetP.html#generalize",
          "type": "function"
        },
        "index": {
          "description": "Given typechecking action ta yielding the type return the type scheme quantifying over truly free type variables in with respect to TVE that existed before the typechecking action began Let tve before is TVE before the type checking action is executed and tve after is TVE after the action type variable tv is truly free if it is free in tve after and remains free if the typechecking action were executed in any tve extending tve before with arbitrary binding to type variables free in tve before To be more precise type variable tv is truly free with respect to tve before if tv notin domain tve after forall tvb in fv tve before tv notin fv tvsub tve after tvb In other words tv is truly free if it is free and independent of tve before Our goal is to reproduce the behavior in TInfLetI.hs generalize instantiate should mimic multiple executions of the typechecking action That means we should quantify over all type variables created by ta that are independent of the type environment in which the action may be executed",
          "hierarchy": "Language TEval TInfLetP",
          "module": "Language.TEval.TInfLetP",
          "name": "generalize",
          "normalized": "TVEM Typ-\u003eTVEM TypS",
          "package": "liboleg",
          "signature": "TVEM Typ-\u003eTVEM TypS",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TInfLetP.html#v:generalize"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGiven a type scheme, that is, the type t and the list of type variables tvs,\n for every tvs, replace all of its occurrences in t with a fresh\n type variable.\n We do that by creating a substitution tve and applying it to t.\n\u003c/p\u003e",
          "module": "Language.TEval.TInfLetP",
          "name": "instantiate",
          "package": "liboleg",
          "signature": "TypS -\u003e TVEM Typ",
          "source": "src/Language-TEval-TInfLetP.html#instantiate",
          "type": "function"
        },
        "index": {
          "description": "Given type scheme that is the type and the list of type variables tvs for every tvs replace all of its occurrences in with fresh type variable We do that by creating substitution tve and applying it to",
          "hierarchy": "Language TEval TInfLetP",
          "module": "Language.TEval.TInfLetP",
          "name": "instantiate",
          "normalized": "TypS-\u003eTVEM Typ",
          "package": "liboleg",
          "signature": "TypS-\u003eTVEM Typ",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TInfLetP.html#v:instantiate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TEval.TInfLetP",
          "name": "lkup",
          "package": "liboleg",
          "signature": "TEnv -\u003e VarName -\u003e TypS",
          "source": "src/Language-TEval-TInfLetP.html#lkup",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language TEval TInfLetP",
          "module": "Language.TEval.TInfLetP",
          "name": "lkup",
          "normalized": "TEnv-\u003eVarName-\u003eTypS",
          "package": "liboleg",
          "signature": "TEnv-\u003eVarName-\u003eTypS",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TInfLetP.html#v:lkup"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAllocate a fresh type variable (see the first component of TVE)\n\u003c/p\u003e",
          "module": "Language.TEval.TInfLetP",
          "name": "newtv",
          "package": "liboleg",
          "signature": "TVEM Typ",
          "source": "src/Language-TEval-TInfLetP.html#newtv",
          "type": "function"
        },
        "index": {
          "description": "Allocate fresh type variable see the first component of TVE",
          "hierarchy": "Language TEval TInfLetP",
          "module": "Language.TEval.TInfLetP",
          "name": "newtv",
          "package": "liboleg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TInfLetP.html#v:newtv"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe occurs check: if v appears free in t\n\u003c/p\u003e",
          "module": "Language.TEval.TInfLetP",
          "name": "occurs",
          "package": "liboleg",
          "signature": "TVarName -\u003e Typ -\u003e TVE -\u003e Bool",
          "source": "src/Language-TEval-TInfLetP.html#occurs",
          "type": "function"
        },
        "index": {
          "description": "The occurs check if appears free in",
          "hierarchy": "Language TEval TInfLetP",
          "module": "Language.TEval.TInfLetP",
          "name": "occurs",
          "normalized": "TVarName-\u003eTyp-\u003eTVE-\u003eBool",
          "package": "liboleg",
          "signature": "TVarName-\u003eTyp-\u003eTVE-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TInfLetP.html#v:occurs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eResolve all type variables, as far as possible, and generalize\n We assume teval will be used for top-level expressions where generalization\n is appropriate.\n\u003c/p\u003e",
          "module": "Language.TEval.TInfLetP",
          "name": "teval",
          "package": "liboleg",
          "signature": "TEnv -\u003e Term -\u003e TypS",
          "source": "src/Language-TEval-TInfLetP.html#teval",
          "type": "function"
        },
        "index": {
          "description": "Resolve all type variables as far as possible and generalize We assume teval will be used for top-level expressions where generalization is appropriate",
          "hierarchy": "Language TEval TInfLetP",
          "module": "Language.TEval.TInfLetP",
          "name": "teval",
          "normalized": "TEnv-\u003eTerm-\u003eTypS",
          "package": "liboleg",
          "signature": "TEnv-\u003eTerm-\u003eTypS",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TInfLetP.html#v:teval"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eType reconstruction: abstract evaluation\n\u003c/p\u003e",
          "module": "Language.TEval.TInfLetP",
          "name": "teval'",
          "package": "liboleg",
          "signature": "TEnv -\u003e Term -\u003e TVEM Typ",
          "source": "src/Language-TEval-TInfLetP.html#teval%27",
          "type": "function"
        },
        "index": {
          "description": "Type reconstruction abstract evaluation",
          "hierarchy": "Language TEval TInfLetP",
          "module": "Language.TEval.TInfLetP",
          "name": "teval'",
          "normalized": "TEnv-\u003eTerm-\u003eTVEM Typ",
          "package": "liboleg",
          "signature": "TEnv-\u003eTerm-\u003eTVEM Typ",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TInfLetP.html#v:teval-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003enon-generalizing teval (as before)\n\u003c/p\u003e",
          "module": "Language.TEval.TInfLetP",
          "name": "tevalng",
          "package": "liboleg",
          "signature": "TEnv -\u003e Term -\u003e Typ",
          "source": "src/Language-TEval-TInfLetP.html#tevalng",
          "type": "function"
        },
        "index": {
          "description": "non-generalizing teval as before",
          "hierarchy": "Language TEval TInfLetP",
          "module": "Language.TEval.TInfLetP",
          "name": "tevalng",
          "normalized": "TEnv-\u003eTerm-\u003eTyp",
          "package": "liboleg",
          "signature": "TEnv-\u003eTerm-\u003eTyp",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TInfLetP.html#v:tevalng"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eshallow\u003c/code\u003e substitution; check if tv is bound to anything \u003ccode\u003esubstantial\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Language.TEval.TInfLetP",
          "name": "tvchase",
          "package": "liboleg",
          "signature": "TVE -\u003e Typ -\u003e Typ",
          "source": "src/Language-TEval-TInfLetP.html#tvchase",
          "type": "function"
        },
        "index": {
          "description": "shallow substitution check if tv is bound to anything substantial",
          "hierarchy": "Language TEval TInfLetP",
          "module": "Language.TEval.TInfLetP",
          "name": "tvchase",
          "normalized": "TVE-\u003eTyp-\u003eTyp",
          "package": "liboleg",
          "signature": "TVE-\u003eTyp-\u003eTyp",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TInfLetP.html#v:tvchase"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCompute (quite unoptimally) the characteristic function of the set \n  forall tvb in fv(tve_before). Union fv(tvsub(tve_after,tvb))\n\u003c/p\u003e",
          "module": "Language.TEval.TInfLetP",
          "name": "tvdependentset",
          "package": "liboleg",
          "signature": "TVE -\u003e TVE -\u003e TVarName -\u003e Bool",
          "source": "src/Language-TEval-TInfLetP.html#tvdependentset",
          "type": "function"
        },
        "index": {
          "description": "Compute quite unoptimally the characteristic function of the set forall tvb in fv tve before Union fv tvsub tve after tvb",
          "hierarchy": "Language TEval TInfLetP",
          "module": "Language.TEval.TInfLetP",
          "name": "tvdependentset",
          "normalized": "TVE-\u003eTVE-\u003eTVarName-\u003eBool",
          "package": "liboleg",
          "signature": "TVE-\u003eTVE-\u003eTVarName-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TInfLetP.html#v:tvdependentset"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTVE domain predicate: check to see if a TVarName is in the domain of TVE\n\u003c/p\u003e",
          "module": "Language.TEval.TInfLetP",
          "name": "tvdomainp",
          "package": "liboleg",
          "signature": "TVE -\u003e TVarName -\u003e Bool",
          "source": "src/Language-TEval-TInfLetP.html#tvdomainp",
          "type": "function"
        },
        "index": {
          "description": "TVE domain predicate check to see if TVarName is in the domain of TVE",
          "hierarchy": "Language TEval TInfLetP",
          "module": "Language.TEval.TInfLetP",
          "name": "tvdomainp",
          "normalized": "TVE-\u003eTVarName-\u003eBool",
          "package": "liboleg",
          "signature": "TVE-\u003eTVarName-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TInfLetP.html#v:tvdomainp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TEval.TInfLetP",
          "name": "tve0",
          "package": "liboleg",
          "signature": "TVE",
          "source": "src/Language-TEval-TInfLetP.html#tve0",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language TEval TInfLetP",
          "module": "Language.TEval.TInfLetP",
          "name": "tve0",
          "package": "liboleg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TInfLetP.html#v:tve0"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TEval.TInfLetP",
          "name": "tvext",
          "package": "liboleg",
          "signature": "TVE -\u003e (TVarName, Typ) -\u003e TVE",
          "source": "src/Language-TEval-TInfLetP.html#tvext",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language TEval TInfLetP",
          "module": "Language.TEval.TInfLetP",
          "name": "tvext",
          "normalized": "TVE-\u003e(TVarName,Typ)-\u003eTVE",
          "package": "liboleg",
          "signature": "TVE-\u003e(TVarName,Typ)-\u003eTVE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TInfLetP.html#v:tvext"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGive the list of all type variables that are allocated in TVE but\n not bound there\n\u003c/p\u003e",
          "module": "Language.TEval.TInfLetP",
          "name": "tvfree",
          "package": "liboleg",
          "signature": "TVE -\u003e [TVarName]",
          "source": "src/Language-TEval-TInfLetP.html#tvfree",
          "type": "function"
        },
        "index": {
          "description": "Give the list of all type variables that are allocated in TVE but not bound there",
          "hierarchy": "Language TEval TInfLetP",
          "module": "Language.TEval.TInfLetP",
          "name": "tvfree",
          "normalized": "TVE-\u003e[TVarName]",
          "package": "liboleg",
          "signature": "TVE-\u003e[TVarName]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TInfLetP.html#v:tvfree"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TEval.TInfLetP",
          "name": "tvlkup",
          "package": "liboleg",
          "signature": "TVE -\u003e TVarName -\u003e Maybe Typ",
          "source": "src/Language-TEval-TInfLetP.html#tvlkup",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language TEval TInfLetP",
          "module": "Language.TEval.TInfLetP",
          "name": "tvlkup",
          "normalized": "TVE-\u003eTVarName-\u003eMaybe Typ",
          "package": "liboleg",
          "signature": "TVE-\u003eTVarName-\u003eMaybe Typ",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TInfLetP.html#v:tvlkup"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eType variables are logic variables: hypothetical reasoning\n\u003c/p\u003e",
          "module": "Language.TEval.TInfLetP",
          "name": "tvsub",
          "package": "liboleg",
          "signature": "TVE -\u003e Typ -\u003e Typ",
          "source": "src/Language-TEval-TInfLetP.html#tvsub",
          "type": "function"
        },
        "index": {
          "description": "Type variables are logic variables hypothetical reasoning",
          "hierarchy": "Language TEval TInfLetP",
          "module": "Language.TEval.TInfLetP",
          "name": "tvsub",
          "normalized": "TVE-\u003eTyp-\u003eTyp",
          "package": "liboleg",
          "signature": "TVE-\u003eTyp-\u003eTyp",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TInfLetP.html#v:tvsub"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe unification. If unification failed, return the reason\n\u003c/p\u003e",
          "module": "Language.TEval.TInfLetP",
          "name": "unify",
          "package": "liboleg",
          "signature": "Typ -\u003e Typ -\u003e TVE -\u003e Either String TVE",
          "source": "src/Language-TEval-TInfLetP.html#unify",
          "type": "function"
        },
        "index": {
          "description": "The unification If unification failed return the reason",
          "hierarchy": "Language TEval TInfLetP",
          "module": "Language.TEval.TInfLetP",
          "name": "unify",
          "normalized": "Typ-\u003eTyp-\u003eTVE-\u003eEither String TVE",
          "package": "liboleg",
          "signature": "Typ-\u003eTyp-\u003eTVE-\u003eEither String TVE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TInfLetP.html#v:unify"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIf either t1 or t2 are type variables, they are definitely unbound\n\u003c/p\u003e",
          "module": "Language.TEval.TInfLetP",
          "name": "unify'",
          "package": "liboleg",
          "signature": "Typ -\u003e Typ -\u003e TVE -\u003e Either String TVE",
          "source": "src/Language-TEval-TInfLetP.html#unify%27",
          "type": "function"
        },
        "index": {
          "description": "If either t1 or t2 are type variables they are definitely unbound",
          "hierarchy": "Language TEval TInfLetP",
          "module": "Language.TEval.TInfLetP",
          "name": "unify'",
          "normalized": "Typ-\u003eTyp-\u003eTVE-\u003eEither String TVE",
          "package": "liboleg",
          "signature": "Typ-\u003eTyp-\u003eTVE-\u003eEither String TVE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TInfLetP.html#v:unify-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMonadic version of unify\n\u003c/p\u003e",
          "module": "Language.TEval.TInfLetP",
          "name": "unifyM",
          "package": "liboleg",
          "signature": "Typ -\u003e Typ -\u003e (String -\u003e String) -\u003e TVEM ()",
          "source": "src/Language-TEval-TInfLetP.html#unifyM",
          "type": "function"
        },
        "index": {
          "description": "Monadic version of unify",
          "hierarchy": "Language TEval TInfLetP",
          "module": "Language.TEval.TInfLetP",
          "name": "unifyM",
          "normalized": "Typ-\u003eTyp-\u003e(String-\u003eString)-\u003eTVEM()",
          "package": "liboleg",
          "signature": "Typ-\u003eTyp-\u003e(String-\u003eString)-\u003eTVEM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TInfLetP.html#v:unifyM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUnify a free variable v1 with t2\n\u003c/p\u003e",
          "module": "Language.TEval.TInfLetP",
          "name": "unifyv",
          "package": "liboleg",
          "signature": "TVarName -\u003e Typ -\u003e TVE -\u003e Either String TVE",
          "source": "src/Language-TEval-TInfLetP.html#unifyv",
          "type": "function"
        },
        "index": {
          "description": "Unify free variable v1 with t2",
          "hierarchy": "Language TEval TInfLetP",
          "module": "Language.TEval.TInfLetP",
          "name": "unifyv",
          "normalized": "TVarName-\u003eTyp-\u003eTVE-\u003eEither String TVE",
          "package": "liboleg",
          "signature": "TVarName-\u003eTyp-\u003eTVE-\u003eEither String TVE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TInfLetP.html#v:unifyv"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eSimply-typed Curry-style (nominal) lambda-calculus\n with integers and zero-comparison\n Type inference\n\u003c/p\u003e\u003cp\u003e\u003ca\u003ehttp://okmij.org/ftp/Computation/Computation.html#teval\u003c/a\u003e\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Language.TEval.TInfT",
          "name": "TInfT",
          "package": "liboleg",
          "source": "src/Language-TEval-TInfT.html",
          "type": "module"
        },
        "index": {
          "description": "Simply-typed Curry-style nominal lambda-calculus with integers and zero-comparison Type inference http okmij.org ftp Computation Computation.html teval",
          "hierarchy": "Language TEval TInfT",
          "module": "Language.TEval.TInfT",
          "name": "TInfT",
          "package": "liboleg",
          "partial": "TInf",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TInfT.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eType Environment: associating types with \u003ccode\u003efree\u003c/code\u003e term variables\n\u003c/p\u003e",
          "module": "Language.TEval.TInfT",
          "name": "TEnv",
          "package": "liboleg",
          "source": "src/Language-TEval-TInfT.html#TEnv",
          "type": "type"
        },
        "index": {
          "description": "Type Environment associating types with free term variables",
          "hierarchy": "Language TEval TInfT",
          "module": "Language.TEval.TInfT",
          "name": "TEnv",
          "package": "liboleg",
          "partial": "TEnv",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TInfT.html#t:TEnv"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TEval.TInfT",
          "name": "TVE",
          "package": "liboleg",
          "source": "src/Language-TEval-TInfT.html#TVE",
          "type": "data"
        },
        "index": {
          "hierarchy": "Language TEval TInfT",
          "module": "Language.TEval.TInfT",
          "name": "TVE",
          "package": "liboleg",
          "partial": "TVE",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TInfT.html#t:TVE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TEval.TInfT",
          "name": "TVarName",
          "package": "liboleg",
          "source": "src/Language-TEval-TInfT.html#TVarName",
          "type": "type"
        },
        "index": {
          "hierarchy": "Language TEval TInfT",
          "module": "Language.TEval.TInfT",
          "name": "TVarName",
          "package": "liboleg",
          "partial": "TVar Name",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TInfT.html#t:TVarName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TEval.TInfT",
          "name": "Term",
          "package": "liboleg",
          "source": "src/Language-TEval-TInfT.html#Term",
          "type": "data"
        },
        "index": {
          "hierarchy": "Language TEval TInfT",
          "module": "Language.TEval.TInfT",
          "name": "Term",
          "package": "liboleg",
          "partial": "Term",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TInfT.html#t:Term"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TEval.TInfT",
          "name": "Typ",
          "package": "liboleg",
          "source": "src/Language-TEval-TInfT.html#Typ",
          "type": "data"
        },
        "index": {
          "hierarchy": "Language TEval TInfT",
          "module": "Language.TEval.TInfT",
          "name": "Typ",
          "package": "liboleg",
          "partial": "Typ",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TInfT.html#t:Typ"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TEval.TInfT",
          "name": "VarName",
          "package": "liboleg",
          "source": "src/Language-TEval-TInfT.html#VarName",
          "type": "type"
        },
        "index": {
          "hierarchy": "Language TEval TInfT",
          "module": "Language.TEval.TInfT",
          "name": "VarName",
          "package": "liboleg",
          "partial": "Var Name",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TInfT.html#t:VarName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TEval.TInfT",
          "name": ":+",
          "package": "liboleg",
          "signature": "Term :+ Term",
          "source": "src/Language-TEval-TInfT.html#Term",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language TEval TInfT",
          "module": "Language.TEval.TInfT",
          "name": ":+",
          "package": "liboleg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TInfT.html#v::-43-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TEval.TInfT",
          "name": ":\u003e",
          "package": "liboleg",
          "signature": "Typ :\u003e !Typ",
          "source": "src/Language-TEval-TInfT.html#Typ",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language TEval TInfT",
          "module": "Language.TEval.TInfT",
          "name": ":\u003e",
          "package": "liboleg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TInfT.html#v::-62-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TEval.TInfT",
          "name": "A",
          "package": "liboleg",
          "signature": "A Term Term",
          "source": "src/Language-TEval-TInfT.html#Term",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language TEval TInfT",
          "module": "Language.TEval.TInfT",
          "name": "A",
          "package": "liboleg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TInfT.html#v:A"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TEval.TInfT",
          "name": "Fix",
          "package": "liboleg",
          "signature": "Fix Term",
          "source": "src/Language-TEval-TInfT.html#Term",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language TEval TInfT",
          "module": "Language.TEval.TInfT",
          "name": "Fix",
          "package": "liboleg",
          "partial": "Fix",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TInfT.html#v:Fix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TEval.TInfT",
          "name": "I",
          "package": "liboleg",
          "signature": "I Int",
          "source": "src/Language-TEval-TInfT.html#Term",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language TEval TInfT",
          "module": "Language.TEval.TInfT",
          "name": "I",
          "package": "liboleg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TInfT.html#v:I"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TEval.TInfT",
          "name": "IFZ",
          "package": "liboleg",
          "signature": "IFZ Term Term Term",
          "source": "src/Language-TEval-TInfT.html#Term",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language TEval TInfT",
          "module": "Language.TEval.TInfT",
          "name": "IFZ",
          "package": "liboleg",
          "partial": "IFZ",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TInfT.html#v:IFZ"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TEval.TInfT",
          "name": "L",
          "package": "liboleg",
          "signature": "L VarName Term",
          "source": "src/Language-TEval-TInfT.html#Term",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language TEval TInfT",
          "module": "Language.TEval.TInfT",
          "name": "L",
          "package": "liboleg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TInfT.html#v:L"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TEval.TInfT",
          "name": "TInt",
          "package": "liboleg",
          "signature": "TInt",
          "source": "src/Language-TEval-TInfT.html#Typ",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language TEval TInfT",
          "module": "Language.TEval.TInfT",
          "name": "TInt",
          "package": "liboleg",
          "partial": "TInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TInfT.html#v:TInt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TEval.TInfT",
          "name": "TV",
          "package": "liboleg",
          "signature": "TV TVarName",
          "source": "src/Language-TEval-TInfT.html#Typ",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language TEval TInfT",
          "module": "Language.TEval.TInfT",
          "name": "TV",
          "package": "liboleg",
          "partial": "TV",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TInfT.html#v:TV"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TEval.TInfT",
          "name": "TVE",
          "package": "liboleg",
          "signature": "TVE Int (IntMap Typ)",
          "source": "src/Language-TEval-TInfT.html#TVE",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language TEval TInfT",
          "module": "Language.TEval.TInfT",
          "name": "TVE",
          "package": "liboleg",
          "partial": "TVE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TInfT.html#v:TVE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TEval.TInfT",
          "name": "V",
          "package": "liboleg",
          "signature": "V VarName",
          "source": "src/Language-TEval-TInfT.html#Term",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language TEval TInfT",
          "module": "Language.TEval.TInfT",
          "name": "V",
          "package": "liboleg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TInfT.html#v:V"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TEval.TInfT",
          "name": "env0",
          "package": "liboleg",
          "signature": "TEnv",
          "source": "src/Language-TEval-TInfT.html#env0",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language TEval TInfT",
          "module": "Language.TEval.TInfT",
          "name": "env0",
          "package": "liboleg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TInfT.html#v:env0"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TEval.TInfT",
          "name": "ext",
          "package": "liboleg",
          "signature": "TEnv -\u003e (VarName, Typ) -\u003e TEnv",
          "source": "src/Language-TEval-TInfT.html#ext",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language TEval TInfT",
          "module": "Language.TEval.TInfT",
          "name": "ext",
          "normalized": "TEnv-\u003e(VarName,Typ)-\u003eTEnv",
          "package": "liboleg",
          "signature": "TEnv-\u003e(VarName,Typ)-\u003eTEnv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TInfT.html#v:ext"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TEval.TInfT",
          "name": "lkup",
          "package": "liboleg",
          "signature": "TEnv -\u003e VarName -\u003e Typ",
          "source": "src/Language-TEval-TInfT.html#lkup",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language TEval TInfT",
          "module": "Language.TEval.TInfT",
          "name": "lkup",
          "normalized": "TEnv-\u003eVarName-\u003eTyp",
          "package": "liboleg",
          "signature": "TEnv-\u003eVarName-\u003eTyp",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TInfT.html#v:lkup"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TEval.TInfT",
          "name": "newtv",
          "package": "liboleg",
          "signature": "TVE -\u003e (Typ, TVE)",
          "source": "src/Language-TEval-TInfT.html#newtv",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language TEval TInfT",
          "module": "Language.TEval.TInfT",
          "name": "newtv",
          "normalized": "TVE-\u003e(Typ,TVE)",
          "package": "liboleg",
          "signature": "TVE-\u003e(Typ,TVE)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TInfT.html#v:newtv"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe occurs check: if v appears free in t\n\u003c/p\u003e",
          "module": "Language.TEval.TInfT",
          "name": "occurs",
          "package": "liboleg",
          "signature": "TVarName -\u003e Typ -\u003e TVE -\u003e Bool",
          "source": "src/Language-TEval-TInfT.html#occurs",
          "type": "function"
        },
        "index": {
          "description": "The occurs check if appears free in",
          "hierarchy": "Language TEval TInfT",
          "module": "Language.TEval.TInfT",
          "name": "occurs",
          "normalized": "TVarName-\u003eTyp-\u003eTVE-\u003eBool",
          "package": "liboleg",
          "signature": "TVarName-\u003eTyp-\u003eTVE-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TInfT.html#v:occurs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eResolve all type variables, as far as possible\n\u003c/p\u003e",
          "module": "Language.TEval.TInfT",
          "name": "teval",
          "package": "liboleg",
          "signature": "TEnv -\u003e Term -\u003e Typ",
          "source": "src/Language-TEval-TInfT.html#teval",
          "type": "function"
        },
        "index": {
          "description": "Resolve all type variables as far as possible",
          "hierarchy": "Language TEval TInfT",
          "module": "Language.TEval.TInfT",
          "name": "teval",
          "normalized": "TEnv-\u003eTerm-\u003eTyp",
          "package": "liboleg",
          "signature": "TEnv-\u003eTerm-\u003eTyp",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TInfT.html#v:teval"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eType reconstruction: abstract evaluation\n\u003c/p\u003e",
          "module": "Language.TEval.TInfT",
          "name": "teval'",
          "package": "liboleg",
          "signature": "TEnv -\u003e Term -\u003e TVE -\u003e (Typ, TVE)",
          "source": "src/Language-TEval-TInfT.html#teval%27",
          "type": "function"
        },
        "index": {
          "description": "Type reconstruction abstract evaluation",
          "hierarchy": "Language TEval TInfT",
          "module": "Language.TEval.TInfT",
          "name": "teval'",
          "normalized": "TEnv-\u003eTerm-\u003eTVE-\u003e(Typ,TVE)",
          "package": "liboleg",
          "signature": "TEnv-\u003eTerm-\u003eTVE-\u003e(Typ,TVE)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TInfT.html#v:teval-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eshallow\u003c/code\u003e substitution; check if tv is bound to anything \u003ccode\u003esubstantial\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Language.TEval.TInfT",
          "name": "tvchase",
          "package": "liboleg",
          "signature": "TVE -\u003e Typ -\u003e Typ",
          "source": "src/Language-TEval-TInfT.html#tvchase",
          "type": "function"
        },
        "index": {
          "description": "shallow substitution check if tv is bound to anything substantial",
          "hierarchy": "Language TEval TInfT",
          "module": "Language.TEval.TInfT",
          "name": "tvchase",
          "normalized": "TVE-\u003eTyp-\u003eTyp",
          "package": "liboleg",
          "signature": "TVE-\u003eTyp-\u003eTyp",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TInfT.html#v:tvchase"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TEval.TInfT",
          "name": "tve0",
          "package": "liboleg",
          "signature": "TVE",
          "source": "src/Language-TEval-TInfT.html#tve0",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language TEval TInfT",
          "module": "Language.TEval.TInfT",
          "name": "tve0",
          "package": "liboleg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TInfT.html#v:tve0"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TEval.TInfT",
          "name": "tvext",
          "package": "liboleg",
          "signature": "TVE -\u003e (TVarName, Typ) -\u003e TVE",
          "source": "src/Language-TEval-TInfT.html#tvext",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language TEval TInfT",
          "module": "Language.TEval.TInfT",
          "name": "tvext",
          "normalized": "TVE-\u003e(TVarName,Typ)-\u003eTVE",
          "package": "liboleg",
          "signature": "TVE-\u003e(TVarName,Typ)-\u003eTVE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TInfT.html#v:tvext"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TEval.TInfT",
          "name": "tvlkup",
          "package": "liboleg",
          "signature": "TVE -\u003e TVarName -\u003e Maybe Typ",
          "source": "src/Language-TEval-TInfT.html#tvlkup",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language TEval TInfT",
          "module": "Language.TEval.TInfT",
          "name": "tvlkup",
          "normalized": "TVE-\u003eTVarName-\u003eMaybe Typ",
          "package": "liboleg",
          "signature": "TVE-\u003eTVarName-\u003eMaybe Typ",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TInfT.html#v:tvlkup"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eType variables are logic variables: hypothetical reasoning\n\u003c/p\u003e",
          "module": "Language.TEval.TInfT",
          "name": "tvsub",
          "package": "liboleg",
          "signature": "TVE -\u003e Typ -\u003e Typ",
          "source": "src/Language-TEval-TInfT.html#tvsub",
          "type": "function"
        },
        "index": {
          "description": "Type variables are logic variables hypothetical reasoning",
          "hierarchy": "Language TEval TInfT",
          "module": "Language.TEval.TInfT",
          "name": "tvsub",
          "normalized": "TVE-\u003eTyp-\u003eTyp",
          "package": "liboleg",
          "signature": "TVE-\u003eTyp-\u003eTyp",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TInfT.html#v:tvsub"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe unification. If unification failed, return the reason\n\u003c/p\u003e",
          "module": "Language.TEval.TInfT",
          "name": "unify",
          "package": "liboleg",
          "signature": "Typ -\u003e Typ -\u003e TVE -\u003e Either String TVE",
          "source": "src/Language-TEval-TInfT.html#unify",
          "type": "function"
        },
        "index": {
          "description": "The unification If unification failed return the reason",
          "hierarchy": "Language TEval TInfT",
          "module": "Language.TEval.TInfT",
          "name": "unify",
          "normalized": "Typ-\u003eTyp-\u003eTVE-\u003eEither String TVE",
          "package": "liboleg",
          "signature": "Typ-\u003eTyp-\u003eTVE-\u003eEither String TVE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TInfT.html#v:unify"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIf either t1 or t2 are type variables, they are definitely unbound\n\u003c/p\u003e",
          "module": "Language.TEval.TInfT",
          "name": "unify'",
          "package": "liboleg",
          "signature": "Typ -\u003e Typ -\u003e TVE -\u003e Either String TVE",
          "source": "src/Language-TEval-TInfT.html#unify%27",
          "type": "function"
        },
        "index": {
          "description": "If either t1 or t2 are type variables they are definitely unbound",
          "hierarchy": "Language TEval TInfT",
          "module": "Language.TEval.TInfT",
          "name": "unify'",
          "normalized": "Typ-\u003eTyp-\u003eTVE-\u003eEither String TVE",
          "package": "liboleg",
          "signature": "Typ-\u003eTyp-\u003eTVE-\u003eEither String TVE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TInfT.html#v:unify-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUnify a free variable v1 with t2\n\u003c/p\u003e",
          "module": "Language.TEval.TInfT",
          "name": "unifyv",
          "package": "liboleg",
          "signature": "TVarName -\u003e Typ -\u003e TVE -\u003e Either String TVE",
          "source": "src/Language-TEval-TInfT.html#unifyv",
          "type": "function"
        },
        "index": {
          "description": "Unify free variable v1 with t2",
          "hierarchy": "Language TEval TInfT",
          "module": "Language.TEval.TInfT",
          "name": "unifyv",
          "normalized": "TVarName-\u003eTyp-\u003eTVE-\u003eEither String TVE",
          "package": "liboleg",
          "signature": "TVarName-\u003eTyp-\u003eTVE-\u003eEither String TVE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TInfT.html#v:unifyv"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eSimply-typed Curry-style (nominal) lambda-calculus\n with integers and zero-comparison\n Type inference, of the type and of the environment, aka\n conditional typechecking\n This code does not in general infer polymorphic bindings as this is akin \n to higher-order unification.\n\u003c/p\u003e\u003cp\u003eThe benefit of the approach: we can handle _open_ terms.\n Some of them we type check, and some of them we reject. The rejection means\n the term cannot be typed in _any_ type environment.\n\u003c/p\u003e\u003cp\u003eOne often hears a complaint against typing: one can evaluate\n terms we can't even type check. This code shows that we can type check\n terms we can't even evaluate.\n\u003c/p\u003e\u003cp\u003eWe cannot evaluate open terms at all, but we can type check them, \n inferring both the type as well as the _requirement_\n on the environments in which the term must be used.\n\u003c/p\u003e\u003cp\u003e\u003ca\u003ehttp://okmij.org/ftp/Computation/Computation.html#teval\u003c/a\u003e\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Language.TEval.TInfTEnv",
          "name": "TInfTEnv",
          "package": "liboleg",
          "source": "src/Language-TEval-TInfTEnv.html",
          "type": "module"
        },
        "index": {
          "description": "Simply-typed Curry-style nominal lambda-calculus with integers and zero-comparison Type inference of the type and of the environment aka conditional typechecking This code does not in general infer polymorphic bindings as this is akin to higher-order unification The benefit of the approach we can handle open terms Some of them we type check and some of them we reject The rejection means the term cannot be typed in any type environment One often hears complaint against typing one can evaluate terms we can even type check This code shows that we can type check terms we can even evaluate We cannot evaluate open terms at all but we can type check them inferring both the type as well as the requirement on the environments in which the term must be used http okmij.org ftp Computation Computation.html teval",
          "hierarchy": "Language TEval TInfTEnv",
          "module": "Language.TEval.TInfTEnv",
          "name": "TInfTEnv",
          "package": "liboleg",
          "partial": "TInf TEnv",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TInfTEnv.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eType Environment: associating types with \u003ccode\u003efree\u003c/code\u003e term variables\n\u003c/p\u003e",
          "module": "Language.TEval.TInfTEnv",
          "name": "TEnv",
          "package": "liboleg",
          "source": "src/Language-TEval-TInfTEnv.html#TEnv",
          "type": "type"
        },
        "index": {
          "description": "Type Environment associating types with free term variables",
          "hierarchy": "Language TEval TInfTEnv",
          "module": "Language.TEval.TInfTEnv",
          "name": "TEnv",
          "package": "liboleg",
          "partial": "TEnv",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TInfTEnv.html#t:TEnv"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eType Variable Environment: associating types with \u003ccode\u003efree\u003c/code\u003e type variables\n\u003c/p\u003e",
          "module": "Language.TEval.TInfTEnv",
          "name": "TVE",
          "package": "liboleg",
          "source": "src/Language-TEval-TInfTEnv.html#TVE",
          "type": "data"
        },
        "index": {
          "description": "Type Variable Environment associating types with free type variables",
          "hierarchy": "Language TEval TInfTEnv",
          "module": "Language.TEval.TInfTEnv",
          "name": "TVE",
          "package": "liboleg",
          "partial": "TVE",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TInfTEnv.html#t:TVE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TEval.TInfTEnv",
          "name": "TVarName",
          "package": "liboleg",
          "source": "src/Language-TEval-TInfTEnv.html#TVarName",
          "type": "type"
        },
        "index": {
          "hierarchy": "Language TEval TInfTEnv",
          "module": "Language.TEval.TInfTEnv",
          "name": "TVarName",
          "package": "liboleg",
          "partial": "TVar Name",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TInfTEnv.html#t:TVarName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TEval.TInfTEnv",
          "name": "Term",
          "package": "liboleg",
          "source": "src/Language-TEval-TInfTEnv.html#Term",
          "type": "data"
        },
        "index": {
          "hierarchy": "Language TEval TInfTEnv",
          "module": "Language.TEval.TInfTEnv",
          "name": "Term",
          "package": "liboleg",
          "partial": "Term",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TInfTEnv.html#t:Term"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TEval.TInfTEnv",
          "name": "Typ",
          "package": "liboleg",
          "source": "src/Language-TEval-TInfTEnv.html#Typ",
          "type": "data"
        },
        "index": {
          "hierarchy": "Language TEval TInfTEnv",
          "module": "Language.TEval.TInfTEnv",
          "name": "Typ",
          "package": "liboleg",
          "partial": "Typ",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TInfTEnv.html#t:Typ"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TEval.TInfTEnv",
          "name": "VarName",
          "package": "liboleg",
          "source": "src/Language-TEval-TInfTEnv.html#VarName",
          "type": "type"
        },
        "index": {
          "hierarchy": "Language TEval TInfTEnv",
          "module": "Language.TEval.TInfTEnv",
          "name": "VarName",
          "package": "liboleg",
          "partial": "Var Name",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TInfTEnv.html#t:VarName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TEval.TInfTEnv",
          "name": ":+",
          "package": "liboleg",
          "signature": "Term :+ Term",
          "source": "src/Language-TEval-TInfTEnv.html#Term",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language TEval TInfTEnv",
          "module": "Language.TEval.TInfTEnv",
          "name": ":+",
          "package": "liboleg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TInfTEnv.html#v::-43-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TEval.TInfTEnv",
          "name": ":\u003e",
          "package": "liboleg",
          "signature": "Typ :\u003e !Typ",
          "source": "src/Language-TEval-TInfTEnv.html#Typ",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language TEval TInfTEnv",
          "module": "Language.TEval.TInfTEnv",
          "name": ":\u003e",
          "package": "liboleg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TInfTEnv.html#v::-62-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TEval.TInfTEnv",
          "name": "A",
          "package": "liboleg",
          "signature": "A Term Term",
          "source": "src/Language-TEval-TInfTEnv.html#Term",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language TEval TInfTEnv",
          "module": "Language.TEval.TInfTEnv",
          "name": "A",
          "package": "liboleg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TInfTEnv.html#v:A"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TEval.TInfTEnv",
          "name": "Fix",
          "package": "liboleg",
          "signature": "Fix Term",
          "source": "src/Language-TEval-TInfTEnv.html#Term",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language TEval TInfTEnv",
          "module": "Language.TEval.TInfTEnv",
          "name": "Fix",
          "package": "liboleg",
          "partial": "Fix",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TInfTEnv.html#v:Fix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TEval.TInfTEnv",
          "name": "I",
          "package": "liboleg",
          "signature": "I Int",
          "source": "src/Language-TEval-TInfTEnv.html#Term",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language TEval TInfTEnv",
          "module": "Language.TEval.TInfTEnv",
          "name": "I",
          "package": "liboleg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TInfTEnv.html#v:I"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TEval.TInfTEnv",
          "name": "IFZ",
          "package": "liboleg",
          "signature": "IFZ Term Term Term",
          "source": "src/Language-TEval-TInfTEnv.html#Term",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language TEval TInfTEnv",
          "module": "Language.TEval.TInfTEnv",
          "name": "IFZ",
          "package": "liboleg",
          "partial": "IFZ",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TInfTEnv.html#v:IFZ"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TEval.TInfTEnv",
          "name": "L",
          "package": "liboleg",
          "signature": "L VarName Term",
          "source": "src/Language-TEval-TInfTEnv.html#Term",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language TEval TInfTEnv",
          "module": "Language.TEval.TInfTEnv",
          "name": "L",
          "package": "liboleg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TInfTEnv.html#v:L"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TEval.TInfTEnv",
          "name": "TInt",
          "package": "liboleg",
          "signature": "TInt",
          "source": "src/Language-TEval-TInfTEnv.html#Typ",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language TEval TInfTEnv",
          "module": "Language.TEval.TInfTEnv",
          "name": "TInt",
          "package": "liboleg",
          "partial": "TInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TInfTEnv.html#v:TInt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TEval.TInfTEnv",
          "name": "TV",
          "package": "liboleg",
          "signature": "TV TVarName",
          "source": "src/Language-TEval-TInfTEnv.html#Typ",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language TEval TInfTEnv",
          "module": "Language.TEval.TInfTEnv",
          "name": "TV",
          "package": "liboleg",
          "partial": "TV",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TInfTEnv.html#v:TV"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TEval.TInfTEnv",
          "name": "TVE",
          "package": "liboleg",
          "signature": "TVE Int (IntMap Typ)",
          "source": "src/Language-TEval-TInfTEnv.html#TVE",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language TEval TInfTEnv",
          "module": "Language.TEval.TInfTEnv",
          "name": "TVE",
          "package": "liboleg",
          "partial": "TVE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TInfTEnv.html#v:TVE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TEval.TInfTEnv",
          "name": "V",
          "package": "liboleg",
          "signature": "V VarName",
          "source": "src/Language-TEval-TInfTEnv.html#Term",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language TEval TInfTEnv",
          "module": "Language.TEval.TInfTEnv",
          "name": "V",
          "package": "liboleg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TInfTEnv.html#v:V"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TEval.TInfTEnv",
          "name": "env0",
          "package": "liboleg",
          "signature": "TEnv",
          "source": "src/Language-TEval-TInfTEnv.html#env0",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language TEval TInfTEnv",
          "module": "Language.TEval.TInfTEnv",
          "name": "env0",
          "package": "liboleg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TInfTEnv.html#v:env0"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMerge two environment, using the given function to resolve the conflicts,\n if any\n\u003c/p\u003e",
          "module": "Language.TEval.TInfTEnv",
          "name": "env_fold_merge",
          "package": "liboleg",
          "signature": "TEnv -\u003e TEnv -\u003e (Typ -\u003e Typ -\u003e seed -\u003e Either err seed) -\u003e seed -\u003e Either err (TEnv, seed)",
          "source": "src/Language-TEval-TInfTEnv.html#env_fold_merge",
          "type": "function"
        },
        "index": {
          "description": "Merge two environment using the given function to resolve the conflicts if any",
          "hierarchy": "Language TEval TInfTEnv",
          "module": "Language.TEval.TInfTEnv",
          "name": "env_fold_merge",
          "normalized": "TEnv-\u003eTEnv-\u003e(Typ-\u003eTyp-\u003ea-\u003eEither b a)-\u003ea-\u003eEither b(TEnv,a)",
          "package": "liboleg",
          "signature": "TEnv-\u003eTEnv-\u003e(Typ-\u003eTyp-\u003eseed-\u003eEither err seed)-\u003eseed-\u003eEither err(TEnv,seed)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TInfTEnv.html#v:env_fold_merge"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TEval.TInfTEnv",
          "name": "env_map",
          "package": "liboleg",
          "signature": "(Typ -\u003e Typ) -\u003e TEnv -\u003e TEnv",
          "source": "src/Language-TEval-TInfTEnv.html#env_map",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language TEval TInfTEnv",
          "module": "Language.TEval.TInfTEnv",
          "name": "env_map",
          "normalized": "(Typ-\u003eTyp)-\u003eTEnv-\u003eTEnv",
          "package": "liboleg",
          "signature": "(Typ-\u003eTyp)-\u003eTEnv-\u003eTEnv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TInfTEnv.html#v:env_map"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TEval.TInfTEnv",
          "name": "ext",
          "package": "liboleg",
          "signature": "TEnv -\u003e (VarName, Typ) -\u003e TEnv",
          "source": "src/Language-TEval-TInfTEnv.html#ext",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language TEval TInfTEnv",
          "module": "Language.TEval.TInfTEnv",
          "name": "ext",
          "normalized": "TEnv-\u003e(VarName,Typ)-\u003eTEnv",
          "package": "liboleg",
          "signature": "TEnv-\u003e(VarName,Typ)-\u003eTEnv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TInfTEnv.html#v:ext"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TEval.TInfTEnv",
          "name": "lkup",
          "package": "liboleg",
          "signature": "TEnv -\u003e VarName -\u003e Typ",
          "source": "src/Language-TEval-TInfTEnv.html#lkup",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language TEval TInfTEnv",
          "module": "Language.TEval.TInfTEnv",
          "name": "lkup",
          "normalized": "TEnv-\u003eVarName-\u003eTyp",
          "package": "liboleg",
          "signature": "TEnv-\u003eVarName-\u003eTyp",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TInfTEnv.html#v:lkup"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TEval.TInfTEnv",
          "name": "merge_env",
          "package": "liboleg",
          "signature": "TEnv -\u003e TEnv -\u003e TVE -\u003e (TEnv, TVE)",
          "source": "src/Language-TEval-TInfTEnv.html#merge_env",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language TEval TInfTEnv",
          "module": "Language.TEval.TInfTEnv",
          "name": "merge_env",
          "normalized": "TEnv-\u003eTEnv-\u003eTVE-\u003e(TEnv,TVE)",
          "package": "liboleg",
          "signature": "TEnv-\u003eTEnv-\u003eTVE-\u003e(TEnv,TVE)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TInfTEnv.html#v:merge_env"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAllocate a fresh type variable (see the first component of TVE)\n\u003c/p\u003e",
          "module": "Language.TEval.TInfTEnv",
          "name": "newtv",
          "package": "liboleg",
          "signature": "TVE -\u003e (Typ, TVE)",
          "source": "src/Language-TEval-TInfTEnv.html#newtv",
          "type": "function"
        },
        "index": {
          "description": "Allocate fresh type variable see the first component of TVE",
          "hierarchy": "Language TEval TInfTEnv",
          "module": "Language.TEval.TInfTEnv",
          "name": "newtv",
          "normalized": "TVE-\u003e(Typ,TVE)",
          "package": "liboleg",
          "signature": "TVE-\u003e(Typ,TVE)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TInfTEnv.html#v:newtv"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe occurs check: if v appears free in t\n\u003c/p\u003e",
          "module": "Language.TEval.TInfTEnv",
          "name": "occurs",
          "package": "liboleg",
          "signature": "TVarName -\u003e Typ -\u003e TVE -\u003e Bool",
          "source": "src/Language-TEval-TInfTEnv.html#occurs",
          "type": "function"
        },
        "index": {
          "description": "The occurs check if appears free in",
          "hierarchy": "Language TEval TInfTEnv",
          "module": "Language.TEval.TInfTEnv",
          "name": "occurs",
          "normalized": "TVarName-\u003eTyp-\u003eTVE-\u003eBool",
          "package": "liboleg",
          "signature": "TVarName-\u003eTyp-\u003eTVE-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TInfTEnv.html#v:occurs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eResolve all type variables, as far as possible\n\u003c/p\u003e",
          "module": "Language.TEval.TInfTEnv",
          "name": "teval",
          "package": "liboleg",
          "signature": "Term -\u003e (Typ, TEnv)",
          "source": "src/Language-TEval-TInfTEnv.html#teval",
          "type": "function"
        },
        "index": {
          "description": "Resolve all type variables as far as possible",
          "hierarchy": "Language TEval TInfTEnv",
          "module": "Language.TEval.TInfTEnv",
          "name": "teval",
          "normalized": "Term-\u003e(Typ,TEnv)",
          "package": "liboleg",
          "signature": "Term-\u003e(Typ,TEnv)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TInfTEnv.html#v:teval"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eType reconstruction: abstract evaluation\n\u003c/p\u003e",
          "module": "Language.TEval.TInfTEnv",
          "name": "teval'",
          "package": "liboleg",
          "signature": "Term -\u003e TVE -\u003e (Typ, TEnv, TVE)",
          "source": "src/Language-TEval-TInfTEnv.html#teval%27",
          "type": "function"
        },
        "index": {
          "description": "Type reconstruction abstract evaluation",
          "hierarchy": "Language TEval TInfTEnv",
          "module": "Language.TEval.TInfTEnv",
          "name": "teval'",
          "normalized": "Term-\u003eTVE-\u003e(Typ,TEnv,TVE)",
          "package": "liboleg",
          "signature": "Term-\u003eTVE-\u003e(Typ,TEnv,TVE)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TInfTEnv.html#v:teval-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eshallow\u003c/code\u003e substitution; check if tv is bound to anything \u003ccode\u003esubstantial\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Language.TEval.TInfTEnv",
          "name": "tvchase",
          "package": "liboleg",
          "signature": "TVE -\u003e Typ -\u003e Typ",
          "source": "src/Language-TEval-TInfTEnv.html#tvchase",
          "type": "function"
        },
        "index": {
          "description": "shallow substitution check if tv is bound to anything substantial",
          "hierarchy": "Language TEval TInfTEnv",
          "module": "Language.TEval.TInfTEnv",
          "name": "tvchase",
          "normalized": "TVE-\u003eTyp-\u003eTyp",
          "package": "liboleg",
          "signature": "TVE-\u003eTyp-\u003eTyp",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TInfTEnv.html#v:tvchase"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TEval.TInfTEnv",
          "name": "tve0",
          "package": "liboleg",
          "signature": "TVE",
          "source": "src/Language-TEval-TInfTEnv.html#tve0",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language TEval TInfTEnv",
          "module": "Language.TEval.TInfTEnv",
          "name": "tve0",
          "package": "liboleg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TInfTEnv.html#v:tve0"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TEval.TInfTEnv",
          "name": "tvext",
          "package": "liboleg",
          "signature": "TVE -\u003e (TVarName, Typ) -\u003e TVE",
          "source": "src/Language-TEval-TInfTEnv.html#tvext",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language TEval TInfTEnv",
          "module": "Language.TEval.TInfTEnv",
          "name": "tvext",
          "normalized": "TVE-\u003e(TVarName,Typ)-\u003eTVE",
          "package": "liboleg",
          "signature": "TVE-\u003e(TVarName,Typ)-\u003eTVE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TInfTEnv.html#v:tvext"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TEval.TInfTEnv",
          "name": "tvlkup",
          "package": "liboleg",
          "signature": "TVE -\u003e TVarName -\u003e Maybe Typ",
          "source": "src/Language-TEval-TInfTEnv.html#tvlkup",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language TEval TInfTEnv",
          "module": "Language.TEval.TInfTEnv",
          "name": "tvlkup",
          "normalized": "TVE-\u003eTVarName-\u003eMaybe Typ",
          "package": "liboleg",
          "signature": "TVE-\u003eTVarName-\u003eMaybe Typ",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TInfTEnv.html#v:tvlkup"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eType variables are logic variables: hypothetical reasoning\n\u003c/p\u003e",
          "module": "Language.TEval.TInfTEnv",
          "name": "tvsub",
          "package": "liboleg",
          "signature": "TVE -\u003e Typ -\u003e Typ",
          "source": "src/Language-TEval-TInfTEnv.html#tvsub",
          "type": "function"
        },
        "index": {
          "description": "Type variables are logic variables hypothetical reasoning",
          "hierarchy": "Language TEval TInfTEnv",
          "module": "Language.TEval.TInfTEnv",
          "name": "tvsub",
          "normalized": "TVE-\u003eTyp-\u003eTyp",
          "package": "liboleg",
          "signature": "TVE-\u003eTyp-\u003eTyp",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TInfTEnv.html#v:tvsub"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TEval.TInfTEnv",
          "name": "unext",
          "package": "liboleg",
          "signature": "TEnv -\u003e VarName -\u003e TEnv",
          "source": "src/Language-TEval-TInfTEnv.html#unext",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language TEval TInfTEnv",
          "module": "Language.TEval.TInfTEnv",
          "name": "unext",
          "normalized": "TEnv-\u003eVarName-\u003eTEnv",
          "package": "liboleg",
          "signature": "TEnv-\u003eVarName-\u003eTEnv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TInfTEnv.html#v:unext"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe unification. If unification failed, return the reason\n\u003c/p\u003e",
          "module": "Language.TEval.TInfTEnv",
          "name": "unify",
          "package": "liboleg",
          "signature": "Typ -\u003e Typ -\u003e TVE -\u003e Either String TVE",
          "source": "src/Language-TEval-TInfTEnv.html#unify",
          "type": "function"
        },
        "index": {
          "description": "The unification If unification failed return the reason",
          "hierarchy": "Language TEval TInfTEnv",
          "module": "Language.TEval.TInfTEnv",
          "name": "unify",
          "normalized": "Typ-\u003eTyp-\u003eTVE-\u003eEither String TVE",
          "package": "liboleg",
          "signature": "Typ-\u003eTyp-\u003eTVE-\u003eEither String TVE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TInfTEnv.html#v:unify"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIf either t1 or t2 are type variables, they are definitely unbound\n\u003c/p\u003e",
          "module": "Language.TEval.TInfTEnv",
          "name": "unify'",
          "package": "liboleg",
          "signature": "Typ -\u003e Typ -\u003e TVE -\u003e Either String TVE",
          "source": "src/Language-TEval-TInfTEnv.html#unify%27",
          "type": "function"
        },
        "index": {
          "description": "If either t1 or t2 are type variables they are definitely unbound",
          "hierarchy": "Language TEval TInfTEnv",
          "module": "Language.TEval.TInfTEnv",
          "name": "unify'",
          "normalized": "Typ-\u003eTyp-\u003eTVE-\u003eEither String TVE",
          "package": "liboleg",
          "signature": "Typ-\u003eTyp-\u003eTVE-\u003eEither String TVE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TInfTEnv.html#v:unify-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUnify a free variable v1 with t2\n\u003c/p\u003e",
          "module": "Language.TEval.TInfTEnv",
          "name": "unifyv",
          "package": "liboleg",
          "signature": "TVarName -\u003e Typ -\u003e TVE -\u003e Either String TVE",
          "source": "src/Language-TEval-TInfTEnv.html#unifyv",
          "type": "function"
        },
        "index": {
          "description": "Unify free variable v1 with t2",
          "hierarchy": "Language TEval TInfTEnv",
          "module": "Language.TEval.TInfTEnv",
          "name": "unifyv",
          "normalized": "TVarName-\u003eTyp-\u003eTVE-\u003eEither String TVE",
          "package": "liboleg",
          "signature": "TVarName-\u003eTyp-\u003eTVE-\u003eEither String TVE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TInfTEnv.html#v:unifyv"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eSimply-typed Curry-style (nominal) lambda-calculus\n with integers and zero-comparison\n Type inference. Hiding the single-threaded state via simple\n algebraic transformations (beta-expansions). \n\u003c/p\u003e\u003cp\u003e\u003ca\u003ehttp://okmij.org/ftp/Computation/Computation.html#teval\u003c/a\u003e\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Language.TEval.TInfTM",
          "name": "TInfTM",
          "package": "liboleg",
          "source": "src/Language-TEval-TInfTM.html",
          "type": "module"
        },
        "index": {
          "description": "Simply-typed Curry-style nominal lambda-calculus with integers and zero-comparison Type inference Hiding the single-threaded state via simple algebraic transformations beta-expansions http okmij.org ftp Computation Computation.html teval",
          "hierarchy": "Language TEval TInfTM",
          "module": "Language.TEval.TInfTM",
          "name": "TInfTM",
          "package": "liboleg",
          "partial": "TInf TM",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TInfTM.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eType Environment: associating types with \u003ccode\u003efree\u003c/code\u003e term variables\n\u003c/p\u003e",
          "module": "Language.TEval.TInfTM",
          "name": "TEnv",
          "package": "liboleg",
          "source": "src/Language-TEval-TInfTM.html#TEnv",
          "type": "type"
        },
        "index": {
          "description": "Type Environment associating types with free term variables",
          "hierarchy": "Language TEval TInfTM",
          "module": "Language.TEval.TInfTM",
          "name": "TEnv",
          "package": "liboleg",
          "partial": "TEnv",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TInfTM.html#t:TEnv"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eType Variable Environment: associating types with \u003ccode\u003efree\u003c/code\u003e type variables\n\u003c/p\u003e",
          "module": "Language.TEval.TInfTM",
          "name": "TVE",
          "package": "liboleg",
          "source": "src/Language-TEval-TInfTM.html#TVE",
          "type": "data"
        },
        "index": {
          "description": "Type Variable Environment associating types with free type variables",
          "hierarchy": "Language TEval TInfTM",
          "module": "Language.TEval.TInfTM",
          "name": "TVE",
          "package": "liboleg",
          "partial": "TVE",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TInfTM.html#t:TVE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIntroducing the combinators to hide single-threaded state tve in one\n case of teval' (the A case). The other cases stay as they are, to illustrate\n that our transformation is fully compatible with the earlier code.\n\u003c/p\u003e",
          "module": "Language.TEval.TInfTM",
          "name": "TVEM",
          "package": "liboleg",
          "source": "src/Language-TEval-TInfTM.html#TVEM",
          "type": "type"
        },
        "index": {
          "description": "Introducing the combinators to hide single-threaded state tve in one case of teval the case The other cases stay as they are to illustrate that our transformation is fully compatible with the earlier code",
          "hierarchy": "Language TEval TInfTM",
          "module": "Language.TEval.TInfTM",
          "name": "TVEM",
          "package": "liboleg",
          "partial": "TVEM",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TInfTM.html#t:TVEM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TEval.TInfTM",
          "name": "TVarName",
          "package": "liboleg",
          "source": "src/Language-TEval-TInfTM.html#TVarName",
          "type": "type"
        },
        "index": {
          "hierarchy": "Language TEval TInfTM",
          "module": "Language.TEval.TInfTM",
          "name": "TVarName",
          "package": "liboleg",
          "partial": "TVar Name",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TInfTM.html#t:TVarName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TEval.TInfTM",
          "name": "Term",
          "package": "liboleg",
          "source": "src/Language-TEval-TInfTM.html#Term",
          "type": "data"
        },
        "index": {
          "hierarchy": "Language TEval TInfTM",
          "module": "Language.TEval.TInfTM",
          "name": "Term",
          "package": "liboleg",
          "partial": "Term",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TInfTM.html#t:Term"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TEval.TInfTM",
          "name": "Typ",
          "package": "liboleg",
          "source": "src/Language-TEval-TInfTM.html#Typ",
          "type": "data"
        },
        "index": {
          "hierarchy": "Language TEval TInfTM",
          "module": "Language.TEval.TInfTM",
          "name": "Typ",
          "package": "liboleg",
          "partial": "Typ",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TInfTM.html#t:Typ"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TEval.TInfTM",
          "name": "VarName",
          "package": "liboleg",
          "source": "src/Language-TEval-TInfTM.html#VarName",
          "type": "type"
        },
        "index": {
          "hierarchy": "Language TEval TInfTM",
          "module": "Language.TEval.TInfTM",
          "name": "VarName",
          "package": "liboleg",
          "partial": "Var Name",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TInfTM.html#t:VarName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TEval.TInfTM",
          "name": "(\u003e\u003e=)",
          "package": "liboleg",
          "signature": "TVEM a -\u003e (a -\u003e TVEM b) -\u003e TVEM b",
          "source": "src/Language-TEval-TInfTM.html#%3E%3E%3D",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language TEval TInfTM",
          "module": "Language.TEval.TInfTM",
          "name": "(\u003e\u003e=) \u003e\u003e=",
          "normalized": "TVEM a-\u003e(a-\u003eTVEM b)-\u003eTVEM b",
          "package": "liboleg",
          "signature": "TVEM a-\u003e(a-\u003eTVEM b)-\u003eTVEM b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TInfTM.html#v:-62--62--61-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TEval.TInfTM",
          "name": ":+",
          "package": "liboleg",
          "signature": "Term :+ Term",
          "source": "src/Language-TEval-TInfTM.html#Term",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language TEval TInfTM",
          "module": "Language.TEval.TInfTM",
          "name": ":+",
          "package": "liboleg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TInfTM.html#v::-43-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TEval.TInfTM",
          "name": ":\u003e",
          "package": "liboleg",
          "signature": "Typ :\u003e !Typ",
          "source": "src/Language-TEval-TInfTM.html#Typ",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language TEval TInfTM",
          "module": "Language.TEval.TInfTM",
          "name": ":\u003e",
          "package": "liboleg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TInfTM.html#v::-62-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TEval.TInfTM",
          "name": "A",
          "package": "liboleg",
          "signature": "A Term Term",
          "source": "src/Language-TEval-TInfTM.html#Term",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language TEval TInfTM",
          "module": "Language.TEval.TInfTM",
          "name": "A",
          "package": "liboleg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TInfTM.html#v:A"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TEval.TInfTM",
          "name": "Fix",
          "package": "liboleg",
          "signature": "Fix Term",
          "source": "src/Language-TEval-TInfTM.html#Term",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language TEval TInfTM",
          "module": "Language.TEval.TInfTM",
          "name": "Fix",
          "package": "liboleg",
          "partial": "Fix",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TInfTM.html#v:Fix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TEval.TInfTM",
          "name": "I",
          "package": "liboleg",
          "signature": "I Int",
          "source": "src/Language-TEval-TInfTM.html#Term",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language TEval TInfTM",
          "module": "Language.TEval.TInfTM",
          "name": "I",
          "package": "liboleg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TInfTM.html#v:I"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TEval.TInfTM",
          "name": "IFZ",
          "package": "liboleg",
          "signature": "IFZ Term Term Term",
          "source": "src/Language-TEval-TInfTM.html#Term",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language TEval TInfTM",
          "module": "Language.TEval.TInfTM",
          "name": "IFZ",
          "package": "liboleg",
          "partial": "IFZ",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TInfTM.html#v:IFZ"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TEval.TInfTM",
          "name": "L",
          "package": "liboleg",
          "signature": "L VarName Term",
          "source": "src/Language-TEval-TInfTM.html#Term",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language TEval TInfTM",
          "module": "Language.TEval.TInfTM",
          "name": "L",
          "package": "liboleg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TInfTM.html#v:L"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TEval.TInfTM",
          "name": "TInt",
          "package": "liboleg",
          "signature": "TInt",
          "source": "src/Language-TEval-TInfTM.html#Typ",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language TEval TInfTM",
          "module": "Language.TEval.TInfTM",
          "name": "TInt",
          "package": "liboleg",
          "partial": "TInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TInfTM.html#v:TInt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TEval.TInfTM",
          "name": "TV",
          "package": "liboleg",
          "signature": "TV TVarName",
          "source": "src/Language-TEval-TInfTM.html#Typ",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language TEval TInfTM",
          "module": "Language.TEval.TInfTM",
          "name": "TV",
          "package": "liboleg",
          "partial": "TV",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TInfTM.html#v:TV"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TEval.TInfTM",
          "name": "TVE",
          "package": "liboleg",
          "signature": "TVE Int (IntMap Typ)",
          "source": "src/Language-TEval-TInfTM.html#TVE",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language TEval TInfTM",
          "module": "Language.TEval.TInfTM",
          "name": "TVE",
          "package": "liboleg",
          "partial": "TVE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TInfTM.html#v:TVE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TEval.TInfTM",
          "name": "V",
          "package": "liboleg",
          "signature": "V VarName",
          "source": "src/Language-TEval-TInfTM.html#Term",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language TEval TInfTM",
          "module": "Language.TEval.TInfTM",
          "name": "V",
          "package": "liboleg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TInfTM.html#v:V"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TEval.TInfTM",
          "name": "env0",
          "package": "liboleg",
          "signature": "TEnv",
          "source": "src/Language-TEval-TInfTM.html#env0",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language TEval TInfTM",
          "module": "Language.TEval.TInfTM",
          "name": "env0",
          "package": "liboleg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TInfTM.html#v:env0"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TEval.TInfTM",
          "name": "ext",
          "package": "liboleg",
          "signature": "TEnv -\u003e (VarName, Typ) -\u003e TEnv",
          "source": "src/Language-TEval-TInfTM.html#ext",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language TEval TInfTM",
          "module": "Language.TEval.TInfTM",
          "name": "ext",
          "normalized": "TEnv-\u003e(VarName,Typ)-\u003eTEnv",
          "package": "liboleg",
          "signature": "TEnv-\u003e(VarName,Typ)-\u003eTEnv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TInfTM.html#v:ext"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TEval.TInfTM",
          "name": "lkup",
          "package": "liboleg",
          "signature": "TEnv -\u003e VarName -\u003e Typ",
          "source": "src/Language-TEval-TInfTM.html#lkup",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language TEval TInfTM",
          "module": "Language.TEval.TInfTM",
          "name": "lkup",
          "normalized": "TEnv-\u003eVarName-\u003eTyp",
          "package": "liboleg",
          "signature": "TEnv-\u003eVarName-\u003eTyp",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TInfTM.html#v:lkup"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAllocate a fresh type variable (see the first component of TVE)\n\u003c/p\u003e",
          "module": "Language.TEval.TInfTM",
          "name": "newtv",
          "package": "liboleg",
          "signature": "TVE -\u003e (Typ, TVE)",
          "source": "src/Language-TEval-TInfTM.html#newtv",
          "type": "function"
        },
        "index": {
          "description": "Allocate fresh type variable see the first component of TVE",
          "hierarchy": "Language TEval TInfTM",
          "module": "Language.TEval.TInfTM",
          "name": "newtv",
          "normalized": "TVE-\u003e(Typ,TVE)",
          "package": "liboleg",
          "signature": "TVE-\u003e(Typ,TVE)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TInfTM.html#v:newtv"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe occurs check: if v appears free in t\n\u003c/p\u003e",
          "module": "Language.TEval.TInfTM",
          "name": "occurs",
          "package": "liboleg",
          "signature": "TVarName -\u003e Typ -\u003e TVE -\u003e Bool",
          "source": "src/Language-TEval-TInfTM.html#occurs",
          "type": "function"
        },
        "index": {
          "description": "The occurs check if appears free in",
          "hierarchy": "Language TEval TInfTM",
          "module": "Language.TEval.TInfTM",
          "name": "occurs",
          "normalized": "TVarName-\u003eTyp-\u003eTVE-\u003eBool",
          "package": "liboleg",
          "signature": "TVarName-\u003eTyp-\u003eTVE-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TInfTM.html#v:occurs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TEval.TInfTM",
          "name": "return",
          "package": "liboleg",
          "signature": "a -\u003e TVEM a",
          "source": "src/Language-TEval-TInfTM.html#return",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language TEval TInfTM",
          "module": "Language.TEval.TInfTM",
          "name": "return",
          "normalized": "a-\u003eTVEM a",
          "package": "liboleg",
          "signature": "a-\u003eTVEM a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TInfTM.html#v:return"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TEval.TInfTM",
          "name": "teval",
          "package": "liboleg",
          "signature": "TEnv -\u003e Term -\u003e Typ",
          "source": "src/Language-TEval-TInfTM.html#teval",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language TEval TInfTM",
          "module": "Language.TEval.TInfTM",
          "name": "teval",
          "normalized": "TEnv-\u003eTerm-\u003eTyp",
          "package": "liboleg",
          "signature": "TEnv-\u003eTerm-\u003eTyp",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TInfTM.html#v:teval"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe expression abstracted from the last-but-one re-writing of the A-clause\n below\n\u003c/p\u003e\u003cp\u003eType reconstruction: abstract evaluation\n\u003c/p\u003e",
          "module": "Language.TEval.TInfTM",
          "name": "teval'",
          "package": "liboleg",
          "signature": "TEnv -\u003e Term -\u003e TVE -\u003e (Typ, TVE)",
          "source": "src/Language-TEval-TInfTM.html#teval%27",
          "type": "function"
        },
        "index": {
          "description": "The expression abstracted from the last-but-one re-writing of the A-clause below Type reconstruction abstract evaluation",
          "hierarchy": "Language TEval TInfTM",
          "module": "Language.TEval.TInfTM",
          "name": "teval'",
          "normalized": "TEnv-\u003eTerm-\u003eTVE-\u003e(Typ,TVE)",
          "package": "liboleg",
          "signature": "TEnv-\u003eTerm-\u003eTVE-\u003e(Typ,TVE)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TInfTM.html#v:teval-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eshallow\u003c/code\u003e substitution; check if tv is bound to anything \u003ccode\u003esubstantial\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Language.TEval.TInfTM",
          "name": "tvchase",
          "package": "liboleg",
          "signature": "TVE -\u003e Typ -\u003e Typ",
          "source": "src/Language-TEval-TInfTM.html#tvchase",
          "type": "function"
        },
        "index": {
          "description": "shallow substitution check if tv is bound to anything substantial",
          "hierarchy": "Language TEval TInfTM",
          "module": "Language.TEval.TInfTM",
          "name": "tvchase",
          "normalized": "TVE-\u003eTyp-\u003eTyp",
          "package": "liboleg",
          "signature": "TVE-\u003eTyp-\u003eTyp",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TInfTM.html#v:tvchase"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TEval.TInfTM",
          "name": "tve0",
          "package": "liboleg",
          "signature": "TVE",
          "source": "src/Language-TEval-TInfTM.html#tve0",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language TEval TInfTM",
          "module": "Language.TEval.TInfTM",
          "name": "tve0",
          "package": "liboleg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TInfTM.html#v:tve0"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TEval.TInfTM",
          "name": "tvext",
          "package": "liboleg",
          "signature": "TVE -\u003e (TVarName, Typ) -\u003e TVE",
          "source": "src/Language-TEval-TInfTM.html#tvext",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language TEval TInfTM",
          "module": "Language.TEval.TInfTM",
          "name": "tvext",
          "normalized": "TVE-\u003e(TVarName,Typ)-\u003eTVE",
          "package": "liboleg",
          "signature": "TVE-\u003e(TVarName,Typ)-\u003eTVE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TInfTM.html#v:tvext"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TEval.TInfTM",
          "name": "tvlkup",
          "package": "liboleg",
          "signature": "TVE -\u003e TVarName -\u003e Maybe Typ",
          "source": "src/Language-TEval-TInfTM.html#tvlkup",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language TEval TInfTM",
          "module": "Language.TEval.TInfTM",
          "name": "tvlkup",
          "normalized": "TVE-\u003eTVarName-\u003eMaybe Typ",
          "package": "liboleg",
          "signature": "TVE-\u003eTVarName-\u003eMaybe Typ",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TInfTM.html#v:tvlkup"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eType variables are logic variables: hypothetical reasoning\n\u003c/p\u003e",
          "module": "Language.TEval.TInfTM",
          "name": "tvsub",
          "package": "liboleg",
          "signature": "TVE -\u003e Typ -\u003e Typ",
          "source": "src/Language-TEval-TInfTM.html#tvsub",
          "type": "function"
        },
        "index": {
          "description": "Type variables are logic variables hypothetical reasoning",
          "hierarchy": "Language TEval TInfTM",
          "module": "Language.TEval.TInfTM",
          "name": "tvsub",
          "normalized": "TVE-\u003eTyp-\u003eTyp",
          "package": "liboleg",
          "signature": "TVE-\u003eTyp-\u003eTyp",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TInfTM.html#v:tvsub"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe unification. If unification failed, return the reason\n\u003c/p\u003e",
          "module": "Language.TEval.TInfTM",
          "name": "unify",
          "package": "liboleg",
          "signature": "Typ -\u003e Typ -\u003e TVE -\u003e Either String TVE",
          "source": "src/Language-TEval-TInfTM.html#unify",
          "type": "function"
        },
        "index": {
          "description": "The unification If unification failed return the reason",
          "hierarchy": "Language TEval TInfTM",
          "module": "Language.TEval.TInfTM",
          "name": "unify",
          "normalized": "Typ-\u003eTyp-\u003eTVE-\u003eEither String TVE",
          "package": "liboleg",
          "signature": "Typ-\u003eTyp-\u003eTVE-\u003eEither String TVE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TInfTM.html#v:unify"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIf either t1 or t2 are type variables, they are definitely unbound\n\u003c/p\u003e",
          "module": "Language.TEval.TInfTM",
          "name": "unify'",
          "package": "liboleg",
          "signature": "Typ -\u003e Typ -\u003e TVE -\u003e Either String TVE",
          "source": "src/Language-TEval-TInfTM.html#unify%27",
          "type": "function"
        },
        "index": {
          "description": "If either t1 or t2 are type variables they are definitely unbound",
          "hierarchy": "Language TEval TInfTM",
          "module": "Language.TEval.TInfTM",
          "name": "unify'",
          "normalized": "Typ-\u003eTyp-\u003eTVE-\u003eEither String TVE",
          "package": "liboleg",
          "signature": "Typ-\u003eTyp-\u003eTVE-\u003eEither String TVE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TInfTM.html#v:unify-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUnify a free variable v1 with t2\n\u003c/p\u003e",
          "module": "Language.TEval.TInfTM",
          "name": "unifyv",
          "package": "liboleg",
          "signature": "TVarName -\u003e Typ -\u003e TVE -\u003e Either String TVE",
          "source": "src/Language-TEval-TInfTM.html#unifyv",
          "type": "function"
        },
        "index": {
          "description": "Unify free variable v1 with t2",
          "hierarchy": "Language TEval TInfTM",
          "module": "Language.TEval.TInfTM",
          "name": "unifyv",
          "normalized": "TVarName-\u003eTyp-\u003eTVE-\u003eEither String TVE",
          "package": "liboleg",
          "signature": "TVarName-\u003eTyp-\u003eTVE-\u003eEither String TVE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TEval-TInfTM.html#v:unifyv"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eTyped tagless-final interpreters for PCF\n Higher-order abstract syntax\n based on the code accompanying the paper by\n   Jacques Carette, Oleg Kiselyov, and Chung-chieh Shan\n\u003c/p\u003e\u003cp\u003e\u003ca\u003ehttp://okmij.org/ftp/tagless-final/course/course.html#TDPE\u003c/a\u003e\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Language.TTF",
          "name": "TTF",
          "package": "liboleg",
          "source": "src/Language-TTF.html",
          "type": "module"
        },
        "index": {
          "description": "Typed tagless-final interpreters for PCF Higher-order abstract syntax based on the code accompanying the paper by Jacques Carette Oleg Kiselyov and Chung-chieh Shan http okmij.org ftp tagless-final course course.html TDPE",
          "hierarchy": "Language TTF",
          "module": "Language.TTF",
          "name": "TTF",
          "package": "liboleg",
          "partial": "TTF",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TTF.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TTF",
          "name": "BoolSYM",
          "package": "liboleg",
          "source": "src/Language-TTF.html#BoolSYM",
          "type": "class"
        },
        "index": {
          "hierarchy": "Language TTF",
          "module": "Language.TTF",
          "name": "BoolSYM",
          "package": "liboleg",
          "partial": "Bool SYM",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TTF.html#t:BoolSYM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TTF",
          "name": "FixSYM",
          "package": "liboleg",
          "source": "src/Language-TTF.html#FixSYM",
          "type": "class"
        },
        "index": {
          "hierarchy": "Language TTF",
          "module": "Language.TTF",
          "name": "FixSYM",
          "package": "liboleg",
          "partial": "Fix SYM",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TTF.html#t:FixSYM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cul\u003e\u003cli\u003e The crucial role of repr being a type constructor\n rather than just a type. It lets some information about\n object-term representation through (the type) while\n keeping the representation itself hidden.\n\u003c/li\u003e\u003cli\u003e \u003cem/\u003e\n * Extensions of the language\n\u003c/li\u003e\u003cli\u003e Multiplication\n\u003c/li\u003e\u003c/ul\u003e",
          "module": "Language.TTF",
          "name": "MulSYM",
          "package": "liboleg",
          "source": "src/Language-TTF.html#MulSYM",
          "type": "class"
        },
        "index": {
          "description": "The crucial role of repr being type constructor rather than just type It lets some information about object-term representation through the type while keeping the representation itself hidden Extensions of the language Multiplication",
          "hierarchy": "Language TTF",
          "module": "Language.TTF",
          "name": "MulSYM",
          "package": "liboleg",
          "partial": "Mul SYM",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TTF.html#t:MulSYM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TTF",
          "name": "R",
          "package": "liboleg",
          "source": "src/Language-TTF.html#R",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "Language TTF",
          "module": "Language.TTF",
          "name": "R",
          "package": "liboleg",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TTF.html#t:R"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TTF",
          "name": "S",
          "package": "liboleg",
          "source": "src/Language-TTF.html#S",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "Language TTF",
          "module": "Language.TTF",
          "name": "S",
          "package": "liboleg",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TTF.html#t:S"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe language is simply-typed lambda-calculus with fixpoint and\n constants. It is essentially PCF.\n The language is just expressive enough for the power function.\n We define the language by parts, to emphasize modularity.\n The core plus the fixpoint is the language described in the paper\n\u003c/p\u003e\u003cp\u003e\u003cem\u003eHongwei Xi, Chiyan Chen, Gang Chen Guarded Recursive Datatype Constructors, POPL2003\u003c/em\u003e\n\u003c/p\u003e\u003cp\u003ewhich is used to justify GADTs.\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e Core language\n\u003c/li\u003e\u003c/ul\u003e",
          "module": "Language.TTF",
          "name": "Symantics",
          "package": "liboleg",
          "source": "src/Language-TTF.html#Symantics",
          "type": "class"
        },
        "index": {
          "description": "The language is simply-typed lambda-calculus with fixpoint and constants It is essentially PCF The language is just expressive enough for the power function We define the language by parts to emphasize modularity The core plus the fixpoint is the language described in the paper Hongwei Xi Chiyan Chen Gang Chen Guarded Recursive Datatype Constructors POPL2003 which is used to justify GADTs Core language",
          "hierarchy": "Language TTF",
          "module": "Language.TTF",
          "name": "Symantics",
          "package": "liboleg",
          "partial": "Symantics",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TTF.html#t:Symantics"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cul\u003e\u003cli\u003e R is not a tag! It is a newtype\n The expression with unR _looks_ like tag introduction and\n elimination. But the function unR is *total*. There is no \n run-time error is possible at all -- and this fact is fully \n apparent to the compiler.\n Furthermore, at run-time, (R x) is indistinguishable from x\n * R is a meta-circular interpreter\n This is easier to see now. So, object-level addition is\n _truly_ the metalanguage addition. Needless to say, that is\n efficient.\n * R never gets stuck: no pattern-matching of any kind\n * R is total\n\u003c/li\u003e\u003cli\u003e \u003cem/\u003e\n Another interpreter\n\u003c/li\u003e\u003c/ul\u003e",
          "module": "Language.TTF",
          "name": "VarCounter",
          "package": "liboleg",
          "source": "src/Language-TTF.html#VarCounter",
          "type": "type"
        },
        "index": {
          "description": "is not tag It is newtype The expression with unR looks like tag introduction and elimination But the function unR is total There is no run-time error is possible at all and this fact is fully apparent to the compiler Furthermore at run-time is indistinguishable from is meta-circular interpreter This is easier to see now So object-level addition is truly the metalanguage addition Needless to say that is efficient never gets stuck no pattern-matching of any kind is total Another interpreter",
          "hierarchy": "Language TTF",
          "module": "Language.TTF",
          "name": "VarCounter",
          "package": "liboleg",
          "partial": "Var Counter",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TTF.html#t:VarCounter"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TTF",
          "name": "R",
          "package": "liboleg",
          "signature": "R",
          "source": "src/Language-TTF.html#R",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language TTF",
          "module": "Language.TTF",
          "name": "R",
          "package": "liboleg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TTF.html#v:R"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TTF",
          "name": "S",
          "package": "liboleg",
          "signature": "S",
          "source": "src/Language-TTF.html#S",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language TTF",
          "module": "Language.TTF",
          "name": "S",
          "package": "liboleg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TTF.html#v:S"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TTF",
          "name": "add",
          "package": "liboleg",
          "signature": "repr Int -\u003e repr Int -\u003e repr Int",
          "source": "src/Language-TTF.html#add",
          "type": "method"
        },
        "index": {
          "hierarchy": "Language TTF",
          "module": "Language.TTF",
          "name": "add",
          "normalized": "a Int-\u003ea Int-\u003ea Int",
          "package": "liboleg",
          "signature": "repr Int-\u003erepr Int-\u003erepr Int",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TTF.html#v:add"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TTF",
          "name": "app",
          "package": "liboleg",
          "signature": "repr (a -\u003e b) -\u003e repr a -\u003e repr b",
          "source": "src/Language-TTF.html#app",
          "type": "method"
        },
        "index": {
          "hierarchy": "Language TTF",
          "module": "Language.TTF",
          "name": "app",
          "normalized": "a(b-\u003ec)-\u003ea b-\u003ea c",
          "package": "liboleg",
          "signature": "repr(a-\u003eb)-\u003erepr a-\u003erepr b",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TTF.html#v:app"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TTF",
          "name": "bool",
          "package": "liboleg",
          "signature": "Bool -\u003e repr Bool",
          "source": "src/Language-TTF.html#bool",
          "type": "method"
        },
        "index": {
          "hierarchy": "Language TTF",
          "module": "Language.TTF",
          "name": "bool",
          "normalized": "Bool-\u003ea Bool",
          "package": "liboleg",
          "signature": "Bool-\u003erepr Bool",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TTF.html#v:bool"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TTF",
          "name": "fix",
          "package": "liboleg",
          "signature": "(repr a -\u003e repr a) -\u003e repr a",
          "source": "src/Language-TTF.html#fix",
          "type": "method"
        },
        "index": {
          "hierarchy": "Language TTF",
          "module": "Language.TTF",
          "name": "fix",
          "normalized": "(a b-\u003ea b)-\u003ea b",
          "package": "liboleg",
          "signature": "(repr a-\u003erepr a)-\u003erepr a",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TTF.html#v:fix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TTF",
          "name": "if_",
          "package": "liboleg",
          "signature": "repr Bool -\u003e repr a -\u003e repr a -\u003e repr a",
          "source": "src/Language-TTF.html#if_",
          "type": "method"
        },
        "index": {
          "hierarchy": "Language TTF",
          "module": "Language.TTF",
          "name": "if_",
          "normalized": "a Bool-\u003ea b-\u003ea b-\u003ea b",
          "package": "liboleg",
          "signature": "repr Bool-\u003erepr a-\u003erepr a-\u003erepr a",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TTF.html#v:if_"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TTF",
          "name": "int",
          "package": "liboleg",
          "signature": "Int -\u003e repr Int",
          "source": "src/Language-TTF.html#int",
          "type": "method"
        },
        "index": {
          "hierarchy": "Language TTF",
          "module": "Language.TTF",
          "name": "int",
          "normalized": "Int-\u003ea Int",
          "package": "liboleg",
          "signature": "Int-\u003erepr Int",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TTF.html#v:int"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TTF",
          "name": "lam",
          "package": "liboleg",
          "signature": "(repr a -\u003e repr b) -\u003e repr (a -\u003e b)",
          "source": "src/Language-TTF.html#lam",
          "type": "method"
        },
        "index": {
          "hierarchy": "Language TTF",
          "module": "Language.TTF",
          "name": "lam",
          "normalized": "(a b-\u003ea c)-\u003ea(b-\u003ec)",
          "package": "liboleg",
          "signature": "(repr a-\u003erepr b)-\u003erepr(a-\u003eb)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TTF.html#v:lam"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TTF",
          "name": "leq",
          "package": "liboleg",
          "signature": "repr Int -\u003e repr Int -\u003e repr Bool",
          "source": "src/Language-TTF.html#leq",
          "type": "method"
        },
        "index": {
          "hierarchy": "Language TTF",
          "module": "Language.TTF",
          "name": "leq",
          "normalized": "a Int-\u003ea Int-\u003ea Bool",
          "package": "liboleg",
          "signature": "repr Int-\u003erepr Int-\u003erepr Bool",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TTF.html#v:leq"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TTF",
          "name": "mul",
          "package": "liboleg",
          "signature": "repr Int -\u003e repr Int -\u003e repr Int",
          "source": "src/Language-TTF.html#mul",
          "type": "method"
        },
        "index": {
          "hierarchy": "Language TTF",
          "module": "Language.TTF",
          "name": "mul",
          "normalized": "a Int-\u003ea Int-\u003ea Int",
          "package": "liboleg",
          "signature": "repr Int-\u003erepr Int-\u003erepr Int",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TTF.html#v:mul"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TTF",
          "name": "unR",
          "package": "liboleg",
          "signature": "a",
          "source": "src/Language-TTF.html#R",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language TTF",
          "module": "Language.TTF",
          "name": "unR",
          "package": "liboleg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TTF.html#v:unR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TTF",
          "name": "unS",
          "package": "liboleg",
          "signature": "VarCounter -\u003e String",
          "source": "src/Language-TTF.html#S",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language TTF",
          "module": "Language.TTF",
          "name": "unS",
          "normalized": "VarCounter-\u003eString",
          "package": "liboleg",
          "signature": "VarCounter-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TTF.html#v:unS"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cul\u003e\u003cli\u003e Essentially, Haskell98!\n * Typed tagless-final interpreters for simply-typed lambda-calculus\n * de Bruijn indices\n based on the code accompanying the paper by\n   Jacques Carette, Oleg Kiselyov, and Chung-chieh Shan\n\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e",
          "module": "Language.TTFdB",
          "name": "TTFdB",
          "package": "liboleg",
          "source": "src/Language-TTFdB.html",
          "type": "module"
        },
        "index": {
          "description": "Essentially Haskell98 Typed tagless-final interpreters for simply-typed lambda-calculus de Bruijn indices based on the code accompanying the paper by Jacques Carette Oleg Kiselyov and Chung-chieh Shan",
          "hierarchy": "Language TTFdB",
          "module": "Language.TTFdB",
          "name": "TTFdB",
          "package": "liboleg",
          "partial": "TTFd",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TTFdB.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TTFdB",
          "name": "R",
          "package": "liboleg",
          "source": "src/Language-TTFdB.html#R",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "Language TTFdB",
          "module": "Language.TTFdB",
          "name": "R",
          "package": "liboleg",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TTFdB.html#t:R"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TTFdB",
          "name": "S",
          "package": "liboleg",
          "source": "src/Language-TTFdB.html#S",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "Language TTFdB",
          "module": "Language.TTFdB",
          "name": "S",
          "package": "liboleg",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TTFdB.html#t:S"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TTFdB",
          "name": "Symantics",
          "package": "liboleg",
          "source": "src/Language-TTFdB.html#Symantics",
          "type": "class"
        },
        "index": {
          "hierarchy": "Language TTFdB",
          "module": "Language.TTFdB",
          "name": "Symantics",
          "package": "liboleg",
          "partial": "Symantics",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TTFdB.html#t:Symantics"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TTFdB",
          "name": "R",
          "package": "liboleg",
          "signature": "R",
          "source": "src/Language-TTFdB.html#R",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language TTFdB",
          "module": "Language.TTFdB",
          "name": "R",
          "package": "liboleg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TTFdB.html#v:R"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TTFdB",
          "name": "S",
          "package": "liboleg",
          "signature": "S",
          "source": "src/Language-TTFdB.html#S",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language TTFdB",
          "module": "Language.TTFdB",
          "name": "S",
          "package": "liboleg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TTFdB.html#v:S"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TTFdB",
          "name": "add",
          "package": "liboleg",
          "signature": "repr h Int -\u003e repr h Int -\u003e repr h Int",
          "source": "src/Language-TTFdB.html#add",
          "type": "method"
        },
        "index": {
          "hierarchy": "Language TTFdB",
          "module": "Language.TTFdB",
          "name": "add",
          "normalized": "a b Int-\u003ea b Int-\u003ea b Int",
          "package": "liboleg",
          "signature": "repr h Int-\u003erepr h Int-\u003erepr h Int",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TTFdB.html#v:add"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TTFdB",
          "name": "app",
          "package": "liboleg",
          "signature": "repr h (a -\u003e b) -\u003e repr h a -\u003e repr h b",
          "source": "src/Language-TTFdB.html#app",
          "type": "method"
        },
        "index": {
          "hierarchy": "Language TTFdB",
          "module": "Language.TTFdB",
          "name": "app",
          "normalized": "a b(c-\u003ed)-\u003ea b c-\u003ea b d",
          "package": "liboleg",
          "signature": "repr h(a-\u003eb)-\u003erepr h a-\u003erepr h b",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TTFdB.html#v:app"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TTFdB",
          "name": "int",
          "package": "liboleg",
          "signature": "Int -\u003e repr h Int",
          "source": "src/Language-TTFdB.html#int",
          "type": "method"
        },
        "index": {
          "hierarchy": "Language TTFdB",
          "module": "Language.TTFdB",
          "name": "int",
          "normalized": "Int-\u003ea b Int",
          "package": "liboleg",
          "signature": "Int-\u003erepr h Int",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TTFdB.html#v:int"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TTFdB",
          "name": "lam",
          "package": "liboleg",
          "signature": "repr (a, h) b -\u003e repr h (a -\u003e b)",
          "source": "src/Language-TTFdB.html#lam",
          "type": "method"
        },
        "index": {
          "hierarchy": "Language TTFdB",
          "module": "Language.TTFdB",
          "name": "lam",
          "normalized": "a(b,c)d-\u003ea c(b-\u003ed)",
          "package": "liboleg",
          "signature": "repr(a,h)b-\u003erepr h(a-\u003eb)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TTFdB.html#v:lam"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TTFdB",
          "name": "s",
          "package": "liboleg",
          "signature": "repr h a -\u003e repr (any, h) a",
          "source": "src/Language-TTFdB.html#s",
          "type": "method"
        },
        "index": {
          "hierarchy": "Language TTFdB",
          "module": "Language.TTFdB",
          "name": "s",
          "normalized": "a b c-\u003ea(d,b)c",
          "package": "liboleg",
          "signature": "repr h a-\u003erepr(any,h)a",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TTFdB.html#v:s"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TTFdB",
          "name": "unR",
          "package": "liboleg",
          "signature": "h -\u003e a",
          "source": "src/Language-TTFdB.html#R",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language TTFdB",
          "module": "Language.TTFdB",
          "name": "unR",
          "normalized": "a-\u003eb",
          "package": "liboleg",
          "signature": "h-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TTFdB.html#v:unR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TTFdB",
          "name": "unS",
          "package": "liboleg",
          "signature": "[String] -\u003e String",
          "source": "src/Language-TTFdB.html#S",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language TTFdB",
          "module": "Language.TTFdB",
          "name": "unS",
          "normalized": "[String]-\u003eString",
          "package": "liboleg",
          "signature": "[String]-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TTFdB.html#v:unS"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TTFdB",
          "name": "view",
          "package": "liboleg",
          "signature": "S () a -\u003e String",
          "source": "src/Language-TTFdB.html#view",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language TTFdB",
          "module": "Language.TTFdB",
          "name": "view",
          "normalized": "S()a-\u003eString",
          "package": "liboleg",
          "signature": "S()a-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TTFdB.html#v:view"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TTFdB",
          "name": "z",
          "package": "liboleg",
          "signature": "repr (a, h) a",
          "source": "src/Language-TTFdB.html#z",
          "type": "method"
        },
        "index": {
          "hierarchy": "Language TTFdB",
          "module": "Language.TTFdB",
          "name": "z",
          "normalized": "a(b,c)b",
          "package": "liboleg",
          "signature": "repr(a,h)a",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TTFdB.html#v:z"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.ToTDPE",
          "name": "ToTDPE",
          "package": "liboleg",
          "source": "src/Language-ToTDPE.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Language ToTDPE",
          "module": "Language.ToTDPE",
          "name": "ToTDPE",
          "package": "liboleg",
          "partial": "To TDPE",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-ToTDPE.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cul\u003e\u003cli\u003e Type representation, equality and the safe typecast:\n * the above-the-board version of Data.Typeable\n\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e",
          "module": "Language.Typ",
          "name": "Typ",
          "package": "liboleg",
          "source": "src/Language-Typ.html",
          "type": "module"
        },
        "index": {
          "description": "Type representation equality and the safe typecast the above-the-board version of Data.Typeable",
          "hierarchy": "Language Typ",
          "module": "Language.Typ",
          "name": "Typ",
          "package": "liboleg",
          "partial": "Typ",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-Typ.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Typ",
          "name": "AsArrow",
          "package": "liboleg",
          "source": "src/Language-Typ.html#AsArrow",
          "type": "data"
        },
        "index": {
          "hierarchy": "Language Typ",
          "module": "Language.Typ",
          "name": "AsArrow",
          "package": "liboleg",
          "partial": "As Arrow",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-Typ.html#t:AsArrow"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Typ",
          "name": "AsInt",
          "package": "liboleg",
          "source": "src/Language-Typ.html#AsInt",
          "type": "data"
        },
        "index": {
          "hierarchy": "Language Typ",
          "module": "Language.Typ",
          "name": "AsInt",
          "package": "liboleg",
          "partial": "As Int",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-Typ.html#t:AsInt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Typ",
          "name": "Dynamic",
          "package": "liboleg",
          "source": "src/Language-Typ.html#Dynamic",
          "type": "data"
        },
        "index": {
          "hierarchy": "Language Typ",
          "module": "Language.Typ",
          "name": "Dynamic",
          "package": "liboleg",
          "partial": "Dynamic",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-Typ.html#t:Dynamic"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Typ",
          "name": "EQU",
          "package": "liboleg",
          "source": "src/Language-Typ.html#EQU",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "Language Typ",
          "module": "Language.Typ",
          "name": "EQU",
          "package": "liboleg",
          "partial": "EQU",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-Typ.html#t:EQU"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Typ",
          "name": "F1",
          "package": "liboleg",
          "source": "src/Language-Typ.html#F1",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "Language Typ",
          "module": "Language.Typ",
          "name": "F1",
          "package": "liboleg",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-Typ.html#t:F1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Typ",
          "name": "F2",
          "package": "liboleg",
          "source": "src/Language-Typ.html#F2",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "Language Typ",
          "module": "Language.Typ",
          "name": "F2",
          "package": "liboleg",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-Typ.html#t:F2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Typ",
          "name": "FS",
          "package": "liboleg",
          "source": "src/Language-Typ.html#FS",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "Language Typ",
          "module": "Language.Typ",
          "name": "FS",
          "package": "liboleg",
          "partial": "FS",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-Typ.html#t:FS"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Typ",
          "name": "Id",
          "package": "liboleg",
          "source": "src/Language-Typ.html#Id",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "Language Typ",
          "module": "Language.Typ",
          "name": "Id",
          "package": "liboleg",
          "partial": "Id",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-Typ.html#t:Id"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Typ",
          "name": "SafeCast",
          "package": "liboleg",
          "source": "src/Language-Typ.html#SafeCast",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "Language Typ",
          "module": "Language.Typ",
          "name": "SafeCast",
          "package": "liboleg",
          "partial": "Safe Cast",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-Typ.html#t:SafeCast"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe implementation of the interpreter ShowAs shows off\n the technique of accumulating new TQ as we traverse the old\n one. We shall see more examples later.\n One is again reminded of attribute grammars.\n\u003c/p\u003e",
          "module": "Language.Typ",
          "name": "ShowAs",
          "package": "liboleg",
          "source": "src/Language-Typ.html#ShowAs",
          "type": "data"
        },
        "index": {
          "description": "The implementation of the interpreter ShowAs shows off the technique of accumulating new TQ as we traverse the old one We shall see more examples later One is again reminded of attribute grammars",
          "hierarchy": "Language Typ",
          "module": "Language.Typ",
          "name": "ShowAs",
          "package": "liboleg",
          "partial": "Show As",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-Typ.html#t:ShowAs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cul\u003e\u003cli\u003e The view interpreter\n The first interpreter is to view the types\n\u003c/li\u003e\u003c/ul\u003e",
          "module": "Language.Typ",
          "name": "ShowT",
          "package": "liboleg",
          "source": "src/Language-Typ.html#ShowT",
          "type": "newtype"
        },
        "index": {
          "description": "The view interpreter The first interpreter is to view the types",
          "hierarchy": "Language Typ",
          "module": "Language.Typ",
          "name": "ShowT",
          "package": "liboleg",
          "partial": "Show",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-Typ.html#t:ShowT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Typ",
          "name": "TCOPY",
          "package": "liboleg",
          "source": "src/Language-Typ.html#TCOPY",
          "type": "data"
        },
        "index": {
          "hierarchy": "Language Typ",
          "module": "Language.Typ",
          "name": "TCOPY",
          "package": "liboleg",
          "partial": "TCOPY",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-Typ.html#t:TCOPY"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Typ",
          "name": "TQ",
          "package": "liboleg",
          "source": "src/Language-Typ.html#TQ",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "Language Typ",
          "module": "Language.Typ",
          "name": "TQ",
          "package": "liboleg",
          "partial": "TQ",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-Typ.html#t:TQ"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cul\u003e\u003cli\u003e The language of type representations: first-order and typed\n It is quite like the language of int\u003cem\u003eneg\u003c/em\u003eadd we have seen before,\n but it is now typed.\n It is first order: the language of simple types is first order\n\u003c/li\u003e\u003c/ul\u003e",
          "module": "Language.Typ",
          "name": "TSYM",
          "package": "liboleg",
          "source": "src/Language-Typ.html#TSYM",
          "type": "class"
        },
        "index": {
          "description": "The language of type representations first-order and typed It is quite like the language of int neg add we have seen before but it is now typed It is first order the language of simple types is first order",
          "hierarchy": "Language Typ",
          "module": "Language.Typ",
          "name": "TSYM",
          "package": "liboleg",
          "partial": "TSYM",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-Typ.html#t:TSYM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Typ",
          "name": "Typ",
          "package": "liboleg",
          "source": "src/Language-Typ.html#Typ",
          "type": "data"
        },
        "index": {
          "hierarchy": "Language Typ",
          "module": "Language.Typ",
          "name": "Typ",
          "package": "liboleg",
          "partial": "Typ",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-Typ.html#t:Typ"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Typ",
          "name": "AsArrow",
          "package": "liboleg",
          "signature": "forall b1 b2 . AsArrow (TQ a) (Maybe (TQ b1, TQ b2, EQU a (b1 -\u003e b2)))",
          "source": "src/Language-Typ.html#AsArrow",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Typ",
          "module": "Language.Typ",
          "name": "AsArrow",
          "normalized": "a b b AsArrow(TQ c)(Maybe(TQ b,TQ b,EQU c(b-\u003eb)))",
          "package": "liboleg",
          "partial": "As Arrow",
          "signature": "forall b b AsArrow(TQ a)(Maybe(TQ b,TQ b,EQU a(b-\u003eb)))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-Typ.html#v:AsArrow"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Typ",
          "name": "AsInt",
          "package": "liboleg",
          "signature": "AsInt (Maybe (EQU a Int))",
          "source": "src/Language-Typ.html#AsInt",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Typ",
          "module": "Language.Typ",
          "name": "AsInt",
          "package": "liboleg",
          "partial": "As Int",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-Typ.html#v:AsInt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Typ",
          "name": "Dynamic",
          "package": "liboleg",
          "signature": "forall t . Dynamic (TQ t) t",
          "source": "src/Language-Typ.html#Dynamic",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Typ",
          "module": "Language.Typ",
          "name": "Dynamic",
          "package": "liboleg",
          "partial": "Dynamic",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-Typ.html#v:Dynamic"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Typ",
          "name": "EQU",
          "package": "liboleg",
          "signature": "EQU",
          "source": "src/Language-Typ.html#EQU",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Typ",
          "module": "Language.Typ",
          "name": "EQU",
          "package": "liboleg",
          "partial": "EQU",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-Typ.html#v:EQU"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Typ",
          "name": "F1",
          "package": "liboleg",
          "signature": "F1",
          "source": "src/Language-Typ.html#F1",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Typ",
          "module": "Language.Typ",
          "name": "F1",
          "package": "liboleg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-Typ.html#v:F1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Typ",
          "name": "F2",
          "package": "liboleg",
          "signature": "F2",
          "source": "src/Language-Typ.html#F2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Typ",
          "module": "Language.Typ",
          "name": "F2",
          "package": "liboleg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-Typ.html#v:F2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Typ",
          "name": "FS",
          "package": "liboleg",
          "signature": "FS",
          "source": "src/Language-Typ.html#FS",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Typ",
          "module": "Language.Typ",
          "name": "FS",
          "package": "liboleg",
          "partial": "FS",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-Typ.html#v:FS"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Typ",
          "name": "Id",
          "package": "liboleg",
          "signature": "Id a",
          "source": "src/Language-Typ.html#Id",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Typ",
          "module": "Language.Typ",
          "name": "Id",
          "package": "liboleg",
          "partial": "Id",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-Typ.html#v:Id"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Typ",
          "name": "SafeCast",
          "package": "liboleg",
          "signature": "SafeCast (forall b.  TQ b -\u003e Maybe (EQU a b))",
          "source": "src/Language-Typ.html#SafeCast",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Typ",
          "module": "Language.Typ",
          "name": "SafeCast",
          "normalized": "SafeCast(a b TQ c-\u003eMaybe(EQU d c))",
          "package": "liboleg",
          "partial": "Safe Cast",
          "signature": "SafeCast(forall b. TQ b-\u003eMaybe(EQU a b))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-Typ.html#v:SafeCast"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Typ",
          "name": "ShowAs",
          "package": "liboleg",
          "signature": "ShowAs (TQ a) (a -\u003e String)",
          "source": "src/Language-Typ.html#ShowAs",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Typ",
          "module": "Language.Typ",
          "name": "ShowAs",
          "normalized": "ShowAs(TQ a)(a-\u003eString)",
          "package": "liboleg",
          "partial": "Show As",
          "signature": "ShowAs(TQ a)(a-\u003eString)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-Typ.html#v:ShowAs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Typ",
          "name": "ShowT",
          "package": "liboleg",
          "signature": "ShowT String",
          "source": "src/Language-Typ.html#ShowT",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Typ",
          "module": "Language.Typ",
          "name": "ShowT",
          "package": "liboleg",
          "partial": "Show",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-Typ.html#v:ShowT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Typ",
          "name": "TCOPY",
          "package": "liboleg",
          "signature": "TCOPY (trep1 a) (trep2 a)",
          "source": "src/Language-Typ.html#TCOPY",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Typ",
          "module": "Language.Typ",
          "name": "TCOPY",
          "package": "liboleg",
          "partial": "TCOPY",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-Typ.html#v:TCOPY"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Typ",
          "name": "TQ",
          "package": "liboleg",
          "signature": "TQ",
          "source": "src/Language-Typ.html#TQ",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Typ",
          "module": "Language.Typ",
          "name": "TQ",
          "package": "liboleg",
          "partial": "TQ",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-Typ.html#v:TQ"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Typ",
          "name": "Typ",
          "package": "liboleg",
          "signature": "forall t . Typ (TQ t)",
          "source": "src/Language-Typ.html#Typ",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Typ",
          "module": "Language.Typ",
          "name": "Typ",
          "package": "liboleg",
          "partial": "Typ",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-Typ.html#v:Typ"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Typ",
          "name": "as_arrow",
          "package": "liboleg",
          "signature": "AsArrow a -\u003e AsArrow a",
          "source": "src/Language-Typ.html#as_arrow",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Typ",
          "module": "Language.Typ",
          "name": "as_arrow",
          "normalized": "AsArrow a-\u003eAsArrow a",
          "package": "liboleg",
          "signature": "AsArrow a-\u003eAsArrow a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-Typ.html#v:as_arrow"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Typ",
          "name": "as_int",
          "package": "liboleg",
          "signature": "AsInt a -\u003e c a -\u003e Maybe (c Int)",
          "source": "src/Language-Typ.html#as_int",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Typ",
          "module": "Language.Typ",
          "name": "as_int",
          "normalized": "AsInt a-\u003eb a-\u003eMaybe(b Int)",
          "package": "liboleg",
          "signature": "AsInt a-\u003ec a-\u003eMaybe(c Int)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-Typ.html#v:as_int"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Typ",
          "name": "eq_arr",
          "package": "liboleg",
          "signature": "EQU a1 a2 -\u003e EQU b1 b2 -\u003e EQU (a1 -\u003e b1) (a2 -\u003e b2)",
          "source": "src/Language-Typ.html#eq_arr",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Typ",
          "module": "Language.Typ",
          "name": "eq_arr",
          "normalized": "EQU a a-\u003eEQU b b-\u003eEQU(a-\u003eb)(a-\u003eb)",
          "package": "liboleg",
          "signature": "EQU a a-\u003eEQU b b-\u003eEQU(a-\u003eb)(a-\u003eb)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-Typ.html#v:eq_arr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Typ",
          "name": "equ_cast",
          "package": "liboleg",
          "signature": "forall c.  c a -\u003e c b",
          "source": "src/Language-Typ.html#EQU",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Typ",
          "module": "Language.Typ",
          "name": "equ_cast",
          "normalized": "a b c d-\u003ec e",
          "package": "liboleg",
          "signature": "forall c. c a-\u003ec b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-Typ.html#v:equ_cast"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Typ",
          "name": "refl",
          "package": "liboleg",
          "signature": "EQU a a",
          "source": "src/Language-Typ.html#refl",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Typ",
          "module": "Language.Typ",
          "name": "refl",
          "package": "liboleg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-Typ.html#v:refl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Typ",
          "name": "safe_gcast",
          "package": "liboleg",
          "signature": "TQ a -\u003e c a -\u003e TQ b -\u003e Maybe (c b)",
          "source": "src/Language-Typ.html#safe_gcast",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Typ",
          "module": "Language.Typ",
          "name": "safe_gcast",
          "normalized": "TQ a-\u003eb a-\u003eTQ c-\u003eMaybe(b c)",
          "package": "liboleg",
          "signature": "TQ a-\u003ec a-\u003eTQ b-\u003eMaybe(c b)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-Typ.html#v:safe_gcast"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Typ",
          "name": "show_as",
          "package": "liboleg",
          "signature": "TQ a -\u003e a -\u003e String",
          "source": "src/Language-Typ.html#show_as",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Typ",
          "module": "Language.Typ",
          "name": "show_as",
          "normalized": "TQ a-\u003ea-\u003eString",
          "package": "liboleg",
          "signature": "TQ a-\u003ea-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-Typ.html#v:show_as"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Typ",
          "name": "symm",
          "package": "liboleg",
          "signature": "EQU a b -\u003e EQU b a",
          "source": "src/Language-Typ.html#symm",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Typ",
          "module": "Language.Typ",
          "name": "symm",
          "normalized": "EQU a b-\u003eEQU b a",
          "package": "liboleg",
          "signature": "EQU a b-\u003eEQU b a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-Typ.html#v:symm"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Typ",
          "name": "tarr",
          "package": "liboleg",
          "signature": "trepr a -\u003e trepr b -\u003e trepr (a -\u003e b)",
          "source": "src/Language-Typ.html#tarr",
          "type": "method"
        },
        "index": {
          "hierarchy": "Language Typ",
          "module": "Language.Typ",
          "name": "tarr",
          "normalized": "a b-\u003ea c-\u003ea(b-\u003ec)",
          "package": "liboleg",
          "signature": "trepr a-\u003etrepr b-\u003etrepr(a-\u003eb)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-Typ.html#v:tarr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Typ",
          "name": "tint",
          "package": "liboleg",
          "signature": "trepr Int",
          "source": "src/Language-Typ.html#tint",
          "type": "method"
        },
        "index": {
          "hierarchy": "Language Typ",
          "module": "Language.Typ",
          "name": "tint",
          "package": "liboleg",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-Typ.html#v:tint"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Typ",
          "name": "tran",
          "package": "liboleg",
          "signature": "EQU a u -\u003e EQU u b -\u003e EQU a b",
          "source": "src/Language-Typ.html#tran",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Typ",
          "module": "Language.Typ",
          "name": "tran",
          "normalized": "EQU a b-\u003eEQU b c-\u003eEQU a c",
          "package": "liboleg",
          "signature": "EQU a u-\u003eEQU u b-\u003eEQU a b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-Typ.html#v:tran"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Typ",
          "name": "unF1",
          "package": "liboleg",
          "signature": "EQU t (a -\u003e b)",
          "source": "src/Language-Typ.html#F1",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Typ",
          "module": "Language.Typ",
          "name": "unF1",
          "normalized": "EQU a(b-\u003ec)",
          "package": "liboleg",
          "signature": "EQU t(a-\u003eb)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-Typ.html#v:unF1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Typ",
          "name": "unF2",
          "package": "liboleg",
          "signature": "EQU t (a -\u003e b)",
          "source": "src/Language-Typ.html#F2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Typ",
          "module": "Language.Typ",
          "name": "unF2",
          "normalized": "EQU a(b-\u003ec)",
          "package": "liboleg",
          "signature": "EQU t(a-\u003eb)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-Typ.html#v:unF2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Typ",
          "name": "unFS",
          "package": "liboleg",
          "signature": "EQU a b",
          "source": "src/Language-Typ.html#FS",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Typ",
          "module": "Language.Typ",
          "name": "unFS",
          "package": "liboleg",
          "partial": "FS",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-Typ.html#v:unFS"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Typ",
          "name": "unTQ",
          "package": "liboleg",
          "signature": "trepr t",
          "source": "src/Language-Typ.html#TQ",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Typ",
          "module": "Language.Typ",
          "name": "unTQ",
          "package": "liboleg",
          "partial": "TQ",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-Typ.html#v:unTQ"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Typ",
          "name": "view_t",
          "package": "liboleg",
          "signature": "ShowT a -\u003e String",
          "source": "src/Language-Typ.html#view_t",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Typ",
          "module": "Language.Typ",
          "name": "view_t",
          "normalized": "ShowT a-\u003eString",
          "package": "liboleg",
          "signature": "ShowT a-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-Typ.html#v:view_t"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eWhy all these extensions?\n I could've cheated a bit and gotten by without the last four:\n the function typecheck below is partial anyway.\n If we permit one sort of errors (when the deserialized term is\n ill-typed), we may as well permit another sort of errors\n (a closed-looking term turns out open), even if the\n latter sort of  error can't arise if our typecheck function is correct.\n due to the desire to let GHC check some correctness properties\n I wanted to avoid unnecessary errors and let GHC see the\n correctness of my code to a larger extent\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Language.TypeCheck",
          "name": "TypeCheck",
          "package": "liboleg",
          "source": "src/Language-TypeCheck.html",
          "type": "module"
        },
        "index": {
          "description": "Why all these extensions could ve cheated bit and gotten by without the last four the function typecheck below is partial anyway If we permit one sort of errors when the deserialized term is ill-typed we may as well permit another sort of errors closed-looking term turns out open even if the latter sort of error can arise if our typecheck function is correct due to the desire to let GHC check some correctness properties wanted to avoid unnecessary errors and let GHC see the correctness of my code to larger extent",
          "hierarchy": "Language TypeCheck",
          "module": "Language.TypeCheck",
          "name": "TypeCheck",
          "package": "liboleg",
          "partial": "Type Check",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TypeCheck.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TypeCheck",
          "name": "CL",
          "package": "liboleg",
          "source": "src/Language-TypeCheck.html#CL",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "Language TypeCheck",
          "module": "Language.TypeCheck",
          "name": "CL",
          "package": "liboleg",
          "partial": "CL",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TypeCheck.html#t:CL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TypeCheck",
          "name": "DynTerm",
          "package": "liboleg",
          "source": "src/Language-TypeCheck.html#DynTerm",
          "type": "data"
        },
        "index": {
          "hierarchy": "Language TypeCheck",
          "module": "Language.TypeCheck",
          "name": "DynTerm",
          "package": "liboleg",
          "partial": "Dyn Term",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TypeCheck.html#t:DynTerm"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TypeCheck",
          "name": "Tree",
          "package": "liboleg",
          "source": "src/Language-TypeCheck.html#Tree",
          "type": "data"
        },
        "index": {
          "hierarchy": "Language TypeCheck",
          "module": "Language.TypeCheck",
          "name": "Tree",
          "package": "liboleg",
          "partial": "Tree",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TypeCheck.html#t:Tree"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TypeCheck",
          "name": "Var",
          "package": "liboleg",
          "source": "src/Language-TypeCheck.html#Var",
          "type": "class"
        },
        "index": {
          "hierarchy": "Language TypeCheck",
          "module": "Language.TypeCheck",
          "name": "Var",
          "package": "liboleg",
          "partial": "Var",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TypeCheck.html#t:Var"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TypeCheck",
          "name": "VarDesc",
          "package": "liboleg",
          "source": "src/Language-TypeCheck.html#VarDesc",
          "type": "data"
        },
        "index": {
          "hierarchy": "Language TypeCheck",
          "module": "Language.TypeCheck",
          "name": "VarDesc",
          "package": "liboleg",
          "partial": "Var Desc",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TypeCheck.html#t:VarDesc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TypeCheck",
          "name": "VarName",
          "package": "liboleg",
          "source": "src/Language-TypeCheck.html#VarName",
          "type": "type"
        },
        "index": {
          "hierarchy": "Language TypeCheck",
          "module": "Language.TypeCheck",
          "name": "VarName",
          "package": "liboleg",
          "partial": "Var Name",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TypeCheck.html#t:VarName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TypeCheck",
          "name": "CL",
          "package": "liboleg",
          "signature": "CL",
          "source": "src/Language-TypeCheck.html#CL",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language TypeCheck",
          "module": "Language.TypeCheck",
          "name": "CL",
          "package": "liboleg",
          "partial": "CL",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TypeCheck.html#v:CL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TypeCheck",
          "name": "DynTerm",
          "package": "liboleg",
          "signature": "forall a . DynTerm (TQ a) (repr h a)",
          "source": "src/Language-TypeCheck.html#DynTerm",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language TypeCheck",
          "module": "Language.TypeCheck",
          "name": "DynTerm",
          "package": "liboleg",
          "partial": "Dyn Term",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TypeCheck.html#v:DynTerm"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TypeCheck",
          "name": "Leaf",
          "package": "liboleg",
          "signature": "Leaf String",
          "source": "src/Language-TypeCheck.html#Tree",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language TypeCheck",
          "module": "Language.TypeCheck",
          "name": "Leaf",
          "package": "liboleg",
          "partial": "Leaf",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TypeCheck.html#v:Leaf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TypeCheck",
          "name": "Node",
          "package": "liboleg",
          "signature": "Node String [Tree]",
          "source": "src/Language-TypeCheck.html#Tree",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language TypeCheck",
          "module": "Language.TypeCheck",
          "name": "Node",
          "normalized": "Node String[Tree]",
          "package": "liboleg",
          "partial": "Node",
          "signature": "Node String[Tree]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TypeCheck.html#v:Node"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TypeCheck",
          "name": "VarDesc",
          "package": "liboleg",
          "signature": "VarDesc (TQ t) VarName",
          "source": "src/Language-TypeCheck.html#VarDesc",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language TypeCheck",
          "module": "Language.TypeCheck",
          "name": "VarDesc",
          "package": "liboleg",
          "partial": "Var Desc",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TypeCheck.html#v:VarDesc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TypeCheck",
          "name": "asTypeRepr",
          "package": "liboleg",
          "signature": "t -\u003e repr h t -\u003e repr h t",
          "source": "src/Language-TypeCheck.html#asTypeRepr",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language TypeCheck",
          "module": "Language.TypeCheck",
          "name": "asTypeRepr",
          "normalized": "a-\u003eb c a-\u003eb c a",
          "package": "liboleg",
          "partial": "Type Repr",
          "signature": "t-\u003erepr h t-\u003erepr h t",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TypeCheck.html#v:asTypeRepr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TypeCheck",
          "name": "findvar",
          "package": "liboleg",
          "signature": "VarName -\u003e gamma -\u003e Either String (DynTerm repr h)",
          "source": "src/Language-TypeCheck.html#findvar",
          "type": "method"
        },
        "index": {
          "hierarchy": "Language TypeCheck",
          "module": "Language.TypeCheck",
          "name": "findvar",
          "normalized": "VarName-\u003ea-\u003eEither String(DynTerm b c)",
          "package": "liboleg",
          "signature": "VarName-\u003egamma-\u003eEither String(DynTerm repr h)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TypeCheck.html#v:findvar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TypeCheck",
          "name": "read_t",
          "package": "liboleg",
          "signature": "Tree -\u003e Either String Typ",
          "source": "src/Language-TypeCheck.html#read_t",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language TypeCheck",
          "module": "Language.TypeCheck",
          "name": "read_t",
          "normalized": "Tree-\u003eEither String Typ",
          "package": "liboleg",
          "signature": "Tree-\u003eEither String Typ",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TypeCheck.html#v:read_t"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TypeCheck",
          "name": "typecheck",
          "package": "liboleg",
          "signature": "Tree -\u003e gamma -\u003e Either String (DynTerm repr h)",
          "source": "src/Language-TypeCheck.html#typecheck",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language TypeCheck",
          "module": "Language.TypeCheck",
          "name": "typecheck",
          "normalized": "Tree-\u003ea-\u003eEither String(DynTerm b c)",
          "package": "liboleg",
          "signature": "Tree-\u003egamma-\u003eEither String(DynTerm repr h)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TypeCheck.html#v:typecheck"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TypeCheck",
          "name": "unCL",
          "package": "liboleg",
          "signature": "repr h a",
          "source": "src/Language-TypeCheck.html#CL",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language TypeCheck",
          "module": "Language.TypeCheck",
          "name": "unCL",
          "package": "liboleg",
          "partial": "CL",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TypeCheck.html#v:unCL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003e\u003ca\u003ehttp://okmij.org/ftp/Haskell/types.html#computable-types\u003c/a\u003e\n\u003c/p\u003e\u003cp\u003ePart I of the series introduced the type-level functional language\n with the notation that resembles lambda-calculus with case\n distinction, fixpoint recursion, etc. Modulo a bit of syntactic tart,\n the language of the type functions even looks almost like the pure\n Haskell.  In this message, we show the applications of computable\n types, to ascribe signatures to terms and to drive the selection of\n overloaded functions.  We can compute the type of a tree of the depth\n fib(N) or a complex XML type, and instantiate the read function to\n read the trees of only that shape.\n\u003c/p\u003e\u003cp\u003eA telling example of the power of the approach is the ability to use\n not only (a-\u003e) but also (-\u003ea) as an unary type function. The former is\n just (-\u003e) a. The latter is considered impossible.  In our approach,\n (-\u003ea) is written almost literally as (flip (-\u003e) a)\n\u003c/p\u003e\u003cp\u003eThis series of messages has been inspired by Luca Cardelli's 1988\n manuscript ``Phase Distinctions in Type Theory''\n        \u003ca\u003ehttp://lucacardelli.name/Papers/PhaseDistinctions.pdf\u003c/a\u003e\n and by Simon Peyton Jones and Erik Meijer's ``Henk: A Typed\n Intermediate Language''\n        \u003ca\u003ehttp://www.research.microsoft.com/~simonpj/Papers/henk.ps.gz\u003c/a\u003e\n which expounds many of the same notions in an excellent tutorial style\n and in modern terminology.\n\u003c/p\u003e\u003cp\u003eI'm very grateful to Chung-chieh Shan for pointing out these papers to\n me and for thought-provoking discussions.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Language.TypeFN",
          "name": "TypeFN",
          "package": "liboleg",
          "source": "src/Language-TypeFN.html",
          "type": "module"
        },
        "index": {
          "description": "http okmij.org ftp Haskell types.html computable-types Part of the series introduced the type-level functional language with the notation that resembles lambda-calculus with case distinction fixpoint recursion etc Modulo bit of syntactic tart the language of the type functions even looks almost like the pure Haskell In this message we show the applications of computable types to ascribe signatures to terms and to drive the selection of overloaded functions We can compute the type of tree of the depth fib or complex XML type and instantiate the read function to read the trees of only that shape telling example of the power of the approach is the ability to use not only but also as an unary type function The former is just The latter is considered impossible In our approach is written almost literally as flip This series of messages has been inspired by Luca Cardelli manuscript Phase Distinctions in Type Theory http lucacardelli.name Papers PhaseDistinctions.pdf and by Simon Peyton Jones and Erik Meijer Henk Typed Intermediate Language http www.research.microsoft.com simonpj Papers henk.ps.gz which expounds many of the same notions in an excellent tutorial style and in modern terminology very grateful to Chung-chieh Shan for pointing out these papers to me and for thought-provoking discussions",
          "hierarchy": "Language TypeFN",
          "module": "Language.TypeFN",
          "name": "TypeFN",
          "package": "liboleg",
          "partial": "Type FN",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TypeFN.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TypeFN",
          "name": "ATC1",
          "package": "liboleg",
          "source": "src/Language-TypeFN.html#ATC1",
          "type": "data"
        },
        "index": {
          "hierarchy": "Language TypeFN",
          "module": "Language.TypeFN",
          "name": "ATC1",
          "package": "liboleg",
          "partial": "ATC",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TypeFN.html#t:ATC1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTo generalize,\n\u003c/p\u003e",
          "module": "Language.TypeFN",
          "name": "ATC2",
          "package": "liboleg",
          "source": "src/Language-TypeFN.html#ATC2",
          "type": "data"
        },
        "index": {
          "description": "To generalize",
          "hierarchy": "Language TypeFN",
          "module": "Language.TypeFN",
          "name": "ATC2",
          "package": "liboleg",
          "partial": "ATC",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TypeFN.html#t:ATC2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe comparison of ATC1 with ATC2 shows two different ways of defining\n abstractions: as (F x) terms (`lambda-terms' in our calculus) and as\n polymorphic types (Haskell type abstractions). The two ways are\n profoundly related. The more verbose type application notation, via\n (:\u003c), has its benefits. After we introduce another higher-order\n function\n\u003c/p\u003e",
          "module": "Language.TypeFN",
          "name": "Flip",
          "package": "liboleg",
          "source": "src/Language-TypeFN.html#Flip",
          "type": "data"
        },
        "index": {
          "description": "The comparison of ATC1 with ATC2 shows two different ways of defining abstractions as terms lambda-terms in our calculus and as polymorphic types Haskell type abstractions The two ways are profoundly related The more verbose type application notation via has its benefits After we introduce another higher-order function",
          "hierarchy": "Language TypeFN",
          "module": "Language.TypeFN",
          "name": "Flip",
          "package": "liboleg",
          "partial": "Flip",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TypeFN.html#t:Flip"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eand obtain quite a different result:\n\u003c/p\u003e\u003cpre\u003e *TypeFN\u003e :t test_sspn4\n test_sspn4 :: ((((Bool -\u003e Bool) -\u003e Bool) -\u003e Bool) -\u003e Bool) -\u003e Bool\n\u003c/pre\u003e\u003cp\u003eIn effect, we were able to use not only (a-\u003e) but also (-\u003ea) as an\n unary type function. Moreover, we achieved the latter by almost\n literally applying the flip function to the arrow type constructor\n (-\u003e).\n\u003c/p\u003e\u003cp\u003eUsing the type inspection tools (typecast), we can replace the family\n of functions ATC1, ATC2 with one, kind-polymorphic, polyvariadic\n function ATC. This approach will be explained in further messages.\n\u003c/p\u003e\u003cp\u003eWe can use the computed types to drive overloaded functions such as\n read and show. The specifically instantiated read functions, in\n particular, will check that a (remotely) received serialized value\n matches our expectation. Let's consider the type of trees of the depth\n of at most N.\n\u003c/p\u003e",
          "module": "Language.TypeFN",
          "name": "Node",
          "package": "liboleg",
          "source": "src/Language-TypeFN.html#Node",
          "type": "data"
        },
        "index": {
          "description": "and obtain quite different result TypeFN test sspn4 test sspn4 Bool Bool Bool Bool Bool Bool In effect we were able to use not only but also as an unary type function Moreover we achieved the latter by almost literally applying the flip function to the arrow type constructor Using the type inspection tools typecast we can replace the family of functions ATC1 ATC2 with one kind-polymorphic polyvariadic function ATC This approach will be explained in further messages We can use the computed types to drive overloaded functions such as read and show The specifically instantiated read functions in particular will check that remotely received serialized value matches our expectation Let consider the type of trees of the depth of at most",
          "hierarchy": "Language TypeFN",
          "module": "Language.TypeFN",
          "name": "Node",
          "package": "liboleg",
          "partial": "Node",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TypeFN.html#t:Node"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWe introduce the combinator Ntimes: |NTimes f x n| applies f to x n times.\n This is a sort of fold over numerals.\n\u003c/p\u003e",
          "module": "Language.TypeFN",
          "name": "Ntimes",
          "package": "liboleg",
          "source": "src/Language-TypeFN.html#Ntimes",
          "type": "data"
        },
        "index": {
          "description": "We introduce the combinator Ntimes NTimes applies to times This is sort of fold over numerals",
          "hierarchy": "Language TypeFN",
          "module": "Language.TypeFN",
          "name": "Ntimes",
          "package": "liboleg",
          "partial": "Ntimes",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TypeFN.html#t:Ntimes"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TypeFN",
          "name": "Prop",
          "package": "liboleg",
          "source": "src/Language-TypeFN.html#Prop",
          "type": "type"
        },
        "index": {
          "hierarchy": "Language TypeFN",
          "module": "Language.TypeFN",
          "name": "Prop",
          "package": "liboleg",
          "partial": "Prop",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TypeFN.html#t:Prop"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eOur first example comes from Cardelli's paper: defining the type\n Prop(n), of n-ary propositions. That is, \n\u003c/p\u003e\u003cpre\u003e   Prop(2) should be the type       Bool -\u003e Bool -\u003e Bool\n   Prop(3) is the type of functions Bool -\u003e Bool -\u003e Bool -\u003e Bool\n\u003c/pre\u003e\u003cp\u003eetc. \n\u003c/p\u003e\u003cp\u003eCardelli's paper (p. 10) writes this type as\n\u003c/p\u003e\u003cpre\u003elet Prop:: AllKK(N:: NatK) Type =\n     recK(F:: AllKK(N:: NatK) Type)\n         funKK(N:: NatK) caseK N of 0K =\u003e Bool; succK(M) =\u003e Bool -\u003e F(M);\n\u003c/pre\u003e\u003cpre\u003elet and2: Prop(2K) =\n     fun(a: Bool) fun(b: Bool) a & b;\n\u003c/pre\u003e\u003cp\u003eHere 0K and 2K are type-level numerals of the kind NatK; recK is the\n type-level fix-point combinator. The computed type Prop(2) then gives\n the type to the term and2.\n\u003c/p\u003e\u003cp\u003eIn our system, this example looks as follows:\n\u003c/p\u003e",
          "module": "Language.TypeFN",
          "name": "Prop'",
          "package": "liboleg",
          "source": "src/Language-TypeFN.html#Prop%27",
          "type": "data"
        },
        "index": {
          "description": "Our first example comes from Cardelli paper defining the type Prop of n-ary propositions That is Prop should be the type Bool Bool Bool Prop is the type of functions Bool Bool Bool Bool etc Cardelli paper writes this type as let Prop AllKK NatK Type recK AllKK NatK Type funKK NatK caseK of Bool succK Bool let and2 Prop fun Bool fun Bool Here and are type-level numerals of the kind NatK recK is the type-level fix-point combinator The computed type Prop then gives the type to the term and2 In our system this example looks as follows",
          "hierarchy": "Language TypeFN",
          "module": "Language.TypeFN",
          "name": "Prop'",
          "package": "liboleg",
          "partial": "Prop'",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TypeFN.html#t:Prop-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TypeFN",
          "name": "Prop2",
          "package": "liboleg",
          "source": "src/Language-TypeFN.html#Prop2",
          "type": "type"
        },
        "index": {
          "hierarchy": "Language TypeFN",
          "module": "Language.TypeFN",
          "name": "Prop2",
          "package": "liboleg",
          "partial": "Prop",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TypeFN.html#t:Prop2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWe can then write the type of n-ary propositions Prop(N) in a different way,\n as an N-times application of the type constructor (Bool-\u003e) to Bool.\n\u003c/p\u003e",
          "module": "Language.TypeFN",
          "name": "PropN'",
          "package": "liboleg",
          "source": "src/Language-TypeFN.html#PropN%27",
          "type": "type"
        },
        "index": {
          "description": "We can then write the type of n-ary propositions Prop in different way as an N-times application of the type constructor Bool to Bool",
          "hierarchy": "Language TypeFN",
          "module": "Language.TypeFN",
          "name": "PropN'",
          "package": "liboleg",
          "partial": "Prop N'",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TypeFN.html#t:PropN-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TypeFN",
          "name": "SPropN'",
          "package": "liboleg",
          "source": "src/Language-TypeFN.html#SPropN%27",
          "type": "type"
        },
        "index": {
          "hierarchy": "Language TypeFN",
          "module": "Language.TypeFN",
          "name": "SPropN'",
          "package": "liboleg",
          "partial": "SProp N'",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TypeFN.html#t:SPropN-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ewe make a very little change\n\u003c/p\u003e",
          "module": "Language.TypeFN",
          "name": "SSPropN'",
          "package": "liboleg",
          "source": "src/Language-TypeFN.html#SSPropN%27",
          "type": "type"
        },
        "index": {
          "description": "we make very little change",
          "hierarchy": "Language TypeFN",
          "module": "Language.TypeFN",
          "name": "SSPropN'",
          "package": "liboleg",
          "partial": "SSProp N'",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TypeFN.html#t:SSPropN-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWe can compute types by applying type functions, just as we can\n compute values by applying regular functions. Indeed, let us define a\n StrangeProp of the kind NAT -\u003e Type. StrangeProp(n) is the type of\n propositions of arity m, where m is fib(n). We compose together the\n already defined type function Prop2 and the type function Fib in the\n previous message.\n\u003c/p\u003e",
          "module": "Language.TypeFN",
          "name": "StrangeProp",
          "package": "liboleg",
          "source": "src/Language-TypeFN.html#StrangeProp",
          "type": "data"
        },
        "index": {
          "description": "We can compute types by applying type functions just as we can compute values by applying regular functions Indeed let us define StrangeProp of the kind NAT Type StrangeProp is the type of propositions of arity where is fib We compose together the already defined type function Prop2 and the type function Fib in the previous message",
          "hierarchy": "Language TypeFN",
          "module": "Language.TypeFN",
          "name": "StrangeProp",
          "package": "liboleg",
          "partial": "Strange Prop",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TypeFN.html#t:StrangeProp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TypeFN",
          "name": "TreeDN",
          "package": "liboleg",
          "source": "src/Language-TypeFN.html#TreeDN",
          "type": "type"
        },
        "index": {
          "hierarchy": "Language TypeFN",
          "module": "Language.TypeFN",
          "name": "TreeDN",
          "package": "liboleg",
          "partial": "Tree DN",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TypeFN.html#t:TreeDN"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TypeFN",
          "name": "Node",
          "package": "liboleg",
          "signature": "Node v [els]",
          "source": "src/Language-TypeFN.html#Node",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language TypeFN",
          "module": "Language.TypeFN",
          "name": "Node",
          "normalized": "Node a[b]",
          "package": "liboleg",
          "partial": "Node",
          "signature": "Node v[els]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TypeFN.html#v:Node"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TypeFN",
          "name": "oddand4t",
          "package": "liboleg",
          "signature": "r",
          "source": "src/Language-TypeFN.html#oddand4t",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language TypeFN",
          "module": "Language.TypeFN",
          "name": "oddand4t",
          "package": "liboleg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TypeFN.html#v:oddand4t"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003e\u003ca\u003ehttp://okmij.org/ftp/Computation/lambda-calc.html#haskell-type-level\u003c/a\u003e\n\u003c/p\u003e\u003cp\u003eThis is the first message in a series on arbitrary type/kind-level\n computations in the present-day Haskell, and on using of so computed\n types to give signatures to terms and to drive the selection of\n overloaded functions. We can define the type TD N to be the type of a\n tree fib(N)-level deep, and instantiate the read function for the tree\n of that type. The type computations are largely expressed in a\n functional language not too unlike Haskell itself.\n\u003c/p\u003e\u003cp\u003eIn this message we implement call-by-value lambda-calculus with\n booleans, naturals and case-discrimination. The distinct feature of\n our implementation, besides its simplicity, is the primary role of\n type application rather than that of abstraction. Yet we trivially\n represent closures and higher-order functions. We use proper names for\n function arguments (rather than deBruijn indices), and yet we avoid\n the need for fresh name generation, name comparison, and\n alpha-conversion. We have no explicit environment and no need to\n propagate and search it, and yet we can partially apply functions.\n\u003c/p\u003e\u003cp\u003eOur implementation fundamentally relies on the connection between\n polymorphism and abstraction, and takes the full advantage of the\n type-lambda implicitly present in Haskell. The reason for the\n triviality of our code is the typechecker's already doing most of the\n work need for an implementation of lambda-calculus.\n\u003c/p\u003e\u003cp\u003eOur code is indeed quite simple: its general part has only three\n lines:\n\u003c/p\u003e\u003cpre\u003e  instance E (F x) (F x)\n  instance (E y y', A (F x) y' r) =\u003e E ((F x) :\u003c y) r\n  instance (E (x :\u003c y) r', E (r' :\u003c z) r) =\u003e E ((x :\u003c y) :\u003c z) r\n\u003c/pre\u003e\u003cp\u003eThe first line says that abstractions evaluate to themselves, the\n second line executes the redex, and the third recurses to find it.\n Still, we may (and did) write partial applications, the fixpoint\n combinator, Fibonacci function, and S and K combinators. Incidentally,\n the realization of the S combinator again takes three lines, two of\n which build the closures (partial applications) and the third line\n executes the familiar S-rule.\n\u003c/p\u003e\u003cpre\u003e  instance A (F CombS) f (F (CombS,f))\n  instance A (F (CombS,f)) g (F (CombS,f,g))\n  instance E (f :\u003c x :\u003c (g :\u003c x)) r =\u003e A (F (CombS,f,g)) x r\n\u003c/pre\u003e\u003cp\u003eIncidentally, the present code constitutes what seems to be the\n shortest proof that the type system of Haskell with the undecidable\n instances extension is indeed Turing-complete. That extension is\n needed for the fixpoint combinator -- which is present in the system\n described in Luca Cardelli's 1988 manuscript:\n\u003c/p\u003e\u003cp\u003e\u003ca\u003ehttp://lucacardelli.name/Papers/PhaseDistinctions.pdf\u003c/a\u003e\n\u003c/p\u003e\u003cp\u003eAs he wrote, ``Here we have generalized the language of constant\n expressions to include typed lambda abstraction, application and\n recursion (because of the latter we do not require compile-time\n computations to terminate).'' [p9]\n\u003c/p\u003e\u003cp\u003eThis message is all the code, which runs in GHC 6.4.1 - 6.8.2 (it could well\n run in Hugs; alas, Hugs did not like infix type constructors like :\u003c).\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Language.TypeLC",
          "name": "TypeLC",
          "package": "liboleg",
          "source": "src/Language-TypeLC.html",
          "type": "module"
        },
        "index": {
          "description": "http okmij.org ftp Computation lambda-calc.html haskell-type-level This is the first message in series on arbitrary type kind-level computations in the present-day Haskell and on using of so computed types to give signatures to terms and to drive the selection of overloaded functions We can define the type TD to be the type of tree fib level deep and instantiate the read function for the tree of that type The type computations are largely expressed in functional language not too unlike Haskell itself In this message we implement call-by-value lambda-calculus with booleans naturals and case-discrimination The distinct feature of our implementation besides its simplicity is the primary role of type application rather than that of abstraction Yet we trivially represent closures and higher-order functions We use proper names for function arguments rather than deBruijn indices and yet we avoid the need for fresh name generation name comparison and alpha-conversion We have no explicit environment and no need to propagate and search it and yet we can partially apply functions Our implementation fundamentally relies on the connection between polymorphism and abstraction and takes the full advantage of the type-lambda implicitly present in Haskell The reason for the triviality of our code is the typechecker already doing most of the work need for an implementation of lambda-calculus Our code is indeed quite simple its general part has only three lines instance instance instance The first line says that abstractions evaluate to themselves the second line executes the redex and the third recurses to find it Still we may and did write partial applications the fixpoint combinator Fibonacci function and and combinators Incidentally the realization of the combinator again takes three lines two of which build the closures partial applications and the third line executes the familiar S-rule instance CombS CombS instance CombS CombS instance CombS Incidentally the present code constitutes what seems to be the shortest proof that the type system of Haskell with the undecidable instances extension is indeed Turing-complete That extension is needed for the fixpoint combinator which is present in the system described in Luca Cardelli manuscript http lucacardelli.name Papers PhaseDistinctions.pdf As he wrote Here we have generalized the language of constant expressions to include typed lambda abstraction application and recursion because of the latter we do not require compile-time computations to terminate p9 This message is all the code which runs in GHC it could well run in Hugs alas Hugs did not like infix type constructors like",
          "hierarchy": "Language TypeLC",
          "module": "Language.TypeLC",
          "name": "TypeLC",
          "package": "liboleg",
          "partial": "Type LC",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TypeLC.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCommonly, abstraction is held to be `more fundamental', which is\n reflected in the popular phrase `Lambda-the-Ultimate'. In our system,\n application is fundamental.  An abstraction is a not-yet-applied\n application -- which is in itself a first-class value.  The class A\n defines the meaning of a function, and an instance of A becomes the\n definition of a function (clause).\n\u003c/p\u003e\u003cp\u003eWe have dealt with simple expressions and applicative things. We now\n build sequences of applications, and define the corresponding big step\n semantics. We introduce the syntax for applications:\n\u003c/p\u003e",
          "module": "Language.TypeLC",
          "name": ":\u003c",
          "package": "liboleg",
          "source": "src/Language-TypeLC.html#%3A%3C",
          "type": "data"
        },
        "index": {
          "description": "Commonly abstraction is held to be more fundamental which is reflected in the popular phrase Lambda-the-Ultimate In our system application is fundamental An abstraction is not-yet-applied application which is in itself first-class value The class defines the meaning of function and an instance of becomes the definition of function clause We have dealt with simple expressions and applicative things We now build sequences of applications and define the corresponding big step semantics We introduce the syntax for applications",
          "hierarchy": "Language TypeLC",
          "module": "Language.TypeLC",
          "name": ":\u003c",
          "package": "liboleg",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TypeLC.html#t::-60-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TypeLC",
          "name": "A",
          "package": "liboleg",
          "source": "src/Language-TypeLC.html#A",
          "type": "class"
        },
        "index": {
          "hierarchy": "Language TypeLC",
          "module": "Language.TypeLC",
          "name": "A",
          "package": "liboleg",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TypeLC.html#t:A"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFinally, we demonstrate that our calculus is combinatorially complete,\n by writing the S and K combinators\n\u003c/p\u003e",
          "module": "Language.TypeLC",
          "name": "CombK",
          "package": "liboleg",
          "source": "src/Language-TypeLC.html#CombK",
          "type": "data"
        },
        "index": {
          "description": "Finally we demonstrate that our calculus is combinatorially complete by writing the and combinators",
          "hierarchy": "Language TypeLC",
          "module": "Language.TypeLC",
          "name": "CombK",
          "package": "liboleg",
          "partial": "Comb",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TypeLC.html#t:CombK"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TypeLC",
          "name": "CombS",
          "package": "liboleg",
          "source": "src/Language-TypeLC.html#CombS",
          "type": "data"
        },
        "index": {
          "hierarchy": "Language TypeLC",
          "module": "Language.TypeLC",
          "name": "CombS",
          "package": "liboleg",
          "partial": "Comb",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TypeLC.html#t:CombS"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TypeLC",
          "name": "CombSu",
          "package": "liboleg",
          "source": "src/Language-TypeLC.html#CombSu",
          "type": "type"
        },
        "index": {
          "hierarchy": "Language TypeLC",
          "module": "Language.TypeLC",
          "name": "CombSu",
          "package": "liboleg",
          "partial": "Comb Su",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TypeLC.html#t:CombSu"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TypeLC",
          "name": "CombTwo",
          "package": "liboleg",
          "source": "src/Language-TypeLC.html#CombTwo",
          "type": "type"
        },
        "index": {
          "hierarchy": "Language TypeLC",
          "module": "Language.TypeLC",
          "name": "CombTwo",
          "package": "liboleg",
          "partial": "Comb Two",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TypeLC.html#t:CombTwo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eand the representation of numerals in the SK calculus. The expression\n (F FSum :\u003c Su Zero) is a partial application of the function sum to 1.\n\u003c/p\u003e",
          "module": "Language.TypeLC",
          "name": "CombZ",
          "package": "liboleg",
          "source": "src/Language-TypeLC.html#CombZ",
          "type": "type"
        },
        "index": {
          "description": "and the representation of numerals in the SK calculus The expression FSum Su Zero is partial application of the function sum to",
          "hierarchy": "Language TypeLC",
          "module": "Language.TypeLC",
          "name": "CombZ",
          "package": "liboleg",
          "partial": "Comb",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TypeLC.html#t:CombZ"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eand the big-step evaluation function:\n\u003c/p\u003e",
          "module": "Language.TypeLC",
          "name": "E",
          "package": "liboleg",
          "source": "src/Language-TypeLC.html#E",
          "type": "class"
        },
        "index": {
          "description": "and the big-step evaluation function",
          "hierarchy": "Language TypeLC",
          "module": "Language.TypeLC",
          "name": "E",
          "package": "liboleg",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TypeLC.html#t:E"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIndicator for functions, or applicable things:\n\u003c/p\u003e",
          "module": "Language.TypeLC",
          "name": "F",
          "package": "liboleg",
          "source": "src/Language-TypeLC.html#F",
          "type": "data"
        },
        "index": {
          "description": "Indicator for functions or applicable things",
          "hierarchy": "Language TypeLC",
          "module": "Language.TypeLC",
          "name": "F",
          "package": "liboleg",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TypeLC.html#t:F"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe next function is the boolean And. It takes two arguments, so we\n have to handle currying now.\n\u003c/p\u003e",
          "module": "Language.TypeLC",
          "name": "FAnd",
          "package": "liboleg",
          "source": "src/Language-TypeLC.html#FAnd",
          "type": "data"
        },
        "index": {
          "description": "The next function is the boolean And It takes two arguments so we have to handle currying now",
          "hierarchy": "Language TypeLC",
          "module": "Language.TypeLC",
          "name": "FAnd",
          "package": "liboleg",
          "partial": "FAnd",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TypeLC.html#t:FAnd"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe meaning of |A l a b| is that the application to |a| of an\n applicable thing denoted by |l| yields |b|.\n\u003c/p\u003e\u003cp\u003eSurprisingly, this already works. Let us define the boolean Not function\n\u003c/p\u003e",
          "module": "Language.TypeLC",
          "name": "FNot",
          "package": "liboleg",
          "source": "src/Language-TypeLC.html#FNot",
          "type": "data"
        },
        "index": {
          "description": "The meaning of is that the application to of an applicable thing denoted by yields Surprisingly this already works Let us define the boolean Not function",
          "hierarchy": "Language TypeLC",
          "module": "Language.TypeLC",
          "name": "FNot",
          "package": "liboleg",
          "partial": "FNot",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TypeLC.html#t:FNot"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003enow we tie up the knot\n\u003c/p\u003e",
          "module": "Language.TypeLC",
          "name": "FSum",
          "package": "liboleg",
          "source": "src/Language-TypeLC.html#FSum",
          "type": "type"
        },
        "index": {
          "description": "now we tie up the knot",
          "hierarchy": "Language TypeLC",
          "module": "Language.TypeLC",
          "name": "FSum",
          "package": "liboleg",
          "partial": "FSum",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TypeLC.html#t:FSum"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eand define the sum of two numerals\n\u003c/p\u003e\u003cp\u003eAt the type level, this looks as follows\n\u003c/p\u003e",
          "module": "Language.TypeLC",
          "name": "FSum'",
          "package": "liboleg",
          "source": "src/Language-TypeLC.html#FSum%27",
          "type": "data"
        },
        "index": {
          "description": "and define the sum of two numerals At the type level this looks as follows",
          "hierarchy": "Language TypeLC",
          "module": "Language.TypeLC",
          "name": "FSum'",
          "package": "liboleg",
          "partial": "FSum'",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TypeLC.html#t:FSum-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TypeLC",
          "name": "Fib",
          "package": "liboleg",
          "source": "src/Language-TypeLC.html#Fib",
          "type": "type"
        },
        "index": {
          "hierarchy": "Language TypeLC",
          "module": "Language.TypeLC",
          "name": "Fib",
          "package": "liboleg",
          "partial": "Fib",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TypeLC.html#t:Fib"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFinally, the standard test -- Fibonacci\n\u003c/p\u003e",
          "module": "Language.TypeLC",
          "name": "Fib'",
          "package": "liboleg",
          "source": "src/Language-TypeLC.html#Fib%27",
          "type": "data"
        },
        "index": {
          "description": "Finally the standard test Fibonacci",
          "hierarchy": "Language TypeLC",
          "module": "Language.TypeLC",
          "name": "Fib'",
          "package": "liboleg",
          "partial": "Fib'",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TypeLC.html#t:Fib-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TypeLC",
          "name": "HFalse",
          "package": "liboleg",
          "source": "src/Language-TypeLC.html#HFalse",
          "type": "data"
        },
        "index": {
          "hierarchy": "Language TypeLC",
          "module": "Language.TypeLC",
          "name": "HFalse",
          "package": "liboleg",
          "partial": "HFalse",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TypeLC.html#t:HFalse"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFirst we define some constants\n\u003c/p\u003e",
          "module": "Language.TypeLC",
          "name": "HTrue",
          "package": "liboleg",
          "source": "src/Language-TypeLC.html#HTrue",
          "type": "data"
        },
        "index": {
          "description": "First we define some constants",
          "hierarchy": "Language TypeLC",
          "module": "Language.TypeLC",
          "name": "HTrue",
          "package": "liboleg",
          "partial": "HTrue",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TypeLC.html#t:HTrue"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TypeLC",
          "name": "N0",
          "package": "liboleg",
          "source": "src/Language-TypeLC.html#N0",
          "type": "type"
        },
        "index": {
          "hierarchy": "Language TypeLC",
          "module": "Language.TypeLC",
          "name": "N0",
          "package": "liboleg",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TypeLC.html#t:N0"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TypeLC",
          "name": "N1",
          "package": "liboleg",
          "source": "src/Language-TypeLC.html#N1",
          "type": "type"
        },
        "index": {
          "hierarchy": "Language TypeLC",
          "module": "Language.TypeLC",
          "name": "N1",
          "package": "liboleg",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TypeLC.html#t:N1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TypeLC",
          "name": "N2",
          "package": "liboleg",
          "source": "src/Language-TypeLC.html#N2",
          "type": "type"
        },
        "index": {
          "hierarchy": "Language TypeLC",
          "module": "Language.TypeLC",
          "name": "N2",
          "package": "liboleg",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TypeLC.html#t:N2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TypeLC",
          "name": "N3",
          "package": "liboleg",
          "source": "src/Language-TypeLC.html#N3",
          "type": "type"
        },
        "index": {
          "hierarchy": "Language TypeLC",
          "module": "Language.TypeLC",
          "name": "N3",
          "package": "liboleg",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TypeLC.html#t:N3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TypeLC",
          "name": "Nat",
          "package": "liboleg",
          "source": "src/Language-TypeLC.html#Nat",
          "type": "class"
        },
        "index": {
          "hierarchy": "Language TypeLC",
          "module": "Language.TypeLC",
          "name": "Nat",
          "package": "liboleg",
          "partial": "Nat",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TypeLC.html#t:Nat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWe introduce the applicative fixpoint combinator\n\u003c/p\u003e",
          "module": "Language.TypeLC",
          "name": "Rec",
          "package": "liboleg",
          "source": "src/Language-TypeLC.html#Rec",
          "type": "data"
        },
        "index": {
          "description": "We introduce the applicative fixpoint combinator",
          "hierarchy": "Language TypeLC",
          "module": "Language.TypeLC",
          "name": "Rec",
          "package": "liboleg",
          "partial": "Rec",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TypeLC.html#t:Rec"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TypeLC",
          "name": "Su",
          "package": "liboleg",
          "source": "src/Language-TypeLC.html#Su",
          "type": "data"
        },
        "index": {
          "hierarchy": "Language TypeLC",
          "module": "Language.TypeLC",
          "name": "Su",
          "package": "liboleg",
          "partial": "Su",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TypeLC.html#t:Su"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA few examples: SKK as the identity\n\u003c/p\u003e",
          "module": "Language.TypeLC",
          "name": "Test_skk",
          "package": "liboleg",
          "source": "src/Language-TypeLC.html#Test_skk",
          "type": "type"
        },
        "index": {
          "description": "few examples SKK as the identity",
          "hierarchy": "Language TypeLC",
          "module": "Language.TypeLC",
          "name": "Test_skk",
          "package": "liboleg",
          "partial": "Test",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TypeLC.html#t:Test_skk"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThat is all. The rest of the message are the tests. The first one is\n the type-level equivalent of the following function:\n\u003c/p\u003e\u003cpre\u003e      testb x = and (not x) (not (not x))\n\u003c/pre\u003e\u003cp\u003eAt the type level, it looks not much differently:\n\u003c/p\u003e",
          "module": "Language.TypeLC",
          "name": "Testb",
          "package": "liboleg",
          "source": "src/Language-TypeLC.html#Testb",
          "type": "type"
        },
        "index": {
          "description": "That is all The rest of the message are the tests The first one is the type-level equivalent of the following function testb and not not not At the type level it looks not much differently",
          "hierarchy": "Language TypeLC",
          "module": "Language.TypeLC",
          "name": "Testb",
          "package": "liboleg",
          "partial": "Testb",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TypeLC.html#t:Testb"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TypeLC",
          "name": "Zero",
          "package": "liboleg",
          "source": "src/Language-TypeLC.html#Zero",
          "type": "data"
        },
        "index": {
          "hierarchy": "Language TypeLC",
          "module": "Language.TypeLC",
          "name": "Zero",
          "package": "liboleg",
          "partial": "Zero",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TypeLC.html#t:Zero"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TypeLC",
          "name": "HFalse",
          "package": "liboleg",
          "signature": "HFalse",
          "source": "src/Language-TypeLC.html#HFalse",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language TypeLC",
          "module": "Language.TypeLC",
          "name": "HFalse",
          "package": "liboleg",
          "partial": "HFalse",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TypeLC.html#v:HFalse"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TypeLC",
          "name": "HTrue",
          "package": "liboleg",
          "signature": "HTrue",
          "source": "src/Language-TypeLC.html#HTrue",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language TypeLC",
          "module": "Language.TypeLC",
          "name": "HTrue",
          "package": "liboleg",
          "partial": "HTrue",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TypeLC.html#v:HTrue"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TypeLC",
          "name": "Su",
          "package": "liboleg",
          "signature": "Su a",
          "source": "src/Language-TypeLC.html#Su",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language TypeLC",
          "module": "Language.TypeLC",
          "name": "Su",
          "package": "liboleg",
          "partial": "Su",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TypeLC.html#v:Su"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TypeLC",
          "name": "Zero",
          "package": "liboleg",
          "signature": "Zero",
          "source": "src/Language-TypeLC.html#Zero",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language TypeLC",
          "module": "Language.TypeLC",
          "name": "Zero",
          "package": "liboleg",
          "partial": "Zero",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TypeLC.html#v:Zero"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TypeLC",
          "name": "fromNat",
          "package": "liboleg",
          "signature": "a -\u003e Integer",
          "source": "src/Language-TypeLC.html#fromNat",
          "type": "method"
        },
        "index": {
          "hierarchy": "Language TypeLC",
          "module": "Language.TypeLC",
          "name": "fromNat",
          "normalized": "a-\u003eInteger",
          "package": "liboleg",
          "partial": "Nat",
          "signature": "a-\u003eInteger",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TypeLC.html#v:fromNat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TypeLC",
          "name": "test_ctwo",
          "package": "liboleg",
          "signature": "r",
          "source": "src/Language-TypeLC.html#test_ctwo",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language TypeLC",
          "module": "Language.TypeLC",
          "name": "test_ctwo",
          "package": "liboleg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TypeLC.html#v:test_ctwo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TypeLC",
          "name": "test_fib",
          "package": "liboleg",
          "signature": "n -\u003e r",
          "source": "src/Language-TypeLC.html#test_fib",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language TypeLC",
          "module": "Language.TypeLC",
          "name": "test_fib",
          "normalized": "a-\u003eb",
          "package": "liboleg",
          "signature": "n-\u003er",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TypeLC.html#v:test_fib"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.TypeLC",
          "name": "test_sum",
          "package": "liboleg",
          "signature": "x -\u003e y -\u003e r",
          "source": "src/Language-TypeLC.html#test_sum",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language TypeLC",
          "module": "Language.TypeLC",
          "name": "test_sum",
          "normalized": "a-\u003eb-\u003ec",
          "package": "liboleg",
          "signature": "x-\u003ey-\u003er",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Language-TypeLC.html#v:test_sum"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eDynamic Epistemic Logic: solving the puzzles from\n Hans van Ditmarsch's tutorial course on Dynamic Epistemic Logic,\n NASSLLI 2010, June 20, 2010.\n See also\n\u003c/p\u003e\u003cp\u003eDynamic Epistemic Logic and Knowledge Puzzles\n H.P. van Ditmarsch, W. van der Hoek, and B.P. Kooi\n \u003ca\u003ehttp://www.csc.liv.ac.uk/~wiebe/pubs/Documents/iccs.pdf\u003c/a\u003e\n\u003c/p\u003e\u003cp\u003eEpistemic Puzzles\n Hans van Ditmarsch\n \u003ca\u003ehttp://www.cs.otago.ac.nz/staffpriv/hans/cosc462/logicpuzzlesB.pdf\u003c/a\u003e\n\u003c/p\u003e\u003cp\u003eWe encode the statement of the problem as a filter on\n possible worlds.\n The possible worlds consistent with the statement of\n the problem are the solutions.\n\u003c/p\u003e\u003cpre\u003e \"Agent A does not know proposition phi\" is interpreted\n\u003c/pre\u003e\u003cp\u003eas the statement that for all worlds consistent with the propositions\n A currently knows, phi is true in some but false in the others.\n\u003c/p\u003e\u003cp\u003e\u003ca\u003ehttp://okmij.org/ftp/Algorithms.html#dyn-epistemology\u003c/a\u003e\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Logic.DynEpistemology",
          "name": "DynEpistemology",
          "package": "liboleg",
          "source": "src/Logic-DynEpistemology.html",
          "type": "module"
        },
        "index": {
          "description": "Dynamic Epistemic Logic solving the puzzles from Hans van Ditmarsch tutorial course on Dynamic Epistemic Logic NASSLLI June See also Dynamic Epistemic Logic and Knowledge Puzzles H.P van Ditmarsch van der Hoek and B.P Kooi http www.csc.liv.ac.uk wiebe pubs Documents iccs.pdf Epistemic Puzzles Hans van Ditmarsch http www.cs.otago.ac.nz staffpriv hans cosc462 logicpuzzlesB.pdf We encode the statement of the problem as filter on possible worlds The possible worlds consistent with the statement of the problem are the solutions Agent does not know proposition phi is interpreted as the statement that for all worlds consistent with the propositions currently knows phi is true in some but false in the others http okmij.org ftp Algorithms.html dyn-epistemology",
          "hierarchy": "Logic DynEpistemology",
          "module": "Logic.DynEpistemology",
          "name": "DynEpistemology",
          "package": "liboleg",
          "partial": "Dyn Epistemology",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Logic-DynEpistemology.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eProblem 1\n Anne and Bill each privately receive a natural number.\n Their numbers are consecutive.\n The following truthful conversation takes place:\n\u003c/p\u003e\u003cpre\u003e Anne: I don't know your number\n Bill: I don't know your number either\n Anne: I know your number.\n Bill: I know your number too.\n\u003c/pre\u003e\u003cp\u003eIf Anne has received the number 2, what was the number\n received by Bill?\n This puzzle is also known as `Conway paradox': it appears\n that Anne and Bill have truthfully made contradictory statements.\n\u003c/p\u003e\u003cp\u003eA possible world for a problem 1:\n numbers received by Anne and Bill\n\u003c/p\u003e",
          "module": "Logic.DynEpistemology",
          "name": "P1World",
          "package": "liboleg",
          "source": "src/Logic-DynEpistemology.html#P1World",
          "type": "type"
        },
        "index": {
          "description": "Problem Anne and Bill each privately receive natural number Their numbers are consecutive The following truthful conversation takes place Anne don know your number Bill don know your number either Anne know your number Bill know your number too If Anne has received the number what was the number received by Bill This puzzle is also known as Conway paradox it appears that Anne and Bill have truthfully made contradictory statements possible world for problem numbers received by Anne and Bill",
          "hierarchy": "Logic DynEpistemology",
          "module": "Logic.DynEpistemology",
          "name": "P1World",
          "package": "liboleg",
          "partial": "World",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Logic-DynEpistemology.html#t:P1World"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eProblem 2\n\u003c/p\u003e\u003cp\u003eAnne, Bill and Cath each have a positive natural number written on\n their foreheads. They can only see the foreheads of others.\n One of the numbers is the sum of the other two. All the previous\n is common knowledge. The following truthful conversation takes place:\n\u003c/p\u003e\u003cpre\u003e Anne: I don't know my number.\n Bill: I don't know my number.\n Cath: I don't know my number.\n Anne: I now know my number, and it is 50.\n\u003c/pre\u003e\u003cp\u003eWhat are the numbers of Bill and Cath?\n Math Horizons, November 2004. Problem 182.\n\u003c/p\u003e\u003cp\u003eA possible world for a problem 1:\n numbers received by Anne, Bill, and Cath\n\u003c/p\u003e",
          "module": "Logic.DynEpistemology",
          "name": "P2World",
          "package": "liboleg",
          "source": "src/Logic-DynEpistemology.html#P2World",
          "type": "type"
        },
        "index": {
          "description": "Problem Anne Bill and Cath each have positive natural number written on their foreheads They can only see the foreheads of others One of the numbers is the sum of the other two All the previous is common knowledge The following truthful conversation takes place Anne don know my number Bill don know my number Cath don know my number Anne now know my number and it is What are the numbers of Bill and Cath Math Horizons November Problem possible world for problem numbers received by Anne Bill and Cath",
          "hierarchy": "Logic DynEpistemology",
          "module": "Logic.DynEpistemology",
          "name": "P2World",
          "package": "liboleg",
          "partial": "World",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Logic-DynEpistemology.html#t:P2World"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReverse application\n\u003c/p\u003e",
          "module": "Logic.DynEpistemology",
          "name": "choose",
          "package": "liboleg",
          "signature": "[a] -\u003e m a",
          "source": "src/Logic-DynEpistemology.html#choose",
          "type": "function"
        },
        "index": {
          "description": "Reverse application",
          "hierarchy": "Logic DynEpistemology",
          "module": "Logic.DynEpistemology",
          "name": "choose",
          "normalized": "[a]-\u003eb a",
          "package": "liboleg",
          "signature": "[a]-\u003em a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Logic-DynEpistemology.html#v:choose"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA stream of integers starting with n\n\u003c/p\u003e",
          "module": "Logic.DynEpistemology",
          "name": "iota",
          "package": "liboleg",
          "signature": "Int -\u003e m Int",
          "source": "src/Logic-DynEpistemology.html#iota",
          "type": "function"
        },
        "index": {
          "description": "stream of integers starting with",
          "hierarchy": "Logic DynEpistemology",
          "module": "Logic.DynEpistemology",
          "name": "iota",
          "normalized": "Int-\u003ea Int",
          "package": "liboleg",
          "signature": "Int-\u003em Int",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Logic-DynEpistemology.html#v:iota"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA stream of naturals\n\u003c/p\u003e",
          "module": "Logic.DynEpistemology",
          "name": "nat",
          "package": "liboleg",
          "signature": "m Int",
          "source": "src/Logic-DynEpistemology.html#nat",
          "type": "function"
        },
        "index": {
          "description": "stream of naturals",
          "hierarchy": "Logic DynEpistemology",
          "module": "Logic.DynEpistemology",
          "name": "nat",
          "package": "liboleg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Logic-DynEpistemology.html#v:nat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFilter a set of possible worlds\n Given a proj function (yielding a set of keys for a world w),\n return a stream of worlds that are not unique with\n respect to their keys. That is, there are several\n worlds with the same key.\n Our state is a set of quarantined worlds.\n When we receive a world whose key we have not seen,\n we quarantine it. We release from the quarantine\n when we encounter the same key again.\n Our function is specialized to the List monad. In general,\n we need MonadMinus (see the LogicT paper), of which List is an instance.\n\u003c/p\u003e",
          "module": "Logic.DynEpistemology",
          "name": "nonunique",
          "package": "liboleg",
          "signature": "(w -\u003e [key]) -\u003e [w] -\u003e [w]",
          "source": "src/Logic-DynEpistemology.html#nonunique",
          "type": "function"
        },
        "index": {
          "description": "Filter set of possible worlds Given proj function yielding set of keys for world return stream of worlds that are not unique with respect to their keys That is there are several worlds with the same key Our state is set of quarantined worlds When we receive world whose key we have not seen we quarantine it We release from the quarantine when we encounter the same key again Our function is specialized to the List monad In general we need MonadMinus see the LogicT paper of which List is an instance",
          "hierarchy": "Logic DynEpistemology",
          "module": "Logic.DynEpistemology",
          "name": "nonunique",
          "normalized": "(a-\u003e[b])-\u003e[a]-\u003e[a]",
          "package": "liboleg",
          "signature": "(w-\u003e[key])-\u003e[w]-\u003e[w]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Logic-DynEpistemology.html#v:nonunique"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe number Anne received in the world w\n\u003c/p\u003e",
          "module": "Logic.DynEpistemology",
          "name": "p1_anne",
          "package": "liboleg",
          "signature": "P1World -\u003e Int",
          "source": "src/Logic-DynEpistemology.html#p1_anne",
          "type": "function"
        },
        "index": {
          "description": "The number Anne received in the world",
          "hierarchy": "Logic DynEpistemology",
          "module": "Logic.DynEpistemology",
          "name": "p1_anne",
          "normalized": "P World-\u003eInt",
          "package": "liboleg",
          "signature": "P World-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Logic-DynEpistemology.html#v:p1_anne"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe number Bill received in the world w\n\u003c/p\u003e",
          "module": "Logic.DynEpistemology",
          "name": "p1_bill",
          "package": "liboleg",
          "signature": "P1World -\u003e Int",
          "source": "src/Logic-DynEpistemology.html#p1_bill",
          "type": "function"
        },
        "index": {
          "description": "The number Bill received in the world",
          "hierarchy": "Logic DynEpistemology",
          "module": "Logic.DynEpistemology",
          "name": "p1_bill",
          "normalized": "P World-\u003eInt",
          "package": "liboleg",
          "signature": "P World-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Logic-DynEpistemology.html#v:p1_bill"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn initial stream of possible worlds for problem 1\n\u003c/p\u003e",
          "module": "Logic.DynEpistemology",
          "name": "p1worlds",
          "package": "liboleg",
          "signature": "m P1World",
          "source": "src/Logic-DynEpistemology.html#p1worlds",
          "type": "function"
        },
        "index": {
          "description": "An initial stream of possible worlds for problem",
          "hierarchy": "Logic DynEpistemology",
          "module": "Logic.DynEpistemology",
          "name": "p1worlds",
          "package": "liboleg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Logic-DynEpistemology.html#v:p1worlds"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe number on Anne's forehead in the world w\n\u003c/p\u003e",
          "module": "Logic.DynEpistemology",
          "name": "p2_anne",
          "package": "liboleg",
          "signature": "P2World -\u003e Int",
          "source": "src/Logic-DynEpistemology.html#p2_anne",
          "type": "function"
        },
        "index": {
          "description": "The number on Anne forehead in the world",
          "hierarchy": "Logic DynEpistemology",
          "module": "Logic.DynEpistemology",
          "name": "p2_anne",
          "normalized": "P World-\u003eInt",
          "package": "liboleg",
          "signature": "P World-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Logic-DynEpistemology.html#v:p2_anne"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIf Anne sees the number x on Bill's forehead and the\n number y on Cath's forehead, what numbers could be\n on Anne's forehead?\n In other words, compute the set of possible worlds\n that are indistinguishable from the world w as far as\n Anne is concerned.\n\u003c/p\u003e",
          "module": "Logic.DynEpistemology",
          "name": "p2_anne_keys",
          "package": "liboleg",
          "signature": "P2World -\u003e [P2World]",
          "source": "src/Logic-DynEpistemology.html#p2_anne_keys",
          "type": "function"
        },
        "index": {
          "description": "If Anne sees the number on Bill forehead and the number on Cath forehead what numbers could be on Anne forehead In other words compute the set of possible worlds that are indistinguishable from the world as far as Anne is concerned",
          "hierarchy": "Logic DynEpistemology",
          "module": "Logic.DynEpistemology",
          "name": "p2_anne_keys",
          "normalized": "P World-\u003e[P World]",
          "package": "liboleg",
          "signature": "P World-\u003e[P World]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Logic-DynEpistemology.html#v:p2_anne_keys"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe number on Bill's forehead in the world w\n\u003c/p\u003e",
          "module": "Logic.DynEpistemology",
          "name": "p2_bill",
          "package": "liboleg",
          "signature": "P2World -\u003e Int",
          "source": "src/Logic-DynEpistemology.html#p2_bill",
          "type": "function"
        },
        "index": {
          "description": "The number on Bill forehead in the world",
          "hierarchy": "Logic DynEpistemology",
          "module": "Logic.DynEpistemology",
          "name": "p2_bill",
          "normalized": "P World-\u003eInt",
          "package": "liboleg",
          "signature": "P World-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Logic-DynEpistemology.html#v:p2_bill"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWhich worlds Bill can't distinguish\n\u003c/p\u003e",
          "module": "Logic.DynEpistemology",
          "name": "p2_bill_keys",
          "package": "liboleg",
          "signature": "P2World -\u003e [P2World]",
          "source": "src/Logic-DynEpistemology.html#p2_bill_keys",
          "type": "function"
        },
        "index": {
          "description": "Which worlds Bill can distinguish",
          "hierarchy": "Logic DynEpistemology",
          "module": "Logic.DynEpistemology",
          "name": "p2_bill_keys",
          "normalized": "P World-\u003e[P World]",
          "package": "liboleg",
          "signature": "P World-\u003e[P World]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Logic-DynEpistemology.html#v:p2_bill_keys"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe number on Cath's forehead in the world w\n\u003c/p\u003e",
          "module": "Logic.DynEpistemology",
          "name": "p2_cath",
          "package": "liboleg",
          "signature": "P2World -\u003e Int",
          "source": "src/Logic-DynEpistemology.html#p2_cath",
          "type": "function"
        },
        "index": {
          "description": "The number on Cath forehead in the world",
          "hierarchy": "Logic DynEpistemology",
          "module": "Logic.DynEpistemology",
          "name": "p2_cath",
          "normalized": "P World-\u003eInt",
          "package": "liboleg",
          "signature": "P World-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Logic-DynEpistemology.html#v:p2_cath"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDitto for Cath\n\u003c/p\u003e",
          "module": "Logic.DynEpistemology",
          "name": "p2_cath_keys",
          "package": "liboleg",
          "signature": "P2World -\u003e [P2World]",
          "source": "src/Logic-DynEpistemology.html#p2_cath_keys",
          "type": "function"
        },
        "index": {
          "description": "Ditto for Cath",
          "hierarchy": "Logic DynEpistemology",
          "module": "Logic.DynEpistemology",
          "name": "p2_cath_keys",
          "normalized": "P World-\u003e[P World]",
          "package": "liboleg",
          "signature": "P World-\u003e[P World]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Logic-DynEpistemology.html#v:p2_cath_keys"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn initial stream of possible worlds for problem 2.\n The code is naive but hopefully obviously correct\n as it clearly corresponds to the statement of the problem.\n\u003c/p\u003e",
          "module": "Logic.DynEpistemology",
          "name": "p2worlds",
          "package": "liboleg",
          "signature": "m P2World",
          "source": "src/Logic-DynEpistemology.html#p2worlds",
          "type": "function"
        },
        "index": {
          "description": "An initial stream of possible worlds for problem The code is naive but hopefully obviously correct as it clearly corresponds to the statement of the problem",
          "hierarchy": "Logic DynEpistemology",
          "module": "Logic.DynEpistemology",
          "name": "p2worlds",
          "package": "liboleg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Logic-DynEpistemology.html#v:p2worlds"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEncoding the statement of the problem: the conversation steps.\n The remaining possible world gives us the solution.\n\u003c/p\u003e",
          "module": "Logic.DynEpistemology",
          "name": "prob1",
          "package": "liboleg",
          "signature": "[P1World]",
          "source": "src/Logic-DynEpistemology.html#prob1",
          "type": "function"
        },
        "index": {
          "description": "Encoding the statement of the problem the conversation steps The remaining possible world gives us the solution",
          "hierarchy": "Logic DynEpistemology",
          "module": "Logic.DynEpistemology",
          "name": "prob1",
          "normalized": "[P World]",
          "package": "liboleg",
          "signature": "[P World]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Logic-DynEpistemology.html#v:prob1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA variation of the problem:\n Assuming the numbers don't exceed 100, what\n are the numbers received by Anne and Bill?\n Again, the possible worlds consistent with the statement of\n the problem are the solutions.\n\u003c/p\u003e",
          "module": "Logic.DynEpistemology",
          "name": "prob1a",
          "package": "liboleg",
          "signature": "[P1World]",
          "source": "src/Logic-DynEpistemology.html#prob1a",
          "type": "function"
        },
        "index": {
          "description": "variation of the problem Assuming the numbers don exceed what are the numbers received by Anne and Bill Again the possible worlds consistent with the statement of the problem are the solutions",
          "hierarchy": "Logic DynEpistemology",
          "module": "Logic.DynEpistemology",
          "name": "prob1a",
          "normalized": "[P World]",
          "package": "liboleg",
          "signature": "[P World]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Logic-DynEpistemology.html#v:prob1a"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSpelling out the \u003ccode\u003e\u003ca\u003eunique\u003c/a\u003e\u003c/code\u003e condition, to demonstrate what it means\n\u003c/p\u003e",
          "module": "Logic.DynEpistemology",
          "name": "prob1a'",
          "package": "liboleg",
          "signature": "[[P1World]]",
          "source": "src/Logic-DynEpistemology.html#prob1a%27",
          "type": "function"
        },
        "index": {
          "description": "Spelling out the unique condition to demonstrate what it means",
          "hierarchy": "Logic DynEpistemology",
          "module": "Logic.DynEpistemology",
          "name": "prob1a'",
          "normalized": "[[P World]]",
          "package": "liboleg",
          "signature": "[[P World]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Logic-DynEpistemology.html#v:prob1a-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEncoding the statement of the problem: the conversation steps.\n The remaining possible world gives us the solution.\n\u003c/p\u003e",
          "module": "Logic.DynEpistemology",
          "name": "prob2",
          "package": "liboleg",
          "signature": "[P2World]",
          "source": "src/Logic-DynEpistemology.html#prob2",
          "type": "function"
        },
        "index": {
          "description": "Encoding the statement of the problem the conversation steps The remaining possible world gives us the solution",
          "hierarchy": "Logic DynEpistemology",
          "module": "Logic.DynEpistemology",
          "name": "prob2",
          "normalized": "[P World]",
          "package": "liboleg",
          "signature": "[P World]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Logic-DynEpistemology.html#v:prob2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGiven a proj function (yielding a set of keys for a world w),\n return a stream of worlds that are unique with\n respect to their keys. That is, there is only one\n world for the key.\n We accept a termination criterion.\n We terminate the stream once we have received the key\n for which the criterion returns true.\n When we receive a world whose key we have not seen,\n we quarantine it. We release from the quarantine\n when the stream is terminated.\n\u003c/p\u003e",
          "module": "Logic.DynEpistemology",
          "name": "unique",
          "package": "liboleg",
          "signature": "(w -\u003e [key]) -\u003e (key -\u003e Bool) -\u003e [w] -\u003e [w]",
          "source": "src/Logic-DynEpistemology.html#unique",
          "type": "function"
        },
        "index": {
          "description": "Given proj function yielding set of keys for world return stream of worlds that are unique with respect to their keys That is there is only one world for the key We accept termination criterion We terminate the stream once we have received the key for which the criterion returns true When we receive world whose key we have not seen we quarantine it We release from the quarantine when the stream is terminated",
          "hierarchy": "Logic DynEpistemology",
          "module": "Logic.DynEpistemology",
          "name": "unique",
          "normalized": "(a-\u003e[b])-\u003e(b-\u003eBool)-\u003e[a]-\u003e[a]",
          "package": "liboleg",
          "signature": "(w-\u003e[key])-\u003e(key-\u003eBool)-\u003e[w]-\u003e[w]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Logic-DynEpistemology.html#v:unique"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eMonadic and General Iteratees:\n incremental input parsers, processors and transformers\n\u003c/p\u003e\u003cp\u003eThe running example, parts 1 and 2\n Part 1 is reading the headers, the sequence of lines terminated by an\n empty line. Each line is terminated by CR, LF, or CRLF.\n We should return the headers in order. In the case of error,\n we should return the headers read so far and the description of the error.\n Part 2 is reading the headers and reading all the lines from the\n HTTP-chunk-encoded content that follows the headers. Part 2 thus\n verifies layering of streams, and processing of one stream\n embedded (chunk encoded) into another stream.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "System.IterateeM",
          "name": "IterateeM",
          "package": "liboleg",
          "source": "src/System-IterateeM.html",
          "type": "module"
        },
        "index": {
          "description": "Monadic and General Iteratees incremental input parsers processors and transformers The running example parts and Part is reading the headers the sequence of lines terminated by an empty line Each line is terminated by CR LF or CRLF We should return the headers in order In the case of error we should return the headers read so far and the description of the error Part is reading the headers and reading all the lines from the HTTP-chunk-encoded content that follows the headers Part thus verifies layering of streams and processing of one stream embedded chunk encoded into another stream",
          "hierarchy": "System IterateeM",
          "module": "System.IterateeM",
          "name": "IterateeM",
          "package": "liboleg",
          "partial": "Iteratee",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/System-IterateeM.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEnumerators\n Each enumerator takes an iteratee and returns an iteratee\n an Enumerator is an iteratee transformer.\n The enumerator normally stops when the stream is terminated\n or when the iteratee moves to the done state, whichever comes first.\n When to stop is of course up to the enumerator...\n\u003c/p\u003e\u003cp\u003eWe have two choices of composition: compose iteratees or compose\n enumerators. The latter is useful when one iteratee\n reads from the concatenation of two data sources.\n\u003c/p\u003e",
          "module": "System.IterateeM",
          "name": "EnumeratorGM",
          "package": "liboleg",
          "source": "src/System-IterateeM.html#EnumeratorGM",
          "type": "type"
        },
        "index": {
          "description": "Enumerators Each enumerator takes an iteratee and returns an iteratee an Enumerator is an iteratee transformer The enumerator normally stops when the stream is terminated or when the iteratee moves to the done state whichever comes first When to stop is of course up to the enumerator We have two choices of composition compose iteratees or compose enumerators The latter is useful when one iteratee reads from the concatenation of two data sources",
          "hierarchy": "System IterateeM",
          "module": "System.IterateeM",
          "name": "EnumeratorGM",
          "package": "liboleg",
          "partial": "Enumerator GM",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/System-IterateeM.html#t:EnumeratorGM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "System.IterateeM",
          "name": "EnumeratorM",
          "package": "liboleg",
          "source": "src/System-IterateeM.html#EnumeratorM",
          "type": "type"
        },
        "index": {
          "hierarchy": "System IterateeM",
          "module": "System.IterateeM",
          "name": "EnumeratorM",
          "package": "liboleg",
          "partial": "Enumerator",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/System-IterateeM.html#t:EnumeratorM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIteratee converters for stream embedding\n The converters show a different way of composing two iteratees:\n \u003ccode\u003evertical\u003c/code\u003e rather than \u003ccode\u003ehorizontal\u003c/code\u003e\n\u003c/p\u003e\u003cp\u003eThe type of the converter from the stream with elements el_outer\n to the stream with element el_inner. The result is the iteratee\n for the outer stream that uses  an `IterateeG el_inner m a'\n to process the embedded, inner stream as it reads the outer stream.\n\u003c/p\u003e",
          "module": "System.IterateeM",
          "name": "EnumeratorN",
          "package": "liboleg",
          "source": "src/System-IterateeM.html#EnumeratorN",
          "type": "type"
        },
        "index": {
          "description": "Iteratee converters for stream embedding The converters show different way of composing two iteratees vertical rather than horizontal The type of the converter from the stream with elements el outer to the stream with element el inner The result is the iteratee for the outer stream that uses an IterateeG el inner to process the embedded inner stream as it reads the outer stream",
          "hierarchy": "System IterateeM",
          "module": "System.IterateeM",
          "name": "EnumeratorN",
          "package": "liboleg",
          "partial": "Enumerator",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/System-IterateeM.html#t:EnumeratorN"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "System.IterateeM",
          "name": "Iteratee",
          "package": "liboleg",
          "source": "src/System-IterateeM.html#Iteratee",
          "type": "type"
        },
        "index": {
          "hierarchy": "System IterateeM",
          "module": "System.IterateeM",
          "name": "Iteratee",
          "package": "liboleg",
          "partial": "Iteratee",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/System-IterateeM.html#t:Iteratee"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIteratee -- a generic stream processor, what is being folded over\n a stream\n When Iteratee is in the \u003ccode\u003edone\u003c/code\u003e state, it contains the computed\n result and the remaining part of the stream.\n In the \u003ccode\u003econt\u003c/code\u003e state, the iteratee has not finished the computation\n and needs more input.\n We assume that all iteratees are \u003ccode\u003egood\u003c/code\u003e -- given bounded input,\n they do the bounded amount of computation and take the bounded amount\n of resources. The monad m describes the sort of computations done\n by the iteratee as it processes the stream. The monad m could be\n the identity monad (for pure computations) or the IO monad\n (to let the iteratee store the stream processing results as they\n are computed).\n We also assume that given a terminated stream, an iteratee\n moves to the done state, so the results computed so far could be returned.\n\u003c/p\u003e\u003cp\u003eWe could have used existentials instead, by doing the closure conversion\n\u003c/p\u003e",
          "module": "System.IterateeM",
          "name": "IterateeG",
          "package": "liboleg",
          "source": "src/System-IterateeM.html#IterateeG",
          "type": "data"
        },
        "index": {
          "description": "Iteratee generic stream processor what is being folded over stream When Iteratee is in the done state it contains the computed result and the remaining part of the stream In the cont state the iteratee has not finished the computation and needs more input We assume that all iteratees are good given bounded input they do the bounded amount of computation and take the bounded amount of resources The monad describes the sort of computations done by the iteratee as it processes the stream The monad could be the identity monad for pure computations or the IO monad to let the iteratee store the stream processing results as they are computed We also assume that given terminated stream an iteratee moves to the done state so the results computed so far could be returned We could have used existentials instead by doing the closure conversion",
          "hierarchy": "System IterateeM",
          "module": "System.IterateeM",
          "name": "IterateeG",
          "package": "liboleg",
          "partial": "Iteratee",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/System-IterateeM.html#t:IterateeG"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "System.IterateeM",
          "name": "IterateeGM",
          "package": "liboleg",
          "source": "src/System-IterateeM.html#IterateeGM",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "System IterateeM",
          "module": "System.IterateeM",
          "name": "IterateeGM",
          "package": "liboleg",
          "partial": "Iteratee GM",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/System-IterateeM.html#t:IterateeGM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "System.IterateeM",
          "name": "IterateeM",
          "package": "liboleg",
          "source": "src/System-IterateeM.html#IterateeM",
          "type": "type"
        },
        "index": {
          "hierarchy": "System IterateeM",
          "module": "System.IterateeM",
          "name": "IterateeM",
          "package": "liboleg",
          "partial": "Iteratee",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/System-IterateeM.html#t:IterateeM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCombining the primitive iteratees to solve the running problem:\n Reading headers and the content from an HTTP-like stream\n\u003c/p\u003e",
          "module": "System.IterateeM",
          "name": "Line",
          "package": "liboleg",
          "source": "src/System-IterateeM.html#Line",
          "type": "type"
        },
        "index": {
          "description": "Combining the primitive iteratees to solve the running problem Reading headers and the content from an HTTP-like stream",
          "hierarchy": "System IterateeM",
          "module": "System.IterateeM",
          "name": "Line",
          "package": "liboleg",
          "partial": "Line",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/System-IterateeM.html#t:Line"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA particular instance of StreamG: the stream of characters.\n This stream is used by many input parsers.\n\u003c/p\u003e",
          "module": "System.IterateeM",
          "name": "Stream",
          "package": "liboleg",
          "source": "src/System-IterateeM.html#Stream",
          "type": "type"
        },
        "index": {
          "description": "particular instance of StreamG the stream of characters This stream is used by many input parsers",
          "hierarchy": "System IterateeM",
          "module": "System.IterateeM",
          "name": "Stream",
          "package": "liboleg",
          "partial": "Stream",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/System-IterateeM.html#t:Stream"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA stream is a (continuing) sequence of elements bundled in Chunks.\n The first two variants indicate termination of the stream.\n Chunk [a] gives the currently available part of the stream.\n The stream is not terminated yet.\n The case (Chunk []) signifies a stream with no currently available\n data but which is still continuing. A stream processor should,\n informally speaking, ``suspend itself'' and wait for more data\n to arrive.\n Later on, we can add another variant: IE_block (Ptr CChar) CSize\n so we could parse right from the buffer.\n\u003c/p\u003e",
          "module": "System.IterateeM",
          "name": "StreamG",
          "package": "liboleg",
          "source": "src/System-IterateeM.html#StreamG",
          "type": "data"
        },
        "index": {
          "description": "stream is continuing sequence of elements bundled in Chunks The first two variants indicate termination of the stream Chunk gives the currently available part of the stream The stream is not terminated yet The case Chunk signifies stream with no currently available data but which is still continuing stream processor should informally speaking suspend itself and wait for more data to arrive Later on we can add another variant IE block Ptr CChar CSize so we could parse right from the buffer",
          "hierarchy": "System IterateeM",
          "module": "System.IterateeM",
          "name": "StreamG",
          "package": "liboleg",
          "partial": "Stream",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/System-IterateeM.html#t:StreamG"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eJust like an application -- a call-by-value-like application\n\u003c/p\u003e",
          "module": "System.IterateeM",
          "name": "(==\u003c\u003c)",
          "package": "liboleg",
          "signature": "(IterateeG el m a -\u003e IterateeGM el' m b) -\u003e IterateeGM el m a -\u003e IterateeGM el' m b",
          "source": "src/System-IterateeM.html#%3D%3D%3C%3C",
          "type": "function"
        },
        "index": {
          "description": "Just like an application call-by-value-like application",
          "hierarchy": "System IterateeM",
          "module": "System.IterateeM",
          "name": "(==\u003c\u003c) ==\u003c\u003c",
          "normalized": "(IterateeG a b c-\u003eIterateeGM d b e)-\u003eIterateeGM a b c-\u003eIterateeGM d b e",
          "package": "liboleg",
          "signature": "(IterateeG el m a-\u003eIterateeGM el' m b)-\u003eIterateeGM el m a-\u003eIterateeGM el' m b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/System-IterateeM.html#v:-61--61--60--60-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eJust like bind (at run-time, this is indeed exactly bind)\n\u003c/p\u003e",
          "module": "System.IterateeM",
          "name": "(\u003e\u003e==)",
          "package": "liboleg",
          "signature": "IterateeGM el m a -\u003e (IterateeG el m a -\u003e IterateeGM el' m b) -\u003e IterateeGM el' m b",
          "source": "src/System-IterateeM.html#%3E%3E%3D%3D",
          "type": "function"
        },
        "index": {
          "description": "Just like bind at run-time this is indeed exactly bind",
          "hierarchy": "System IterateeM",
          "module": "System.IterateeM",
          "name": "(\u003e\u003e==) \u003e\u003e==",
          "normalized": "IterateeGM a b c-\u003e(IterateeG a b c-\u003eIterateeGM d b e)-\u003eIterateeGM d b e",
          "package": "liboleg",
          "signature": "IterateeGM el m a-\u003e(IterateeG el m a-\u003eIterateeGM el' m b)-\u003eIterateeGM el' m b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/System-IterateeM.html#v:-62--62--61--61-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe composition of two enumerators: essentially the functional composition\n It is convenient to flip the order of the arguments of the composition\n though: in e1 \u003e. e2, e1 is executed first\n\u003c/p\u003e",
          "module": "System.IterateeM",
          "name": "(\u003e.)",
          "package": "liboleg",
          "signature": "EnumeratorGM el m a -\u003e EnumeratorGM el m a -\u003e EnumeratorGM el m a",
          "source": "src/System-IterateeM.html#%3E.",
          "type": "function"
        },
        "index": {
          "description": "The composition of two enumerators essentially the functional composition It is convenient to flip the order of the arguments of the composition though in e1 e2 e1 is executed first",
          "hierarchy": "System IterateeM",
          "module": "System.IterateeM",
          "name": "(\u003e.) \u003e.",
          "normalized": "EnumeratorGM a b c-\u003eEnumeratorGM a b c-\u003eEnumeratorGM a b c",
          "package": "liboleg",
          "signature": "EnumeratorGM el m a-\u003eEnumeratorGM el m a-\u003eEnumeratorGM el m a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/System-IterateeM.html#v:-62-."
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "System.IterateeM",
          "name": "Chunk",
          "package": "liboleg",
          "signature": "Chunk [a]",
          "source": "src/System-IterateeM.html#StreamG",
          "type": "function"
        },
        "index": {
          "hierarchy": "System IterateeM",
          "module": "System.IterateeM",
          "name": "Chunk",
          "normalized": "Chunk[a]",
          "package": "liboleg",
          "partial": "Chunk",
          "signature": "Chunk[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/System-IterateeM.html#v:Chunk"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "System.IterateeM",
          "name": "EOF",
          "package": "liboleg",
          "signature": "EOF",
          "source": "src/System-IterateeM.html#StreamG",
          "type": "function"
        },
        "index": {
          "hierarchy": "System IterateeM",
          "module": "System.IterateeM",
          "name": "EOF",
          "package": "liboleg",
          "partial": "EOF",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/System-IterateeM.html#v:EOF"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "System.IterateeM",
          "name": "Err",
          "package": "liboleg",
          "signature": "Err String",
          "source": "src/System-IterateeM.html#StreamG",
          "type": "function"
        },
        "index": {
          "hierarchy": "System IterateeM",
          "module": "System.IterateeM",
          "name": "Err",
          "package": "liboleg",
          "partial": "Err",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/System-IterateeM.html#v:Err"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "System.IterateeM",
          "name": "IE_cont",
          "package": "liboleg",
          "signature": "IE_cont (StreamG el -\u003e IterateeGM el m a)",
          "source": "src/System-IterateeM.html#IterateeG",
          "type": "function"
        },
        "index": {
          "hierarchy": "System IterateeM",
          "module": "System.IterateeM",
          "name": "IE_cont",
          "normalized": "IE_cont(StreamG a-\u003eIterateeGM a b c)",
          "package": "liboleg",
          "partial": "IE",
          "signature": "IE_cont(StreamG el-\u003eIterateeGM el m a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/System-IterateeM.html#v:IE_cont"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "System.IterateeM",
          "name": "IE_done",
          "package": "liboleg",
          "signature": "IE_done a (StreamG el)",
          "source": "src/System-IterateeM.html#IterateeG",
          "type": "function"
        },
        "index": {
          "hierarchy": "System IterateeM",
          "module": "System.IterateeM",
          "name": "IE_done",
          "package": "liboleg",
          "partial": "IE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/System-IterateeM.html#v:IE_done"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "System.IterateeM",
          "name": "IM",
          "package": "liboleg",
          "signature": "IM",
          "source": "src/System-IterateeM.html#IterateeGM",
          "type": "function"
        },
        "index": {
          "hierarchy": "System IterateeM",
          "module": "System.IterateeM",
          "name": "IM",
          "package": "liboleg",
          "partial": "IM",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/System-IterateeM.html#v:IM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert one stream into another, not necessarily in \u003ccode\u003elockstep\u003c/code\u003e\n The transformer map_stream maps one element of the outer stream\n to one element of the nested stream. The transformer below is more\n general: it may take several elements of the outer stream to produce\n one element of the inner stream, or the other way around.\n The transformation from one stream to the other is specified as\n IterateeGM el m (Maybe [el']). The \u003ccode\u003e\u003ca\u003eMaybe\u003c/a\u003e\u003c/code\u003e type reflects the\n possibility of the conversion error.\n\u003c/p\u003e",
          "module": "System.IterateeM",
          "name": "conv_stream",
          "package": "liboleg",
          "signature": "IterateeGM el m (Maybe [el']) -\u003e EnumeratorN el el' m a",
          "source": "src/System-IterateeM.html#conv_stream",
          "type": "function"
        },
        "index": {
          "description": "Convert one stream into another not necessarily in lockstep The transformer map stream maps one element of the outer stream to one element of the nested stream The transformer below is more general it may take several elements of the outer stream to produce one element of the inner stream or the other way around The transformation from one stream to the other is specified as IterateeGM el Maybe el The Maybe type reflects the possibility of the conversion error",
          "hierarchy": "System IterateeM",
          "module": "System.IterateeM",
          "name": "conv_stream",
          "normalized": "IterateeGM a b(Maybe[c])-\u003eEnumeratorN a c b d",
          "package": "liboleg",
          "signature": "IterateeGM el m(Maybe[el'])-\u003eEnumeratorN el el' m a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/System-IterateeM.html#v:conv_stream"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eHTTP chunk decoding\n Each chunk has the following format:\n\u003c/p\u003e\u003cpre\u003e      \u003cchunk-size\u003e CRLF \u003cchunk-data\u003e CRLF\n\u003c/pre\u003e\u003cp\u003ewhere \u003ca\u003echunk-size\u003c/a\u003e is the hexadecimal number; \u003ca\u003echunk-data\u003c/a\u003e is a\n sequence of \u003ca\u003echunk-size\u003c/a\u003e bytes.\n The last chunk (so-called EOF chunk) has the format\n 0 CRLF CRLF (where 0 is an ASCII zero, a character with the decimal code 48).\n For more detail, see \u003ca\u003eChunked Transfer Coding\u003c/a\u003e, Sec 3.6.1 of\n the HTTP/1.1 standard:\n \u003ca\u003ehttp://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.6.1\u003c/a\u003e\n\u003c/p\u003e\u003cp\u003eThe following enum_chunk_decoded has the signature of the enumerator\n of the nested (encapsulated and chunk-encoded) stream. It receives\n an iteratee for the embedded stream and returns the iteratee for\n the base, embedding stream. Thus what is an enumerator and what\n is an iteratee may be a matter of perspective.\n\u003c/p\u003e\u003cp\u003eWe have a decision to make: Suppose an iteratee has finished (either because\n it obtained all needed data or encountered an error that makes further\n processing meaningless). While skipping the rest of the stream/the trailer,\n we encountered a framing error (e.g., missing CRLF after chunk data).\n What do we do? We chose to disregard the latter problem.\n Rationale: when the iteratee has finished, we are in the process\n of skipping up to the EOF (draining the source).\n Disregarding the errors seems OK then.\n Also, the iteratee may have found an error and decided to abort further\n processing. Flushing the remainder of the input is reasonable then.\n One can make a different choice...\n\u003c/p\u003e",
          "module": "System.IterateeM",
          "name": "enum_chunk_decoded",
          "package": "liboleg",
          "signature": "Iteratee m a -\u003e IterateeM m a",
          "source": "src/System-IterateeM.html#enum_chunk_decoded",
          "type": "function"
        },
        "index": {
          "description": "HTTP chunk decoding Each chunk has the following format chunk-size CRLF chunk-data CRLF where chunk-size is the hexadecimal number chunk-data is sequence of chunk-size bytes The last chunk so-called EOF chunk has the format CRLF CRLF where is an ASCII zero character with the decimal code For more detail see Chunked Transfer Coding Sec of the HTTP standard http www.w3.org Protocols rfc2616 rfc2616-sec3.html sec3.6.1 The following enum chunk decoded has the signature of the enumerator of the nested encapsulated and chunk-encoded stream It receives an iteratee for the embedded stream and returns the iteratee for the base embedding stream Thus what is an enumerator and what is an iteratee may be matter of perspective We have decision to make Suppose an iteratee has finished either because it obtained all needed data or encountered an error that makes further processing meaningless While skipping the rest of the stream the trailer we encountered framing error e.g missing CRLF after chunk data What do we do We chose to disregard the latter problem Rationale when the iteratee has finished we are in the process of skipping up to the EOF draining the source Disregarding the errors seems OK then Also the iteratee may have found an error and decided to abort further processing Flushing the remainder of the input is reasonable then One can make different choice",
          "hierarchy": "System IterateeM",
          "module": "System.IterateeM",
          "name": "enum_chunk_decoded",
          "normalized": "Iteratee a b-\u003eIterateeM a b",
          "package": "liboleg",
          "signature": "Iteratee m a-\u003eIterateeM m a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/System-IterateeM.html#v:enum_chunk_decoded"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe most primitive enumerator: applies the iteratee to the terminated\n stream. The result is the iteratee usually in the done state.\n\u003c/p\u003e",
          "module": "System.IterateeM",
          "name": "enum_eof",
          "package": "liboleg",
          "signature": "EnumeratorGM el m a",
          "source": "src/System-IterateeM.html#enum_eof",
          "type": "function"
        },
        "index": {
          "description": "The most primitive enumerator applies the iteratee to the terminated stream The result is the iteratee usually in the done state",
          "hierarchy": "System IterateeM",
          "module": "System.IterateeM",
          "name": "enum_eof",
          "package": "liboleg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/System-IterateeM.html#v:enum_eof"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAnother primitive enumerator: report an error\n\u003c/p\u003e",
          "module": "System.IterateeM",
          "name": "enum_err",
          "package": "liboleg",
          "signature": "String -\u003e EnumeratorGM el m a",
          "source": "src/System-IterateeM.html#enum_err",
          "type": "function"
        },
        "index": {
          "description": "Another primitive enumerator report an error",
          "hierarchy": "System IterateeM",
          "module": "System.IterateeM",
          "name": "enum_err",
          "normalized": "String-\u003eEnumeratorGM a b c",
          "package": "liboleg",
          "signature": "String-\u003eEnumeratorGM el m a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/System-IterateeM.html#v:enum_err"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe enumerator of a POSIX Fd\n Unlike fdRead (which allocates a new buffer on\n each invocation), we use the same buffer all throughout\n\u003c/p\u003e",
          "module": "System.IterateeM",
          "name": "enum_fd",
          "package": "liboleg",
          "signature": "Fd -\u003e EnumeratorM IO a",
          "source": "src/System-IterateeM.html#enum_fd",
          "type": "function"
        },
        "index": {
          "description": "The enumerator of POSIX Fd Unlike fdRead which allocates new buffer on each invocation we use the same buffer all throughout",
          "hierarchy": "System IterateeM",
          "module": "System.IterateeM",
          "name": "enum_fd",
          "normalized": "Fd-\u003eEnumeratorM IO a",
          "package": "liboleg",
          "signature": "Fd-\u003eEnumeratorM IO a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/System-IterateeM.html#v:enum_fd"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "System.IterateeM",
          "name": "enum_file",
          "package": "liboleg",
          "signature": "FilePath -\u003e EnumeratorM IO a",
          "source": "src/System-IterateeM.html#enum_file",
          "type": "function"
        },
        "index": {
          "hierarchy": "System IterateeM",
          "module": "System.IterateeM",
          "name": "enum_file",
          "normalized": "FilePath-\u003eEnumeratorM IO a",
          "package": "liboleg",
          "signature": "FilePath-\u003eEnumeratorM IO a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/System-IterateeM.html#v:enum_file"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert the stream of characters to the stream of lines, and\n apply the given iteratee to enumerate the latter.\n The stream of lines is normally terminated by the empty line.\n When the stream of characters is terminated, the stream of lines\n is also terminated, abnormally.\n This is the first proper iteratee-enumerator: it is the iteratee of the\n character stream and the enumerator of the line stream.\n More generally, we could have used conv_stream to implement enum_lines.\n\u003c/p\u003e",
          "module": "System.IterateeM",
          "name": "enum_lines",
          "package": "liboleg",
          "signature": "EnumeratorN Char Line m a",
          "source": "src/System-IterateeM.html#enum_lines",
          "type": "function"
        },
        "index": {
          "description": "Convert the stream of characters to the stream of lines and apply the given iteratee to enumerate the latter The stream of lines is normally terminated by the empty line When the stream of characters is terminated the stream of lines is also terminated abnormally This is the first proper iteratee-enumerator it is the iteratee of the character stream and the enumerator of the line stream More generally we could have used conv stream to implement enum lines",
          "hierarchy": "System IterateeM",
          "module": "System.IterateeM",
          "name": "enum_lines",
          "package": "liboleg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/System-IterateeM.html#v:enum_lines"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe pure 1-chunk enumerator\n It passes a given list of elements to the iteratee in one chunk\n This enumerator does no IO and is useful for testing of base parsing\n\u003c/p\u003e",
          "module": "System.IterateeM",
          "name": "enum_pure_1chunk",
          "package": "liboleg",
          "signature": "[el] -\u003e EnumeratorGM el m a",
          "source": "src/System-IterateeM.html#enum_pure_1chunk",
          "type": "function"
        },
        "index": {
          "description": "The pure chunk enumerator It passes given list of elements to the iteratee in one chunk This enumerator does no IO and is useful for testing of base parsing",
          "hierarchy": "System IterateeM",
          "module": "System.IterateeM",
          "name": "enum_pure_1chunk",
          "normalized": "[a]-\u003eEnumeratorGM a b c",
          "package": "liboleg",
          "signature": "[el]-\u003eEnumeratorGM el m a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/System-IterateeM.html#v:enum_pure_1chunk"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe pure n-chunk enumerator\n It passes a given lift of elements to the iteratee in n chunks\n This enumerator does no IO and is useful for testing of base parsing\n and handling of chunk boundaries\n\u003c/p\u003e",
          "module": "System.IterateeM",
          "name": "enum_pure_nchunk",
          "package": "liboleg",
          "signature": "[el] -\u003e Int -\u003e EnumeratorGM el m a",
          "source": "src/System-IterateeM.html#enum_pure_nchunk",
          "type": "function"
        },
        "index": {
          "description": "The pure n-chunk enumerator It passes given lift of elements to the iteratee in chunks This enumerator does no IO and is useful for testing of base parsing and handling of chunk boundaries",
          "hierarchy": "System IterateeM",
          "module": "System.IterateeM",
          "name": "enum_pure_nchunk",
          "normalized": "[a]-\u003eInt-\u003eEnumeratorGM a b c",
          "package": "liboleg",
          "signature": "[el]-\u003eInt-\u003eEnumeratorGM el m a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/System-IterateeM.html#v:enum_pure_nchunk"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert the stream of characters to the stream of words, and\n apply the given iteratee to enumerate the latter.\n Words are delimited by white space.\n This is the analogue of List.words\n It is instructive to compare the code below with the code of\n List.words, which is:\n\u003c/p\u003e\u003cpre\u003ewords                   :: String -\u003e [String]\nwords s                 =  case dropWhile isSpace s of\n                                \"\" -\u003e []\n                                s' -\u003e w : words s''\n                                      where (w, s'') =\n                                            break isSpace s'\n\u003c/pre\u003e\u003cp\u003eOne should keep in mind that enum_words is a more general, monadic\n function.\n More generally, we could have used conv_stream to implement enum_words.\n\u003c/p\u003e",
          "module": "System.IterateeM",
          "name": "enum_words",
          "package": "liboleg",
          "signature": "EnumeratorN Char String m a",
          "source": "src/System-IterateeM.html#enum_words",
          "type": "function"
        },
        "index": {
          "description": "Convert the stream of characters to the stream of words and apply the given iteratee to enumerate the latter Words are delimited by white space This is the analogue of List.words It is instructive to compare the code below with the code of List.words which is words String String words case dropWhile isSpace of words where break isSpace One should keep in mind that enum words is more general monadic function More generally we could have used conv stream to implement enum words",
          "hierarchy": "System IterateeM",
          "module": "System.IterateeM",
          "name": "enum_words",
          "package": "liboleg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/System-IterateeM.html#v:enum_words"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCheck to see if the stream is in error\n\u003c/p\u003e",
          "module": "System.IterateeM",
          "name": "iter_report_err",
          "package": "liboleg",
          "signature": "IterateeGM el m (Maybe String)",
          "source": "src/System-IterateeM.html#iter_report_err",
          "type": "function"
        },
        "index": {
          "description": "Check to see if the stream is in error",
          "hierarchy": "System IterateeM",
          "module": "System.IterateeM",
          "name": "iter_report_err",
          "package": "liboleg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/System-IterateeM.html#v:iter_report_err"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe following is a \u003ccode\u003evariant\u003c/code\u003e of join in the IterateeGM el m monad.\n When el' is the same as el, the type of joinI is indeed that of\n true monadic join. However, joinI is subtly different: since\n generally el' is different from el, it makes no sense to\n continue using the internal, IterateeG el' m a: we no longer\n have elements of the type el' to feed to that iteratee.\n We thus send EOF to the internal Iteratee and propagate its result.\n This join function is useful when dealing with `derived iteratees'\n for embedded/nested streams. In particular, joinI is useful to\n process the result of stake, map_stream, or conv_stream below.\n\u003c/p\u003e",
          "module": "System.IterateeM",
          "name": "joinI",
          "package": "liboleg",
          "signature": "IterateeGM el m (IterateeG el' m a) -\u003e IterateeGM el m a",
          "source": "src/System-IterateeM.html#joinI",
          "type": "function"
        },
        "index": {
          "description": "The following is variant of join in the IterateeGM el monad When el is the same as el the type of joinI is indeed that of true monadic join However joinI is subtly different since generally el is different from el it makes no sense to continue using the internal IterateeG el we no longer have elements of the type el to feed to that iteratee We thus send EOF to the internal Iteratee and propagate its result This join function is useful when dealing with derived iteratees for embedded nested streams In particular joinI is useful to process the result of stake map stream or conv stream below",
          "hierarchy": "System IterateeM",
          "module": "System.IterateeM",
          "name": "joinI",
          "normalized": "IterateeGM a b(IterateeG c b d)-\u003eIterateeGM a b d",
          "package": "liboleg",
          "signature": "IterateeGM el m(IterateeG el' m a)-\u003eIterateeGM el m a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/System-IterateeM.html#v:joinI"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUseful combinators for implementing iteratees and enumerators\n\u003c/p\u003e",
          "module": "System.IterateeM",
          "name": "liftI",
          "package": "liboleg",
          "signature": "IterateeG el m a -\u003e IterateeGM el m a",
          "source": "src/System-IterateeM.html#liftI",
          "type": "function"
        },
        "index": {
          "description": "Useful combinators for implementing iteratees and enumerators",
          "hierarchy": "System IterateeM",
          "module": "System.IterateeM",
          "name": "liftI",
          "normalized": "IterateeG a b c-\u003eIterateeGM a b c",
          "package": "liboleg",
          "signature": "IterateeG el m a-\u003eIterateeGM el m a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/System-IterateeM.html#v:liftI"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRead the line of text from the stream\n The line can be terminated by CR, LF or CRLF.\n Return (Right Line) if successful. Return (Left Line) if EOF or\n a stream error were encountered before the terminator is seen.\n The returned line is the string read so far.\n\u003c/p\u003e\u003cp\u003eThe code is the same as that of pure Iteratee, only the signature\n has changed.\n Compare the code below with GHCBufferIO.line_lazy\n\u003c/p\u003e",
          "module": "System.IterateeM",
          "name": "line",
          "package": "liboleg",
          "signature": "IterateeM m (Either Line Line)",
          "source": "src/System-IterateeM.html#line",
          "type": "function"
        },
        "index": {
          "description": "Read the line of text from the stream The line can be terminated by CR LF or CRLF Return Right Line if successful Return Left Line if EOF or stream error were encountered before the terminator is seen The returned line is the string read so far The code is the same as that of pure Iteratee only the signature has changed Compare the code below with GHCBufferIO.line lazy",
          "hierarchy": "System IterateeM",
          "module": "System.IterateeM",
          "name": "line",
          "package": "liboleg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/System-IterateeM.html#v:line"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMap the stream: yet another iteratee transformer\n Given the stream of elements of the type el and the function el-\u003eel',\n build a nested stream of elements of the type el' and apply the\n given iteratee to it.\n Note the contravariance\n\u003c/p\u003e",
          "module": "System.IterateeM",
          "name": "map_stream",
          "package": "liboleg",
          "signature": "(el -\u003e el') -\u003e EnumeratorN el el' m a",
          "source": "src/System-IterateeM.html#map_stream",
          "type": "function"
        },
        "index": {
          "description": "Map the stream yet another iteratee transformer Given the stream of elements of the type el and the function el el build nested stream of elements of the type el and apply the given iteratee to it Note the contravariance",
          "hierarchy": "System IterateeM",
          "module": "System.IterateeM",
          "name": "map_stream",
          "normalized": "(a-\u003eb)-\u003eEnumeratorN a b c d",
          "package": "liboleg",
          "signature": "(el-\u003eel')-\u003eEnumeratorN el el' m a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/System-IterateeM.html#v:map_stream"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLine iteratees: processors of a stream whose elements are made of Lines\n\u003c/p\u003e\u003cp\u003eCollect all read lines and return them as a list\n see stream2list\n\u003c/p\u003e\u003cp\u003ePrint lines as they are received. This is the first \u003ccode\u003eimpure\u003c/code\u003e iteratee\n with non-trivial actions during chunk processing\n\u003c/p\u003e",
          "module": "System.IterateeM",
          "name": "print_lines",
          "package": "liboleg",
          "signature": "IterateeGM Line IO ()",
          "source": "src/System-IterateeM.html#print_lines",
          "type": "function"
        },
        "index": {
          "description": "Line iteratees processors of stream whose elements are made of Lines Collect all read lines and return them as list see stream2list Print lines as they are received This is the first impure iteratee with non-trivial actions during chunk processing",
          "hierarchy": "System IterateeM",
          "module": "System.IterateeM",
          "name": "print_lines",
          "normalized": "IterateeGM Line IO()",
          "package": "liboleg",
          "signature": "IterateeGM Line IO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/System-IterateeM.html#v:print_lines"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe analogue of List.break\n It takes an element predicate and returns a pair:\n  (str, Just c) -- the element \u003ccode\u003ec\u003c/code\u003e is the first element of the stream\n                   satisfying the break predicate;\n                   The list str is the prefix of the stream up\n                   to but including \u003ccode\u003ec\u003c/code\u003e\n  (str,Nothing) -- The stream is terminated with EOF or error before\n                   any element satisfying the break predicate was found.\n                   str is the scanned part of the stream.\n None of the element in str satisfy the break predicate.\n\u003c/p\u003e",
          "module": "System.IterateeM",
          "name": "sbreak",
          "package": "liboleg",
          "signature": "(el -\u003e Bool) -\u003e IterateeGM el m ([el], Maybe el)",
          "source": "src/System-IterateeM.html#sbreak",
          "type": "function"
        },
        "index": {
          "description": "The analogue of List.break It takes an element predicate and returns pair str Just the element is the first element of the stream satisfying the break predicate The list str is the prefix of the stream up to but including str Nothing The stream is terminated with EOF or error before any element satisfying the break predicate was found str is the scanned part of the stream None of the element in str satisfy the break predicate",
          "hierarchy": "System IterateeM",
          "module": "System.IterateeM",
          "name": "sbreak",
          "normalized": "(a-\u003eBool)-\u003eIterateeGM a b([a],Maybe a)",
          "package": "liboleg",
          "signature": "(el-\u003eBool)-\u003eIterateeGM el m([el],Maybe el)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/System-IterateeM.html#v:sbreak"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSkip n elements of the stream, if there are that many\n This is the analogue of List.drop\n\u003c/p\u003e",
          "module": "System.IterateeM",
          "name": "sdrop",
          "package": "liboleg",
          "signature": "Int -\u003e IterateeGM el m ()",
          "source": "src/System-IterateeM.html#sdrop",
          "type": "function"
        },
        "index": {
          "description": "Skip elements of the stream if there are that many This is the analogue of List.drop",
          "hierarchy": "System IterateeM",
          "module": "System.IterateeM",
          "name": "sdrop",
          "normalized": "Int-\u003eIterateeGM a b()",
          "package": "liboleg",
          "signature": "Int-\u003eIterateeGM el m()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/System-IterateeM.html#v:sdrop"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA particular optimized case of the above: skip all elements of the stream\n satisfying the given predicate -- until the first element\n that does not satisfy the predicate, or the end of the stream.\n This is the analogue of List.dropWhile\n\u003c/p\u003e",
          "module": "System.IterateeM",
          "name": "sdropWhile",
          "package": "liboleg",
          "signature": "(el -\u003e Bool) -\u003e IterateeGM el m ()",
          "source": "src/System-IterateeM.html#sdropWhile",
          "type": "function"
        },
        "index": {
          "description": "particular optimized case of the above skip all elements of the stream satisfying the given predicate until the first element that does not satisfy the predicate or the end of the stream This is the analogue of List.dropWhile",
          "hierarchy": "System IterateeM",
          "module": "System.IterateeM",
          "name": "sdropWhile",
          "normalized": "(a-\u003eBool)-\u003eIterateeGM a b()",
          "package": "liboleg",
          "partial": "While",
          "signature": "(el-\u003eBool)-\u003eIterateeGM el m()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/System-IterateeM.html#v:sdropWhile"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSkip the rest of the stream\n\u003c/p\u003e",
          "module": "System.IterateeM",
          "name": "skip_till_eof",
          "package": "liboleg",
          "signature": "IterateeGM el m ()",
          "source": "src/System-IterateeM.html#skip_till_eof",
          "type": "function"
        },
        "index": {
          "description": "Skip the rest of the stream",
          "hierarchy": "System IterateeM",
          "module": "System.IterateeM",
          "name": "skip_till_eof",
          "normalized": "IterateeGM a b()",
          "package": "liboleg",
          "signature": "IterateeGM el m()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/System-IterateeM.html#v:skip_till_eof"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAttempt to read the next element of the stream\n Return (Just c) if successful, return Nothing if the stream is\n terminated (by EOF or an error)\n\u003c/p\u003e",
          "module": "System.IterateeM",
          "name": "snext",
          "package": "liboleg",
          "signature": "IterateeGM el m (Maybe el)",
          "source": "src/System-IterateeM.html#snext",
          "type": "function"
        },
        "index": {
          "description": "Attempt to read the next element of the stream Return Just if successful return Nothing if the stream is terminated by EOF or an error",
          "hierarchy": "System IterateeM",
          "module": "System.IterateeM",
          "name": "snext",
          "package": "liboleg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/System-IterateeM.html#v:snext"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLook ahead at the next element of the stream, without removing\n it from the stream.\n Return (Just c) if successful, return Nothing if the stream is\n terminated (by EOF or an error)\n\u003c/p\u003e",
          "module": "System.IterateeM",
          "name": "speek",
          "package": "liboleg",
          "signature": "IterateeGM el m (Maybe el)",
          "source": "src/System-IterateeM.html#speek",
          "type": "function"
        },
        "index": {
          "description": "Look ahead at the next element of the stream without removing it from the stream Return Just if successful return Nothing if the stream is terminated by EOF or an error",
          "hierarchy": "System IterateeM",
          "module": "System.IterateeM",
          "name": "speek",
          "package": "liboleg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/System-IterateeM.html#v:speek"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRead n elements from a stream and apply the given iteratee to the\n stream of the read elements. Unless the stream is terminated early, we\n read exactly n elements (even if the iteratee has accepted fewer).\n\u003c/p\u003e",
          "module": "System.IterateeM",
          "name": "stake",
          "package": "liboleg",
          "signature": "Int -\u003e EnumeratorN el el m a",
          "source": "src/System-IterateeM.html#stake",
          "type": "function"
        },
        "index": {
          "description": "Read elements from stream and apply the given iteratee to the stream of the read elements Unless the stream is terminated early we read exactly elements even if the iteratee has accepted fewer",
          "hierarchy": "System IterateeM",
          "module": "System.IterateeM",
          "name": "stake",
          "normalized": "Int-\u003eEnumeratorN a a b c",
          "package": "liboleg",
          "signature": "Int-\u003eEnumeratorN el el m a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/System-IterateeM.html#v:stake"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRead a stream to the end and return all of its elements as a list\n\u003c/p\u003e",
          "module": "System.IterateeM",
          "name": "stream2list",
          "package": "liboleg",
          "signature": "IterateeGM el m [el]",
          "source": "src/System-IterateeM.html#stream2list",
          "type": "function"
        },
        "index": {
          "description": "Read stream to the end and return all of its elements as list",
          "hierarchy": "System IterateeM",
          "module": "System.IterateeM",
          "name": "stream2list",
          "normalized": "IterateeGM a b[a]",
          "package": "liboleg",
          "signature": "IterateeGM el m[el]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/System-IterateeM.html#v:stream2list"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "System.IterateeM",
          "name": "unIM",
          "package": "liboleg",
          "signature": "m (IterateeG el m a)",
          "source": "src/System-IterateeM.html#IterateeGM",
          "type": "function"
        },
        "index": {
          "hierarchy": "System IterateeM",
          "module": "System.IterateeM",
          "name": "unIM",
          "package": "liboleg",
          "partial": "IM",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/System-IterateeM.html#v:unIM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eLow-level IO operations \n These operations are either missing from the GHC run-time library,\n or implemented suboptimally or heavy-handedly\n\u003c/p\u003e\u003c/div\u003e",
          "module": "System.LowLevelIO",
          "name": "LowLevelIO",
          "package": "liboleg",
          "source": "src/System-LowLevelIO.html",
          "type": "module"
        },
        "index": {
          "description": "Low-level IO operations These operations are either missing from the GHC run-time library or implemented suboptimally or heavy-handedly",
          "hierarchy": "System LowLevelIO",
          "module": "System.LowLevelIO",
          "name": "LowLevelIO",
          "package": "liboleg",
          "partial": "Low Level IO",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/System-LowLevelIO.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eHaskell representation for \u003ccode\u003eerrno\u003c/code\u003e values.\n The implementation is deliberately exposed, to allow users to add\n their own definitions of \u003ccode\u003e\u003ca\u003eErrno\u003c/a\u003e\u003c/code\u003e values.\n\u003c/p\u003e",
          "module": "System.LowLevelIO",
          "name": "Errno",
          "package": "liboleg",
          "type": "newtype"
        },
        "index": {
          "description": "Haskell representation for errno values The implementation is deliberately exposed to allow users to add their own definitions of Errno values",
          "hierarchy": "System LowLevelIO",
          "module": "System.LowLevelIO",
          "name": "Errno",
          "package": "liboleg",
          "partial": "Errno",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/System-LowLevelIO.html#t:Errno"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "System.LowLevelIO",
          "name": "Errno",
          "package": "liboleg",
          "signature": "Errno CInt",
          "type": "function"
        },
        "index": {
          "hierarchy": "System LowLevelIO",
          "module": "System.LowLevelIO",
          "name": "Errno",
          "package": "liboleg",
          "partial": "Errno",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/System-LowLevelIO.html#v:Errno"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAlas, GHC provides no function to read from Fd to an allocated buffer.\n The library function fdRead is not appropriate as it returns a string\n already. I'd rather get data from a buffer.\n Furthermore, fdRead (at least in GHC) allocates a new buffer each\n time it is called. This is a waste. Yet another problem with fdRead\n is in raising an exception on any IOError or even EOF. I'd rather\n avoid exceptions altogether.\n\u003c/p\u003e",
          "module": "System.LowLevelIO",
          "name": "myfdRead",
          "package": "liboleg",
          "signature": "Fd -\u003e Ptr CChar -\u003e ByteCount -\u003e IO (Either Errno ByteCount)",
          "source": "src/System-LowLevelIO.html#myfdRead",
          "type": "function"
        },
        "index": {
          "description": "Alas GHC provides no function to read from Fd to an allocated buffer The library function fdRead is not appropriate as it returns string already rather get data from buffer Furthermore fdRead at least in GHC allocates new buffer each time it is called This is waste Yet another problem with fdRead is in raising an exception on any IOError or even EOF rather avoid exceptions altogether",
          "hierarchy": "System LowLevelIO",
          "module": "System.LowLevelIO",
          "name": "myfdRead",
          "normalized": "Fd-\u003ePtr CChar-\u003eByteCount-\u003eIO(Either Errno ByteCount)",
          "package": "liboleg",
          "partial": "Read",
          "signature": "Fd-\u003ePtr CChar-\u003eByteCount-\u003eIO(Either Errno ByteCount)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/System-LowLevelIO.html#v:myfdRead"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe following fseek procedure throws no exceptions.\n\u003c/p\u003e",
          "module": "System.LowLevelIO",
          "name": "myfdSeek",
          "package": "liboleg",
          "signature": "Fd -\u003e SeekMode -\u003e FileOffset -\u003e IO (Either Errno FileOffset)",
          "source": "src/System-LowLevelIO.html#myfdSeek",
          "type": "function"
        },
        "index": {
          "description": "The following fseek procedure throws no exceptions",
          "hierarchy": "System LowLevelIO",
          "module": "System.LowLevelIO",
          "name": "myfdSeek",
          "normalized": "Fd-\u003eSeekMode-\u003eFileOffset-\u003eIO(Either Errno FileOffset)",
          "package": "liboleg",
          "partial": "Seek",
          "signature": "Fd-\u003eSeekMode-\u003eFileOffset-\u003eIO(Either Errno FileOffset)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/System-LowLevelIO.html#v:myfdSeek"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003epoll if file descriptors have something to read\n Return the list of read-pending descriptors\n\u003c/p\u003e",
          "module": "System.LowLevelIO",
          "name": "select'read'pending",
          "package": "liboleg",
          "signature": "[Fd] -\u003e IO (Either Errno [Fd])",
          "source": "src/System-LowLevelIO.html#select%27read%27pending",
          "type": "function"
        },
        "index": {
          "description": "poll if file descriptors have something to read Return the list of read-pending descriptors",
          "hierarchy": "System LowLevelIO",
          "module": "System.LowLevelIO",
          "name": "select'read'pending",
          "normalized": "[Fd]-\u003eIO(Either Errno[Fd])",
          "package": "liboleg",
          "signature": "[Fd]-\u003eIO(Either Errno[Fd])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/System-LowLevelIO.html#v:select-39-read-39-pending"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eRandom and Binary IO with IterateeM\n\u003c/p\u003e\u003cp\u003e\u003ca\u003ehttp://okmij.org/ftp/Streams.html#random-bin-IO\u003c/a\u003e\n\u003c/p\u003e\u003cp\u003eRandom and binary IO: Reading TIFF\n\u003c/p\u003e\u003cp\u003eIteratees presuppose sequential processing. A general-purpose input method\n    must also support random IO: processing a seek-able input stream from an\n    arbitrary position, jumping back and forth through the stream. We demonstrate\n    random IO with iteratees, as well as reading non-textual files and converting\n    raw bytes into multi-byte quantities such as integers, rationals, and TIFF\n    dictionaries. Positioning of the input stream is evocative of delimited\n    continuations.\n\u003c/p\u003e\u003cp\u003eWe use random and binary IO to write a general-purpose TIFF library. The\n    library emphasizes incremental processing, relying on iteratees and enumerators\n    for on-demand reading of tag values.  The library extensively uses nested\n    streams, tacitly converting the stream of raw bytes from the file into streams\n    of integers, rationals and other user-friendly items. The pixel matrix is\n    presented as a contiguous stream, regardless of its segmentation into strips\n    and physical arrangement.\n\u003c/p\u003e\u003cp\u003eWe show a representative application of the library: reading a sample TIFF\n    file, printing selected values from the TIFF dictionary, verifying the values\n    of selected pixels and computing the histogram of pixel values. The pixel\n    verification procedure stops reading the pixel matrix as soon as all specified\n    pixel values are verified. The histogram accumulation does read the entire\n    matrix, but incrementally. Neither pixel matrix processing procedure loads the\n    whole matrix in memory. In fact, we never read and retain more than the\n    IO-buffer-full of raw data.\n\u003c/p\u003e\u003cp\u003eVersion: The current version is 1.1, December 2008.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "System.RandomIO",
          "name": "RandomIO",
          "package": "liboleg",
          "source": "src/System-RandomIO.html",
          "type": "module"
        },
        "index": {
          "description": "Random and Binary IO with IterateeM http okmij.org ftp Streams.html random-bin-IO Random and binary IO Reading TIFF Iteratees presuppose sequential processing general-purpose input method must also support random IO processing seek-able input stream from an arbitrary position jumping back and forth through the stream We demonstrate random IO with iteratees as well as reading non-textual files and converting raw bytes into multi-byte quantities such as integers rationals and TIFF dictionaries Positioning of the input stream is evocative of delimited continuations We use random and binary IO to write general-purpose TIFF library The library emphasizes incremental processing relying on iteratees and enumerators for on-demand reading of tag values The library extensively uses nested streams tacitly converting the stream of raw bytes from the file into streams of integers rationals and other user-friendly items The pixel matrix is presented as contiguous stream regardless of its segmentation into strips and physical arrangement We show representative application of the library reading sample TIFF file printing selected values from the TIFF dictionary verifying the values of selected pixels and computing the histogram of pixel values The pixel verification procedure stops reading the pixel matrix as soon as all specified pixel values are verified The histogram accumulation does read the entire matrix but incrementally Neither pixel matrix processing procedure loads the whole matrix in memory In fact we never read and retain more than the IO-buffer-full of raw data Version The current version is December",
          "hierarchy": "System RandomIO",
          "module": "System.RandomIO",
          "name": "RandomIO",
          "package": "liboleg",
          "partial": "Random IO",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/System-RandomIO.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe type of the IO monad supporting seek requests and endianness\n The seek_request is not-quite a state, more like a `communication channel'\n set by the iteratee and answered by the enumerator. Since the\n base monad is IO, it seems simpler to implement both endianness\n and seek requests as IORef cells. Their names are grouped in a structure\n RBState, which is propagated as the `environment.'\n\u003c/p\u003e",
          "module": "System.RandomIO",
          "name": "RBIO",
          "package": "liboleg",
          "source": "src/System-RandomIO.html#RBIO",
          "type": "newtype"
        },
        "index": {
          "description": "The type of the IO monad supporting seek requests and endianness The seek request is not-quite state more like communication channel set by the iteratee and answered by the enumerator Since the base monad is IO it seems simpler to implement both endianness and seek requests as IORef cells Their names are grouped in structure RBState which is propagated as the environment",
          "hierarchy": "System RandomIO",
          "module": "System.RandomIO",
          "name": "RBIO",
          "package": "liboleg",
          "partial": "RBIO",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/System-RandomIO.html#t:RBIO"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGenerally, RBState is opaque and should not be exported.\n\u003c/p\u003e",
          "module": "System.RandomIO",
          "name": "RBState",
          "package": "liboleg",
          "source": "src/System-RandomIO.html#RBState",
          "type": "data"
        },
        "index": {
          "description": "Generally RBState is opaque and should not be exported",
          "hierarchy": "System RandomIO",
          "module": "System.RandomIO",
          "name": "RBState",
          "package": "liboleg",
          "partial": "RBState",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/System-RandomIO.html#t:RBState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "System.RandomIO",
          "name": "RBIO",
          "package": "liboleg",
          "signature": "RBIO",
          "source": "src/System-RandomIO.html#RBIO",
          "type": "function"
        },
        "index": {
          "hierarchy": "System RandomIO",
          "module": "System.RandomIO",
          "name": "RBIO",
          "package": "liboleg",
          "partial": "RBIO",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/System-RandomIO.html#v:RBIO"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "System.RandomIO",
          "name": "RBState",
          "package": "liboleg",
          "signature": "RBState",
          "source": "src/System-RandomIO.html#RBState",
          "type": "function"
        },
        "index": {
          "hierarchy": "System RandomIO",
          "module": "System.RandomIO",
          "name": "RBState",
          "package": "liboleg",
          "partial": "RBState",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/System-RandomIO.html#v:RBState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA useful combinator.\n Perhaps a better idea would have been to define\n Iteratee to have (Maybe a) in IE_done? In that case, we could\n make IterateeGM to be the instance of MonadPlus\n\u003c/p\u003e",
          "module": "System.RandomIO",
          "name": "bindm",
          "package": "liboleg",
          "signature": "m (Maybe a) -\u003e (a -\u003e m (Maybe b)) -\u003e m (Maybe b)",
          "source": "src/System-RandomIO.html#bindm",
          "type": "function"
        },
        "index": {
          "description": "useful combinator Perhaps better idea would have been to define Iteratee to have Maybe in IE done In that case we could make IterateeGM to be the instance of MonadPlus",
          "hierarchy": "System RandomIO",
          "module": "System.RandomIO",
          "name": "bindm",
          "normalized": "a(Maybe b)-\u003e(b-\u003ea(Maybe c))-\u003ea(Maybe c)",
          "package": "liboleg",
          "signature": "m(Maybe a)-\u003e(a-\u003em(Maybe b))-\u003em(Maybe b)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/System-RandomIO.html#v:bindm"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIteratees to read unsigned integers written in Big- or Little-endian ways\n\u003c/p\u003e",
          "module": "System.RandomIO",
          "name": "endian_read2",
          "package": "liboleg",
          "signature": "IterateeGM Word8 RBIO (Maybe Word16)",
          "source": "src/System-RandomIO.html#endian_read2",
          "type": "function"
        },
        "index": {
          "description": "Iteratees to read unsigned integers written in Big or Little-endian ways",
          "hierarchy": "System RandomIO",
          "module": "System.RandomIO",
          "name": "endian_read2",
          "package": "liboleg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/System-RandomIO.html#v:endian_read2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "System.RandomIO",
          "name": "endian_read4",
          "package": "liboleg",
          "signature": "IterateeGM Word8 RBIO (Maybe Word32)",
          "source": "src/System-RandomIO.html#endian_read4",
          "type": "function"
        },
        "index": {
          "hierarchy": "System RandomIO",
          "module": "System.RandomIO",
          "name": "endian_read4",
          "package": "liboleg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/System-RandomIO.html#v:endian_read4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe enumerator of a POSIX Fd: a variation of enum_fd that\n supports RandomIO (seek requests)\n\u003c/p\u003e",
          "module": "System.RandomIO",
          "name": "enum_fd_random",
          "package": "liboleg",
          "signature": "Fd -\u003e EnumeratorGM Word8 RBIO a",
          "source": "src/System-RandomIO.html#enum_fd_random",
          "type": "function"
        },
        "index": {
          "description": "The enumerator of POSIX Fd variation of enum fd that supports RandomIO seek requests",
          "hierarchy": "System RandomIO",
          "module": "System.RandomIO",
          "name": "enum_fd_random",
          "normalized": "Fd-\u003eEnumeratorGM Word RBIO a",
          "package": "liboleg",
          "signature": "Fd-\u003eEnumeratorGM Word RBIO a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/System-RandomIO.html#v:enum_fd_random"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn iteratee that reports and propagates an error\n We disregard the input first and then propagate error.\n It is reminiscent of \u003ccode\u003eabort\u003c/code\u003e\n\u003c/p\u003e",
          "module": "System.RandomIO",
          "name": "iter_err",
          "package": "liboleg",
          "signature": "String -\u003e IterateeGM el m ()",
          "source": "src/System-RandomIO.html#iter_err",
          "type": "function"
        },
        "index": {
          "description": "An iteratee that reports and propagates an error We disregard the input first and then propagate error It is reminiscent of abort",
          "hierarchy": "System RandomIO",
          "module": "System.RandomIO",
          "name": "iter_err",
          "normalized": "String-\u003eIterateeGM a b()",
          "package": "liboleg",
          "signature": "String-\u003eIterateeGM el m()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/System-RandomIO.html#v:iter_err"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "System.RandomIO",
          "name": "msb_first",
          "package": "liboleg",
          "signature": "IORef Bool",
          "source": "src/System-RandomIO.html#RBState",
          "type": "function"
        },
        "index": {
          "hierarchy": "System RandomIO",
          "module": "System.RandomIO",
          "name": "msb_first",
          "package": "liboleg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/System-RandomIO.html#v:msb_first"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "System.RandomIO",
          "name": "rb_msb_first",
          "package": "liboleg",
          "signature": "RBIO Bool",
          "source": "src/System-RandomIO.html#rb_msb_first",
          "type": "function"
        },
        "index": {
          "hierarchy": "System RandomIO",
          "module": "System.RandomIO",
          "name": "rb_msb_first",
          "package": "liboleg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/System-RandomIO.html#v:rb_msb_first"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "System.RandomIO",
          "name": "rb_msb_first_set",
          "package": "liboleg",
          "signature": "Bool -\u003e RBIO ()",
          "source": "src/System-RandomIO.html#rb_msb_first_set",
          "type": "function"
        },
        "index": {
          "hierarchy": "System RandomIO",
          "module": "System.RandomIO",
          "name": "rb_msb_first_set",
          "normalized": "Bool-\u003eRBIO()",
          "package": "liboleg",
          "signature": "Bool-\u003eRBIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/System-RandomIO.html#v:rb_msb_first_set"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "System.RandomIO",
          "name": "rb_seek_answered",
          "package": "liboleg",
          "signature": "RBIO Bool",
          "source": "src/System-RandomIO.html#rb_seek_answered",
          "type": "function"
        },
        "index": {
          "hierarchy": "System RandomIO",
          "module": "System.RandomIO",
          "name": "rb_seek_answered",
          "package": "liboleg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/System-RandomIO.html#v:rb_seek_answered"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe programmer should use the following functions instead\n\u003c/p\u003e\u003cp\u003eTo request seeking, the iteratee sets seek_req to (Just desired_offset)\n When the enumerator answers the request, it sets seek_req back\n to Nothing\n\u003c/p\u003e",
          "module": "System.RandomIO",
          "name": "rb_seek_set",
          "package": "liboleg",
          "signature": "FileOffset -\u003e RBIO ()",
          "source": "src/System-RandomIO.html#rb_seek_set",
          "type": "function"
        },
        "index": {
          "description": "The programmer should use the following functions instead To request seeking the iteratee sets seek req to Just desired offset When the enumerator answers the request it sets seek req back to Nothing",
          "hierarchy": "System RandomIO",
          "module": "System.RandomIO",
          "name": "rb_seek_set",
          "normalized": "FileOffset-\u003eRBIO()",
          "package": "liboleg",
          "signature": "FileOffset-\u003eRBIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/System-RandomIO.html#v:rb_seek_set"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "System.RandomIO",
          "name": "runRB",
          "package": "liboleg",
          "signature": "RBState -\u003e IterateeGM el RBIO a -\u003e IO (IterateeG el RBIO a)",
          "source": "src/System-RandomIO.html#runRB",
          "type": "function"
        },
        "index": {
          "hierarchy": "System RandomIO",
          "module": "System.RandomIO",
          "name": "runRB",
          "normalized": "RBState-\u003eIterateeGM a RBIO b-\u003eIO(IterateeG a RBIO b)",
          "package": "liboleg",
          "partial": "RB",
          "signature": "RBState-\u003eIterateeGM el RBIO a-\u003eIO(IterateeG el RBIO a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/System-RandomIO.html#v:runRB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "System.RandomIO",
          "name": "seek_req",
          "package": "liboleg",
          "signature": "IORef (Maybe FileOffset)",
          "source": "src/System-RandomIO.html#RBState",
          "type": "function"
        },
        "index": {
          "hierarchy": "System RandomIO",
          "module": "System.RandomIO",
          "name": "seek_req",
          "package": "liboleg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/System-RandomIO.html#v:seek_req"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWe discard all available input first.\n We keep discarding the stream s until we determine that our request \n has been answered:\n rb_seek_set sets the state seek_req to (Just off). When the\n request is answered, the state goes back to Nothing.\n The above features remind one of delimited continuations.\n\u003c/p\u003e",
          "module": "System.RandomIO",
          "name": "sseek",
          "package": "liboleg",
          "signature": "FileOffset -\u003e IterateeGM el RBIO ()",
          "source": "src/System-RandomIO.html#sseek",
          "type": "function"
        },
        "index": {
          "description": "We discard all available input first We keep discarding the stream until we determine that our request has been answered rb seek set sets the state seek req to Just off When the request is answered the state goes back to Nothing The above features remind one of delimited continuations",
          "hierarchy": "System RandomIO",
          "module": "System.RandomIO",
          "name": "sseek",
          "normalized": "FileOffset-\u003eIterateeGM a RBIO()",
          "package": "liboleg",
          "signature": "FileOffset-\u003eIterateeGM el RBIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/System-RandomIO.html#v:sseek"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRead n elements from a stream and apply the given iteratee to the\n stream of the read elements. If the given iteratee accepted fewer\n elements, we stop.\n This is the variation of \u003ccode\u003e\u003ca\u003estake\u003c/a\u003e\u003c/code\u003e with the early termination\n of processing of the outer stream once the processing of the inner stream\n finished early. This variation is particularly useful for randomIO,\n where we do not have to care to `drain the input stream'.\n\u003c/p\u003e",
          "module": "System.RandomIO",
          "name": "stakeR",
          "package": "liboleg",
          "signature": "Int -\u003e EnumeratorN el el m a",
          "source": "src/System-RandomIO.html#stakeR",
          "type": "function"
        },
        "index": {
          "description": "Read elements from stream and apply the given iteratee to the stream of the read elements If the given iteratee accepted fewer elements we stop This is the variation of stake with the early termination of processing of the outer stream once the processing of the inner stream finished early This variation is particularly useful for randomIO where we do not have to care to drain the input stream",
          "hierarchy": "System RandomIO",
          "module": "System.RandomIO",
          "name": "stakeR",
          "normalized": "Int-\u003eEnumeratorN a a b c",
          "package": "liboleg",
          "signature": "Int-\u003eEnumeratorN el el m a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/System-RandomIO.html#v:stakeR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "System.RandomIO",
          "name": "unRBIO",
          "package": "liboleg",
          "signature": "RBState -\u003e IO a",
          "source": "src/System-RandomIO.html#RBIO",
          "type": "function"
        },
        "index": {
          "hierarchy": "System RandomIO",
          "module": "System.RandomIO",
          "name": "unRBIO",
          "normalized": "RBState-\u003eIO a",
          "package": "liboleg",
          "partial": "RBIO",
          "signature": "RBState-\u003eIO a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/System-RandomIO.html#v:unRBIO"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003e\u003ca\u003ehttp://okmij.org/ftp/Haskell/regions.html#light-weight\u003c/a\u003e\n\u003c/p\u003e\u003cp\u003eLightweight monadic regions\n\u003c/p\u003e\u003cdl\u003e\u003cdt\u003eThe Abstract of the paper\u003c/dt\u003e\u003cdd\u003e\n We present Haskell libraries that statically ensure the safe use of resources such as file\n handles. We statically prevent accessing an already closed handle or forgetting to close it. The\n libraries can be trivially extended to other resources such as database connections and graphic\n contexts.\n\u003c/dd\u003e\u003c/dl\u003e\u003cp\u003eBecause file handles and similar resources are scarce, we want to not just assure their safe use\n but further deallocate them soon after they are no longer needed. Relying on Fluet and\n Morrisett's calculus of nested regions, we contribute a novel, improved, and extended\n implementation of the calculus in Haskell, with file handles as resources.\n\u003c/p\u003e\u003cp\u003eOur library supports region polymorphism and implicit region subtyping, along with higher-order\n functions, mutable state, recursion, and run-time exceptions. A program may allocate arbitrarily\n many resources and dispose of them in any order, not necessarily LIFO. Region annotations are\n part of an expression's inferred type. Our new Haskell encoding of monadic regions as monad\n transformers needs no witness terms. It assures timely deallocation even when resources have\n markedly different lifetimes and the identity of the longest-living resource is determined only\n dynamically.\n\u003c/p\u003e\u003cp\u003eFor contrast, we also implement a Haskell library for manual resource management, where\n deallocation is explicit and safety is assured by a form of linear types. We implement the linear\n typing in Haskell with the help of phantom types and a parameterized monad to statically track\n the type-state of resources.\n\u003c/p\u003e\u003cp\u003eJoint work with Chung-chieh Shan.\n\u003c/p\u003e\u003cp\u003eHandle-based IO with the assured open/close protocol, see README\n This file contains the Security kernel. See SafeHandlesTest.hs for tests.\n This is the final solution: lightweight monadic regions with\n only type-level enforcement of region discipline\n\u003c/p\u003e\u003c/div\u003e",
          "module": "System.SafeHandles",
          "name": "SafeHandles",
          "package": "liboleg",
          "source": "src/System-SafeHandles.html",
          "type": "module"
        },
        "index": {
          "description": "http okmij.org ftp Haskell regions.html light-weight Lightweight monadic regions The Abstract of the paper We present Haskell libraries that statically ensure the safe use of resources such as file handles We statically prevent accessing an already closed handle or forgetting to close it The libraries can be trivially extended to other resources such as database connections and graphic contexts Because file handles and similar resources are scarce we want to not just assure their safe use but further deallocate them soon after they are no longer needed Relying on Fluet and Morrisett calculus of nested regions we contribute novel improved and extended implementation of the calculus in Haskell with file handles as resources Our library supports region polymorphism and implicit region subtyping along with higher-order functions mutable state recursion and run-time exceptions program may allocate arbitrarily many resources and dispose of them in any order not necessarily LIFO Region annotations are part of an expression inferred type Our new Haskell encoding of monadic regions as monad transformers needs no witness terms It assures timely deallocation even when resources have markedly different lifetimes and the identity of the longest-living resource is determined only dynamically For contrast we also implement Haskell library for manual resource management where deallocation is explicit and safety is assured by form of linear types We implement the linear typing in Haskell with the help of phantom types and parameterized monad to statically track the type-state of resources Joint work with Chung-chieh Shan Handle-based IO with the assured open close protocol see README This file contains the Security kernel See SafeHandlesTest.hs for tests This is the final solution lightweight monadic regions with only type-level enforcement of region discipline",
          "hierarchy": "System SafeHandles",
          "module": "System.SafeHandles",
          "name": "SafeHandles",
          "package": "liboleg",
          "partial": "Safe Handles",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/System-SafeHandles.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "System.SafeHandles",
          "name": "IOMode",
          "package": "liboleg",
          "type": "data"
        },
        "index": {
          "hierarchy": "System SafeHandles",
          "module": "System.SafeHandles",
          "name": "IOMode",
          "package": "liboleg",
          "partial": "IOMode",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/System-SafeHandles.html#t:IOMode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe IO monad with safe handles and regions (SIO) is implemented as \n the monad transformer IORT (recursively) applied to IO.\n\u003c/p\u003e\u003cp\u003eEach region maintains the state listing all open \n handles assigned to the region.\n Since we already have IO, it is easy to implement the state as a \n mutable list (IORef of the list) and make this reference\n a pervasive environment. \n We could have used implicit parameters or implicit configurations to\n pass that IORef around. Here, we use ReaderT.\n\u003c/p\u003e",
          "module": "System.SafeHandles",
          "name": "IORT",
          "package": "liboleg",
          "source": "src/System-SafeHandles.html#IORT",
          "type": "data"
        },
        "index": {
          "description": "The IO monad with safe handles and regions SIO is implemented as the monad transformer IORT recursively applied to IO Each region maintains the state listing all open handles assigned to the region Since we already have IO it is easy to implement the state as mutable list IORef of the list and make this reference pervasive environment We could have used implicit parameters or implicit configurations to pass that IORef around Here we use ReaderT",
          "hierarchy": "System SafeHandles",
          "module": "System.SafeHandles",
          "name": "IORT",
          "package": "liboleg",
          "partial": "IORT",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/System-SafeHandles.html#t:IORT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eOur (safe) handle is labeled with the monad where it was created\n\u003c/p\u003e",
          "module": "System.SafeHandles",
          "name": "SHandle",
          "package": "liboleg",
          "source": "src/System-SafeHandles.html#SHandle",
          "type": "data"
        },
        "index": {
          "description": "Our safe handle is labeled with the monad where it was created",
          "hierarchy": "System SafeHandles",
          "module": "System.SafeHandles",
          "name": "SHandle",
          "package": "liboleg",
          "partial": "SHandle",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/System-SafeHandles.html#t:SHandle"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "System.SafeHandles",
          "name": "SIO",
          "package": "liboleg",
          "source": "src/System-SafeHandles.html#SIO",
          "type": "type"
        },
        "index": {
          "hierarchy": "System SafeHandles",
          "module": "System.SafeHandles",
          "name": "SIO",
          "package": "liboleg",
          "partial": "SIO",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/System-SafeHandles.html#t:SIO"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "System.SafeHandles",
          "name": "AppendMode",
          "package": "liboleg",
          "signature": "AppendMode",
          "type": "function"
        },
        "index": {
          "hierarchy": "System SafeHandles",
          "module": "System.SafeHandles",
          "name": "AppendMode",
          "package": "liboleg",
          "partial": "Append Mode",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/System-SafeHandles.html#v:AppendMode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "System.SafeHandles",
          "name": "ReadMode",
          "package": "liboleg",
          "signature": "ReadMode",
          "type": "function"
        },
        "index": {
          "hierarchy": "System SafeHandles",
          "module": "System.SafeHandles",
          "name": "ReadMode",
          "package": "liboleg",
          "partial": "Read Mode",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/System-SafeHandles.html#v:ReadMode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "System.SafeHandles",
          "name": "ReadWriteMode",
          "package": "liboleg",
          "signature": "ReadWriteMode",
          "type": "function"
        },
        "index": {
          "hierarchy": "System SafeHandles",
          "module": "System.SafeHandles",
          "name": "ReadWriteMode",
          "package": "liboleg",
          "partial": "Read Write Mode",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/System-SafeHandles.html#v:ReadWriteMode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "System.SafeHandles",
          "name": "WriteMode",
          "package": "liboleg",
          "signature": "WriteMode",
          "type": "function"
        },
        "index": {
          "hierarchy": "System SafeHandles",
          "module": "System.SafeHandles",
          "name": "WriteMode",
          "package": "liboleg",
          "partial": "Write Mode",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/System-SafeHandles.html#v:WriteMode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLift from one IORT to an IORT in a children region...\n IORT should be opaque to the user: hence this is not the instance \n of MonadTrans\n\u003c/p\u003e",
          "module": "System.SafeHandles",
          "name": "liftSIO",
          "package": "liboleg",
          "signature": "IORT s m a -\u003e IORT s1 (IORT s m) a",
          "source": "src/System-SafeHandles.html#liftSIO",
          "type": "function"
        },
        "index": {
          "description": "Lift from one IORT to an IORT in children region IORT should be opaque to the user hence this is not the instance of MonadTrans",
          "hierarchy": "System SafeHandles",
          "module": "System.SafeHandles",
          "name": "liftSIO",
          "normalized": "IORT a b c-\u003eIORT a(IORT a b)c",
          "package": "liboleg",
          "partial": "SIO",
          "signature": "IORT s m a-\u003eIORT s(IORT s m)a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/System-SafeHandles.html#v:liftSIO"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThere is no explicit close operation. A handle is automatically\n closed when its region is finished (normally or abnormally).\n\u003c/p\u003e",
          "module": "System.SafeHandles",
          "name": "newRgn",
          "package": "liboleg",
          "signature": "(forall s.  IORT s m v) -\u003e m v",
          "source": "src/System-SafeHandles.html#newRgn",
          "type": "function"
        },
        "index": {
          "description": "There is no explicit close operation handle is automatically closed when its region is finished normally or abnormally",
          "hierarchy": "System SafeHandles",
          "module": "System.SafeHandles",
          "name": "newRgn",
          "normalized": "(a b IORT c d e)-\u003ed e",
          "package": "liboleg",
          "partial": "Rgn",
          "signature": "(forall s. IORT s m v)-\u003em v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/System-SafeHandles.html#v:newRgn"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreate a new handle and assign it to the current region \n One can use liftIORT (newSHandle ...) to assign the handle to any parent\n region.\n\u003c/p\u003e",
          "module": "System.SafeHandles",
          "name": "newSHandle",
          "package": "liboleg",
          "signature": "FilePath -\u003e IOMode -\u003e IORT s m (SHandle (IORT s m))",
          "source": "src/System-SafeHandles.html#newSHandle",
          "type": "function"
        },
        "index": {
          "description": "Create new handle and assign it to the current region One can use liftIORT newSHandle to assign the handle to any parent region",
          "hierarchy": "System SafeHandles",
          "module": "System.SafeHandles",
          "name": "newSHandle",
          "normalized": "FilePath-\u003eIOMode-\u003eIORT a b(SHandle(IORT a b))",
          "package": "liboleg",
          "partial": "SHandle",
          "signature": "FilePath-\u003eIOMode-\u003eIORT s m(SHandle(IORT s m))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/System-SafeHandles.html#v:newSHandle"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "System.SafeHandles",
          "name": "runSIO",
          "package": "liboleg",
          "signature": "(forall s.  SIO s v) -\u003e IO v",
          "source": "src/System-SafeHandles.html#runSIO",
          "type": "function"
        },
        "index": {
          "hierarchy": "System SafeHandles",
          "module": "System.SafeHandles",
          "name": "runSIO",
          "normalized": "(a b SIO c d)-\u003eIO d",
          "package": "liboleg",
          "partial": "SIO",
          "signature": "(forall s. SIO s v)-\u003eIO v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/System-SafeHandles.html#v:runSIO"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003emake IORef available with SIO, so we may write tests that attempt\n to leak handles and computations with handles via assignment\n\u003c/p\u003e",
          "module": "System.SafeHandles",
          "name": "sNewIORef",
          "package": "liboleg",
          "signature": "a -\u003e m (IORef a)",
          "source": "src/System-SafeHandles.html#sNewIORef",
          "type": "function"
        },
        "index": {
          "description": "make IORef available with SIO so we may write tests that attempt to leak handles and computations with handles via assignment",
          "hierarchy": "System SafeHandles",
          "module": "System.SafeHandles",
          "name": "sNewIORef",
          "normalized": "a-\u003eb(IORef a)",
          "package": "liboleg",
          "partial": "New IORef",
          "signature": "a-\u003em(IORef a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/System-SafeHandles.html#v:sNewIORef"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "System.SafeHandles",
          "name": "sReadIORef",
          "package": "liboleg",
          "signature": "IORef a -\u003e m a",
          "source": "src/System-SafeHandles.html#sReadIORef",
          "type": "function"
        },
        "index": {
          "hierarchy": "System SafeHandles",
          "module": "System.SafeHandles",
          "name": "sReadIORef",
          "normalized": "IORef a-\u003eb a",
          "package": "liboleg",
          "partial": "Read IORef",
          "signature": "IORef a-\u003em a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/System-SafeHandles.html#v:sReadIORef"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "System.SafeHandles",
          "name": "sWriteIORef",
          "package": "liboleg",
          "signature": "IORef a -\u003e a -\u003e m ()",
          "source": "src/System-SafeHandles.html#sWriteIORef",
          "type": "function"
        },
        "index": {
          "hierarchy": "System SafeHandles",
          "module": "System.SafeHandles",
          "name": "sWriteIORef",
          "normalized": "IORef a-\u003ea-\u003eb()",
          "package": "liboleg",
          "partial": "Write IORef",
          "signature": "IORef a-\u003ea-\u003em()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/System-SafeHandles.html#v:sWriteIORef"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "System.SafeHandles",
          "name": "shCatch",
          "package": "liboleg",
          "signature": "m a -\u003e (Exception -\u003e m a) -\u003e m a",
          "source": "src/System-SafeHandles.html#shCatch",
          "type": "function"
        },
        "index": {
          "hierarchy": "System SafeHandles",
          "module": "System.SafeHandles",
          "name": "shCatch",
          "normalized": "a b-\u003e(Exception-\u003ea b)-\u003ea b",
          "package": "liboleg",
          "partial": "Catch",
          "signature": "m a-\u003e(Exception-\u003em a)-\u003em a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/System-SafeHandles.html#v:shCatch"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDuplicate a handle, returning a handle that can be used in the parent\n region (and can be returned from the current region as the result).\n This operation prolongs the life of a handle based on a\n _dynamic_ condition. If we know the lifetime of a handle statically,\n we can execute liftSIO (newSHandle ...) to place the handle in the\n corresponding region. If we don't know the lifetime of a handle\n statically, we place it in the inner region, and then extend its lifetime\n by reassigning to the parent region based on the dynamic conditions.\n\u003c/p\u003e",
          "module": "System.SafeHandles",
          "name": "shDup",
          "package": "liboleg",
          "signature": "SHandle (IORT s1 (IORT s m)) -\u003e IORT s1 (IORT s m) (SHandle (IORT s m))",
          "source": "src/System-SafeHandles.html#shDup",
          "type": "function"
        },
        "index": {
          "description": "Duplicate handle returning handle that can be used in the parent region and can be returned from the current region as the result This operation prolongs the life of handle based on dynamic condition If we know the lifetime of handle statically we can execute liftSIO newSHandle to place the handle in the corresponding region If we don know the lifetime of handle statically we place it in the inner region and then extend its lifetime by reassigning to the parent region based on the dynamic conditions",
          "hierarchy": "System SafeHandles",
          "module": "System.SafeHandles",
          "name": "shDup",
          "normalized": "SHandle(IORT a(IORT a b))-\u003eIORT a(IORT a b)(SHandle(IORT a b))",
          "package": "liboleg",
          "partial": "Dup",
          "signature": "SHandle(IORT s(IORT s m))-\u003eIORT s(IORT s m)(SHandle(IORT s m))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/System-SafeHandles.html#v:shDup"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSafe-handle-based IO...\n The handle is assigned to the current region or its ancestor.\n So, we have to verify that the label of the handle is the prefix\n (perhaps improper) of the label of the monad (label of the region).\n\u003c/p\u003e",
          "module": "System.SafeHandles",
          "name": "shGetLine",
          "package": "liboleg",
          "signature": "SHandle m1 -\u003e m2 String",
          "source": "src/System-SafeHandles.html#shGetLine",
          "type": "function"
        },
        "index": {
          "description": "Safe-handle-based IO The handle is assigned to the current region or its ancestor So we have to verify that the label of the handle is the prefix perhaps improper of the label of the monad label of the region",
          "hierarchy": "System SafeHandles",
          "module": "System.SafeHandles",
          "name": "shGetLine",
          "normalized": "SHandle a-\u003ea String",
          "package": "liboleg",
          "partial": "Get Line",
          "signature": "SHandle m-\u003em String",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/System-SafeHandles.html#v:shGetLine"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "System.SafeHandles",
          "name": "shIsEOF",
          "package": "liboleg",
          "signature": "SHandle m1 -\u003e m2 Bool",
          "source": "src/System-SafeHandles.html#shIsEOF",
          "type": "function"
        },
        "index": {
          "hierarchy": "System SafeHandles",
          "module": "System.SafeHandles",
          "name": "shIsEOF",
          "normalized": "SHandle a-\u003ea Bool",
          "package": "liboleg",
          "partial": "Is EOF",
          "signature": "SHandle m-\u003em Bool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/System-SafeHandles.html#v:shIsEOF"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "System.SafeHandles",
          "name": "shPutStrLn",
          "package": "liboleg",
          "signature": "SHandle m1 -\u003e String -\u003e m2 ()",
          "source": "src/System-SafeHandles.html#shPutStrLn",
          "type": "function"
        },
        "index": {
          "hierarchy": "System SafeHandles",
          "module": "System.SafeHandles",
          "name": "shPutStrLn",
          "normalized": "SHandle a-\u003eString-\u003ea()",
          "package": "liboleg",
          "partial": "Put Str Ln",
          "signature": "SHandle m-\u003eString-\u003em()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/System-SafeHandles.html#v:shPutStrLn"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUseful for debugging\n\u003c/p\u003e",
          "module": "System.SafeHandles",
          "name": "shReport",
          "package": "liboleg",
          "signature": "String -\u003e m ()",
          "source": "src/System-SafeHandles.html#shReport",
          "type": "function"
        },
        "index": {
          "description": "Useful for debugging",
          "hierarchy": "System SafeHandles",
          "module": "System.SafeHandles",
          "name": "shReport",
          "normalized": "String-\u003ea()",
          "package": "liboleg",
          "partial": "Report",
          "signature": "String-\u003em()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/System-SafeHandles.html#v:shReport"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIt seems however that IOErrors don't invalidate the Handles.\n For example, if EOF is reported, we may try to reposition the \u003ccode\u003efile\u003c/code\u003e\n and read again. That's why in Posix, EOF and file errors can be cleared.\n\u003c/p\u003e",
          "module": "System.SafeHandles",
          "name": "shThrow",
          "package": "liboleg",
          "signature": "Exception -\u003e m a",
          "source": "src/System-SafeHandles.html#shThrow",
          "type": "function"
        },
        "index": {
          "description": "It seems however that IOErrors don invalidate the Handles For example if EOF is reported we may try to reposition the file and read again That why in Posix EOF and file errors can be cleared",
          "hierarchy": "System SafeHandles",
          "module": "System.SafeHandles",
          "name": "shThrow",
          "normalized": "Exception-\u003ea b",
          "package": "liboleg",
          "partial": "Throw",
          "signature": "Exception-\u003em a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/System-SafeHandles.html#v:shThrow"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003e\u003ca\u003ehttp://okmij.org/ftp/Haskell/misc.html#sys_open\u003c/a\u003e\n\u003c/p\u003e\u003cp\u003eHaskell interface to sys_open.c:\n providing openFd and closeFd that can deal with \u003ccode\u003eextended\u003c/code\u003e\n file names (which can name TCP and bi-directional pipes in addition\n to the regular disk files)\n      \u003ca\u003ehttp://okmij.org/ftp/syscall-interpose.html#Application\u003c/a\u003e\n\u003c/p\u003e\u003cp\u003eAlso included a useful utility read_line to read a NL-terminated\n line from an Fd. It deliberately uses no handles and so never\n messes with Fd (in particular, it doesn't put the file descriptor in the \n non-blocking mode)\n\u003c/p\u003e\u003cp\u003eSimple and reliable uni- and bi-directional pipes\n\u003c/p\u003e\u003cp\u003eMySysOpen module offers a reliable, proven way of interacting with another\n     local or remote process via a unidirectional or bidirectional channel. It\n     supports pipes and Unix and TCP sockets. MySysOpen is a simple and explicit\n     alternative to the multi-threaded IO processing of the GHC run-time system. The\n     module is the Haskell binding to sys_open -- the extended, user-level file\n     opening interface.\n\u003c/p\u003e\u003cp\u003eThe second half of MySysOpen.hs contains several bi-directional channel\n     interaction tests. One checks repeated sending and receiving of data; the\n     amount of received data is intentionally large, about 510K. Two other tests\n     interact with programs that are not specifically written for interactive use,\n     such as sort. The latter cannot produce any output before it has read all of\n     the input, accepting no input terminator other than the EOF condition. One test\n     uses shutdown to set the EOF condition. The other test programs the handler for\n     a custom EOF indicator, literally in the file name of the communication pipe.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "System.SysOpen",
          "name": "SysOpen",
          "package": "liboleg",
          "source": "src/System-SysOpen.html",
          "type": "module"
        },
        "index": {
          "description": "http okmij.org ftp Haskell misc.html sys open Haskell interface to sys open.c providing openFd and closeFd that can deal with extended file names which can name TCP and bi-directional pipes in addition to the regular disk files http okmij.org ftp syscall-interpose.html Application Also included useful utility read line to read NL-terminated line from an Fd It deliberately uses no handles and so never messes with Fd in particular it doesn put the file descriptor in the non-blocking mode Simple and reliable uni and bi-directional pipes MySysOpen module offers reliable proven way of interacting with another local or remote process via unidirectional or bidirectional channel It supports pipes and Unix and TCP sockets MySysOpen is simple and explicit alternative to the multi-threaded IO processing of the GHC run-time system The module is the Haskell binding to sys open the extended user-level file opening interface The second half of MySysOpen.hs contains several bi-directional channel interaction tests One checks repeated sending and receiving of data the amount of received data is intentionally large about Two other tests interact with programs that are not specifically written for interactive use such as sort The latter cannot produce any output before it has read all of the input accepting no input terminator other than the EOF condition One test uses shutdown to set the EOF condition The other test programs the handler for custom EOF indicator literally in the file name of the communication pipe",
          "hierarchy": "System SysOpen",
          "module": "System.SysOpen",
          "name": "SysOpen",
          "package": "liboleg",
          "partial": "Sys Open",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/System-SysOpen.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "System.SysOpen",
          "name": "mysysCloseFd",
          "package": "liboleg",
          "signature": "Fd -\u003e IO ()",
          "source": "src/System-SysOpen.html#mysysCloseFd",
          "type": "function"
        },
        "index": {
          "hierarchy": "System SysOpen",
          "module": "System.SysOpen",
          "name": "mysysCloseFd",
          "normalized": "Fd-\u003eIO()",
          "package": "liboleg",
          "partial": "Close Fd",
          "signature": "Fd-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/System-SysOpen.html#v:mysysCloseFd"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eClose the output direction of the bi-directional pipe\n\u003c/p\u003e",
          "module": "System.SysOpen",
          "name": "mysysCloseOut",
          "package": "liboleg",
          "signature": "Fd -\u003e IO ()",
          "source": "src/System-SysOpen.html#mysysCloseOut",
          "type": "function"
        },
        "index": {
          "description": "Close the output direction of the bi-directional pipe",
          "hierarchy": "System SysOpen",
          "module": "System.SysOpen",
          "name": "mysysCloseOut",
          "normalized": "Fd-\u003eIO()",
          "package": "liboleg",
          "partial": "Close Out",
          "signature": "Fd-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/System-SysOpen.html#v:mysysCloseOut"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "System.SysOpen",
          "name": "mysysOpenFd",
          "package": "liboleg",
          "signature": "FilePath -\u003e OpenMode -\u003e Maybe FileMode -\u003e IO Fd",
          "source": "src/System-SysOpen.html#mysysOpenFd",
          "type": "function"
        },
        "index": {
          "hierarchy": "System SysOpen",
          "module": "System.SysOpen",
          "name": "mysysOpenFd",
          "normalized": "FilePath-\u003eOpenMode-\u003eMaybe FileMode-\u003eIO Fd",
          "package": "liboleg",
          "partial": "Open Fd",
          "signature": "FilePath-\u003eOpenMode-\u003eMaybe FileMode-\u003eIO Fd",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/System-SysOpen.html#v:mysysOpenFd"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "System.SysOpen",
          "name": "read_line",
          "package": "liboleg",
          "signature": "[Char] -\u003e Fd -\u003e IO ([Char], [Char])",
          "source": "src/System-SysOpen.html#read_line",
          "type": "function"
        },
        "index": {
          "hierarchy": "System SysOpen",
          "module": "System.SysOpen",
          "name": "read_line",
          "normalized": "[Char]-\u003eFd-\u003eIO([Char],[Char])",
          "package": "liboleg",
          "signature": "[Char]-\u003eFd-\u003eIO([Char],[Char])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/System-SysOpen.html#v:read_line"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003e\u003ca\u003ehttp://okmij.org/ftp/typed-formatting/FPrintScan.html#print-show\u003c/a\u003e\n\u003c/p\u003e\u003cp\u003eGeneric polyvariadic printf in Haskell98\n\u003c/p\u003e\u003cp\u003eThis generalization of Text.Printf.printf is inspired by the message of Evan Klitzke, who wrote\n on Haskell-Cafe about frequent occurrences in his code of the lines like\n\u003c/p\u003e\u003cpre\u003e        infoM $ printf \"%s saw %s with %s\" (show x) (show y) (show z)\n\u003c/pre\u003e\u003cp\u003eWriting show on and on quickly becomes tiresome. It turns out, we can avoid these repeating show,\n still conforming to Haskell98.\n\u003c/p\u003e\u003cp\u003eOur polyvariadic generic printf is like polyvariadic show with the printf-like format string. Our\n printf handles values of any present and future type for which there is a Show instance. For\n example:\n\u003c/p\u003e\u003cpre\u003e        t1 = unR $ printf \"Hi there\"\n        -- \"Hi there\"\n\u003c/pre\u003e\u003cpre\u003e        t2 = unR $ printf \"Hi %s!\" \"there\"\n        -- \"Hi there!\"\n\u003c/pre\u003e\u003cpre\u003e        t3 = unR $ printf \"The value of %s is %s\" \"x\" 3\n        -- \"The value of x is 3\"\n\u003c/pre\u003e\u003cpre\u003e        t4 = unR $ printf \"The value of %s is %s\" \"x\" [5]\n        -- \"The value of x is [5]\"\n\u003c/pre\u003e\u003cp\u003eThe unsightly unR appears solely for Haskell98 compatibility: flexible instances remove the need\n for it. On the other hand, Evan Klitzke's code post-processes the result of formatting with\n infoM, which can subsume unR.\n\u003c/p\u003e\u003cp\u003eA bigger problem with our generic printf, shared with the original Text.Printf.printf, is\n partiality: The errors like passing too many or too few arguments to printf are caught only at\n run-time. We can certainly do better.\n\u003c/p\u003e\u003cp\u003eVersion:  The current version is 1.1, June 5, 2009.\n\u003c/p\u003e\u003cp\u003eReferences\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e  The complete source code with the tests. It was published in the message posted on the\n     Haskell-Cafe mailing list on Fri, 5 Jun 2009 00:57:00 -0700 (PDT)\n     \u003ca\u003ehttp://okmij.org/ftp/typed-formatting/GenPrintF.hs\u003c/a\u003e\n\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e",
          "module": "Text.GenPrintF",
          "name": "GenPrintF",
          "package": "liboleg",
          "source": "src/Text-GenPrintF.html",
          "type": "module"
        },
        "index": {
          "description": "http okmij.org ftp typed-formatting FPrintScan.html print-show Generic polyvariadic printf in Haskell98 This generalization of Text.Printf.printf is inspired by the message of Evan Klitzke who wrote on Haskell-Cafe about frequent occurrences in his code of the lines like infoM printf saw with show show show Writing show on and on quickly becomes tiresome It turns out we can avoid these repeating show still conforming to Haskell98 Our polyvariadic generic printf is like polyvariadic show with the printf-like format string Our printf handles values of any present and future type for which there is Show instance For example t1 unR printf Hi there Hi there t2 unR printf Hi there Hi there t3 unR printf The value of is The value of is t4 unR printf The value of is The value of is The unsightly unR appears solely for Haskell98 compatibility flexible instances remove the need for it On the other hand Evan Klitzke code post-processes the result of formatting with infoM which can subsume unR bigger problem with our generic printf shared with the original Text.Printf.printf is partiality The errors like passing too many or too few arguments to printf are caught only at run-time We can certainly do better Version The current version is June References The complete source code with the tests It was published in the message posted on the Haskell-Cafe mailing list on Fri Jun PDT http okmij.org ftp typed-formatting GenPrintF.hs",
          "hierarchy": "Text GenPrintF",
          "module": "Text.GenPrintF",
          "name": "GenPrintF",
          "package": "liboleg",
          "partial": "Gen Print",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Text-GenPrintF.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA very simple language of format descriptors\n\u003c/p\u003e",
          "module": "Text.GenPrintF",
          "name": "FDesc",
          "package": "liboleg",
          "source": "src/Text-GenPrintF.html#FDesc",
          "type": "data"
        },
        "index": {
          "description": "very simple language of format descriptors",
          "hierarchy": "Text GenPrintF",
          "module": "Text.GenPrintF",
          "name": "FDesc",
          "package": "liboleg",
          "partial": "FDesc",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Text-GenPrintF.html#t:FDesc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eNeeded only for the sake of Haskell98\n If we are OK with flexible instances, this newtype can be disposed of\n\u003c/p\u003e",
          "module": "Text.GenPrintF",
          "name": "RString",
          "package": "liboleg",
          "source": "src/Text-GenPrintF.html#RString",
          "type": "newtype"
        },
        "index": {
          "description": "Needed only for the sake of Haskell98 If we are OK with flexible instances this newtype can be disposed of",
          "hierarchy": "Text GenPrintF",
          "module": "Text.GenPrintF",
          "name": "RString",
          "package": "liboleg",
          "partial": "RString",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Text-GenPrintF.html#t:RString"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.GenPrintF",
          "name": "SPrintF",
          "package": "liboleg",
          "source": "src/Text-GenPrintF.html#SPrintF",
          "type": "class"
        },
        "index": {
          "hierarchy": "Text GenPrintF",
          "module": "Text.GenPrintF",
          "name": "SPrintF",
          "package": "liboleg",
          "partial": "SPrint",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Text-GenPrintF.html#t:SPrintF"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.GenPrintF",
          "name": "FD_lit",
          "package": "liboleg",
          "signature": "FD_lit String",
          "source": "src/Text-GenPrintF.html#FDesc",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text GenPrintF",
          "module": "Text.GenPrintF",
          "name": "FD_lit",
          "package": "liboleg",
          "partial": "FD",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Text-GenPrintF.html#v:FD_lit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.GenPrintF",
          "name": "FD_str",
          "package": "liboleg",
          "signature": "FD_str",
          "source": "src/Text-GenPrintF.html#FDesc",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text GenPrintF",
          "module": "Text.GenPrintF",
          "name": "FD_str",
          "package": "liboleg",
          "partial": "FD",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Text-GenPrintF.html#v:FD_str"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.GenPrintF",
          "name": "RString",
          "package": "liboleg",
          "signature": "RString",
          "source": "src/Text-GenPrintF.html#RString",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text GenPrintF",
          "module": "Text.GenPrintF",
          "name": "RString",
          "package": "liboleg",
          "partial": "RString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Text-GenPrintF.html#v:RString"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.GenPrintF",
          "name": "convert_to_fdesc",
          "package": "liboleg",
          "signature": "String -\u003e [FDesc]",
          "source": "src/Text-GenPrintF.html#convert_to_fdesc",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text GenPrintF",
          "module": "Text.GenPrintF",
          "name": "convert_to_fdesc",
          "normalized": "String-\u003e[FDesc]",
          "package": "liboleg",
          "signature": "String-\u003e[FDesc]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Text-GenPrintF.html#v:convert_to_fdesc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.GenPrintF",
          "name": "pr_aux",
          "package": "liboleg",
          "signature": "[FDesc] -\u003e [String] -\u003e r",
          "source": "src/Text-GenPrintF.html#pr_aux",
          "type": "method"
        },
        "index": {
          "hierarchy": "Text GenPrintF",
          "module": "Text.GenPrintF",
          "name": "pr_aux",
          "normalized": "[FDesc]-\u003e[String]-\u003ea",
          "package": "liboleg",
          "signature": "[FDesc]-\u003e[String]-\u003er",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Text-GenPrintF.html#v:pr_aux"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.GenPrintF",
          "name": "unR",
          "package": "liboleg",
          "signature": "String",
          "source": "src/Text-GenPrintF.html#RString",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text GenPrintF",
          "module": "Text.GenPrintF",
          "name": "unR",
          "package": "liboleg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Text-GenPrintF.html#v:unR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003e\u003ca\u003ehttp://okmij.org/ftp/typed-formatting/FPrintScan.html\u003c/a\u003e\n\u003c/p\u003e\u003cp\u003eThe initial view to the typed sprintf and sscanf\n This code defines a simple domain-specific language of string\n patterns and demonstrates two interpreters of the language:\n for building strings (sprintf) and parsing strings (sscanf).\n This code thus solves the problem of typed printf/scanf sharing the\n same format string posed by Chung-chieh Shan.\n\u003c/p\u003e\u003cp\u003eVersion: The current version is 1.1, Aug 31, 2008.\n\u003c/p\u003e\u003cp\u003eReferences\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e The complete code with many examples.\n   \u003ca\u003ehttp://okmij.org/ftp/typed-formatting/PrintScan.hs\u003c/a\u003e\n\u003c/li\u003e\u003cli\u003e The initial view on typed sprintf and sscanf\n   \u003ca\u003ehttp://okmij.org/ftp/typed-formatting/PrintScanI.txt\u003c/a\u003e\n\u003c/li\u003e\u003cli\u003e The message with more explanations, posted on the Haskell mailing list\n   on Sun, 31 Aug 2008 19:40:41 -0700 (PDT)\n\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e",
          "module": "Text.PrintScan",
          "name": "PrintScan",
          "package": "liboleg",
          "source": "src/Text-PrintScan.html",
          "type": "module"
        },
        "index": {
          "description": "http okmij.org ftp typed-formatting FPrintScan.html The initial view to the typed sprintf and sscanf This code defines simple domain-specific language of string patterns and demonstrates two interpreters of the language for building strings sprintf and parsing strings sscanf This code thus solves the problem of typed printf scanf sharing the same format string posed by Chung-chieh Shan Version The current version is Aug References The complete code with many examples http okmij.org ftp typed-formatting PrintScan.hs The initial view on typed sprintf and sscanf http okmij.org ftp typed-formatting PrintScanI.txt The message with more explanations posted on the Haskell mailing list on Sun Aug PDT",
          "hierarchy": "Text PrintScan",
          "module": "Text.PrintScan",
          "name": "PrintScan",
          "package": "liboleg",
          "partial": "Print Scan",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Text-PrintScan.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.PrintScan",
          "name": "F",
          "package": "liboleg",
          "source": "src/Text-PrintScan.html#F",
          "type": "data"
        },
        "index": {
          "hierarchy": "Text PrintScan",
          "module": "Text.PrintScan",
          "name": "F",
          "package": "liboleg",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Text-PrintScan.html#t:F"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePrinter\u003cem\u003eparsers (injection\u003c/em\u003eprojection pairs)\n\u003c/p\u003e",
          "module": "Text.PrintScan",
          "name": "PrinterParser",
          "package": "liboleg",
          "source": "src/Text-PrintScan.html#PrinterParser",
          "type": "data"
        },
        "index": {
          "description": "Printer parsers injection projection pairs",
          "hierarchy": "Text PrintScan",
          "module": "Text.PrintScan",
          "name": "PrinterParser",
          "package": "liboleg",
          "partial": "Printer Parser",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Text-PrintScan.html#t:PrinterParser"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.PrintScan",
          "name": ":^",
          "package": "liboleg",
          "signature": "F b c -\u003e F a b -\u003e F a c",
          "source": "src/Text-PrintScan.html#F",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text PrintScan",
          "module": "Text.PrintScan",
          "name": ":^",
          "normalized": "F a b-\u003eF c a-\u003eF c b",
          "package": "liboleg",
          "signature": "F b c-\u003eF a b-\u003eF a c",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Text-PrintScan.html#v::-94-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.PrintScan",
          "name": "FChr",
          "package": "liboleg",
          "signature": "F a (Char -\u003e a)",
          "source": "src/Text-PrintScan.html#F",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text PrintScan",
          "module": "Text.PrintScan",
          "name": "FChr",
          "normalized": "F a(Char-\u003ea)",
          "package": "liboleg",
          "partial": "FChr",
          "signature": "F a(Char-\u003ea)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Text-PrintScan.html#v:FChr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.PrintScan",
          "name": "FInt",
          "package": "liboleg",
          "signature": "F a (Int -\u003e a)",
          "source": "src/Text-PrintScan.html#F",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text PrintScan",
          "module": "Text.PrintScan",
          "name": "FInt",
          "normalized": "F a(Int-\u003ea)",
          "package": "liboleg",
          "partial": "FInt",
          "signature": "F a(Int-\u003ea)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Text-PrintScan.html#v:FInt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.PrintScan",
          "name": "FLit",
          "package": "liboleg",
          "signature": "String -\u003e F a a",
          "source": "src/Text-PrintScan.html#F",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text PrintScan",
          "module": "Text.PrintScan",
          "name": "FLit",
          "normalized": "String-\u003eF a a",
          "package": "liboleg",
          "partial": "FLit",
          "signature": "String-\u003eF a a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Text-PrintScan.html#v:FLit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.PrintScan",
          "name": "FPP",
          "package": "liboleg",
          "signature": "PrinterParser b -\u003e F a (b -\u003e a)",
          "source": "src/Text-PrintScan.html#F",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text PrintScan",
          "module": "Text.PrintScan",
          "name": "FPP",
          "normalized": "PrinterParser a-\u003eF b(a-\u003eb)",
          "package": "liboleg",
          "partial": "FPP",
          "signature": "PrinterParser b-\u003eF a(b-\u003ea)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Text-PrintScan.html#v:FPP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.PrintScan",
          "name": "PrinterParser",
          "package": "liboleg",
          "signature": "PrinterParser (a -\u003e String) (String -\u003e Maybe (a, String))",
          "source": "src/Text-PrintScan.html#PrinterParser",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text PrintScan",
          "module": "Text.PrintScan",
          "name": "PrinterParser",
          "normalized": "PrinterParser(a-\u003eString)(String-\u003eMaybe(a,String))",
          "package": "liboleg",
          "partial": "Printer Parser",
          "signature": "PrinterParser(a-\u003eString)(String-\u003eMaybe(a,String))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Text-PrintScan.html#v:PrinterParser"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ea bit of syntactic sugar to avoid hitting the Shift key too many a time\n\u003c/p\u003e",
          "module": "Text.PrintScan",
          "name": "fmt",
          "package": "liboleg",
          "signature": "b -\u003e F a (b -\u003e a)",
          "source": "src/Text-PrintScan.html#fmt",
          "type": "function"
        },
        "index": {
          "description": "bit of syntactic sugar to avoid hitting the Shift key too many time",
          "hierarchy": "Text PrintScan",
          "module": "Text.PrintScan",
          "name": "fmt",
          "normalized": "a-\u003eF b(a-\u003eb)",
          "package": "liboleg",
          "signature": "b-\u003eF a(b-\u003ea)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Text-PrintScan.html#v:fmt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe interpreter for printf \n It implements Asai's accumulator-less alternative to\n Danvy's functional unparsing\n\u003c/p\u003e",
          "module": "Text.PrintScan",
          "name": "intp",
          "package": "liboleg",
          "signature": "F a b -\u003e (String -\u003e a) -\u003e b",
          "source": "src/Text-PrintScan.html#intp",
          "type": "function"
        },
        "index": {
          "description": "The interpreter for printf It implements Asai accumulator-less alternative to Danvy functional unparsing",
          "hierarchy": "Text PrintScan",
          "module": "Text.PrintScan",
          "name": "intp",
          "normalized": "F a b-\u003e(String-\u003ea)-\u003eb",
          "package": "liboleg",
          "signature": "F a b-\u003e(String-\u003ea)-\u003eb",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Text-PrintScan.html#v:intp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe interpreter for scanf\n\u003c/p\u003e",
          "module": "Text.PrintScan",
          "name": "ints",
          "package": "liboleg",
          "signature": "F a b -\u003e String -\u003e b -\u003e Maybe (a, String)",
          "source": "src/Text-PrintScan.html#ints",
          "type": "function"
        },
        "index": {
          "description": "The interpreter for scanf",
          "hierarchy": "Text PrintScan",
          "module": "Text.PrintScan",
          "name": "ints",
          "normalized": "F a b-\u003eString-\u003eb-\u003eMaybe(a,String)",
          "package": "liboleg",
          "signature": "F a b-\u003eString-\u003eb-\u003eMaybe(a,String)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Text-PrintScan.html#v:ints"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA better prefixOf function\n prefix patt str --\u003e Just str'\n    if the String patt is the prefix of String str. The result str'\n    is str with patt removed\n Otherwise, the result is Nothing\n\u003c/p\u003e",
          "module": "Text.PrintScan",
          "name": "prefix",
          "package": "liboleg",
          "signature": "String -\u003e String -\u003e Maybe String",
          "source": "src/Text-PrintScan.html#prefix",
          "type": "function"
        },
        "index": {
          "description": "better prefixOf function prefix patt str Just str if the String patt is the prefix of String str The result str is str with patt removed Otherwise the result is Nothing",
          "hierarchy": "Text PrintScan",
          "module": "Text.PrintScan",
          "name": "prefix",
          "normalized": "String-\u003eString-\u003eMaybe String",
          "package": "liboleg",
          "signature": "String-\u003eString-\u003eMaybe String",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Text-PrintScan.html#v:prefix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe format specification is first-class. One can build format specification\n incrementally\n This is not the case with OCaml's printf/scanf (where the \n format specification has a weird typing and is not first class).\n\u003c/p\u003e\u003cp\u003ePrimitive Printer/parsers\n\u003c/p\u003e",
          "module": "Text.PrintScan",
          "name": "showread",
          "package": "liboleg",
          "signature": "PrinterParser a",
          "source": "src/Text-PrintScan.html#showread",
          "type": "function"
        },
        "index": {
          "description": "The format specification is first-class One can build format specification incrementally This is not the case with OCaml printf scanf where the format specification has weird typing and is not first class Primitive Printer parsers",
          "hierarchy": "Text PrintScan",
          "module": "Text.PrintScan",
          "name": "showread",
          "package": "liboleg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Text-PrintScan.html#v:showread"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.PrintScan",
          "name": "sprintf",
          "package": "liboleg",
          "signature": "F String b -\u003e b",
          "source": "src/Text-PrintScan.html#sprintf",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text PrintScan",
          "module": "Text.PrintScan",
          "name": "sprintf",
          "normalized": "F String a-\u003ea",
          "package": "liboleg",
          "signature": "F String b-\u003eb",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Text-PrintScan.html#v:sprintf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.PrintScan",
          "name": "sscanf",
          "package": "liboleg",
          "signature": "String -\u003e F a b -\u003e b -\u003e Maybe a",
          "source": "src/Text-PrintScan.html#sscanf",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text PrintScan",
          "module": "Text.PrintScan",
          "name": "sscanf",
          "normalized": "String-\u003eF a b-\u003eb-\u003eMaybe a",
          "package": "liboleg",
          "signature": "String-\u003eF a b-\u003eb-\u003eMaybe a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Text-PrintScan.html#v:sscanf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThe final view to the typed sprintf and sscanf\n\u003c/p\u003e\u003cp\u003e\u003ca\u003ehttp://okmij.org/ftp/typed-formatting/FPrintScan.html\u003c/a\u003e\n\u003c/p\u003e\u003cp\u003eThis code defines a simple domain-specific language of string\n patterns and demonstrates two interpreters of the language:\n for building strings (sprintf) and parsing strings (sscanf).\n This code thus solves the problem of typed printf/scanf sharing the\n same format string posed by Chung-chieh Shan.\n This code presents scanf/printf interpreters in the final style;\n it is thus the dual of the code in PrintScan.hs\n\u003c/p\u003e\u003cp\u003eVersion: The current version is 1.1, Sep 2, 2008.\n\u003c/p\u003e\u003cp\u003eReferences\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e The complete Haskell98 code with many examples.\n  \u003ca\u003ehttp://okmij.org/ftp/typed-formatting/PrintScanF.hs\u003c/a\u003e\n\u003c/li\u003e\u003cli\u003e The final view on typed sprintf and sscanf\n  \u003ca\u003ehttp://okmij.org/ftp/typed-formatting/PrintScanF.txt\u003c/a\u003e\n\u003c/li\u003e\u003cli\u003e The message posted on the Haskell mailing list on Tue, 2 Sep 2008 00:57:18 -0700 (PDT)\n\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e",
          "module": "Text.PrintScanF",
          "name": "PrintScanF",
          "package": "liboleg",
          "source": "src/Text-PrintScanF.html",
          "type": "module"
        },
        "index": {
          "description": "The final view to the typed sprintf and sscanf http okmij.org ftp typed-formatting FPrintScan.html This code defines simple domain-specific language of string patterns and demonstrates two interpreters of the language for building strings sprintf and parsing strings sscanf This code thus solves the problem of typed printf scanf sharing the same format string posed by Chung-chieh Shan This code presents scanf printf interpreters in the final style it is thus the dual of the code in PrintScan.hs Version The current version is Sep References The complete Haskell98 code with many examples http okmij.org ftp typed-formatting PrintScanF.hs The final view on typed sprintf and sscanf http okmij.org ftp typed-formatting PrintScanF.txt The message posted on the Haskell mailing list on Tue Sep PDT",
          "hierarchy": "Text PrintScanF",
          "module": "Text.PrintScanF",
          "name": "PrintScanF",
          "package": "liboleg",
          "partial": "Print Scan",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Text-PrintScanF.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.PrintScanF",
          "name": "FPr",
          "package": "liboleg",
          "source": "src/Text-PrintScanF.html#FPr",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "Text PrintScanF",
          "module": "Text.PrintScanF",
          "name": "FPr",
          "package": "liboleg",
          "partial": "FPr",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Text-PrintScanF.html#t:FPr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.PrintScanF",
          "name": "FSc",
          "package": "liboleg",
          "source": "src/Text-PrintScanF.html#FSc",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "Text PrintScanF",
          "module": "Text.PrintScanF",
          "name": "FSc",
          "package": "liboleg",
          "partial": "FSc",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Text-PrintScanF.html#t:FSc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.PrintScanF",
          "name": "FormattingSpec",
          "package": "liboleg",
          "source": "src/Text-PrintScanF.html#FormattingSpec",
          "type": "class"
        },
        "index": {
          "hierarchy": "Text PrintScanF",
          "module": "Text.PrintScanF",
          "name": "FormattingSpec",
          "package": "liboleg",
          "partial": "Formatting Spec",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Text-PrintScanF.html#t:FormattingSpec"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.PrintScanF",
          "name": "PrinterParser",
          "package": "liboleg",
          "source": "src/Text-PrintScanF.html#PrinterParser",
          "type": "data"
        },
        "index": {
          "hierarchy": "Text PrintScanF",
          "module": "Text.PrintScanF",
          "name": "PrinterParser",
          "package": "liboleg",
          "partial": "Printer Parser",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Text-PrintScanF.html#t:PrinterParser"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.PrintScanF",
          "name": "(^)",
          "package": "liboleg",
          "signature": "repr b c -\u003e repr a b -\u003e repr a c",
          "source": "src/Text-PrintScanF.html#%5E",
          "type": "method"
        },
        "index": {
          "hierarchy": "Text PrintScanF",
          "module": "Text.PrintScanF",
          "name": "(^) ^",
          "normalized": "a b c-\u003ea d b-\u003ea d c",
          "package": "liboleg",
          "signature": "repr b c-\u003erepr a b-\u003erepr a c",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Text-PrintScanF.html#v:-94-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.PrintScanF",
          "name": "FPr",
          "package": "liboleg",
          "signature": "FPr ((String -\u003e a) -\u003e b)",
          "source": "src/Text-PrintScanF.html#FPr",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text PrintScanF",
          "module": "Text.PrintScanF",
          "name": "FPr",
          "normalized": "FPr((String-\u003ea)-\u003eb)",
          "package": "liboleg",
          "partial": "FPr",
          "signature": "FPr((String-\u003ea)-\u003eb)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Text-PrintScanF.html#v:FPr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.PrintScanF",
          "name": "FSc",
          "package": "liboleg",
          "signature": "FSc (String -\u003e b -\u003e Maybe (a, String))",
          "source": "src/Text-PrintScanF.html#FSc",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text PrintScanF",
          "module": "Text.PrintScanF",
          "name": "FSc",
          "normalized": "FSc(String-\u003ea-\u003eMaybe(b,String))",
          "package": "liboleg",
          "partial": "FSc",
          "signature": "FSc(String-\u003eb-\u003eMaybe(a,String))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Text-PrintScanF.html#v:FSc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.PrintScanF",
          "name": "PrinterParser",
          "package": "liboleg",
          "signature": "PrinterParser (a -\u003e String) (String -\u003e Maybe (a, String))",
          "source": "src/Text-PrintScanF.html#PrinterParser",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text PrintScanF",
          "module": "Text.PrintScanF",
          "name": "PrinterParser",
          "normalized": "PrinterParser(a-\u003eString)(String-\u003eMaybe(a,String))",
          "package": "liboleg",
          "partial": "Printer Parser",
          "signature": "PrinterParser(a-\u003eString)(String-\u003eMaybe(a,String))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Text-PrintScanF.html#v:PrinterParser"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.PrintScanF",
          "name": "char",
          "package": "liboleg",
          "signature": "repr a (Char -\u003e a)",
          "source": "src/Text-PrintScanF.html#char",
          "type": "method"
        },
        "index": {
          "hierarchy": "Text PrintScanF",
          "module": "Text.PrintScanF",
          "name": "char",
          "normalized": "a b(Char-\u003eb)",
          "package": "liboleg",
          "signature": "repr a(Char-\u003ea)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Text-PrintScanF.html#v:char"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.PrintScanF",
          "name": "fmt",
          "package": "liboleg",
          "signature": "b -\u003e repr a (b -\u003e a)",
          "source": "src/Text-PrintScanF.html#fmt",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text PrintScanF",
          "module": "Text.PrintScanF",
          "name": "fmt",
          "normalized": "a-\u003eb c(a-\u003ec)",
          "package": "liboleg",
          "signature": "b-\u003erepr a(b-\u003ea)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Text-PrintScanF.html#v:fmt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.PrintScanF",
          "name": "fpp",
          "package": "liboleg",
          "signature": "PrinterParser b -\u003e repr a (b -\u003e a)",
          "source": "src/Text-PrintScanF.html#fpp",
          "type": "method"
        },
        "index": {
          "hierarchy": "Text PrintScanF",
          "module": "Text.PrintScanF",
          "name": "fpp",
          "normalized": "PrinterParser a-\u003eb c(a-\u003ec)",
          "package": "liboleg",
          "signature": "PrinterParser b-\u003erepr a(b-\u003ea)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Text-PrintScanF.html#v:fpp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.PrintScanF",
          "name": "int",
          "package": "liboleg",
          "signature": "repr a (Int -\u003e a)",
          "source": "src/Text-PrintScanF.html#int",
          "type": "method"
        },
        "index": {
          "hierarchy": "Text PrintScanF",
          "module": "Text.PrintScanF",
          "name": "int",
          "normalized": "a b(Int-\u003eb)",
          "package": "liboleg",
          "signature": "repr a(Int-\u003ea)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Text-PrintScanF.html#v:int"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.PrintScanF",
          "name": "lit",
          "package": "liboleg",
          "signature": "String -\u003e repr a a",
          "source": "src/Text-PrintScanF.html#lit",
          "type": "method"
        },
        "index": {
          "hierarchy": "Text PrintScanF",
          "module": "Text.PrintScanF",
          "name": "lit",
          "normalized": "String-\u003ea b b",
          "package": "liboleg",
          "signature": "String-\u003erepr a a",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Text-PrintScanF.html#v:lit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.PrintScanF",
          "name": "prefix",
          "package": "liboleg",
          "signature": "String -\u003e String -\u003e Maybe String",
          "source": "src/Text-PrintScanF.html#prefix",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text PrintScanF",
          "module": "Text.PrintScanF",
          "name": "prefix",
          "normalized": "String-\u003eString-\u003eMaybe String",
          "package": "liboleg",
          "signature": "String-\u003eString-\u003eMaybe String",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Text-PrintScanF.html#v:prefix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.PrintScanF",
          "name": "showread",
          "package": "liboleg",
          "signature": "PrinterParser a",
          "source": "src/Text-PrintScanF.html#showread",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text PrintScanF",
          "module": "Text.PrintScanF",
          "name": "showread",
          "package": "liboleg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Text-PrintScanF.html#v:showread"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Text.PrintScanF\",\"Text.TotalPrintF\"]",
          "name": "sprintf",
          "package": "liboleg",
          "signature": "FPr String b -\u003e b",
          "source": "src/Text-PrintScanF.html#sprintf",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/liboleg/docs/Text-PrintScanF.html#v:sprintf\",\"http://hackage.haskell.org/package/liboleg/docs/Text-TotalPrintF.html#v:sprintf\"]"
        },
        "index": {
          "hierarchy": "Text PrintScanF",
          "module": "Text.PrintScanF",
          "name": "sprintf",
          "normalized": "FPr String a-\u003ea",
          "package": "liboleg",
          "signature": "FPr String b-\u003eb",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Text-PrintScanF.html#v:sprintf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Text.PrintScanF\",\"Text.TotalPrintF\"]",
          "name": "sscanf",
          "package": "liboleg",
          "signature": "String -\u003e FSc a b -\u003e b -\u003e Maybe a",
          "source": "src/Text-PrintScanF.html#sscanf",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/liboleg/docs/Text-PrintScanF.html#v:sscanf\",\"http://hackage.haskell.org/package/liboleg/docs/Text-TotalPrintF.html#v:sscanf\"]"
        },
        "index": {
          "hierarchy": "Text PrintScanF",
          "module": "Text.PrintScanF",
          "name": "sscanf",
          "normalized": "String-\u003eFSc a b-\u003eb-\u003eMaybe a",
          "package": "liboleg",
          "signature": "String-\u003eFSc a b-\u003eb-\u003eMaybe a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Text-PrintScanF.html#v:sscanf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eType-safe printf and scanf with C-like formatting string\n We also permit a generic format specifier %a to format or parse\n any showable and readable value.\n Our format descriptors are first-class and can be built incrementally.\n We can use the same format descriptor to format to a string,\n to the standard output or any other data sink. Furthermore,\n we can use the same format descriptor to parse from a string\n or any data source.\n What we print we can parse, using the same descriptor.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Text.TFTest",
          "name": "TFTest",
          "package": "liboleg",
          "source": "src/Text-TFTest.html",
          "type": "module"
        },
        "index": {
          "description": "Type-safe printf and scanf with C-like formatting string We also permit generic format specifier to format or parse any showable and readable value Our format descriptors are first-class and can be built incrementally We can use the same format descriptor to format to string to the standard output or any other data sink Furthermore we can use the same format descriptor to parse from string or any data source What we print we can parse using the same descriptor",
          "hierarchy": "Text TFTest",
          "module": "Text.TFTest",
          "name": "TFTest",
          "package": "liboleg",
          "partial": "TFTest",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Text-TFTest.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.TFTest",
          "name": "FPrIO",
          "package": "liboleg",
          "source": "src/Text-TFTest.html#FPrIO",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "Text TFTest",
          "module": "Text.TFTest",
          "name": "FPrIO",
          "package": "liboleg",
          "partial": "FPr IO",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Text-TFTest.html#t:FPrIO"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.TFTest",
          "name": "FPrIO",
          "package": "liboleg",
          "signature": "FPrIO ((IO () -\u003e a) -\u003e b)",
          "source": "src/Text-TFTest.html#FPrIO",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text TFTest",
          "module": "Text.TFTest",
          "name": "FPrIO",
          "normalized": "FPrIO((IO()-\u003ea)-\u003eb)",
          "package": "liboleg",
          "partial": "FPr IO",
          "signature": "FPrIO((IO()-\u003ea)-\u003eb)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Text-TFTest.html#v:FPrIO"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003e\u003ca\u003ehttp://okmij.org/ftp/typed-formatting/FPrintScan.html#C-like\u003c/a\u003e\n\u003c/p\u003e\u003cp\u003eSafe and generic printf/scanf with C-like format string\n\u003c/p\u003e\u003cp\u003eWe implement printf that takes a C-like format string and the variable number\n of other arguments.  Unlike C of Haskell's printf, ours is total: if the types\n or the number of the other arguments, the values to format, does not match the\n format string, a type error is reported at compile time.  To the familiar\n format descriptors %s and %d we add %a to format any showable value. The latter\n is like the format descriptor ~a of Common Lisp. Likewise, we build scanf that\n takes a C-like format string and the consumer function with the variable number\n of arguments. The types and the number of the arguments must match the format\n string; a type error is reported otherwise.\n\u003c/p\u003e\u003cp\u003eOur approach is a variation of the safe printf and scanf described\n elsewhere on this page. We use Template Haskell to translate the format string\n to a phrase in the DSL of format descriptors. We use the final approach to\n embed that DSL into Haskell.\n\u003c/p\u003e\u003cp\u003eUnlike the safe printf explained in the Template Haskell documentation, in\n our implementation, format descriptors are first class. They can be built\n incrementally. The same descriptor can be used both for printing and for\n parsing. Our printf and scanf are user-extensible: library users can write\n functions to direct format output to any suitable data sink, or to read parsed\n data from any suitable data source such as string or a file. Finally, what is\n formatted can be parsed back using the same format descriptor.\n\u003c/p\u003e\u003cp\u003eHere are some of the tests from the test collection referenced below. The\n evaluation result is given in the comments below each binding. Example t31\n shows that format descriptors are indeed first-class. The definition t32, when\n uncommented, raises the shown type error because the format descriptor does not\n match the type of the corresponding argument.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Text.TotalPrintF",
          "name": "TotalPrintF",
          "package": "liboleg",
          "source": "src/Text-TotalPrintF.html",
          "type": "module"
        },
        "index": {
          "description": "http okmij.org ftp typed-formatting FPrintScan.html C-like Safe and generic printf scanf with C-like format string We implement printf that takes C-like format string and the variable number of other arguments Unlike of Haskell printf ours is total if the types or the number of the other arguments the values to format does not match the format string type error is reported at compile time To the familiar format descriptors and we add to format any showable value The latter is like the format descriptor of Common Lisp Likewise we build scanf that takes C-like format string and the consumer function with the variable number of arguments The types and the number of the arguments must match the format string type error is reported otherwise Our approach is variation of the safe printf and scanf described elsewhere on this page We use Template Haskell to translate the format string to phrase in the DSL of format descriptors We use the final approach to embed that DSL into Haskell Unlike the safe printf explained in the Template Haskell documentation in our implementation format descriptors are first class They can be built incrementally The same descriptor can be used both for printing and for parsing Our printf and scanf are user-extensible library users can write functions to direct format output to any suitable data sink or to read parsed data from any suitable data source such as string or file Finally what is formatted can be parsed back using the same format descriptor Here are some of the tests from the test collection referenced below The evaluation result is given in the comments below each binding Example t31 shows that format descriptors are indeed first-class The definition t32 when uncommented raises the shown type error because the format descriptor does not match the type of the corresponding argument",
          "hierarchy": "Text TotalPrintF",
          "module": "Text.TotalPrintF",
          "name": "TotalPrintF",
          "package": "liboleg",
          "partial": "Total Print",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Text-TotalPrintF.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.TotalPrintF",
          "name": "(^)",
          "package": "liboleg",
          "signature": "repr b c -\u003e repr a b -\u003e repr a c",
          "source": "src/Text-PrintScanF.html#%5E",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text TotalPrintF",
          "module": "Text.TotalPrintF",
          "name": "(^) ^",
          "normalized": "a b c-\u003ea d b-\u003ea d c",
          "package": "liboleg",
          "signature": "repr b c-\u003erepr a b-\u003erepr a c",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Text-TotalPrintF.html#v:-94-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.TotalPrintF",
          "name": "spec",
          "package": "liboleg",
          "signature": "String -\u003e ExpQ",
          "source": "src/Text-TotalPrintF.html#spec",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text TotalPrintF",
          "module": "Text.TotalPrintF",
          "name": "spec",
          "normalized": "String-\u003eExpQ",
          "package": "liboleg",
          "signature": "String-\u003eExpQ",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/liboleg/docs/Text-TotalPrintF.html#v:spec"
      }
    }
  ]
]