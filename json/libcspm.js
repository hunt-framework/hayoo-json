[
  {
    "cmd": "delete-by-query",
    "query": {
      "contexts": [
        "package"
      ],
      "query": {
        "op": "case",
        "type": "word",
        "word": "libcspm"
      },
      "type": "context"
    }
  },
  [
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.CommandLineOptions",
          "name": "CommandLineOptions",
          "package": "libcspm",
          "source": "src/CSPM-CommandLineOptions.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "CSPM CommandLineOptions",
          "module": "CSPM.CommandLineOptions",
          "name": "CommandLineOptions",
          "package": "libcspm",
          "partial": "Command Line Options",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-CommandLineOptions.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe type of options for libcspm.\n\u003c/p\u003e",
          "module": "CSPM.CommandLineOptions",
          "name": "Options",
          "package": "libcspm",
          "source": "src/CSPM-CommandLineOptions.html#Options",
          "type": "data"
        },
        "index": {
          "description": "The type of options for libcspm",
          "hierarchy": "CSPM CommandLineOptions",
          "module": "CSPM.CommandLineOptions",
          "name": "Options",
          "package": "libcspm",
          "partial": "Options",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-CommandLineOptions.html#t:Options"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.CommandLineOptions",
          "name": "Options",
          "package": "libcspm",
          "signature": "Options",
          "source": "src/CSPM-CommandLineOptions.html#Options",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM CommandLineOptions",
          "module": "CSPM.CommandLineOptions",
          "name": "Options",
          "package": "libcspm",
          "partial": "Options",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-CommandLineOptions.html#v:Options"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAll available command line options.\n\u003c/p\u003e",
          "module": "CSPM.CommandLineOptions",
          "name": "allOptions",
          "package": "libcspm",
          "signature": "(a -\u003e Options) -\u003e (a -\u003e Options -\u003e a) -\u003e [OptDescr (a -\u003e a)]",
          "source": "src/CSPM-CommandLineOptions.html#allOptions",
          "type": "function"
        },
        "index": {
          "description": "All available command line options",
          "hierarchy": "CSPM CommandLineOptions",
          "module": "CSPM.CommandLineOptions",
          "name": "allOptions",
          "normalized": "(a-\u003eOptions)-\u003e(a-\u003eOptions-\u003ea)-\u003e[OptDescr(a-\u003ea)]",
          "package": "libcspm",
          "partial": "Options",
          "signature": "(a-\u003eOptions)-\u003e(a-\u003eOptions-\u003ea)-\u003e[OptDescr(a-\u003ea)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-CommandLineOptions.html#v:allOptions"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe default set of options.\n\u003c/p\u003e",
          "module": "CSPM.CommandLineOptions",
          "name": "defaultOptions",
          "package": "libcspm",
          "signature": "Options",
          "source": "src/CSPM-CommandLineOptions.html#defaultOptions",
          "type": "function"
        },
        "index": {
          "description": "The default set of options",
          "hierarchy": "CSPM CommandLineOptions",
          "module": "CSPM.CommandLineOptions",
          "name": "defaultOptions",
          "package": "libcspm",
          "partial": "Options",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-CommandLineOptions.html#v:defaultOptions"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSets the options to the values given.\n\u003c/p\u003e",
          "module": "CSPM.CommandLineOptions",
          "name": "setOptions",
          "package": "libcspm",
          "signature": "Options -\u003e m ()",
          "source": "src/CSPM-CommandLineOptions.html#setOptions",
          "type": "function"
        },
        "index": {
          "description": "Sets the options to the values given",
          "hierarchy": "CSPM CommandLineOptions",
          "module": "CSPM.CommandLineOptions",
          "name": "setOptions",
          "normalized": "Options-\u003ea()",
          "package": "libcspm",
          "partial": "Options",
          "signature": "Options-\u003em()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-CommandLineOptions.html#v:setOptions"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.CommandLineOptions",
          "name": "tcOptions",
          "package": "libcspm",
          "signature": "ErrorOptions",
          "source": "src/CSPM-CommandLineOptions.html#Options",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM CommandLineOptions",
          "module": "CSPM.CommandLineOptions",
          "name": "tcOptions",
          "package": "libcspm",
          "partial": "Options",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-CommandLineOptions.html#v:tcOptions"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAll options for the type-checker.\n\u003c/p\u003e",
          "module": "CSPM.CommandLineOptions",
          "name": "typeCheckerOptions",
          "package": "libcspm",
          "signature": "(a -\u003e Options) -\u003e (a -\u003e Options -\u003e a) -\u003e [OptDescr (a -\u003e a)]",
          "source": "src/CSPM-CommandLineOptions.html#typeCheckerOptions",
          "type": "function"
        },
        "index": {
          "description": "All options for the type-checker",
          "hierarchy": "CSPM CommandLineOptions",
          "module": "CSPM.CommandLineOptions",
          "name": "typeCheckerOptions",
          "normalized": "(a-\u003eOptions)-\u003e(a-\u003eOptions-\u003ea)-\u003e[OptDescr(a-\u003ea)]",
          "package": "libcspm",
          "partial": "Checker Options",
          "signature": "(a-\u003eOptions)-\u003e(a-\u003eOptions-\u003ea)-\u003e[OptDescr(a-\u003ea)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-CommandLineOptions.html#v:typeCheckerOptions"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.FreeVars",
          "name": "FreeVars",
          "package": "libcspm",
          "source": "src/CSPM-DataStructures-FreeVars.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "CSPM DataStructures FreeVars",
          "module": "CSPM.DataStructures.FreeVars",
          "name": "FreeVars",
          "package": "libcspm",
          "partial": "Free Vars",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-FreeVars.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.FreeVars",
          "name": "BoundNames",
          "package": "libcspm",
          "source": "src/CSPM-DataStructures-FreeVars.html#BoundNames",
          "type": "class"
        },
        "index": {
          "hierarchy": "CSPM DataStructures FreeVars",
          "module": "CSPM.DataStructures.FreeVars",
          "name": "BoundNames",
          "package": "libcspm",
          "partial": "Bound Names",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-FreeVars.html#t:BoundNames"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.FreeVars",
          "name": "FreeVars",
          "package": "libcspm",
          "source": "src/CSPM-DataStructures-FreeVars.html#FreeVars",
          "type": "class"
        },
        "index": {
          "hierarchy": "CSPM DataStructures FreeVars",
          "module": "CSPM.DataStructures.FreeVars",
          "name": "FreeVars",
          "package": "libcspm",
          "partial": "Free Vars",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-FreeVars.html#t:FreeVars"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.FreeVars",
          "name": "boundNames",
          "package": "libcspm",
          "signature": "a -\u003e [Name]",
          "source": "src/CSPM-DataStructures-FreeVars.html#boundNames",
          "type": "method"
        },
        "index": {
          "hierarchy": "CSPM DataStructures FreeVars",
          "module": "CSPM.DataStructures.FreeVars",
          "name": "boundNames",
          "normalized": "a-\u003e[Name]",
          "package": "libcspm",
          "partial": "Names",
          "signature": "a-\u003e[Name]",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-FreeVars.html#v:boundNames"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.FreeVars",
          "name": "freeVars",
          "package": "libcspm",
          "signature": "a -\u003e [Name]",
          "source": "src/CSPM-DataStructures-FreeVars.html#freeVars",
          "type": "method"
        },
        "index": {
          "hierarchy": "CSPM DataStructures FreeVars",
          "module": "CSPM.DataStructures.FreeVars",
          "name": "freeVars",
          "normalized": "a-\u003e[Name]",
          "package": "libcspm",
          "partial": "Vars",
          "signature": "a-\u003e[Name]",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-FreeVars.html#v:freeVars"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.FreeVars",
          "name": "freeVars'",
          "package": "libcspm",
          "signature": "a -\u003e [Name]",
          "source": "src/CSPM-DataStructures-FreeVars.html#freeVars%27",
          "type": "method"
        },
        "index": {
          "hierarchy": "CSPM DataStructures FreeVars",
          "module": "CSPM.DataStructures.FreeVars",
          "name": "freeVars'",
          "normalized": "a-\u003e[Name]",
          "package": "libcspm",
          "partial": "Vars'",
          "signature": "a-\u003e[Name]",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-FreeVars.html#v:freeVars-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Literals",
          "name": "Literals",
          "package": "libcspm",
          "source": "src/CSPM-DataStructures-Literals.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Literals",
          "module": "CSPM.DataStructures.Literals",
          "name": "Literals",
          "package": "libcspm",
          "partial": "Literals",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Literals.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Literals",
          "name": "Literal",
          "package": "libcspm",
          "source": "src/CSPM-DataStructures-Literals.html#Literal",
          "type": "data"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Literals",
          "module": "CSPM.DataStructures.Literals",
          "name": "Literal",
          "package": "libcspm",
          "partial": "Literal",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Literals.html#t:Literal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA boolean.\n\u003c/p\u003e",
          "module": "CSPM.DataStructures.Literals",
          "name": "Bool",
          "package": "libcspm",
          "signature": "Bool Bool",
          "source": "src/CSPM-DataStructures-Literals.html#Literal",
          "type": "function"
        },
        "index": {
          "description": "boolean",
          "hierarchy": "CSPM DataStructures Literals",
          "module": "CSPM.DataStructures.Literals",
          "name": "Bool",
          "package": "libcspm",
          "partial": "Bool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Literals.html#v:Bool"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA character.\n\u003c/p\u003e",
          "module": "CSPM.DataStructures.Literals",
          "name": "Char",
          "package": "libcspm",
          "signature": "Char Char",
          "source": "src/CSPM-DataStructures-Literals.html#Literal",
          "type": "function"
        },
        "index": {
          "description": "character",
          "hierarchy": "CSPM DataStructures Literals",
          "module": "CSPM.DataStructures.Literals",
          "name": "Char",
          "package": "libcspm",
          "partial": "Char",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Literals.html#v:Char"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn integer. This is finite size, as per the FDR spec.\n\u003c/p\u003e",
          "module": "CSPM.DataStructures.Literals",
          "name": "Int",
          "package": "libcspm",
          "signature": "Int Int",
          "source": "src/CSPM-DataStructures-Literals.html#Literal",
          "type": "function"
        },
        "index": {
          "description": "An integer This is finite size as per the FDR spec",
          "hierarchy": "CSPM DataStructures Literals",
          "module": "CSPM.DataStructures.Literals",
          "name": "Int",
          "package": "libcspm",
          "partial": "Int",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Literals.html#v:Int"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA string.\n\u003c/p\u003e",
          "module": "CSPM.DataStructures.Literals",
          "name": "String",
          "package": "libcspm",
          "signature": "String String",
          "source": "src/CSPM-DataStructures-Literals.html#Literal",
          "type": "function"
        },
        "index": {
          "description": "string",
          "hierarchy": "CSPM DataStructures Literals",
          "module": "CSPM.DataStructures.Literals",
          "name": "String",
          "package": "libcspm",
          "partial": "String",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Literals.html#v:String"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eNames used by the evaluator. This is heavily inspired by GHC.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "CSPM.DataStructures.Names",
          "name": "Names",
          "package": "libcspm",
          "source": "src/CSPM-DataStructures-Names.html",
          "type": "module"
        },
        "index": {
          "description": "Names used by the evaluator This is heavily inspired by GHC",
          "hierarchy": "CSPM DataStructures Names",
          "module": "CSPM.DataStructures.Names",
          "name": "Names",
          "package": "libcspm",
          "partial": "Names",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Names.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA renamed name and is the exclusive type used after the renamer. Names\n are guaranteed to be unique, meaning that two names are equal iff they\n refer to the same binding instance. For example, consider the following CSPM\n code:\n\u003c/p\u003e\u003cpre\u003e\n      f = 1\n      g = let f = 2 within (f, f)\n\u003c/pre\u003e\u003cp\u003eThis will be renamed to:\n\u003c/p\u003e\u003cpre\u003e\n      f0 = 1\n      g = let f1 = 2 within (f1, f1)\n\u003c/pre\u003e",
          "module": "CSPM.DataStructures.Names",
          "name": "Name",
          "package": "libcspm",
          "source": "src/CSPM-DataStructures-Names.html#Name",
          "type": "data"
        },
        "index": {
          "description": "renamed name and is the exclusive type used after the renamer Names are guaranteed to be unique meaning that two names are equal iff they refer to the same binding instance For example consider the following CSPM code let within This will be renamed to f0 let f1 within f1 f1",
          "hierarchy": "CSPM DataStructures Names",
          "module": "CSPM.DataStructures.Names",
          "name": "Name",
          "package": "libcspm",
          "partial": "Name",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Names.html#t:Name"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Names",
          "name": "NameType",
          "package": "libcspm",
          "source": "src/CSPM-DataStructures-Names.html#NameType",
          "type": "data"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Names",
          "module": "CSPM.DataStructures.Names",
          "name": "NameType",
          "package": "libcspm",
          "partial": "Name Type",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Names.html#t:NameType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA name that occurs in the source code somewhere.\n\u003c/p\u003e",
          "module": "CSPM.DataStructures.Names",
          "name": "OccName",
          "package": "libcspm",
          "source": "src/CSPM-DataStructures-Names.html#OccName",
          "type": "data"
        },
        "index": {
          "description": "name that occurs in the source code somewhere",
          "hierarchy": "CSPM DataStructures Names",
          "module": "CSPM.DataStructures.Names",
          "name": "OccName",
          "package": "libcspm",
          "partial": "Occ Name",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Names.html#t:OccName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA name that has not yet been renamed. Created by the parser.\n\u003c/p\u003e",
          "module": "CSPM.DataStructures.Names",
          "name": "UnRenamedName",
          "package": "libcspm",
          "source": "src/CSPM-DataStructures-Names.html#UnRenamedName",
          "type": "data"
        },
        "index": {
          "description": "name that has not yet been renamed Created by the parser",
          "hierarchy": "CSPM DataStructures Names",
          "module": "CSPM.DataStructures.Names",
          "name": "UnRenamedName",
          "package": "libcspm",
          "partial": "Un Renamed Name",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Names.html#t:UnRenamedName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn externally visible name (like a top level definition).\n\u003c/p\u003e",
          "module": "CSPM.DataStructures.Names",
          "name": "ExternalName",
          "package": "libcspm",
          "signature": "ExternalName",
          "source": "src/CSPM-DataStructures-Names.html#NameType",
          "type": "function"
        },
        "index": {
          "description": "An externally visible name like top level definition",
          "hierarchy": "CSPM DataStructures Names",
          "module": "CSPM.DataStructures.Names",
          "name": "ExternalName",
          "package": "libcspm",
          "partial": "External Name",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Names.html#v:ExternalName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA name created by the renamer, but from the users' source (e.g. from\n a lambda).\n\u003c/p\u003e",
          "module": "CSPM.DataStructures.Names",
          "name": "InternalName",
          "package": "libcspm",
          "signature": "InternalName",
          "source": "src/CSPM-DataStructures-Names.html#NameType",
          "type": "function"
        },
        "index": {
          "description": "name created by the renamer but from the users source e.g from lambda",
          "hierarchy": "CSPM DataStructures Names",
          "module": "CSPM.DataStructures.Names",
          "name": "InternalName",
          "package": "libcspm",
          "partial": "Internal Name",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Names.html#v:InternalName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Names",
          "name": "Name",
          "package": "libcspm",
          "signature": "Name",
          "source": "src/CSPM-DataStructures-Names.html#Name",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Names",
          "module": "CSPM.DataStructures.Names",
          "name": "Name",
          "package": "libcspm",
          "partial": "Name",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Names.html#v:Name"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Names",
          "name": "OccName",
          "package": "libcspm",
          "signature": "OccName String",
          "source": "src/CSPM-DataStructures-Names.html#OccName",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Names",
          "module": "CSPM.DataStructures.Names",
          "name": "OccName",
          "package": "libcspm",
          "partial": "Occ Name",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Names.html#v:OccName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Names",
          "name": "Qual",
          "package": "libcspm",
          "signature": "Qual",
          "source": "src/CSPM-DataStructures-Names.html#UnRenamedName",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Names",
          "module": "CSPM.DataStructures.Names",
          "name": "Qual",
          "package": "libcspm",
          "partial": "Qual",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Names.html#v:Qual"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Names",
          "name": "UnQual",
          "package": "libcspm",
          "signature": "UnQual OccName",
          "source": "src/CSPM-DataStructures-Names.html#UnRenamedName",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Names",
          "module": "CSPM.DataStructures.Names",
          "name": "UnQual",
          "package": "libcspm",
          "partial": "Un Qual",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Names.html#v:UnQual"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA built in name.\n\u003c/p\u003e",
          "module": "CSPM.DataStructures.Names",
          "name": "WiredInName",
          "package": "libcspm",
          "signature": "WiredInName",
          "source": "src/CSPM-DataStructures-Names.html#NameType",
          "type": "function"
        },
        "index": {
          "description": "built in name",
          "hierarchy": "CSPM DataStructures Names",
          "module": "CSPM.DataStructures.Names",
          "name": "WiredInName",
          "package": "libcspm",
          "partial": "Wired In Name",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Names.html#v:WiredInName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDoes the given Name correspond to a data type or a channel definition.\n\u003c/p\u003e",
          "module": "CSPM.DataStructures.Names",
          "name": "isNameDataConstructor",
          "package": "libcspm",
          "signature": "Name -\u003e Bool",
          "source": "src/CSPM-DataStructures-Names.html#isNameDataConstructor",
          "type": "function"
        },
        "index": {
          "description": "Does the given Name correspond to data type or channel definition",
          "hierarchy": "CSPM DataStructures Names",
          "module": "CSPM.DataStructures.Names",
          "name": "isNameDataConstructor",
          "normalized": "Name-\u003eBool",
          "package": "libcspm",
          "partial": "Name Data Constructor",
          "signature": "Name-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Names.html#v:isNameDataConstructor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Names",
          "name": "mkExternalName",
          "package": "libcspm",
          "signature": "UnRenamedName -\u003e SrcSpan -\u003e Bool -\u003e m Name",
          "source": "src/CSPM-DataStructures-Names.html#mkExternalName",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Names",
          "module": "CSPM.DataStructures.Names",
          "name": "mkExternalName",
          "normalized": "UnRenamedName-\u003eSrcSpan-\u003eBool-\u003ea Name",
          "package": "libcspm",
          "partial": "External Name",
          "signature": "UnRenamedName-\u003eSrcSpan-\u003eBool-\u003em Name",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Names.html#v:mkExternalName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Names",
          "name": "mkFreshInternalName",
          "package": "libcspm",
          "signature": "m Name",
          "source": "src/CSPM-DataStructures-Names.html#mkFreshInternalName",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Names",
          "module": "CSPM.DataStructures.Names",
          "name": "mkFreshInternalName",
          "package": "libcspm",
          "partial": "Fresh Internal Name",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Names.html#v:mkFreshInternalName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Names",
          "name": "mkInternalName",
          "package": "libcspm",
          "signature": "UnRenamedName -\u003e SrcSpan -\u003e m Name",
          "source": "src/CSPM-DataStructures-Names.html#mkInternalName",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Names",
          "module": "CSPM.DataStructures.Names",
          "name": "mkInternalName",
          "normalized": "UnRenamedName-\u003eSrcSpan-\u003ea Name",
          "package": "libcspm",
          "partial": "Internal Name",
          "signature": "UnRenamedName-\u003eSrcSpan-\u003em Name",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Names.html#v:mkInternalName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Names",
          "name": "mkWiredInName",
          "package": "libcspm",
          "signature": "UnRenamedName -\u003e Bool -\u003e m Name",
          "source": "src/CSPM-DataStructures-Names.html#mkWiredInName",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Names",
          "module": "CSPM.DataStructures.Names",
          "name": "mkWiredInName",
          "normalized": "UnRenamedName-\u003eBool-\u003ea Name",
          "package": "libcspm",
          "partial": "Wired In Name",
          "signature": "UnRenamedName-\u003eBool-\u003em Name",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Names.html#v:mkWiredInName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWhere this name was defined. If this occurs in a pattern, then it\n will be equal to the location of the pattern, otherwise it will be\n equal to the location of the definition that this name binds to.\n\u003c/p\u003e",
          "module": "CSPM.DataStructures.Names",
          "name": "nameDefinition",
          "package": "libcspm",
          "signature": "SrcSpan",
          "source": "src/CSPM-DataStructures-Names.html#Name",
          "type": "function"
        },
        "index": {
          "description": "Where this name was defined If this occurs in pattern then it will be equal to the location of the pattern otherwise it will be equal to the location of the definition that this name binds to",
          "hierarchy": "CSPM DataStructures Names",
          "module": "CSPM.DataStructures.Names",
          "name": "nameDefinition",
          "package": "libcspm",
          "partial": "Definition",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Names.html#v:nameDefinition"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe original occurence of this name (used for error messages).\n\u003c/p\u003e",
          "module": "CSPM.DataStructures.Names",
          "name": "nameFullyQualified",
          "package": "libcspm",
          "signature": "UnRenamedName",
          "source": "src/CSPM-DataStructures-Names.html#Name",
          "type": "function"
        },
        "index": {
          "description": "The original occurence of this name used for error messages",
          "hierarchy": "CSPM DataStructures Names",
          "module": "CSPM.DataStructures.Names",
          "name": "nameFullyQualified",
          "package": "libcspm",
          "partial": "Fully Qualified",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Names.html#v:nameFullyQualified"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIs this name a type constructor, i.e. a datatype or a channel?\n\u003c/p\u003e",
          "module": "CSPM.DataStructures.Names",
          "name": "nameIsConstructor",
          "package": "libcspm",
          "signature": "Bool",
          "source": "src/CSPM-DataStructures-Names.html#Name",
          "type": "function"
        },
        "index": {
          "description": "Is this name type constructor i.e datatype or channel",
          "hierarchy": "CSPM DataStructures Names",
          "module": "CSPM.DataStructures.Names",
          "name": "nameIsConstructor",
          "package": "libcspm",
          "partial": "Is Constructor",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Names.html#v:nameIsConstructor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe type of this name.\n\u003c/p\u003e",
          "module": "CSPM.DataStructures.Names",
          "name": "nameType",
          "package": "libcspm",
          "signature": "NameType",
          "source": "src/CSPM-DataStructures-Names.html#Name",
          "type": "function"
        },
        "index": {
          "description": "The type of this name",
          "hierarchy": "CSPM DataStructures Names",
          "module": "CSPM.DataStructures.Names",
          "name": "nameType",
          "package": "libcspm",
          "partial": "Type",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Names.html#v:nameType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe unique identifier for this name. Inserted by the renamer.\n\u003c/p\u003e",
          "module": "CSPM.DataStructures.Names",
          "name": "nameUnique",
          "package": "libcspm",
          "signature": "Int",
          "source": "src/CSPM-DataStructures-Names.html#Name",
          "type": "function"
        },
        "index": {
          "description": "The unique identifier for this name Inserted by the renamer",
          "hierarchy": "CSPM DataStructures Names",
          "module": "CSPM.DataStructures.Names",
          "name": "nameUnique",
          "package": "libcspm",
          "partial": "Unique",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Names.html#v:nameUnique"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Names",
          "name": "unRenamedNameMemberName",
          "package": "libcspm",
          "signature": "UnRenamedName",
          "source": "src/CSPM-DataStructures-Names.html#UnRenamedName",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Names",
          "module": "CSPM.DataStructures.Names",
          "name": "unRenamedNameMemberName",
          "package": "libcspm",
          "partial": "Renamed Name Member Name",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Names.html#v:unRenamedNameMemberName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Names",
          "name": "unRenamedNameModuleName",
          "package": "libcspm",
          "signature": "OccName",
          "source": "src/CSPM-DataStructures-Names.html#UnRenamedName",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Names",
          "module": "CSPM.DataStructures.Names",
          "name": "unRenamedNameModuleName",
          "package": "libcspm",
          "partial": "Renamed Name Module Name",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Names.html#v:unRenamedNameModuleName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module represents the abstract syntax tree of machine CSP.\n Most of the datatypes are parameterised over the type of variables that they\n contain. Before renaming (by \u003ccode\u003e\u003ca\u003eRenamer\u003c/a\u003e\u003c/code\u003e) the variables are of type \n \u003ccode\u003e\u003ca\u003eUnRenamedName\u003c/a\u003e\u003c/code\u003e, wheras after renaming they are of type \u003ccode\u003e\u003ca\u003eName\u003c/a\u003e\u003c/code\u003e (and are\n hence associated with their bindings instances). Furthermore, nearly all\n pieces of syntax are annoated with their location in the source code, and\n (sometimes) with their type (but only after type checking). This is done \n using the \u003ccode\u003e\u003ca\u003eAnnotated\u003c/a\u003e\u003c/code\u003e datatype.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "CSPM.DataStructures.Syntax",
          "name": "Syntax",
          "package": "libcspm",
          "source": "src/CSPM-DataStructures-Syntax.html",
          "type": "module"
        },
        "index": {
          "description": "This module represents the abstract syntax tree of machine CSP Most of the datatypes are parameterised over the type of variables that they contain Before renaming by Renamer the variables are of type UnRenamedName wheras after renaming they are of type Name and are hence associated with their bindings instances Furthermore nearly all pieces of syntax are annoated with their location in the source code and sometimes with their type but only after type checking This is done using the Annotated datatype",
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "Syntax",
          "package": "libcspm",
          "partial": "Syntax",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "AnAssertion",
          "package": "libcspm",
          "source": "src/CSPM-DataStructures-Syntax.html#AnAssertion",
          "type": "type"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "AnAssertion",
          "package": "libcspm",
          "partial": "An Assertion",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#t:AnAssertion"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "AnCSPMFile",
          "package": "libcspm",
          "source": "src/CSPM-DataStructures-Syntax.html#AnCSPMFile",
          "type": "type"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "AnCSPMFile",
          "package": "libcspm",
          "partial": "An CSPMFile",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#t:AnCSPMFile"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "AnDataTypeClause",
          "package": "libcspm",
          "source": "src/CSPM-DataStructures-Syntax.html#AnDataTypeClause",
          "type": "type"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "AnDataTypeClause",
          "package": "libcspm",
          "partial": "An Data Type Clause",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#t:AnDataTypeClause"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "AnDecl",
          "package": "libcspm",
          "source": "src/CSPM-DataStructures-Syntax.html#AnDecl",
          "type": "type"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "AnDecl",
          "package": "libcspm",
          "partial": "An Decl",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#t:AnDecl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "AnExp",
          "package": "libcspm",
          "source": "src/CSPM-DataStructures-Syntax.html#AnExp",
          "type": "type"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "AnExp",
          "package": "libcspm",
          "partial": "An Exp",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#t:AnExp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "AnField",
          "package": "libcspm",
          "source": "src/CSPM-DataStructures-Syntax.html#AnField",
          "type": "type"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "AnField",
          "package": "libcspm",
          "partial": "An Field",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#t:AnField"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "AnInteractiveStmt",
          "package": "libcspm",
          "source": "src/CSPM-DataStructures-Syntax.html#AnInteractiveStmt",
          "type": "type"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "AnInteractiveStmt",
          "package": "libcspm",
          "partial": "An Interactive Stmt",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#t:AnInteractiveStmt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "AnMatch",
          "package": "libcspm",
          "source": "src/CSPM-DataStructures-Syntax.html#AnMatch",
          "type": "type"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "AnMatch",
          "package": "libcspm",
          "partial": "An Match",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#t:AnMatch"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "AnPat",
          "package": "libcspm",
          "source": "src/CSPM-DataStructures-Syntax.html#AnPat",
          "type": "type"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "AnPat",
          "package": "libcspm",
          "partial": "An Pat",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#t:AnPat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "AnSType",
          "package": "libcspm",
          "source": "src/CSPM-DataStructures-Syntax.html#AnSType",
          "type": "type"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "AnSType",
          "package": "libcspm",
          "partial": "An SType",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#t:AnSType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "AnSTypeConstraint",
          "package": "libcspm",
          "source": "src/CSPM-DataStructures-Syntax.html#AnSTypeConstraint",
          "type": "type"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "AnSTypeConstraint",
          "package": "libcspm",
          "partial": "An SType Constraint",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#t:AnSTypeConstraint"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "AnSTypeScheme",
          "package": "libcspm",
          "source": "src/CSPM-DataStructures-Syntax.html#AnSTypeScheme",
          "type": "type"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "AnSTypeScheme",
          "package": "libcspm",
          "partial": "An SType Scheme",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#t:AnSTypeScheme"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "AnStmt",
          "package": "libcspm",
          "source": "src/CSPM-DataStructures-Syntax.html#AnStmt",
          "type": "type"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "AnStmt",
          "package": "libcspm",
          "partial": "An Stmt",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#t:AnStmt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "Assertion",
          "package": "libcspm",
          "source": "src/CSPM-DataStructures-Syntax.html#Assertion",
          "type": "data"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "Assertion",
          "package": "libcspm",
          "partial": "Assertion",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#t:Assertion"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "BinaryBooleanOp",
          "package": "libcspm",
          "source": "src/CSPM-DataStructures-Syntax.html#BinaryBooleanOp",
          "type": "data"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "BinaryBooleanOp",
          "package": "libcspm",
          "partial": "Binary Boolean Op",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#t:BinaryBooleanOp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "BinaryMathsOp",
          "package": "libcspm",
          "source": "src/CSPM-DataStructures-Syntax.html#BinaryMathsOp",
          "type": "data"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "BinaryMathsOp",
          "package": "libcspm",
          "partial": "Binary Maths Op",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#t:BinaryMathsOp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "CSPMFile",
          "package": "libcspm",
          "source": "src/CSPM-DataStructures-Syntax.html#CSPMFile",
          "type": "data"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "CSPMFile",
          "package": "libcspm",
          "partial": "CSPMFile",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#t:CSPMFile"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe clause of a datatype, e.g. if a datatype declaration was:\n\u003c/p\u003e\u003cpre\u003e datatype T = A.Int.Bool | B.Bool | C\n\u003c/pre\u003e\u003cp\u003eThen T would have three datatype clauses, one for each of its tags (i.e.\n \u003ccode\u003eA\u003c/code\u003e, \u003ccode\u003eB\u003c/code\u003e and \u003ccode\u003eC\u003c/code\u003e).\n\u003c/p\u003e",
          "module": "CSPM.DataStructures.Syntax",
          "name": "DataTypeClause",
          "package": "libcspm",
          "source": "src/CSPM-DataStructures-Syntax.html#DataTypeClause",
          "type": "data"
        },
        "index": {
          "description": "The clause of datatype e.g if datatype declaration was datatype A.Int.Bool B.Bool Then would have three datatype clauses one for each of its tags i.e and",
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "DataTypeClause",
          "package": "libcspm",
          "partial": "Data Type Clause",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#t:DataTypeClause"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "Decl",
          "package": "libcspm",
          "source": "src/CSPM-DataStructures-Syntax.html#Decl",
          "type": "data"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "Decl",
          "package": "libcspm",
          "partial": "Decl",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#t:Decl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn expression.\n\u003c/p\u003e",
          "module": "CSPM.DataStructures.Syntax",
          "name": "Exp",
          "package": "libcspm",
          "source": "src/CSPM-DataStructures-Syntax.html#Exp",
          "type": "data"
        },
        "index": {
          "description": "An expression",
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "Exp",
          "package": "libcspm",
          "partial": "Exp",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#t:Exp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "Field",
          "package": "libcspm",
          "source": "src/CSPM-DataStructures-Syntax.html#Field",
          "type": "data"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "Field",
          "package": "libcspm",
          "partial": "Field",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#t:Field"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA statement in an interactive session.\n\u003c/p\u003e",
          "module": "CSPM.DataStructures.Syntax",
          "name": "InteractiveStmt",
          "package": "libcspm",
          "source": "src/CSPM-DataStructures-Syntax.html#InteractiveStmt",
          "type": "data"
        },
        "index": {
          "description": "statement in an interactive session",
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "InteractiveStmt",
          "package": "libcspm",
          "partial": "Interactive Stmt",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#t:InteractiveStmt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMatches occur on the left hand side of a function declaration and there\n is one \u003ccode\u003e\u003ca\u003eMatch\u003c/a\u003e\u003c/code\u003e for each clause of the declaration. For example, given the\n declaration:\n\u003c/p\u003e\u003cpre\u003e\n      f(\u003ca/\u003e) = 0\n      f(\u003ca\u003ex\u003c/a\u003e^xs) = 1+f(xs)\n\u003c/pre\u003e\u003cp\u003ethere would be two matches.\n\u003c/p\u003e",
          "module": "CSPM.DataStructures.Syntax",
          "name": "Match",
          "package": "libcspm",
          "source": "src/CSPM-DataStructures-Syntax.html#Match",
          "type": "data"
        },
        "index": {
          "description": "Matches occur on the left hand side of function declaration and there is one Match for each clause of the declaration For example given the declaration xs xs there would be two matches",
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "Match",
          "package": "libcspm",
          "partial": "Match",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#t:Match"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "Model",
          "package": "libcspm",
          "source": "src/CSPM-DataStructures-Syntax.html#Model",
          "type": "data"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "Model",
          "package": "libcspm",
          "partial": "Model",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#t:Model"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "ModelOption",
          "package": "libcspm",
          "source": "src/CSPM-DataStructures-Syntax.html#ModelOption",
          "type": "data"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "ModelOption",
          "package": "libcspm",
          "partial": "Model Option",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#t:ModelOption"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "PAssertion",
          "package": "libcspm",
          "source": "src/CSPM-DataStructures-Syntax.html#PAssertion",
          "type": "type"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "PAssertion",
          "package": "libcspm",
          "partial": "PAssertion",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#t:PAssertion"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "PCSPMFile",
          "package": "libcspm",
          "source": "src/CSPM-DataStructures-Syntax.html#PCSPMFile",
          "type": "type"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "PCSPMFile",
          "package": "libcspm",
          "partial": "PCSPMFile",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#t:PCSPMFile"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "PDataTypeClause",
          "package": "libcspm",
          "source": "src/CSPM-DataStructures-Syntax.html#PDataTypeClause",
          "type": "type"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "PDataTypeClause",
          "package": "libcspm",
          "partial": "PData Type Clause",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#t:PDataTypeClause"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "PDecl",
          "package": "libcspm",
          "source": "src/CSPM-DataStructures-Syntax.html#PDecl",
          "type": "type"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "PDecl",
          "package": "libcspm",
          "partial": "PDecl",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#t:PDecl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "PExp",
          "package": "libcspm",
          "source": "src/CSPM-DataStructures-Syntax.html#PExp",
          "type": "type"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "PExp",
          "package": "libcspm",
          "partial": "PExp",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#t:PExp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "PField",
          "package": "libcspm",
          "source": "src/CSPM-DataStructures-Syntax.html#PField",
          "type": "type"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "PField",
          "package": "libcspm",
          "partial": "PField",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#t:PField"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "PInteractiveStmt",
          "package": "libcspm",
          "source": "src/CSPM-DataStructures-Syntax.html#PInteractiveStmt",
          "type": "type"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "PInteractiveStmt",
          "package": "libcspm",
          "partial": "PInteractive Stmt",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#t:PInteractiveStmt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "PMatch",
          "package": "libcspm",
          "source": "src/CSPM-DataStructures-Syntax.html#PMatch",
          "type": "type"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "PMatch",
          "package": "libcspm",
          "partial": "PMatch",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#t:PMatch"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "PPat",
          "package": "libcspm",
          "source": "src/CSPM-DataStructures-Syntax.html#PPat",
          "type": "type"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "PPat",
          "package": "libcspm",
          "partial": "PPat",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#t:PPat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "PSType",
          "package": "libcspm",
          "source": "src/CSPM-DataStructures-Syntax.html#PSType",
          "type": "type"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "PSType",
          "package": "libcspm",
          "partial": "PSType",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#t:PSType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "PSTypeConstraint",
          "package": "libcspm",
          "source": "src/CSPM-DataStructures-Syntax.html#PSTypeConstraint",
          "type": "type"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "PSTypeConstraint",
          "package": "libcspm",
          "partial": "PSType Constraint",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#t:PSTypeConstraint"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "PSTypeScheme",
          "package": "libcspm",
          "source": "src/CSPM-DataStructures-Syntax.html#PSTypeScheme",
          "type": "type"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "PSTypeScheme",
          "package": "libcspm",
          "partial": "PSType Scheme",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#t:PSTypeScheme"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "PStmt",
          "package": "libcspm",
          "source": "src/CSPM-DataStructures-Syntax.html#PStmt",
          "type": "type"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "PStmt",
          "package": "libcspm",
          "partial": "PStmt",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#t:PStmt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "Pat",
          "package": "libcspm",
          "source": "src/CSPM-DataStructures-Syntax.html#Pat",
          "type": "data"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "Pat",
          "package": "libcspm",
          "partial": "Pat",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#t:Pat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA syntatic type.\n\u003c/p\u003e",
          "module": "CSPM.DataStructures.Syntax",
          "name": "SType",
          "package": "libcspm",
          "source": "src/CSPM-DataStructures-Syntax.html#SType",
          "type": "data"
        },
        "index": {
          "description": "syntatic type",
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "SType",
          "package": "libcspm",
          "partial": "SType",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#t:SType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA syntatic type constraint.\n\u003c/p\u003e",
          "module": "CSPM.DataStructures.Syntax",
          "name": "STypeConstraint",
          "package": "libcspm",
          "source": "src/CSPM-DataStructures-Syntax.html#STypeConstraint",
          "type": "data"
        },
        "index": {
          "description": "syntatic type constraint",
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "STypeConstraint",
          "package": "libcspm",
          "partial": "SType Constraint",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#t:STypeConstraint"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA syntatic type scheme.\n\u003c/p\u003e",
          "module": "CSPM.DataStructures.Syntax",
          "name": "STypeScheme",
          "package": "libcspm",
          "source": "src/CSPM-DataStructures-Syntax.html#STypeScheme",
          "type": "data"
        },
        "index": {
          "description": "syntatic type scheme",
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "STypeScheme",
          "package": "libcspm",
          "partial": "SType Scheme",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#t:STypeScheme"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "SemanticProperty",
          "package": "libcspm",
          "source": "src/CSPM-DataStructures-Syntax.html#SemanticProperty",
          "type": "data"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "SemanticProperty",
          "package": "libcspm",
          "partial": "Semantic Property",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#t:SemanticProperty"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "Stmt",
          "package": "libcspm",
          "source": "src/CSPM-DataStructures-Syntax.html#Stmt",
          "type": "data"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "Stmt",
          "package": "libcspm",
          "partial": "Stmt",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#t:Stmt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "TCAssertion",
          "package": "libcspm",
          "source": "src/CSPM-DataStructures-Syntax.html#TCAssertion",
          "type": "type"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "TCAssertion",
          "package": "libcspm",
          "partial": "TCAssertion",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#t:TCAssertion"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "TCCSPMFile",
          "package": "libcspm",
          "source": "src/CSPM-DataStructures-Syntax.html#TCCSPMFile",
          "type": "type"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "TCCSPMFile",
          "package": "libcspm",
          "partial": "TCCSPMFile",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#t:TCCSPMFile"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "TCDataTypeClause",
          "package": "libcspm",
          "source": "src/CSPM-DataStructures-Syntax.html#TCDataTypeClause",
          "type": "type"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "TCDataTypeClause",
          "package": "libcspm",
          "partial": "TCData Type Clause",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#t:TCDataTypeClause"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "TCDecl",
          "package": "libcspm",
          "source": "src/CSPM-DataStructures-Syntax.html#TCDecl",
          "type": "type"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "TCDecl",
          "package": "libcspm",
          "partial": "TCDecl",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#t:TCDecl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "TCExp",
          "package": "libcspm",
          "source": "src/CSPM-DataStructures-Syntax.html#TCExp",
          "type": "type"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "TCExp",
          "package": "libcspm",
          "partial": "TCExp",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#t:TCExp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "TCField",
          "package": "libcspm",
          "source": "src/CSPM-DataStructures-Syntax.html#TCField",
          "type": "type"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "TCField",
          "package": "libcspm",
          "partial": "TCField",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#t:TCField"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "TCInteractiveStmt",
          "package": "libcspm",
          "source": "src/CSPM-DataStructures-Syntax.html#TCInteractiveStmt",
          "type": "type"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "TCInteractiveStmt",
          "package": "libcspm",
          "partial": "TCInteractive Stmt",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#t:TCInteractiveStmt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "TCMatch",
          "package": "libcspm",
          "source": "src/CSPM-DataStructures-Syntax.html#TCMatch",
          "type": "type"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "TCMatch",
          "package": "libcspm",
          "partial": "TCMatch",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#t:TCMatch"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "TCPat",
          "package": "libcspm",
          "source": "src/CSPM-DataStructures-Syntax.html#TCPat",
          "type": "type"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "TCPat",
          "package": "libcspm",
          "partial": "TCPat",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#t:TCPat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "TCSType",
          "package": "libcspm",
          "source": "src/CSPM-DataStructures-Syntax.html#TCSType",
          "type": "type"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "TCSType",
          "package": "libcspm",
          "partial": "TCSType",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#t:TCSType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "TCSTypeConstraint",
          "package": "libcspm",
          "source": "src/CSPM-DataStructures-Syntax.html#TCSTypeConstraint",
          "type": "type"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "TCSTypeConstraint",
          "package": "libcspm",
          "partial": "TCSType Constraint",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#t:TCSTypeConstraint"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "TCSTypeScheme",
          "package": "libcspm",
          "source": "src/CSPM-DataStructures-Syntax.html#TCSTypeScheme",
          "type": "type"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "TCSTypeScheme",
          "package": "libcspm",
          "partial": "TCSType Scheme",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#t:TCSTypeScheme"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "TCStmt",
          "package": "libcspm",
          "source": "src/CSPM-DataStructures-Syntax.html#TCStmt",
          "type": "type"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "TCStmt",
          "package": "libcspm",
          "partial": "TCStmt",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#t:TCStmt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "UnaryBooleanOp",
          "package": "libcspm",
          "source": "src/CSPM-DataStructures-Syntax.html#UnaryBooleanOp",
          "type": "data"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "UnaryBooleanOp",
          "package": "libcspm",
          "partial": "Unary Boolean Op",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#t:UnaryBooleanOp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "UnaryMathsOp",
          "package": "libcspm",
          "source": "src/CSPM-DataStructures-Syntax.html#UnaryMathsOp",
          "type": "data"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "UnaryMathsOp",
          "package": "libcspm",
          "partial": "Unary Maths Op",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#t:UnaryMathsOp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe negation of an assertion, not currently supported.\n\u003c/p\u003e",
          "module": "CSPM.DataStructures.Syntax",
          "name": "ASNot",
          "package": "libcspm",
          "signature": "ASNot (AnAssertion id)",
          "source": "src/CSPM-DataStructures-Syntax.html#Assertion",
          "type": "function"
        },
        "index": {
          "description": "The negation of an assertion not currently supported",
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "ASNot",
          "package": "libcspm",
          "partial": "ASNot",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:ASNot"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAlphabetised parallel, e.g. \u003ccode\u003eP [A || B] Q\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "CSPM.DataStructures.Syntax",
          "name": "AlphaParallel",
          "package": "libcspm",
          "signature": "AlphaParallel",
          "source": "src/CSPM-DataStructures-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "description": "Alphabetised parallel e.g",
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "AlphaParallel",
          "package": "libcspm",
          "partial": "Alpha Parallel",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:AlphaParallel"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "And",
          "package": "libcspm",
          "signature": "And",
          "source": "src/CSPM-DataStructures-Syntax.html#BinaryBooleanOp",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "And",
          "package": "libcspm",
          "partial": "And",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:And"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFunction application.\n\u003c/p\u003e",
          "module": "CSPM.DataStructures.Syntax",
          "name": "App",
          "package": "libcspm",
          "signature": "App",
          "source": "src/CSPM-DataStructures-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "description": "Function application",
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "App",
          "package": "libcspm",
          "partial": "App",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:App"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn assertion in a file, e.g. \u003ccode\u003eassert P [T= Q\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "CSPM.DataStructures.Syntax",
          "name": "Assert",
          "package": "libcspm",
          "signature": "Assert (AnAssertion id)",
          "source": "src/CSPM-DataStructures-Syntax.html#Decl",
          "type": "function"
        },
        "index": {
          "description": "An assertion in file e.g assert",
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "Assert",
          "package": "libcspm",
          "partial": "Assert",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:Assert"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "Bind",
          "package": "libcspm",
          "signature": "Bind [AnDecl id]",
          "source": "src/CSPM-DataStructures-Syntax.html#InteractiveStmt",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "Bind",
          "normalized": "Bind[AnDecl a]",
          "package": "libcspm",
          "partial": "Bind",
          "signature": "Bind[AnDecl id]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:Bind"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eApplication of a binary boolean operator.\n\u003c/p\u003e",
          "module": "CSPM.DataStructures.Syntax",
          "name": "BooleanBinaryOp",
          "package": "libcspm",
          "signature": "BooleanBinaryOp",
          "source": "src/CSPM-DataStructures-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "description": "Application of binary boolean operator",
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "BooleanBinaryOp",
          "package": "libcspm",
          "partial": "Boolean Binary Op",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:BooleanBinaryOp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eApplication of a unary boolean operator.\n\u003c/p\u003e",
          "module": "CSPM.DataStructures.Syntax",
          "name": "BooleanUnaryOp",
          "package": "libcspm",
          "signature": "BooleanUnaryOp",
          "source": "src/CSPM-DataStructures-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "description": "Application of unary boolean operator",
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "BooleanUnaryOp",
          "package": "libcspm",
          "partial": "Boolean Unary Op",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:BooleanUnaryOp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "CSPMFile",
          "package": "libcspm",
          "signature": "CSPMFile [AnDecl id]",
          "source": "src/CSPM-DataStructures-Syntax.html#CSPMFile",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "CSPMFile",
          "normalized": "CSPMFile[AnDecl a]",
          "package": "libcspm",
          "partial": "CSPMFile",
          "signature": "CSPMFile[AnDecl id]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:CSPMFile"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA channel declaration, e.g. \u003ccode\u003echannel c, d : {0..1}.{0..1}\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "CSPM.DataStructures.Syntax",
          "name": "Channel",
          "package": "libcspm",
          "signature": "Channel [id] (Maybe (AnExp id))",
          "source": "src/CSPM-DataStructures-Syntax.html#Decl",
          "type": "function"
        },
        "index": {
          "description": "channel declaration e.g channel",
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "Channel",
          "normalized": "Channel[a](Maybe(AnExp a))",
          "package": "libcspm",
          "partial": "Channel",
          "signature": "Channel[id](Maybe(AnExp id))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:Channel"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eList concatenation, e.g. \u003ccode\u003ex^y\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "CSPM.DataStructures.Syntax",
          "name": "Concat",
          "package": "libcspm",
          "signature": "Concat",
          "source": "src/CSPM-DataStructures-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "description": "List concatenation e.g",
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "Concat",
          "package": "libcspm",
          "partial": "Concat",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:Concat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA datatype declaration, e.g. \u003ccode\u003edatatype T = Clause1 | Clause2\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "CSPM.DataStructures.Syntax",
          "name": "DataType",
          "package": "libcspm",
          "signature": "DataType id [AnDataTypeClause id]",
          "source": "src/CSPM-DataStructures-Syntax.html#Decl",
          "type": "function"
        },
        "index": {
          "description": "datatype declaration e.g datatype Clause1 Clause2",
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "DataType",
          "normalized": "DataType a[AnDataTypeClause a]",
          "package": "libcspm",
          "partial": "Data Type",
          "signature": "DataType id[AnDataTypeClause id]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:DataType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "DataTypeClause",
          "package": "libcspm",
          "signature": "DataTypeClause",
          "source": "src/CSPM-DataStructures-Syntax.html#DataTypeClause",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "DataTypeClause",
          "package": "libcspm",
          "partial": "Data Type Clause",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:DataTypeClause"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "DeadlockFreedom",
          "package": "libcspm",
          "signature": "DeadlockFreedom",
          "source": "src/CSPM-DataStructures-Syntax.html#SemanticProperty",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "DeadlockFreedom",
          "package": "libcspm",
          "partial": "Deadlock Freedom",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:DeadlockFreedom"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "Deterministic",
          "package": "libcspm",
          "signature": "Deterministic",
          "source": "src/CSPM-DataStructures-Syntax.html#SemanticProperty",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "Deterministic",
          "package": "libcspm",
          "partial": "Deterministic",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:Deterministic"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "Divide",
          "package": "libcspm",
          "signature": "Divide",
          "source": "src/CSPM-DataStructures-Syntax.html#BinaryMathsOp",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "Divide",
          "package": "libcspm",
          "partial": "Divide",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:Divide"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDot operator application, e.g. \u003ccode\u003ec.x\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "CSPM.DataStructures.Syntax",
          "name": "DotApp",
          "package": "libcspm",
          "signature": "DotApp",
          "source": "src/CSPM-DataStructures-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "description": "Dot operator application e.g c.x",
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "DotApp",
          "package": "libcspm",
          "partial": "Dot App",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:DotApp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "Equals",
          "package": "libcspm",
          "signature": "Equals",
          "source": "src/CSPM-DataStructures-Syntax.html#BinaryBooleanOp",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "Equals",
          "package": "libcspm",
          "partial": "Equals",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:Equals"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "Evaluate",
          "package": "libcspm",
          "signature": "Evaluate (AnExp id)",
          "source": "src/CSPM-DataStructures-Syntax.html#InteractiveStmt",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "Evaluate",
          "package": "libcspm",
          "partial": "Evaluate",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:Evaluate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eException operator, e.g. \u003ccode\u003eP [| A |\u003e Q\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "CSPM.DataStructures.Syntax",
          "name": "Exception",
          "package": "libcspm",
          "signature": "Exception",
          "source": "src/CSPM-DataStructures-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "description": "Exception operator e.g",
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "Exception",
          "package": "libcspm",
          "partial": "Exception",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:Exception"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUsed only for parsing - never appears in an AST.\n\u003c/p\u003e",
          "module": "CSPM.DataStructures.Syntax",
          "name": "ExpPatDoublePattern",
          "package": "libcspm",
          "signature": "ExpPatDoublePattern (AnExp id) (AnExp id)",
          "source": "src/CSPM-DataStructures-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "description": "Used only for parsing never appears in an AST",
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "ExpPatDoublePattern",
          "package": "libcspm",
          "partial": "Exp Pat Double Pattern",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:ExpPatDoublePattern"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUsed only for parsing - never appears in an AST.\n\u003c/p\u003e",
          "module": "CSPM.DataStructures.Syntax",
          "name": "ExpPatWildCard",
          "package": "libcspm",
          "signature": "ExpPatWildCard",
          "source": "src/CSPM-DataStructures-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "description": "Used only for parsing never appears in an AST",
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "ExpPatWildCard",
          "package": "libcspm",
          "partial": "Exp Pat Wild Card",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:ExpPatWildCard"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn import of an external function, e.g. \u003ccode\u003eexternal test\u003c/code\u003e,\n\u003c/p\u003e",
          "module": "CSPM.DataStructures.Syntax",
          "name": "External",
          "package": "libcspm",
          "signature": "External",
          "source": "src/CSPM-DataStructures-Syntax.html#Decl",
          "type": "function"
        },
        "index": {
          "description": "An import of an external function e.g external test",
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "External",
          "package": "libcspm",
          "partial": "External",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:External"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExternal choice, e.g. \u003ccode\u003eP [] Q\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "CSPM.DataStructures.Syntax",
          "name": "ExternalChoice",
          "package": "libcspm",
          "signature": "ExternalChoice",
          "source": "src/CSPM-DataStructures-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "description": "External choice e.g",
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "ExternalChoice",
          "package": "libcspm",
          "partial": "External Choice",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:ExternalChoice"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"CSPM.DataStructures.Syntax\",\"CSPM.Parser.Tokens\"]",
          "name": "Failures",
          "package": "libcspm",
          "signature": "Failures",
          "source": "src/CSPM-DataStructures-Syntax.html#Model",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:Failures\",\"http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Tokens.html#v:Failures\"]"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "Failures",
          "package": "libcspm",
          "partial": "Failures",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:Failures"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"CSPM.DataStructures.Syntax\",\"CSPM.Parser.Tokens\"]",
          "name": "FailuresDivergences",
          "package": "libcspm",
          "signature": "FailuresDivergences",
          "source": "src/CSPM-DataStructures-Syntax.html#Model",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:FailuresDivergences\",\"http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Tokens.html#v:FailuresDivergences\"]"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "FailuresDivergences",
          "package": "libcspm",
          "partial": "Failures Divergences",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:FailuresDivergences"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA function binding, e.g. \u003ccode\u003efunc(x,y)(z) = 0\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "CSPM.DataStructures.Syntax",
          "name": "FunBind",
          "package": "libcspm",
          "signature": "FunBind id [AnMatch id] (Maybe (AnSTypeScheme id))",
          "source": "src/CSPM-DataStructures-Syntax.html#Decl",
          "type": "function"
        },
        "index": {
          "description": "function binding e.g func",
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "FunBind",
          "normalized": "FunBind a[AnMatch a](Maybe(AnSTypeScheme a))",
          "package": "libcspm",
          "partial": "Fun Bind",
          "signature": "FunBind id[AnMatch id](Maybe(AnSTypeScheme id))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:FunBind"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGeneralised parallel, e.g. \u003ccode\u003eP [| A |] Q\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "CSPM.DataStructures.Syntax",
          "name": "GenParallel",
          "package": "libcspm",
          "signature": "GenParallel",
          "source": "src/CSPM-DataStructures-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "description": "Generalised parallel e.g",
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "GenParallel",
          "package": "libcspm",
          "partial": "Gen Parallel",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:GenParallel"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "Generator",
          "package": "libcspm",
          "signature": "Generator (AnPat id) (AnExp id)",
          "source": "src/CSPM-DataStructures-Syntax.html#Stmt",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "Generator",
          "package": "libcspm",
          "partial": "Generator",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:Generator"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "GreaterThan",
          "package": "libcspm",
          "signature": "GreaterThan",
          "source": "src/CSPM-DataStructures-Syntax.html#BinaryBooleanOp",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "GreaterThan",
          "package": "libcspm",
          "partial": "Greater Than",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:GreaterThan"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "GreaterThanEq",
          "package": "libcspm",
          "signature": "GreaterThanEq",
          "source": "src/CSPM-DataStructures-Syntax.html#BinaryBooleanOp",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "GreaterThanEq",
          "package": "libcspm",
          "partial": "Greater Than Eq",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:GreaterThanEq"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGuarded expressions, e.g. \u003ccode\u003eb & P\u003c/code\u003e where \u003ccode\u003eb\u003c/code\u003e is a boolean expression.\n This is equivalent to \u003ccode\u003eif b then P else STOP\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "CSPM.DataStructures.Syntax",
          "name": "GuardedExp",
          "package": "libcspm",
          "signature": "GuardedExp",
          "source": "src/CSPM-DataStructures-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "description": "Guarded expressions e.g where is boolean expression This is equivalent to if then else STOP",
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "GuardedExp",
          "package": "libcspm",
          "partial": "Guarded Exp",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:GuardedExp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eHiding of events, e.g. \u003ccode\u003eP  A\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "CSPM.DataStructures.Syntax",
          "name": "Hiding",
          "package": "libcspm",
          "signature": "Hiding",
          "source": "src/CSPM-DataStructures-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "description": "Hiding of events e.g",
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "Hiding",
          "package": "libcspm",
          "partial": "Hiding",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:Hiding"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIf statements, e.g. \u003ccode\u003eif cond then e1 else e2\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "CSPM.DataStructures.Syntax",
          "name": "If",
          "package": "libcspm",
          "signature": "If",
          "source": "src/CSPM-DataStructures-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "description": "If statements e.g if cond then e1 else e2",
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "If",
          "package": "libcspm",
          "partial": "If",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:If"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cpre\u003e?x:A\u003c/pre\u003e",
          "module": "CSPM.DataStructures.Syntax",
          "name": "Input",
          "package": "libcspm",
          "signature": "Input (AnPat id) (Maybe (AnExp id))",
          "source": "src/CSPM-DataStructures-Syntax.html#Field",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "Input",
          "package": "libcspm",
          "partial": "Input",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:Input"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInterleaving of processes, e.g. \u003ccode\u003eP ||| Q\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "CSPM.DataStructures.Syntax",
          "name": "Interleave",
          "package": "libcspm",
          "signature": "Interleave",
          "source": "src/CSPM-DataStructures-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "description": "Interleaving of processes e.g",
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "Interleave",
          "package": "libcspm",
          "partial": "Interleave",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:Interleave"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInternal choice, e.g. \u003ccode\u003eP |~| Q\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "CSPM.DataStructures.Syntax",
          "name": "InternalChoice",
          "package": "libcspm",
          "signature": "InternalChoice",
          "source": "src/CSPM-DataStructures-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "description": "Internal choice e.g",
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "InternalChoice",
          "package": "libcspm",
          "partial": "Internal Choice",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:InternalChoice"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInterrupt (where the left process is turned off once the right process\n performs an event), e.g. \u003ccode\u003eP / Q\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "CSPM.DataStructures.Syntax",
          "name": "Interrupt",
          "package": "libcspm",
          "signature": "Interrupt",
          "source": "src/CSPM-DataStructures-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "description": "Interrupt where the left process is turned off once the right process performs an event e.g",
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "Interrupt",
          "package": "libcspm",
          "partial": "Interrupt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:Interrupt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLambda functions, e.g. \u003ccode\u003e(x,y) @ e(x,y)\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "CSPM.DataStructures.Syntax",
          "name": "Lambda",
          "package": "libcspm",
          "signature": "Lambda",
          "source": "src/CSPM-DataStructures-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "description": "Lambda functions e.g",
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "Lambda",
          "package": "libcspm",
          "partial": "Lambda",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:Lambda"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "LessThan",
          "package": "libcspm",
          "signature": "LessThan",
          "source": "src/CSPM-DataStructures-Syntax.html#BinaryBooleanOp",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "LessThan",
          "package": "libcspm",
          "partial": "Less Than",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:LessThan"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "LessThanEq",
          "package": "libcspm",
          "signature": "LessThanEq",
          "source": "src/CSPM-DataStructures-Syntax.html#BinaryBooleanOp",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "LessThanEq",
          "package": "libcspm",
          "partial": "Less Than Eq",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:LessThanEq"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLet declarations, e.g. \u003ccode\u003elet func = e1 within e2\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "CSPM.DataStructures.Syntax",
          "name": "Let",
          "package": "libcspm",
          "signature": "Let",
          "source": "src/CSPM-DataStructures-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "description": "Let declarations e.g let func e1 within e2",
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "Let",
          "package": "libcspm",
          "partial": "Let",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:Let"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "LinkParallel",
          "package": "libcspm",
          "signature": "LinkParallel",
          "source": "src/CSPM-DataStructures-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "LinkParallel",
          "package": "libcspm",
          "partial": "Link Parallel",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:LinkParallel"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eList literals, e.g. \u003ccode\u003e\u003ca\u003e1,2,3\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "CSPM.DataStructures.Syntax",
          "name": "List",
          "package": "libcspm",
          "signature": "List",
          "source": "src/CSPM-DataStructures-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "description": "List literals e.g",
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "List",
          "package": "libcspm",
          "partial": "List",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:List"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eList comprehensions, e.g. \u003ccode\u003e\u003ca\u003e| (x,y) \u003c- e\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "CSPM.DataStructures.Syntax",
          "name": "ListComp",
          "package": "libcspm",
          "signature": "ListComp",
          "source": "src/CSPM-DataStructures-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "description": "List comprehensions e.g",
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "ListComp",
          "package": "libcspm",
          "partial": "List Comp",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:ListComp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInfinite list of integers from the given value, e.g. \u003ccode\u003e\u003ca\u003e1..\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "CSPM.DataStructures.Syntax",
          "name": "ListEnumFrom",
          "package": "libcspm",
          "signature": "ListEnumFrom",
          "source": "src/CSPM-DataStructures-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "description": "Infinite list of integers from the given value e.g",
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "ListEnumFrom",
          "package": "libcspm",
          "partial": "List Enum From",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:ListEnumFrom"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eList of integers from the given value, concatenating all adjacent\n lists, e.g. \u003ccode\u003e\u003ca\u003e| x \u003c- \u003c0\u003c/a\u003e\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "CSPM.DataStructures.Syntax",
          "name": "ListEnumFromComp",
          "package": "libcspm",
          "signature": "ListEnumFromComp",
          "source": "src/CSPM-DataStructures-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "description": "List of integers from the given value concatenating all adjacent lists e.g",
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "ListEnumFromComp",
          "package": "libcspm",
          "partial": "List Enum From Comp",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:ListEnumFromComp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eBounded list of integers between the given values, e.g. \u003ccode\u003e\u003ca\u003e1..3\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "CSPM.DataStructures.Syntax",
          "name": "ListEnumFromTo",
          "package": "libcspm",
          "signature": "ListEnumFromTo",
          "source": "src/CSPM-DataStructures-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "description": "Bounded list of integers between the given values e.g",
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "ListEnumFromTo",
          "package": "libcspm",
          "partial": "List Enum From To",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:ListEnumFromTo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eList of integers between the given values, concatenating all items into\n one list, e.g. \u003ccode\u003e\u003ca\u003e| (x,y) \u003c- \u003c(0,1)\u003c/a\u003e\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "CSPM.DataStructures.Syntax",
          "name": "ListEnumFromToComp",
          "package": "libcspm",
          "signature": "ListEnumFromToComp",
          "source": "src/CSPM-DataStructures-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "description": "List of integers between the given values concatenating all items into one list e.g",
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "ListEnumFromToComp",
          "package": "libcspm",
          "partial": "List Enum From To Comp",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:ListEnumFromToComp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe length of the list, e.g. \u003ccode\u003e#list\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "CSPM.DataStructures.Syntax",
          "name": "ListLength",
          "package": "libcspm",
          "signature": "ListLength",
          "source": "src/CSPM-DataStructures-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "description": "The length of the list e.g list",
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "ListLength",
          "package": "libcspm",
          "partial": "List Length",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:ListLength"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLiterals, e.g. \u003ccode\u003etrue\u003c/code\u003e or \u003ccode\u003e1\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "CSPM.DataStructures.Syntax",
          "name": "Lit",
          "package": "libcspm",
          "signature": "Lit",
          "source": "src/CSPM-DataStructures-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "description": "Literals e.g true or",
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "Lit",
          "package": "libcspm",
          "partial": "Lit",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:Lit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "LivelockFreedom",
          "package": "libcspm",
          "signature": "LivelockFreedom",
          "source": "src/CSPM-DataStructures-Syntax.html#SemanticProperty",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "LivelockFreedom",
          "package": "libcspm",
          "partial": "Livelock Freedom",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:LivelockFreedom"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA literal map, e.g. \u003ccode\u003e(| 1 =\u003e 2 |)\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "CSPM.DataStructures.Syntax",
          "name": "Map",
          "package": "libcspm",
          "signature": "Map",
          "source": "src/CSPM-DataStructures-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "description": "literal map e.g",
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "Map",
          "package": "libcspm",
          "partial": "Map",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:Map"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "Match",
          "package": "libcspm",
          "signature": "Match",
          "source": "src/CSPM-DataStructures-Syntax.html#Match",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "Match",
          "package": "libcspm",
          "partial": "Match",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:Match"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eApplication of binary maths operator, e.g. \u003ccode\u003ex+y\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "CSPM.DataStructures.Syntax",
          "name": "MathsBinaryOp",
          "package": "libcspm",
          "signature": "MathsBinaryOp",
          "source": "src/CSPM-DataStructures-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "description": "Application of binary maths operator e.g",
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "MathsBinaryOp",
          "package": "libcspm",
          "partial": "Maths Binary Op",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:MathsBinaryOp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eApplication of unary maths operator, e.g. \u003ccode\u003e-x\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "CSPM.DataStructures.Syntax",
          "name": "MathsUnaryOp",
          "package": "libcspm",
          "signature": "MathsUnaryOp",
          "source": "src/CSPM-DataStructures-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "description": "Application of unary maths operator e.g",
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "MathsUnaryOp",
          "package": "libcspm",
          "partial": "Maths Unary Op",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:MathsUnaryOp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "Minus",
          "package": "libcspm",
          "signature": "Minus",
          "source": "src/CSPM-DataStructures-Syntax.html#BinaryMathsOp",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "Minus",
          "package": "libcspm",
          "partial": "Minus",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:Minus"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "Mod",
          "package": "libcspm",
          "signature": "Mod",
          "source": "src/CSPM-DataStructures-Syntax.html#BinaryMathsOp",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "Mod",
          "package": "libcspm",
          "partial": "Mod",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:Mod"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA module declaration, e.g. \u003ccode\u003emodule X(Y,Z) ... export ... endmodule\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "CSPM.DataStructures.Syntax",
          "name": "Module",
          "package": "libcspm",
          "signature": "Module",
          "source": "src/CSPM-DataStructures-Syntax.html#Decl",
          "type": "function"
        },
        "index": {
          "description": "module declaration e.g module export endmodule",
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "Module",
          "package": "libcspm",
          "partial": "Module",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:Module"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "ModuleInstance",
          "package": "libcspm",
          "signature": "ModuleInstance",
          "source": "src/CSPM-DataStructures-Syntax.html#Decl",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "ModuleInstance",
          "package": "libcspm",
          "partial": "Module Instance",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:ModuleInstance"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA nametype declaration, e.g. \u003ccode\u003enametype T2 = T.T\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "CSPM.DataStructures.Syntax",
          "name": "NameType",
          "package": "libcspm",
          "signature": "NameType id (AnExp id)",
          "source": "src/CSPM-DataStructures-Syntax.html#Decl",
          "type": "function"
        },
        "index": {
          "description": "nametype declaration e.g nametype T2 T.T",
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "NameType",
          "package": "libcspm",
          "partial": "Name Type",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:NameType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "Negate",
          "package": "libcspm",
          "signature": "Negate",
          "source": "src/CSPM-DataStructures-Syntax.html#UnaryMathsOp",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "Negate",
          "package": "libcspm",
          "partial": "Negate",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:Negate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e$x:A\u003c/code\u003e (see P395 UCS)\n\u003c/p\u003e",
          "module": "CSPM.DataStructures.Syntax",
          "name": "NonDetInput",
          "package": "libcspm",
          "signature": "NonDetInput (AnPat id) (Maybe (AnExp id))",
          "source": "src/CSPM-DataStructures-Syntax.html#Field",
          "type": "function"
        },
        "index": {
          "description": "see P395 UCS",
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "NonDetInput",
          "package": "libcspm",
          "partial": "Non Det Input",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:NonDetInput"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "Not",
          "package": "libcspm",
          "signature": "Not",
          "source": "src/CSPM-DataStructures-Syntax.html#UnaryBooleanOp",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "Not",
          "package": "libcspm",
          "partial": "Not",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:Not"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "NotEquals",
          "package": "libcspm",
          "signature": "NotEquals",
          "source": "src/CSPM-DataStructures-Syntax.html#BinaryBooleanOp",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "NotEquals",
          "package": "libcspm",
          "partial": "Not Equals",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:NotEquals"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "Or",
          "package": "libcspm",
          "signature": "Or",
          "source": "src/CSPM-DataStructures-Syntax.html#BinaryBooleanOp",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "Or",
          "package": "libcspm",
          "partial": "Or",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:Or"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cpre\u003e!x\u003c/pre\u003e",
          "module": "CSPM.DataStructures.Syntax",
          "name": "Output",
          "package": "libcspm",
          "signature": "Output (AnExp id)",
          "source": "src/CSPM-DataStructures-Syntax.html#Field",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "Output",
          "package": "libcspm",
          "partial": "Output",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:Output"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLike with a \u003ccode\u003e\u003ca\u003ePCompList\u003c/a\u003e\u003c/code\u003e we flatten nested dot patterns to make it\n easier to evaluate.\n\u003c/p\u003e",
          "module": "CSPM.DataStructures.Syntax",
          "name": "PCompDot",
          "package": "libcspm",
          "signature": "PCompDot",
          "source": "src/CSPM-DataStructures-Syntax.html#Pat",
          "type": "function"
        },
        "index": {
          "description": "Like with PCompList we flatten nested dot patterns to make it easier to evaluate",
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "PCompDot",
          "package": "libcspm",
          "partial": "PComp Dot",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:PCompDot"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSince you can write list patterns such as:\n\u003c/p\u003e\u003cpre\u003e f(\u003cx,y\u003e^xs^\u003cz,p\u003e^\u003c9,0\u003e)\n f(\u003cx,y\u003e)\n f(xs^\u003cx,y\u003e)\n\u003c/pre\u003e\u003cp\u003ewe need an easy may of matching them. Thus, we compile\n the patterns to a \u003ccode\u003ePCompList\u003c/code\u003e instead.\n\u003c/p\u003e\u003cp\u003e\u003ccode\u003ePCompList ps (Just (p, ps'))\u003c/code\u003e corresponds to a list\n where it starts with ps (where each p in ps matches exactly one\n list element, has a middle of p (which must be a variable pattern, \n or a wildcard) and and end matching exactly ps' (again, where each p\n in ps matches exactly one list component).\n\u003c/p\u003e",
          "module": "CSPM.DataStructures.Syntax",
          "name": "PCompList",
          "package": "libcspm",
          "signature": "PCompList",
          "source": "src/CSPM-DataStructures-Syntax.html#Pat",
          "type": "function"
        },
        "index": {
          "description": "Since you can write list patterns such as xs xs we need an easy may of matching them Thus we compile the patterns to PCompList instead PCompList ps Just ps corresponds to list where it starts with ps where each in ps matches exactly one list element has middle of which must be variable pattern or wildcard and and end matching exactly ps again where each in ps matches exactly one list component",
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "PCompList",
          "package": "libcspm",
          "partial": "PComp List",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:PCompList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe concatenation of two patterns, e.g. \u003ccode\u003ep1^p2\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "CSPM.DataStructures.Syntax",
          "name": "PConcat",
          "package": "libcspm",
          "signature": "PConcat",
          "source": "src/CSPM-DataStructures-Syntax.html#Pat",
          "type": "function"
        },
        "index": {
          "description": "The concatenation of two patterns e.g p1 p2",
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "PConcat",
          "package": "libcspm",
          "partial": "PConcat",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:PConcat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe dot of two patterns, e.g. \u003ccode\u003ep1.p2\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "CSPM.DataStructures.Syntax",
          "name": "PDotApp",
          "package": "libcspm",
          "signature": "PDotApp",
          "source": "src/CSPM-DataStructures-Syntax.html#Pat",
          "type": "function"
        },
        "index": {
          "description": "The dot of two patterns e.g p1.p2",
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "PDotApp",
          "package": "libcspm",
          "partial": "PDot App",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:PDotApp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA double pattern match, e.g. \u003ccode\u003ep1@@p2\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "CSPM.DataStructures.Syntax",
          "name": "PDoublePattern",
          "package": "libcspm",
          "signature": "PDoublePattern",
          "source": "src/CSPM-DataStructures-Syntax.html#Pat",
          "type": "function"
        },
        "index": {
          "description": "double pattern match e.g p1@@p2",
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "PDoublePattern",
          "package": "libcspm",
          "partial": "PDouble Pattern",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:PDoublePattern"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA literal pattern list, e.g. \u003ccode\u003e\u003ca\u003ep1,p2,p3\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "CSPM.DataStructures.Syntax",
          "name": "PList",
          "package": "libcspm",
          "signature": "PList",
          "source": "src/CSPM-DataStructures-Syntax.html#Pat",
          "type": "function"
        },
        "index": {
          "description": "literal pattern list e.g p1 p2 p3",
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "PList",
          "package": "libcspm",
          "partial": "PList",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:PList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA literal pattern, e.g. \u003ccode\u003etrue\u003c/code\u003e, or \u003ccode\u003e0\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "CSPM.DataStructures.Syntax",
          "name": "PLit",
          "package": "libcspm",
          "signature": "PLit",
          "source": "src/CSPM-DataStructures-Syntax.html#Pat",
          "type": "function"
        },
        "index": {
          "description": "literal pattern e.g true or",
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "PLit",
          "package": "libcspm",
          "partial": "PLit",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:PLit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA user supplied parenthesis in a pattern.\n\u003c/p\u003e",
          "module": "CSPM.DataStructures.Syntax",
          "name": "PParen",
          "package": "libcspm",
          "signature": "PParen",
          "source": "src/CSPM-DataStructures-Syntax.html#Pat",
          "type": "function"
        },
        "index": {
          "description": "user supplied parenthesis in pattern",
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "PParen",
          "package": "libcspm",
          "partial": "PParen",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:PParen"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA set pattern. Only singleton patterns, or zero patterns are supported.\n This is checked by the desugarer. For example, \u003ccode\u003e{p1,p2}\u003c/code\u003e is not allowed,\n but \u003ccode\u003e{p1}\u003c/code\u003e and \u003ccode\u003e{}\u003c/code\u003e are allowed.\n\u003c/p\u003e",
          "module": "CSPM.DataStructures.Syntax",
          "name": "PSet",
          "package": "libcspm",
          "signature": "PSet",
          "source": "src/CSPM-DataStructures-Syntax.html#Pat",
          "type": "function"
        },
        "index": {
          "description": "set pattern Only singleton patterns or zero patterns are supported This is checked by the desugarer For example p1 p2 is not allowed but p1 and are allowed",
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "PSet",
          "package": "libcspm",
          "partial": "PSet",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:PSet"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA tuple pattern, e.g. \u003ccode\u003e(p1,p2,p3)\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "CSPM.DataStructures.Syntax",
          "name": "PTuple",
          "package": "libcspm",
          "signature": "PTuple",
          "source": "src/CSPM-DataStructures-Syntax.html#Pat",
          "type": "function"
        },
        "index": {
          "description": "tuple pattern e.g p1 p2 p3",
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "PTuple",
          "package": "libcspm",
          "partial": "PTuple",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:PTuple"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA variable pattern, e.g. \u003ccode\u003ex\u003c/code\u003e, or \u003ccode\u003eA\u003c/code\u003e where \u003ccode\u003eA\u003c/code\u003e is a datatype clause. \n If the variable is a datatype clause then it only matches that datatype\n tag, whereas for anything else it matches anything.\n\u003c/p\u003e",
          "module": "CSPM.DataStructures.Syntax",
          "name": "PVar",
          "package": "libcspm",
          "signature": "PVar",
          "source": "src/CSPM-DataStructures-Syntax.html#Pat",
          "type": "function"
        },
        "index": {
          "description": "variable pattern e.g or where is datatype clause If the variable is datatype clause then it only matches that datatype tag whereas for anything else it matches anything",
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "PVar",
          "package": "libcspm",
          "partial": "PVar",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:PVar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMatches anything but does not bind it.\n\u003c/p\u003e",
          "module": "CSPM.DataStructures.Syntax",
          "name": "PWildCard",
          "package": "libcspm",
          "signature": "PWildCard",
          "source": "src/CSPM-DataStructures-Syntax.html#Pat",
          "type": "function"
        },
        "index": {
          "description": "Matches anything but does not bind it",
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "PWildCard",
          "package": "libcspm",
          "partial": "PWild Card",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:PWildCard"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA user provided bracket, e.g. \u003ccode\u003e(e)\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "CSPM.DataStructures.Syntax",
          "name": "Paren",
          "package": "libcspm",
          "signature": "Paren",
          "source": "src/CSPM-DataStructures-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "description": "user provided bracket e.g",
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "Paren",
          "package": "libcspm",
          "partial": "Paren",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:Paren"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA type annotation for the given names. This is only used inside the\n parser and never appears in outside ASTs.\n\u003c/p\u003e",
          "module": "CSPM.DataStructures.Syntax",
          "name": "ParsedTypeAnnotation",
          "package": "libcspm",
          "signature": "ParsedTypeAnnotation [id] (AnSTypeScheme id)",
          "source": "src/CSPM-DataStructures-Syntax.html#Decl",
          "type": "function"
        },
        "index": {
          "description": "type annotation for the given names This is only used inside the parser and never appears in outside ASTs",
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "ParsedTypeAnnotation",
          "normalized": "ParsedTypeAnnotation[a](AnSTypeScheme a)",
          "package": "libcspm",
          "partial": "Parsed Type Annotation",
          "signature": "ParsedTypeAnnotation[id](AnSTypeScheme id)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:ParsedTypeAnnotation"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe binding of a pattern to an expression, e.g. \u003ccode\u003e(p,q) = e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "CSPM.DataStructures.Syntax",
          "name": "PatBind",
          "package": "libcspm",
          "signature": "PatBind (AnPat id) (AnExp id) (Maybe (AnSTypeScheme id))",
          "source": "src/CSPM-DataStructures-Syntax.html#Decl",
          "type": "function"
        },
        "index": {
          "description": "The binding of pattern to an expression e.g",
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "PatBind",
          "package": "libcspm",
          "partial": "Pat Bind",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:PatBind"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "Plus",
          "package": "libcspm",
          "signature": "Plus",
          "source": "src/CSPM-DataStructures-Syntax.html#BinaryMathsOp",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "Plus",
          "package": "libcspm",
          "partial": "Plus",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:Plus"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEvent prefixing, e.g. \u003ccode\u003ec$x?y!z -\u003e P\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "CSPM.DataStructures.Syntax",
          "name": "Prefix",
          "package": "libcspm",
          "signature": "Prefix",
          "source": "src/CSPM-DataStructures-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "description": "Event prefixing e.g",
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "Prefix",
          "package": "libcspm",
          "partial": "Prefix",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:Prefix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA print statement, e.g. \u003ccode\u003eprint x\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "CSPM.DataStructures.Syntax",
          "name": "PrintStatement",
          "package": "libcspm",
          "signature": "PrintStatement",
          "source": "src/CSPM-DataStructures-Syntax.html#Decl",
          "type": "function"
        },
        "index": {
          "description": "print statement e.g print",
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "PrintStatement",
          "package": "libcspm",
          "partial": "Print Statement",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:PrintStatement"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA check of property, like deadlock freedom, e.g. \n \u003ccode\u003eassert P :[deadlock free [F]]\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "CSPM.DataStructures.Syntax",
          "name": "PropertyCheck",
          "package": "libcspm",
          "signature": "PropertyCheck",
          "source": "src/CSPM-DataStructures-Syntax.html#Assertion",
          "type": "function"
        },
        "index": {
          "description": "check of property like deadlock freedom e.g assert deadlock free",
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "PropertyCheck",
          "package": "libcspm",
          "partial": "Property Check",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:PropertyCheck"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "Qualifier",
          "package": "libcspm",
          "signature": "Qualifier (AnExp id)",
          "source": "src/CSPM-DataStructures-Syntax.html#Stmt",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "Qualifier",
          "package": "libcspm",
          "partial": "Qualifier",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:Qualifier"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA refinement assertion, e.g. \u003ccode\u003eassert P [F= Q\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "CSPM.DataStructures.Syntax",
          "name": "Refinement",
          "package": "libcspm",
          "signature": "Refinement",
          "source": "src/CSPM-DataStructures-Syntax.html#Assertion",
          "type": "function"
        },
        "index": {
          "description": "refinement assertion e.g assert",
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "Refinement",
          "package": "libcspm",
          "partial": "Refinement",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:Refinement"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"CSPM.DataStructures.Syntax\",\"CSPM.Parser.Tokens\"]",
          "name": "Refusals",
          "package": "libcspm",
          "signature": "Refusals",
          "source": "src/CSPM-DataStructures-Syntax.html#Model",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:Refusals\",\"http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Tokens.html#v:Refusals\"]"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "Refusals",
          "package": "libcspm",
          "partial": "Refusals",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:Refusals"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"CSPM.DataStructures.Syntax\",\"CSPM.Parser.Tokens\"]",
          "name": "RefusalsDivergences",
          "package": "libcspm",
          "signature": "RefusalsDivergences",
          "source": "src/CSPM-DataStructures-Syntax.html#Model",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:RefusalsDivergences\",\"http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Tokens.html#v:RefusalsDivergences\"]"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "RefusalsDivergences",
          "package": "libcspm",
          "partial": "Refusals Divergences",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:RefusalsDivergences"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEvent renaming, e.g. \u003ccode\u003eP [[ a.x \u003c- b.x | x \u003c- X ]]\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "CSPM.DataStructures.Syntax",
          "name": "Rename",
          "package": "libcspm",
          "signature": "Rename",
          "source": "src/CSPM-DataStructures-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "description": "Event renaming e.g a.x b.x",
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "Rename",
          "package": "libcspm",
          "partial": "Rename",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:Rename"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReplicated alphabetised parallel, e.g. \u003ccode\u003e|| x : X @ [| A(x) |] P(x)\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "CSPM.DataStructures.Syntax",
          "name": "ReplicatedAlphaParallel",
          "package": "libcspm",
          "signature": "ReplicatedAlphaParallel",
          "source": "src/CSPM-DataStructures-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "description": "Replicated alphabetised parallel e.g",
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "ReplicatedAlphaParallel",
          "package": "libcspm",
          "partial": "Replicated Alpha Parallel",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:ReplicatedAlphaParallel"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReplicated external choice, e.g. \u003ccode\u003e[] x : X @ P(x)\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "CSPM.DataStructures.Syntax",
          "name": "ReplicatedExternalChoice",
          "package": "libcspm",
          "signature": "ReplicatedExternalChoice",
          "source": "src/CSPM-DataStructures-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "description": "Replicated external choice e.g",
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "ReplicatedExternalChoice",
          "package": "libcspm",
          "partial": "Replicated External Choice",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:ReplicatedExternalChoice"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReplicated interleave, e.g. \u003ccode\u003e||| x : X @ P(x)\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "CSPM.DataStructures.Syntax",
          "name": "ReplicatedInterleave",
          "package": "libcspm",
          "signature": "ReplicatedInterleave",
          "source": "src/CSPM-DataStructures-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "description": "Replicated interleave e.g",
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "ReplicatedInterleave",
          "package": "libcspm",
          "partial": "Replicated Interleave",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:ReplicatedInterleave"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReplicated internal choice, e.g. \u003ccode\u003e|~| x : X @ P(x)\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "CSPM.DataStructures.Syntax",
          "name": "ReplicatedInternalChoice",
          "package": "libcspm",
          "signature": "ReplicatedInternalChoice",
          "source": "src/CSPM-DataStructures-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "description": "Replicated internal choice e.g",
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "ReplicatedInternalChoice",
          "package": "libcspm",
          "partial": "Replicated Internal Choice",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:ReplicatedInternalChoice"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReplicated link parallel, e.g. \n \u003ccode\u003e[a.x \u003c- b.x | x \u003c- X(y)] y : Y @ P(y)\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "CSPM.DataStructures.Syntax",
          "name": "ReplicatedLinkParallel",
          "package": "libcspm",
          "signature": "ReplicatedLinkParallel",
          "source": "src/CSPM-DataStructures-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "description": "Replicated link parallel e.g a.x b.x",
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "ReplicatedLinkParallel",
          "package": "libcspm",
          "partial": "Replicated Link Parallel",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:ReplicatedLinkParallel"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReplicated parallel, e.g. \u003ccode\u003e[| A |] x : X @ P(x)\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "CSPM.DataStructures.Syntax",
          "name": "ReplicatedParallel",
          "package": "libcspm",
          "signature": "ReplicatedParallel",
          "source": "src/CSPM-DataStructures-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "description": "Replicated parallel e.g",
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "ReplicatedParallel",
          "package": "libcspm",
          "partial": "Replicated Parallel",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:ReplicatedParallel"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReplicated sequential choice, e.g. \u003ccode\u003e; x : \u003ca\u003e0,1\u003c/a\u003e @ P(x)\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "CSPM.DataStructures.Syntax",
          "name": "ReplicatedSequentialComp",
          "package": "libcspm",
          "signature": "ReplicatedSequentialComp",
          "source": "src/CSPM-DataStructures-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "description": "Replicated sequential choice e.g",
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "ReplicatedSequentialComp",
          "package": "libcspm",
          "partial": "Replicated Sequential Comp",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:ReplicatedSequentialComp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReplicated synchronising external choice, e.g. \u003ccode\u003e[+ A +] x : X @ P(x)\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "CSPM.DataStructures.Syntax",
          "name": "ReplicatedSynchronisingExternalChoice",
          "package": "libcspm",
          "signature": "ReplicatedSynchronisingExternalChoice",
          "source": "src/CSPM-DataStructures-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "description": "Replicated synchronising external choice e.g",
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "ReplicatedSynchronisingExternalChoice",
          "package": "libcspm",
          "partial": "Replicated Synchronising External Choice",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:ReplicatedSynchronisingExternalChoice"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"CSPM.DataStructures.Syntax\",\"CSPM.Parser.Tokens\"]",
          "name": "Revivals",
          "package": "libcspm",
          "signature": "Revivals",
          "source": "src/CSPM-DataStructures-Syntax.html#Model",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:Revivals\",\"http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Tokens.html#v:Revivals\"]"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "Revivals",
          "package": "libcspm",
          "partial": "Revivals",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:Revivals"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"CSPM.DataStructures.Syntax\",\"CSPM.Parser.Tokens\"]",
          "name": "RevivalsDivergences",
          "package": "libcspm",
          "signature": "RevivalsDivergences",
          "source": "src/CSPM-DataStructures-Syntax.html#Model",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:RevivalsDivergences\",\"http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Tokens.html#v:RevivalsDivergences\"]"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "RevivalsDivergences",
          "package": "libcspm",
          "partial": "Revivals Divergences",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:RevivalsDivergences"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "RunAssertion",
          "package": "libcspm",
          "signature": "RunAssertion (AnAssertion id)",
          "source": "src/CSPM-DataStructures-Syntax.html#InteractiveStmt",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "RunAssertion",
          "package": "libcspm",
          "partial": "Run Assertion",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:RunAssertion"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "STBool",
          "package": "libcspm",
          "signature": "STBool",
          "source": "src/CSPM-DataStructures-Syntax.html#SType",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "STBool",
          "package": "libcspm",
          "partial": "STBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:STBool"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "STChar",
          "package": "libcspm",
          "signature": "STChar",
          "source": "src/CSPM-DataStructures-Syntax.html#SType",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "STChar",
          "package": "libcspm",
          "partial": "STChar",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:STChar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "STDatatype",
          "package": "libcspm",
          "signature": "STDatatype id",
          "source": "src/CSPM-DataStructures-Syntax.html#SType",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "STDatatype",
          "package": "libcspm",
          "partial": "STDatatype",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:STDatatype"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "STDot",
          "package": "libcspm",
          "signature": "STDot (AnSType id) (AnSType id)",
          "source": "src/CSPM-DataStructures-Syntax.html#SType",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "STDot",
          "package": "libcspm",
          "partial": "STDot",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:STDot"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "STDotable",
          "package": "libcspm",
          "signature": "STDotable (AnSType id) (AnSType id)",
          "source": "src/CSPM-DataStructures-Syntax.html#SType",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "STDotable",
          "package": "libcspm",
          "partial": "STDotable",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:STDotable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "STEvent",
          "package": "libcspm",
          "signature": "STEvent",
          "source": "src/CSPM-DataStructures-Syntax.html#SType",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "STEvent",
          "package": "libcspm",
          "partial": "STEvent",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:STEvent"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "STExtendable",
          "package": "libcspm",
          "signature": "STExtendable (AnSType id) id",
          "source": "src/CSPM-DataStructures-Syntax.html#SType",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "STExtendable",
          "package": "libcspm",
          "partial": "STExtendable",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:STExtendable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "STFunction",
          "package": "libcspm",
          "signature": "STFunction [AnSType id] (AnSType id)",
          "source": "src/CSPM-DataStructures-Syntax.html#SType",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "STFunction",
          "normalized": "STFunction[AnSType a](AnSType a)",
          "package": "libcspm",
          "partial": "STFunction",
          "signature": "STFunction[AnSType id](AnSType id)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:STFunction"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "STInt",
          "package": "libcspm",
          "signature": "STInt",
          "source": "src/CSPM-DataStructures-Syntax.html#SType",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "STInt",
          "package": "libcspm",
          "partial": "STInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:STInt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "STMap",
          "package": "libcspm",
          "signature": "STMap (AnSType id) (AnSType id)",
          "source": "src/CSPM-DataStructures-Syntax.html#SType",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "STMap",
          "package": "libcspm",
          "partial": "STMap",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:STMap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "STParen",
          "package": "libcspm",
          "signature": "STParen (AnSType id)",
          "source": "src/CSPM-DataStructures-Syntax.html#SType",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "STParen",
          "package": "libcspm",
          "partial": "STParen",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:STParen"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "STProc",
          "package": "libcspm",
          "signature": "STProc",
          "source": "src/CSPM-DataStructures-Syntax.html#SType",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "STProc",
          "package": "libcspm",
          "partial": "STProc",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:STProc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "STSeq",
          "package": "libcspm",
          "signature": "STSeq (AnSType id)",
          "source": "src/CSPM-DataStructures-Syntax.html#SType",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "STSeq",
          "package": "libcspm",
          "partial": "STSeq",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:STSeq"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "STSet",
          "package": "libcspm",
          "signature": "STSet (AnSType id)",
          "source": "src/CSPM-DataStructures-Syntax.html#SType",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "STSet",
          "package": "libcspm",
          "partial": "STSet",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:STSet"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "STTuple",
          "package": "libcspm",
          "signature": "STTuple [AnSType id]",
          "source": "src/CSPM-DataStructures-Syntax.html#SType",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "STTuple",
          "normalized": "STTuple[AnSType a]",
          "package": "libcspm",
          "partial": "STTuple",
          "signature": "STTuple[AnSType id]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:STTuple"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "STVar",
          "package": "libcspm",
          "signature": "STVar id",
          "source": "src/CSPM-DataStructures-Syntax.html#SType",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "STVar",
          "package": "libcspm",
          "partial": "STVar",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:STVar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "STypeConstraint",
          "package": "libcspm",
          "signature": "STypeConstraint",
          "source": "src/CSPM-DataStructures-Syntax.html#STypeConstraint",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "STypeConstraint",
          "package": "libcspm",
          "partial": "SType Constraint",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:STypeConstraint"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "STypeScheme",
          "package": "libcspm",
          "signature": "STypeScheme",
          "source": "src/CSPM-DataStructures-Syntax.html#STypeScheme",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "STypeScheme",
          "package": "libcspm",
          "partial": "SType Scheme",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:STypeScheme"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSequential composition, e.g. \u003ccode\u003eP; Q\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "CSPM.DataStructures.Syntax",
          "name": "SequentialComp",
          "package": "libcspm",
          "signature": "SequentialComp",
          "source": "src/CSPM-DataStructures-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "description": "Sequential composition e.g",
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "SequentialComp",
          "package": "libcspm",
          "partial": "Sequential Comp",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:SequentialComp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSet literals, e.g. \u003ccode\u003e{1,2,3}\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "CSPM.DataStructures.Syntax",
          "name": "Set",
          "package": "libcspm",
          "signature": "Set",
          "source": "src/CSPM-DataStructures-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "description": "Set literals e.g",
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "Set",
          "package": "libcspm",
          "partial": "Set",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:Set"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSet comprehensions, e.g. \u003ccode\u003e{x,y | (x,y) \u003c- e}\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "CSPM.DataStructures.Syntax",
          "name": "SetComp",
          "package": "libcspm",
          "signature": "SetComp",
          "source": "src/CSPM-DataStructures-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "description": "Set comprehensions e.g",
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "SetComp",
          "package": "libcspm",
          "partial": "Set Comp",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:SetComp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEnumerated Sets, i.e. sets that complete the events, e.g. \u003ccode\u003e{| c.x |}\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "CSPM.DataStructures.Syntax",
          "name": "SetEnum",
          "package": "libcspm",
          "signature": "SetEnum",
          "source": "src/CSPM-DataStructures-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "description": "Enumerated Sets i.e sets that complete the events e.g c.x",
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "SetEnum",
          "package": "libcspm",
          "partial": "Set Enum",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:SetEnum"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSet comprehension version of \u003ccode\u003e\u003ca\u003eSetEnum\u003c/a\u003e\u003c/code\u003e, e.g. \u003ccode\u003e{| c.x | x \u003c- xs |}\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "CSPM.DataStructures.Syntax",
          "name": "SetEnumComp",
          "package": "libcspm",
          "signature": "SetEnumComp",
          "source": "src/CSPM-DataStructures-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "description": "Set comprehension version of SetEnum e.g c.x xs",
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "SetEnumComp",
          "package": "libcspm",
          "partial": "Set Enum Comp",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:SetEnumComp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe infinite set of integers from the given value, e.g. \u003ccode\u003e{5..}\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "CSPM.DataStructures.Syntax",
          "name": "SetEnumFrom",
          "package": "libcspm",
          "signature": "SetEnumFrom",
          "source": "src/CSPM-DataStructures-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "description": "The infinite set of integers from the given value e.g",
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "SetEnumFrom",
          "package": "libcspm",
          "partial": "Set Enum From",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:SetEnumFrom"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSet of integers from the given value, concatenating all adjacent\n sets, e.g. \u003ccode\u003e{x.. | x \u003c- {0}}\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "CSPM.DataStructures.Syntax",
          "name": "SetEnumFromComp",
          "package": "libcspm",
          "signature": "SetEnumFromComp",
          "source": "src/CSPM-DataStructures-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "description": "Set of integers from the given value concatenating all adjacent sets e.g",
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "SetEnumFromComp",
          "package": "libcspm",
          "partial": "Set Enum From Comp",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:SetEnumFromComp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe bounded set of integers between the two given values, e.g. \n \u003ccode\u003e{5..6}\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "CSPM.DataStructures.Syntax",
          "name": "SetEnumFromTo",
          "package": "libcspm",
          "signature": "SetEnumFromTo",
          "source": "src/CSPM-DataStructures-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "description": "The bounded set of integers between the two given values e.g",
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "SetEnumFromTo",
          "package": "libcspm",
          "partial": "Set Enum From To",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:SetEnumFromTo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSet of integers between the given values, concatenating all items into\n one set, e.g. \u003ccode\u003e{x..y | (x,y) \u003c- {(0,1)}}\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "CSPM.DataStructures.Syntax",
          "name": "SetEnumFromToComp",
          "package": "libcspm",
          "signature": "SetEnumFromToComp",
          "source": "src/CSPM-DataStructures-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "description": "Set of integers between the given values concatenating all items into one set e.g x..y",
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "SetEnumFromToComp",
          "package": "libcspm",
          "partial": "Set Enum From To Comp",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:SetEnumFromToComp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSliding choice, e.g. \u003ccode\u003eP |\u003e Q\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "CSPM.DataStructures.Syntax",
          "name": "SlidingChoice",
          "package": "libcspm",
          "signature": "SlidingChoice",
          "source": "src/CSPM-DataStructures-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "description": "Sliding choice e.g",
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "SlidingChoice",
          "package": "libcspm",
          "partial": "Sliding Choice",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:SlidingChoice"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA subtype declaration, e.g. \u003ccode\u003esubtype T = Clause1 | Clause2\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "CSPM.DataStructures.Syntax",
          "name": "SubType",
          "package": "libcspm",
          "signature": "SubType id [AnDataTypeClause id]",
          "source": "src/CSPM-DataStructures-Syntax.html#Decl",
          "type": "function"
        },
        "index": {
          "description": "subtype declaration e.g subtype Clause1 Clause2",
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "SubType",
          "normalized": "SubType a[AnDataTypeClause a]",
          "package": "libcspm",
          "partial": "Sub Type",
          "signature": "SubType id[AnDataTypeClause id]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:SubType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSynchronising external choice, e.g. \u003ccode\u003eP [+A+] Q\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "CSPM.DataStructures.Syntax",
          "name": "SynchronisingExternalChoice",
          "package": "libcspm",
          "signature": "SynchronisingExternalChoice",
          "source": "src/CSPM-DataStructures-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "description": "Synchronising external choice e.g",
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "SynchronisingExternalChoice",
          "package": "libcspm",
          "partial": "Synchronising External Choice",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:SynchronisingExternalChoice"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSynchronising interrupt, e.g. \u003ccode\u003eP /+A+ Q\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "CSPM.DataStructures.Syntax",
          "name": "SynchronisingInterrupt",
          "package": "libcspm",
          "signature": "SynchronisingInterrupt",
          "source": "src/CSPM-DataStructures-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "description": "Synchronising interrupt e.g",
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "SynchronisingInterrupt",
          "package": "libcspm",
          "partial": "Synchronising Interrupt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:SynchronisingInterrupt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "TauPriority",
          "package": "libcspm",
          "signature": "TauPriority (AnExp id)",
          "source": "src/CSPM-DataStructures-Syntax.html#ModelOption",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "TauPriority",
          "package": "libcspm",
          "partial": "Tau Priority",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:TauPriority"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA timed prefix - only appears after desugaring.\n\u003c/p\u003e",
          "module": "CSPM.DataStructures.Syntax",
          "name": "TimedPrefix",
          "package": "libcspm",
          "signature": "TimedPrefix",
          "source": "src/CSPM-DataStructures-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "description": "timed prefix only appears after desugaring",
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "TimedPrefix",
          "package": "libcspm",
          "partial": "Timed Prefix",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:TimedPrefix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA timed section, e.g. \u003ccode\u003eTimed(f) { P = a -\u003e b -\u003e P }\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "CSPM.DataStructures.Syntax",
          "name": "TimedSection",
          "package": "libcspm",
          "signature": "TimedSection",
          "source": "src/CSPM-DataStructures-Syntax.html#Decl",
          "type": "function"
        },
        "index": {
          "description": "timed section e.g Timed",
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "TimedSection",
          "package": "libcspm",
          "partial": "Timed Section",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:TimedSection"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "Times",
          "package": "libcspm",
          "signature": "Times",
          "source": "src/CSPM-DataStructures-Syntax.html#BinaryMathsOp",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "Times",
          "package": "libcspm",
          "partial": "Times",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:Times"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"CSPM.DataStructures.Syntax\",\"CSPM.Parser.Tokens\"]",
          "name": "Traces",
          "package": "libcspm",
          "signature": "Traces",
          "source": "src/CSPM-DataStructures-Syntax.html#Model",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:Traces\",\"http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Tokens.html#v:Traces\"]"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "Traces",
          "package": "libcspm",
          "partial": "Traces",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:Traces"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn import of a transparent function, e.g. \u003ccode\u003etransparent normal\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "CSPM.DataStructures.Syntax",
          "name": "Transparent",
          "package": "libcspm",
          "signature": "Transparent",
          "source": "src/CSPM-DataStructures-Syntax.html#Decl",
          "type": "function"
        },
        "index": {
          "description": "An import of transparent function e.g transparent normal",
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "Transparent",
          "package": "libcspm",
          "partial": "Transparent",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:Transparent"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTuples, e.g. \u003ccode\u003e(1,2)\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "CSPM.DataStructures.Syntax",
          "name": "Tuple",
          "package": "libcspm",
          "signature": "Tuple",
          "source": "src/CSPM-DataStructures-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "description": "Tuples e.g",
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "Tuple",
          "package": "libcspm",
          "partial": "Tuple",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:Tuple"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eVariables, e.g. \u003ccode\u003ex\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "CSPM.DataStructures.Syntax",
          "name": "Var",
          "package": "libcspm",
          "signature": "Var",
          "source": "src/CSPM-DataStructures-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "description": "Variables e.g",
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "Var",
          "package": "libcspm",
          "partial": "Var",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:Var"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "allAssertionsInFile",
          "package": "libcspm",
          "signature": "AnCSPMFile a -\u003e [AnAssertion a]",
          "source": "src/CSPM-DataStructures-Syntax.html#allAssertionsInFile",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "allAssertionsInFile",
          "normalized": "AnCSPMFile a-\u003e[AnAssertion a]",
          "package": "libcspm",
          "partial": "Assertions In File",
          "signature": "AnCSPMFile a-\u003e[AnAssertion a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:allAssertionsInFile"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "allPrintStatementsInFile",
          "package": "libcspm",
          "signature": "AnCSPMFile a -\u003e [Located String]",
          "source": "src/CSPM-DataStructures-Syntax.html#allPrintStatementsInFile",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "allPrintStatementsInFile",
          "normalized": "AnCSPMFile a-\u003e[Located String]",
          "package": "libcspm",
          "partial": "Print Statements In File",
          "signature": "AnCSPMFile a-\u003e[Located String]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:allPrintStatementsInFile"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAlphabet of process 1.\n\u003c/p\u003e",
          "module": "CSPM.DataStructures.Syntax",
          "name": "alphaParAlphabetLeftProcess",
          "package": "libcspm",
          "signature": "AnExp id",
          "source": "src/CSPM-DataStructures-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "description": "Alphabet of process",
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "alphaParAlphabetLeftProcess",
          "package": "libcspm",
          "partial": "Par Alphabet Left Process",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:alphaParAlphabetLeftProcess"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAlphabet of process 2.\n\u003c/p\u003e",
          "module": "CSPM.DataStructures.Syntax",
          "name": "alphaParAlphabetRightProcess",
          "package": "libcspm",
          "signature": "AnExp id",
          "source": "src/CSPM-DataStructures-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "description": "Alphabet of process",
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "alphaParAlphabetRightProcess",
          "package": "libcspm",
          "partial": "Par Alphabet Right Process",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:alphaParAlphabetRightProcess"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eProcess 1.\n\u003c/p\u003e",
          "module": "CSPM.DataStructures.Syntax",
          "name": "alphaParLeftProcess",
          "package": "libcspm",
          "signature": "AnExp id",
          "source": "src/CSPM-DataStructures-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "description": "Process",
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "alphaParLeftProcess",
          "package": "libcspm",
          "partial": "Par Left Process",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:alphaParLeftProcess"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eProcess 2.\n\u003c/p\u003e",
          "module": "CSPM.DataStructures.Syntax",
          "name": "alphaParRightProcess",
          "package": "libcspm",
          "signature": "AnExp id",
          "source": "src/CSPM-DataStructures-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "description": "Process",
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "alphaParRightProcess",
          "package": "libcspm",
          "partial": "Par Right Process",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:alphaParRightProcess"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe arguments applied to the function\n\u003c/p\u003e",
          "module": "CSPM.DataStructures.Syntax",
          "name": "appArguments",
          "package": "libcspm",
          "signature": "[AnExp id]",
          "source": "src/CSPM-DataStructures-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "description": "The arguments applied to the function",
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "appArguments",
          "normalized": "[AnExp a]",
          "package": "libcspm",
          "partial": "Arguments",
          "signature": "[AnExp id]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:appArguments"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe function.\n\u003c/p\u003e",
          "module": "CSPM.DataStructures.Syntax",
          "name": "appFunction",
          "package": "libcspm",
          "signature": "AnExp id",
          "source": "src/CSPM-DataStructures-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "description": "The function",
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "appFunction",
          "package": "libcspm",
          "partial": "Function",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:appFunction"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "booleanBinaryOpLeftExpression",
          "package": "libcspm",
          "signature": "AnExp id",
          "source": "src/CSPM-DataStructures-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "booleanBinaryOpLeftExpression",
          "package": "libcspm",
          "partial": "Binary Op Left Expression",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:booleanBinaryOpLeftExpression"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "booleanBinaryOpOperator",
          "package": "libcspm",
          "signature": "BinaryBooleanOp",
          "source": "src/CSPM-DataStructures-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "booleanBinaryOpOperator",
          "package": "libcspm",
          "partial": "Binary Op Operator",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:booleanBinaryOpOperator"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "booleanBinaryOpRightExpression",
          "package": "libcspm",
          "signature": "AnExp id",
          "source": "src/CSPM-DataStructures-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "booleanBinaryOpRightExpression",
          "package": "libcspm",
          "partial": "Binary Op Right Expression",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:booleanBinaryOpRightExpression"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "concatLeftList",
          "package": "libcspm",
          "signature": "AnExp id",
          "source": "src/CSPM-DataStructures-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "concatLeftList",
          "package": "libcspm",
          "partial": "Left List",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:concatLeftList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "concatRightList",
          "package": "libcspm",
          "signature": "AnExp id",
          "source": "src/CSPM-DataStructures-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "concatRightList",
          "package": "libcspm",
          "partial": "Right List",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:concatRightList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe name of the datatype clause.\n\u003c/p\u003e",
          "module": "CSPM.DataStructures.Syntax",
          "name": "dataTypeClauseName",
          "package": "libcspm",
          "signature": "id",
          "source": "src/CSPM-DataStructures-Syntax.html#DataTypeClause",
          "type": "function"
        },
        "index": {
          "description": "The name of the datatype clause",
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "dataTypeClauseName",
          "package": "libcspm",
          "partial": "Type Clause Name",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:dataTypeClauseName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe expression that gives the set of values that can be dotted\n with this clause. For example, in the above example the datatype\n clause for A would have \u003ca\u003eInt.Bool\u003c/a\u003e as its type expression.\n\u003c/p\u003e",
          "module": "CSPM.DataStructures.Syntax",
          "name": "dataTypeClauseTypeExpression",
          "package": "libcspm",
          "signature": "Maybe (AnExp id)",
          "source": "src/CSPM-DataStructures-Syntax.html#DataTypeClause",
          "type": "function"
        },
        "index": {
          "description": "The expression that gives the set of values that can be dotted with this clause For example in the above example the datatype clause for would have Int.Bool as its type expression",
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "dataTypeClauseTypeExpression",
          "package": "libcspm",
          "partial": "Type Clause Type Expression",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:dataTypeClauseTypeExpression"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "dotAppLeftArgument",
          "package": "libcspm",
          "signature": "AnExp id",
          "source": "src/CSPM-DataStructures-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "dotAppLeftArgument",
          "package": "libcspm",
          "partial": "App Left Argument",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:dotAppLeftArgument"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "dotAppRighArgument",
          "package": "libcspm",
          "signature": "AnExp id",
          "source": "src/CSPM-DataStructures-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "dotAppRighArgument",
          "package": "libcspm",
          "partial": "App Righ Argument",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:dotAppRighArgument"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "exceptionAlphabet",
          "package": "libcspm",
          "signature": "AnExp id",
          "source": "src/CSPM-DataStructures-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "exceptionAlphabet",
          "package": "libcspm",
          "partial": "Alphabet",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:exceptionAlphabet"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "exceptionLeftProcess",
          "package": "libcspm",
          "signature": "AnExp id",
          "source": "src/CSPM-DataStructures-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "exceptionLeftProcess",
          "package": "libcspm",
          "partial": "Left Process",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:exceptionLeftProcess"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "exceptionRightProcess",
          "package": "libcspm",
          "signature": "AnExp id",
          "source": "src/CSPM-DataStructures-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "exceptionRightProcess",
          "package": "libcspm",
          "partial": "Right Process",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:exceptionRightProcess"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "extChoiceLeftProcess",
          "package": "libcspm",
          "signature": "AnExp id",
          "source": "src/CSPM-DataStructures-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "extChoiceLeftProcess",
          "package": "libcspm",
          "partial": "Choice Left Process",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:extChoiceLeftProcess"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "extChoiceRightOperator",
          "package": "libcspm",
          "signature": "AnExp id",
          "source": "src/CSPM-DataStructures-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "extChoiceRightOperator",
          "package": "libcspm",
          "partial": "Choice Right Operator",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:extChoiceRightOperator"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "externalImportedNames",
          "package": "libcspm",
          "signature": "[id]",
          "source": "src/CSPM-DataStructures-Syntax.html#Decl",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "externalImportedNames",
          "normalized": "[a]",
          "package": "libcspm",
          "partial": "Imported Names",
          "signature": "[id]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:externalImportedNames"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "genParallelAlphabet",
          "package": "libcspm",
          "signature": "AnExp id",
          "source": "src/CSPM-DataStructures-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "genParallelAlphabet",
          "package": "libcspm",
          "partial": "Parallel Alphabet",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:genParallelAlphabet"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "genParallelLeftProcess",
          "package": "libcspm",
          "signature": "AnExp id",
          "source": "src/CSPM-DataStructures-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "genParallelLeftProcess",
          "package": "libcspm",
          "partial": "Parallel Left Process",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:genParallelLeftProcess"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "genParallelRightProcess",
          "package": "libcspm",
          "signature": "AnExp id",
          "source": "src/CSPM-DataStructures-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "genParallelRightProcess",
          "package": "libcspm",
          "partial": "Parallel Right Process",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:genParallelRightProcess"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "getSymbolTable",
          "package": "libcspm",
          "signature": "Annotated (Maybe SymbolTable, PSymbolTable) a -\u003e SymbolTable",
          "source": "src/CSPM-DataStructures-Syntax.html#getSymbolTable",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "getSymbolTable",
          "normalized": "Annotated(Maybe SymbolTable,PSymbolTable)a-\u003eSymbolTable",
          "package": "libcspm",
          "partial": "Symbol Table",
          "signature": "Annotated(Maybe SymbolTable,PSymbolTable)a-\u003eSymbolTable",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:getSymbolTable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "getType",
          "package": "libcspm",
          "signature": "Annotated (Maybe Type, PType) a -\u003e Type",
          "source": "src/CSPM-DataStructures-Syntax.html#getType",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "getType",
          "normalized": "Annotated(Maybe Type,PType)a-\u003eType",
          "package": "libcspm",
          "partial": "Type",
          "signature": "Annotated(Maybe Type,PType)a-\u003eType",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:getType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "guardedExpCondition",
          "package": "libcspm",
          "signature": "AnExp id",
          "source": "src/CSPM-DataStructures-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "guardedExpCondition",
          "package": "libcspm",
          "partial": "Exp Condition",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:guardedExpCondition"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "guardedExpProcess",
          "package": "libcspm",
          "signature": "AnExp id",
          "source": "src/CSPM-DataStructures-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "guardedExpProcess",
          "package": "libcspm",
          "partial": "Exp Process",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:guardedExpProcess"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe set of events to be hidden.\n\u003c/p\u003e",
          "module": "CSPM.DataStructures.Syntax",
          "name": "hidingAlphabet",
          "package": "libcspm",
          "signature": "AnExp id",
          "source": "src/CSPM-DataStructures-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "description": "The set of events to be hidden",
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "hidingAlphabet",
          "package": "libcspm",
          "partial": "Alphabet",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:hidingAlphabet"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe process the hiding is applied to.\n\u003c/p\u003e",
          "module": "CSPM.DataStructures.Syntax",
          "name": "hidingProcess",
          "package": "libcspm",
          "signature": "AnExp id",
          "source": "src/CSPM-DataStructures-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "description": "The process the hiding is applied to",
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "hidingProcess",
          "package": "libcspm",
          "partial": "Process",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:hidingProcess"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe condition of the if.\n\u003c/p\u003e",
          "module": "CSPM.DataStructures.Syntax",
          "name": "ifCondition",
          "package": "libcspm",
          "signature": "AnExp id",
          "source": "src/CSPM-DataStructures-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "description": "The condition of the if",
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "ifCondition",
          "package": "libcspm",
          "partial": "Condition",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:ifCondition"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "ifElseBranch",
          "package": "libcspm",
          "signature": "AnExp id",
          "source": "src/CSPM-DataStructures-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "ifElseBranch",
          "package": "libcspm",
          "partial": "Else Branch",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:ifElseBranch"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe then branch.\n\u003c/p\u003e",
          "module": "CSPM.DataStructures.Syntax",
          "name": "ifThenBranch",
          "package": "libcspm",
          "signature": "AnExp id",
          "source": "src/CSPM-DataStructures-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "description": "The then branch",
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "ifThenBranch",
          "package": "libcspm",
          "partial": "Then Branch",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:ifThenBranch"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "intChoiceLeftProcess",
          "package": "libcspm",
          "signature": "AnExp id",
          "source": "src/CSPM-DataStructures-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "intChoiceLeftProcess",
          "package": "libcspm",
          "partial": "Choice Left Process",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:intChoiceLeftProcess"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "intChoiceRightProcess",
          "package": "libcspm",
          "signature": "AnExp id",
          "source": "src/CSPM-DataStructures-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "intChoiceRightProcess",
          "package": "libcspm",
          "partial": "Choice Right Process",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:intChoiceRightProcess"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "interleaveLeftProcess",
          "package": "libcspm",
          "signature": "AnExp id",
          "source": "src/CSPM-DataStructures-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "interleaveLeftProcess",
          "package": "libcspm",
          "partial": "Left Process",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:interleaveLeftProcess"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "interleaveRightProcess",
          "package": "libcspm",
          "signature": "AnExp id",
          "source": "src/CSPM-DataStructures-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "interleaveRightProcess",
          "package": "libcspm",
          "partial": "Right Process",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:interleaveRightProcess"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "interruptLeftProcess",
          "package": "libcspm",
          "signature": "AnExp id",
          "source": "src/CSPM-DataStructures-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "interruptLeftProcess",
          "package": "libcspm",
          "partial": "Left Process",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:interruptLeftProcess"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "interruptRightProcess",
          "package": "libcspm",
          "signature": "AnExp id",
          "source": "src/CSPM-DataStructures-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "interruptRightProcess",
          "package": "libcspm",
          "partial": "Right Process",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:interruptRightProcess"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "lambdaBindingPatterns",
          "package": "libcspm",
          "signature": "[AnPat id]",
          "source": "src/CSPM-DataStructures-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "lambdaBindingPatterns",
          "normalized": "[AnPat a]",
          "package": "libcspm",
          "partial": "Binding Patterns",
          "signature": "[AnPat id]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:lambdaBindingPatterns"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "lambdaRightHandSide",
          "package": "libcspm",
          "signature": "AnExp id",
          "source": "src/CSPM-DataStructures-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "lambdaRightHandSide",
          "package": "libcspm",
          "partial": "Right Hand Side",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:lambdaRightHandSide"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "letDeclarations",
          "package": "libcspm",
          "signature": "[AnDecl id]",
          "source": "src/CSPM-DataStructures-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "letDeclarations",
          "normalized": "[AnDecl a]",
          "package": "libcspm",
          "partial": "Declarations",
          "signature": "[AnDecl id]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:letDeclarations"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "letExpression",
          "package": "libcspm",
          "signature": "AnExp id",
          "source": "src/CSPM-DataStructures-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "letExpression",
          "package": "libcspm",
          "partial": "Expression",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:letExpression"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "linkParLeftProcess",
          "package": "libcspm",
          "signature": "AnExp id",
          "source": "src/CSPM-DataStructures-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "linkParLeftProcess",
          "package": "libcspm",
          "partial": "Par Left Process",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:linkParLeftProcess"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "linkParRightProcess",
          "package": "libcspm",
          "signature": "AnExp id",
          "source": "src/CSPM-DataStructures-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "linkParRightProcess",
          "package": "libcspm",
          "partial": "Par Right Process",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:linkParRightProcess"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "linkParTieStatements",
          "package": "libcspm",
          "signature": "[AnStmt id]",
          "source": "src/CSPM-DataStructures-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "linkParTieStatements",
          "normalized": "[AnStmt a]",
          "package": "libcspm",
          "partial": "Par Tie Statements",
          "signature": "[AnStmt id]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:linkParTieStatements"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "linkParTiedEvents",
          "package": "libcspm",
          "signature": "[(AnExp id, AnExp id)]",
          "source": "src/CSPM-DataStructures-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "linkParTiedEvents",
          "normalized": "[(AnExp a,AnExp a)]",
          "package": "libcspm",
          "partial": "Par Tied Events",
          "signature": "[(AnExp id,AnExp id)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:linkParTiedEvents"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "listCompItems",
          "package": "libcspm",
          "signature": "[AnExp id]",
          "source": "src/CSPM-DataStructures-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "listCompItems",
          "normalized": "[AnExp a]",
          "package": "libcspm",
          "partial": "Comp Items",
          "signature": "[AnExp id]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:listCompItems"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "listCompStatements",
          "package": "libcspm",
          "signature": "[AnStmt id]",
          "source": "src/CSPM-DataStructures-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "listCompStatements",
          "normalized": "[AnStmt a]",
          "package": "libcspm",
          "partial": "Comp Statements",
          "signature": "[AnStmt id]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:listCompStatements"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "listEnumFromCompLowerBound",
          "package": "libcspm",
          "signature": "AnExp id",
          "source": "src/CSPM-DataStructures-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "listEnumFromCompLowerBound",
          "package": "libcspm",
          "partial": "Enum From Comp Lower Bound",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:listEnumFromCompLowerBound"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "listEnumFromCompStatements",
          "package": "libcspm",
          "signature": "[AnStmt id]",
          "source": "src/CSPM-DataStructures-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "listEnumFromCompStatements",
          "normalized": "[AnStmt a]",
          "package": "libcspm",
          "partial": "Enum From Comp Statements",
          "signature": "[AnStmt id]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:listEnumFromCompStatements"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "listEnumFromLowerBound",
          "package": "libcspm",
          "signature": "AnExp id",
          "source": "src/CSPM-DataStructures-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "listEnumFromLowerBound",
          "package": "libcspm",
          "partial": "Enum From Lower Bound",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:listEnumFromLowerBound"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "listEnumFromToCompLowerBound",
          "package": "libcspm",
          "signature": "AnExp id",
          "source": "src/CSPM-DataStructures-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "listEnumFromToCompLowerBound",
          "package": "libcspm",
          "partial": "Enum From To Comp Lower Bound",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:listEnumFromToCompLowerBound"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "listEnumFromToCompStatements",
          "package": "libcspm",
          "signature": "[AnStmt id]",
          "source": "src/CSPM-DataStructures-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "listEnumFromToCompStatements",
          "normalized": "[AnStmt a]",
          "package": "libcspm",
          "partial": "Enum From To Comp Statements",
          "signature": "[AnStmt id]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:listEnumFromToCompStatements"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "listEnumFromToCompUpperBound",
          "package": "libcspm",
          "signature": "AnExp id",
          "source": "src/CSPM-DataStructures-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "listEnumFromToCompUpperBound",
          "package": "libcspm",
          "partial": "Enum From To Comp Upper Bound",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:listEnumFromToCompUpperBound"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "listEnumFromToLowerBound",
          "package": "libcspm",
          "signature": "AnExp id",
          "source": "src/CSPM-DataStructures-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "listEnumFromToLowerBound",
          "package": "libcspm",
          "partial": "Enum From To Lower Bound",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:listEnumFromToLowerBound"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "listEnumFromToUpperBound",
          "package": "libcspm",
          "signature": "AnExp id",
          "source": "src/CSPM-DataStructures-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "listEnumFromToUpperBound",
          "package": "libcspm",
          "partial": "Enum From To Upper Bound",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:listEnumFromToUpperBound"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "listItems",
          "package": "libcspm",
          "signature": "[AnExp id]",
          "source": "src/CSPM-DataStructures-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "listItems",
          "normalized": "[AnExp a]",
          "package": "libcspm",
          "partial": "Items",
          "signature": "[AnExp id]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:listItems"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "listLengthExpression",
          "package": "libcspm",
          "signature": "AnExp id",
          "source": "src/CSPM-DataStructures-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "listLengthExpression",
          "package": "libcspm",
          "partial": "Length Expression",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:listLengthExpression"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "litLiteral",
          "package": "libcspm",
          "signature": "Literal",
          "source": "src/CSPM-DataStructures-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "litLiteral",
          "package": "libcspm",
          "partial": "Literal",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:litLiteral"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "mapKeyValuePairs",
          "package": "libcspm",
          "signature": "[(AnExp id, AnExp id)]",
          "source": "src/CSPM-DataStructures-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "mapKeyValuePairs",
          "normalized": "[(AnExp a,AnExp a)]",
          "package": "libcspm",
          "partial": "Key Value Pairs",
          "signature": "[(AnExp id,AnExp id)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:mapKeyValuePairs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe patterns that need to be matched. This is a list of lists as\n functions may be curried, like \u003ccode\u003ef(x,y)(z) = ...\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "CSPM.DataStructures.Syntax",
          "name": "matchPatterns",
          "package": "libcspm",
          "signature": "[[AnPat id]]",
          "source": "src/CSPM-DataStructures-Syntax.html#Match",
          "type": "function"
        },
        "index": {
          "description": "The patterns that need to be matched This is list of lists as functions may be curried like",
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "matchPatterns",
          "normalized": "[[AnPat a]]",
          "package": "libcspm",
          "partial": "Patterns",
          "signature": "[[AnPat id]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:matchPatterns"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe expression to be evaluated if the match succeeds.\n\u003c/p\u003e",
          "module": "CSPM.DataStructures.Syntax",
          "name": "matchRightHandSide",
          "package": "libcspm",
          "signature": "AnExp id",
          "source": "src/CSPM-DataStructures-Syntax.html#Match",
          "type": "function"
        },
        "index": {
          "description": "The expression to be evaluated if the match succeeds",
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "matchRightHandSide",
          "package": "libcspm",
          "partial": "Right Hand Side",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:matchRightHandSide"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "mathsBinaryOpLeftExpression",
          "package": "libcspm",
          "signature": "AnExp id",
          "source": "src/CSPM-DataStructures-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "mathsBinaryOpLeftExpression",
          "package": "libcspm",
          "partial": "Binary Op Left Expression",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:mathsBinaryOpLeftExpression"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "mathsBinaryOpOperator",
          "package": "libcspm",
          "signature": "BinaryMathsOp",
          "source": "src/CSPM-DataStructures-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "mathsBinaryOpOperator",
          "package": "libcspm",
          "partial": "Binary Op Operator",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:mathsBinaryOpOperator"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "mathsBinaryOpRightExpression",
          "package": "libcspm",
          "signature": "AnExp id",
          "source": "src/CSPM-DataStructures-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "mathsBinaryOpRightExpression",
          "package": "libcspm",
          "partial": "Binary Op Right Expression",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:mathsBinaryOpRightExpression"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "mathsUnaryOpExpression",
          "package": "libcspm",
          "signature": "AnExp id",
          "source": "src/CSPM-DataStructures-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "mathsUnaryOpExpression",
          "package": "libcspm",
          "partial": "Unary Op Expression",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:mathsUnaryOpExpression"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "mathsUnaryOpOperator",
          "package": "libcspm",
          "signature": "UnaryMathsOp",
          "source": "src/CSPM-DataStructures-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "mathsUnaryOpOperator",
          "package": "libcspm",
          "partial": "Unary Op Operator",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:mathsUnaryOpOperator"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "moduleArguments",
          "package": "libcspm",
          "signature": "[AnPat id]",
          "source": "src/CSPM-DataStructures-Syntax.html#Decl",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "moduleArguments",
          "normalized": "[AnPat a]",
          "package": "libcspm",
          "partial": "Arguments",
          "signature": "[AnPat id]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:moduleArguments"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "moduleExportedDeclarations",
          "package": "libcspm",
          "signature": "[AnDecl id]",
          "source": "src/CSPM-DataStructures-Syntax.html#Decl",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "moduleExportedDeclarations",
          "normalized": "[AnDecl a]",
          "package": "libcspm",
          "partial": "Exported Declarations",
          "signature": "[AnDecl id]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:moduleExportedDeclarations"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe name of the module instance.\n\u003c/p\u003e",
          "module": "CSPM.DataStructures.Syntax",
          "name": "moduleInstanceName",
          "package": "libcspm",
          "signature": "id",
          "source": "src/CSPM-DataStructures-Syntax.html#Decl",
          "type": "function"
        },
        "index": {
          "description": "The name of the module instance",
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "moduleInstanceName",
          "package": "libcspm",
          "partial": "Instance Name",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:moduleInstanceName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMap from name of this module to name of inner module.\n\u003c/p\u003e",
          "module": "CSPM.DataStructures.Syntax",
          "name": "moduleInstanceNameMap",
          "package": "libcspm",
          "signature": "[(id, id)]",
          "source": "src/CSPM-DataStructures-Syntax.html#Decl",
          "type": "function"
        },
        "index": {
          "description": "Map from name of this module to name of inner module",
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "moduleInstanceNameMap",
          "normalized": "[(a,a)]",
          "package": "libcspm",
          "partial": "Instance Name Map",
          "signature": "[(id,id)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:moduleInstanceNameMap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe name of the module this is an instance of.\n\u003c/p\u003e",
          "module": "CSPM.DataStructures.Syntax",
          "name": "moduleInstanceOf",
          "package": "libcspm",
          "signature": "id",
          "source": "src/CSPM-DataStructures-Syntax.html#Decl",
          "type": "function"
        },
        "index": {
          "description": "The name of the module this is an instance of",
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "moduleInstanceOf",
          "package": "libcspm",
          "partial": "Instance Of",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:moduleInstanceOf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe arguments of the module that this is an instance of.\n\u003c/p\u003e",
          "module": "CSPM.DataStructures.Syntax",
          "name": "moduleInstanceOfArguments",
          "package": "libcspm",
          "signature": "[AnExp id]",
          "source": "src/CSPM-DataStructures-Syntax.html#Decl",
          "type": "function"
        },
        "index": {
          "description": "The arguments of the module that this is an instance of",
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "moduleInstanceOfArguments",
          "normalized": "[AnExp a]",
          "package": "libcspm",
          "partial": "Instance Of Arguments",
          "signature": "[AnExp id]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:moduleInstanceOfArguments"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe module that this is an instance of\n\u003c/p\u003e",
          "module": "CSPM.DataStructures.Syntax",
          "name": "moduleInstanceOfDeclaration",
          "package": "libcspm",
          "signature": "Maybe (AnDecl id)",
          "source": "src/CSPM-DataStructures-Syntax.html#Decl",
          "type": "function"
        },
        "index": {
          "description": "The module that this is an instance of",
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "moduleInstanceOfDeclaration",
          "package": "libcspm",
          "partial": "Instance Of Declaration",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:moduleInstanceOfDeclaration"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "moduleName",
          "package": "libcspm",
          "signature": "id",
          "source": "src/CSPM-DataStructures-Syntax.html#Decl",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "moduleName",
          "package": "libcspm",
          "partial": "Name",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:moduleName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "modulePrivateDeclarations",
          "package": "libcspm",
          "signature": "[AnDecl id]",
          "source": "src/CSPM-DataStructures-Syntax.html#Decl",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "modulePrivateDeclarations",
          "normalized": "[AnDecl a]",
          "package": "libcspm",
          "partial": "Private Declarations",
          "signature": "[AnDecl id]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:modulePrivateDeclarations"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "pConcatLeftPat",
          "package": "libcspm",
          "signature": "AnPat id",
          "source": "src/CSPM-DataStructures-Syntax.html#Pat",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "pConcatLeftPat",
          "package": "libcspm",
          "partial": "Concat Left Pat",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:pConcatLeftPat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "pConcatRightPat",
          "package": "libcspm",
          "signature": "AnPat id",
          "source": "src/CSPM-DataStructures-Syntax.html#Pat",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "pConcatRightPat",
          "package": "libcspm",
          "partial": "Concat Right Pat",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:pConcatRightPat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "pDotItems",
          "package": "libcspm",
          "signature": "[AnPat id]",
          "source": "src/CSPM-DataStructures-Syntax.html#Pat",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "pDotItems",
          "normalized": "[AnPat a]",
          "package": "libcspm",
          "partial": "Dot Items",
          "signature": "[AnPat id]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:pDotItems"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "pDotLeftPat",
          "package": "libcspm",
          "signature": "AnPat id",
          "source": "src/CSPM-DataStructures-Syntax.html#Pat",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "pDotLeftPat",
          "package": "libcspm",
          "partial": "Dot Left Pat",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:pDotLeftPat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "pDotOriginalpattern",
          "package": "libcspm",
          "signature": "Pat id",
          "source": "src/CSPM-DataStructures-Syntax.html#Pat",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "pDotOriginalpattern",
          "package": "libcspm",
          "partial": "Dot Originalpattern",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:pDotOriginalpattern"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "pDotRightPat",
          "package": "libcspm",
          "signature": "AnPat id",
          "source": "src/CSPM-DataStructures-Syntax.html#Pat",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "pDotRightPat",
          "package": "libcspm",
          "partial": "Dot Right Pat",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:pDotRightPat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "pDoublePatLeftPat",
          "package": "libcspm",
          "signature": "AnPat id",
          "source": "src/CSPM-DataStructures-Syntax.html#Pat",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "pDoublePatLeftPat",
          "package": "libcspm",
          "partial": "Double Pat Left Pat",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:pDoublePatLeftPat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "pDoublePatRightPat",
          "package": "libcspm",
          "signature": "AnPat id",
          "source": "src/CSPM-DataStructures-Syntax.html#Pat",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "pDoublePatRightPat",
          "package": "libcspm",
          "partial": "Double Pat Right Pat",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:pDoublePatRightPat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "pListItems",
          "package": "libcspm",
          "signature": "[AnPat id]",
          "source": "src/CSPM-DataStructures-Syntax.html#Pat",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "pListItems",
          "normalized": "[AnPat a]",
          "package": "libcspm",
          "partial": "List Items",
          "signature": "[AnPat id]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:pListItems"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "pListMiddleEndItems",
          "package": "libcspm",
          "signature": "Maybe (AnPat id, [AnPat id])",
          "source": "src/CSPM-DataStructures-Syntax.html#Pat",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "pListMiddleEndItems",
          "normalized": "Maybe(AnPat a,[AnPat a])",
          "package": "libcspm",
          "partial": "List Middle End Items",
          "signature": "Maybe(AnPat id,[AnPat id])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:pListMiddleEndItems"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "pListOriginalPattern",
          "package": "libcspm",
          "signature": "Pat id",
          "source": "src/CSPM-DataStructures-Syntax.html#Pat",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "pListOriginalPattern",
          "package": "libcspm",
          "partial": "List Original Pattern",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:pListOriginalPattern"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "pListStartItems",
          "package": "libcspm",
          "signature": "[AnPat id]",
          "source": "src/CSPM-DataStructures-Syntax.html#Pat",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "pListStartItems",
          "normalized": "[AnPat a]",
          "package": "libcspm",
          "partial": "List Start Items",
          "signature": "[AnPat id]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:pListStartItems"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "pLitLiteral",
          "package": "libcspm",
          "signature": "Literal",
          "source": "src/CSPM-DataStructures-Syntax.html#Pat",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "pLitLiteral",
          "package": "libcspm",
          "partial": "Lit Literal",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:pLitLiteral"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "pParenPattern",
          "package": "libcspm",
          "signature": "AnPat id",
          "source": "src/CSPM-DataStructures-Syntax.html#Pat",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "pParenPattern",
          "package": "libcspm",
          "partial": "Paren Pattern",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:pParenPattern"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "pSetItems",
          "package": "libcspm",
          "signature": "[AnPat id]",
          "source": "src/CSPM-DataStructures-Syntax.html#Pat",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "pSetItems",
          "normalized": "[AnPat a]",
          "package": "libcspm",
          "partial": "Set Items",
          "signature": "[AnPat id]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:pSetItems"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "pTupleItems",
          "package": "libcspm",
          "signature": "[AnPat id]",
          "source": "src/CSPM-DataStructures-Syntax.html#Pat",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "pTupleItems",
          "normalized": "[AnPat a]",
          "package": "libcspm",
          "partial": "Tuple Items",
          "signature": "[AnPat id]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:pTupleItems"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "pVarIdentity",
          "package": "libcspm",
          "signature": "id",
          "source": "src/CSPM-DataStructures-Syntax.html#Pat",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "pVarIdentity",
          "package": "libcspm",
          "partial": "Var Identity",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:pVarIdentity"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "parenExpression",
          "package": "libcspm",
          "signature": "AnExp id",
          "source": "src/CSPM-DataStructures-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "parenExpression",
          "package": "libcspm",
          "partial": "Expression",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:parenExpression"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "prefixChannel",
          "package": "libcspm",
          "signature": "AnExp id",
          "source": "src/CSPM-DataStructures-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "prefixChannel",
          "package": "libcspm",
          "partial": "Channel",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:prefixChannel"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "prefixFields",
          "package": "libcspm",
          "signature": "[AnField id]",
          "source": "src/CSPM-DataStructures-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "prefixFields",
          "normalized": "[AnField a]",
          "package": "libcspm",
          "partial": "Fields",
          "signature": "[AnField id]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:prefixFields"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "prefixProcess",
          "package": "libcspm",
          "signature": "AnExp id",
          "source": "src/CSPM-DataStructures-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "prefixProcess",
          "package": "libcspm",
          "partial": "Process",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:prefixProcess"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "printStatement",
          "package": "libcspm",
          "signature": "String",
          "source": "src/CSPM-DataStructures-Syntax.html#Decl",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "printStatement",
          "package": "libcspm",
          "partial": "Statement",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:printStatement"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "propertyCheckModel",
          "package": "libcspm",
          "signature": "Maybe Model",
          "source": "src/CSPM-DataStructures-Syntax.html#Assertion",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "propertyCheckModel",
          "package": "libcspm",
          "partial": "Check Model",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:propertyCheckModel"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "propertyCheckProcess",
          "package": "libcspm",
          "signature": "AnExp id",
          "source": "src/CSPM-DataStructures-Syntax.html#Assertion",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "propertyCheckProcess",
          "package": "libcspm",
          "partial": "Check Process",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:propertyCheckProcess"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "propertyCheckProperty",
          "package": "libcspm",
          "signature": "SemanticProperty",
          "source": "src/CSPM-DataStructures-Syntax.html#Assertion",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "propertyCheckProperty",
          "package": "libcspm",
          "partial": "Check Property",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:propertyCheckProperty"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "refinementImplementation",
          "package": "libcspm",
          "signature": "AnExp id",
          "source": "src/CSPM-DataStructures-Syntax.html#Assertion",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "refinementImplementation",
          "package": "libcspm",
          "partial": "Implementation",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:refinementImplementation"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "refinementModel",
          "package": "libcspm",
          "signature": "Model",
          "source": "src/CSPM-DataStructures-Syntax.html#Assertion",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "refinementModel",
          "package": "libcspm",
          "partial": "Model",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:refinementModel"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "refinementModelOptions",
          "package": "libcspm",
          "signature": "[ModelOption id]",
          "source": "src/CSPM-DataStructures-Syntax.html#Assertion",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "refinementModelOptions",
          "normalized": "[ModelOption a]",
          "package": "libcspm",
          "partial": "Model Options",
          "signature": "[ModelOption id]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:refinementModelOptions"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "refinementSpecification",
          "package": "libcspm",
          "signature": "AnExp id",
          "source": "src/CSPM-DataStructures-Syntax.html#Assertion",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "refinementSpecification",
          "package": "libcspm",
          "partial": "Specification",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:refinementSpecification"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe process that is renamed.\n\u003c/p\u003e",
          "module": "CSPM.DataStructures.Syntax",
          "name": "renameProcess",
          "package": "libcspm",
          "signature": "AnExp id",
          "source": "src/CSPM-DataStructures-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "description": "The process that is renamed",
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "renameProcess",
          "package": "libcspm",
          "partial": "Process",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:renameProcess"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe statements for the ties.\n\u003c/p\u003e",
          "module": "CSPM.DataStructures.Syntax",
          "name": "renameTieStatements",
          "package": "libcspm",
          "signature": "[AnStmt id]",
          "source": "src/CSPM-DataStructures-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "description": "The statements for the ties",
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "renameTieStatements",
          "normalized": "[AnStmt a]",
          "package": "libcspm",
          "partial": "Tie Statements",
          "signature": "[AnStmt id]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:renameTieStatements"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe events that are renamed, in the format of \u003ccode\u003e(old, new)\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "CSPM.DataStructures.Syntax",
          "name": "renameTiedEvents",
          "package": "libcspm",
          "signature": "[(AnExp id, AnExp id)]",
          "source": "src/CSPM-DataStructures-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "description": "The events that are renamed in the format of old new",
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "renameTiedEvents",
          "normalized": "[(AnExp a,AnExp a)]",
          "package": "libcspm",
          "partial": "Tied Events",
          "signature": "[(AnExp id,AnExp id)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:renameTiedEvents"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "repAlphaParAlphabet",
          "package": "libcspm",
          "signature": "AnExp id",
          "source": "src/CSPM-DataStructures-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "repAlphaParAlphabet",
          "package": "libcspm",
          "partial": "Alpha Par Alphabet",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:repAlphaParAlphabet"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "repAlphaParProcess",
          "package": "libcspm",
          "signature": "AnExp id",
          "source": "src/CSPM-DataStructures-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "repAlphaParProcess",
          "package": "libcspm",
          "partial": "Alpha Par Process",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:repAlphaParProcess"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "repAlphaParReplicatedStatements",
          "package": "libcspm",
          "signature": "[AnStmt id]",
          "source": "src/CSPM-DataStructures-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "repAlphaParReplicatedStatements",
          "normalized": "[AnStmt a]",
          "package": "libcspm",
          "partial": "Alpha Par Replicated Statements",
          "signature": "[AnStmt id]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:repAlphaParReplicatedStatements"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "repExtChoiceProcess",
          "package": "libcspm",
          "signature": "AnExp id",
          "source": "src/CSPM-DataStructures-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "repExtChoiceProcess",
          "package": "libcspm",
          "partial": "Ext Choice Process",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:repExtChoiceProcess"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "repExtChoiceReplicatedStatements",
          "package": "libcspm",
          "signature": "[AnStmt id]",
          "source": "src/CSPM-DataStructures-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "repExtChoiceReplicatedStatements",
          "normalized": "[AnStmt a]",
          "package": "libcspm",
          "partial": "Ext Choice Replicated Statements",
          "signature": "[AnStmt id]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:repExtChoiceReplicatedStatements"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "repIntChoiceProcess",
          "package": "libcspm",
          "signature": "AnExp id",
          "source": "src/CSPM-DataStructures-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "repIntChoiceProcess",
          "package": "libcspm",
          "partial": "Int Choice Process",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:repIntChoiceProcess"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "repIntChoiceReplicatedStatements",
          "package": "libcspm",
          "signature": "[AnStmt id]",
          "source": "src/CSPM-DataStructures-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "repIntChoiceReplicatedStatements",
          "normalized": "[AnStmt a]",
          "package": "libcspm",
          "partial": "Int Choice Replicated Statements",
          "signature": "[AnStmt id]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:repIntChoiceReplicatedStatements"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "repInterleaveProcess",
          "package": "libcspm",
          "signature": "AnExp id",
          "source": "src/CSPM-DataStructures-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "repInterleaveProcess",
          "package": "libcspm",
          "partial": "Interleave Process",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:repInterleaveProcess"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "repInterleaveReplicatedStatements",
          "package": "libcspm",
          "signature": "[AnStmt id]",
          "source": "src/CSPM-DataStructures-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "repInterleaveReplicatedStatements",
          "normalized": "[AnStmt a]",
          "package": "libcspm",
          "partial": "Interleave Replicated Statements",
          "signature": "[AnStmt id]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:repInterleaveReplicatedStatements"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe process\n\u003c/p\u003e",
          "module": "CSPM.DataStructures.Syntax",
          "name": "repLinkParProcess",
          "package": "libcspm",
          "signature": "AnExp id",
          "source": "src/CSPM-DataStructures-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "description": "The process",
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "repLinkParProcess",
          "package": "libcspm",
          "partial": "Link Par Process",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:repLinkParProcess"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003eStmt\u003c/a\u003e\u003c/code\u003es - the process (and ties) are evaluated once for each \n value generated by these.\n\u003c/p\u003e",
          "module": "CSPM.DataStructures.Syntax",
          "name": "repLinkParReplicatedStatements",
          "package": "libcspm",
          "signature": "[AnStmt id]",
          "source": "src/CSPM-DataStructures-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "description": "The Stmt the process and ties are evaluated once for each value generated by these",
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "repLinkParReplicatedStatements",
          "normalized": "[AnStmt a]",
          "package": "libcspm",
          "partial": "Link Par Replicated Statements",
          "signature": "[AnStmt id]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:repLinkParReplicatedStatements"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe statements for the ties.\n\u003c/p\u003e",
          "module": "CSPM.DataStructures.Syntax",
          "name": "repLinkParTieStatements",
          "package": "libcspm",
          "signature": "[AnStmt id]",
          "source": "src/CSPM-DataStructures-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "description": "The statements for the ties",
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "repLinkParTieStatements",
          "normalized": "[AnStmt a]",
          "package": "libcspm",
          "partial": "Link Par Tie Statements",
          "signature": "[AnStmt id]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:repLinkParTieStatements"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe tied events.\n\u003c/p\u003e",
          "module": "CSPM.DataStructures.Syntax",
          "name": "repLinkParTiedChannels",
          "package": "libcspm",
          "signature": "[(AnExp id, AnExp id)]",
          "source": "src/CSPM-DataStructures-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "description": "The tied events",
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "repLinkParTiedChannels",
          "normalized": "[(AnExp a,AnExp a)]",
          "package": "libcspm",
          "partial": "Link Par Tied Channels",
          "signature": "[(AnExp id,AnExp id)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:repLinkParTiedChannels"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "repParAlphabet",
          "package": "libcspm",
          "signature": "AnExp id",
          "source": "src/CSPM-DataStructures-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "repParAlphabet",
          "package": "libcspm",
          "partial": "Par Alphabet",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:repParAlphabet"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "repParProcess",
          "package": "libcspm",
          "signature": "AnExp id",
          "source": "src/CSPM-DataStructures-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "repParProcess",
          "package": "libcspm",
          "partial": "Par Process",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:repParProcess"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "repParReplicatedStatements",
          "package": "libcspm",
          "signature": "[AnStmt id]",
          "source": "src/CSPM-DataStructures-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "repParReplicatedStatements",
          "normalized": "[AnStmt a]",
          "package": "libcspm",
          "partial": "Par Replicated Statements",
          "signature": "[AnStmt id]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:repParReplicatedStatements"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "repSeqCompProcess",
          "package": "libcspm",
          "signature": "AnExp id",
          "source": "src/CSPM-DataStructures-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "repSeqCompProcess",
          "package": "libcspm",
          "partial": "Seq Comp Process",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:repSeqCompProcess"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "repSeqCompStatements",
          "package": "libcspm",
          "signature": "[AnStmt id]",
          "source": "src/CSPM-DataStructures-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "repSeqCompStatements",
          "normalized": "[AnStmt a]",
          "package": "libcspm",
          "partial": "Seq Comp Statements",
          "signature": "[AnStmt id]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:repSeqCompStatements"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "repSynchronisingExtChoiceAlphabet",
          "package": "libcspm",
          "signature": "AnExp id",
          "source": "src/CSPM-DataStructures-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "repSynchronisingExtChoiceAlphabet",
          "package": "libcspm",
          "partial": "Synchronising Ext Choice Alphabet",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:repSynchronisingExtChoiceAlphabet"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "repSynchronisingExtChoiceProcess",
          "package": "libcspm",
          "signature": "AnExp id",
          "source": "src/CSPM-DataStructures-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "repSynchronisingExtChoiceProcess",
          "package": "libcspm",
          "partial": "Synchronising Ext Choice Process",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:repSynchronisingExtChoiceProcess"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "repSynchronisingExtChoiceReplicatedStatements",
          "package": "libcspm",
          "signature": "[AnStmt id]",
          "source": "src/CSPM-DataStructures-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "repSynchronisingExtChoiceReplicatedStatements",
          "normalized": "[AnStmt a]",
          "package": "libcspm",
          "partial": "Synchronising Ext Choice Replicated Statements",
          "signature": "[AnStmt id]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:repSynchronisingExtChoiceReplicatedStatements"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "seqCompLeftProcess",
          "package": "libcspm",
          "signature": "AnExp id",
          "source": "src/CSPM-DataStructures-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "seqCompLeftProcess",
          "package": "libcspm",
          "partial": "Comp Left Process",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:seqCompLeftProcess"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "seqCompRightProcess",
          "package": "libcspm",
          "signature": "AnExp id",
          "source": "src/CSPM-DataStructures-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "seqCompRightProcess",
          "package": "libcspm",
          "partial": "Comp Right Process",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:seqCompRightProcess"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "setCompItems",
          "package": "libcspm",
          "signature": "[AnExp id]",
          "source": "src/CSPM-DataStructures-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "setCompItems",
          "normalized": "[AnExp a]",
          "package": "libcspm",
          "partial": "Comp Items",
          "signature": "[AnExp id]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:setCompItems"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "setCompStatements",
          "package": "libcspm",
          "signature": "[AnStmt id]",
          "source": "src/CSPM-DataStructures-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "setCompStatements",
          "normalized": "[AnStmt a]",
          "package": "libcspm",
          "partial": "Comp Statements",
          "signature": "[AnStmt id]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:setCompStatements"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "setEnumCompItems",
          "package": "libcspm",
          "signature": "[AnExp id]",
          "source": "src/CSPM-DataStructures-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "setEnumCompItems",
          "normalized": "[AnExp a]",
          "package": "libcspm",
          "partial": "Enum Comp Items",
          "signature": "[AnExp id]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:setEnumCompItems"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "setEnumCompStatements",
          "package": "libcspm",
          "signature": "[AnStmt id]",
          "source": "src/CSPM-DataStructures-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "setEnumCompStatements",
          "normalized": "[AnStmt a]",
          "package": "libcspm",
          "partial": "Enum Comp Statements",
          "signature": "[AnStmt id]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:setEnumCompStatements"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "setEnumFromCompLowerBound",
          "package": "libcspm",
          "signature": "AnExp id",
          "source": "src/CSPM-DataStructures-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "setEnumFromCompLowerBound",
          "package": "libcspm",
          "partial": "Enum From Comp Lower Bound",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:setEnumFromCompLowerBound"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "setEnumFromCompStatements",
          "package": "libcspm",
          "signature": "[AnStmt id]",
          "source": "src/CSPM-DataStructures-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "setEnumFromCompStatements",
          "normalized": "[AnStmt a]",
          "package": "libcspm",
          "partial": "Enum From Comp Statements",
          "signature": "[AnStmt id]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:setEnumFromCompStatements"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "setEnumFromLowerBound",
          "package": "libcspm",
          "signature": "AnExp id",
          "source": "src/CSPM-DataStructures-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "setEnumFromLowerBound",
          "package": "libcspm",
          "partial": "Enum From Lower Bound",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:setEnumFromLowerBound"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "setEnumFromToCompLowerBound",
          "package": "libcspm",
          "signature": "AnExp id",
          "source": "src/CSPM-DataStructures-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "setEnumFromToCompLowerBound",
          "package": "libcspm",
          "partial": "Enum From To Comp Lower Bound",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:setEnumFromToCompLowerBound"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "setEnumFromToCompStatements",
          "package": "libcspm",
          "signature": "[AnStmt id]",
          "source": "src/CSPM-DataStructures-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "setEnumFromToCompStatements",
          "normalized": "[AnStmt a]",
          "package": "libcspm",
          "partial": "Enum From To Comp Statements",
          "signature": "[AnStmt id]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:setEnumFromToCompStatements"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "setEnumFromToCompUpperBound",
          "package": "libcspm",
          "signature": "AnExp id",
          "source": "src/CSPM-DataStructures-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "setEnumFromToCompUpperBound",
          "package": "libcspm",
          "partial": "Enum From To Comp Upper Bound",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:setEnumFromToCompUpperBound"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe lower bound.\n\u003c/p\u003e",
          "module": "CSPM.DataStructures.Syntax",
          "name": "setEnumFromToLowerBound",
          "package": "libcspm",
          "signature": "AnExp id",
          "source": "src/CSPM-DataStructures-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "description": "The lower bound",
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "setEnumFromToLowerBound",
          "package": "libcspm",
          "partial": "Enum From To Lower Bound",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:setEnumFromToLowerBound"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe upper bound.\n\u003c/p\u003e",
          "module": "CSPM.DataStructures.Syntax",
          "name": "setEnumFromToUpperBound",
          "package": "libcspm",
          "signature": "AnExp id",
          "source": "src/CSPM-DataStructures-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "description": "The upper bound",
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "setEnumFromToUpperBound",
          "package": "libcspm",
          "partial": "Enum From To Upper Bound",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:setEnumFromToUpperBound"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "setEnumItems",
          "package": "libcspm",
          "signature": "[AnExp id]",
          "source": "src/CSPM-DataStructures-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "setEnumItems",
          "normalized": "[AnExp a]",
          "package": "libcspm",
          "partial": "Enum Items",
          "signature": "[AnExp id]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:setEnumItems"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "setItems",
          "package": "libcspm",
          "signature": "[AnExp id]",
          "source": "src/CSPM-DataStructures-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "setItems",
          "normalized": "[AnExp a]",
          "package": "libcspm",
          "partial": "Items",
          "signature": "[AnExp id]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:setItems"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "slidingChoiceLeftProcess",
          "package": "libcspm",
          "signature": "AnExp id",
          "source": "src/CSPM-DataStructures-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "slidingChoiceLeftProcess",
          "package": "libcspm",
          "partial": "Choice Left Process",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:slidingChoiceLeftProcess"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "slidingChoiceRightProcess",
          "package": "libcspm",
          "signature": "AnExp id",
          "source": "src/CSPM-DataStructures-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "slidingChoiceRightProcess",
          "package": "libcspm",
          "partial": "Choice Right Process",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:slidingChoiceRightProcess"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "stypeConstraintName",
          "package": "libcspm",
          "signature": "Constraint",
          "source": "src/CSPM-DataStructures-Syntax.html#STypeConstraint",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "stypeConstraintName",
          "package": "libcspm",
          "partial": "Constraint Name",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:stypeConstraintName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "stypeConstraintVariable",
          "package": "libcspm",
          "signature": "id",
          "source": "src/CSPM-DataStructures-Syntax.html#STypeConstraint",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "stypeConstraintVariable",
          "package": "libcspm",
          "partial": "Constraint Variable",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:stypeConstraintVariable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "stypeSchemeFreeVars",
          "package": "libcspm",
          "signature": "[id]",
          "source": "src/CSPM-DataStructures-Syntax.html#STypeScheme",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "stypeSchemeFreeVars",
          "normalized": "[a]",
          "package": "libcspm",
          "partial": "Scheme Free Vars",
          "signature": "[id]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:stypeSchemeFreeVars"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "stypeSchemeType",
          "package": "libcspm",
          "signature": "AnSType id",
          "source": "src/CSPM-DataStructures-Syntax.html#STypeScheme",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "stypeSchemeType",
          "package": "libcspm",
          "partial": "Scheme Type",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:stypeSchemeType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "stypeSchemeTypeConstraints",
          "package": "libcspm",
          "signature": "[AnSTypeConstraint id]",
          "source": "src/CSPM-DataStructures-Syntax.html#STypeScheme",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "stypeSchemeTypeConstraints",
          "normalized": "[AnSTypeConstraint a]",
          "package": "libcspm",
          "partial": "Scheme Type Constraints",
          "signature": "[AnSTypeConstraint id]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:stypeSchemeTypeConstraints"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "synchronisingExternalChoiceAlphabet",
          "package": "libcspm",
          "signature": "AnExp id",
          "source": "src/CSPM-DataStructures-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "synchronisingExternalChoiceAlphabet",
          "package": "libcspm",
          "partial": "External Choice Alphabet",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:synchronisingExternalChoiceAlphabet"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "synchronisingExternalChoiceLeftProcess",
          "package": "libcspm",
          "signature": "AnExp id",
          "source": "src/CSPM-DataStructures-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "synchronisingExternalChoiceLeftProcess",
          "package": "libcspm",
          "partial": "External Choice Left Process",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:synchronisingExternalChoiceLeftProcess"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "synchronisingExternalChoiceRightProcess",
          "package": "libcspm",
          "signature": "AnExp id",
          "source": "src/CSPM-DataStructures-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "synchronisingExternalChoiceRightProcess",
          "package": "libcspm",
          "partial": "External Choice Right Process",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:synchronisingExternalChoiceRightProcess"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "synchronisingInterruptAlphabet",
          "package": "libcspm",
          "signature": "AnExp id",
          "source": "src/CSPM-DataStructures-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "synchronisingInterruptAlphabet",
          "package": "libcspm",
          "partial": "Interrupt Alphabet",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:synchronisingInterruptAlphabet"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "synchronisingInterruptLeftProcess",
          "package": "libcspm",
          "signature": "AnExp id",
          "source": "src/CSPM-DataStructures-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "synchronisingInterruptLeftProcess",
          "package": "libcspm",
          "partial": "Interrupt Left Process",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:synchronisingInterruptLeftProcess"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "synchronisingInterruptRightProcess",
          "package": "libcspm",
          "signature": "AnExp id",
          "source": "src/CSPM-DataStructures-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "synchronisingInterruptRightProcess",
          "package": "libcspm",
          "partial": "Interrupt Right Process",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:synchronisingInterruptRightProcess"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe original Prefix clause (it MUST be a regular Prefix).\n\u003c/p\u003e",
          "module": "CSPM.DataStructures.Syntax",
          "name": "timedPrefixOriginalPrefix",
          "package": "libcspm",
          "signature": "AnExp id",
          "source": "src/CSPM-DataStructures-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "description": "The original Prefix clause it MUST be regular Prefix",
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "timedPrefixOriginalPrefix",
          "package": "libcspm",
          "partial": "Prefix Original Prefix",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:timedPrefixOriginalPrefix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe name used to recurse back to this process.\n\u003c/p\u003e",
          "module": "CSPM.DataStructures.Syntax",
          "name": "timedPrefixRecursionName",
          "package": "libcspm",
          "signature": "id",
          "source": "src/CSPM-DataStructures-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "description": "The name used to recurse back to this process",
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "timedPrefixRecursionName",
          "package": "libcspm",
          "partial": "Prefix Recursion Name",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:timedPrefixRecursionName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "timedSectionContents",
          "package": "libcspm",
          "signature": "[AnDecl id]",
          "source": "src/CSPM-DataStructures-Syntax.html#Decl",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "timedSectionContents",
          "normalized": "[AnDecl a]",
          "package": "libcspm",
          "partial": "Section Contents",
          "signature": "[AnDecl id]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:timedSectionContents"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "timedSectionFunction",
          "package": "libcspm",
          "signature": "Maybe (AnExp id)",
          "source": "src/CSPM-DataStructures-Syntax.html#Decl",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "timedSectionFunction",
          "package": "libcspm",
          "partial": "Section Function",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:timedSectionFunction"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe tock instance used - set by the renamer.\n\u003c/p\u003e",
          "module": "CSPM.DataStructures.Syntax",
          "name": "timedSectionTockName",
          "package": "libcspm",
          "signature": "Maybe Name",
          "source": "src/CSPM-DataStructures-Syntax.html#Decl",
          "type": "function"
        },
        "index": {
          "description": "The tock instance used set by the renamer",
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "timedSectionTockName",
          "package": "libcspm",
          "partial": "Section Tock Name",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:timedSectionTockName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "transparentImportedNames",
          "package": "libcspm",
          "signature": "[id]",
          "source": "src/CSPM-DataStructures-Syntax.html#Decl",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "transparentImportedNames",
          "normalized": "[a]",
          "package": "libcspm",
          "partial": "Imported Names",
          "signature": "[id]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:transparentImportedNames"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "tupleItems",
          "package": "libcspm",
          "signature": "[AnExp id]",
          "source": "src/CSPM-DataStructures-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "tupleItems",
          "normalized": "[AnExp a]",
          "package": "libcspm",
          "partial": "Items",
          "signature": "[AnExp id]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:tupleItems"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "unaryBooleanExpression",
          "package": "libcspm",
          "signature": "AnExp id",
          "source": "src/CSPM-DataStructures-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "unaryBooleanExpression",
          "package": "libcspm",
          "partial": "Boolean Expression",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:unaryBooleanExpression"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "unaryBooleanOpOperator",
          "package": "libcspm",
          "signature": "UnaryBooleanOp",
          "source": "src/CSPM-DataStructures-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "unaryBooleanOpOperator",
          "package": "libcspm",
          "partial": "Boolean Op Operator",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:unaryBooleanOpOperator"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Syntax",
          "name": "varIdentity",
          "package": "libcspm",
          "signature": "id",
          "source": "src/CSPM-DataStructures-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Syntax",
          "module": "CSPM.DataStructures.Syntax",
          "name": "varIdentity",
          "package": "libcspm",
          "partial": "Identity",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Syntax.html#v:varIdentity"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Types",
          "name": "Types",
          "package": "libcspm",
          "source": "src/CSPM-DataStructures-Types.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Types",
          "module": "CSPM.DataStructures.Types",
          "name": "Types",
          "package": "libcspm",
          "partial": "Types",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Types.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Types",
          "name": "Constraint",
          "package": "libcspm",
          "source": "src/CSPM-DataStructures-Types.html#Constraint",
          "type": "data"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Types",
          "module": "CSPM.DataStructures.Types",
          "name": "Constraint",
          "package": "libcspm",
          "partial": "Constraint",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Types.html#t:Constraint"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Types",
          "name": "PSymbolTable",
          "package": "libcspm",
          "source": "src/CSPM-DataStructures-Types.html#PSymbolTable",
          "type": "type"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Types",
          "module": "CSPM.DataStructures.Types",
          "name": "PSymbolTable",
          "package": "libcspm",
          "partial": "PSymbol Table",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Types.html#t:PSymbolTable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Types",
          "name": "PType",
          "package": "libcspm",
          "source": "src/CSPM-DataStructures-Types.html#PType",
          "type": "type"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Types",
          "module": "CSPM.DataStructures.Types",
          "name": "PType",
          "package": "libcspm",
          "partial": "PType",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Types.html#t:PType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Types",
          "name": "SymbolTable",
          "package": "libcspm",
          "source": "src/CSPM-DataStructures-Types.html#SymbolTable",
          "type": "type"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Types",
          "module": "CSPM.DataStructures.Types",
          "name": "SymbolTable",
          "package": "libcspm",
          "partial": "Symbol Table",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Types.html#t:SymbolTable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Types",
          "name": "Type",
          "package": "libcspm",
          "source": "src/CSPM-DataStructures-Types.html#Type",
          "type": "data"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Types",
          "module": "CSPM.DataStructures.Types",
          "name": "Type",
          "package": "libcspm",
          "partial": "Type",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Types.html#t:Type"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Types",
          "name": "TypeScheme",
          "package": "libcspm",
          "source": "src/CSPM-DataStructures-Types.html#TypeScheme",
          "type": "data"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Types",
          "module": "CSPM.DataStructures.Types",
          "name": "TypeScheme",
          "package": "libcspm",
          "partial": "Type Scheme",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Types.html#t:TypeScheme"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Types",
          "name": "TypeVar",
          "package": "libcspm",
          "source": "src/CSPM-DataStructures-Types.html#TypeVar",
          "type": "data"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Types",
          "module": "CSPM.DataStructures.Types",
          "name": "TypeVar",
          "package": "libcspm",
          "partial": "Type Var",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Types.html#t:TypeVar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Types",
          "name": "TypeVarRef",
          "package": "libcspm",
          "source": "src/CSPM-DataStructures-Types.html#TypeVarRef",
          "type": "data"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Types",
          "module": "CSPM.DataStructures.Types",
          "name": "TypeVarRef",
          "package": "libcspm",
          "partial": "Type Var Ref",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Types.html#t:TypeVarRef"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eComparable for equality\n\u003c/p\u003e",
          "module": "CSPM.DataStructures.Types",
          "name": "CEq",
          "package": "libcspm",
          "signature": "CEq",
          "source": "src/CSPM-DataStructures-Types.html#Constraint",
          "type": "function"
        },
        "index": {
          "description": "Comparable for equality",
          "hierarchy": "CSPM DataStructures Types",
          "module": "CSPM.DataStructures.Types",
          "name": "CEq",
          "package": "libcspm",
          "partial": "CEq",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Types.html#v:CEq"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCan be input on a channel\n\u003c/p\u003e",
          "module": "CSPM.DataStructures.Types",
          "name": "CInputable",
          "package": "libcspm",
          "signature": "CInputable",
          "source": "src/CSPM-DataStructures-Types.html#Constraint",
          "type": "function"
        },
        "index": {
          "description": "Can be input on channel",
          "hierarchy": "CSPM DataStructures Types",
          "module": "CSPM.DataStructures.Types",
          "name": "CInputable",
          "package": "libcspm",
          "partial": "CInputable",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Types.html#v:CInputable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eOrderable\n\u003c/p\u003e",
          "module": "CSPM.DataStructures.Types",
          "name": "COrd",
          "package": "libcspm",
          "signature": "COrd",
          "source": "src/CSPM-DataStructures-Types.html#Constraint",
          "type": "function"
        },
        "index": {
          "description": "Orderable",
          "hierarchy": "CSPM DataStructures Types",
          "module": "CSPM.DataStructures.Types",
          "name": "COrd",
          "package": "libcspm",
          "partial": "COrd",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Types.html#v:COrd"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCan form sets of the type.\n\u003c/p\u003e",
          "module": "CSPM.DataStructures.Types",
          "name": "CSet",
          "package": "libcspm",
          "signature": "CSet",
          "source": "src/CSPM-DataStructures-Types.html#Constraint",
          "type": "function"
        },
        "index": {
          "description": "Can form sets of the type",
          "hierarchy": "CSPM DataStructures Types",
          "module": "CSPM.DataStructures.Types",
          "name": "CSet",
          "package": "libcspm",
          "partial": "CSet",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Types.html#v:CSet"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIs something that can be yielded on the right hand side of =\u003e.\n\u003c/p\u003e",
          "module": "CSPM.DataStructures.Types",
          "name": "CYieldable",
          "package": "libcspm",
          "signature": "CYieldable",
          "source": "src/CSPM-DataStructures-Types.html#Constraint",
          "type": "function"
        },
        "index": {
          "description": "Is something that can be yielded on the right hand side of",
          "hierarchy": "CSPM DataStructures Types",
          "module": "CSPM.DataStructures.Types",
          "name": "CYieldable",
          "package": "libcspm",
          "partial": "CYieldable",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Types.html#v:CYieldable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Types",
          "name": "ForAll",
          "package": "libcspm",
          "signature": "ForAll",
          "source": "src/CSPM-DataStructures-Types.html#TypeScheme",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Types",
          "module": "CSPM.DataStructures.Types",
          "name": "ForAll",
          "package": "libcspm",
          "partial": "For All",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Types.html#v:ForAll"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Types",
          "name": "RigidTypeVarRef",
          "package": "libcspm",
          "signature": "RigidTypeVarRef",
          "source": "src/CSPM-DataStructures-Types.html#TypeVarRef",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Types",
          "module": "CSPM.DataStructures.Types",
          "name": "RigidTypeVarRef",
          "package": "libcspm",
          "partial": "Rigid Type Var Ref",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Types.html#v:RigidTypeVarRef"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Types",
          "name": "TBool",
          "package": "libcspm",
          "signature": "TBool",
          "source": "src/CSPM-DataStructures-Types.html#Type",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Types",
          "module": "CSPM.DataStructures.Types",
          "name": "TBool",
          "package": "libcspm",
          "partial": "TBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Types.html#v:TBool"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Types",
          "name": "TChar",
          "package": "libcspm",
          "signature": "TChar",
          "source": "src/CSPM-DataStructures-Types.html#Type",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Types",
          "module": "CSPM.DataStructures.Types",
          "name": "TChar",
          "package": "libcspm",
          "partial": "TChar",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Types.html#v:TChar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Types",
          "name": "TDatatype",
          "package": "libcspm",
          "signature": "TDatatype Name",
          "source": "src/CSPM-DataStructures-Types.html#Type",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Types",
          "module": "CSPM.DataStructures.Types",
          "name": "TDatatype",
          "package": "libcspm",
          "partial": "TDatatype",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Types.html#v:TDatatype"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Types",
          "name": "TDot",
          "package": "libcspm",
          "signature": "TDot Type Type",
          "source": "src/CSPM-DataStructures-Types.html#Type",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Types",
          "module": "CSPM.DataStructures.Types",
          "name": "TDot",
          "package": "libcspm",
          "partial": "TDot",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Types.html#v:TDot"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Types",
          "name": "TDotable",
          "package": "libcspm",
          "signature": "TDotable Type Type",
          "source": "src/CSPM-DataStructures-Types.html#Type",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Types",
          "module": "CSPM.DataStructures.Types",
          "name": "TDotable",
          "package": "libcspm",
          "partial": "TDotable",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Types.html#v:TDotable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Types",
          "name": "TEvent",
          "package": "libcspm",
          "signature": "TEvent",
          "source": "src/CSPM-DataStructures-Types.html#Type",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Types",
          "module": "CSPM.DataStructures.Types",
          "name": "TEvent",
          "package": "libcspm",
          "partial": "TEvent",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Types.html#v:TEvent"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSomething that can be extended via some means to a given type.\n\u003c/p\u003e\u003cp\u003eAfter type-checking, the TypeVarRef will simply be a variable that\n contains Nothing. This means that it can be converted into an explicit\n TDotable via some unknown means, or directly to the return type.\n\u003c/p\u003e\u003cp\u003eThe variable argument here has a slightly special role during\n unification. If it contains Nothing then this is extendable via some\n unknown means to the specified type. If it contains a TDotable argt rt,\n then we know that one of the arguments is argt, and the remaining\n arguments are rt, which must either be a Dotable or a variable. The\n meaning in the former sense is recursive, the meaning in the latter case\n is clear. If it contains  TVar tvref, then this means tvref has replaced\n this argument variable.\n\u003c/p\u003e\u003cp\u003eWe need to do the above as we may have multiple things that are\n extendable in the same way, so we need to sync the arguments together.\n\u003c/p\u003e",
          "module": "CSPM.DataStructures.Types",
          "name": "TExtendable",
          "package": "libcspm",
          "signature": "TExtendable",
          "source": "src/CSPM-DataStructures-Types.html#Type",
          "type": "function"
        },
        "index": {
          "description": "Something that can be extended via some means to given type After type-checking the TypeVarRef will simply be variable that contains Nothing This means that it can be converted into an explicit TDotable via some unknown means or directly to the return type The variable argument here has slightly special role during unification If it contains Nothing then this is extendable via some unknown means to the specified type If it contains TDotable argt rt then we know that one of the arguments is argt and the remaining arguments are rt which must either be Dotable or variable The meaning in the former sense is recursive the meaning in the latter case is clear If it contains TVar tvref then this means tvref has replaced this argument variable We need to do the above as we may have multiple things that are extendable in the same way so we need to sync the arguments together",
          "hierarchy": "CSPM DataStructures Types",
          "module": "CSPM.DataStructures.Types",
          "name": "TExtendable",
          "package": "libcspm",
          "partial": "TExtendable",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Types.html#v:TExtendable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis type is used only during type-checking, and is guaranteed to only\n ever appear at the top-level of the left-hand side of a TExtendable.\n\u003c/p\u003e",
          "module": "CSPM.DataStructures.Types",
          "name": "TExtendableEmptyDotList",
          "package": "libcspm",
          "signature": "TExtendableEmptyDotList",
          "source": "src/CSPM-DataStructures-Types.html#Type",
          "type": "function"
        },
        "index": {
          "description": "This type is used only during type-checking and is guaranteed to only ever appear at the top-level of the left-hand side of TExtendable",
          "hierarchy": "CSPM DataStructures Types",
          "module": "CSPM.DataStructures.Types",
          "name": "TExtendableEmptyDotList",
          "package": "libcspm",
          "partial": "TExtendable Empty Dot List",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Types.html#v:TExtendableEmptyDotList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Types",
          "name": "TFunction",
          "package": "libcspm",
          "signature": "TFunction [Type] Type",
          "source": "src/CSPM-DataStructures-Types.html#Type",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Types",
          "module": "CSPM.DataStructures.Types",
          "name": "TFunction",
          "normalized": "TFunction[Type]Type",
          "package": "libcspm",
          "partial": "TFunction",
          "signature": "TFunction[Type]Type",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Types.html#v:TFunction"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Types",
          "name": "TInt",
          "package": "libcspm",
          "signature": "TInt",
          "source": "src/CSPM-DataStructures-Types.html#Type",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Types",
          "module": "CSPM.DataStructures.Types",
          "name": "TInt",
          "package": "libcspm",
          "partial": "TInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Types.html#v:TInt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Types",
          "name": "TMap",
          "package": "libcspm",
          "signature": "TMap",
          "source": "src/CSPM-DataStructures-Types.html#Type",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Types",
          "module": "CSPM.DataStructures.Types",
          "name": "TMap",
          "package": "libcspm",
          "partial": "TMap",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Types.html#v:TMap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Types",
          "name": "TProc",
          "package": "libcspm",
          "signature": "TProc",
          "source": "src/CSPM-DataStructures-Types.html#Type",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Types",
          "module": "CSPM.DataStructures.Types",
          "name": "TProc",
          "package": "libcspm",
          "partial": "TProc",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Types.html#v:TProc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Types",
          "name": "TSeq",
          "package": "libcspm",
          "signature": "TSeq Type",
          "source": "src/CSPM-DataStructures-Types.html#Type",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Types",
          "module": "CSPM.DataStructures.Types",
          "name": "TSeq",
          "package": "libcspm",
          "partial": "TSeq",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Types.html#v:TSeq"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Types",
          "name": "TSet",
          "package": "libcspm",
          "signature": "TSet Type",
          "source": "src/CSPM-DataStructures-Types.html#Type",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Types",
          "module": "CSPM.DataStructures.Types",
          "name": "TSet",
          "package": "libcspm",
          "partial": "TSet",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Types.html#v:TSet"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Types",
          "name": "TTuple",
          "package": "libcspm",
          "signature": "TTuple [Type]",
          "source": "src/CSPM-DataStructures-Types.html#Type",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Types",
          "module": "CSPM.DataStructures.Types",
          "name": "TTuple",
          "normalized": "TTuple[Type]",
          "package": "libcspm",
          "partial": "TTuple",
          "signature": "TTuple[Type]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Types.html#v:TTuple"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Types",
          "name": "TVar",
          "package": "libcspm",
          "signature": "TVar TypeVarRef",
          "source": "src/CSPM-DataStructures-Types.html#Type",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Types",
          "module": "CSPM.DataStructures.Types",
          "name": "TVar",
          "package": "libcspm",
          "partial": "TVar",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Types.html#v:TVar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Types",
          "name": "TypeVarRef",
          "package": "libcspm",
          "signature": "TypeVarRef",
          "source": "src/CSPM-DataStructures-Types.html#TypeVarRef",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Types",
          "module": "CSPM.DataStructures.Types",
          "name": "TypeVarRef",
          "package": "libcspm",
          "partial": "Type Var Ref",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Types.html#v:TypeVarRef"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Types",
          "name": "collectConstraints",
          "package": "libcspm",
          "signature": "Type -\u003e [(TypeVarRef, [Constraint])]",
          "source": "src/CSPM-DataStructures-Types.html#collectConstraints",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Types",
          "module": "CSPM.DataStructures.Types",
          "name": "collectConstraints",
          "normalized": "Type-\u003e[(TypeVarRef,[Constraint])]",
          "package": "libcspm",
          "partial": "Constraints",
          "signature": "Type-\u003e[(TypeVarRef,[Constraint])]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Types.html#v:collectConstraints"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Types",
          "name": "constraintImpliedBy",
          "package": "libcspm",
          "signature": "Constraint -\u003e Constraint -\u003e Bool",
          "source": "src/CSPM-DataStructures-Types.html#constraintImpliedBy",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Types",
          "module": "CSPM.DataStructures.Types",
          "name": "constraintImpliedBy",
          "normalized": "Constraint-\u003eConstraint-\u003eBool",
          "package": "libcspm",
          "partial": "Implied By",
          "signature": "Constraint-\u003eConstraint-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Types.html#v:constraintImpliedBy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Types",
          "name": "constraints",
          "package": "libcspm",
          "signature": "[Constraint]",
          "source": "src/CSPM-DataStructures-Types.html#TypeVarRef",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Types",
          "module": "CSPM.DataStructures.Types",
          "name": "constraints",
          "normalized": "[Constraint]",
          "package": "libcspm",
          "signature": "[Constraint]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Types.html#v:constraints"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Types",
          "name": "extendableArgument",
          "package": "libcspm",
          "signature": "TypeVarRef",
          "source": "src/CSPM-DataStructures-Types.html#Type",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Types",
          "module": "CSPM.DataStructures.Types",
          "name": "extendableArgument",
          "package": "libcspm",
          "partial": "Argument",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Types.html#v:extendableArgument"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Types",
          "name": "extendableUltimateType",
          "package": "libcspm",
          "signature": "Type",
          "source": "src/CSPM-DataStructures-Types.html#Type",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Types",
          "module": "CSPM.DataStructures.Types",
          "name": "extendableUltimateType",
          "package": "libcspm",
          "partial": "Ultimate Type",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Types.html#v:extendableUltimateType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Types",
          "name": "freshPSymbolTable",
          "package": "libcspm",
          "signature": "m PSymbolTable",
          "source": "src/CSPM-DataStructures-Types.html#freshPSymbolTable",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Types",
          "module": "CSPM.DataStructures.Types",
          "name": "freshPSymbolTable",
          "package": "libcspm",
          "partial": "PSymbol Table",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Types.html#v:freshPSymbolTable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Types",
          "name": "freshPType",
          "package": "libcspm",
          "signature": "m PType",
          "source": "src/CSPM-DataStructures-Types.html#freshPType",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Types",
          "module": "CSPM.DataStructures.Types",
          "name": "freshPType",
          "package": "libcspm",
          "partial": "PType",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Types.html#v:freshPType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Types",
          "name": "freshRigidTypeVarWithConstraints",
          "package": "libcspm",
          "signature": "Name -\u003e [Constraint] -\u003e m Type",
          "source": "src/CSPM-DataStructures-Types.html#freshRigidTypeVarWithConstraints",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Types",
          "module": "CSPM.DataStructures.Types",
          "name": "freshRigidTypeVarWithConstraints",
          "normalized": "Name-\u003e[Constraint]-\u003ea Type",
          "package": "libcspm",
          "partial": "Rigid Type Var With Constraints",
          "signature": "Name-\u003e[Constraint]-\u003em Type",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Types.html#v:freshRigidTypeVarWithConstraints"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"CSPM.DataStructures.Types\",\"CSPM.TypeChecker.Monad\"]",
          "name": "freshTypeVar",
          "package": "libcspm",
          "signature": "m Type",
          "source": "src/CSPM-DataStructures-Types.html#freshTypeVar",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Types.html#v:freshTypeVar\",\"http://hackage.haskell.org/package/libcspm/docs/CSPM-TypeChecker-Monad.html#v:freshTypeVar\"]"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Types",
          "module": "CSPM.DataStructures.Types",
          "name": "freshTypeVar",
          "package": "libcspm",
          "partial": "Type Var",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Types.html#v:freshTypeVar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Types",
          "name": "freshTypeVarRef",
          "package": "libcspm",
          "signature": "[Constraint] -\u003e m TypeVarRef",
          "source": "src/CSPM-DataStructures-Types.html#freshTypeVarRef",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Types",
          "module": "CSPM.DataStructures.Types",
          "name": "freshTypeVarRef",
          "normalized": "[Constraint]-\u003ea TypeVarRef",
          "package": "libcspm",
          "partial": "Type Var Ref",
          "signature": "[Constraint]-\u003em TypeVarRef",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Types.html#v:freshTypeVarRef"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"CSPM.DataStructures.Types\",\"CSPM.TypeChecker.Monad\"]",
          "name": "freshTypeVarWithConstraints",
          "package": "libcspm",
          "signature": "[Constraint] -\u003e m Type",
          "source": "src/CSPM-DataStructures-Types.html#freshTypeVarWithConstraints",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Types.html#v:freshTypeVarWithConstraints\",\"http://hackage.haskell.org/package/libcspm/docs/CSPM-TypeChecker-Monad.html#v:freshTypeVarWithConstraints\"]"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Types",
          "module": "CSPM.DataStructures.Types",
          "name": "freshTypeVarWithConstraints",
          "normalized": "[Constraint]-\u003ea Type",
          "package": "libcspm",
          "partial": "Type Var With Constraints",
          "signature": "[Constraint]-\u003em Type",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Types.html#v:freshTypeVarWithConstraints"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Types",
          "name": "isRigid",
          "package": "libcspm",
          "signature": "TypeVarRef -\u003e Bool",
          "source": "src/CSPM-DataStructures-Types.html#isRigid",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Types",
          "module": "CSPM.DataStructures.Types",
          "name": "isRigid",
          "normalized": "TypeVarRef-\u003eBool",
          "package": "libcspm",
          "partial": "Rigid",
          "signature": "TypeVarRef-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Types.html#v:isRigid"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Types",
          "name": "mapKeyType",
          "package": "libcspm",
          "signature": "Type",
          "source": "src/CSPM-DataStructures-Types.html#Type",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Types",
          "module": "CSPM.DataStructures.Types",
          "name": "mapKeyType",
          "package": "libcspm",
          "partial": "Key Type",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Types.html#v:mapKeyType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Types",
          "name": "mapValueType",
          "package": "libcspm",
          "signature": "Type",
          "source": "src/CSPM-DataStructures-Types.html#Type",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Types",
          "module": "CSPM.DataStructures.Types",
          "name": "mapValueType",
          "package": "libcspm",
          "partial": "Value Type",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Types.html#v:mapValueType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePretty prints several types using the same variable substitutions\n\u003c/p\u003e",
          "module": "CSPM.DataStructures.Types",
          "name": "prettyPrintTypes",
          "package": "libcspm",
          "signature": "[Type] -\u003e [Doc]",
          "source": "src/CSPM-DataStructures-Types.html#prettyPrintTypes",
          "type": "function"
        },
        "index": {
          "description": "Pretty prints several types using the same variable substitutions",
          "hierarchy": "CSPM DataStructures Types",
          "module": "CSPM.DataStructures.Types",
          "name": "prettyPrintTypes",
          "normalized": "[Type]-\u003e[Doc]",
          "package": "libcspm",
          "partial": "Print Types",
          "signature": "[Type]-\u003e[Doc]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Types.html#v:prettyPrintTypes"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Types",
          "name": "readPSymbolTable",
          "package": "libcspm",
          "signature": "PSymbolTable -\u003e m SymbolTable",
          "source": "src/CSPM-DataStructures-Types.html#readPSymbolTable",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Types",
          "module": "CSPM.DataStructures.Types",
          "name": "readPSymbolTable",
          "normalized": "PSymbolTable-\u003ea SymbolTable",
          "package": "libcspm",
          "partial": "PSymbol Table",
          "signature": "PSymbolTable-\u003em SymbolTable",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Types.html#v:readPSymbolTable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Types",
          "name": "readPType",
          "package": "libcspm",
          "signature": "PType -\u003e m (Maybe Type)",
          "source": "src/CSPM-DataStructures-Types.html#readPType",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Types",
          "module": "CSPM.DataStructures.Types",
          "name": "readPType",
          "normalized": "PType-\u003ea(Maybe Type)",
          "package": "libcspm",
          "partial": "PType",
          "signature": "PType-\u003em(Maybe Type)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Types.html#v:readPType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Types",
          "name": "reduceConstraints",
          "package": "libcspm",
          "signature": "[Constraint] -\u003e [Constraint]",
          "source": "src/CSPM-DataStructures-Types.html#reduceConstraints",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Types",
          "module": "CSPM.DataStructures.Types",
          "name": "reduceConstraints",
          "normalized": "[Constraint]-\u003e[Constraint]",
          "package": "libcspm",
          "partial": "Constraints",
          "signature": "[Constraint]-\u003e[Constraint]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Types.html#v:reduceConstraints"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Types",
          "name": "rigidName",
          "package": "libcspm",
          "signature": "Name",
          "source": "src/CSPM-DataStructures-Types.html#TypeVarRef",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Types",
          "module": "CSPM.DataStructures.Types",
          "name": "rigidName",
          "package": "libcspm",
          "partial": "Name",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Types.html#v:rigidName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Types",
          "name": "setPSymbolTable",
          "package": "libcspm",
          "signature": "PSymbolTable -\u003e SymbolTable -\u003e m ()",
          "source": "src/CSPM-DataStructures-Types.html#setPSymbolTable",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Types",
          "module": "CSPM.DataStructures.Types",
          "name": "setPSymbolTable",
          "normalized": "PSymbolTable-\u003eSymbolTable-\u003ea()",
          "package": "libcspm",
          "partial": "PSymbol Table",
          "signature": "PSymbolTable-\u003eSymbolTable-\u003em()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Types.html#v:setPSymbolTable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Types",
          "name": "setPType",
          "package": "libcspm",
          "signature": "PType -\u003e Type -\u003e m ()",
          "source": "src/CSPM-DataStructures-Types.html#setPType",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Types",
          "module": "CSPM.DataStructures.Types",
          "name": "setPType",
          "normalized": "PType-\u003eType-\u003ea()",
          "package": "libcspm",
          "partial": "PType",
          "signature": "PType-\u003eType-\u003em()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Types.html#v:setPType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Types",
          "name": "typePointer",
          "package": "libcspm",
          "signature": "PType",
          "source": "src/CSPM-DataStructures-Types.html#TypeVarRef",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Types",
          "module": "CSPM.DataStructures.Types",
          "name": "typePointer",
          "package": "libcspm",
          "partial": "Pointer",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Types.html#v:typePointer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Types",
          "name": "typeSchemeType",
          "package": "libcspm",
          "signature": "Type",
          "source": "src/CSPM-DataStructures-Types.html#TypeScheme",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Types",
          "module": "CSPM.DataStructures.Types",
          "name": "typeSchemeType",
          "package": "libcspm",
          "partial": "Scheme Type",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Types.html#v:typeSchemeType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Types",
          "name": "typeSchemeVariables",
          "package": "libcspm",
          "signature": "[(TypeVar, [Constraint])]",
          "source": "src/CSPM-DataStructures-Types.html#TypeScheme",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Types",
          "module": "CSPM.DataStructures.Types",
          "name": "typeSchemeVariables",
          "normalized": "[(TypeVar,[Constraint])]",
          "package": "libcspm",
          "partial": "Scheme Variables",
          "signature": "[(TypeVar,[Constraint])]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Types.html#v:typeSchemeVariables"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.DataStructures.Types",
          "name": "typeVar",
          "package": "libcspm",
          "signature": "TypeVar",
          "source": "src/CSPM-DataStructures-Types.html#TypeVarRef",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM DataStructures Types",
          "module": "CSPM.DataStructures.Types",
          "name": "typeVar",
          "package": "libcspm",
          "partial": "Var",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-DataStructures-Types.html#v:typeVar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Desugar",
          "name": "Desugar",
          "package": "libcspm",
          "source": "src/CSPM-Desugar.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "CSPM Desugar",
          "module": "CSPM.Desugar",
          "name": "Desugar",
          "package": "libcspm",
          "partial": "Desugar",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Desugar.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Desugar",
          "name": "Desugarable",
          "package": "libcspm",
          "source": "src/CSPM-Desugar.html#Desugarable",
          "type": "class"
        },
        "index": {
          "hierarchy": "CSPM Desugar",
          "module": "CSPM.Desugar",
          "name": "Desugarable",
          "package": "libcspm",
          "partial": "Desugarable",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Desugar.html#t:Desugarable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Desugar",
          "name": "desugar",
          "package": "libcspm",
          "signature": "a -\u003e DesugarMonad a",
          "source": "src/CSPM-Desugar.html#desugar",
          "type": "method"
        },
        "index": {
          "hierarchy": "CSPM Desugar",
          "module": "CSPM.Desugar",
          "name": "desugar",
          "normalized": "a-\u003eDesugarMonad a",
          "package": "libcspm",
          "signature": "a-\u003eDesugarMonad a",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Desugar.html#v:desugar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Desugar",
          "name": "runDesugar",
          "package": "libcspm",
          "signature": "DesugarMonad a -\u003e m a",
          "source": "src/CSPM-Desugar.html#runDesugar",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Desugar",
          "module": "CSPM.Desugar",
          "name": "runDesugar",
          "normalized": "DesugarMonad a-\u003eb a",
          "package": "libcspm",
          "partial": "Desugar",
          "signature": "DesugarMonad a-\u003em a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Desugar.html#v:runDesugar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Evaluator.BuiltInFunctions",
          "name": "BuiltInFunctions",
          "package": "libcspm",
          "source": "src/CSPM-Evaluator-BuiltInFunctions.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "CSPM Evaluator BuiltInFunctions",
          "module": "CSPM.Evaluator.BuiltInFunctions",
          "name": "BuiltInFunctions",
          "package": "libcspm",
          "partial": "Built In Functions",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-BuiltInFunctions.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"CSPM.Evaluator.BuiltInFunctions\",\"CSPM.Prelude\"]",
          "name": "builtInName",
          "package": "libcspm",
          "signature": "String -\u003e Name",
          "source": "src/CSPM-Prelude.html#builtInName",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-BuiltInFunctions.html#v:builtInName\",\"http://hackage.haskell.org/package/libcspm/docs/CSPM-Prelude.html#v:builtInName\"]"
        },
        "index": {
          "hierarchy": "CSPM Evaluator BuiltInFunctions",
          "module": "CSPM.Evaluator.BuiltInFunctions",
          "name": "builtInName",
          "normalized": "String-\u003eName",
          "package": "libcspm",
          "partial": "In Name",
          "signature": "String-\u003eName",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-BuiltInFunctions.html#v:builtInName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Evaluator.BuiltInFunctions",
          "name": "injectBuiltInFunctions",
          "package": "libcspm",
          "signature": "EvaluationMonad a -\u003e EvaluationMonad a",
          "source": "src/CSPM-Evaluator-BuiltInFunctions.html#injectBuiltInFunctions",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Evaluator BuiltInFunctions",
          "module": "CSPM.Evaluator.BuiltInFunctions",
          "name": "injectBuiltInFunctions",
          "normalized": "EvaluationMonad a-\u003eEvaluationMonad a",
          "package": "libcspm",
          "partial": "Built In Functions",
          "signature": "EvaluationMonad a-\u003eEvaluationMonad a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-BuiltInFunctions.html#v:injectBuiltInFunctions"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Evaluator.DeclBind",
          "name": "DeclBind",
          "package": "libcspm",
          "source": "src/CSPM-Evaluator-DeclBind.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "CSPM Evaluator DeclBind",
          "module": "CSPM.Evaluator.DeclBind",
          "name": "DeclBind",
          "package": "libcspm",
          "partial": "Decl Bind",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-DeclBind.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGiven a list of declarations, returns a sequence of names bounds to\n values that can be passed to \u003ccode\u003e\u003ca\u003eaddScopeAndBind\u003c/a\u003e\u003c/code\u003e in order to bind them in\n the current scope.\n\u003c/p\u003e",
          "module": "CSPM.Evaluator.DeclBind",
          "name": "bindDecls",
          "package": "libcspm",
          "signature": "[TCDecl] -\u003e EvaluationMonad [(Name, EvaluationMonad Value)]",
          "source": "src/CSPM-Evaluator-DeclBind.html#bindDecls",
          "type": "function"
        },
        "index": {
          "description": "Given list of declarations returns sequence of names bounds to values that can be passed to addScopeAndBind in order to bind them in the current scope",
          "hierarchy": "CSPM Evaluator DeclBind",
          "module": "CSPM.Evaluator.DeclBind",
          "name": "bindDecls",
          "normalized": "[TCDecl]-\u003eEvaluationMonad[(Name,EvaluationMonad Value)]",
          "package": "libcspm",
          "partial": "Decls",
          "signature": "[TCDecl]-\u003eEvaluationMonad[(Name,EvaluationMonad Value)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-DeclBind.html#v:bindDecls"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Evaluator.DeepSeq",
          "name": "DeepSeq",
          "package": "libcspm",
          "source": "src/CSPM-Evaluator-DeepSeq.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "CSPM Evaluator DeepSeq",
          "module": "CSPM.Evaluator.DeepSeq",
          "name": "DeepSeq",
          "package": "libcspm",
          "partial": "Deep Seq",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-DeepSeq.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Evaluator.Dot",
          "name": "Dot",
          "package": "libcspm",
          "source": "src/CSPM-Evaluator-Dot.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "CSPM Evaluator Dot",
          "module": "CSPM.Evaluator.Dot",
          "name": "Dot",
          "package": "libcspm",
          "partial": "Dot",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-Dot.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTakes two values and dots then together appropriately.\n\u003c/p\u003e",
          "module": "CSPM.Evaluator.Dot",
          "name": "combineDots",
          "package": "libcspm",
          "signature": "Value -\u003e Value -\u003e EvaluationMonad Value",
          "source": "src/CSPM-Evaluator-Dot.html#combineDots",
          "type": "function"
        },
        "index": {
          "description": "Takes two values and dots then together appropriately",
          "hierarchy": "CSPM Evaluator Dot",
          "module": "CSPM.Evaluator.Dot",
          "name": "combineDots",
          "normalized": "Value-\u003eValue-\u003eEvaluationMonad Value",
          "package": "libcspm",
          "partial": "Dots",
          "signature": "Value-\u003eValue-\u003eEvaluationMonad Value",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-Dot.html#v:combineDots"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTakes a set and returns a list of values xs such that \n Union({productions(x) | x \u003c- xs}) == xs. For example, if c is a channel of\n type {0,1} then {c.0, c.1} would return [c].\n\u003c/p\u003e\u003cp\u003eThis is primarily used for display purposes.\n\u003c/p\u003e",
          "module": "CSPM.Evaluator.Dot",
          "name": "compressIntoEnumeratedSet",
          "package": "libcspm",
          "signature": "ValueSet -\u003e EvaluationMonad (Maybe [Value])",
          "source": "src/CSPM-Evaluator-Dot.html#compressIntoEnumeratedSet",
          "type": "function"
        },
        "index": {
          "description": "Takes set and returns list of values xs such that Union productions xs xs For example if is channel of type then c.0 c.1 would return This is primarily used for display purposes",
          "hierarchy": "CSPM Evaluator Dot",
          "module": "CSPM.Evaluator.Dot",
          "name": "compressIntoEnumeratedSet",
          "normalized": "ValueSet-\u003eEvaluationMonad(Maybe[Value])",
          "package": "libcspm",
          "partial": "Into Enumerated Set",
          "signature": "ValueSet-\u003eEvaluationMonad(Maybe[Value])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-Dot.html#v:compressIntoEnumeratedSet"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Evaluator.Dot",
          "name": "dataTypeInfo",
          "package": "libcspm",
          "signature": "Name -\u003e EvaluationMonad (Value, Int, Array Int ValueSet)",
          "source": "src/CSPM-Evaluator-Dot.html#dataTypeInfo",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Evaluator Dot",
          "module": "CSPM.Evaluator.Dot",
          "name": "dataTypeInfo",
          "normalized": "Name-\u003eEvaluationMonad(Value,Int,Array Int ValueSet)",
          "package": "libcspm",
          "partial": "Type Info",
          "signature": "Name-\u003eEvaluationMonad(Value,Int,Array Int ValueSet)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-Dot.html#v:dataTypeInfo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTakes a datatype or a channel value and then computes all x such that \n ev.x is a full datatype/event. Each of the returned values is guaranteed\n to be a VDot.\n\u003c/p\u003e",
          "module": "CSPM.Evaluator.Dot",
          "name": "extensions",
          "package": "libcspm",
          "signature": "Value -\u003e EvaluationMonad [Value]",
          "source": "src/CSPM-Evaluator-Dot.html#extensions",
          "type": "function"
        },
        "index": {
          "description": "Takes datatype or channel value and then computes all such that ev.x is full datatype event Each of the returned values is guaranteed to be VDot",
          "hierarchy": "CSPM Evaluator Dot",
          "module": "CSPM.Evaluator.Dot",
          "name": "extensions",
          "normalized": "Value-\u003eEvaluationMonad[Value]",
          "package": "libcspm",
          "signature": "Value-\u003eEvaluationMonad[Value]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-Dot.html#v:extensions"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Evaluator.Dot",
          "name": "extensionsSet",
          "package": "libcspm",
          "signature": "Value -\u003e EvaluationMonad ValueSet",
          "source": "src/CSPM-Evaluator-Dot.html#extensionsSet",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Evaluator Dot",
          "module": "CSPM.Evaluator.Dot",
          "name": "extensionsSet",
          "normalized": "Value-\u003eEvaluationMonad ValueSet",
          "package": "libcspm",
          "partial": "Set",
          "signature": "Value-\u003eEvaluationMonad ValueSet",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-Dot.html#v:extensionsSet"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturns an x such that ev.x has been extended by exactly one atomic field.\n This could be inside a subfield or elsewhere.\n\u003c/p\u003e",
          "module": "CSPM.Evaluator.Dot",
          "name": "oneFieldExtensions",
          "package": "libcspm",
          "signature": "Value -\u003e EvaluationMonad [Value]",
          "source": "src/CSPM-Evaluator-Dot.html#oneFieldExtensions",
          "type": "function"
        },
        "index": {
          "description": "Returns an such that ev.x has been extended by exactly one atomic field This could be inside subfield or elsewhere",
          "hierarchy": "CSPM Evaluator Dot",
          "module": "CSPM.Evaluator.Dot",
          "name": "oneFieldExtensions",
          "normalized": "Value-\u003eEvaluationMonad[Value]",
          "package": "libcspm",
          "partial": "Field Extensions",
          "signature": "Value-\u003eEvaluationMonad[Value]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-Dot.html#v:oneFieldExtensions"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTakes a datatype or a channel value and computes v.x for all x that\n complete the value.\n\u003c/p\u003e",
          "module": "CSPM.Evaluator.Dot",
          "name": "productions",
          "package": "libcspm",
          "signature": "Value -\u003e EvaluationMonad [Value]",
          "source": "src/CSPM-Evaluator-Dot.html#productions",
          "type": "function"
        },
        "index": {
          "description": "Takes datatype or channel value and computes v.x for all that complete the value",
          "hierarchy": "CSPM Evaluator Dot",
          "module": "CSPM.Evaluator.Dot",
          "name": "productions",
          "normalized": "Value-\u003eEvaluationMonad[Value]",
          "package": "libcspm",
          "signature": "Value-\u003eEvaluationMonad[Value]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-Dot.html#v:productions"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Evaluator.Dot",
          "name": "productionsSet",
          "package": "libcspm",
          "signature": "Value -\u003e EvaluationMonad ValueSet",
          "source": "src/CSPM-Evaluator-Dot.html#productionsSet",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Evaluator Dot",
          "module": "CSPM.Evaluator.Dot",
          "name": "productionsSet",
          "normalized": "Value-\u003eEvaluationMonad ValueSet",
          "package": "libcspm",
          "partial": "Set",
          "signature": "Value-\u003eEvaluationMonad ValueSet",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-Dot.html#v:productionsSet"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTakes a set of dotted values (i.e. a set of VDot _) and returns a list of\n sets such that the cartesian product is equal to the original set.\n\u003c/p\u003e\u003cp\u003eThis throws an error if the set cannot be decomposed.\n\u003c/p\u003e",
          "module": "CSPM.Evaluator.Dot",
          "name": "splitIntoFields",
          "package": "libcspm",
          "signature": "Bool -\u003e Name -\u003e ValueSet -\u003e EvaluationMonad [ValueSet]",
          "source": "src/CSPM-Evaluator-Dot.html#splitIntoFields",
          "type": "function"
        },
        "index": {
          "description": "Takes set of dotted values i.e set of VDot and returns list of sets such that the cartesian product is equal to the original set This throws an error if the set cannot be decomposed",
          "hierarchy": "CSPM Evaluator Dot",
          "module": "CSPM.Evaluator.Dot",
          "name": "splitIntoFields",
          "normalized": "Bool-\u003eName-\u003eValueSet-\u003eEvaluationMonad[ValueSet]",
          "package": "libcspm",
          "partial": "Into Fields",
          "signature": "Bool-\u003eName-\u003eValueSet-\u003eEvaluationMonad[ValueSet]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-Dot.html#v:splitIntoFields"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Evaluator.Environment",
          "name": "Environment",
          "package": "libcspm",
          "source": "src/CSPM-Evaluator-Environment.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "CSPM Evaluator Environment",
          "module": "CSPM.Evaluator.Environment",
          "name": "Environment",
          "package": "libcspm",
          "partial": "Environment",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-Environment.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Evaluator.Environment",
          "name": "Environment",
          "package": "libcspm",
          "source": "src/CSPM-Evaluator-Environment.html#Environment",
          "type": "data"
        },
        "index": {
          "hierarchy": "CSPM Evaluator Environment",
          "module": "CSPM.Evaluator.Environment",
          "name": "Environment",
          "package": "libcspm",
          "partial": "Environment",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-Environment.html#t:Environment"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Evaluator.Environment",
          "name": "lookup",
          "package": "libcspm",
          "signature": "Environment -\u003e Name -\u003e Value",
          "source": "src/CSPM-Evaluator-Environment.html#lookup",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Evaluator Environment",
          "module": "CSPM.Evaluator.Environment",
          "name": "lookup",
          "normalized": "Environment-\u003eName-\u003eValue",
          "package": "libcspm",
          "signature": "Environment-\u003eName-\u003eValue",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-Environment.html#v:lookup"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Evaluator.Environment",
          "name": "new",
          "package": "libcspm",
          "signature": "Environment",
          "source": "src/CSPM-Evaluator-Environment.html#new",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Evaluator Environment",
          "module": "CSPM.Evaluator.Environment",
          "name": "new",
          "package": "libcspm",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-Environment.html#v:new"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Evaluator.Environment",
          "name": "newLayerAndBind",
          "package": "libcspm",
          "signature": "Environment -\u003e [(Name, Value)] -\u003e Environment",
          "source": "src/CSPM-Evaluator-Environment.html#newLayerAndBind",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Evaluator Environment",
          "module": "CSPM.Evaluator.Environment",
          "name": "newLayerAndBind",
          "normalized": "Environment-\u003e[(Name,Value)]-\u003eEnvironment",
          "package": "libcspm",
          "partial": "Layer And Bind",
          "signature": "Environment-\u003e[(Name,Value)]-\u003eEnvironment",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-Environment.html#v:newLayerAndBind"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Evaluator.Exceptions",
          "name": "Exceptions",
          "package": "libcspm",
          "source": "src/CSPM-Evaluator-Exceptions.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "CSPM Evaluator Exceptions",
          "module": "CSPM.Evaluator.Exceptions",
          "name": "Exceptions",
          "package": "libcspm",
          "partial": "Exceptions",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-Exceptions.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Evaluator.Exceptions",
          "name": "cannotCheckSetMembershipError",
          "package": "libcspm",
          "signature": "Value -\u003e ValueSet -\u003e ErrorMessage",
          "source": "src/CSPM-Evaluator-Exceptions.html#cannotCheckSetMembershipError",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Evaluator Exceptions",
          "module": "CSPM.Evaluator.Exceptions",
          "name": "cannotCheckSetMembershipError",
          "normalized": "Value-\u003eValueSet-\u003eErrorMessage",
          "package": "libcspm",
          "partial": "Check Set Membership Error",
          "signature": "Value-\u003eValueSet-\u003eErrorMessage",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-Exceptions.html#v:cannotCheckSetMembershipError"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Evaluator.Exceptions",
          "name": "cannotConvertIntegersToListMessage",
          "package": "libcspm",
          "signature": "ErrorMessage",
          "source": "src/CSPM-Evaluator-Exceptions.html#cannotConvertIntegersToListMessage",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Evaluator Exceptions",
          "module": "CSPM.Evaluator.Exceptions",
          "name": "cannotConvertIntegersToListMessage",
          "package": "libcspm",
          "partial": "Convert Integers To List Message",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-Exceptions.html#v:cannotConvertIntegersToListMessage"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Evaluator.Exceptions",
          "name": "cannotConvertProcessesToListMessage",
          "package": "libcspm",
          "signature": "ErrorMessage",
          "source": "src/CSPM-Evaluator-Exceptions.html#cannotConvertProcessesToListMessage",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Evaluator Exceptions",
          "module": "CSPM.Evaluator.Exceptions",
          "name": "cannotConvertProcessesToListMessage",
          "package": "libcspm",
          "partial": "Convert Processes To List Message",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-Exceptions.html#v:cannotConvertProcessesToListMessage"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Evaluator.Exceptions",
          "name": "cannotDifferenceSetsMessage",
          "package": "libcspm",
          "signature": "ValueSet -\u003e ValueSet -\u003e ErrorMessage",
          "source": "src/CSPM-Evaluator-Exceptions.html#cannotDifferenceSetsMessage",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Evaluator Exceptions",
          "module": "CSPM.Evaluator.Exceptions",
          "name": "cannotDifferenceSetsMessage",
          "normalized": "ValueSet-\u003eValueSet-\u003eErrorMessage",
          "package": "libcspm",
          "partial": "Difference Sets Message",
          "signature": "ValueSet-\u003eValueSet-\u003eErrorMessage",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-Exceptions.html#v:cannotDifferenceSetsMessage"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Evaluator.Exceptions",
          "name": "cardOfInfiniteSetMessage",
          "package": "libcspm",
          "signature": "ValueSet -\u003e ErrorMessage",
          "source": "src/CSPM-Evaluator-Exceptions.html#cardOfInfiniteSetMessage",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Evaluator Exceptions",
          "module": "CSPM.Evaluator.Exceptions",
          "name": "cardOfInfiniteSetMessage",
          "normalized": "ValueSet-\u003eErrorMessage",
          "package": "libcspm",
          "partial": "Of Infinite Set Message",
          "signature": "ValueSet-\u003eErrorMessage",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-Exceptions.html#v:cardOfInfiniteSetMessage"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Evaluator.Exceptions",
          "name": "divideByZeroMessage",
          "package": "libcspm",
          "signature": "SrcSpan -\u003e Maybe ScopeIdentifier -\u003e ErrorMessage",
          "source": "src/CSPM-Evaluator-Exceptions.html#divideByZeroMessage",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Evaluator Exceptions",
          "module": "CSPM.Evaluator.Exceptions",
          "name": "divideByZeroMessage",
          "normalized": "SrcSpan-\u003eMaybe ScopeIdentifier-\u003eErrorMessage",
          "package": "libcspm",
          "partial": "By Zero Message",
          "signature": "SrcSpan-\u003eMaybe ScopeIdentifier-\u003eErrorMessage",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-Exceptions.html#v:divideByZeroMessage"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Evaluator.Exceptions",
          "name": "dotIsNotValidMessage",
          "package": "libcspm",
          "signature": "Value -\u003e Int -\u003e Value -\u003e ValueSet -\u003e SrcSpan -\u003e Maybe ScopeIdentifier -\u003e ErrorMessage",
          "source": "src/CSPM-Evaluator-Exceptions.html#dotIsNotValidMessage",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Evaluator Exceptions",
          "module": "CSPM.Evaluator.Exceptions",
          "name": "dotIsNotValidMessage",
          "normalized": "Value-\u003eInt-\u003eValue-\u003eValueSet-\u003eSrcSpan-\u003eMaybe ScopeIdentifier-\u003eErrorMessage",
          "package": "libcspm",
          "partial": "Is Not Valid Message",
          "signature": "Value-\u003eInt-\u003eValue-\u003eValueSet-\u003eSrcSpan-\u003eMaybe ScopeIdentifier-\u003eErrorMessage",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-Exceptions.html#v:dotIsNotValidMessage"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Evaluator.Exceptions",
          "name": "funBindPatternMatchFailureMessage",
          "package": "libcspm",
          "signature": "SrcSpan -\u003e Name -\u003e [[Value]] -\u003e ErrorMessage",
          "source": "src/CSPM-Evaluator-Exceptions.html#funBindPatternMatchFailureMessage",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Evaluator Exceptions",
          "module": "CSPM.Evaluator.Exceptions",
          "name": "funBindPatternMatchFailureMessage",
          "normalized": "SrcSpan-\u003eName-\u003e[[Value]]-\u003eErrorMessage",
          "package": "libcspm",
          "partial": "Bind Pattern Match Failure Message",
          "signature": "SrcSpan-\u003eName-\u003e[[Value]]-\u003eErrorMessage",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-Exceptions.html#v:funBindPatternMatchFailureMessage"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Evaluator.Exceptions",
          "name": "headEmptyListMessage",
          "package": "libcspm",
          "signature": "SrcSpan -\u003e Maybe ScopeIdentifier -\u003e ErrorMessage",
          "source": "src/CSPM-Evaluator-Exceptions.html#headEmptyListMessage",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Evaluator Exceptions",
          "module": "CSPM.Evaluator.Exceptions",
          "name": "headEmptyListMessage",
          "normalized": "SrcSpan-\u003eMaybe ScopeIdentifier-\u003eErrorMessage",
          "package": "libcspm",
          "partial": "Empty List Message",
          "signature": "SrcSpan-\u003eMaybe ScopeIdentifier-\u003eErrorMessage",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-Exceptions.html#v:headEmptyListMessage"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Evaluator.Exceptions",
          "name": "keyNotInDomainOfMapMessage",
          "package": "libcspm",
          "signature": "SrcSpan -\u003e Maybe ScopeIdentifier -\u003e ErrorMessage",
          "source": "src/CSPM-Evaluator-Exceptions.html#keyNotInDomainOfMapMessage",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Evaluator Exceptions",
          "module": "CSPM.Evaluator.Exceptions",
          "name": "keyNotInDomainOfMapMessage",
          "normalized": "SrcSpan-\u003eMaybe ScopeIdentifier-\u003eErrorMessage",
          "package": "libcspm",
          "partial": "Not In Domain Of Map Message",
          "signature": "SrcSpan-\u003eMaybe ScopeIdentifier-\u003eErrorMessage",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-Exceptions.html#v:keyNotInDomainOfMapMessage"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Evaluator.Exceptions",
          "name": "patternMatchFailureMessage",
          "package": "libcspm",
          "signature": "SrcSpan -\u003e TCPat -\u003e Value -\u003e ErrorMessage",
          "source": "src/CSPM-Evaluator-Exceptions.html#patternMatchFailureMessage",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Evaluator Exceptions",
          "module": "CSPM.Evaluator.Exceptions",
          "name": "patternMatchFailureMessage",
          "normalized": "SrcSpan-\u003eTCPat-\u003eValue-\u003eErrorMessage",
          "package": "libcspm",
          "partial": "Match Failure Message",
          "signature": "SrcSpan-\u003eTCPat-\u003eValue-\u003eErrorMessage",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-Exceptions.html#v:patternMatchFailureMessage"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Evaluator.Exceptions",
          "name": "patternMatchesFailureMessage",
          "package": "libcspm",
          "signature": "SrcSpan -\u003e [TCPat] -\u003e [Value] -\u003e ErrorMessage",
          "source": "src/CSPM-Evaluator-Exceptions.html#patternMatchesFailureMessage",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Evaluator Exceptions",
          "module": "CSPM.Evaluator.Exceptions",
          "name": "patternMatchesFailureMessage",
          "normalized": "SrcSpan-\u003e[TCPat]-\u003e[Value]-\u003eErrorMessage",
          "package": "libcspm",
          "partial": "Matches Failure Message",
          "signature": "SrcSpan-\u003e[TCPat]-\u003e[Value]-\u003eErrorMessage",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-Exceptions.html#v:patternMatchesFailureMessage"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Evaluator.Exceptions",
          "name": "printCallStack",
          "package": "libcspm",
          "signature": "Maybe ScopeIdentifier -\u003e Doc",
          "source": "src/CSPM-Evaluator-Exceptions.html#printCallStack",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Evaluator Exceptions",
          "module": "CSPM.Evaluator.Exceptions",
          "name": "printCallStack",
          "normalized": "Maybe ScopeIdentifier-\u003eDoc",
          "package": "libcspm",
          "partial": "Call Stack",
          "signature": "Maybe ScopeIdentifier-\u003eDoc",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-Exceptions.html#v:printCallStack"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Evaluator.Exceptions",
          "name": "prioritiseEmptyListMessage",
          "package": "libcspm",
          "signature": "SrcSpan -\u003e Maybe ScopeIdentifier -\u003e ErrorMessage",
          "source": "src/CSPM-Evaluator-Exceptions.html#prioritiseEmptyListMessage",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Evaluator Exceptions",
          "module": "CSPM.Evaluator.Exceptions",
          "name": "prioritiseEmptyListMessage",
          "normalized": "SrcSpan-\u003eMaybe ScopeIdentifier-\u003eErrorMessage",
          "package": "libcspm",
          "partial": "Empty List Message",
          "signature": "SrcSpan-\u003eMaybe ScopeIdentifier-\u003eErrorMessage",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-Exceptions.html#v:prioritiseEmptyListMessage"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Evaluator.Exceptions",
          "name": "replicatedInternalChoiceOverEmptySetMessage",
          "package": "libcspm",
          "signature": "Exp Name -\u003e SrcSpan -\u003e Maybe ScopeIdentifier -\u003e ErrorMessage",
          "source": "src/CSPM-Evaluator-Exceptions.html#replicatedInternalChoiceOverEmptySetMessage",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Evaluator Exceptions",
          "module": "CSPM.Evaluator.Exceptions",
          "name": "replicatedInternalChoiceOverEmptySetMessage",
          "normalized": "Exp Name-\u003eSrcSpan-\u003eMaybe ScopeIdentifier-\u003eErrorMessage",
          "package": "libcspm",
          "partial": "Internal Choice Over Empty Set Message",
          "signature": "Exp Name-\u003eSrcSpan-\u003eMaybe ScopeIdentifier-\u003eErrorMessage",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-Exceptions.html#v:replicatedInternalChoiceOverEmptySetMessage"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Evaluator.Exceptions",
          "name": "replicatedInternalChoiceOverEmptySetMessage'",
          "package": "libcspm",
          "signature": "Pat Name -\u003e SrcSpan -\u003e Maybe ScopeIdentifier -\u003e ErrorMessage",
          "source": "src/CSPM-Evaluator-Exceptions.html#replicatedInternalChoiceOverEmptySetMessage%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Evaluator Exceptions",
          "module": "CSPM.Evaluator.Exceptions",
          "name": "replicatedInternalChoiceOverEmptySetMessage'",
          "normalized": "Pat Name-\u003eSrcSpan-\u003eMaybe ScopeIdentifier-\u003eErrorMessage",
          "package": "libcspm",
          "partial": "Internal Choice Over Empty Set Message'",
          "signature": "Pat Name-\u003eSrcSpan-\u003eMaybe ScopeIdentifier-\u003eErrorMessage",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-Exceptions.html#v:replicatedInternalChoiceOverEmptySetMessage-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Evaluator.Exceptions",
          "name": "replicatedLinkParallelOverEmptySeqMessage",
          "package": "libcspm",
          "signature": "Exp Name -\u003e SrcSpan -\u003e Maybe ScopeIdentifier -\u003e ErrorMessage",
          "source": "src/CSPM-Evaluator-Exceptions.html#replicatedLinkParallelOverEmptySeqMessage",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Evaluator Exceptions",
          "module": "CSPM.Evaluator.Exceptions",
          "name": "replicatedLinkParallelOverEmptySeqMessage",
          "normalized": "Exp Name-\u003eSrcSpan-\u003eMaybe ScopeIdentifier-\u003eErrorMessage",
          "package": "libcspm",
          "partial": "Link Parallel Over Empty Seq Message",
          "signature": "Exp Name-\u003eSrcSpan-\u003eMaybe ScopeIdentifier-\u003eErrorMessage",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-Exceptions.html#v:replicatedLinkParallelOverEmptySeqMessage"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Evaluator.Exceptions",
          "name": "setNotRectangularErrorMessage",
          "package": "libcspm",
          "signature": "SrcSpan -\u003e ValueSet -\u003e Maybe ValueSet -\u003e ErrorMessage",
          "source": "src/CSPM-Evaluator-Exceptions.html#setNotRectangularErrorMessage",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Evaluator Exceptions",
          "module": "CSPM.Evaluator.Exceptions",
          "name": "setNotRectangularErrorMessage",
          "normalized": "SrcSpan-\u003eValueSet-\u003eMaybe ValueSet-\u003eErrorMessage",
          "package": "libcspm",
          "partial": "Not Rectangular Error Message",
          "signature": "SrcSpan-\u003eValueSet-\u003eMaybe ValueSet-\u003eErrorMessage",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-Exceptions.html#v:setNotRectangularErrorMessage"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Evaluator.Exceptions",
          "name": "tailEmptyListMessage",
          "package": "libcspm",
          "signature": "SrcSpan -\u003e Maybe ScopeIdentifier -\u003e ErrorMessage",
          "source": "src/CSPM-Evaluator-Exceptions.html#tailEmptyListMessage",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Evaluator Exceptions",
          "module": "CSPM.Evaluator.Exceptions",
          "name": "tailEmptyListMessage",
          "normalized": "SrcSpan-\u003eMaybe ScopeIdentifier-\u003eErrorMessage",
          "package": "libcspm",
          "partial": "Empty List Message",
          "signature": "SrcSpan-\u003eMaybe ScopeIdentifier-\u003eErrorMessage",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-Exceptions.html#v:tailEmptyListMessage"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Evaluator.Exceptions",
          "name": "typeCheckerFailureMessage",
          "package": "libcspm",
          "signature": "String -\u003e ErrorMessage",
          "source": "src/CSPM-Evaluator-Exceptions.html#typeCheckerFailureMessage",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Evaluator Exceptions",
          "module": "CSPM.Evaluator.Exceptions",
          "name": "typeCheckerFailureMessage",
          "normalized": "String-\u003eErrorMessage",
          "package": "libcspm",
          "partial": "Checker Failure Message",
          "signature": "String-\u003eErrorMessage",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-Exceptions.html#v:typeCheckerFailureMessage"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Evaluator.Expr",
          "name": "Expr",
          "package": "libcspm",
          "source": "src/CSPM-Evaluator-Expr.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "CSPM Evaluator Expr",
          "module": "CSPM.Evaluator.Expr",
          "name": "Expr",
          "package": "libcspm",
          "partial": "Expr",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-Expr.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Evaluator.Expr",
          "name": "Evaluatable",
          "package": "libcspm",
          "source": "src/CSPM-Evaluator-Expr.html#Evaluatable",
          "type": "class"
        },
        "index": {
          "hierarchy": "CSPM Evaluator Expr",
          "module": "CSPM.Evaluator.Expr",
          "name": "Evaluatable",
          "package": "libcspm",
          "partial": "Evaluatable",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-Expr.html#t:Evaluatable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Evaluator.Expr",
          "name": "eval",
          "package": "libcspm",
          "signature": "a -\u003e EvaluationMonad Value",
          "source": "src/CSPM-Evaluator-Expr.html#eval",
          "type": "method"
        },
        "index": {
          "hierarchy": "CSPM Evaluator Expr",
          "module": "CSPM.Evaluator.Expr",
          "name": "eval",
          "normalized": "a-\u003eEvaluationMonad Value",
          "package": "libcspm",
          "signature": "a-\u003eEvaluationMonad Value",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-Expr.html#v:eval"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Evaluator.File",
          "name": "File",
          "package": "libcspm",
          "source": "src/CSPM-Evaluator-File.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "CSPM Evaluator File",
          "module": "CSPM.Evaluator.File",
          "name": "File",
          "package": "libcspm",
          "partial": "File",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-File.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Evaluator.File",
          "name": "bindFile",
          "package": "libcspm",
          "signature": "TCCSPMFile -\u003e EvaluationMonad [(Name, EvaluationMonad Value)]",
          "source": "src/CSPM-Evaluator-File.html#bindFile",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Evaluator File",
          "module": "CSPM.Evaluator.File",
          "name": "bindFile",
          "normalized": "TCCSPMFile-\u003eEvaluationMonad[(Name,EvaluationMonad Value)]",
          "package": "libcspm",
          "partial": "File",
          "signature": "TCCSPMFile-\u003eEvaluationMonad[(Name,EvaluationMonad Value)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-File.html#v:bindFile"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Evaluator.Monad",
          "name": "Monad",
          "package": "libcspm",
          "source": "src/CSPM-Evaluator-Monad.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "CSPM Evaluator Monad",
          "module": "CSPM.Evaluator.Monad",
          "name": "Monad",
          "package": "libcspm",
          "partial": "Monad",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-Monad.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Evaluator.Monad",
          "name": "EvaluationMonad",
          "package": "libcspm",
          "source": "src/CSPM-Evaluator-Monad.html#EvaluationMonad",
          "type": "type"
        },
        "index": {
          "hierarchy": "CSPM Evaluator Monad",
          "module": "CSPM.Evaluator.Monad",
          "name": "EvaluationMonad",
          "package": "libcspm",
          "partial": "Evaluation Monad",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-Monad.html#t:EvaluationMonad"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Evaluator.Monad",
          "name": "EvaluationState",
          "package": "libcspm",
          "source": "src/CSPM-Evaluator-Monad.html#EvaluationState",
          "type": "data"
        },
        "index": {
          "hierarchy": "CSPM Evaluator Monad",
          "module": "CSPM.Evaluator.Monad",
          "name": "EvaluationState",
          "package": "libcspm",
          "partial": "Evaluation State",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-Monad.html#t:EvaluationState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Evaluator.Monad",
          "name": "EvaluationState",
          "package": "libcspm",
          "signature": "EvaluationState",
          "source": "src/CSPM-Evaluator-Monad.html#EvaluationState",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Evaluator Monad",
          "module": "CSPM.Evaluator.Monad",
          "name": "EvaluationState",
          "package": "libcspm",
          "partial": "Evaluation State",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-Monad.html#v:EvaluationState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eImplements non-recursive lets.\n\u003c/p\u003e",
          "module": "CSPM.Evaluator.Monad",
          "name": "addScopeAndBind",
          "package": "libcspm",
          "signature": "[(Name, Value)] -\u003e EvaluationMonad a -\u003e EvaluationMonad a",
          "source": "src/CSPM-Evaluator-Monad.html#addScopeAndBind",
          "type": "function"
        },
        "index": {
          "description": "Implements non-recursive lets",
          "hierarchy": "CSPM Evaluator Monad",
          "module": "CSPM.Evaluator.Monad",
          "name": "addScopeAndBind",
          "normalized": "[(Name,Value)]-\u003eEvaluationMonad a-\u003eEvaluationMonad a",
          "package": "libcspm",
          "partial": "Scope And Bind",
          "signature": "[(Name,Value)]-\u003eEvaluationMonad a-\u003eEvaluationMonad a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-Monad.html#v:addScopeAndBind"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eImplements recursive lets.\n\u003c/p\u003e",
          "module": "CSPM.Evaluator.Monad",
          "name": "addScopeAndBindM",
          "package": "libcspm",
          "signature": "[(Name, EvaluationMonad Value)] -\u003e EvaluationMonad a -\u003e EvaluationMonad a",
          "source": "src/CSPM-Evaluator-Monad.html#addScopeAndBindM",
          "type": "function"
        },
        "index": {
          "description": "Implements recursive lets",
          "hierarchy": "CSPM Evaluator Monad",
          "module": "CSPM.Evaluator.Monad",
          "name": "addScopeAndBindM",
          "normalized": "[(Name,EvaluationMonad Value)]-\u003eEvaluationMonad a-\u003eEvaluationMonad a",
          "package": "libcspm",
          "partial": "Scope And Bind",
          "signature": "[(Name,EvaluationMonad Value)]-\u003eEvaluationMonad a-\u003eEvaluationMonad a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-Monad.html#v:addScopeAndBindM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Evaluator.Monad",
          "name": "currentExpressionLocation",
          "package": "libcspm",
          "signature": "SrcSpan",
          "source": "src/CSPM-Evaluator-Monad.html#EvaluationState",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Evaluator Monad",
          "module": "CSPM.Evaluator.Monad",
          "name": "currentExpressionLocation",
          "package": "libcspm",
          "partial": "Expression Location",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-Monad.html#v:currentExpressionLocation"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Evaluator.Monad",
          "name": "doRuntimeRangeChecks",
          "package": "libcspm",
          "signature": "Bool",
          "source": "src/CSPM-Evaluator-Monad.html#EvaluationState",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Evaluator Monad",
          "module": "CSPM.Evaluator.Monad",
          "name": "doRuntimeRangeChecks",
          "package": "libcspm",
          "partial": "Runtime Range Checks",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-Monad.html#v:doRuntimeRangeChecks"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Evaluator.Monad",
          "name": "environment",
          "package": "libcspm",
          "signature": "Environment",
          "source": "src/CSPM-Evaluator-Monad.html#EvaluationState",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Evaluator Monad",
          "module": "CSPM.Evaluator.Monad",
          "name": "environment",
          "package": "libcspm",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-Monad.html#v:environment"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Evaluator.Monad",
          "name": "getCurrentExpressionLocation",
          "package": "libcspm",
          "signature": "EvaluationMonad SrcSpan",
          "source": "src/CSPM-Evaluator-Monad.html#getCurrentExpressionLocation",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Evaluator Monad",
          "module": "CSPM.Evaluator.Monad",
          "name": "getCurrentExpressionLocation",
          "package": "libcspm",
          "partial": "Current Expression Location",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-Monad.html#v:getCurrentExpressionLocation"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Evaluator.Monad",
          "name": "getEnvironment",
          "package": "libcspm",
          "signature": "EvaluationMonad Environment",
          "source": "src/CSPM-Evaluator-Monad.html#getEnvironment",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Evaluator Monad",
          "module": "CSPM.Evaluator.Monad",
          "name": "getEnvironment",
          "package": "libcspm",
          "partial": "Environment",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-Monad.html#v:getEnvironment"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Evaluator.Monad",
          "name": "getParentScopeIdentifier",
          "package": "libcspm",
          "signature": "EvaluationMonad (Maybe ScopeIdentifier)",
          "source": "src/CSPM-Evaluator-Monad.html#getParentScopeIdentifier",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Evaluator Monad",
          "module": "CSPM.Evaluator.Monad",
          "name": "getParentScopeIdentifier",
          "package": "libcspm",
          "partial": "Parent Scope Identifier",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-Monad.html#v:getParentScopeIdentifier"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Evaluator.Monad",
          "name": "getState",
          "package": "libcspm",
          "signature": "EvaluationMonad EvaluationState",
          "source": "src/CSPM-Evaluator-Monad.html#getState",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Evaluator Monad",
          "module": "CSPM.Evaluator.Monad",
          "name": "getState",
          "package": "libcspm",
          "partial": "State",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-Monad.html#v:getState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Evaluator.Monad",
          "name": "gets",
          "package": "libcspm",
          "signature": "(EvaluationState -\u003e a) -\u003e EvaluationMonad a",
          "source": "src/CSPM-Evaluator-Monad.html#gets",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Evaluator Monad",
          "module": "CSPM.Evaluator.Monad",
          "name": "gets",
          "normalized": "(EvaluationState-\u003ea)-\u003eEvaluationMonad a",
          "package": "libcspm",
          "signature": "(EvaluationState-\u003ea)-\u003eEvaluationMonad a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-Monad.html#v:gets"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Evaluator.Monad",
          "name": "lookupVarMaybeThunk",
          "package": "libcspm",
          "signature": "Name -\u003e EvaluationMonad Value",
          "source": "src/CSPM-Evaluator-Monad.html#lookupVarMaybeThunk",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Evaluator Monad",
          "module": "CSPM.Evaluator.Monad",
          "name": "lookupVarMaybeThunk",
          "normalized": "Name-\u003eEvaluationMonad Value",
          "package": "libcspm",
          "partial": "Var Maybe Thunk",
          "signature": "Name-\u003eEvaluationMonad Value",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-Monad.html#v:lookupVarMaybeThunk"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Evaluator.Monad",
          "name": "maybeTimedCSP",
          "package": "libcspm",
          "signature": "EvaluationMonad a -\u003e (Name -\u003e (Event -\u003e Int) -\u003e EvaluationMonad a) -\u003e EvaluationMonad a",
          "source": "src/CSPM-Evaluator-Monad.html#maybeTimedCSP",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Evaluator Monad",
          "module": "CSPM.Evaluator.Monad",
          "name": "maybeTimedCSP",
          "normalized": "EvaluationMonad a-\u003e(Name-\u003e(Event-\u003eInt)-\u003eEvaluationMonad a)-\u003eEvaluationMonad a",
          "package": "libcspm",
          "partial": "Timed CSP",
          "signature": "EvaluationMonad a-\u003e(Name-\u003e(Event-\u003eInt)-\u003eEvaluationMonad a)-\u003eEvaluationMonad a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-Monad.html#v:maybeTimedCSP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Evaluator.Monad",
          "name": "modify",
          "package": "libcspm",
          "signature": "(EvaluationState -\u003e EvaluationState) -\u003e EvaluationMonad a -\u003e EvaluationMonad a",
          "source": "src/CSPM-Evaluator-Monad.html#modify",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Evaluator Monad",
          "module": "CSPM.Evaluator.Monad",
          "name": "modify",
          "normalized": "(EvaluationState-\u003eEvaluationState)-\u003eEvaluationMonad a-\u003eEvaluationMonad a",
          "package": "libcspm",
          "signature": "(EvaluationState-\u003eEvaluationState)-\u003eEvaluationMonad a-\u003eEvaluationMonad a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-Monad.html#v:modify"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Evaluator.Monad",
          "name": "parentScopeIdentifier",
          "package": "libcspm",
          "signature": "Maybe ScopeIdentifier",
          "source": "src/CSPM-Evaluator-Monad.html#EvaluationState",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Evaluator Monad",
          "module": "CSPM.Evaluator.Monad",
          "name": "parentScopeIdentifier",
          "package": "libcspm",
          "partial": "Scope Identifier",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-Monad.html#v:parentScopeIdentifier"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Evaluator.Monad",
          "name": "profilerState",
          "package": "libcspm",
          "signature": "ProfilerState",
          "source": "src/CSPM-Evaluator-Monad.html#EvaluationState",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Evaluator Monad",
          "module": "CSPM.Evaluator.Monad",
          "name": "profilerState",
          "package": "libcspm",
          "partial": "State",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-Monad.html#v:profilerState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"CSPM.Evaluator.Monad\",\"CSPM.Evaluator\"]",
          "name": "runEvaluator",
          "package": "libcspm",
          "signature": "EvaluationState -\u003e EvaluationMonad a -\u003e a",
          "source": "src/CSPM-Evaluator-Monad.html#runEvaluator",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-Monad.html#v:runEvaluator\",\"http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator.html#v:runEvaluator\"]"
        },
        "index": {
          "hierarchy": "CSPM Evaluator Monad",
          "module": "CSPM.Evaluator.Monad",
          "name": "runEvaluator",
          "normalized": "EvaluationState-\u003eEvaluationMonad a-\u003ea",
          "package": "libcspm",
          "partial": "Evaluator",
          "signature": "EvaluationState-\u003eEvaluationMonad a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-Monad.html#v:runEvaluator"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Evaluator.Monad",
          "name": "setCurrentExpressionLocation",
          "package": "libcspm",
          "signature": "SrcSpan -\u003e EvaluationMonad a -\u003e EvaluationMonad a",
          "source": "src/CSPM-Evaluator-Monad.html#setCurrentExpressionLocation",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Evaluator Monad",
          "module": "CSPM.Evaluator.Monad",
          "name": "setCurrentExpressionLocation",
          "normalized": "SrcSpan-\u003eEvaluationMonad a-\u003eEvaluationMonad a",
          "package": "libcspm",
          "partial": "Current Expression Location",
          "signature": "SrcSpan-\u003eEvaluationMonad a-\u003eEvaluationMonad a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-Monad.html#v:setCurrentExpressionLocation"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Evaluator.Monad",
          "name": "setTimedCSP",
          "package": "libcspm",
          "signature": "Name -\u003e (Event -\u003e Int) -\u003e EvaluationMonad a -\u003e EvaluationMonad a",
          "source": "src/CSPM-Evaluator-Monad.html#setTimedCSP",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Evaluator Monad",
          "module": "CSPM.Evaluator.Monad",
          "name": "setTimedCSP",
          "normalized": "Name-\u003e(Event-\u003eInt)-\u003eEvaluationMonad a-\u003eEvaluationMonad a",
          "package": "libcspm",
          "partial": "Timed CSP",
          "signature": "Name-\u003e(Event-\u003eInt)-\u003eEvaluationMonad a-\u003eEvaluationMonad a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-Monad.html#v:setTimedCSP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Evaluator.Monad",
          "name": "throwError",
          "package": "libcspm",
          "signature": "ErrorMessage -\u003e a",
          "source": "src/CSPM-Evaluator-Monad.html#throwError",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Evaluator Monad",
          "module": "CSPM.Evaluator.Monad",
          "name": "throwError",
          "normalized": "ErrorMessage-\u003ea",
          "package": "libcspm",
          "partial": "Error",
          "signature": "ErrorMessage-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-Monad.html#v:throwError"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Evaluator.Monad",
          "name": "throwError'",
          "package": "libcspm",
          "signature": "(SrcSpan -\u003e Maybe ScopeIdentifier -\u003e ErrorMessage) -\u003e EvaluationMonad a",
          "source": "src/CSPM-Evaluator-Monad.html#throwError%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Evaluator Monad",
          "module": "CSPM.Evaluator.Monad",
          "name": "throwError'",
          "normalized": "(SrcSpan-\u003eMaybe ScopeIdentifier-\u003eErrorMessage)-\u003eEvaluationMonad a",
          "package": "libcspm",
          "partial": "Error'",
          "signature": "(SrcSpan-\u003eMaybe ScopeIdentifier-\u003eErrorMessage)-\u003eEvaluationMonad a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-Monad.html#v:throwError-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Evaluator.Monad",
          "name": "timedSection",
          "package": "libcspm",
          "signature": "Maybe (Event -\u003e Int, Name)",
          "source": "src/CSPM-Evaluator-Monad.html#EvaluationState",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Evaluator Monad",
          "module": "CSPM.Evaluator.Monad",
          "name": "timedSection",
          "normalized": "Maybe(Event-\u003eInt,Name)",
          "package": "libcspm",
          "partial": "Section",
          "signature": "Maybe(Event-\u003eInt,Name)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-Monad.html#v:timedSection"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Evaluator.Monad",
          "name": "updateParentScopeIdentifier",
          "package": "libcspm",
          "signature": "ScopeIdentifier -\u003e EvaluationMonad a -\u003e EvaluationMonad a",
          "source": "src/CSPM-Evaluator-Monad.html#updateParentScopeIdentifier",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Evaluator Monad",
          "module": "CSPM.Evaluator.Monad",
          "name": "updateParentScopeIdentifier",
          "normalized": "ScopeIdentifier-\u003eEvaluationMonad a-\u003eEvaluationMonad a",
          "package": "libcspm",
          "partial": "Parent Scope Identifier",
          "signature": "ScopeIdentifier-\u003eEvaluationMonad a-\u003eEvaluationMonad a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-Monad.html#v:updateParentScopeIdentifier"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Evaluator.PatBind",
          "name": "PatBind",
          "package": "libcspm",
          "source": "src/CSPM-Evaluator-PatBind.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "CSPM Evaluator PatBind",
          "module": "CSPM.Evaluator.PatBind",
          "name": "PatBind",
          "package": "libcspm",
          "partial": "Pat Bind",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-PatBind.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Evaluator.PatBind",
          "name": "Bindable",
          "package": "libcspm",
          "source": "src/CSPM-Evaluator-PatBind.html#Bindable",
          "type": "class"
        },
        "index": {
          "hierarchy": "CSPM Evaluator PatBind",
          "module": "CSPM.Evaluator.PatBind",
          "name": "Bindable",
          "package": "libcspm",
          "partial": "Bindable",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-PatBind.html#t:Bindable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Evaluator.PatBind",
          "name": "bind",
          "package": "libcspm",
          "signature": "a -\u003e Value -\u003e (Bool, [(Name, Value)])",
          "source": "src/CSPM-Evaluator-PatBind.html#bind",
          "type": "method"
        },
        "index": {
          "hierarchy": "CSPM Evaluator PatBind",
          "module": "CSPM.Evaluator.PatBind",
          "name": "bind",
          "normalized": "a-\u003eValue-\u003e(Bool,[(Name,Value)])",
          "package": "libcspm",
          "signature": "a-\u003eValue-\u003e(Bool,[(Name,Value)])",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-PatBind.html#v:bind"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Evaluator.PatBind",
          "name": "bindAll",
          "package": "libcspm",
          "signature": "[a] -\u003e [Value] -\u003e (Bool, [(Name, Value)])",
          "source": "src/CSPM-Evaluator-PatBind.html#bindAll",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Evaluator PatBind",
          "module": "CSPM.Evaluator.PatBind",
          "name": "bindAll",
          "normalized": "[a]-\u003e[Value]-\u003e(Bool,[(Name,Value)])",
          "package": "libcspm",
          "partial": "All",
          "signature": "[a]-\u003e[Value]-\u003e(Bool,[(Name,Value)])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-PatBind.html#v:bindAll"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Evaluator.ProcessValues",
          "name": "ProcessValues",
          "package": "libcspm",
          "source": "src/CSPM-Evaluator-ProcessValues.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "CSPM Evaluator ProcessValues",
          "module": "CSPM.Evaluator.ProcessValues",
          "name": "ProcessValues",
          "package": "libcspm",
          "partial": "Process Values",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-ProcessValues.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Evaluator.ProcessValues",
          "name": "CSPOperator",
          "package": "libcspm",
          "source": "src/CSPM-Evaluator-ProcessValues.html#CSPOperator",
          "type": "data"
        },
        "index": {
          "hierarchy": "CSPM Evaluator ProcessValues",
          "module": "CSPM.Evaluator.ProcessValues",
          "name": "CSPOperator",
          "package": "libcspm",
          "partial": "CSPOperator",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-ProcessValues.html#t:CSPOperator"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEvents, as represented in the LTS.\n\u003c/p\u003e",
          "module": "CSPM.Evaluator.ProcessValues",
          "name": "Event",
          "package": "libcspm",
          "source": "src/CSPM-Evaluator-ProcessValues.html#Event",
          "type": "data"
        },
        "index": {
          "description": "Events as represented in the LTS",
          "hierarchy": "CSPM Evaluator ProcessValues",
          "module": "CSPM.Evaluator.ProcessValues",
          "name": "Event",
          "package": "libcspm",
          "partial": "Event",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-ProcessValues.html#t:Event"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Evaluator.ProcessValues",
          "name": "EventMap",
          "package": "libcspm",
          "source": "src/CSPM-Evaluator-ProcessValues.html#EventMap",
          "type": "type"
        },
        "index": {
          "hierarchy": "CSPM Evaluator ProcessValues",
          "module": "CSPM.Evaluator.ProcessValues",
          "name": "EventMap",
          "package": "libcspm",
          "partial": "Event Map",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-ProcessValues.html#t:EventMap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Evaluator.ProcessValues",
          "name": "EventSet",
          "package": "libcspm",
          "source": "src/CSPM-Evaluator-ProcessValues.html#EventSet",
          "type": "type"
        },
        "index": {
          "hierarchy": "CSPM Evaluator ProcessValues",
          "module": "CSPM.Evaluator.ProcessValues",
          "name": "EventSet",
          "package": "libcspm",
          "partial": "Event Set",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-ProcessValues.html#t:EventSet"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA compiled process. Note this is an infinite data structure (due to\n PProcCall) as this makes compilation easy (we can easily chase\n dependencies).\n\u003c/p\u003e",
          "module": "CSPM.Evaluator.ProcessValues",
          "name": "Proc",
          "package": "libcspm",
          "source": "src/CSPM-Evaluator-ProcessValues.html#Proc",
          "type": "data"
        },
        "index": {
          "description": "compiled process Note this is an infinite data structure due to PProcCall as this makes compilation easy we can easily chase dependencies",
          "hierarchy": "CSPM Evaluator ProcessValues",
          "module": "CSPM.Evaluator.ProcessValues",
          "name": "Proc",
          "package": "libcspm",
          "partial": "Proc",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-ProcessValues.html#t:Proc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eProcNames uniquely identify processes.\n\u003c/p\u003e",
          "module": "CSPM.Evaluator.ProcessValues",
          "name": "ProcName",
          "package": "libcspm",
          "source": "src/CSPM-Evaluator-ProcessValues.html#ProcName",
          "type": "newtype"
        },
        "index": {
          "description": "ProcNames uniquely identify processes",
          "hierarchy": "CSPM Evaluator ProcessValues",
          "module": "CSPM.Evaluator.ProcessValues",
          "name": "ProcName",
          "package": "libcspm",
          "partial": "Proc Name",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-ProcessValues.html#t:ProcName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn operator that can be applied to processes.\n\u003c/p\u003e",
          "module": "CSPM.Evaluator.ProcessValues",
          "name": "ProcOperator",
          "package": "libcspm",
          "source": "src/CSPM-Evaluator-ProcessValues.html#ProcOperator",
          "type": "data"
        },
        "index": {
          "description": "An operator that can be applied to processes",
          "hierarchy": "CSPM Evaluator ProcessValues",
          "module": "CSPM.Evaluator.ProcessValues",
          "name": "ProcOperator",
          "package": "libcspm",
          "partial": "Proc Operator",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-ProcessValues.html#t:ProcOperator"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Evaluator.ProcessValues",
          "name": "UnCompiledOperator",
          "package": "libcspm",
          "source": "src/CSPM-Evaluator-ProcessValues.html#UnCompiledOperator",
          "type": "type"
        },
        "index": {
          "hierarchy": "CSPM Evaluator ProcessValues",
          "module": "CSPM.Evaluator.ProcessValues",
          "name": "UnCompiledOperator",
          "package": "libcspm",
          "partial": "Un Compiled Operator",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-ProcessValues.html#t:UnCompiledOperator"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Evaluator.ProcessValues",
          "name": "UnCompiledProc",
          "package": "libcspm",
          "source": "src/CSPM-Evaluator-ProcessValues.html#UnCompiledProc",
          "type": "type"
        },
        "index": {
          "hierarchy": "CSPM Evaluator ProcessValues",
          "module": "CSPM.Evaluator.ProcessValues",
          "name": "UnCompiledProc",
          "package": "libcspm",
          "partial": "Un Compiled Proc",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-ProcessValues.html#t:UnCompiledProc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Evaluator.ProcessValues",
          "name": "UnCompiledProcOperator",
          "package": "libcspm",
          "source": "src/CSPM-Evaluator-ProcessValues.html#UnCompiledProcOperator",
          "type": "type"
        },
        "index": {
          "hierarchy": "CSPM Evaluator ProcessValues",
          "module": "CSPM.Evaluator.ProcessValues",
          "name": "UnCompiledProcOperator",
          "package": "libcspm",
          "partial": "Un Compiled Proc Operator",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-ProcessValues.html#t:UnCompiledProcOperator"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"CSPM.Evaluator.ProcessValues\",\"CSPM.Evaluator.Values\"]",
          "name": "Chase",
          "package": "libcspm",
          "signature": "Chase Bool",
          "source": "src/CSPM-Evaluator-ProcessValues.html#ProcOperator",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-ProcessValues.html#v:Chase\",\"http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-Values.html#v:Chase\"]"
        },
        "index": {
          "hierarchy": "CSPM Evaluator ProcessValues",
          "module": "CSPM.Evaluator.ProcessValues",
          "name": "Chase",
          "package": "libcspm",
          "partial": "Chase",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-ProcessValues.html#v:Chase"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"CSPM.Evaluator.ProcessValues\",\"CSPM.Evaluator.Values\"]",
          "name": "Determinise",
          "package": "libcspm",
          "signature": "Determinise",
          "source": "src/CSPM-Evaluator-ProcessValues.html#ProcOperator",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-ProcessValues.html#v:Determinise\",\"http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-Values.html#v:Determinise\"]"
        },
        "index": {
          "hierarchy": "CSPM Evaluator ProcessValues",
          "module": "CSPM.Evaluator.ProcessValues",
          "name": "Determinise",
          "package": "libcspm",
          "partial": "Determinise",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-ProcessValues.html#v:Determinise"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"CSPM.Evaluator.ProcessValues\",\"CSPM.Evaluator.Values\"]",
          "name": "Diamond",
          "package": "libcspm",
          "signature": "Diamond",
          "source": "src/CSPM-Evaluator-ProcessValues.html#ProcOperator",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-ProcessValues.html#v:Diamond\",\"http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-Values.html#v:Diamond\"]"
        },
        "index": {
          "hierarchy": "CSPM Evaluator ProcessValues",
          "module": "CSPM.Evaluator.ProcessValues",
          "name": "Diamond",
          "package": "libcspm",
          "partial": "Diamond",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-ProcessValues.html#v:Diamond"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"CSPM.Evaluator.ProcessValues\",\"CSPM.Evaluator.Values\"]",
          "name": "Explicate",
          "package": "libcspm",
          "signature": "Explicate Bool",
          "source": "src/CSPM-Evaluator-ProcessValues.html#ProcOperator",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-ProcessValues.html#v:Explicate\",\"http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-Values.html#v:Explicate\"]"
        },
        "index": {
          "hierarchy": "CSPM Evaluator ProcessValues",
          "module": "CSPM.Evaluator.ProcessValues",
          "name": "Explicate",
          "package": "libcspm",
          "partial": "Explicate",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-ProcessValues.html#v:Explicate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"CSPM.Evaluator.ProcessValues\",\"CSPM.Evaluator.Values\"]",
          "name": "ModelCompress",
          "package": "libcspm",
          "signature": "ModelCompress",
          "source": "src/CSPM-Evaluator-ProcessValues.html#ProcOperator",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-ProcessValues.html#v:ModelCompress\",\"http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-Values.html#v:ModelCompress\"]"
        },
        "index": {
          "hierarchy": "CSPM Evaluator ProcessValues",
          "module": "CSPM.Evaluator.ProcessValues",
          "name": "ModelCompress",
          "package": "libcspm",
          "partial": "Model Compress",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-ProcessValues.html#v:ModelCompress"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"CSPM.Evaluator.ProcessValues\",\"CSPM.Evaluator.Values\"]",
          "name": "Normalize",
          "package": "libcspm",
          "signature": "Normalize Bool",
          "source": "src/CSPM-Evaluator-ProcessValues.html#ProcOperator",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-ProcessValues.html#v:Normalize\",\"http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-Values.html#v:Normalize\"]"
        },
        "index": {
          "hierarchy": "CSPM Evaluator ProcessValues",
          "module": "CSPM.Evaluator.ProcessValues",
          "name": "Normalize",
          "package": "libcspm",
          "partial": "Normalize",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-ProcessValues.html#v:Normalize"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"CSPM.Evaluator.ProcessValues\",\"CSPM.Evaluator.Values\"]",
          "name": "PAlphaParallel",
          "package": "libcspm",
          "signature": "PAlphaParallel (seq evs)",
          "source": "src/CSPM-Evaluator-ProcessValues.html#CSPOperator",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-ProcessValues.html#v:PAlphaParallel\",\"http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-Values.html#v:PAlphaParallel\"]"
        },
        "index": {
          "hierarchy": "CSPM Evaluator ProcessValues",
          "module": "CSPM.Evaluator.ProcessValues",
          "name": "PAlphaParallel",
          "package": "libcspm",
          "partial": "PAlpha Parallel",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-ProcessValues.html#v:PAlphaParallel"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"CSPM.Evaluator.ProcessValues\",\"CSPM.Evaluator.Values\"]",
          "name": "PBinaryOp",
          "package": "libcspm",
          "signature": "PBinaryOp (op seq ev evs evm) (Proc seq op pn ev evs evm) (Proc seq op pn ev evs evm)",
          "source": "src/CSPM-Evaluator-ProcessValues.html#Proc",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-ProcessValues.html#v:PBinaryOp\",\"http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-Values.html#v:PBinaryOp\"]"
        },
        "index": {
          "hierarchy": "CSPM Evaluator ProcessValues",
          "module": "CSPM.Evaluator.ProcessValues",
          "name": "PBinaryOp",
          "package": "libcspm",
          "partial": "PBinary Op",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-ProcessValues.html#v:PBinaryOp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"CSPM.Evaluator.ProcessValues\",\"CSPM.Evaluator.Values\"]",
          "name": "PException",
          "package": "libcspm",
          "signature": "PException evs",
          "source": "src/CSPM-Evaluator-ProcessValues.html#CSPOperator",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-ProcessValues.html#v:PException\",\"http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-Values.html#v:PException\"]"
        },
        "index": {
          "hierarchy": "CSPM Evaluator ProcessValues",
          "module": "CSPM.Evaluator.ProcessValues",
          "name": "PException",
          "package": "libcspm",
          "partial": "PException",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-ProcessValues.html#v:PException"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"CSPM.Evaluator.ProcessValues\",\"CSPM.Evaluator.Values\"]",
          "name": "PExternalChoice",
          "package": "libcspm",
          "signature": "PExternalChoice",
          "source": "src/CSPM-Evaluator-ProcessValues.html#CSPOperator",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-ProcessValues.html#v:PExternalChoice\",\"http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-Values.html#v:PExternalChoice\"]"
        },
        "index": {
          "hierarchy": "CSPM Evaluator ProcessValues",
          "module": "CSPM.Evaluator.ProcessValues",
          "name": "PExternalChoice",
          "package": "libcspm",
          "partial": "PExternal Choice",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-ProcessValues.html#v:PExternalChoice"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"CSPM.Evaluator.ProcessValues\",\"CSPM.Evaluator.Values\"]",
          "name": "PGenParallel",
          "package": "libcspm",
          "signature": "PGenParallel evs",
          "source": "src/CSPM-Evaluator-ProcessValues.html#CSPOperator",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-ProcessValues.html#v:PGenParallel\",\"http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-Values.html#v:PGenParallel\"]"
        },
        "index": {
          "hierarchy": "CSPM Evaluator ProcessValues",
          "module": "CSPM.Evaluator.ProcessValues",
          "name": "PGenParallel",
          "package": "libcspm",
          "partial": "PGen Parallel",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-ProcessValues.html#v:PGenParallel"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"CSPM.Evaluator.ProcessValues\",\"CSPM.Evaluator.Values\"]",
          "name": "PHide",
          "package": "libcspm",
          "signature": "PHide evs",
          "source": "src/CSPM-Evaluator-ProcessValues.html#CSPOperator",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-ProcessValues.html#v:PHide\",\"http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-Values.html#v:PHide\"]"
        },
        "index": {
          "hierarchy": "CSPM Evaluator ProcessValues",
          "module": "CSPM.Evaluator.ProcessValues",
          "name": "PHide",
          "package": "libcspm",
          "partial": "PHide",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-ProcessValues.html#v:PHide"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"CSPM.Evaluator.ProcessValues\",\"CSPM.Evaluator.Values\"]",
          "name": "PInterleave",
          "package": "libcspm",
          "signature": "PInterleave",
          "source": "src/CSPM-Evaluator-ProcessValues.html#CSPOperator",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-ProcessValues.html#v:PInterleave\",\"http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-Values.html#v:PInterleave\"]"
        },
        "index": {
          "hierarchy": "CSPM Evaluator ProcessValues",
          "module": "CSPM.Evaluator.ProcessValues",
          "name": "PInterleave",
          "package": "libcspm",
          "partial": "PInterleave",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-ProcessValues.html#v:PInterleave"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"CSPM.Evaluator.ProcessValues\",\"CSPM.Evaluator.Values\"]",
          "name": "PInternalChoice",
          "package": "libcspm",
          "signature": "PInternalChoice",
          "source": "src/CSPM-Evaluator-ProcessValues.html#CSPOperator",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-ProcessValues.html#v:PInternalChoice\",\"http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-Values.html#v:PInternalChoice\"]"
        },
        "index": {
          "hierarchy": "CSPM Evaluator ProcessValues",
          "module": "CSPM.Evaluator.ProcessValues",
          "name": "PInternalChoice",
          "package": "libcspm",
          "partial": "PInternal Choice",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-ProcessValues.html#v:PInternalChoice"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"CSPM.Evaluator.ProcessValues\",\"CSPM.Evaluator.Values\"]",
          "name": "PInterrupt",
          "package": "libcspm",
          "signature": "PInterrupt",
          "source": "src/CSPM-Evaluator-ProcessValues.html#CSPOperator",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-ProcessValues.html#v:PInterrupt\",\"http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-Values.html#v:PInterrupt\"]"
        },
        "index": {
          "hierarchy": "CSPM Evaluator ProcessValues",
          "module": "CSPM.Evaluator.ProcessValues",
          "name": "PInterrupt",
          "package": "libcspm",
          "partial": "PInterrupt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-ProcessValues.html#v:PInterrupt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"CSPM.Evaluator.ProcessValues\",\"CSPM.Evaluator.Values\"]",
          "name": "PLinkParallel",
          "package": "libcspm",
          "signature": "PLinkParallel evm",
          "source": "src/CSPM-Evaluator-ProcessValues.html#CSPOperator",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-ProcessValues.html#v:PLinkParallel\",\"http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-Values.html#v:PLinkParallel\"]"
        },
        "index": {
          "hierarchy": "CSPM Evaluator ProcessValues",
          "module": "CSPM.Evaluator.ProcessValues",
          "name": "PLinkParallel",
          "package": "libcspm",
          "partial": "PLink Parallel",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-ProcessValues.html#v:PLinkParallel"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"CSPM.Evaluator.ProcessValues\",\"CSPM.Evaluator.Values\"]",
          "name": "POp",
          "package": "libcspm",
          "signature": "POp (op seq ev evs evm) (seq (Proc seq op pn ev evs evm))",
          "source": "src/CSPM-Evaluator-ProcessValues.html#Proc",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-ProcessValues.html#v:POp\",\"http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-Values.html#v:POp\"]"
        },
        "index": {
          "hierarchy": "CSPM Evaluator ProcessValues",
          "module": "CSPM.Evaluator.ProcessValues",
          "name": "POp",
          "package": "libcspm",
          "partial": "POp",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-ProcessValues.html#v:POp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"CSPM.Evaluator.ProcessValues\",\"CSPM.Evaluator.Values\"]",
          "name": "POperator",
          "package": "libcspm",
          "signature": "POperator (ProcOperator seq evs)",
          "source": "src/CSPM-Evaluator-ProcessValues.html#CSPOperator",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-ProcessValues.html#v:POperator\",\"http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-Values.html#v:POperator\"]"
        },
        "index": {
          "hierarchy": "CSPM Evaluator ProcessValues",
          "module": "CSPM.Evaluator.ProcessValues",
          "name": "POperator",
          "package": "libcspm",
          "partial": "POperator",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-ProcessValues.html#v:POperator"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"CSPM.Evaluator.ProcessValues\",\"CSPM.Evaluator.Values\"]",
          "name": "PPrefix",
          "package": "libcspm",
          "signature": "PPrefix ev",
          "source": "src/CSPM-Evaluator-ProcessValues.html#CSPOperator",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-ProcessValues.html#v:PPrefix\",\"http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-Values.html#v:PPrefix\"]"
        },
        "index": {
          "hierarchy": "CSPM Evaluator ProcessValues",
          "module": "CSPM.Evaluator.ProcessValues",
          "name": "PPrefix",
          "package": "libcspm",
          "partial": "PPrefix",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-ProcessValues.html#v:PPrefix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLabels the process this contains. This allows infinite loops to be\n spotted.\n\u003c/p\u003e",
          "module": "[\"CSPM.Evaluator.ProcessValues\",\"CSPM.Evaluator.Values\"]",
          "name": "PProcCall",
          "package": "libcspm",
          "signature": "PProcCall pn (Proc seq op pn ev evs evm)",
          "source": "src/CSPM-Evaluator-ProcessValues.html#Proc",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-ProcessValues.html#v:PProcCall\",\"http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-Values.html#v:PProcCall\"]"
        },
        "index": {
          "description": "Labels the process this contains This allows infinite loops to be spotted",
          "hierarchy": "CSPM Evaluator ProcessValues",
          "module": "CSPM.Evaluator.ProcessValues",
          "name": "PProcCall",
          "package": "libcspm",
          "partial": "PProc Call",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-ProcessValues.html#v:PProcCall"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"CSPM.Evaluator.ProcessValues\",\"CSPM.Evaluator.Values\"]",
          "name": "PRename",
          "package": "libcspm",
          "signature": "PRename evm",
          "source": "src/CSPM-Evaluator-ProcessValues.html#CSPOperator",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-ProcessValues.html#v:PRename\",\"http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-Values.html#v:PRename\"]"
        },
        "index": {
          "hierarchy": "CSPM Evaluator ProcessValues",
          "module": "CSPM.Evaluator.ProcessValues",
          "name": "PRename",
          "package": "libcspm",
          "partial": "PRename",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-ProcessValues.html#v:PRename"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"CSPM.Evaluator.ProcessValues\",\"CSPM.Evaluator.Values\"]",
          "name": "PSequentialComp",
          "package": "libcspm",
          "signature": "PSequentialComp",
          "source": "src/CSPM-Evaluator-ProcessValues.html#CSPOperator",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-ProcessValues.html#v:PSequentialComp\",\"http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-Values.html#v:PSequentialComp\"]"
        },
        "index": {
          "hierarchy": "CSPM Evaluator ProcessValues",
          "module": "CSPM.Evaluator.ProcessValues",
          "name": "PSequentialComp",
          "package": "libcspm",
          "partial": "PSequential Comp",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-ProcessValues.html#v:PSequentialComp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"CSPM.Evaluator.ProcessValues\",\"CSPM.Evaluator.Values\"]",
          "name": "PSlidingChoice",
          "package": "libcspm",
          "signature": "PSlidingChoice",
          "source": "src/CSPM-Evaluator-ProcessValues.html#CSPOperator",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-ProcessValues.html#v:PSlidingChoice\",\"http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-Values.html#v:PSlidingChoice\"]"
        },
        "index": {
          "hierarchy": "CSPM Evaluator ProcessValues",
          "module": "CSPM.Evaluator.ProcessValues",
          "name": "PSlidingChoice",
          "package": "libcspm",
          "partial": "PSliding Choice",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-ProcessValues.html#v:PSlidingChoice"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"CSPM.Evaluator.ProcessValues\",\"CSPM.Evaluator.Values\"]",
          "name": "PSynchronisingExternalChoice",
          "package": "libcspm",
          "signature": "PSynchronisingExternalChoice evs",
          "source": "src/CSPM-Evaluator-ProcessValues.html#CSPOperator",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-ProcessValues.html#v:PSynchronisingExternalChoice\",\"http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-Values.html#v:PSynchronisingExternalChoice\"]"
        },
        "index": {
          "hierarchy": "CSPM Evaluator ProcessValues",
          "module": "CSPM.Evaluator.ProcessValues",
          "name": "PSynchronisingExternalChoice",
          "package": "libcspm",
          "partial": "PSynchronising External Choice",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-ProcessValues.html#v:PSynchronisingExternalChoice"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"CSPM.Evaluator.ProcessValues\",\"CSPM.Evaluator.Values\"]",
          "name": "PSynchronisingInterrupt",
          "package": "libcspm",
          "signature": "PSynchronisingInterrupt evs",
          "source": "src/CSPM-Evaluator-ProcessValues.html#CSPOperator",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-ProcessValues.html#v:PSynchronisingInterrupt\",\"http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-Values.html#v:PSynchronisingInterrupt\"]"
        },
        "index": {
          "hierarchy": "CSPM Evaluator ProcessValues",
          "module": "CSPM.Evaluator.ProcessValues",
          "name": "PSynchronisingInterrupt",
          "package": "libcspm",
          "partial": "PSynchronising Interrupt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-ProcessValues.html#v:PSynchronisingInterrupt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"CSPM.Evaluator.ProcessValues\",\"CSPM.Evaluator.Values\"]",
          "name": "PUnaryOp",
          "package": "libcspm",
          "signature": "PUnaryOp (op seq ev evs evm) (Proc seq op pn ev evs evm)",
          "source": "src/CSPM-Evaluator-ProcessValues.html#Proc",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-ProcessValues.html#v:PUnaryOp\",\"http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-Values.html#v:PUnaryOp\"]"
        },
        "index": {
          "hierarchy": "CSPM Evaluator ProcessValues",
          "module": "CSPM.Evaluator.ProcessValues",
          "name": "PUnaryOp",
          "package": "libcspm",
          "partial": "PUnary Op",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-ProcessValues.html#v:PUnaryOp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"CSPM.Evaluator.ProcessValues\",\"CSPM.Evaluator.Values\"]",
          "name": "Prioritise",
          "package": "libcspm",
          "signature": "Prioritise Bool (seq evs)",
          "source": "src/CSPM-Evaluator-ProcessValues.html#ProcOperator",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-ProcessValues.html#v:Prioritise\",\"http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-Values.html#v:Prioritise\"]"
        },
        "index": {
          "hierarchy": "CSPM Evaluator ProcessValues",
          "module": "CSPM.Evaluator.ProcessValues",
          "name": "Prioritise",
          "package": "libcspm",
          "partial": "Prioritise",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-ProcessValues.html#v:Prioritise"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Evaluator.ProcessValues",
          "name": "ProcName",
          "package": "libcspm",
          "signature": "ProcName ScopeIdentifier",
          "source": "src/CSPM-Evaluator-ProcessValues.html#ProcName",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Evaluator ProcessValues",
          "module": "CSPM.Evaluator.ProcessValues",
          "name": "ProcName",
          "package": "libcspm",
          "partial": "Proc Name",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-ProcessValues.html#v:ProcName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"CSPM.Evaluator.ProcessValues\",\"CSPM.Evaluator.Values\"]",
          "name": "StrongBisim",
          "package": "libcspm",
          "signature": "StrongBisim",
          "source": "src/CSPM-Evaluator-ProcessValues.html#ProcOperator",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-ProcessValues.html#v:StrongBisim\",\"http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-Values.html#v:StrongBisim\"]"
        },
        "index": {
          "hierarchy": "CSPM Evaluator ProcessValues",
          "module": "CSPM.Evaluator.ProcessValues",
          "name": "StrongBisim",
          "package": "libcspm",
          "partial": "Strong Bisim",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-ProcessValues.html#v:StrongBisim"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe internal special event tau.\n\u003c/p\u003e",
          "module": "[\"CSPM.Evaluator.ProcessValues\",\"CSPM.Evaluator.Values\"]",
          "name": "Tau",
          "package": "libcspm",
          "signature": "Tau",
          "source": "src/CSPM-Evaluator-ProcessValues.html#Event",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-ProcessValues.html#v:Tau\",\"http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-Values.html#v:Tau\"]"
        },
        "index": {
          "description": "The internal special event tau",
          "hierarchy": "CSPM Evaluator ProcessValues",
          "module": "CSPM.Evaluator.ProcessValues",
          "name": "Tau",
          "package": "libcspm",
          "partial": "Tau",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-ProcessValues.html#v:Tau"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"CSPM.Evaluator.ProcessValues\",\"CSPM.Evaluator.Values\"]",
          "name": "TauLoopFactor",
          "package": "libcspm",
          "signature": "TauLoopFactor",
          "source": "src/CSPM-Evaluator-ProcessValues.html#ProcOperator",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-ProcessValues.html#v:TauLoopFactor\",\"http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-Values.html#v:TauLoopFactor\"]"
        },
        "index": {
          "hierarchy": "CSPM Evaluator ProcessValues",
          "module": "CSPM.Evaluator.ProcessValues",
          "name": "TauLoopFactor",
          "package": "libcspm",
          "partial": "Tau Loop Factor",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-ProcessValues.html#v:TauLoopFactor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe internal event tick, representing termination.\n\u003c/p\u003e",
          "module": "[\"CSPM.Evaluator.ProcessValues\",\"CSPM.Evaluator.Values\"]",
          "name": "Tick",
          "package": "libcspm",
          "signature": "Tick",
          "source": "src/CSPM-Evaluator-ProcessValues.html#Event",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-ProcessValues.html#v:Tick\",\"http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-Values.html#v:Tick\"]"
        },
        "index": {
          "description": "The internal event tick representing termination",
          "hierarchy": "CSPM Evaluator ProcessValues",
          "module": "CSPM.Evaluator.ProcessValues",
          "name": "Tick",
          "package": "libcspm",
          "partial": "Tick",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-ProcessValues.html#v:Tick"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAny event defined in a channel definition.\n\u003c/p\u003e",
          "module": "[\"CSPM.Evaluator.ProcessValues\",\"CSPM.Evaluator.Values\"]",
          "name": "UserEvent",
          "package": "libcspm",
          "signature": "UserEvent Value",
          "source": "src/CSPM-Evaluator-ProcessValues.html#Event",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-ProcessValues.html#v:UserEvent\",\"http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-Values.html#v:UserEvent\"]"
        },
        "index": {
          "description": "Any event defined in channel definition",
          "hierarchy": "CSPM Evaluator ProcessValues",
          "module": "CSPM.Evaluator.ProcessValues",
          "name": "UserEvent",
          "package": "libcspm",
          "partial": "User Event",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-ProcessValues.html#v:UserEvent"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"CSPM.Evaluator.ProcessValues\",\"CSPM.Evaluator.Values\"]",
          "name": "WeakBisim",
          "package": "libcspm",
          "signature": "WeakBisim",
          "source": "src/CSPM-Evaluator-ProcessValues.html#ProcOperator",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-ProcessValues.html#v:WeakBisim\",\"http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-Values.html#v:WeakBisim\"]"
        },
        "index": {
          "hierarchy": "CSPM Evaluator ProcessValues",
          "module": "CSPM.Evaluator.ProcessValues",
          "name": "WeakBisim",
          "package": "libcspm",
          "partial": "Weak Bisim",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-ProcessValues.html#v:WeakBisim"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturns the components of a given process.\n\u003c/p\u003e",
          "module": "CSPM.Evaluator.ProcessValues",
          "name": "components",
          "package": "libcspm",
          "signature": "Proc Seq op pn ev evs evm -\u003e Seq (Proc Seq op pn ev evs evm)",
          "source": "src/CSPM-Evaluator-ProcessValues.html#components",
          "type": "function"
        },
        "index": {
          "description": "Returns the components of given process",
          "hierarchy": "CSPM Evaluator ProcessValues",
          "module": "CSPM.Evaluator.ProcessValues",
          "name": "components",
          "normalized": "Proc Seq a b c d e-\u003eSeq(Proc Seq a b c d e)",
          "package": "libcspm",
          "signature": "Proc Seq op pn ev evs evm-\u003eSeq(Proc Seq op pn ev evs evm)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-ProcessValues.html#v:components"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Evaluator.ProcessValues",
          "name": "eventSetFromList",
          "package": "libcspm",
          "signature": "[Event] -\u003e EventSet",
          "source": "src/CSPM-Evaluator-ProcessValues.html#eventSetFromList",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Evaluator ProcessValues",
          "module": "CSPM.Evaluator.ProcessValues",
          "name": "eventSetFromList",
          "normalized": "[Event]-\u003eEventSet",
          "package": "libcspm",
          "partial": "Set From List",
          "signature": "[Event]-\u003eEventSet",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-ProcessValues.html#v:eventSetFromList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGives the operator of a process. If the process is a ProcCall an error is\n thrown.\n\u003c/p\u003e",
          "module": "CSPM.Evaluator.ProcessValues",
          "name": "operator",
          "package": "libcspm",
          "signature": "Proc seq op pn ev evs evm -\u003e op seq ev evs evm",
          "source": "src/CSPM-Evaluator-ProcessValues.html#operator",
          "type": "function"
        },
        "index": {
          "description": "Gives the operator of process If the process is ProcCall an error is thrown",
          "hierarchy": "CSPM Evaluator ProcessValues",
          "module": "CSPM.Evaluator.ProcessValues",
          "name": "operator",
          "normalized": "Proc a b c d e f-\u003eb a d e f",
          "package": "libcspm",
          "signature": "Proc seq op pn ev evs evm-\u003eop seq ev evs evm",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-ProcessValues.html#v:operator"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGiven a process, returns the initial process and all processes that it\n calls.\n\u003c/p\u003e",
          "module": "CSPM.Evaluator.ProcessValues",
          "name": "splitProcIntoComponents",
          "package": "libcspm",
          "signature": "Proc seq op pn ev evs evm -\u003e (Proc seq op pn ev evs evm, [(pn, Proc seq op pn ev evs evm)])",
          "source": "src/CSPM-Evaluator-ProcessValues.html#splitProcIntoComponents",
          "type": "function"
        },
        "index": {
          "description": "Given process returns the initial process and all processes that it calls",
          "hierarchy": "CSPM Evaluator ProcessValues",
          "module": "CSPM.Evaluator.ProcessValues",
          "name": "splitProcIntoComponents",
          "normalized": "Proc a b c d e f-\u003e(Proc a b c d e f,[(c,Proc a b c d e f)])",
          "package": "libcspm",
          "partial": "Proc Into Components",
          "signature": "Proc seq op pn ev evs evm-\u003e(Proc seq op pn ev evs evm,[(pn,Proc seq op pn ev evs evm)])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-ProcessValues.html#v:splitProcIntoComponents"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Evaluator.ProcessValues",
          "name": "trimProcess",
          "package": "libcspm",
          "signature": "UnCompiledProc -\u003e UnCompiledProc",
          "source": "src/CSPM-Evaluator-ProcessValues.html#trimProcess",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Evaluator ProcessValues",
          "module": "CSPM.Evaluator.ProcessValues",
          "name": "trimProcess",
          "normalized": "UnCompiledProc-\u003eUnCompiledProc",
          "package": "libcspm",
          "partial": "Process",
          "signature": "UnCompiledProc-\u003eUnCompiledProc",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-ProcessValues.html#v:trimProcess"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Evaluator.Profiler",
          "name": "Profiler",
          "package": "libcspm",
          "source": "src/CSPM-Evaluator-Profiler.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "CSPM Evaluator Profiler",
          "module": "CSPM.Evaluator.Profiler",
          "name": "Profiler",
          "package": "libcspm",
          "partial": "Profiler",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-Profiler.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Evaluator.Profiler",
          "name": "ProfilerOptions",
          "package": "libcspm",
          "source": "src/CSPM-Evaluator-Profiler.html#ProfilerOptions",
          "type": "data"
        },
        "index": {
          "hierarchy": "CSPM Evaluator Profiler",
          "module": "CSPM.Evaluator.Profiler",
          "name": "ProfilerOptions",
          "package": "libcspm",
          "partial": "Profiler Options",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-Profiler.html#t:ProfilerOptions"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Evaluator.Profiler",
          "name": "ProfilerState",
          "package": "libcspm",
          "source": "src/CSPM-Evaluator-Profiler.html#ProfilerState",
          "type": "data"
        },
        "index": {
          "hierarchy": "CSPM Evaluator Profiler",
          "module": "CSPM.Evaluator.Profiler",
          "name": "ProfilerState",
          "package": "libcspm",
          "partial": "Profiler State",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-Profiler.html#t:ProfilerState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Evaluator.Profiler",
          "name": "ProfilingData",
          "package": "libcspm",
          "source": "src/CSPM-Evaluator-Profiler.html#ProfilingData",
          "type": "data"
        },
        "index": {
          "hierarchy": "CSPM Evaluator Profiler",
          "module": "CSPM.Evaluator.Profiler",
          "name": "ProfilingData",
          "package": "libcspm",
          "partial": "Profiling Data",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-Profiler.html#t:ProfilingData"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"CSPM.Evaluator.Profiler\",\"CSPM.Evaluator\",\"CSPM\"]",
          "name": "ProfilerOptions",
          "package": "libcspm",
          "signature": "ProfilerOptions",
          "source": "src/CSPM-Evaluator-Profiler.html#ProfilerOptions",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-Profiler.html#v:ProfilerOptions\",\"http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator.html#v:ProfilerOptions\",\"http://hackage.haskell.org/package/libcspm/docs/CSPM.html#v:ProfilerOptions\"]"
        },
        "index": {
          "hierarchy": "CSPM Evaluator Profiler",
          "module": "CSPM.Evaluator.Profiler",
          "name": "ProfilerOptions",
          "package": "libcspm",
          "partial": "Profiler Options",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-Profiler.html#v:ProfilerOptions"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"CSPM.Evaluator.Profiler\",\"CSPM.Evaluator\",\"CSPM\"]",
          "name": "defaultProfilerOptions",
          "package": "libcspm",
          "signature": "ProfilerOptions",
          "source": "src/CSPM-Evaluator-Profiler.html#defaultProfilerOptions",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-Profiler.html#v:defaultProfilerOptions\",\"http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator.html#v:defaultProfilerOptions\",\"http://hackage.haskell.org/package/libcspm/docs/CSPM.html#v:defaultProfilerOptions\"]"
        },
        "index": {
          "hierarchy": "CSPM Evaluator Profiler",
          "module": "CSPM.Evaluator.Profiler",
          "name": "defaultProfilerOptions",
          "package": "libcspm",
          "partial": "Profiler Options",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-Profiler.html#v:defaultProfilerOptions"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"CSPM.Evaluator.Profiler\",\"CSPM.Evaluator\",\"CSPM\"]",
          "name": "flattenRecursiveCalls",
          "package": "libcspm",
          "signature": "Bool",
          "source": "src/CSPM-Evaluator-Profiler.html#ProfilerOptions",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-Profiler.html#v:flattenRecursiveCalls\",\"http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator.html#v:flattenRecursiveCalls\",\"http://hackage.haskell.org/package/libcspm/docs/CSPM.html#v:flattenRecursiveCalls\"]"
        },
        "index": {
          "hierarchy": "CSPM Evaluator Profiler",
          "module": "CSPM.Evaluator.Profiler",
          "name": "flattenRecursiveCalls",
          "package": "libcspm",
          "partial": "Recursive Calls",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-Profiler.html#v:flattenRecursiveCalls"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Evaluator.Profiler",
          "name": "getProfilingData",
          "package": "libcspm",
          "signature": "EvaluationMonad ProfilingData",
          "source": "src/CSPM-Evaluator-Profiler.html#getProfilingData",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Evaluator Profiler",
          "module": "CSPM.Evaluator.Profiler",
          "name": "getProfilingData",
          "package": "libcspm",
          "partial": "Profiling Data",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-Profiler.html#v:getProfilingData"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Evaluator.Profiler",
          "name": "initialProfilerState",
          "package": "libcspm",
          "signature": "ProfilerOptions -\u003e IO ProfilerState",
          "source": "src/CSPM-Evaluator-Profiler.html#initialProfilerState",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Evaluator Profiler",
          "module": "CSPM.Evaluator.Profiler",
          "name": "initialProfilerState",
          "normalized": "ProfilerOptions-\u003eIO ProfilerState",
          "package": "libcspm",
          "partial": "Profiler State",
          "signature": "ProfilerOptions-\u003eIO ProfilerState",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-Profiler.html#v:initialProfilerState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"CSPM.Evaluator.Profiler\",\"CSPM.Evaluator\",\"CSPM\"]",
          "name": "isActive",
          "package": "libcspm",
          "signature": "Bool",
          "source": "src/CSPM-Evaluator-Profiler.html#ProfilerOptions",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-Profiler.html#v:isActive\",\"http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator.html#v:isActive\",\"http://hackage.haskell.org/package/libcspm/docs/CSPM.html#v:isActive\"]"
        },
        "index": {
          "hierarchy": "CSPM Evaluator Profiler",
          "module": "CSPM.Evaluator.Profiler",
          "name": "isActive",
          "package": "libcspm",
          "partial": "Active",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-Profiler.html#v:isActive"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Evaluator.Profiler",
          "name": "maybeRegisterCall",
          "package": "libcspm",
          "signature": "EvaluationMonad (Name -\u003e EvaluationMonad a -\u003e EvaluationMonad a)",
          "source": "src/CSPM-Evaluator-Profiler.html#maybeRegisterCall",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Evaluator Profiler",
          "module": "CSPM.Evaluator.Profiler",
          "name": "maybeRegisterCall",
          "normalized": "EvaluationMonad(Name-\u003eEvaluationMonad a-\u003eEvaluationMonad a)",
          "package": "libcspm",
          "partial": "Register Call",
          "signature": "EvaluationMonad(Name-\u003eEvaluationMonad a-\u003eEvaluationMonad a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-Profiler.html#v:maybeRegisterCall"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Evaluator.Profiler",
          "name": "profilerActive",
          "package": "libcspm",
          "signature": "EvaluationState -\u003e Bool",
          "source": "src/CSPM-Evaluator-Profiler.html#profilerActive",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Evaluator Profiler",
          "module": "CSPM.Evaluator.Profiler",
          "name": "profilerActive",
          "normalized": "EvaluationState-\u003eBool",
          "package": "libcspm",
          "partial": "Active",
          "signature": "EvaluationState-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-Profiler.html#v:profilerActive"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Evaluator.Profiler",
          "name": "registerCall",
          "package": "libcspm",
          "signature": "Name -\u003e EvaluationMonad a -\u003e EvaluationMonad a",
          "source": "src/CSPM-Evaluator-Profiler.html#registerCall",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Evaluator Profiler",
          "module": "CSPM.Evaluator.Profiler",
          "name": "registerCall",
          "normalized": "Name-\u003eEvaluationMonad a-\u003eEvaluationMonad a",
          "package": "libcspm",
          "partial": "Call",
          "signature": "Name-\u003eEvaluationMonad a-\u003eEvaluationMonad a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-Profiler.html#v:registerCall"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Evaluator.ValuePrettyPrinter",
          "name": "ValuePrettyPrinter",
          "package": "libcspm",
          "source": "src/CSPM-Evaluator-ValuePrettyPrinter.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "CSPM Evaluator ValuePrettyPrinter",
          "module": "CSPM.Evaluator.ValuePrettyPrinter",
          "name": "ValuePrettyPrinter",
          "package": "libcspm",
          "partial": "Value Pretty Printer",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-ValuePrettyPrinter.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePretty prints the given process and all processes that it depends upon.\n\u003c/p\u003e",
          "module": "CSPM.Evaluator.ValuePrettyPrinter",
          "name": "prettyPrintAllRequiredProcesses",
          "package": "libcspm",
          "signature": "Proc seq op ProcName ev evs evm -\u003e Doc",
          "source": "src/CSPM-Evaluator-ValuePrettyPrinter.html#prettyPrintAllRequiredProcesses",
          "type": "function"
        },
        "index": {
          "description": "Pretty prints the given process and all processes that it depends upon",
          "hierarchy": "CSPM Evaluator ValuePrettyPrinter",
          "module": "CSPM.Evaluator.ValuePrettyPrinter",
          "name": "prettyPrintAllRequiredProcesses",
          "normalized": "Proc a b ProcName c d e-\u003eDoc",
          "package": "libcspm",
          "partial": "Print All Required Processes",
          "signature": "Proc seq op ProcName ev evs evm-\u003eDoc",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-ValuePrettyPrinter.html#v:prettyPrintAllRequiredProcesses"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eProvides a set implementation for machine CSP sets. This relies heavily\n on the type checking and assumes in many places that the sets being operated\n on are suitable for the opertion in question.\n\u003c/p\u003e\u003cp\u003eWe cannot just use the built in set implementation as FDR assumes in several\n places that infinite sets are allowed.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "CSPM.Evaluator.ValueSet",
          "name": "ValueSet",
          "package": "libcspm",
          "source": "src/CSPM-Evaluator-ValueSet.html",
          "type": "module"
        },
        "index": {
          "description": "Provides set implementation for machine CSP sets This relies heavily on the type checking and assumes in many places that the sets being operated on are suitable for the opertion in question We cannot just use the built in set implementation as FDR assumes in several places that infinite sets are allowed",
          "hierarchy": "CSPM Evaluator ValueSet",
          "module": "CSPM.Evaluator.ValueSet",
          "name": "ValueSet",
          "package": "libcspm",
          "partial": "Value Set",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-ValueSet.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Evaluator.ValueSet",
          "name": "CartProductType",
          "package": "libcspm",
          "source": "src/CSPM-Evaluator-ValueSet.html#CartProductType",
          "type": "data"
        },
        "index": {
          "hierarchy": "CSPM Evaluator ValueSet",
          "module": "CSPM.Evaluator.ValueSet",
          "name": "CartProductType",
          "package": "libcspm",
          "partial": "Cart Product Type",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-ValueSet.html#t:CartProductType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Evaluator.ValueSet",
          "name": "ValueSet",
          "package": "libcspm",
          "source": "src/CSPM-Evaluator-ValueSet.html#ValueSet",
          "type": "data"
        },
        "index": {
          "hierarchy": "CSPM Evaluator ValueSet",
          "module": "CSPM.Evaluator.ValueSet",
          "name": "ValueSet",
          "package": "libcspm",
          "partial": "Value Set",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-ValueSet.html#t:ValueSet"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe set of all maps from the given domain to the given image.\n\u003c/p\u003e",
          "module": "CSPM.Evaluator.ValueSet",
          "name": "AllMaps",
          "package": "libcspm",
          "signature": "AllMaps ValueSet ValueSet",
          "source": "src/CSPM-Evaluator-ValueSet.html#ValueSet",
          "type": "function"
        },
        "index": {
          "description": "The set of all maps from the given domain to the given image",
          "hierarchy": "CSPM Evaluator ValueSet",
          "module": "CSPM.Evaluator.ValueSet",
          "name": "AllMaps",
          "package": "libcspm",
          "partial": "All Maps",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-ValueSet.html#v:AllMaps"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA set containing all sequences over the given set.\n\u003c/p\u003e",
          "module": "CSPM.Evaluator.ValueSet",
          "name": "AllSequences",
          "package": "libcspm",
          "signature": "AllSequences ValueSet",
          "source": "src/CSPM-Evaluator-ValueSet.html#ValueSet",
          "type": "function"
        },
        "index": {
          "description": "set containing all sequences over the given set",
          "hierarchy": "CSPM Evaluator ValueSet",
          "module": "CSPM.Evaluator.ValueSet",
          "name": "AllSequences",
          "package": "libcspm",
          "partial": "All Sequences",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-ValueSet.html#v:AllSequences"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Evaluator.ValueSet",
          "name": "CartDot",
          "package": "libcspm",
          "signature": "CartDot",
          "source": "src/CSPM-Evaluator-ValueSet.html#CartProductType",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Evaluator ValueSet",
          "module": "CSPM.Evaluator.ValueSet",
          "name": "CartDot",
          "package": "libcspm",
          "partial": "Cart Dot",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-ValueSet.html#v:CartDot"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Evaluator.ValueSet",
          "name": "CartTuple",
          "package": "libcspm",
          "signature": "CartTuple",
          "source": "src/CSPM-Evaluator-ValueSet.html#CartProductType",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Evaluator ValueSet",
          "module": "CSPM.Evaluator.ValueSet",
          "name": "CartTuple",
          "package": "libcspm",
          "partial": "Cart Tuple",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-ValueSet.html#v:CartTuple"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA cartesian product of several sets.\n\u003c/p\u003e",
          "module": "CSPM.Evaluator.ValueSet",
          "name": "CartesianProduct",
          "package": "libcspm",
          "signature": "CartesianProduct [ValueSet] CartProductType",
          "source": "src/CSPM-Evaluator-ValueSet.html#ValueSet",
          "type": "function"
        },
        "index": {
          "description": "cartesian product of several sets",
          "hierarchy": "CSPM Evaluator ValueSet",
          "module": "CSPM.Evaluator.ValueSet",
          "name": "CartesianProduct",
          "normalized": "CartesianProduct[ValueSet]CartProductType",
          "package": "libcspm",
          "partial": "Cartesian Product",
          "signature": "CartesianProduct[ValueSet]CartProductType",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-ValueSet.html#v:CartesianProduct"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA union of several sets.\n\u003c/p\u003e",
          "module": "CSPM.Evaluator.ValueSet",
          "name": "CompositeSet",
          "package": "libcspm",
          "signature": "CompositeSet (Seq ValueSet)",
          "source": "src/CSPM-Evaluator-ValueSet.html#ValueSet",
          "type": "function"
        },
        "index": {
          "description": "union of several sets",
          "hierarchy": "CSPM Evaluator ValueSet",
          "module": "CSPM.Evaluator.ValueSet",
          "name": "CompositeSet",
          "package": "libcspm",
          "partial": "Composite Set",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-ValueSet.html#v:CompositeSet"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn explicit set of values\n\u003c/p\u003e",
          "module": "CSPM.Evaluator.ValueSet",
          "name": "ExplicitSet",
          "package": "libcspm",
          "signature": "ExplicitSet (Set Value)",
          "source": "src/CSPM-Evaluator-ValueSet.html#ValueSet",
          "type": "function"
        },
        "index": {
          "description": "An explicit set of values",
          "hierarchy": "CSPM Evaluator ValueSet",
          "module": "CSPM.Evaluator.ValueSet",
          "name": "ExplicitSet",
          "package": "libcspm",
          "partial": "Explicit Set",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-ValueSet.html#v:ExplicitSet"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe infinite set of integers starting at lb.\n\u003c/p\u003e",
          "module": "CSPM.Evaluator.ValueSet",
          "name": "IntSetFrom",
          "package": "libcspm",
          "signature": "IntSetFrom Int",
          "source": "src/CSPM-Evaluator-ValueSet.html#ValueSet",
          "type": "function"
        },
        "index": {
          "description": "The infinite set of integers starting at lb",
          "hierarchy": "CSPM Evaluator ValueSet",
          "module": "CSPM.Evaluator.ValueSet",
          "name": "IntSetFrom",
          "package": "libcspm",
          "partial": "Int Set From",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-ValueSet.html#v:IntSetFrom"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSet of all integers\n\u003c/p\u003e",
          "module": "CSPM.Evaluator.ValueSet",
          "name": "Integers",
          "package": "libcspm",
          "signature": "Integers",
          "source": "src/CSPM-Evaluator-ValueSet.html#ValueSet",
          "type": "function"
        },
        "index": {
          "description": "Set of all integers",
          "hierarchy": "CSPM Evaluator ValueSet",
          "module": "CSPM.Evaluator.ValueSet",
          "name": "Integers",
          "package": "libcspm",
          "partial": "Integers",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-ValueSet.html#v:Integers"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe powerset of the given set\n\u003c/p\u003e",
          "module": "CSPM.Evaluator.ValueSet",
          "name": "Powerset",
          "package": "libcspm",
          "signature": "Powerset ValueSet",
          "source": "src/CSPM-Evaluator-ValueSet.html#ValueSet",
          "type": "function"
        },
        "index": {
          "description": "The powerset of the given set",
          "hierarchy": "CSPM Evaluator ValueSet",
          "module": "CSPM.Evaluator.ValueSet",
          "name": "Powerset",
          "package": "libcspm",
          "partial": "Powerset",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-ValueSet.html#v:Powerset"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSet of all processes\n\u003c/p\u003e",
          "module": "CSPM.Evaluator.ValueSet",
          "name": "Processes",
          "package": "libcspm",
          "signature": "Processes",
          "source": "src/CSPM-Evaluator-ValueSet.html#ValueSet",
          "type": "function"
        },
        "index": {
          "description": "Set of all processes",
          "hierarchy": "CSPM Evaluator ValueSet",
          "module": "CSPM.Evaluator.ValueSet",
          "name": "Processes",
          "package": "libcspm",
          "partial": "Processes",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-ValueSet.html#v:Processes"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Evaluator.ValueSet",
          "name": "allMaps",
          "package": "libcspm",
          "signature": "ValueSet -\u003e ValueSet -\u003e ValueSet",
          "source": "src/CSPM-Evaluator-ValueSet.html#allMaps",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Evaluator ValueSet",
          "module": "CSPM.Evaluator.ValueSet",
          "name": "allMaps",
          "normalized": "ValueSet-\u003eValueSet-\u003eValueSet",
          "package": "libcspm",
          "partial": "Maps",
          "signature": "ValueSet-\u003eValueSet-\u003eValueSet",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-ValueSet.html#v:allMaps"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturns the set of all sequences over the input set. This is infinite\n so we use a CompositeSet.\n\u003c/p\u003e",
          "module": "CSPM.Evaluator.ValueSet",
          "name": "allSequences",
          "package": "libcspm",
          "signature": "ValueSet -\u003e ValueSet",
          "source": "src/CSPM-Evaluator-ValueSet.html#allSequences",
          "type": "function"
        },
        "index": {
          "description": "Returns the set of all sequences over the input set This is infinite so we use CompositeSet",
          "hierarchy": "CSPM Evaluator ValueSet",
          "module": "CSPM.Evaluator.ValueSet",
          "name": "allSequences",
          "normalized": "ValueSet-\u003eValueSet",
          "package": "libcspm",
          "partial": "Sequences",
          "signature": "ValueSet-\u003eValueSet",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-ValueSet.html#v:allSequences"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe cardinality of the set. Throws an error if the set is infinite.\n\u003c/p\u003e",
          "module": "CSPM.Evaluator.ValueSet",
          "name": "card",
          "package": "libcspm",
          "signature": "ValueSet -\u003e Integer",
          "source": "src/CSPM-Evaluator-ValueSet.html#card",
          "type": "function"
        },
        "index": {
          "description": "The cardinality of the set Throws an error if the set is infinite",
          "hierarchy": "CSPM Evaluator ValueSet",
          "module": "CSPM.Evaluator.ValueSet",
          "name": "card",
          "normalized": "ValueSet-\u003eInteger",
          "package": "libcspm",
          "signature": "ValueSet-\u003eInteger",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-ValueSet.html#v:card"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eProduces a ValueSet of the carteisan product of several ValueSets, \n using \u003ccode\u003evc\u003c/code\u003e to convert each sequence of values into a single value.\n\u003c/p\u003e",
          "module": "CSPM.Evaluator.ValueSet",
          "name": "cartesianProduct",
          "package": "libcspm",
          "signature": "CartProductType -\u003e [ValueSet] -\u003e ValueSet",
          "source": "src/CSPM-Evaluator-ValueSet.html#cartesianProduct",
          "type": "function"
        },
        "index": {
          "description": "Produces ValueSet of the carteisan product of several ValueSets using vc to convert each sequence of values into single value",
          "hierarchy": "CSPM Evaluator ValueSet",
          "module": "CSPM.Evaluator.ValueSet",
          "name": "cartesianProduct",
          "normalized": "CartProductType-\u003e[ValueSet]-\u003eValueSet",
          "package": "libcspm",
          "partial": "Product",
          "signature": "CartProductType-\u003e[ValueSet]-\u003eValueSet",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-ValueSet.html#v:cartesianProduct"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCompares two value sets using subseteq (as per the specification).\n\u003c/p\u003e",
          "module": "CSPM.Evaluator.ValueSet",
          "name": "compareValueSets",
          "package": "libcspm",
          "signature": "ValueSet -\u003e ValueSet -\u003e Maybe Ordering",
          "source": "src/CSPM-Evaluator-ValueSet.html#compareValueSets",
          "type": "function"
        },
        "index": {
          "description": "Compares two value sets using subseteq as per the specification",
          "hierarchy": "CSPM Evaluator ValueSet",
          "module": "CSPM.Evaluator.ValueSet",
          "name": "compareValueSets",
          "normalized": "ValueSet-\u003eValueSet-\u003eMaybe Ordering",
          "package": "libcspm",
          "partial": "Value Sets",
          "signature": "ValueSet-\u003eValueSet-\u003eMaybe Ordering",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-ValueSet.html#v:compareValueSets"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Evaluator.ValueSet",
          "name": "difference",
          "package": "libcspm",
          "signature": "ValueSet -\u003e ValueSet -\u003e ValueSet",
          "source": "src/CSPM-Evaluator-ValueSet.html#difference",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Evaluator ValueSet",
          "module": "CSPM.Evaluator.ValueSet",
          "name": "difference",
          "normalized": "ValueSet-\u003eValueSet-\u003eValueSet",
          "package": "libcspm",
          "signature": "ValueSet-\u003eValueSet-\u003eValueSet",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-ValueSet.html#v:difference"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIs the specified set empty?\n\u003c/p\u003e",
          "module": "CSPM.Evaluator.ValueSet",
          "name": "empty",
          "package": "libcspm",
          "signature": "ValueSet -\u003e Bool",
          "source": "src/CSPM-Evaluator-ValueSet.html#empty",
          "type": "function"
        },
        "index": {
          "description": "Is the specified set empty",
          "hierarchy": "CSPM Evaluator ValueSet",
          "module": "CSPM.Evaluator.ValueSet",
          "name": "empty",
          "normalized": "ValueSet-\u003eBool",
          "package": "libcspm",
          "signature": "ValueSet-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-ValueSet.html#v:empty"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe empty set\n\u003c/p\u003e",
          "module": "CSPM.Evaluator.ValueSet",
          "name": "emptySet",
          "package": "libcspm",
          "signature": "ValueSet",
          "source": "src/CSPM-Evaluator-ValueSet.html#emptySet",
          "type": "function"
        },
        "index": {
          "description": "The empty set",
          "hierarchy": "CSPM Evaluator ValueSet",
          "module": "CSPM.Evaluator.ValueSet",
          "name": "emptySet",
          "package": "libcspm",
          "partial": "Set",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-ValueSet.html#v:emptySet"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Evaluator.ValueSet",
          "name": "fastUnDotCartProduct",
          "package": "libcspm",
          "signature": "ValueSet -\u003e Maybe [ValueSet]",
          "source": "src/CSPM-Evaluator-ValueSet.html#fastUnDotCartProduct",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Evaluator ValueSet",
          "module": "CSPM.Evaluator.ValueSet",
          "name": "fastUnDotCartProduct",
          "normalized": "ValueSet-\u003eMaybe[ValueSet]",
          "package": "libcspm",
          "partial": "Un Dot Cart Product",
          "signature": "ValueSet-\u003eMaybe[ValueSet]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-ValueSet.html#v:fastUnDotCartProduct"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConverts a list to a set\n\u003c/p\u003e",
          "module": "CSPM.Evaluator.ValueSet",
          "name": "fromList",
          "package": "libcspm",
          "signature": "[Value] -\u003e ValueSet",
          "source": "src/CSPM-Evaluator-ValueSet.html#fromList",
          "type": "function"
        },
        "index": {
          "description": "Converts list to set",
          "hierarchy": "CSPM Evaluator ValueSet",
          "module": "CSPM.Evaluator.ValueSet",
          "name": "fromList",
          "normalized": "[Value]-\u003eValueSet",
          "package": "libcspm",
          "partial": "List",
          "signature": "[Value]-\u003eValueSet",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-ValueSet.html#v:fromList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Evaluator.ValueSet",
          "name": "infiniteUnions",
          "package": "libcspm",
          "signature": "[ValueSet] -\u003e ValueSet",
          "source": "src/CSPM-Evaluator-ValueSet.html#infiniteUnions",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Evaluator ValueSet",
          "module": "CSPM.Evaluator.ValueSet",
          "name": "infiniteUnions",
          "normalized": "[ValueSet]-\u003eValueSet",
          "package": "libcspm",
          "partial": "Unions",
          "signature": "[ValueSet]-\u003eValueSet",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-ValueSet.html#v:infiniteUnions"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIntersects two sets throwing an error if it cannot be done in a way that \n will terminate.\n\u003c/p\u003e",
          "module": "CSPM.Evaluator.ValueSet",
          "name": "intersection",
          "package": "libcspm",
          "signature": "ValueSet -\u003e ValueSet -\u003e ValueSet",
          "source": "src/CSPM-Evaluator-ValueSet.html#intersection",
          "type": "function"
        },
        "index": {
          "description": "Intersects two sets throwing an error if it cannot be done in way that will terminate",
          "hierarchy": "CSPM Evaluator ValueSet",
          "module": "CSPM.Evaluator.ValueSet",
          "name": "intersection",
          "normalized": "ValueSet-\u003eValueSet-\u003eValueSet",
          "package": "libcspm",
          "signature": "ValueSet-\u003eValueSet-\u003eValueSet",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-ValueSet.html#v:intersection"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReplicated intersection.\n\u003c/p\u003e",
          "module": "CSPM.Evaluator.ValueSet",
          "name": "intersections",
          "package": "libcspm",
          "signature": "[ValueSet] -\u003e ValueSet",
          "source": "src/CSPM-Evaluator-ValueSet.html#intersections",
          "type": "function"
        },
        "index": {
          "description": "Replicated intersection",
          "hierarchy": "CSPM Evaluator ValueSet",
          "module": "CSPM.Evaluator.ValueSet",
          "name": "intersections",
          "normalized": "[ValueSet]-\u003eValueSet",
          "package": "libcspm",
          "signature": "[ValueSet]-\u003eValueSet",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-ValueSet.html#v:intersections"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIs the specified value a member of the set.\n\u003c/p\u003e",
          "module": "CSPM.Evaluator.ValueSet",
          "name": "member",
          "package": "libcspm",
          "signature": "Value -\u003e ValueSet -\u003e Bool",
          "source": "src/CSPM-Evaluator-ValueSet.html#member",
          "type": "function"
        },
        "index": {
          "description": "Is the specified value member of the set",
          "hierarchy": "CSPM Evaluator ValueSet",
          "module": "CSPM.Evaluator.ValueSet",
          "name": "member",
          "normalized": "Value-\u003eValueSet-\u003eBool",
          "package": "libcspm",
          "signature": "Value-\u003eValueSet-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-ValueSet.html#v:member"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Evaluator.ValueSet",
          "name": "powerset",
          "package": "libcspm",
          "signature": "ValueSet -\u003e ValueSet",
          "source": "src/CSPM-Evaluator-ValueSet.html#powerset",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Evaluator ValueSet",
          "module": "CSPM.Evaluator.ValueSet",
          "name": "powerset",
          "normalized": "ValueSet-\u003eValueSet",
          "package": "libcspm",
          "signature": "ValueSet-\u003eValueSet",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-ValueSet.html#v:powerset"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturns the value iff the set contains one item only.\n\u003c/p\u003e",
          "module": "CSPM.Evaluator.ValueSet",
          "name": "singletonValue",
          "package": "libcspm",
          "signature": "ValueSet -\u003e Maybe Value",
          "source": "src/CSPM-Evaluator-ValueSet.html#singletonValue",
          "type": "function"
        },
        "index": {
          "description": "Returns the value iff the set contains one item only",
          "hierarchy": "CSPM Evaluator ValueSet",
          "module": "CSPM.Evaluator.ValueSet",
          "name": "singletonValue",
          "normalized": "ValueSet-\u003eMaybe Value",
          "package": "libcspm",
          "partial": "Value",
          "signature": "ValueSet-\u003eMaybe Value",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-ValueSet.html#v:singletonValue"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConverts a set to list.\n\u003c/p\u003e",
          "module": "CSPM.Evaluator.ValueSet",
          "name": "toList",
          "package": "libcspm",
          "signature": "ValueSet -\u003e [Value]",
          "source": "src/CSPM-Evaluator-ValueSet.html#toList",
          "type": "function"
        },
        "index": {
          "description": "Converts set to list",
          "hierarchy": "CSPM Evaluator ValueSet",
          "module": "CSPM.Evaluator.ValueSet",
          "name": "toList",
          "normalized": "ValueSet-\u003e[Value]",
          "package": "libcspm",
          "partial": "List",
          "signature": "ValueSet-\u003e[Value]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-ValueSet.html#v:toList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Evaluator.ValueSet",
          "name": "toSeq",
          "package": "libcspm",
          "signature": "ValueSet -\u003e Seq Value",
          "source": "src/CSPM-Evaluator-ValueSet.html#toSeq",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Evaluator ValueSet",
          "module": "CSPM.Evaluator.ValueSet",
          "name": "toSeq",
          "normalized": "ValueSet-\u003eSeq Value",
          "package": "libcspm",
          "partial": "Seq",
          "signature": "ValueSet-\u003eSeq Value",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-ValueSet.html#v:toSeq"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAttempts to decompose the set into a cartesian product, returning Nothing\n if it cannot.\n\u003c/p\u003e",
          "module": "CSPM.Evaluator.ValueSet",
          "name": "unDotProduct",
          "package": "libcspm",
          "signature": "ValueSet -\u003e Maybe [ValueSet]",
          "source": "src/CSPM-Evaluator-ValueSet.html#unDotProduct",
          "type": "function"
        },
        "index": {
          "description": "Attempts to decompose the set into cartesian product returning Nothing if it cannot",
          "hierarchy": "CSPM Evaluator ValueSet",
          "module": "CSPM.Evaluator.ValueSet",
          "name": "unDotProduct",
          "normalized": "ValueSet-\u003eMaybe[ValueSet]",
          "package": "libcspm",
          "partial": "Dot Product",
          "signature": "ValueSet-\u003eMaybe[ValueSet]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-ValueSet.html#v:unDotProduct"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUnion two sets throwing an error if it cannot be done in a way that will\n terminate.\n\u003c/p\u003e",
          "module": "CSPM.Evaluator.ValueSet",
          "name": "union",
          "package": "libcspm",
          "signature": "ValueSet -\u003e ValueSet -\u003e ValueSet",
          "source": "src/CSPM-Evaluator-ValueSet.html#union",
          "type": "function"
        },
        "index": {
          "description": "Union two sets throwing an error if it cannot be done in way that will terminate",
          "hierarchy": "CSPM Evaluator ValueSet",
          "module": "CSPM.Evaluator.ValueSet",
          "name": "union",
          "normalized": "ValueSet-\u003eValueSet-\u003eValueSet",
          "package": "libcspm",
          "signature": "ValueSet-\u003eValueSet-\u003eValueSet",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-ValueSet.html#v:union"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReplicated union.\n\u003c/p\u003e",
          "module": "CSPM.Evaluator.ValueSet",
          "name": "unions",
          "package": "libcspm",
          "signature": "[ValueSet] -\u003e ValueSet",
          "source": "src/CSPM-Evaluator-ValueSet.html#unions",
          "type": "function"
        },
        "index": {
          "description": "Replicated union",
          "hierarchy": "CSPM Evaluator ValueSet",
          "module": "CSPM.Evaluator.ValueSet",
          "name": "unions",
          "normalized": "[ValueSet]-\u003eValueSet",
          "package": "libcspm",
          "signature": "[ValueSet]-\u003eValueSet",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-ValueSet.html#v:unions"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Evaluator.ValueSet",
          "name": "valueSetToEventSet",
          "package": "libcspm",
          "signature": "ValueSet -\u003e EventSet",
          "source": "src/CSPM-Evaluator-ValueSet.html#valueSetToEventSet",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Evaluator ValueSet",
          "module": "CSPM.Evaluator.ValueSet",
          "name": "valueSetToEventSet",
          "normalized": "ValueSet-\u003eEventSet",
          "package": "libcspm",
          "partial": "Set To Event Set",
          "signature": "ValueSet-\u003eEventSet",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-ValueSet.html#v:valueSetToEventSet"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Evaluator.Values",
          "name": "Values",
          "package": "libcspm",
          "source": "src/CSPM-Evaluator-Values.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "CSPM Evaluator Values",
          "module": "CSPM.Evaluator.Values",
          "name": "Values",
          "package": "libcspm",
          "partial": "Values",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-Values.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Evaluator.Values",
          "name": "CSPOperator",
          "package": "libcspm",
          "source": "src/CSPM-Evaluator-ProcessValues.html#CSPOperator",
          "type": "data"
        },
        "index": {
          "hierarchy": "CSPM Evaluator Values",
          "module": "CSPM.Evaluator.Values",
          "name": "CSPOperator",
          "package": "libcspm",
          "partial": "CSPOperator",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-Values.html#t:CSPOperator"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEvents, as represented in the LTS.\n\u003c/p\u003e",
          "module": "CSPM.Evaluator.Values",
          "name": "Event",
          "package": "libcspm",
          "source": "src/CSPM-Evaluator-ProcessValues.html#Event",
          "type": "data"
        },
        "index": {
          "description": "Events as represented in the LTS",
          "hierarchy": "CSPM Evaluator Values",
          "module": "CSPM.Evaluator.Values",
          "name": "Event",
          "package": "libcspm",
          "partial": "Event",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-Values.html#t:Event"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Evaluator.Values",
          "name": "EventSet",
          "package": "libcspm",
          "source": "src/CSPM-Evaluator-ProcessValues.html#EventSet",
          "type": "type"
        },
        "index": {
          "hierarchy": "CSPM Evaluator Values",
          "module": "CSPM.Evaluator.Values",
          "name": "EventSet",
          "package": "libcspm",
          "partial": "Event Set",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-Values.html#t:EventSet"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Evaluator.Values",
          "name": "FunctionIdentifier",
          "package": "libcspm",
          "source": "src/CSPM-Evaluator-Values.html#FunctionIdentifier",
          "type": "data"
        },
        "index": {
          "hierarchy": "CSPM Evaluator Values",
          "module": "CSPM.Evaluator.Values",
          "name": "FunctionIdentifier",
          "package": "libcspm",
          "partial": "Function Identifier",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-Values.html#t:FunctionIdentifier"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA compiled process. Note this is an infinite data structure (due to\n PProcCall) as this makes compilation easy (we can easily chase\n dependencies).\n\u003c/p\u003e",
          "module": "CSPM.Evaluator.Values",
          "name": "Proc",
          "package": "libcspm",
          "source": "src/CSPM-Evaluator-ProcessValues.html#Proc",
          "type": "data"
        },
        "index": {
          "description": "compiled process Note this is an infinite data structure due to PProcCall as this makes compilation easy we can easily chase dependencies",
          "hierarchy": "CSPM Evaluator Values",
          "module": "CSPM.Evaluator.Values",
          "name": "Proc",
          "package": "libcspm",
          "partial": "Proc",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-Values.html#t:Proc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn operator that can be applied to processes.\n\u003c/p\u003e",
          "module": "CSPM.Evaluator.Values",
          "name": "ProcOperator",
          "package": "libcspm",
          "source": "src/CSPM-Evaluator-ProcessValues.html#ProcOperator",
          "type": "data"
        },
        "index": {
          "description": "An operator that can be applied to processes",
          "hierarchy": "CSPM Evaluator Values",
          "module": "CSPM.Evaluator.Values",
          "name": "ProcOperator",
          "package": "libcspm",
          "partial": "Proc Operator",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-Values.html#t:ProcOperator"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA disambiguator between different occurences of either processes or\n functions. This works by storing the values that are bound (i.e. the free\n variables the inner \u003ccode\u003ething\u003c/code\u003e may depend on). This is used as a \u003ccode\u003e\u003ca\u003eProcName\u003c/a\u003e\u003c/code\u003e and\n for \u003ccode\u003e\u003ca\u003eFunctionIdentifier\u003c/a\u003e\u003c/code\u003es.\n\u003c/p\u003e",
          "module": "CSPM.Evaluator.Values",
          "name": "ScopeIdentifier",
          "package": "libcspm",
          "source": "src/CSPM-Evaluator-Values.html#ScopeIdentifier",
          "type": "data"
        },
        "index": {
          "description": "disambiguator between different occurences of either processes or functions This works by storing the values that are bound i.e the free variables the inner thing may depend on This is used as ProcName and for FunctionIdentifier",
          "hierarchy": "CSPM Evaluator Values",
          "module": "CSPM.Evaluator.Values",
          "name": "ScopeIdentifier",
          "package": "libcspm",
          "partial": "Scope Identifier",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-Values.html#t:ScopeIdentifier"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Evaluator.Values",
          "name": "UProc",
          "package": "libcspm",
          "source": "src/CSPM-Evaluator-Values.html#UProc",
          "type": "type"
        },
        "index": {
          "hierarchy": "CSPM Evaluator Values",
          "module": "CSPM.Evaluator.Values",
          "name": "UProc",
          "package": "libcspm",
          "partial": "UProc",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-Values.html#t:UProc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Evaluator.Values",
          "name": "UProcOperator",
          "package": "libcspm",
          "source": "src/CSPM-Evaluator-Values.html#UProcOperator",
          "type": "type"
        },
        "index": {
          "hierarchy": "CSPM Evaluator Values",
          "module": "CSPM.Evaluator.Values",
          "name": "UProcOperator",
          "package": "libcspm",
          "partial": "UProc Operator",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-Values.html#t:UProcOperator"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Evaluator.Values",
          "name": "Value",
          "package": "libcspm",
          "source": "src/CSPM-Evaluator-Values.html#Value",
          "type": "data"
        },
        "index": {
          "hierarchy": "CSPM Evaluator Values",
          "module": "CSPM.Evaluator.Values",
          "name": "Value",
          "package": "libcspm",
          "partial": "Value",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-Values.html#t:Value"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Evaluator.Values",
          "name": "FBuiltInFunction",
          "package": "libcspm",
          "signature": "FBuiltInFunction",
          "source": "src/CSPM-Evaluator-Values.html#FunctionIdentifier",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Evaluator Values",
          "module": "CSPM.Evaluator.Values",
          "name": "FBuiltInFunction",
          "package": "libcspm",
          "partial": "FBuilt In Function",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-Values.html#v:FBuiltInFunction"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Evaluator.Values",
          "name": "FLambda",
          "package": "libcspm",
          "signature": "FLambda",
          "source": "src/CSPM-Evaluator-Values.html#FunctionIdentifier",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Evaluator Values",
          "module": "CSPM.Evaluator.Values",
          "name": "FLambda",
          "package": "libcspm",
          "partial": "FLambda",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-Values.html#v:FLambda"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Evaluator.Values",
          "name": "FMatchBind",
          "package": "libcspm",
          "signature": "FMatchBind",
          "source": "src/CSPM-Evaluator-Values.html#FunctionIdentifier",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Evaluator Values",
          "module": "CSPM.Evaluator.Values",
          "name": "FMatchBind",
          "package": "libcspm",
          "partial": "FMatch Bind",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-Values.html#v:FMatchBind"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Evaluator.Values",
          "name": "SFunctionBind",
          "package": "libcspm",
          "signature": "SFunctionBind",
          "source": "src/CSPM-Evaluator-Values.html#ScopeIdentifier",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Evaluator Values",
          "module": "CSPM.Evaluator.Values",
          "name": "SFunctionBind",
          "package": "libcspm",
          "partial": "SFunction Bind",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-Values.html#v:SFunctionBind"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Evaluator.Values",
          "name": "SVariableBind",
          "package": "libcspm",
          "signature": "SVariableBind",
          "source": "src/CSPM-Evaluator-Values.html#ScopeIdentifier",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Evaluator Values",
          "module": "CSPM.Evaluator.Values",
          "name": "SVariableBind",
          "package": "libcspm",
          "partial": "SVariable Bind",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-Values.html#v:SVariableBind"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Evaluator.Values",
          "name": "VBool",
          "package": "libcspm",
          "signature": "VBool Bool",
          "source": "src/CSPM-Evaluator-Values.html#Value",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Evaluator Values",
          "module": "CSPM.Evaluator.Values",
          "name": "VBool",
          "package": "libcspm",
          "partial": "VBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-Values.html#v:VBool"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Evaluator.Values",
          "name": "VChannel",
          "package": "libcspm",
          "signature": "VChannel Name",
          "source": "src/CSPM-Evaluator-Values.html#Value",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Evaluator Values",
          "module": "CSPM.Evaluator.Values",
          "name": "VChannel",
          "package": "libcspm",
          "partial": "VChannel",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-Values.html#v:VChannel"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Evaluator.Values",
          "name": "VChar",
          "package": "libcspm",
          "signature": "VChar Char",
          "source": "src/CSPM-Evaluator-Values.html#Value",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Evaluator Values",
          "module": "CSPM.Evaluator.Values",
          "name": "VChar",
          "package": "libcspm",
          "partial": "VChar",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-Values.html#v:VChar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Evaluator.Values",
          "name": "VDataType",
          "package": "libcspm",
          "signature": "VDataType Name",
          "source": "src/CSPM-Evaluator-Values.html#Value",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Evaluator Values",
          "module": "CSPM.Evaluator.Values",
          "name": "VDataType",
          "package": "libcspm",
          "partial": "VData Type",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-Values.html#v:VDataType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIf A is a datatype clause that has 3 fields a b c then a runtime\n instantiation of this would be VDot [VDataType \u003ca\u003eA\u003c/a\u003e, a, b, c] where a,b\n and c can contain other VDots.\n\u003c/p\u003e",
          "module": "CSPM.Evaluator.Values",
          "name": "VDot",
          "package": "libcspm",
          "signature": "VDot [Value]",
          "source": "src/CSPM-Evaluator-Values.html#Value",
          "type": "function"
        },
        "index": {
          "description": "If is datatype clause that has fields then runtime instantiation of this would be VDot VDataType where and can contain other VDots",
          "hierarchy": "CSPM Evaluator Values",
          "module": "CSPM.Evaluator.Values",
          "name": "VDot",
          "normalized": "VDot[Value]",
          "package": "libcspm",
          "partial": "VDot",
          "signature": "VDot[Value]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-Values.html#v:VDot"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Evaluator.Values",
          "name": "VFunction",
          "package": "libcspm",
          "signature": "VFunction FunctionIdentifier ([Value] -\u003e EvaluationMonad Value)",
          "source": "src/CSPM-Evaluator-Values.html#Value",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Evaluator Values",
          "module": "CSPM.Evaluator.Values",
          "name": "VFunction",
          "normalized": "VFunction FunctionIdentifier([Value]-\u003eEvaluationMonad Value)",
          "package": "libcspm",
          "partial": "VFunction",
          "signature": "VFunction FunctionIdentifier([Value]-\u003eEvaluationMonad Value)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-Values.html#v:VFunction"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Evaluator.Values",
          "name": "VInt",
          "package": "libcspm",
          "signature": "VInt Int",
          "source": "src/CSPM-Evaluator-Values.html#Value",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Evaluator Values",
          "module": "CSPM.Evaluator.Values",
          "name": "VInt",
          "package": "libcspm",
          "partial": "VInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-Values.html#v:VInt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Evaluator.Values",
          "name": "VList",
          "package": "libcspm",
          "signature": "VList [Value]",
          "source": "src/CSPM-Evaluator-Values.html#Value",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Evaluator Values",
          "module": "CSPM.Evaluator.Values",
          "name": "VList",
          "normalized": "VList[Value]",
          "package": "libcspm",
          "partial": "VList",
          "signature": "VList[Value]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-Values.html#v:VList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Evaluator.Values",
          "name": "VMap",
          "package": "libcspm",
          "signature": "VMap (Map Value Value)",
          "source": "src/CSPM-Evaluator-Values.html#Value",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Evaluator Values",
          "module": "CSPM.Evaluator.Values",
          "name": "VMap",
          "package": "libcspm",
          "partial": "VMap",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-Values.html#v:VMap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Evaluator.Values",
          "name": "VProc",
          "package": "libcspm",
          "signature": "VProc UProc",
          "source": "src/CSPM-Evaluator-Values.html#Value",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Evaluator Values",
          "module": "CSPM.Evaluator.Values",
          "name": "VProc",
          "package": "libcspm",
          "partial": "VProc",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-Values.html#v:VProc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Evaluator.Values",
          "name": "VSet",
          "package": "libcspm",
          "signature": "VSet ValueSet",
          "source": "src/CSPM-Evaluator-Values.html#Value",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Evaluator Values",
          "module": "CSPM.Evaluator.Values",
          "name": "VSet",
          "package": "libcspm",
          "partial": "VSet",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-Values.html#v:VSet"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Evaluator.Values",
          "name": "VThunk",
          "package": "libcspm",
          "signature": "VThunk (EvaluationMonad Value)",
          "source": "src/CSPM-Evaluator-Values.html#Value",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Evaluator Values",
          "module": "CSPM.Evaluator.Values",
          "name": "VThunk",
          "package": "libcspm",
          "partial": "VThunk",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-Values.html#v:VThunk"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Evaluator.Values",
          "name": "VTuple",
          "package": "libcspm",
          "signature": "VTuple (Array Int Value)",
          "source": "src/CSPM-Evaluator-Values.html#Value",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Evaluator Values",
          "module": "CSPM.Evaluator.Values",
          "name": "VTuple",
          "package": "libcspm",
          "partial": "VTuple",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-Values.html#v:VTuple"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Evaluator.Values",
          "name": "annonymousScopeId",
          "package": "libcspm",
          "signature": "[Value] -\u003e Maybe ScopeIdentifier -\u003e ScopeIdentifier",
          "source": "src/CSPM-Evaluator-Values.html#annonymousScopeId",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Evaluator Values",
          "module": "CSPM.Evaluator.Values",
          "name": "annonymousScopeId",
          "normalized": "[Value]-\u003eMaybe ScopeIdentifier-\u003eScopeIdentifier",
          "package": "libcspm",
          "partial": "Scope Id",
          "signature": "[Value]-\u003eMaybe ScopeIdentifier-\u003eScopeIdentifier",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-Values.html#v:annonymousScopeId"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Evaluator.Values",
          "name": "argumentGroups",
          "package": "libcspm",
          "signature": "[[Value]]",
          "source": "src/CSPM-Evaluator-Values.html#FunctionIdentifier",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Evaluator Values",
          "module": "CSPM.Evaluator.Values",
          "name": "argumentGroups",
          "normalized": "[[Value]]",
          "package": "libcspm",
          "partial": "Groups",
          "signature": "[[Value]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-Values.html#v:argumentGroups"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Evaluator.Values",
          "name": "arguments",
          "package": "libcspm",
          "signature": "[Value]",
          "source": "src/CSPM-Evaluator-Values.html#FunctionIdentifier",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Evaluator Values",
          "module": "CSPM.Evaluator.Values",
          "name": "arguments",
          "normalized": "[Value]",
          "package": "libcspm",
          "signature": "[Value]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-Values.html#v:arguments"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eImplements CSPM comparisons (note that Ord Value does not).\n\u003c/p\u003e",
          "module": "CSPM.Evaluator.Values",
          "name": "compareValues",
          "package": "libcspm",
          "signature": "Value -\u003e Value -\u003e Maybe Ordering",
          "source": "src/CSPM-Evaluator-Values.html#compareValues",
          "type": "function"
        },
        "index": {
          "description": "Implements CSPM comparisons note that Ord Value does not",
          "hierarchy": "CSPM Evaluator Values",
          "module": "CSPM.Evaluator.Values",
          "name": "compareValues",
          "normalized": "Value-\u003eValue-\u003eMaybe Ordering",
          "package": "libcspm",
          "partial": "Values",
          "signature": "Value-\u003eValue-\u003eMaybe Ordering",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-Values.html#v:compareValues"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Evaluator.Values",
          "name": "functionName",
          "package": "libcspm",
          "signature": "Name",
          "source": "src/CSPM-Evaluator-Values.html#FunctionIdentifier",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Evaluator Values",
          "module": "CSPM.Evaluator.Values",
          "name": "functionName",
          "package": "libcspm",
          "partial": "Name",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-Values.html#v:functionName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Evaluator.Values",
          "name": "lambdaExpression",
          "package": "libcspm",
          "signature": "Exp Name",
          "source": "src/CSPM-Evaluator-Values.html#FunctionIdentifier",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Evaluator Values",
          "module": "CSPM.Evaluator.Values",
          "name": "lambdaExpression",
          "package": "libcspm",
          "partial": "Expression",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-Values.html#v:lambdaExpression"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Evaluator.Values",
          "name": "lookupVar",
          "package": "libcspm",
          "signature": "Name -\u003e EvaluationMonad Value",
          "source": "src/CSPM-Evaluator-Values.html#lookupVar",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Evaluator Values",
          "module": "CSPM.Evaluator.Values",
          "name": "lookupVar",
          "normalized": "Name-\u003eEvaluationMonad Value",
          "package": "libcspm",
          "partial": "Var",
          "signature": "Name-\u003eEvaluationMonad Value",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-Values.html#v:lookupVar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Evaluator.Values",
          "name": "maybeSave",
          "package": "libcspm",
          "signature": "Type -\u003e EvaluationMonad Value -\u003e EvaluationMonad Value",
          "source": "src/CSPM-Evaluator-Values.html#maybeSave",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Evaluator Values",
          "module": "CSPM.Evaluator.Values",
          "name": "maybeSave",
          "normalized": "Type-\u003eEvaluationMonad Value-\u003eEvaluationMonad Value",
          "package": "libcspm",
          "partial": "Save",
          "signature": "Type-\u003eEvaluationMonad Value-\u003eEvaluationMonad Value",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-Values.html#v:maybeSave"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGiven a program that yields a value, returns a second program that can be\n inserted into the environment, but will cause the environment not to save\n the actual value, but to recompute it everytime. This is useful for cheap,\n to compute, but high cost in terms of memory, computations (like named\n processes).\n\u003c/p\u003e",
          "module": "CSPM.Evaluator.Values",
          "name": "noSave",
          "package": "libcspm",
          "signature": "EvaluationMonad Value -\u003e EvaluationMonad Value",
          "source": "src/CSPM-Evaluator-Values.html#noSave",
          "type": "function"
        },
        "index": {
          "description": "Given program that yields value returns second program that can be inserted into the environment but will cause the environment not to save the actual value but to recompute it everytime This is useful for cheap to compute but high cost in terms of memory computations like named processes",
          "hierarchy": "CSPM Evaluator Values",
          "module": "CSPM.Evaluator.Values",
          "name": "noSave",
          "normalized": "EvaluationMonad Value-\u003eEvaluationMonad Value",
          "package": "libcspm",
          "partial": "Save",
          "signature": "EvaluationMonad Value-\u003eEvaluationMonad Value",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-Values.html#v:noSave"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Evaluator.Values",
          "name": "parentFunctionIdentifier",
          "package": "libcspm",
          "signature": "Maybe ScopeIdentifier",
          "source": "src/CSPM-Evaluator-Values.html#FunctionIdentifier",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Evaluator Values",
          "module": "CSPM.Evaluator.Values",
          "name": "parentFunctionIdentifier",
          "package": "libcspm",
          "partial": "Function Identifier",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-Values.html#v:parentFunctionIdentifier"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Evaluator.Values",
          "name": "parentScopeIdentifier",
          "package": "libcspm",
          "signature": "Maybe ScopeIdentifier",
          "source": "src/CSPM-Evaluator-Values.html#ScopeIdentifier",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Evaluator Values",
          "module": "CSPM.Evaluator.Values",
          "name": "parentScopeIdentifier",
          "package": "libcspm",
          "partial": "Scope Identifier",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-Values.html#v:parentScopeIdentifier"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Evaluator.Values",
          "name": "procName",
          "package": "libcspm",
          "signature": "ScopeIdentifier -\u003e ProcName",
          "source": "src/CSPM-Evaluator-Values.html#procName",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Evaluator Values",
          "module": "CSPM.Evaluator.Values",
          "name": "procName",
          "normalized": "ScopeIdentifier-\u003eProcName",
          "package": "libcspm",
          "partial": "Name",
          "signature": "ScopeIdentifier-\u003eProcName",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-Values.html#v:procName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Evaluator.Values",
          "name": "removeThunk",
          "package": "libcspm",
          "signature": "Value -\u003e EvaluationMonad Value",
          "source": "src/CSPM-Evaluator-Values.html#removeThunk",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Evaluator Values",
          "module": "CSPM.Evaluator.Values",
          "name": "removeThunk",
          "normalized": "Value-\u003eEvaluationMonad Value",
          "package": "libcspm",
          "partial": "Thunk",
          "signature": "Value-\u003eEvaluationMonad Value",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-Values.html#v:removeThunk"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Evaluator.Values",
          "name": "scopeFunctionArguments",
          "package": "libcspm",
          "signature": "[[Value]]",
          "source": "src/CSPM-Evaluator-Values.html#ScopeIdentifier",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Evaluator Values",
          "module": "CSPM.Evaluator.Values",
          "name": "scopeFunctionArguments",
          "normalized": "[[Value]]",
          "package": "libcspm",
          "partial": "Function Arguments",
          "signature": "[[Value]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-Values.html#v:scopeFunctionArguments"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Evaluator.Values",
          "name": "scopeFunctionName",
          "package": "libcspm",
          "signature": "Name",
          "source": "src/CSPM-Evaluator-Values.html#ScopeIdentifier",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Evaluator Values",
          "module": "CSPM.Evaluator.Values",
          "name": "scopeFunctionName",
          "package": "libcspm",
          "partial": "Function Name",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-Values.html#v:scopeFunctionName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Evaluator.Values",
          "name": "scopeId",
          "package": "libcspm",
          "signature": "Name -\u003e [[Value]] -\u003e Maybe ScopeIdentifier -\u003e ScopeIdentifier",
          "source": "src/CSPM-Evaluator-Values.html#scopeId",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Evaluator Values",
          "module": "CSPM.Evaluator.Values",
          "name": "scopeId",
          "normalized": "Name-\u003e[[Value]]-\u003eMaybe ScopeIdentifier-\u003eScopeIdentifier",
          "package": "libcspm",
          "partial": "Id",
          "signature": "Name-\u003e[[Value]]-\u003eMaybe ScopeIdentifier-\u003eScopeIdentifier",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-Values.html#v:scopeId"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe free variables this is bound in\n\u003c/p\u003e",
          "module": "CSPM.Evaluator.Values",
          "name": "scopeIdentifier",
          "package": "libcspm",
          "signature": "Maybe ScopeIdentifier",
          "source": "src/CSPM-Evaluator-Values.html#FunctionIdentifier",
          "type": "function"
        },
        "index": {
          "description": "The free variables this is bound in",
          "hierarchy": "CSPM Evaluator Values",
          "module": "CSPM.Evaluator.Values",
          "name": "scopeIdentifier",
          "package": "libcspm",
          "partial": "Identifier",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-Values.html#v:scopeIdentifier"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Evaluator.Values",
          "name": "trimValueForProcessName",
          "package": "libcspm",
          "signature": "Value -\u003e Value",
          "source": "src/CSPM-Evaluator-Values.html#trimValueForProcessName",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Evaluator Values",
          "module": "CSPM.Evaluator.Values",
          "name": "trimValueForProcessName",
          "normalized": "Value-\u003eValue",
          "package": "libcspm",
          "partial": "Value For Process Name",
          "signature": "Value-\u003eValue",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-Values.html#v:trimValueForProcessName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Evaluator.Values",
          "name": "tupleFromList",
          "package": "libcspm",
          "signature": "[Value] -\u003e Value",
          "source": "src/CSPM-Evaluator-Values.html#tupleFromList",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Evaluator Values",
          "module": "CSPM.Evaluator.Values",
          "name": "tupleFromList",
          "normalized": "[Value]-\u003eValue",
          "package": "libcspm",
          "partial": "From List",
          "signature": "[Value]-\u003eValue",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-Values.html#v:tupleFromList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis assumes that the value is a VDot with the left is a VChannel\n\u003c/p\u003e",
          "module": "CSPM.Evaluator.Values",
          "name": "valueEventToEvent",
          "package": "libcspm",
          "signature": "Value -\u003e Event",
          "source": "src/CSPM-Evaluator-Values.html#valueEventToEvent",
          "type": "function"
        },
        "index": {
          "description": "This assumes that the value is VDot with the left is VChannel",
          "hierarchy": "CSPM Evaluator Values",
          "module": "CSPM.Evaluator.Values",
          "name": "valueEventToEvent",
          "normalized": "Value-\u003eEvent",
          "package": "libcspm",
          "partial": "Event To Event",
          "signature": "Value-\u003eEvent",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-Values.html#v:valueEventToEvent"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Evaluator.Values",
          "name": "variablesBound",
          "package": "libcspm",
          "signature": "[Value]",
          "source": "src/CSPM-Evaluator-Values.html#ScopeIdentifier",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Evaluator Values",
          "module": "CSPM.Evaluator.Values",
          "name": "variablesBound",
          "normalized": "[Value]",
          "package": "libcspm",
          "partial": "Bound",
          "signature": "[Value]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator-Values.html#v:variablesBound"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Evaluator",
          "name": "Evaluator",
          "package": "libcspm",
          "source": "src/CSPM-Evaluator.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "CSPM Evaluator",
          "module": "CSPM.Evaluator",
          "name": "Evaluator",
          "package": "libcspm",
          "partial": "Evaluator",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Evaluator",
          "name": "EvaluationMonad",
          "package": "libcspm",
          "source": "src/CSPM-Evaluator-Monad.html#EvaluationMonad",
          "type": "type"
        },
        "index": {
          "hierarchy": "CSPM Evaluator",
          "module": "CSPM.Evaluator",
          "name": "EvaluationMonad",
          "package": "libcspm",
          "partial": "Evaluation Monad",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator.html#t:EvaluationMonad"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Evaluator",
          "name": "EvaluationState",
          "package": "libcspm",
          "source": "src/CSPM-Evaluator-Monad.html#EvaluationState",
          "type": "data"
        },
        "index": {
          "hierarchy": "CSPM Evaluator",
          "module": "CSPM.Evaluator",
          "name": "EvaluationState",
          "package": "libcspm",
          "partial": "Evaluation State",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator.html#t:EvaluationState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Evaluator",
          "name": "EvaluatorOptions",
          "package": "libcspm",
          "source": "src/CSPM-Evaluator.html#EvaluatorOptions",
          "type": "data"
        },
        "index": {
          "hierarchy": "CSPM Evaluator",
          "module": "CSPM.Evaluator",
          "name": "EvaluatorOptions",
          "package": "libcspm",
          "partial": "Evaluator Options",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator.html#t:EvaluatorOptions"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Evaluator",
          "name": "ProfilerOptions",
          "package": "libcspm",
          "source": "src/CSPM-Evaluator-Profiler.html#ProfilerOptions",
          "type": "data"
        },
        "index": {
          "hierarchy": "CSPM Evaluator",
          "module": "CSPM.Evaluator",
          "name": "ProfilerOptions",
          "package": "libcspm",
          "partial": "Profiler Options",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator.html#t:ProfilerOptions"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Evaluator",
          "name": "ProfilingData",
          "package": "libcspm",
          "source": "src/CSPM-Evaluator-Profiler.html#ProfilingData",
          "type": "data"
        },
        "index": {
          "hierarchy": "CSPM Evaluator",
          "module": "CSPM.Evaluator",
          "name": "ProfilingData",
          "package": "libcspm",
          "partial": "Profiling Data",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator.html#t:ProfilingData"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"CSPM.Evaluator\",\"CSPM\"]",
          "name": "EvaluatorOptions",
          "package": "libcspm",
          "signature": "EvaluatorOptions",
          "source": "src/CSPM-Evaluator.html#EvaluatorOptions",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator.html#v:EvaluatorOptions\",\"http://hackage.haskell.org/package/libcspm/docs/CSPM.html#v:EvaluatorOptions\"]"
        },
        "index": {
          "hierarchy": "CSPM Evaluator",
          "module": "CSPM.Evaluator",
          "name": "EvaluatorOptions",
          "package": "libcspm",
          "partial": "Evaluator Options",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator.html#v:EvaluatorOptions"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Evaluator",
          "name": "addToEnvironment",
          "package": "libcspm",
          "signature": "[(Name, EvaluationMonad Value)] -\u003e EvaluationMonad EvaluationState",
          "source": "src/CSPM-Evaluator.html#addToEnvironment",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Evaluator",
          "module": "CSPM.Evaluator",
          "name": "addToEnvironment",
          "normalized": "[(Name,EvaluationMonad Value)]-\u003eEvaluationMonad EvaluationState",
          "package": "libcspm",
          "partial": "To Environment",
          "signature": "[(Name,EvaluationMonad Value)]-\u003eEvaluationMonad EvaluationState",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator.html#v:addToEnvironment"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"CSPM.Evaluator\",\"CSPM\"]",
          "name": "defaultEvaluatorOptions",
          "package": "libcspm",
          "signature": "EvaluatorOptions",
          "source": "src/CSPM-Evaluator.html#defaultEvaluatorOptions",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator.html#v:defaultEvaluatorOptions\",\"http://hackage.haskell.org/package/libcspm/docs/CSPM.html#v:defaultEvaluatorOptions\"]"
        },
        "index": {
          "hierarchy": "CSPM Evaluator",
          "module": "CSPM.Evaluator",
          "name": "defaultEvaluatorOptions",
          "package": "libcspm",
          "partial": "Evaluator Options",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator.html#v:defaultEvaluatorOptions"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEvaluates the declaration but doesn't add it to the current environment.\n\u003c/p\u003e",
          "module": "CSPM.Evaluator",
          "name": "evaluateDecl",
          "package": "libcspm",
          "signature": "TCDecl -\u003e EvaluationMonad [(Name, EvaluationMonad Value)]",
          "source": "src/CSPM-Evaluator.html#evaluateDecl",
          "type": "function"
        },
        "index": {
          "description": "Evaluates the declaration but doesn add it to the current environment",
          "hierarchy": "CSPM Evaluator",
          "module": "CSPM.Evaluator",
          "name": "evaluateDecl",
          "normalized": "TCDecl-\u003eEvaluationMonad[(Name,EvaluationMonad Value)]",
          "package": "libcspm",
          "partial": "Decl",
          "signature": "TCDecl-\u003eEvaluationMonad[(Name,EvaluationMonad Value)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator.html#v:evaluateDecl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Evaluator",
          "name": "evaluateExp",
          "package": "libcspm",
          "signature": "TCExp -\u003e EvaluationMonad Value",
          "source": "src/CSPM-Evaluator.html#evaluateExp",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Evaluator",
          "module": "CSPM.Evaluator",
          "name": "evaluateExp",
          "normalized": "TCExp-\u003eEvaluationMonad Value",
          "package": "libcspm",
          "partial": "Exp",
          "signature": "TCExp-\u003eEvaluationMonad Value",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator.html#v:evaluateExp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEvaluates the declaration but doesn't add it to the current environment.\n\u003c/p\u003e",
          "module": "CSPM.Evaluator",
          "name": "evaluateFile",
          "package": "libcspm",
          "signature": "TCCSPMFile -\u003e EvaluationMonad [(Name, EvaluationMonad Value)]",
          "source": "src/CSPM-Evaluator.html#evaluateFile",
          "type": "function"
        },
        "index": {
          "description": "Evaluates the declaration but doesn add it to the current environment",
          "hierarchy": "CSPM Evaluator",
          "module": "CSPM.Evaluator",
          "name": "evaluateFile",
          "normalized": "TCCSPMFile-\u003eEvaluationMonad[(Name,EvaluationMonad Value)]",
          "package": "libcspm",
          "partial": "File",
          "signature": "TCCSPMFile-\u003eEvaluationMonad[(Name,EvaluationMonad Value)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator.html#v:evaluateFile"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe environment to use initially. This uses the IO monad as \n the EvaluationMonad cannot be used without a valid environment.\n\u003c/p\u003e",
          "module": "CSPM.Evaluator",
          "name": "initEvaluator",
          "package": "libcspm",
          "signature": "EvaluatorOptions -\u003e IO EvaluationState",
          "source": "src/CSPM-Evaluator.html#initEvaluator",
          "type": "function"
        },
        "index": {
          "description": "The environment to use initially This uses the IO monad as the EvaluationMonad cannot be used without valid environment",
          "hierarchy": "CSPM Evaluator",
          "module": "CSPM.Evaluator",
          "name": "initEvaluator",
          "normalized": "EvaluatorOptions-\u003eIO EvaluationState",
          "package": "libcspm",
          "partial": "Evaluator",
          "signature": "EvaluatorOptions-\u003eIO EvaluationState",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator.html#v:initEvaluator"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAttempts to convert a process name to a process, if possible.\n\u003c/p\u003e",
          "module": "CSPM.Evaluator",
          "name": "maybeProcessNameToProcess",
          "package": "libcspm",
          "signature": "ProcName -\u003e EvaluationMonad (Maybe UProc)",
          "source": "src/CSPM-Evaluator.html#maybeProcessNameToProcess",
          "type": "function"
        },
        "index": {
          "description": "Attempts to convert process name to process if possible",
          "hierarchy": "CSPM Evaluator",
          "module": "CSPM.Evaluator",
          "name": "maybeProcessNameToProcess",
          "normalized": "ProcName-\u003eEvaluationMonad(Maybe UProc)",
          "package": "libcspm",
          "partial": "Process Name To Process",
          "signature": "ProcName-\u003eEvaluationMonad(Maybe UProc)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator.html#v:maybeProcessNameToProcess"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"CSPM.Evaluator\",\"CSPM\"]",
          "name": "profilerOptions",
          "package": "libcspm",
          "signature": "ProfilerOptions",
          "source": "src/CSPM-Evaluator.html#EvaluatorOptions",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator.html#v:profilerOptions\",\"http://hackage.haskell.org/package/libcspm/docs/CSPM.html#v:profilerOptions\"]"
        },
        "index": {
          "hierarchy": "CSPM Evaluator",
          "module": "CSPM.Evaluator",
          "name": "profilerOptions",
          "package": "libcspm",
          "partial": "Options",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator.html#v:profilerOptions"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Evaluator",
          "name": "profilingData",
          "package": "libcspm",
          "signature": "EvaluationMonad ProfilingData",
          "source": "src/CSPM-Evaluator.html#profilingData",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Evaluator",
          "module": "CSPM.Evaluator",
          "name": "profilingData",
          "package": "libcspm",
          "partial": "Data",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator.html#v:profilingData"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Evaluator",
          "name": "runFromStateToState",
          "package": "libcspm",
          "signature": "EvaluationState -\u003e EvaluationMonad a -\u003e (a, EvaluationState)",
          "source": "src/CSPM-Evaluator.html#runFromStateToState",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Evaluator",
          "module": "CSPM.Evaluator",
          "name": "runFromStateToState",
          "normalized": "EvaluationState-\u003eEvaluationMonad a-\u003e(a,EvaluationState)",
          "package": "libcspm",
          "partial": "From State To State",
          "signature": "EvaluationState-\u003eEvaluationMonad a-\u003e(a,EvaluationState)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator.html#v:runFromStateToState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"CSPM.Evaluator\",\"CSPM\"]",
          "name": "runtimeRangeChecks",
          "package": "libcspm",
          "signature": "Bool",
          "source": "src/CSPM-Evaluator.html#EvaluatorOptions",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator.html#v:runtimeRangeChecks\",\"http://hackage.haskell.org/package/libcspm/docs/CSPM.html#v:runtimeRangeChecks\"]"
        },
        "index": {
          "hierarchy": "CSPM Evaluator",
          "module": "CSPM.Evaluator",
          "name": "runtimeRangeChecks",
          "package": "libcspm",
          "partial": "Range Checks",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Evaluator.html#v:runtimeRangeChecks"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Exceptions",
          "name": "Exceptions",
          "package": "libcspm",
          "source": "src/CSPM-Parser-Exceptions.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "CSPM Parser Exceptions",
          "module": "CSPM.Parser.Exceptions",
          "name": "Exceptions",
          "package": "libcspm",
          "partial": "Exceptions",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Exceptions.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Exceptions",
          "name": "ambiguousTypeAnnotationsError",
          "package": "libcspm",
          "signature": "UnRenamedName -\u003e [SrcSpan] -\u003e ErrorMessage",
          "source": "src/CSPM-Parser-Exceptions.html#ambiguousTypeAnnotationsError",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Exceptions",
          "module": "CSPM.Parser.Exceptions",
          "name": "ambiguousTypeAnnotationsError",
          "normalized": "UnRenamedName-\u003e[SrcSpan]-\u003eErrorMessage",
          "package": "libcspm",
          "partial": "Type Annotations Error",
          "signature": "UnRenamedName-\u003e[SrcSpan]-\u003eErrorMessage",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Exceptions.html#v:ambiguousTypeAnnotationsError"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Exceptions",
          "name": "definitionSpanFileError",
          "package": "libcspm",
          "signature": "PExp -\u003e PExp -\u003e SrcSpan -\u003e ErrorMessage",
          "source": "src/CSPM-Parser-Exceptions.html#definitionSpanFileError",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Exceptions",
          "module": "CSPM.Parser.Exceptions",
          "name": "definitionSpanFileError",
          "normalized": "PExp-\u003ePExp-\u003eSrcSpan-\u003eErrorMessage",
          "package": "libcspm",
          "partial": "Span File Error",
          "signature": "PExp-\u003ePExp-\u003eSrcSpan-\u003eErrorMessage",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Exceptions.html#v:definitionSpanFileError"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Exceptions",
          "name": "fileAccessErrorMessage",
          "package": "libcspm",
          "signature": "FilePath -\u003e ErrorMessage",
          "source": "src/CSPM-Parser-Exceptions.html#fileAccessErrorMessage",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Exceptions",
          "module": "CSPM.Parser.Exceptions",
          "name": "fileAccessErrorMessage",
          "normalized": "FilePath-\u003eErrorMessage",
          "package": "libcspm",
          "partial": "Access Error Message",
          "signature": "FilePath-\u003eErrorMessage",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Exceptions.html#v:fileAccessErrorMessage"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Exceptions",
          "name": "invalidExpressionErrorMessage",
          "package": "libcspm",
          "signature": "PExp -\u003e ErrorMessage",
          "source": "src/CSPM-Parser-Exceptions.html#invalidExpressionErrorMessage",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Exceptions",
          "module": "CSPM.Parser.Exceptions",
          "name": "invalidExpressionErrorMessage",
          "normalized": "PExp-\u003eErrorMessage",
          "package": "libcspm",
          "partial": "Expression Error Message",
          "signature": "PExp-\u003eErrorMessage",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Exceptions.html#v:invalidExpressionErrorMessage"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Exceptions",
          "name": "invalidFunctionArgsErrorMessage",
          "package": "libcspm",
          "signature": "PSType -\u003e ErrorMessage",
          "source": "src/CSPM-Parser-Exceptions.html#invalidFunctionArgsErrorMessage",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Exceptions",
          "module": "CSPM.Parser.Exceptions",
          "name": "invalidFunctionArgsErrorMessage",
          "normalized": "PSType-\u003eErrorMessage",
          "package": "libcspm",
          "partial": "Function Args Error Message",
          "signature": "PSType-\u003eErrorMessage",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Exceptions.html#v:invalidFunctionArgsErrorMessage"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Exceptions",
          "name": "invalidIncludeErrorMessage",
          "package": "libcspm",
          "signature": "SrcSpan -\u003e ErrorMessage",
          "source": "src/CSPM-Parser-Exceptions.html#invalidIncludeErrorMessage",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Exceptions",
          "module": "CSPM.Parser.Exceptions",
          "name": "invalidIncludeErrorMessage",
          "normalized": "SrcSpan-\u003eErrorMessage",
          "package": "libcspm",
          "partial": "Include Error Message",
          "signature": "SrcSpan-\u003eErrorMessage",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Exceptions.html#v:invalidIncludeErrorMessage"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Exceptions",
          "name": "invalidLetDeclarationErrorMessage",
          "package": "libcspm",
          "signature": "PDecl -\u003e ErrorMessage",
          "source": "src/CSPM-Parser-Exceptions.html#invalidLetDeclarationErrorMessage",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Exceptions",
          "module": "CSPM.Parser.Exceptions",
          "name": "invalidLetDeclarationErrorMessage",
          "normalized": "PDecl-\u003eErrorMessage",
          "package": "libcspm",
          "partial": "Let Declaration Error Message",
          "signature": "PDecl-\u003eErrorMessage",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Exceptions.html#v:invalidLetDeclarationErrorMessage"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Exceptions",
          "name": "invalidModuleDeclarationErrorMessage",
          "package": "libcspm",
          "signature": "PDecl -\u003e ErrorMessage",
          "source": "src/CSPM-Parser-Exceptions.html#invalidModuleDeclarationErrorMessage",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Exceptions",
          "module": "CSPM.Parser.Exceptions",
          "name": "invalidModuleDeclarationErrorMessage",
          "normalized": "PDecl-\u003eErrorMessage",
          "package": "libcspm",
          "partial": "Module Declaration Error Message",
          "signature": "PDecl-\u003eErrorMessage",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Exceptions.html#v:invalidModuleDeclarationErrorMessage"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Exceptions",
          "name": "invalidPatternErrorMessage",
          "package": "libcspm",
          "signature": "PExp -\u003e ErrorMessage",
          "source": "src/CSPM-Parser-Exceptions.html#invalidPatternErrorMessage",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Exceptions",
          "module": "CSPM.Parser.Exceptions",
          "name": "invalidPatternErrorMessage",
          "normalized": "PExp-\u003eErrorMessage",
          "package": "libcspm",
          "partial": "Pattern Error Message",
          "signature": "PExp-\u003eErrorMessage",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Exceptions.html#v:invalidPatternErrorMessage"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Exceptions",
          "name": "invalidTimedSectionDeclarationErrorMessage",
          "package": "libcspm",
          "signature": "PDecl -\u003e ErrorMessage",
          "source": "src/CSPM-Parser-Exceptions.html#invalidTimedSectionDeclarationErrorMessage",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Exceptions",
          "module": "CSPM.Parser.Exceptions",
          "name": "invalidTimedSectionDeclarationErrorMessage",
          "normalized": "PDecl-\u003eErrorMessage",
          "package": "libcspm",
          "partial": "Timed Section Declaration Error Message",
          "signature": "PDecl-\u003eErrorMessage",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Exceptions.html#v:invalidTimedSectionDeclarationErrorMessage"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Exceptions",
          "name": "lexicalErrorMessage",
          "package": "libcspm",
          "signature": "SrcSpan -\u003e ErrorMessage",
          "source": "src/CSPM-Parser-Exceptions.html#lexicalErrorMessage",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Exceptions",
          "module": "CSPM.Parser.Exceptions",
          "name": "lexicalErrorMessage",
          "normalized": "SrcSpan-\u003eErrorMessage",
          "package": "libcspm",
          "partial": "Error Message",
          "signature": "SrcSpan-\u003eErrorMessage",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Exceptions.html#v:lexicalErrorMessage"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Exceptions",
          "name": "parseErrorMessage",
          "package": "libcspm",
          "signature": "LToken -\u003e ErrorMessage",
          "source": "src/CSPM-Parser-Exceptions.html#parseErrorMessage",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Exceptions",
          "module": "CSPM.Parser.Exceptions",
          "name": "parseErrorMessage",
          "normalized": "LToken-\u003eErrorMessage",
          "package": "libcspm",
          "partial": "Error Message",
          "signature": "LToken-\u003eErrorMessage",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Exceptions.html#v:parseErrorMessage"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThrow an error message as a \u003ccode\u003e\u003ca\u003eSourceError\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "[\"CSPM.Parser.Exceptions\",\"Util.Exception\"]",
          "name": "throwSourceError",
          "package": "libcspm",
          "signature": "ErrorMessages -\u003e a",
          "source": "src/Util-Exception.html#throwSourceError",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Exceptions.html#v:throwSourceError\",\"http://hackage.haskell.org/package/libcspm/docs/Util-Exception.html#v:throwSourceError\"]"
        },
        "index": {
          "description": "Throw an error message as SourceError",
          "hierarchy": "CSPM Parser Exceptions",
          "module": "CSPM.Parser.Exceptions",
          "name": "throwSourceError",
          "normalized": "ErrorMessages-\u003ea",
          "package": "libcspm",
          "partial": "Source Error",
          "signature": "ErrorMessages-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Exceptions.html#v:throwSourceError"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Exceptions",
          "name": "unknownConstraintError",
          "package": "libcspm",
          "signature": "String -\u003e SrcSpan -\u003e ErrorMessage",
          "source": "src/CSPM-Parser-Exceptions.html#unknownConstraintError",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Exceptions",
          "module": "CSPM.Parser.Exceptions",
          "name": "unknownConstraintError",
          "normalized": "String-\u003eSrcSpan-\u003eErrorMessage",
          "package": "libcspm",
          "partial": "Constraint Error",
          "signature": "String-\u003eSrcSpan-\u003eErrorMessage",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Exceptions.html#v:unknownConstraintError"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Exceptions",
          "name": "unusedTypeAnnotationsError",
          "package": "libcspm",
          "signature": "UnRenamedName -\u003e SrcSpan -\u003e ErrorMessage",
          "source": "src/CSPM-Parser-Exceptions.html#unusedTypeAnnotationsError",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Exceptions",
          "module": "CSPM.Parser.Exceptions",
          "name": "unusedTypeAnnotationsError",
          "normalized": "UnRenamedName-\u003eSrcSpan-\u003eErrorMessage",
          "package": "libcspm",
          "partial": "Type Annotations Error",
          "signature": "UnRenamedName-\u003eSrcSpan-\u003eErrorMessage",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Exceptions.html#v:unusedTypeAnnotationsError"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Lexer",
          "name": "Lexer",
          "package": "libcspm",
          "source": "src/CSPM-Parser-Lexer.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "CSPM Parser Lexer",
          "module": "CSPM.Parser.Lexer",
          "name": "Lexer",
          "package": "libcspm",
          "partial": "Lexer",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Lexer.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Lexer",
          "name": "AlexAcc",
          "package": "libcspm",
          "source": "src/CSPM-Parser-Lexer.html#AlexAcc",
          "type": "data"
        },
        "index": {
          "hierarchy": "CSPM Parser Lexer",
          "module": "CSPM.Parser.Lexer",
          "name": "AlexAcc",
          "package": "libcspm",
          "partial": "Alex Acc",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Lexer.html#t:AlexAcc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Lexer",
          "name": "AlexAccPred",
          "package": "libcspm",
          "source": "src/CSPM-Parser-Lexer.html#AlexAccPred",
          "type": "type"
        },
        "index": {
          "hierarchy": "CSPM Parser Lexer",
          "module": "CSPM.Parser.Lexer",
          "name": "AlexAccPred",
          "package": "libcspm",
          "partial": "Alex Acc Pred",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Lexer.html#t:AlexAccPred"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Lexer",
          "name": "AlexAddr",
          "package": "libcspm",
          "source": "src/CSPM-Parser-Lexer.html#AlexAddr",
          "type": "data"
        },
        "index": {
          "hierarchy": "CSPM Parser Lexer",
          "module": "CSPM.Parser.Lexer",
          "name": "AlexAddr",
          "package": "libcspm",
          "partial": "Alex Addr",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Lexer.html#t:AlexAddr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Lexer",
          "name": "AlexInput",
          "package": "libcspm",
          "source": "src/CSPM-Parser-Lexer.html#AlexInput",
          "type": "type"
        },
        "index": {
          "hierarchy": "CSPM Parser Lexer",
          "module": "CSPM.Parser.Lexer",
          "name": "AlexInput",
          "package": "libcspm",
          "partial": "Alex Input",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Lexer.html#t:AlexInput"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Lexer",
          "name": "AlexLastAcc",
          "package": "libcspm",
          "source": "src/CSPM-Parser-Lexer.html#AlexLastAcc",
          "type": "data"
        },
        "index": {
          "hierarchy": "CSPM Parser Lexer",
          "module": "CSPM.Parser.Lexer",
          "name": "AlexLastAcc",
          "package": "libcspm",
          "partial": "Alex Last Acc",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Lexer.html#t:AlexLastAcc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Lexer",
          "name": "AlexReturn",
          "package": "libcspm",
          "source": "src/CSPM-Parser-Lexer.html#AlexReturn",
          "type": "data"
        },
        "index": {
          "hierarchy": "CSPM Parser Lexer",
          "module": "CSPM.Parser.Lexer",
          "name": "AlexReturn",
          "package": "libcspm",
          "partial": "Alex Return",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Lexer.html#t:AlexReturn"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Lexer",
          "name": "AlexA#",
          "package": "libcspm",
          "signature": "AlexA# Addr#",
          "source": "src/CSPM-Parser-Lexer.html#AlexAddr",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Lexer",
          "module": "CSPM.Parser.Lexer",
          "name": "AlexA#",
          "package": "libcspm",
          "partial": "Alex",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Lexer.html#v:AlexA-35-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Lexer",
          "name": "AlexAcc",
          "package": "libcspm",
          "signature": "AlexAcc a",
          "source": "src/CSPM-Parser-Lexer.html#AlexAcc",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Lexer",
          "module": "CSPM.Parser.Lexer",
          "name": "AlexAcc",
          "package": "libcspm",
          "partial": "Alex Acc",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Lexer.html#v:AlexAcc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Lexer",
          "name": "AlexAccPred",
          "package": "libcspm",
          "signature": "AlexAccPred a (AlexAccPred user)",
          "source": "src/CSPM-Parser-Lexer.html#AlexAcc",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Lexer",
          "module": "CSPM.Parser.Lexer",
          "name": "AlexAccPred",
          "package": "libcspm",
          "partial": "Alex Acc Pred",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Lexer.html#v:AlexAccPred"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Lexer",
          "name": "AlexAccSkip",
          "package": "libcspm",
          "signature": "AlexAccSkip",
          "source": "src/CSPM-Parser-Lexer.html#AlexAcc",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Lexer",
          "module": "CSPM.Parser.Lexer",
          "name": "AlexAccSkip",
          "package": "libcspm",
          "partial": "Alex Acc Skip",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Lexer.html#v:AlexAccSkip"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Lexer",
          "name": "AlexAccSkipPred",
          "package": "libcspm",
          "signature": "AlexAccSkipPred (AlexAccPred user)",
          "source": "src/CSPM-Parser-Lexer.html#AlexAcc",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Lexer",
          "module": "CSPM.Parser.Lexer",
          "name": "AlexAccSkipPred",
          "package": "libcspm",
          "partial": "Alex Acc Skip Pred",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Lexer.html#v:AlexAccSkipPred"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Lexer",
          "name": "AlexEOF",
          "package": "libcspm",
          "signature": "AlexEOF",
          "source": "src/CSPM-Parser-Lexer.html#AlexReturn",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Lexer",
          "module": "CSPM.Parser.Lexer",
          "name": "AlexEOF",
          "package": "libcspm",
          "partial": "Alex EOF",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Lexer.html#v:AlexEOF"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Lexer",
          "name": "AlexError",
          "package": "libcspm",
          "signature": "AlexError !AlexInput",
          "source": "src/CSPM-Parser-Lexer.html#AlexReturn",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Lexer",
          "module": "CSPM.Parser.Lexer",
          "name": "AlexError",
          "package": "libcspm",
          "partial": "Alex Error",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Lexer.html#v:AlexError"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Lexer",
          "name": "AlexLastAcc",
          "package": "libcspm",
          "signature": "AlexLastAcc a !AlexInput !Int",
          "source": "src/CSPM-Parser-Lexer.html#AlexLastAcc",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Lexer",
          "module": "CSPM.Parser.Lexer",
          "name": "AlexLastAcc",
          "package": "libcspm",
          "partial": "Alex Last Acc",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Lexer.html#v:AlexLastAcc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Lexer",
          "name": "AlexLastSkip",
          "package": "libcspm",
          "signature": "AlexLastSkip !AlexInput !Int",
          "source": "src/CSPM-Parser-Lexer.html#AlexLastAcc",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Lexer",
          "module": "CSPM.Parser.Lexer",
          "name": "AlexLastSkip",
          "package": "libcspm",
          "partial": "Alex Last Skip",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Lexer.html#v:AlexLastSkip"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Lexer",
          "name": "AlexNone",
          "package": "libcspm",
          "signature": "AlexNone",
          "source": "src/CSPM-Parser-Lexer.html#AlexLastAcc",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Lexer",
          "module": "CSPM.Parser.Lexer",
          "name": "AlexNone",
          "package": "libcspm",
          "partial": "Alex None",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Lexer.html#v:AlexNone"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Lexer",
          "name": "AlexSkip",
          "package": "libcspm",
          "signature": "AlexSkip !AlexInput !Int",
          "source": "src/CSPM-Parser-Lexer.html#AlexReturn",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Lexer",
          "module": "CSPM.Parser.Lexer",
          "name": "AlexSkip",
          "package": "libcspm",
          "partial": "Alex Skip",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Lexer.html#v:AlexSkip"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Lexer",
          "name": "AlexToken",
          "package": "libcspm",
          "signature": "AlexToken !AlexInput !Int a",
          "source": "src/CSPM-Parser-Lexer.html#AlexReturn",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Lexer",
          "module": "CSPM.Parser.Lexer",
          "name": "AlexToken",
          "package": "libcspm",
          "partial": "Alex Token",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Lexer.html#v:AlexToken"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Lexer",
          "name": "alexAndPred",
          "package": "libcspm",
          "signature": "(t -\u003e t1 -\u003e t2 -\u003e t3 -\u003e Bool) -\u003e (t -\u003e t1 -\u003e t2 -\u003e t3 -\u003e Bool) -\u003e t -\u003e t1 -\u003e t2 -\u003e t3 -\u003e Bool",
          "source": "src/CSPM-Parser-Lexer.html#alexAndPred",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Lexer",
          "module": "CSPM.Parser.Lexer",
          "name": "alexAndPred",
          "normalized": "(a-\u003ea-\u003ea-\u003ea-\u003eBool)-\u003e(a-\u003ea-\u003ea-\u003ea-\u003eBool)-\u003ea-\u003ea-\u003ea-\u003ea-\u003eBool",
          "package": "libcspm",
          "partial": "And Pred",
          "signature": "(t-\u003et-\u003et-\u003et-\u003eBool)-\u003e(t-\u003et-\u003et-\u003et-\u003eBool)-\u003et-\u003et-\u003et-\u003et-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Lexer.html#v:alexAndPred"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Lexer",
          "name": "alexGetByte",
          "package": "libcspm",
          "signature": "AlexInput -\u003e Maybe (Word8, AlexInput)",
          "source": "src/CSPM-Parser-Lexer.html#alexGetByte",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Lexer",
          "module": "CSPM.Parser.Lexer",
          "name": "alexGetByte",
          "normalized": "AlexInput-\u003eMaybe(Word,AlexInput)",
          "package": "libcspm",
          "partial": "Get Byte",
          "signature": "AlexInput-\u003eMaybe(Word,AlexInput)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Lexer.html#v:alexGetByte"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Lexer",
          "name": "alexGetChar",
          "package": "libcspm",
          "signature": "AlexInput -\u003e Maybe (Char, AlexInput)",
          "source": "src/CSPM-Parser-Lexer.html#alexGetChar",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Lexer",
          "module": "CSPM.Parser.Lexer",
          "name": "alexGetChar",
          "normalized": "AlexInput-\u003eMaybe(Char,AlexInput)",
          "package": "libcspm",
          "partial": "Get Char",
          "signature": "AlexInput-\u003eMaybe(Char,AlexInput)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Lexer.html#v:alexGetChar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Lexer",
          "name": "alexIndexInt16OffAddr",
          "package": "libcspm",
          "signature": "AlexAddr -\u003e Int# -\u003e Int#",
          "source": "src/CSPM-Parser-Lexer.html#alexIndexInt16OffAddr",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Lexer",
          "module": "CSPM.Parser.Lexer",
          "name": "alexIndexInt16OffAddr",
          "normalized": "AlexAddr-\u003eInt #-\u003eInt #",
          "package": "libcspm",
          "partial": "Index Int Off Addr",
          "signature": "AlexAddr-\u003eInt #-\u003eInt #",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Lexer.html#v:alexIndexInt16OffAddr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Lexer",
          "name": "alexIndexInt32OffAddr",
          "package": "libcspm",
          "signature": "AlexAddr -\u003e Int# -\u003e Int#",
          "source": "src/CSPM-Parser-Lexer.html#alexIndexInt32OffAddr",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Lexer",
          "module": "CSPM.Parser.Lexer",
          "name": "alexIndexInt32OffAddr",
          "normalized": "AlexAddr-\u003eInt #-\u003eInt #",
          "package": "libcspm",
          "partial": "Index Int Off Addr",
          "signature": "AlexAddr-\u003eInt #-\u003eInt #",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Lexer.html#v:alexIndexInt32OffAddr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Lexer",
          "name": "alexInputPrevChar",
          "package": "libcspm",
          "signature": "AlexInput -\u003e Char",
          "source": "src/CSPM-Parser-Lexer.html#alexInputPrevChar",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Lexer",
          "module": "CSPM.Parser.Lexer",
          "name": "alexInputPrevChar",
          "normalized": "AlexInput-\u003eChar",
          "package": "libcspm",
          "partial": "Input Prev Char",
          "signature": "AlexInput-\u003eChar",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Lexer.html#v:alexInputPrevChar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Lexer",
          "name": "alexPrevCharIs",
          "package": "libcspm",
          "signature": "Char -\u003e t -\u003e AlexInput -\u003e t1 -\u003e t2 -\u003e Bool",
          "source": "src/CSPM-Parser-Lexer.html#alexPrevCharIs",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Lexer",
          "module": "CSPM.Parser.Lexer",
          "name": "alexPrevCharIs",
          "normalized": "Char-\u003ea-\u003eAlexInput-\u003ea-\u003ea-\u003eBool",
          "package": "libcspm",
          "partial": "Prev Char Is",
          "signature": "Char-\u003et-\u003eAlexInput-\u003et-\u003et-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Lexer.html#v:alexPrevCharIs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Lexer",
          "name": "alexPrevCharIsOneOf",
          "package": "libcspm",
          "signature": "Array Char e -\u003e t -\u003e AlexInput -\u003e t1 -\u003e t2 -\u003e e",
          "source": "src/CSPM-Parser-Lexer.html#alexPrevCharIsOneOf",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Lexer",
          "module": "CSPM.Parser.Lexer",
          "name": "alexPrevCharIsOneOf",
          "normalized": "Array Char a-\u003eb-\u003eAlexInput-\u003eb-\u003eb-\u003ea",
          "package": "libcspm",
          "partial": "Prev Char Is One Of",
          "signature": "Array Char e-\u003et-\u003eAlexInput-\u003et-\u003et-\u003ee",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Lexer.html#v:alexPrevCharIsOneOf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Lexer",
          "name": "alexPrevCharMatches",
          "package": "libcspm",
          "signature": "(Char -\u003e t3) -\u003e t -\u003e AlexInput -\u003e t1 -\u003e t2 -\u003e t3",
          "source": "src/CSPM-Parser-Lexer.html#alexPrevCharMatches",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Lexer",
          "module": "CSPM.Parser.Lexer",
          "name": "alexPrevCharMatches",
          "normalized": "(Char-\u003ea)-\u003ea-\u003eAlexInput-\u003ea-\u003ea-\u003ea",
          "package": "libcspm",
          "partial": "Prev Char Matches",
          "signature": "(Char-\u003et)-\u003et-\u003eAlexInput-\u003et-\u003et-\u003et",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Lexer.html#v:alexPrevCharMatches"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Lexer",
          "name": "alexRightContext",
          "package": "libcspm",
          "signature": "Int -\u003e AlexAccPred (Any *)",
          "source": "src/CSPM-Parser-Lexer.html#alexRightContext",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Lexer",
          "module": "CSPM.Parser.Lexer",
          "name": "alexRightContext",
          "normalized": "Int-\u003eAlexAccPred(Any*)",
          "package": "libcspm",
          "partial": "Right Context",
          "signature": "Int-\u003eAlexAccPred(Any*)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Lexer.html#v:alexRightContext"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Lexer",
          "name": "alexScan",
          "package": "libcspm",
          "signature": "ParserState -\u003e Int -\u003e AlexReturn (AlexInput -\u003e Int -\u003e ParseMonad LToken)",
          "source": "src/CSPM-Parser-Lexer.html#alexScan",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Lexer",
          "module": "CSPM.Parser.Lexer",
          "name": "alexScan",
          "normalized": "ParserState-\u003eInt-\u003eAlexReturn(AlexInput-\u003eInt-\u003eParseMonad LToken)",
          "package": "libcspm",
          "partial": "Scan",
          "signature": "ParserState-\u003eInt-\u003eAlexReturn(AlexInput-\u003eInt-\u003eParseMonad LToken)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Lexer.html#v:alexScan"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Lexer",
          "name": "alexScanUser",
          "package": "libcspm",
          "signature": "Any * -\u003e ParserState -\u003e Int -\u003e AlexReturn (AlexInput -\u003e Int -\u003e ParseMonad LToken)",
          "source": "src/CSPM-Parser-Lexer.html#alexScanUser",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Lexer",
          "module": "CSPM.Parser.Lexer",
          "name": "alexScanUser",
          "normalized": "Any*-\u003eParserState-\u003eInt-\u003eAlexReturn(AlexInput-\u003eInt-\u003eParseMonad LToken)",
          "package": "libcspm",
          "partial": "Scan User",
          "signature": "Any*-\u003eParserState-\u003eInt-\u003eAlexReturn(AlexInput-\u003eInt-\u003eParseMonad LToken)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Lexer.html#v:alexScanUser"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Lexer",
          "name": "alex_accept",
          "package": "libcspm",
          "signature": "Array Int [AlexAcc (AlexInput -\u003e Int -\u003e ParseMonad LToken) (Any *)]",
          "source": "src/CSPM-Parser-Lexer.html#alex_accept",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Lexer",
          "module": "CSPM.Parser.Lexer",
          "name": "alex_accept",
          "normalized": "Array Int[AlexAcc(AlexInput-\u003eInt-\u003eParseMonad LToken)(Any*)]",
          "package": "libcspm",
          "signature": "Array Int[AlexAcc(AlexInput-\u003eInt-\u003eParseMonad LToken)(Any*)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Lexer.html#v:alex_accept"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_0",
          "package": "libcspm",
          "signature": "AlexInput -\u003e Int -\u003e ParseMonad LToken",
          "source": "src/CSPM-Parser-Lexer.html#alex_action_0",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Lexer",
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_0",
          "normalized": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "package": "libcspm",
          "signature": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Lexer.html#v:alex_action_0"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_1",
          "package": "libcspm",
          "signature": "AlexInput -\u003e Int -\u003e ParseMonad LToken",
          "source": "src/CSPM-Parser-Lexer.html#alex_action_1",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Lexer",
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_1",
          "normalized": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "package": "libcspm",
          "signature": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Lexer.html#v:alex_action_1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_10",
          "package": "libcspm",
          "signature": "AlexInput -\u003e Int -\u003e ParseMonad LToken",
          "source": "src/CSPM-Parser-Lexer.html#alex_action_10",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Lexer",
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_10",
          "normalized": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "package": "libcspm",
          "signature": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Lexer.html#v:alex_action_10"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_100",
          "package": "libcspm",
          "signature": "AlexInput -\u003e Int -\u003e ParseMonad LToken",
          "source": "src/CSPM-Parser-Lexer.html#alex_action_100",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Lexer",
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_100",
          "normalized": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "package": "libcspm",
          "signature": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Lexer.html#v:alex_action_100"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_101",
          "package": "libcspm",
          "signature": "AlexInput -\u003e Int -\u003e ParseMonad LToken",
          "source": "src/CSPM-Parser-Lexer.html#alex_action_101",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Lexer",
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_101",
          "normalized": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "package": "libcspm",
          "signature": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Lexer.html#v:alex_action_101"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_102",
          "package": "libcspm",
          "signature": "AlexInput -\u003e Int -\u003e ParseMonad LToken",
          "source": "src/CSPM-Parser-Lexer.html#alex_action_102",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Lexer",
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_102",
          "normalized": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "package": "libcspm",
          "signature": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Lexer.html#v:alex_action_102"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_103",
          "package": "libcspm",
          "signature": "AlexInput -\u003e Int -\u003e ParseMonad LToken",
          "source": "src/CSPM-Parser-Lexer.html#alex_action_103",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Lexer",
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_103",
          "normalized": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "package": "libcspm",
          "signature": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Lexer.html#v:alex_action_103"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_104",
          "package": "libcspm",
          "signature": "AlexInput -\u003e Int -\u003e ParseMonad LToken",
          "source": "src/CSPM-Parser-Lexer.html#alex_action_104",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Lexer",
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_104",
          "normalized": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "package": "libcspm",
          "signature": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Lexer.html#v:alex_action_104"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_105",
          "package": "libcspm",
          "signature": "AlexInput -\u003e Int -\u003e ParseMonad LToken",
          "source": "src/CSPM-Parser-Lexer.html#alex_action_105",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Lexer",
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_105",
          "normalized": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "package": "libcspm",
          "signature": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Lexer.html#v:alex_action_105"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_106",
          "package": "libcspm",
          "signature": "AlexInput -\u003e Int -\u003e ParseMonad LToken",
          "source": "src/CSPM-Parser-Lexer.html#alex_action_106",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Lexer",
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_106",
          "normalized": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "package": "libcspm",
          "signature": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Lexer.html#v:alex_action_106"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_107",
          "package": "libcspm",
          "signature": "AlexInput -\u003e Int -\u003e ParseMonad LToken",
          "source": "src/CSPM-Parser-Lexer.html#alex_action_107",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Lexer",
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_107",
          "normalized": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "package": "libcspm",
          "signature": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Lexer.html#v:alex_action_107"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_108",
          "package": "libcspm",
          "signature": "AlexInput -\u003e Int -\u003e ParseMonad LToken",
          "source": "src/CSPM-Parser-Lexer.html#alex_action_108",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Lexer",
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_108",
          "normalized": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "package": "libcspm",
          "signature": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Lexer.html#v:alex_action_108"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_109",
          "package": "libcspm",
          "signature": "AlexInput -\u003e Int -\u003e ParseMonad LToken",
          "source": "src/CSPM-Parser-Lexer.html#alex_action_109",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Lexer",
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_109",
          "normalized": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "package": "libcspm",
          "signature": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Lexer.html#v:alex_action_109"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_11",
          "package": "libcspm",
          "signature": "AlexInput -\u003e Int -\u003e ParseMonad LToken",
          "source": "src/CSPM-Parser-Lexer.html#alex_action_11",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Lexer",
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_11",
          "normalized": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "package": "libcspm",
          "signature": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Lexer.html#v:alex_action_11"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_110",
          "package": "libcspm",
          "signature": "AlexInput -\u003e Int -\u003e ParseMonad LToken",
          "source": "src/CSPM-Parser-Lexer.html#alex_action_110",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Lexer",
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_110",
          "normalized": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "package": "libcspm",
          "signature": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Lexer.html#v:alex_action_110"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_111",
          "package": "libcspm",
          "signature": "AlexInput -\u003e Int -\u003e ParseMonad LToken",
          "source": "src/CSPM-Parser-Lexer.html#alex_action_111",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Lexer",
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_111",
          "normalized": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "package": "libcspm",
          "signature": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Lexer.html#v:alex_action_111"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_112",
          "package": "libcspm",
          "signature": "AlexInput -\u003e Int -\u003e ParseMonad LToken",
          "source": "src/CSPM-Parser-Lexer.html#alex_action_112",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Lexer",
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_112",
          "normalized": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "package": "libcspm",
          "signature": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Lexer.html#v:alex_action_112"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_113",
          "package": "libcspm",
          "signature": "AlexInput -\u003e Int -\u003e ParseMonad LToken",
          "source": "src/CSPM-Parser-Lexer.html#alex_action_113",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Lexer",
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_113",
          "normalized": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "package": "libcspm",
          "signature": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Lexer.html#v:alex_action_113"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_114",
          "package": "libcspm",
          "signature": "AlexInput -\u003e Int -\u003e ParseMonad LToken",
          "source": "src/CSPM-Parser-Lexer.html#alex_action_114",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Lexer",
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_114",
          "normalized": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "package": "libcspm",
          "signature": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Lexer.html#v:alex_action_114"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_115",
          "package": "libcspm",
          "signature": "AlexInput -\u003e Int -\u003e ParseMonad LToken",
          "source": "src/CSPM-Parser-Lexer.html#alex_action_115",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Lexer",
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_115",
          "normalized": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "package": "libcspm",
          "signature": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Lexer.html#v:alex_action_115"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_116",
          "package": "libcspm",
          "signature": "AlexInput -\u003e Int -\u003e ParseMonad LToken",
          "source": "src/CSPM-Parser-Lexer.html#alex_action_116",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Lexer",
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_116",
          "normalized": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "package": "libcspm",
          "signature": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Lexer.html#v:alex_action_116"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_117",
          "package": "libcspm",
          "signature": "AlexInput -\u003e Int -\u003e ParseMonad LToken",
          "source": "src/CSPM-Parser-Lexer.html#alex_action_117",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Lexer",
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_117",
          "normalized": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "package": "libcspm",
          "signature": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Lexer.html#v:alex_action_117"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_118",
          "package": "libcspm",
          "signature": "AlexInput -\u003e Int -\u003e ParseMonad LToken",
          "source": "src/CSPM-Parser-Lexer.html#alex_action_118",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Lexer",
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_118",
          "normalized": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "package": "libcspm",
          "signature": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Lexer.html#v:alex_action_118"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_119",
          "package": "libcspm",
          "signature": "AlexInput -\u003e Int -\u003e ParseMonad LToken",
          "source": "src/CSPM-Parser-Lexer.html#alex_action_119",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Lexer",
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_119",
          "normalized": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "package": "libcspm",
          "signature": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Lexer.html#v:alex_action_119"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_12",
          "package": "libcspm",
          "signature": "AlexInput -\u003e Int -\u003e ParseMonad LToken",
          "source": "src/CSPM-Parser-Lexer.html#alex_action_12",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Lexer",
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_12",
          "normalized": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "package": "libcspm",
          "signature": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Lexer.html#v:alex_action_12"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_120",
          "package": "libcspm",
          "signature": "AlexInput -\u003e Int -\u003e ParseMonad LToken",
          "source": "src/CSPM-Parser-Lexer.html#alex_action_120",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Lexer",
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_120",
          "normalized": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "package": "libcspm",
          "signature": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Lexer.html#v:alex_action_120"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_121",
          "package": "libcspm",
          "signature": "AlexInput -\u003e Int -\u003e ParseMonad LToken",
          "source": "src/CSPM-Parser-Lexer.html#alex_action_121",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Lexer",
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_121",
          "normalized": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "package": "libcspm",
          "signature": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Lexer.html#v:alex_action_121"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_122",
          "package": "libcspm",
          "signature": "AlexInput -\u003e Int -\u003e ParseMonad LToken",
          "source": "src/CSPM-Parser-Lexer.html#alex_action_122",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Lexer",
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_122",
          "normalized": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "package": "libcspm",
          "signature": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Lexer.html#v:alex_action_122"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_123",
          "package": "libcspm",
          "signature": "AlexInput -\u003e Int -\u003e ParseMonad LToken",
          "source": "src/CSPM-Parser-Lexer.html#alex_action_123",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Lexer",
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_123",
          "normalized": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "package": "libcspm",
          "signature": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Lexer.html#v:alex_action_123"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_124",
          "package": "libcspm",
          "signature": "AlexInput -\u003e Int -\u003e ParseMonad LToken",
          "source": "src/CSPM-Parser-Lexer.html#alex_action_124",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Lexer",
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_124",
          "normalized": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "package": "libcspm",
          "signature": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Lexer.html#v:alex_action_124"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_125",
          "package": "libcspm",
          "signature": "AlexInput -\u003e Int -\u003e ParseMonad LToken",
          "source": "src/CSPM-Parser-Lexer.html#alex_action_125",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Lexer",
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_125",
          "normalized": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "package": "libcspm",
          "signature": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Lexer.html#v:alex_action_125"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_13",
          "package": "libcspm",
          "signature": "AlexInput -\u003e Int -\u003e ParseMonad LToken",
          "source": "src/CSPM-Parser-Lexer.html#alex_action_13",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Lexer",
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_13",
          "normalized": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "package": "libcspm",
          "signature": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Lexer.html#v:alex_action_13"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_14",
          "package": "libcspm",
          "signature": "AlexInput -\u003e Int -\u003e ParseMonad LToken",
          "source": "src/CSPM-Parser-Lexer.html#alex_action_14",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Lexer",
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_14",
          "normalized": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "package": "libcspm",
          "signature": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Lexer.html#v:alex_action_14"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_15",
          "package": "libcspm",
          "signature": "AlexInput -\u003e Int -\u003e ParseMonad LToken",
          "source": "src/CSPM-Parser-Lexer.html#alex_action_15",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Lexer",
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_15",
          "normalized": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "package": "libcspm",
          "signature": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Lexer.html#v:alex_action_15"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_16",
          "package": "libcspm",
          "signature": "AlexInput -\u003e Int -\u003e ParseMonad LToken",
          "source": "src/CSPM-Parser-Lexer.html#alex_action_16",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Lexer",
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_16",
          "normalized": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "package": "libcspm",
          "signature": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Lexer.html#v:alex_action_16"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_17",
          "package": "libcspm",
          "signature": "AlexInput -\u003e Int -\u003e ParseMonad LToken",
          "source": "src/CSPM-Parser-Lexer.html#alex_action_17",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Lexer",
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_17",
          "normalized": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "package": "libcspm",
          "signature": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Lexer.html#v:alex_action_17"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_18",
          "package": "libcspm",
          "signature": "AlexInput -\u003e Int -\u003e ParseMonad LToken",
          "source": "src/CSPM-Parser-Lexer.html#alex_action_18",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Lexer",
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_18",
          "normalized": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "package": "libcspm",
          "signature": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Lexer.html#v:alex_action_18"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_19",
          "package": "libcspm",
          "signature": "AlexInput -\u003e Int -\u003e ParseMonad LToken",
          "source": "src/CSPM-Parser-Lexer.html#alex_action_19",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Lexer",
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_19",
          "normalized": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "package": "libcspm",
          "signature": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Lexer.html#v:alex_action_19"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_2",
          "package": "libcspm",
          "signature": "AlexInput -\u003e Int -\u003e ParseMonad LToken",
          "source": "src/CSPM-Parser-Lexer.html#alex_action_2",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Lexer",
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_2",
          "normalized": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "package": "libcspm",
          "signature": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Lexer.html#v:alex_action_2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_20",
          "package": "libcspm",
          "signature": "AlexInput -\u003e Int -\u003e ParseMonad LToken",
          "source": "src/CSPM-Parser-Lexer.html#alex_action_20",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Lexer",
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_20",
          "normalized": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "package": "libcspm",
          "signature": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Lexer.html#v:alex_action_20"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_21",
          "package": "libcspm",
          "signature": "AlexInput -\u003e Int -\u003e ParseMonad LToken",
          "source": "src/CSPM-Parser-Lexer.html#alex_action_21",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Lexer",
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_21",
          "normalized": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "package": "libcspm",
          "signature": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Lexer.html#v:alex_action_21"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_22",
          "package": "libcspm",
          "signature": "AlexInput -\u003e Int -\u003e ParseMonad LToken",
          "source": "src/CSPM-Parser-Lexer.html#alex_action_22",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Lexer",
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_22",
          "normalized": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "package": "libcspm",
          "signature": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Lexer.html#v:alex_action_22"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_23",
          "package": "libcspm",
          "signature": "AlexInput -\u003e Int -\u003e ParseMonad LToken",
          "source": "src/CSPM-Parser-Lexer.html#alex_action_23",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Lexer",
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_23",
          "normalized": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "package": "libcspm",
          "signature": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Lexer.html#v:alex_action_23"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_24",
          "package": "libcspm",
          "signature": "AlexInput -\u003e Int -\u003e ParseMonad LToken",
          "source": "src/CSPM-Parser-Lexer.html#alex_action_24",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Lexer",
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_24",
          "normalized": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "package": "libcspm",
          "signature": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Lexer.html#v:alex_action_24"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_25",
          "package": "libcspm",
          "signature": "AlexInput -\u003e Int -\u003e ParseMonad LToken",
          "source": "src/CSPM-Parser-Lexer.html#alex_action_25",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Lexer",
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_25",
          "normalized": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "package": "libcspm",
          "signature": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Lexer.html#v:alex_action_25"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_26",
          "package": "libcspm",
          "signature": "AlexInput -\u003e Int -\u003e ParseMonad LToken",
          "source": "src/CSPM-Parser-Lexer.html#alex_action_26",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Lexer",
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_26",
          "normalized": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "package": "libcspm",
          "signature": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Lexer.html#v:alex_action_26"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_27",
          "package": "libcspm",
          "signature": "AlexInput -\u003e Int -\u003e ParseMonad LToken",
          "source": "src/CSPM-Parser-Lexer.html#alex_action_27",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Lexer",
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_27",
          "normalized": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "package": "libcspm",
          "signature": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Lexer.html#v:alex_action_27"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_28",
          "package": "libcspm",
          "signature": "AlexInput -\u003e Int -\u003e ParseMonad LToken",
          "source": "src/CSPM-Parser-Lexer.html#alex_action_28",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Lexer",
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_28",
          "normalized": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "package": "libcspm",
          "signature": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Lexer.html#v:alex_action_28"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_29",
          "package": "libcspm",
          "signature": "AlexInput -\u003e Int -\u003e ParseMonad LToken",
          "source": "src/CSPM-Parser-Lexer.html#alex_action_29",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Lexer",
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_29",
          "normalized": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "package": "libcspm",
          "signature": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Lexer.html#v:alex_action_29"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_3",
          "package": "libcspm",
          "signature": "AlexInput -\u003e Int -\u003e ParseMonad LToken",
          "source": "src/CSPM-Parser-Lexer.html#alex_action_3",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Lexer",
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_3",
          "normalized": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "package": "libcspm",
          "signature": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Lexer.html#v:alex_action_3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_30",
          "package": "libcspm",
          "signature": "AlexInput -\u003e Int -\u003e ParseMonad LToken",
          "source": "src/CSPM-Parser-Lexer.html#alex_action_30",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Lexer",
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_30",
          "normalized": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "package": "libcspm",
          "signature": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Lexer.html#v:alex_action_30"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_31",
          "package": "libcspm",
          "signature": "AlexInput -\u003e Int -\u003e ParseMonad LToken",
          "source": "src/CSPM-Parser-Lexer.html#alex_action_31",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Lexer",
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_31",
          "normalized": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "package": "libcspm",
          "signature": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Lexer.html#v:alex_action_31"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_32",
          "package": "libcspm",
          "signature": "AlexInput -\u003e Int -\u003e ParseMonad LToken",
          "source": "src/CSPM-Parser-Lexer.html#alex_action_32",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Lexer",
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_32",
          "normalized": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "package": "libcspm",
          "signature": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Lexer.html#v:alex_action_32"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_33",
          "package": "libcspm",
          "signature": "AlexInput -\u003e Int -\u003e ParseMonad LToken",
          "source": "src/CSPM-Parser-Lexer.html#alex_action_33",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Lexer",
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_33",
          "normalized": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "package": "libcspm",
          "signature": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Lexer.html#v:alex_action_33"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_34",
          "package": "libcspm",
          "signature": "AlexInput -\u003e Int -\u003e ParseMonad LToken",
          "source": "src/CSPM-Parser-Lexer.html#alex_action_34",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Lexer",
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_34",
          "normalized": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "package": "libcspm",
          "signature": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Lexer.html#v:alex_action_34"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_35",
          "package": "libcspm",
          "signature": "AlexInput -\u003e Int -\u003e ParseMonad LToken",
          "source": "src/CSPM-Parser-Lexer.html#alex_action_35",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Lexer",
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_35",
          "normalized": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "package": "libcspm",
          "signature": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Lexer.html#v:alex_action_35"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_36",
          "package": "libcspm",
          "signature": "AlexInput -\u003e Int -\u003e ParseMonad LToken",
          "source": "src/CSPM-Parser-Lexer.html#alex_action_36",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Lexer",
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_36",
          "normalized": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "package": "libcspm",
          "signature": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Lexer.html#v:alex_action_36"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_37",
          "package": "libcspm",
          "signature": "AlexInput -\u003e Int -\u003e ParseMonad LToken",
          "source": "src/CSPM-Parser-Lexer.html#alex_action_37",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Lexer",
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_37",
          "normalized": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "package": "libcspm",
          "signature": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Lexer.html#v:alex_action_37"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_38",
          "package": "libcspm",
          "signature": "AlexInput -\u003e Int -\u003e ParseMonad LToken",
          "source": "src/CSPM-Parser-Lexer.html#alex_action_38",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Lexer",
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_38",
          "normalized": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "package": "libcspm",
          "signature": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Lexer.html#v:alex_action_38"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_39",
          "package": "libcspm",
          "signature": "AlexInput -\u003e Int -\u003e ParseMonad LToken",
          "source": "src/CSPM-Parser-Lexer.html#alex_action_39",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Lexer",
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_39",
          "normalized": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "package": "libcspm",
          "signature": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Lexer.html#v:alex_action_39"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_4",
          "package": "libcspm",
          "signature": "AlexInput -\u003e Int -\u003e ParseMonad LToken",
          "source": "src/CSPM-Parser-Lexer.html#alex_action_4",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Lexer",
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_4",
          "normalized": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "package": "libcspm",
          "signature": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Lexer.html#v:alex_action_4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_40",
          "package": "libcspm",
          "signature": "AlexInput -\u003e Int -\u003e ParseMonad LToken",
          "source": "src/CSPM-Parser-Lexer.html#alex_action_40",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Lexer",
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_40",
          "normalized": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "package": "libcspm",
          "signature": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Lexer.html#v:alex_action_40"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_41",
          "package": "libcspm",
          "signature": "AlexInput -\u003e Int -\u003e ParseMonad LToken",
          "source": "src/CSPM-Parser-Lexer.html#alex_action_41",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Lexer",
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_41",
          "normalized": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "package": "libcspm",
          "signature": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Lexer.html#v:alex_action_41"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_42",
          "package": "libcspm",
          "signature": "AlexInput -\u003e Int -\u003e ParseMonad LToken",
          "source": "src/CSPM-Parser-Lexer.html#alex_action_42",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Lexer",
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_42",
          "normalized": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "package": "libcspm",
          "signature": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Lexer.html#v:alex_action_42"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_43",
          "package": "libcspm",
          "signature": "AlexInput -\u003e Int -\u003e ParseMonad LToken",
          "source": "src/CSPM-Parser-Lexer.html#alex_action_43",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Lexer",
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_43",
          "normalized": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "package": "libcspm",
          "signature": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Lexer.html#v:alex_action_43"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_44",
          "package": "libcspm",
          "signature": "AlexInput -\u003e Int -\u003e ParseMonad LToken",
          "source": "src/CSPM-Parser-Lexer.html#alex_action_44",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Lexer",
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_44",
          "normalized": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "package": "libcspm",
          "signature": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Lexer.html#v:alex_action_44"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_45",
          "package": "libcspm",
          "signature": "AlexInput -\u003e Int -\u003e ParseMonad LToken",
          "source": "src/CSPM-Parser-Lexer.html#alex_action_45",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Lexer",
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_45",
          "normalized": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "package": "libcspm",
          "signature": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Lexer.html#v:alex_action_45"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_46",
          "package": "libcspm",
          "signature": "AlexInput -\u003e Int -\u003e ParseMonad LToken",
          "source": "src/CSPM-Parser-Lexer.html#alex_action_46",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Lexer",
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_46",
          "normalized": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "package": "libcspm",
          "signature": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Lexer.html#v:alex_action_46"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_47",
          "package": "libcspm",
          "signature": "AlexInput -\u003e Int -\u003e ParseMonad LToken",
          "source": "src/CSPM-Parser-Lexer.html#alex_action_47",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Lexer",
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_47",
          "normalized": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "package": "libcspm",
          "signature": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Lexer.html#v:alex_action_47"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_48",
          "package": "libcspm",
          "signature": "AlexInput -\u003e Int -\u003e ParseMonad LToken",
          "source": "src/CSPM-Parser-Lexer.html#alex_action_48",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Lexer",
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_48",
          "normalized": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "package": "libcspm",
          "signature": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Lexer.html#v:alex_action_48"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_49",
          "package": "libcspm",
          "signature": "AlexInput -\u003e Int -\u003e ParseMonad LToken",
          "source": "src/CSPM-Parser-Lexer.html#alex_action_49",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Lexer",
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_49",
          "normalized": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "package": "libcspm",
          "signature": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Lexer.html#v:alex_action_49"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_5",
          "package": "libcspm",
          "signature": "AlexInput -\u003e Int -\u003e ParseMonad LToken",
          "source": "src/CSPM-Parser-Lexer.html#alex_action_5",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Lexer",
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_5",
          "normalized": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "package": "libcspm",
          "signature": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Lexer.html#v:alex_action_5"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_50",
          "package": "libcspm",
          "signature": "AlexInput -\u003e Int -\u003e ParseMonad LToken",
          "source": "src/CSPM-Parser-Lexer.html#alex_action_50",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Lexer",
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_50",
          "normalized": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "package": "libcspm",
          "signature": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Lexer.html#v:alex_action_50"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_51",
          "package": "libcspm",
          "signature": "AlexInput -\u003e Int -\u003e ParseMonad LToken",
          "source": "src/CSPM-Parser-Lexer.html#alex_action_51",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Lexer",
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_51",
          "normalized": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "package": "libcspm",
          "signature": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Lexer.html#v:alex_action_51"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_52",
          "package": "libcspm",
          "signature": "AlexInput -\u003e Int -\u003e ParseMonad LToken",
          "source": "src/CSPM-Parser-Lexer.html#alex_action_52",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Lexer",
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_52",
          "normalized": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "package": "libcspm",
          "signature": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Lexer.html#v:alex_action_52"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_53",
          "package": "libcspm",
          "signature": "AlexInput -\u003e Int -\u003e ParseMonad LToken",
          "source": "src/CSPM-Parser-Lexer.html#alex_action_53",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Lexer",
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_53",
          "normalized": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "package": "libcspm",
          "signature": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Lexer.html#v:alex_action_53"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_54",
          "package": "libcspm",
          "signature": "AlexInput -\u003e Int -\u003e ParseMonad LToken",
          "source": "src/CSPM-Parser-Lexer.html#alex_action_54",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Lexer",
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_54",
          "normalized": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "package": "libcspm",
          "signature": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Lexer.html#v:alex_action_54"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_55",
          "package": "libcspm",
          "signature": "AlexInput -\u003e Int -\u003e ParseMonad LToken",
          "source": "src/CSPM-Parser-Lexer.html#alex_action_55",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Lexer",
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_55",
          "normalized": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "package": "libcspm",
          "signature": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Lexer.html#v:alex_action_55"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_56",
          "package": "libcspm",
          "signature": "AlexInput -\u003e Int -\u003e ParseMonad LToken",
          "source": "src/CSPM-Parser-Lexer.html#alex_action_56",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Lexer",
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_56",
          "normalized": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "package": "libcspm",
          "signature": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Lexer.html#v:alex_action_56"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_57",
          "package": "libcspm",
          "signature": "AlexInput -\u003e Int -\u003e ParseMonad LToken",
          "source": "src/CSPM-Parser-Lexer.html#alex_action_57",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Lexer",
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_57",
          "normalized": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "package": "libcspm",
          "signature": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Lexer.html#v:alex_action_57"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_58",
          "package": "libcspm",
          "signature": "AlexInput -\u003e Int -\u003e ParseMonad LToken",
          "source": "src/CSPM-Parser-Lexer.html#alex_action_58",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Lexer",
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_58",
          "normalized": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "package": "libcspm",
          "signature": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Lexer.html#v:alex_action_58"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_59",
          "package": "libcspm",
          "signature": "AlexInput -\u003e Int -\u003e ParseMonad LToken",
          "source": "src/CSPM-Parser-Lexer.html#alex_action_59",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Lexer",
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_59",
          "normalized": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "package": "libcspm",
          "signature": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Lexer.html#v:alex_action_59"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_6",
          "package": "libcspm",
          "signature": "AlexInput -\u003e Int -\u003e ParseMonad LToken",
          "source": "src/CSPM-Parser-Lexer.html#alex_action_6",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Lexer",
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_6",
          "normalized": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "package": "libcspm",
          "signature": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Lexer.html#v:alex_action_6"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_60",
          "package": "libcspm",
          "signature": "AlexInput -\u003e Int -\u003e ParseMonad LToken",
          "source": "src/CSPM-Parser-Lexer.html#alex_action_60",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Lexer",
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_60",
          "normalized": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "package": "libcspm",
          "signature": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Lexer.html#v:alex_action_60"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_61",
          "package": "libcspm",
          "signature": "AlexInput -\u003e Int -\u003e ParseMonad LToken",
          "source": "src/CSPM-Parser-Lexer.html#alex_action_61",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Lexer",
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_61",
          "normalized": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "package": "libcspm",
          "signature": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Lexer.html#v:alex_action_61"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_62",
          "package": "libcspm",
          "signature": "AlexInput -\u003e Int -\u003e ParseMonad LToken",
          "source": "src/CSPM-Parser-Lexer.html#alex_action_62",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Lexer",
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_62",
          "normalized": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "package": "libcspm",
          "signature": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Lexer.html#v:alex_action_62"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_63",
          "package": "libcspm",
          "signature": "AlexInput -\u003e Int -\u003e StateT ParserState IO LToken",
          "source": "src/CSPM-Parser-Lexer.html#alex_action_63",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Lexer",
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_63",
          "normalized": "AlexInput-\u003eInt-\u003eStateT ParserState IO LToken",
          "package": "libcspm",
          "signature": "AlexInput-\u003eInt-\u003eStateT ParserState IO LToken",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Lexer.html#v:alex_action_63"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_64",
          "package": "libcspm",
          "signature": "AlexInput -\u003e Int -\u003e StateT ParserState IO LToken",
          "source": "src/CSPM-Parser-Lexer.html#alex_action_64",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Lexer",
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_64",
          "normalized": "AlexInput-\u003eInt-\u003eStateT ParserState IO LToken",
          "package": "libcspm",
          "signature": "AlexInput-\u003eInt-\u003eStateT ParserState IO LToken",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Lexer.html#v:alex_action_64"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_65",
          "package": "libcspm",
          "signature": "AlexInput -\u003e Int -\u003e StateT ParserState IO LToken",
          "source": "src/CSPM-Parser-Lexer.html#alex_action_65",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Lexer",
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_65",
          "normalized": "AlexInput-\u003eInt-\u003eStateT ParserState IO LToken",
          "package": "libcspm",
          "signature": "AlexInput-\u003eInt-\u003eStateT ParserState IO LToken",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Lexer.html#v:alex_action_65"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_66",
          "package": "libcspm",
          "signature": "AlexInput -\u003e Int -\u003e StateT ParserState IO LToken",
          "source": "src/CSPM-Parser-Lexer.html#alex_action_66",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Lexer",
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_66",
          "normalized": "AlexInput-\u003eInt-\u003eStateT ParserState IO LToken",
          "package": "libcspm",
          "signature": "AlexInput-\u003eInt-\u003eStateT ParserState IO LToken",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Lexer.html#v:alex_action_66"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_67",
          "package": "libcspm",
          "signature": "AlexInput -\u003e Int -\u003e StateT ParserState IO LToken",
          "source": "src/CSPM-Parser-Lexer.html#alex_action_67",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Lexer",
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_67",
          "normalized": "AlexInput-\u003eInt-\u003eStateT ParserState IO LToken",
          "package": "libcspm",
          "signature": "AlexInput-\u003eInt-\u003eStateT ParserState IO LToken",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Lexer.html#v:alex_action_67"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_68",
          "package": "libcspm",
          "signature": "AlexInput -\u003e Int -\u003e StateT ParserState IO LToken",
          "source": "src/CSPM-Parser-Lexer.html#alex_action_68",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Lexer",
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_68",
          "normalized": "AlexInput-\u003eInt-\u003eStateT ParserState IO LToken",
          "package": "libcspm",
          "signature": "AlexInput-\u003eInt-\u003eStateT ParserState IO LToken",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Lexer.html#v:alex_action_68"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_69",
          "package": "libcspm",
          "signature": "AlexInput -\u003e Int -\u003e StateT ParserState IO LToken",
          "source": "src/CSPM-Parser-Lexer.html#alex_action_69",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Lexer",
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_69",
          "normalized": "AlexInput-\u003eInt-\u003eStateT ParserState IO LToken",
          "package": "libcspm",
          "signature": "AlexInput-\u003eInt-\u003eStateT ParserState IO LToken",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Lexer.html#v:alex_action_69"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_7",
          "package": "libcspm",
          "signature": "AlexInput -\u003e Int -\u003e ParseMonad LToken",
          "source": "src/CSPM-Parser-Lexer.html#alex_action_7",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Lexer",
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_7",
          "normalized": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "package": "libcspm",
          "signature": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Lexer.html#v:alex_action_7"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_70",
          "package": "libcspm",
          "signature": "AlexInput -\u003e Int -\u003e StateT ParserState IO LToken",
          "source": "src/CSPM-Parser-Lexer.html#alex_action_70",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Lexer",
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_70",
          "normalized": "AlexInput-\u003eInt-\u003eStateT ParserState IO LToken",
          "package": "libcspm",
          "signature": "AlexInput-\u003eInt-\u003eStateT ParserState IO LToken",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Lexer.html#v:alex_action_70"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_71",
          "package": "libcspm",
          "signature": "AlexInput -\u003e Int -\u003e StateT ParserState IO LToken",
          "source": "src/CSPM-Parser-Lexer.html#alex_action_71",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Lexer",
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_71",
          "normalized": "AlexInput-\u003eInt-\u003eStateT ParserState IO LToken",
          "package": "libcspm",
          "signature": "AlexInput-\u003eInt-\u003eStateT ParserState IO LToken",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Lexer.html#v:alex_action_71"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_72",
          "package": "libcspm",
          "signature": "AlexInput -\u003e Int -\u003e StateT ParserState IO LToken",
          "source": "src/CSPM-Parser-Lexer.html#alex_action_72",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Lexer",
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_72",
          "normalized": "AlexInput-\u003eInt-\u003eStateT ParserState IO LToken",
          "package": "libcspm",
          "signature": "AlexInput-\u003eInt-\u003eStateT ParserState IO LToken",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Lexer.html#v:alex_action_72"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_73",
          "package": "libcspm",
          "signature": "AlexInput -\u003e Int -\u003e StateT ParserState IO LToken",
          "source": "src/CSPM-Parser-Lexer.html#alex_action_73",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Lexer",
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_73",
          "normalized": "AlexInput-\u003eInt-\u003eStateT ParserState IO LToken",
          "package": "libcspm",
          "signature": "AlexInput-\u003eInt-\u003eStateT ParserState IO LToken",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Lexer.html#v:alex_action_73"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_74",
          "package": "libcspm",
          "signature": "AlexInput -\u003e Int -\u003e StateT ParserState IO LToken",
          "source": "src/CSPM-Parser-Lexer.html#alex_action_74",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Lexer",
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_74",
          "normalized": "AlexInput-\u003eInt-\u003eStateT ParserState IO LToken",
          "package": "libcspm",
          "signature": "AlexInput-\u003eInt-\u003eStateT ParserState IO LToken",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Lexer.html#v:alex_action_74"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_75",
          "package": "libcspm",
          "signature": "AlexInput -\u003e Int -\u003e ParseMonad LToken",
          "source": "src/CSPM-Parser-Lexer.html#alex_action_75",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Lexer",
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_75",
          "normalized": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "package": "libcspm",
          "signature": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Lexer.html#v:alex_action_75"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_76",
          "package": "libcspm",
          "signature": "AlexInput -\u003e Int -\u003e ParseMonad LToken",
          "source": "src/CSPM-Parser-Lexer.html#alex_action_76",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Lexer",
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_76",
          "normalized": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "package": "libcspm",
          "signature": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Lexer.html#v:alex_action_76"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_77",
          "package": "libcspm",
          "signature": "AlexInput -\u003e Int -\u003e ParseMonad LToken",
          "source": "src/CSPM-Parser-Lexer.html#alex_action_77",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Lexer",
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_77",
          "normalized": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "package": "libcspm",
          "signature": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Lexer.html#v:alex_action_77"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_78",
          "package": "libcspm",
          "signature": "AlexInput -\u003e Int -\u003e ParseMonad LToken",
          "source": "src/CSPM-Parser-Lexer.html#alex_action_78",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Lexer",
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_78",
          "normalized": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "package": "libcspm",
          "signature": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Lexer.html#v:alex_action_78"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_79",
          "package": "libcspm",
          "signature": "AlexInput -\u003e Int -\u003e ParseMonad LToken",
          "source": "src/CSPM-Parser-Lexer.html#alex_action_79",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Lexer",
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_79",
          "normalized": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "package": "libcspm",
          "signature": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Lexer.html#v:alex_action_79"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_8",
          "package": "libcspm",
          "signature": "AlexInput -\u003e Int -\u003e ParseMonad LToken",
          "source": "src/CSPM-Parser-Lexer.html#alex_action_8",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Lexer",
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_8",
          "normalized": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "package": "libcspm",
          "signature": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Lexer.html#v:alex_action_8"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_80",
          "package": "libcspm",
          "signature": "AlexInput -\u003e Int -\u003e ParseMonad LToken",
          "source": "src/CSPM-Parser-Lexer.html#alex_action_80",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Lexer",
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_80",
          "normalized": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "package": "libcspm",
          "signature": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Lexer.html#v:alex_action_80"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_81",
          "package": "libcspm",
          "signature": "AlexInput -\u003e Int -\u003e ParseMonad LToken",
          "source": "src/CSPM-Parser-Lexer.html#alex_action_81",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Lexer",
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_81",
          "normalized": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "package": "libcspm",
          "signature": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Lexer.html#v:alex_action_81"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_82",
          "package": "libcspm",
          "signature": "AlexInput -\u003e Int -\u003e ParseMonad LToken",
          "source": "src/CSPM-Parser-Lexer.html#alex_action_82",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Lexer",
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_82",
          "normalized": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "package": "libcspm",
          "signature": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Lexer.html#v:alex_action_82"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_83",
          "package": "libcspm",
          "signature": "AlexInput -\u003e Int -\u003e ParseMonad LToken",
          "source": "src/CSPM-Parser-Lexer.html#alex_action_83",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Lexer",
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_83",
          "normalized": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "package": "libcspm",
          "signature": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Lexer.html#v:alex_action_83"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_84",
          "package": "libcspm",
          "signature": "AlexInput -\u003e Int -\u003e ParseMonad LToken",
          "source": "src/CSPM-Parser-Lexer.html#alex_action_84",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Lexer",
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_84",
          "normalized": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "package": "libcspm",
          "signature": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Lexer.html#v:alex_action_84"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_85",
          "package": "libcspm",
          "signature": "AlexInput -\u003e Int -\u003e ParseMonad LToken",
          "source": "src/CSPM-Parser-Lexer.html#alex_action_85",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Lexer",
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_85",
          "normalized": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "package": "libcspm",
          "signature": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Lexer.html#v:alex_action_85"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_86",
          "package": "libcspm",
          "signature": "AlexInput -\u003e Int -\u003e ParseMonad LToken",
          "source": "src/CSPM-Parser-Lexer.html#alex_action_86",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Lexer",
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_86",
          "normalized": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "package": "libcspm",
          "signature": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Lexer.html#v:alex_action_86"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_87",
          "package": "libcspm",
          "signature": "AlexInput -\u003e Int -\u003e ParseMonad LToken",
          "source": "src/CSPM-Parser-Lexer.html#alex_action_87",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Lexer",
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_87",
          "normalized": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "package": "libcspm",
          "signature": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Lexer.html#v:alex_action_87"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_88",
          "package": "libcspm",
          "signature": "AlexInput -\u003e Int -\u003e ParseMonad LToken",
          "source": "src/CSPM-Parser-Lexer.html#alex_action_88",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Lexer",
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_88",
          "normalized": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "package": "libcspm",
          "signature": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Lexer.html#v:alex_action_88"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_89",
          "package": "libcspm",
          "signature": "AlexInput -\u003e Int -\u003e ParseMonad LToken",
          "source": "src/CSPM-Parser-Lexer.html#alex_action_89",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Lexer",
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_89",
          "normalized": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "package": "libcspm",
          "signature": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Lexer.html#v:alex_action_89"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_9",
          "package": "libcspm",
          "signature": "AlexInput -\u003e Int -\u003e ParseMonad LToken",
          "source": "src/CSPM-Parser-Lexer.html#alex_action_9",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Lexer",
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_9",
          "normalized": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "package": "libcspm",
          "signature": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Lexer.html#v:alex_action_9"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_90",
          "package": "libcspm",
          "signature": "AlexInput -\u003e Int -\u003e ParseMonad LToken",
          "source": "src/CSPM-Parser-Lexer.html#alex_action_90",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Lexer",
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_90",
          "normalized": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "package": "libcspm",
          "signature": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Lexer.html#v:alex_action_90"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_91",
          "package": "libcspm",
          "signature": "AlexInput -\u003e Int -\u003e ParseMonad LToken",
          "source": "src/CSPM-Parser-Lexer.html#alex_action_91",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Lexer",
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_91",
          "normalized": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "package": "libcspm",
          "signature": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Lexer.html#v:alex_action_91"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_92",
          "package": "libcspm",
          "signature": "AlexInput -\u003e Int -\u003e ParseMonad LToken",
          "source": "src/CSPM-Parser-Lexer.html#alex_action_92",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Lexer",
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_92",
          "normalized": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "package": "libcspm",
          "signature": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Lexer.html#v:alex_action_92"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_93",
          "package": "libcspm",
          "signature": "AlexInput -\u003e Int -\u003e ParseMonad LToken",
          "source": "src/CSPM-Parser-Lexer.html#alex_action_93",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Lexer",
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_93",
          "normalized": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "package": "libcspm",
          "signature": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Lexer.html#v:alex_action_93"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_94",
          "package": "libcspm",
          "signature": "AlexInput -\u003e Int -\u003e ParseMonad LToken",
          "source": "src/CSPM-Parser-Lexer.html#alex_action_94",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Lexer",
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_94",
          "normalized": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "package": "libcspm",
          "signature": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Lexer.html#v:alex_action_94"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_95",
          "package": "libcspm",
          "signature": "AlexInput -\u003e Int -\u003e ParseMonad LToken",
          "source": "src/CSPM-Parser-Lexer.html#alex_action_95",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Lexer",
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_95",
          "normalized": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "package": "libcspm",
          "signature": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Lexer.html#v:alex_action_95"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_96",
          "package": "libcspm",
          "signature": "AlexInput -\u003e Int -\u003e ParseMonad LToken",
          "source": "src/CSPM-Parser-Lexer.html#alex_action_96",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Lexer",
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_96",
          "normalized": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "package": "libcspm",
          "signature": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Lexer.html#v:alex_action_96"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_97",
          "package": "libcspm",
          "signature": "AlexInput -\u003e Int -\u003e ParseMonad LToken",
          "source": "src/CSPM-Parser-Lexer.html#alex_action_97",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Lexer",
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_97",
          "normalized": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "package": "libcspm",
          "signature": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Lexer.html#v:alex_action_97"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_98",
          "package": "libcspm",
          "signature": "AlexInput -\u003e Int -\u003e ParseMonad LToken",
          "source": "src/CSPM-Parser-Lexer.html#alex_action_98",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Lexer",
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_98",
          "normalized": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "package": "libcspm",
          "signature": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Lexer.html#v:alex_action_98"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_99",
          "package": "libcspm",
          "signature": "AlexInput -\u003e Int -\u003e ParseMonad LToken",
          "source": "src/CSPM-Parser-Lexer.html#alex_action_99",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Lexer",
          "module": "CSPM.Parser.Lexer",
          "name": "alex_action_99",
          "normalized": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "package": "libcspm",
          "signature": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Lexer.html#v:alex_action_99"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Lexer",
          "name": "alex_base",
          "package": "libcspm",
          "signature": "AlexAddr",
          "source": "src/CSPM-Parser-Lexer.html#alex_base",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Lexer",
          "module": "CSPM.Parser.Lexer",
          "name": "alex_base",
          "package": "libcspm",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Lexer.html#v:alex_base"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Lexer",
          "name": "alex_check",
          "package": "libcspm",
          "signature": "AlexAddr",
          "source": "src/CSPM-Parser-Lexer.html#alex_check",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Lexer",
          "module": "CSPM.Parser.Lexer",
          "name": "alex_check",
          "package": "libcspm",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Lexer.html#v:alex_check"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Lexer",
          "name": "alex_deflt",
          "package": "libcspm",
          "signature": "AlexAddr",
          "source": "src/CSPM-Parser-Lexer.html#alex_deflt",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Lexer",
          "module": "CSPM.Parser.Lexer",
          "name": "alex_deflt",
          "package": "libcspm",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Lexer.html#v:alex_deflt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Lexer",
          "name": "alex_scan_tkn",
          "package": "libcspm",
          "signature": "Any * -\u003e ParserState -\u003e Int# -\u003e ParserState -\u003e Int# -\u003e AlexLastAcc (AlexInput -\u003e Int -\u003e ParseMonad LToken) -\u003e (AlexLastAcc (AlexInput -\u003e Int -\u003e ParseMonad LToken), ParserState)",
          "source": "src/CSPM-Parser-Lexer.html#alex_scan_tkn",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Lexer",
          "module": "CSPM.Parser.Lexer",
          "name": "alex_scan_tkn",
          "normalized": "Any*-\u003eParserState-\u003eInt #-\u003eParserState-\u003eInt #-\u003eAlexLastAcc(AlexInput-\u003eInt-\u003eParseMonad LToken)-\u003e(AlexLastAcc(AlexInput-\u003eInt-\u003eParseMonad LToken),ParserState)",
          "package": "libcspm",
          "signature": "Any*-\u003eParserState-\u003eInt #-\u003eParserState-\u003eInt #-\u003eAlexLastAcc(AlexInput-\u003eInt-\u003eParseMonad LToken)-\u003e(AlexLastAcc(AlexInput-\u003eInt-\u003eParseMonad LToken),ParserState)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Lexer.html#v:alex_scan_tkn"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Lexer",
          "name": "alex_table",
          "package": "libcspm",
          "signature": "AlexAddr",
          "source": "src/CSPM-Parser-Lexer.html#alex_table",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Lexer",
          "module": "CSPM.Parser.Lexer",
          "name": "alex_table",
          "package": "libcspm",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Lexer.html#v:alex_table"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Lexer",
          "name": "assert",
          "package": "libcspm",
          "signature": "Int",
          "source": "src/CSPM-Parser-Lexer.html#assert",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Lexer",
          "module": "CSPM.Parser.Lexer",
          "name": "assert",
          "package": "libcspm",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Lexer.html#v:assert"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Lexer",
          "name": "begin",
          "package": "libcspm",
          "signature": "Int -\u003e AlexInput -\u003e Int -\u003e ParseMonad LToken",
          "source": "src/CSPM-Parser-Lexer.html#begin",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Lexer",
          "module": "CSPM.Parser.Lexer",
          "name": "begin",
          "normalized": "Int-\u003eAlexInput-\u003eInt-\u003eParseMonad LToken",
          "package": "libcspm",
          "signature": "Int-\u003eAlexInput-\u003eInt-\u003eParseMonad LToken",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Lexer.html#v:begin"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Lexer",
          "name": "begin'",
          "package": "libcspm",
          "signature": "Int -\u003e Token -\u003e AlexInput -\u003e Int -\u003e ParseMonad LToken",
          "source": "src/CSPM-Parser-Lexer.html#begin%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Lexer",
          "module": "CSPM.Parser.Lexer",
          "name": "begin'",
          "normalized": "Int-\u003eToken-\u003eAlexInput-\u003eInt-\u003eParseMonad LToken",
          "package": "libcspm",
          "signature": "Int-\u003eToken-\u003eAlexInput-\u003eInt-\u003eParseMonad LToken",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Lexer.html#v:begin-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Lexer",
          "name": "closeseq",
          "package": "libcspm",
          "signature": "Token -\u003e AlexInput -\u003e Int -\u003e StateT ParserState IO LToken",
          "source": "src/CSPM-Parser-Lexer.html#closeseq",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Lexer",
          "module": "CSPM.Parser.Lexer",
          "name": "closeseq",
          "normalized": "Token-\u003eAlexInput-\u003eInt-\u003eStateT ParserState IO LToken",
          "package": "libcspm",
          "signature": "Token-\u003eAlexInput-\u003eInt-\u003eStateT ParserState IO LToken",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Lexer.html#v:closeseq"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Lexer",
          "name": "getNextToken",
          "package": "libcspm",
          "signature": "ParseMonad LToken",
          "source": "src/CSPM-Parser-Lexer.html#getNextToken",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Lexer",
          "module": "CSPM.Parser.Lexer",
          "name": "getNextToken",
          "package": "libcspm",
          "partial": "Next Token",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Lexer.html#v:getNextToken"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Lexer",
          "name": "getNextTokenWrapper",
          "package": "libcspm",
          "signature": "(LToken -\u003e ParseMonad a) -\u003e ParseMonad a",
          "source": "src/CSPM-Parser-Lexer.html#getNextTokenWrapper",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Lexer",
          "module": "CSPM.Parser.Lexer",
          "name": "getNextTokenWrapper",
          "normalized": "(LToken-\u003eParseMonad a)-\u003eParseMonad a",
          "package": "libcspm",
          "partial": "Next Token Wrapper",
          "signature": "(LToken-\u003eParseMonad a)-\u003eParseMonad a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Lexer.html#v:getNextTokenWrapper"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Lexer",
          "name": "gt",
          "package": "libcspm",
          "signature": "AlexInput -\u003e Int -\u003e ParseMonad LToken",
          "source": "src/CSPM-Parser-Lexer.html#gt",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Lexer",
          "module": "CSPM.Parser.Lexer",
          "name": "gt",
          "normalized": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "package": "libcspm",
          "signature": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Lexer.html#v:gt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Lexer",
          "name": "iUnbox",
          "package": "libcspm",
          "signature": "Int -\u003e Int#",
          "source": "src/CSPM-Parser-Lexer.html#iUnbox",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Lexer",
          "module": "CSPM.Parser.Lexer",
          "name": "iUnbox",
          "normalized": "Int-\u003eInt #",
          "package": "libcspm",
          "partial": "Unbox",
          "signature": "Int-\u003eInt #",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Lexer.html#v:iUnbox"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSame as \u003ccode\u003e\u003ca\u003estrip\u003c/a\u003e\u003c/code\u003e, but applies only to the left side of the string.\n\u003c/p\u003e",
          "module": "CSPM.Parser.Lexer",
          "name": "lstrip",
          "package": "libcspm",
          "signature": "String -\u003e String",
          "source": "src/CSPM-Parser-Lexer.html#lstrip",
          "type": "function"
        },
        "index": {
          "description": "Same as strip but applies only to the left side of the string",
          "hierarchy": "CSPM Parser Lexer",
          "module": "CSPM.Parser.Lexer",
          "name": "lstrip",
          "normalized": "String-\u003eString",
          "package": "libcspm",
          "signature": "String-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Lexer.html#v:lstrip"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Lexer",
          "name": "nestedComment",
          "package": "libcspm",
          "signature": "AlexInput -\u003e Int -\u003e ParseMonad LToken",
          "source": "src/CSPM-Parser-Lexer.html#nestedComment",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Lexer",
          "module": "CSPM.Parser.Lexer",
          "name": "nestedComment",
          "normalized": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "package": "libcspm",
          "partial": "Comment",
          "signature": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Lexer.html#v:nestedComment"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Lexer",
          "name": "openseq",
          "package": "libcspm",
          "signature": "Token -\u003e AlexInput -\u003e Int -\u003e StateT ParserState IO LToken",
          "source": "src/CSPM-Parser-Lexer.html#openseq",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Lexer",
          "module": "CSPM.Parser.Lexer",
          "name": "openseq",
          "normalized": "Token-\u003eAlexInput-\u003eInt-\u003eStateT ParserState IO LToken",
          "package": "libcspm",
          "signature": "Token-\u003eAlexInput-\u003eInt-\u003eStateT ParserState IO LToken",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Lexer.html#v:openseq"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Lexer",
          "name": "quickIndex",
          "package": "libcspm",
          "signature": "Array Int [AlexAcc (AlexInput -\u003e Int -\u003e ParseMonad LToken) (Any *)] -\u003e Int -\u003e [AlexAcc (AlexInput -\u003e Int -\u003e ParseMonad LToken) (Any *)]",
          "source": "src/CSPM-Parser-Lexer.html#quickIndex",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Lexer",
          "module": "CSPM.Parser.Lexer",
          "name": "quickIndex",
          "normalized": "Array Int[AlexAcc(AlexInput-\u003eInt-\u003eParseMonad LToken)(Any*)]-\u003eInt-\u003e[AlexAcc(AlexInput-\u003eInt-\u003eParseMonad LToken)(Any*)]",
          "package": "libcspm",
          "partial": "Index",
          "signature": "Array Int[AlexAcc(AlexInput-\u003eInt-\u003eParseMonad LToken)(Any*)]-\u003eInt-\u003e[AlexAcc(AlexInput-\u003eInt-\u003eParseMonad LToken)(Any*)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Lexer.html#v:quickIndex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSame as \u003ccode\u003e\u003ca\u003estrip\u003c/a\u003e\u003c/code\u003e, but applies only to the right side of the string.\n\u003c/p\u003e",
          "module": "CSPM.Parser.Lexer",
          "name": "rstrip",
          "package": "libcspm",
          "signature": "String -\u003e String",
          "source": "src/CSPM-Parser-Lexer.html#rstrip",
          "type": "function"
        },
        "index": {
          "description": "Same as strip but applies only to the right side of the string",
          "hierarchy": "CSPM Parser Lexer",
          "module": "CSPM.Parser.Lexer",
          "name": "rstrip",
          "normalized": "String-\u003eString",
          "package": "libcspm",
          "signature": "String-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Lexer.html#v:rstrip"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Lexer",
          "name": "sem_prop",
          "package": "libcspm",
          "signature": "Int",
          "source": "src/CSPM-Parser-Lexer.html#sem_prop",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Lexer",
          "module": "CSPM.Parser.Lexer",
          "name": "sem_prop",
          "package": "libcspm",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Lexer.html#v:sem_prop"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Lexer",
          "name": "skip",
          "package": "libcspm",
          "signature": "AlexInput -\u003e Int -\u003e ParseMonad LToken",
          "source": "src/CSPM-Parser-Lexer.html#skip",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Lexer",
          "module": "CSPM.Parser.Lexer",
          "name": "skip",
          "normalized": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "package": "libcspm",
          "signature": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Lexer.html#v:skip"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Lexer",
          "name": "soak",
          "package": "libcspm",
          "signature": "Int",
          "source": "src/CSPM-Parser-Lexer.html#soak",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Lexer",
          "module": "CSPM.Parser.Lexer",
          "name": "soak",
          "package": "libcspm",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Lexer.html#v:soak"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Lexer",
          "name": "soakTok",
          "package": "libcspm",
          "signature": "Token -\u003e AlexInput -\u003e Int -\u003e ParseMonad LToken",
          "source": "src/CSPM-Parser-Lexer.html#soakTok",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Lexer",
          "module": "CSPM.Parser.Lexer",
          "name": "soakTok",
          "normalized": "Token-\u003eAlexInput-\u003eInt-\u003eParseMonad LToken",
          "package": "libcspm",
          "partial": "Tok",
          "signature": "Token-\u003eAlexInput-\u003eInt-\u003eParseMonad LToken",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Lexer.html#v:soakTok"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Lexer",
          "name": "soakTok'",
          "package": "libcspm",
          "signature": "Token -\u003e AlexInput -\u003e Int -\u003e ParseMonad LToken",
          "source": "src/CSPM-Parser-Lexer.html#soakTok%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Lexer",
          "module": "CSPM.Parser.Lexer",
          "name": "soakTok'",
          "normalized": "Token-\u003eAlexInput-\u003eInt-\u003eParseMonad LToken",
          "package": "libcspm",
          "partial": "Tok'",
          "signature": "Token-\u003eAlexInput-\u003eInt-\u003eParseMonad LToken",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Lexer.html#v:soakTok-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Lexer",
          "name": "stok",
          "package": "libcspm",
          "signature": "(String -\u003e Token) -\u003e AlexInput -\u003e Int -\u003e ParseMonad LToken",
          "source": "src/CSPM-Parser-Lexer.html#stok",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Lexer",
          "module": "CSPM.Parser.Lexer",
          "name": "stok",
          "normalized": "(String-\u003eToken)-\u003eAlexInput-\u003eInt-\u003eParseMonad LToken",
          "package": "libcspm",
          "signature": "(String-\u003eToken)-\u003eAlexInput-\u003eInt-\u003eParseMonad LToken",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Lexer.html#v:stok"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Lexer",
          "name": "strip",
          "package": "libcspm",
          "signature": "String -\u003e String",
          "source": "src/CSPM-Parser-Lexer.html#strip",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Lexer",
          "module": "CSPM.Parser.Lexer",
          "name": "strip",
          "normalized": "String-\u003eString",
          "package": "libcspm",
          "signature": "String-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Lexer.html#v:strip"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Lexer",
          "name": "switchInput",
          "package": "libcspm",
          "signature": "AlexInput -\u003e Int -\u003e ParseMonad LToken",
          "source": "src/CSPM-Parser-Lexer.html#switchInput",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Lexer",
          "module": "CSPM.Parser.Lexer",
          "name": "switchInput",
          "normalized": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "package": "libcspm",
          "partial": "Input",
          "signature": "AlexInput-\u003eInt-\u003eParseMonad LToken",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Lexer.html#v:switchInput"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Lexer",
          "name": "takeChars",
          "package": "libcspm",
          "signature": "Int -\u003e [FileParserState] -\u003e String",
          "source": "src/CSPM-Parser-Lexer.html#takeChars",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Lexer",
          "module": "CSPM.Parser.Lexer",
          "name": "takeChars",
          "normalized": "Int-\u003e[FileParserState]-\u003eString",
          "package": "libcspm",
          "partial": "Chars",
          "signature": "Int-\u003e[FileParserState]-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Lexer.html#v:takeChars"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Lexer",
          "name": "tok",
          "package": "libcspm",
          "signature": "Token -\u003e AlexInput -\u003e Int -\u003e ParseMonad LToken",
          "source": "src/CSPM-Parser-Lexer.html#tok",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Lexer",
          "module": "CSPM.Parser.Lexer",
          "name": "tok",
          "normalized": "Token-\u003eAlexInput-\u003eInt-\u003eParseMonad LToken",
          "package": "libcspm",
          "signature": "Token-\u003eAlexInput-\u003eInt-\u003eParseMonad LToken",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Lexer.html#v:tok"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Lexer",
          "name": "wschars",
          "package": "libcspm",
          "signature": "String",
          "source": "src/CSPM-Parser-Lexer.html#wschars",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Lexer",
          "module": "CSPM.Parser.Lexer",
          "name": "wschars",
          "package": "libcspm",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Lexer.html#v:wschars"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Monad",
          "name": "Monad",
          "package": "libcspm",
          "source": "src/CSPM-Parser-Monad.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "CSPM Parser Monad",
          "module": "CSPM.Parser.Monad",
          "name": "Monad",
          "package": "libcspm",
          "partial": "Monad",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Monad.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Monad",
          "name": "FileParserState",
          "package": "libcspm",
          "source": "src/CSPM-Parser-Monad.html#FileParserState",
          "type": "data"
        },
        "index": {
          "hierarchy": "CSPM Parser Monad",
          "module": "CSPM.Parser.Monad",
          "name": "FileParserState",
          "package": "libcspm",
          "partial": "File Parser State",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Monad.html#t:FileParserState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Monad",
          "name": "FilePosition",
          "package": "libcspm",
          "source": "src/CSPM-Parser-Monad.html#FilePosition",
          "type": "data"
        },
        "index": {
          "hierarchy": "CSPM Parser Monad",
          "module": "CSPM.Parser.Monad",
          "name": "FilePosition",
          "package": "libcspm",
          "partial": "File Position",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Monad.html#t:FilePosition"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Monad",
          "name": "ParseMonad",
          "package": "libcspm",
          "source": "src/CSPM-Parser-Monad.html#ParseMonad",
          "type": "type"
        },
        "index": {
          "hierarchy": "CSPM Parser Monad",
          "module": "CSPM.Parser.Monad",
          "name": "ParseMonad",
          "package": "libcspm",
          "partial": "Parse Monad",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Monad.html#t:ParseMonad"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Monad",
          "name": "ParserState",
          "package": "libcspm",
          "source": "src/CSPM-Parser-Monad.html#ParserState",
          "type": "data"
        },
        "index": {
          "hierarchy": "CSPM Parser Monad",
          "module": "CSPM.Parser.Monad",
          "name": "ParserState",
          "package": "libcspm",
          "partial": "Parser State",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Monad.html#t:ParserState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Monad",
          "name": "FileParserState",
          "package": "libcspm",
          "signature": "FileParserState",
          "source": "src/CSPM-Parser-Monad.html#FileParserState",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Monad",
          "module": "CSPM.Parser.Monad",
          "name": "FileParserState",
          "package": "libcspm",
          "partial": "File Parser State",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Monad.html#v:FileParserState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Monad",
          "name": "FilePosition",
          "package": "libcspm",
          "signature": "FilePosition !Int !Int !Int",
          "source": "src/CSPM-Parser-Monad.html#FilePosition",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Monad",
          "module": "CSPM.Parser.Monad",
          "name": "FilePosition",
          "package": "libcspm",
          "partial": "File Position",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Monad.html#v:FilePosition"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Monad",
          "name": "ParserState",
          "package": "libcspm",
          "signature": "ParserState",
          "source": "src/CSPM-Parser-Monad.html#ParserState",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Monad",
          "module": "CSPM.Parser.Monad",
          "name": "ParserState",
          "package": "libcspm",
          "partial": "Parser State",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Monad.html#v:ParserState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Monad",
          "name": "currentStartCode",
          "package": "libcspm",
          "signature": "Int",
          "source": "src/CSPM-Parser-Monad.html#FileParserState",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Monad",
          "module": "CSPM.Parser.Monad",
          "name": "currentStartCode",
          "package": "libcspm",
          "partial": "Start Code",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Monad.html#v:currentStartCode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Monad",
          "name": "fileName",
          "package": "libcspm",
          "signature": "String",
          "source": "src/CSPM-Parser-Monad.html#FileParserState",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Monad",
          "module": "CSPM.Parser.Monad",
          "name": "fileName",
          "package": "libcspm",
          "partial": "Name",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Monad.html#v:fileName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Monad",
          "name": "filePositionToSrcLoc",
          "package": "libcspm",
          "signature": "String -\u003e FilePosition -\u003e SrcSpan",
          "source": "src/CSPM-Parser-Monad.html#filePositionToSrcLoc",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Monad",
          "module": "CSPM.Parser.Monad",
          "name": "filePositionToSrcLoc",
          "normalized": "String-\u003eFilePosition-\u003eSrcSpan",
          "package": "libcspm",
          "partial": "Position To Src Loc",
          "signature": "String-\u003eFilePosition-\u003eSrcSpan",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Monad.html#v:filePositionToSrcLoc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Monad",
          "name": "fileStack",
          "package": "libcspm",
          "signature": "[FileParserState]",
          "source": "src/CSPM-Parser-Monad.html#ParserState",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Monad",
          "module": "CSPM.Parser.Monad",
          "name": "fileStack",
          "normalized": "[FileParserState]",
          "package": "libcspm",
          "partial": "Stack",
          "signature": "[FileParserState]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Monad.html#v:fileStack"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Monad",
          "name": "getCurrentStartCode",
          "package": "libcspm",
          "signature": "ParseMonad Int",
          "source": "src/CSPM-Parser-Monad.html#getCurrentStartCode",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Monad",
          "module": "CSPM.Parser.Monad",
          "name": "getCurrentStartCode",
          "package": "libcspm",
          "partial": "Current Start Code",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Monad.html#v:getCurrentStartCode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Monad",
          "name": "getFileName",
          "package": "libcspm",
          "signature": "ParseMonad String",
          "source": "src/CSPM-Parser-Monad.html#getFileName",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Monad",
          "module": "CSPM.Parser.Monad",
          "name": "getFileName",
          "package": "libcspm",
          "partial": "File Name",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Monad.html#v:getFileName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Monad",
          "name": "getInput",
          "package": "libcspm",
          "signature": "ParseMonad String",
          "source": "src/CSPM-Parser-Monad.html#getInput",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Monad",
          "module": "CSPM.Parser.Monad",
          "name": "getInput",
          "package": "libcspm",
          "partial": "Input",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Monad.html#v:getInput"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Monad",
          "name": "getParserState",
          "package": "libcspm",
          "signature": "ParseMonad ParserState",
          "source": "src/CSPM-Parser-Monad.html#getParserState",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Monad",
          "module": "CSPM.Parser.Monad",
          "name": "getParserState",
          "package": "libcspm",
          "partial": "Parser State",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Monad.html#v:getParserState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Monad",
          "name": "getPreviousChar",
          "package": "libcspm",
          "signature": "ParseMonad Char",
          "source": "src/CSPM-Parser-Monad.html#getPreviousChar",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Monad",
          "module": "CSPM.Parser.Monad",
          "name": "getPreviousChar",
          "package": "libcspm",
          "partial": "Previous Char",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Monad.html#v:getPreviousChar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Monad",
          "name": "getSequenceStack",
          "package": "libcspm",
          "signature": "ParseMonad [Int]",
          "source": "src/CSPM-Parser-Monad.html#getSequenceStack",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Monad",
          "module": "CSPM.Parser.Monad",
          "name": "getSequenceStack",
          "normalized": "ParseMonad[Int]",
          "package": "libcspm",
          "partial": "Sequence Stack",
          "signature": "ParseMonad[Int]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Monad.html#v:getSequenceStack"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Monad",
          "name": "getTokenizerPos",
          "package": "libcspm",
          "signature": "ParseMonad FilePosition",
          "source": "src/CSPM-Parser-Monad.html#getTokenizerPos",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Monad",
          "module": "CSPM.Parser.Monad",
          "name": "getTokenizerPos",
          "package": "libcspm",
          "partial": "Tokenizer Pos",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Monad.html#v:getTokenizerPos"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Monad",
          "name": "getTopFileParserState",
          "package": "libcspm",
          "signature": "ParseMonad FileParserState",
          "source": "src/CSPM-Parser-Monad.html#getTopFileParserState",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Monad",
          "module": "CSPM.Parser.Monad",
          "name": "getTopFileParserState",
          "package": "libcspm",
          "partial": "Top File Parser State",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Monad.html#v:getTopFileParserState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Monad",
          "name": "input",
          "package": "libcspm",
          "signature": "String",
          "source": "src/CSPM-Parser-Monad.html#FileParserState",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Monad",
          "module": "CSPM.Parser.Monad",
          "name": "input",
          "package": "libcspm",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Monad.html#v:input"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Monad",
          "name": "modifyTopFileParserState",
          "package": "libcspm",
          "signature": "(FileParserState -\u003e FileParserState) -\u003e ParseMonad ()",
          "source": "src/CSPM-Parser-Monad.html#modifyTopFileParserState",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Monad",
          "module": "CSPM.Parser.Monad",
          "name": "modifyTopFileParserState",
          "normalized": "(FileParserState-\u003eFileParserState)-\u003eParseMonad()",
          "package": "libcspm",
          "partial": "Top File Parser State",
          "signature": "(FileParserState-\u003eFileParserState)-\u003eParseMonad()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Monad.html#v:modifyTopFileParserState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Monad",
          "name": "movePos",
          "package": "libcspm",
          "signature": "FilePosition -\u003e Char -\u003e FilePosition",
          "source": "src/CSPM-Parser-Monad.html#movePos",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Monad",
          "module": "CSPM.Parser.Monad",
          "name": "movePos",
          "normalized": "FilePosition-\u003eChar-\u003eFilePosition",
          "package": "libcspm",
          "partial": "Pos",
          "signature": "FilePosition-\u003eChar-\u003eFilePosition",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Monad.html#v:movePos"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Monad",
          "name": "previousChar",
          "package": "libcspm",
          "signature": "Char",
          "source": "src/CSPM-Parser-Monad.html#FileParserState",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Monad",
          "module": "CSPM.Parser.Monad",
          "name": "previousChar",
          "package": "libcspm",
          "partial": "Char",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Monad.html#v:previousChar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Monad",
          "name": "pushFile",
          "package": "libcspm",
          "signature": "String -\u003e ParseMonad a -\u003e ParseMonad a",
          "source": "src/CSPM-Parser-Monad.html#pushFile",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Monad",
          "module": "CSPM.Parser.Monad",
          "name": "pushFile",
          "normalized": "String-\u003eParseMonad a-\u003eParseMonad a",
          "package": "libcspm",
          "partial": "File",
          "signature": "String-\u003eParseMonad a-\u003eParseMonad a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Monad.html#v:pushFile"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Monad",
          "name": "pushFileContents",
          "package": "libcspm",
          "signature": "String -\u003e String -\u003e ParseMonad ()",
          "source": "src/CSPM-Parser-Monad.html#pushFileContents",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Monad",
          "module": "CSPM.Parser.Monad",
          "name": "pushFileContents",
          "normalized": "String-\u003eString-\u003eParseMonad()",
          "package": "libcspm",
          "partial": "File Contents",
          "signature": "String-\u003eString-\u003eParseMonad()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Monad.html#v:pushFileContents"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Monad",
          "name": "rootDir",
          "package": "libcspm",
          "signature": "String",
          "source": "src/CSPM-Parser-Monad.html#ParserState",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Monad",
          "module": "CSPM.Parser.Monad",
          "name": "rootDir",
          "package": "libcspm",
          "partial": "Dir",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Monad.html#v:rootDir"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"CSPM.Parser.Monad\",\"CSPM.Parser\"]",
          "name": "runParser",
          "package": "libcspm",
          "signature": "ParseMonad a -\u003e String -\u003e IO a",
          "source": "src/CSPM-Parser-Monad.html#runParser",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Monad.html#v:runParser\",\"http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser.html#v:runParser\"]"
        },
        "index": {
          "hierarchy": "CSPM Parser Monad",
          "module": "CSPM.Parser.Monad",
          "name": "runParser",
          "normalized": "ParseMonad a-\u003eString-\u003eIO a",
          "package": "libcspm",
          "partial": "Parser",
          "signature": "ParseMonad a-\u003eString-\u003eIO a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Monad.html#v:runParser"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Monad",
          "name": "sequenceStack",
          "package": "libcspm",
          "signature": "[Int]",
          "source": "src/CSPM-Parser-Monad.html#FileParserState",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Monad",
          "module": "CSPM.Parser.Monad",
          "name": "sequenceStack",
          "normalized": "[Int]",
          "package": "libcspm",
          "partial": "Stack",
          "signature": "[Int]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Monad.html#v:sequenceStack"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Monad",
          "name": "setCurrentStartCode",
          "package": "libcspm",
          "signature": "Int -\u003e ParseMonad ()",
          "source": "src/CSPM-Parser-Monad.html#setCurrentStartCode",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Monad",
          "module": "CSPM.Parser.Monad",
          "name": "setCurrentStartCode",
          "normalized": "Int-\u003eParseMonad()",
          "package": "libcspm",
          "partial": "Current Start Code",
          "signature": "Int-\u003eParseMonad()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Monad.html#v:setCurrentStartCode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Monad",
          "name": "setParserState",
          "package": "libcspm",
          "signature": "ParserState -\u003e ParseMonad ()",
          "source": "src/CSPM-Parser-Monad.html#setParserState",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Monad",
          "module": "CSPM.Parser.Monad",
          "name": "setParserState",
          "normalized": "ParserState-\u003eParseMonad()",
          "package": "libcspm",
          "partial": "Parser State",
          "signature": "ParserState-\u003eParseMonad()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Monad.html#v:setParserState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Monad",
          "name": "setSequenceStack",
          "package": "libcspm",
          "signature": "[Int] -\u003e ParseMonad ()",
          "source": "src/CSPM-Parser-Monad.html#setSequenceStack",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Monad",
          "module": "CSPM.Parser.Monad",
          "name": "setSequenceStack",
          "normalized": "[Int]-\u003eParseMonad()",
          "package": "libcspm",
          "partial": "Sequence Stack",
          "signature": "[Int]-\u003eParseMonad()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Monad.html#v:setSequenceStack"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Monad",
          "name": "tokenizerPos",
          "package": "libcspm",
          "signature": "FilePosition",
          "source": "src/CSPM-Parser-Monad.html#FileParserState",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Monad",
          "module": "CSPM.Parser.Monad",
          "name": "tokenizerPos",
          "package": "libcspm",
          "partial": "Pos",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Monad.html#v:tokenizerPos"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Parser",
          "name": "Parser",
          "package": "libcspm",
          "source": "src/CSPM-Parser-Parser.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "CSPM Parser Parser",
          "module": "CSPM.Parser.Parser",
          "name": "Parser",
          "package": "libcspm",
          "partial": "Parser",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Parser.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Parser",
          "name": "parseExpression_",
          "package": "libcspm",
          "signature": "ParseMonad PExp",
          "source": "src/CSPM-Parser-Parser.html#parseExpression_",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Parser",
          "module": "CSPM.Parser.Parser",
          "name": "parseExpression_",
          "package": "libcspm",
          "partial": "Expression",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Parser.html#v:parseExpression_"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Parser",
          "name": "parseFile_",
          "package": "libcspm",
          "signature": "ParseMonad PCSPMFile",
          "source": "src/CSPM-Parser-Parser.html#parseFile_",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Parser",
          "module": "CSPM.Parser.Parser",
          "name": "parseFile_",
          "package": "libcspm",
          "partial": "File",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Parser.html#v:parseFile_"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Parser",
          "name": "parseInteractiveStmt_",
          "package": "libcspm",
          "signature": "ParseMonad PInteractiveStmt",
          "source": "src/CSPM-Parser-Parser.html#parseInteractiveStmt_",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Parser",
          "module": "CSPM.Parser.Parser",
          "name": "parseInteractiveStmt_",
          "package": "libcspm",
          "partial": "Interactive Stmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Parser.html#v:parseInteractiveStmt_"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Tokens",
          "name": "Tokens",
          "package": "libcspm",
          "source": "src/CSPM-Parser-Tokens.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "CSPM Parser Tokens",
          "module": "CSPM.Parser.Tokens",
          "name": "Tokens",
          "package": "libcspm",
          "partial": "Tokens",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Tokens.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Tokens",
          "name": "LToken",
          "package": "libcspm",
          "source": "src/CSPM-Parser-Tokens.html#LToken",
          "type": "type"
        },
        "index": {
          "hierarchy": "CSPM Parser Tokens",
          "module": "CSPM.Parser.Tokens",
          "name": "LToken",
          "package": "libcspm",
          "partial": "LToken",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Tokens.html#t:LToken"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Tokens",
          "name": "Model",
          "package": "libcspm",
          "source": "src/CSPM-DataStructures-Syntax.html#Model",
          "type": "data"
        },
        "index": {
          "hierarchy": "CSPM Parser Tokens",
          "module": "CSPM.Parser.Tokens",
          "name": "Model",
          "package": "libcspm",
          "partial": "Model",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Tokens.html#t:Model"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Tokens",
          "name": "Token",
          "package": "libcspm",
          "source": "src/CSPM-Parser-Tokens.html#Token",
          "type": "data"
        },
        "index": {
          "hierarchy": "CSPM Parser Tokens",
          "module": "CSPM.Parser.Tokens",
          "name": "Token",
          "package": "libcspm",
          "partial": "Token",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Tokens.html#t:Token"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Tokens",
          "name": "TAnd",
          "package": "libcspm",
          "signature": "TAnd",
          "source": "src/CSPM-Parser-Tokens.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Tokens",
          "module": "CSPM.Parser.Tokens",
          "name": "TAnd",
          "package": "libcspm",
          "partial": "TAnd",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Tokens.html#v:TAnd"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Tokens",
          "name": "TAssert",
          "package": "libcspm",
          "signature": "TAssert",
          "source": "src/CSPM-Parser-Tokens.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Tokens",
          "module": "CSPM.Parser.Tokens",
          "name": "TAssert",
          "package": "libcspm",
          "partial": "TAssert",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Tokens.html#v:TAssert"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Tokens",
          "name": "TAssertNot",
          "package": "libcspm",
          "signature": "TAssertNot",
          "source": "src/CSPM-Parser-Tokens.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Tokens",
          "module": "CSPM.Parser.Tokens",
          "name": "TAssertNot",
          "package": "libcspm",
          "partial": "TAssert Not",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Tokens.html#v:TAssertNot"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Tokens",
          "name": "TBackSlash",
          "package": "libcspm",
          "signature": "TBackSlash",
          "source": "src/CSPM-Parser-Tokens.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Tokens",
          "module": "CSPM.Parser.Tokens",
          "name": "TBackSlash",
          "package": "libcspm",
          "partial": "TBack Slash",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Tokens.html#v:TBackSlash"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Tokens",
          "name": "TChannel",
          "package": "libcspm",
          "signature": "TChannel",
          "source": "src/CSPM-Parser-Tokens.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Tokens",
          "module": "CSPM.Parser.Tokens",
          "name": "TChannel",
          "package": "libcspm",
          "partial": "TChannel",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Tokens.html#v:TChannel"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Tokens",
          "name": "TChar",
          "package": "libcspm",
          "signature": "TChar Char",
          "source": "src/CSPM-Parser-Tokens.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Tokens",
          "module": "CSPM.Parser.Tokens",
          "name": "TChar",
          "package": "libcspm",
          "partial": "TChar",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Tokens.html#v:TChar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Tokens",
          "name": "TCloseSeq",
          "package": "libcspm",
          "signature": "TCloseSeq",
          "source": "src/CSPM-Parser-Tokens.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Tokens",
          "module": "CSPM.Parser.Tokens",
          "name": "TCloseSeq",
          "package": "libcspm",
          "partial": "TClose Seq",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Tokens.html#v:TCloseSeq"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Tokens",
          "name": "TColon",
          "package": "libcspm",
          "signature": "TColon",
          "source": "src/CSPM-Parser-Tokens.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Tokens",
          "module": "CSPM.Parser.Tokens",
          "name": "TColon",
          "package": "libcspm",
          "partial": "TColon",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Tokens.html#v:TColon"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Tokens",
          "name": "TComma",
          "package": "libcspm",
          "signature": "TComma",
          "source": "src/CSPM-Parser-Tokens.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Tokens",
          "module": "CSPM.Parser.Tokens",
          "name": "TComma",
          "package": "libcspm",
          "partial": "TComma",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Tokens.html#v:TComma"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Tokens",
          "name": "TConcat",
          "package": "libcspm",
          "signature": "TConcat",
          "source": "src/CSPM-Parser-Tokens.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Tokens",
          "module": "CSPM.Parser.Tokens",
          "name": "TConcat",
          "package": "libcspm",
          "partial": "TConcat",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Tokens.html#v:TConcat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Tokens",
          "name": "TDataType",
          "package": "libcspm",
          "signature": "TDataType",
          "source": "src/CSPM-Parser-Tokens.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Tokens",
          "module": "CSPM.Parser.Tokens",
          "name": "TDataType",
          "package": "libcspm",
          "partial": "TData Type",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Tokens.html#v:TDataType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Tokens",
          "name": "TDeadlockFree",
          "package": "libcspm",
          "signature": "TDeadlockFree",
          "source": "src/CSPM-Parser-Tokens.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Tokens",
          "module": "CSPM.Parser.Tokens",
          "name": "TDeadlockFree",
          "package": "libcspm",
          "partial": "TDeadlock Free",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Tokens.html#v:TDeadlockFree"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Tokens",
          "name": "TDefineEqual",
          "package": "libcspm",
          "signature": "TDefineEqual",
          "source": "src/CSPM-Parser-Tokens.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Tokens",
          "module": "CSPM.Parser.Tokens",
          "name": "TDefineEqual",
          "package": "libcspm",
          "partial": "TDefine Equal",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Tokens.html#v:TDefineEqual"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Tokens",
          "name": "TDeterministic",
          "package": "libcspm",
          "signature": "TDeterministic",
          "source": "src/CSPM-Parser-Tokens.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Tokens",
          "module": "CSPM.Parser.Tokens",
          "name": "TDeterministic",
          "package": "libcspm",
          "partial": "TDeterministic",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Tokens.html#v:TDeterministic"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Tokens",
          "name": "TDivergenceFree",
          "package": "libcspm",
          "signature": "TDivergenceFree",
          "source": "src/CSPM-Parser-Tokens.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Tokens",
          "module": "CSPM.Parser.Tokens",
          "name": "TDivergenceFree",
          "package": "libcspm",
          "partial": "TDivergence Free",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Tokens.html#v:TDivergenceFree"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Tokens",
          "name": "TDivide",
          "package": "libcspm",
          "signature": "TDivide",
          "source": "src/CSPM-Parser-Tokens.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Tokens",
          "module": "CSPM.Parser.Tokens",
          "name": "TDivide",
          "package": "libcspm",
          "partial": "TDivide",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Tokens.html#v:TDivide"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Tokens",
          "name": "TDollar",
          "package": "libcspm",
          "signature": "TDollar",
          "source": "src/CSPM-Parser-Tokens.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Tokens",
          "module": "CSPM.Parser.Tokens",
          "name": "TDollar",
          "package": "libcspm",
          "partial": "TDollar",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Tokens.html#v:TDollar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Tokens",
          "name": "TDot",
          "package": "libcspm",
          "signature": "TDot",
          "source": "src/CSPM-Parser-Tokens.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Tokens",
          "module": "CSPM.Parser.Tokens",
          "name": "TDot",
          "package": "libcspm",
          "partial": "TDot",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Tokens.html#v:TDot"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Tokens",
          "name": "TDoubleAt",
          "package": "libcspm",
          "signature": "TDoubleAt",
          "source": "src/CSPM-Parser-Tokens.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Tokens",
          "module": "CSPM.Parser.Tokens",
          "name": "TDoubleAt",
          "package": "libcspm",
          "partial": "TDouble At",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Tokens.html#v:TDoubleAt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Tokens",
          "name": "TDoubleDot",
          "package": "libcspm",
          "signature": "TDoubleDot",
          "source": "src/CSPM-Parser-Tokens.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Tokens",
          "module": "CSPM.Parser.Tokens",
          "name": "TDoubleDot",
          "package": "libcspm",
          "partial": "TDouble Dot",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Tokens.html#v:TDoubleDot"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Tokens",
          "name": "TDrawnFrom",
          "package": "libcspm",
          "signature": "TDrawnFrom",
          "source": "src/CSPM-Parser-Tokens.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Tokens",
          "module": "CSPM.Parser.Tokens",
          "name": "TDrawnFrom",
          "package": "libcspm",
          "partial": "TDrawn From",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Tokens.html#v:TDrawnFrom"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Tokens",
          "name": "TEOF",
          "package": "libcspm",
          "signature": "TEOF",
          "source": "src/CSPM-Parser-Tokens.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Tokens",
          "module": "CSPM.Parser.Tokens",
          "name": "TEOF",
          "package": "libcspm",
          "partial": "TEOF",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Tokens.html#v:TEOF"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Tokens",
          "name": "TElse",
          "package": "libcspm",
          "signature": "TElse",
          "source": "src/CSPM-Parser-Tokens.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Tokens",
          "module": "CSPM.Parser.Tokens",
          "name": "TElse",
          "package": "libcspm",
          "partial": "TElse",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Tokens.html#v:TElse"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Tokens",
          "name": "TEmptySeq",
          "package": "libcspm",
          "signature": "TEmptySeq",
          "source": "src/CSPM-Parser-Tokens.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Tokens",
          "module": "CSPM.Parser.Tokens",
          "name": "TEmptySeq",
          "package": "libcspm",
          "partial": "TEmpty Seq",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Tokens.html#v:TEmptySeq"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Tokens",
          "name": "TEndModule",
          "package": "libcspm",
          "signature": "TEndModule",
          "source": "src/CSPM-Parser-Tokens.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Tokens",
          "module": "CSPM.Parser.Tokens",
          "name": "TEndModule",
          "package": "libcspm",
          "partial": "TEnd Module",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Tokens.html#v:TEndModule"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Tokens",
          "name": "TEq",
          "package": "libcspm",
          "signature": "TEq",
          "source": "src/CSPM-Parser-Tokens.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Tokens",
          "module": "CSPM.Parser.Tokens",
          "name": "TEq",
          "package": "libcspm",
          "partial": "TEq",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Tokens.html#v:TEq"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Tokens",
          "name": "TExclamationMark",
          "package": "libcspm",
          "signature": "TExclamationMark",
          "source": "src/CSPM-Parser-Tokens.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Tokens",
          "module": "CSPM.Parser.Tokens",
          "name": "TExclamationMark",
          "package": "libcspm",
          "partial": "TExclamation Mark",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Tokens.html#v:TExclamationMark"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Tokens",
          "name": "TExports",
          "package": "libcspm",
          "signature": "TExports",
          "source": "src/CSPM-Parser-Tokens.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Tokens",
          "module": "CSPM.Parser.Tokens",
          "name": "TExports",
          "package": "libcspm",
          "partial": "TExports",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Tokens.html#v:TExports"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Tokens",
          "name": "TExtChoice",
          "package": "libcspm",
          "signature": "TExtChoice",
          "source": "src/CSPM-Parser-Tokens.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Tokens",
          "module": "CSPM.Parser.Tokens",
          "name": "TExtChoice",
          "package": "libcspm",
          "partial": "TExt Choice",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Tokens.html#v:TExtChoice"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Tokens",
          "name": "TExternal",
          "package": "libcspm",
          "signature": "TExternal",
          "source": "src/CSPM-Parser-Tokens.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Tokens",
          "module": "CSPM.Parser.Tokens",
          "name": "TExternal",
          "package": "libcspm",
          "partial": "TExternal",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Tokens.html#v:TExternal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Tokens",
          "name": "TFalse",
          "package": "libcspm",
          "signature": "TFalse",
          "source": "src/CSPM-Parser-Tokens.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Tokens",
          "module": "CSPM.Parser.Tokens",
          "name": "TFalse",
          "package": "libcspm",
          "partial": "TFalse",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Tokens.html#v:TFalse"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Tokens",
          "name": "TGt",
          "package": "libcspm",
          "signature": "TGt",
          "source": "src/CSPM-Parser-Tokens.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Tokens",
          "module": "CSPM.Parser.Tokens",
          "name": "TGt",
          "package": "libcspm",
          "partial": "TGt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Tokens.html#v:TGt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Tokens",
          "name": "TGtEq",
          "package": "libcspm",
          "signature": "TGtEq",
          "source": "src/CSPM-Parser-Tokens.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Tokens",
          "module": "CSPM.Parser.Tokens",
          "name": "TGtEq",
          "package": "libcspm",
          "partial": "TGt Eq",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Tokens.html#v:TGtEq"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Tokens",
          "name": "TGuard",
          "package": "libcspm",
          "signature": "TGuard",
          "source": "src/CSPM-Parser-Tokens.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Tokens",
          "module": "CSPM.Parser.Tokens",
          "name": "TGuard",
          "package": "libcspm",
          "partial": "TGuard",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Tokens.html#v:TGuard"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Tokens",
          "name": "THash",
          "package": "libcspm",
          "signature": "THash",
          "source": "src/CSPM-Parser-Tokens.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Tokens",
          "module": "CSPM.Parser.Tokens",
          "name": "THash",
          "package": "libcspm",
          "partial": "THash",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Tokens.html#v:THash"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Tokens",
          "name": "TIdent",
          "package": "libcspm",
          "signature": "TIdent String",
          "source": "src/CSPM-Parser-Tokens.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Tokens",
          "module": "CSPM.Parser.Tokens",
          "name": "TIdent",
          "package": "libcspm",
          "partial": "TIdent",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Tokens.html#v:TIdent"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Tokens",
          "name": "TIf",
          "package": "libcspm",
          "signature": "TIf",
          "source": "src/CSPM-Parser-Tokens.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Tokens",
          "module": "CSPM.Parser.Tokens",
          "name": "TIf",
          "package": "libcspm",
          "partial": "TIf",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Tokens.html#v:TIf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Tokens",
          "name": "TInstance",
          "package": "libcspm",
          "signature": "TInstance",
          "source": "src/CSPM-Parser-Tokens.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Tokens",
          "module": "CSPM.Parser.Tokens",
          "name": "TInstance",
          "package": "libcspm",
          "partial": "TInstance",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Tokens.html#v:TInstance"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Tokens",
          "name": "TIntChoice",
          "package": "libcspm",
          "signature": "TIntChoice",
          "source": "src/CSPM-Parser-Tokens.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Tokens",
          "module": "CSPM.Parser.Tokens",
          "name": "TIntChoice",
          "package": "libcspm",
          "partial": "TInt Choice",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Tokens.html#v:TIntChoice"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Tokens",
          "name": "TInteger",
          "package": "libcspm",
          "signature": "TInteger Int",
          "source": "src/CSPM-Parser-Tokens.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Tokens",
          "module": "CSPM.Parser.Tokens",
          "name": "TInteger",
          "package": "libcspm",
          "partial": "TInteger",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Tokens.html#v:TInteger"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Tokens",
          "name": "TInterleave",
          "package": "libcspm",
          "signature": "TInterleave",
          "source": "src/CSPM-Parser-Tokens.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Tokens",
          "module": "CSPM.Parser.Tokens",
          "name": "TInterleave",
          "package": "libcspm",
          "partial": "TInterleave",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Tokens.html#v:TInterleave"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Tokens",
          "name": "TInterrupt",
          "package": "libcspm",
          "signature": "TInterrupt",
          "source": "src/CSPM-Parser-Tokens.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Tokens",
          "module": "CSPM.Parser.Tokens",
          "name": "TInterrupt",
          "package": "libcspm",
          "partial": "TInterrupt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Tokens.html#v:TInterrupt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Tokens",
          "name": "TLBrace",
          "package": "libcspm",
          "signature": "TLBrace",
          "source": "src/CSPM-Parser-Tokens.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Tokens",
          "module": "CSPM.Parser.Tokens",
          "name": "TLBrace",
          "package": "libcspm",
          "partial": "TLBrace",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Tokens.html#v:TLBrace"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Tokens",
          "name": "TLDoubleSqBracket",
          "package": "libcspm",
          "signature": "TLDoubleSqBracket",
          "source": "src/CSPM-Parser-Tokens.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Tokens",
          "module": "CSPM.Parser.Tokens",
          "name": "TLDoubleSqBracket",
          "package": "libcspm",
          "partial": "TLDouble Sq Bracket",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Tokens.html#v:TLDoubleSqBracket"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Tokens",
          "name": "TLMap",
          "package": "libcspm",
          "signature": "TLMap",
          "source": "src/CSPM-Parser-Tokens.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Tokens",
          "module": "CSPM.Parser.Tokens",
          "name": "TLMap",
          "package": "libcspm",
          "partial": "TLMap",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Tokens.html#v:TLMap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Tokens",
          "name": "TLParen",
          "package": "libcspm",
          "signature": "TLParen",
          "source": "src/CSPM-Parser-Tokens.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Tokens",
          "module": "CSPM.Parser.Tokens",
          "name": "TLParen",
          "package": "libcspm",
          "partial": "TLParen",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Tokens.html#v:TLParen"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Tokens",
          "name": "TLPipeBrace",
          "package": "libcspm",
          "signature": "TLPipeBrace",
          "source": "src/CSPM-Parser-Tokens.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Tokens",
          "module": "CSPM.Parser.Tokens",
          "name": "TLPipeBrace",
          "package": "libcspm",
          "partial": "TLPipe Brace",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Tokens.html#v:TLPipeBrace"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Tokens",
          "name": "TLPipeSqBracket",
          "package": "libcspm",
          "signature": "TLPipeSqBracket",
          "source": "src/CSPM-Parser-Tokens.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Tokens",
          "module": "CSPM.Parser.Tokens",
          "name": "TLPipeSqBracket",
          "package": "libcspm",
          "partial": "TLPipe Sq Bracket",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Tokens.html#v:TLPipeSqBracket"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Tokens",
          "name": "TLSqBracket",
          "package": "libcspm",
          "signature": "TLSqBracket",
          "source": "src/CSPM-Parser-Tokens.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Tokens",
          "module": "CSPM.Parser.Tokens",
          "name": "TLSqBracket",
          "package": "libcspm",
          "partial": "TLSq Bracket",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Tokens.html#v:TLSqBracket"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Tokens",
          "name": "TLSyncExtChoice",
          "package": "libcspm",
          "signature": "TLSyncExtChoice",
          "source": "src/CSPM-Parser-Tokens.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Tokens",
          "module": "CSPM.Parser.Tokens",
          "name": "TLSyncExtChoice",
          "package": "libcspm",
          "partial": "TLSync Ext Choice",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Tokens.html#v:TLSyncExtChoice"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Tokens",
          "name": "TLSyncInterrupt",
          "package": "libcspm",
          "signature": "TLSyncInterrupt",
          "source": "src/CSPM-Parser-Tokens.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Tokens",
          "module": "CSPM.Parser.Tokens",
          "name": "TLSyncInterrupt",
          "package": "libcspm",
          "partial": "TLSync Interrupt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Tokens.html#v:TLSyncInterrupt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Tokens",
          "name": "TLambdaDot",
          "package": "libcspm",
          "signature": "TLambdaDot",
          "source": "src/CSPM-Parser-Tokens.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Tokens",
          "module": "CSPM.Parser.Tokens",
          "name": "TLambdaDot",
          "package": "libcspm",
          "partial": "TLambda Dot",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Tokens.html#v:TLambdaDot"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Tokens",
          "name": "TLet",
          "package": "libcspm",
          "signature": "TLet",
          "source": "src/CSPM-Parser-Tokens.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Tokens",
          "module": "CSPM.Parser.Tokens",
          "name": "TLet",
          "package": "libcspm",
          "partial": "TLet",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Tokens.html#v:TLet"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Tokens",
          "name": "TLivelockFree",
          "package": "libcspm",
          "signature": "TLivelockFree",
          "source": "src/CSPM-Parser-Tokens.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Tokens",
          "module": "CSPM.Parser.Tokens",
          "name": "TLivelockFree",
          "package": "libcspm",
          "partial": "TLivelock Free",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Tokens.html#v:TLivelockFree"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Tokens",
          "name": "TLt",
          "package": "libcspm",
          "signature": "TLt",
          "source": "src/CSPM-Parser-Tokens.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Tokens",
          "module": "CSPM.Parser.Tokens",
          "name": "TLt",
          "package": "libcspm",
          "partial": "TLt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Tokens.html#v:TLt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Tokens",
          "name": "TLtEq",
          "package": "libcspm",
          "signature": "TLtEq",
          "source": "src/CSPM-Parser-Tokens.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Tokens",
          "module": "CSPM.Parser.Tokens",
          "name": "TLtEq",
          "package": "libcspm",
          "partial": "TLt Eq",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Tokens.html#v:TLtEq"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Tokens",
          "name": "TMinus",
          "package": "libcspm",
          "signature": "TMinus",
          "source": "src/CSPM-Parser-Tokens.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Tokens",
          "module": "CSPM.Parser.Tokens",
          "name": "TMinus",
          "package": "libcspm",
          "partial": "TMinus",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Tokens.html#v:TMinus"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Tokens",
          "name": "TMod",
          "package": "libcspm",
          "signature": "TMod",
          "source": "src/CSPM-Parser-Tokens.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Tokens",
          "module": "CSPM.Parser.Tokens",
          "name": "TMod",
          "package": "libcspm",
          "partial": "TMod",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Tokens.html#v:TMod"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Tokens",
          "name": "TModel",
          "package": "libcspm",
          "signature": "TModel Model",
          "source": "src/CSPM-Parser-Tokens.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Tokens",
          "module": "CSPM.Parser.Tokens",
          "name": "TModel",
          "package": "libcspm",
          "partial": "TModel",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Tokens.html#v:TModel"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Tokens",
          "name": "TModule",
          "package": "libcspm",
          "signature": "TModule",
          "source": "src/CSPM-Parser-Tokens.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Tokens",
          "module": "CSPM.Parser.Tokens",
          "name": "TModule",
          "package": "libcspm",
          "partial": "TModule",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Tokens.html#v:TModule"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Tokens",
          "name": "TNameType",
          "package": "libcspm",
          "signature": "TNameType",
          "source": "src/CSPM-Parser-Tokens.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Tokens",
          "module": "CSPM.Parser.Tokens",
          "name": "TNameType",
          "package": "libcspm",
          "partial": "TName Type",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Tokens.html#v:TNameType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Tokens",
          "name": "TNewLine",
          "package": "libcspm",
          "signature": "TNewLine",
          "source": "src/CSPM-Parser-Tokens.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Tokens",
          "module": "CSPM.Parser.Tokens",
          "name": "TNewLine",
          "package": "libcspm",
          "partial": "TNew Line",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Tokens.html#v:TNewLine"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Tokens",
          "name": "TNot",
          "package": "libcspm",
          "signature": "TNot",
          "source": "src/CSPM-Parser-Tokens.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Tokens",
          "module": "CSPM.Parser.Tokens",
          "name": "TNot",
          "package": "libcspm",
          "partial": "TNot",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Tokens.html#v:TNot"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Tokens",
          "name": "TNotEq",
          "package": "libcspm",
          "signature": "TNotEq",
          "source": "src/CSPM-Parser-Tokens.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Tokens",
          "module": "CSPM.Parser.Tokens",
          "name": "TNotEq",
          "package": "libcspm",
          "partial": "TNot Eq",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Tokens.html#v:TNotEq"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Tokens",
          "name": "TOfType",
          "package": "libcspm",
          "signature": "TOfType",
          "source": "src/CSPM-Parser-Tokens.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Tokens",
          "module": "CSPM.Parser.Tokens",
          "name": "TOfType",
          "package": "libcspm",
          "partial": "TOf Type",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Tokens.html#v:TOfType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Tokens",
          "name": "TOr",
          "package": "libcspm",
          "signature": "TOr",
          "source": "src/CSPM-Parser-Tokens.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Tokens",
          "module": "CSPM.Parser.Tokens",
          "name": "TOr",
          "package": "libcspm",
          "partial": "TOr",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Tokens.html#v:TOr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Tokens",
          "name": "TParallel",
          "package": "libcspm",
          "signature": "TParallel",
          "source": "src/CSPM-Parser-Tokens.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Tokens",
          "module": "CSPM.Parser.Tokens",
          "name": "TParallel",
          "package": "libcspm",
          "partial": "TParallel",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Tokens.html#v:TParallel"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Tokens",
          "name": "TPipe",
          "package": "libcspm",
          "signature": "TPipe",
          "source": "src/CSPM-Parser-Tokens.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Tokens",
          "module": "CSPM.Parser.Tokens",
          "name": "TPipe",
          "package": "libcspm",
          "partial": "TPipe",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Tokens.html#v:TPipe"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Tokens",
          "name": "TPlus",
          "package": "libcspm",
          "signature": "TPlus",
          "source": "src/CSPM-Parser-Tokens.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Tokens",
          "module": "CSPM.Parser.Tokens",
          "name": "TPlus",
          "package": "libcspm",
          "partial": "TPlus",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Tokens.html#v:TPlus"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Tokens",
          "name": "TPrefix",
          "package": "libcspm",
          "signature": "TPrefix",
          "source": "src/CSPM-Parser-Tokens.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Tokens",
          "module": "CSPM.Parser.Tokens",
          "name": "TPrefix",
          "package": "libcspm",
          "partial": "TPrefix",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Tokens.html#v:TPrefix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Tokens",
          "name": "TPrint",
          "package": "libcspm",
          "signature": "TPrint String",
          "source": "src/CSPM-Parser-Tokens.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Tokens",
          "module": "CSPM.Parser.Tokens",
          "name": "TPrint",
          "package": "libcspm",
          "partial": "TPrint",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Tokens.html#v:TPrint"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Tokens",
          "name": "TQuestionMark",
          "package": "libcspm",
          "signature": "TQuestionMark",
          "source": "src/CSPM-Parser-Tokens.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Tokens",
          "module": "CSPM.Parser.Tokens",
          "name": "TQuestionMark",
          "package": "libcspm",
          "partial": "TQuestion Mark",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Tokens.html#v:TQuestionMark"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Tokens",
          "name": "TRBrace",
          "package": "libcspm",
          "signature": "TRBrace",
          "source": "src/CSPM-Parser-Tokens.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Tokens",
          "module": "CSPM.Parser.Tokens",
          "name": "TRBrace",
          "package": "libcspm",
          "partial": "TRBrace",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Tokens.html#v:TRBrace"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Tokens",
          "name": "TRDoubleSqBracket",
          "package": "libcspm",
          "signature": "TRDoubleSqBracket",
          "source": "src/CSPM-Parser-Tokens.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Tokens",
          "module": "CSPM.Parser.Tokens",
          "name": "TRDoubleSqBracket",
          "package": "libcspm",
          "partial": "TRDouble Sq Bracket",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Tokens.html#v:TRDoubleSqBracket"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Tokens",
          "name": "TRException",
          "package": "libcspm",
          "signature": "TRException",
          "source": "src/CSPM-Parser-Tokens.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Tokens",
          "module": "CSPM.Parser.Tokens",
          "name": "TRException",
          "package": "libcspm",
          "partial": "TRException",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Tokens.html#v:TRException"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Tokens",
          "name": "TRMap",
          "package": "libcspm",
          "signature": "TRMap",
          "source": "src/CSPM-Parser-Tokens.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Tokens",
          "module": "CSPM.Parser.Tokens",
          "name": "TRMap",
          "package": "libcspm",
          "partial": "TRMap",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Tokens.html#v:TRMap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Tokens",
          "name": "TRParen",
          "package": "libcspm",
          "signature": "TRParen",
          "source": "src/CSPM-Parser-Tokens.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Tokens",
          "module": "CSPM.Parser.Tokens",
          "name": "TRParen",
          "package": "libcspm",
          "partial": "TRParen",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Tokens.html#v:TRParen"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Tokens",
          "name": "TRPipeBrace",
          "package": "libcspm",
          "signature": "TRPipeBrace",
          "source": "src/CSPM-Parser-Tokens.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Tokens",
          "module": "CSPM.Parser.Tokens",
          "name": "TRPipeBrace",
          "package": "libcspm",
          "partial": "TRPipe Brace",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Tokens.html#v:TRPipeBrace"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Tokens",
          "name": "TRPipeSqBracket",
          "package": "libcspm",
          "signature": "TRPipeSqBracket",
          "source": "src/CSPM-Parser-Tokens.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Tokens",
          "module": "CSPM.Parser.Tokens",
          "name": "TRPipeSqBracket",
          "package": "libcspm",
          "partial": "TRPipe Sq Bracket",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Tokens.html#v:TRPipeSqBracket"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Tokens",
          "name": "TRSqBracket",
          "package": "libcspm",
          "signature": "TRSqBracket",
          "source": "src/CSPM-Parser-Tokens.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Tokens",
          "module": "CSPM.Parser.Tokens",
          "name": "TRSqBracket",
          "package": "libcspm",
          "partial": "TRSq Bracket",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Tokens.html#v:TRSqBracket"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Tokens",
          "name": "TRSyncExtChoice",
          "package": "libcspm",
          "signature": "TRSyncExtChoice",
          "source": "src/CSPM-Parser-Tokens.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Tokens",
          "module": "CSPM.Parser.Tokens",
          "name": "TRSyncExtChoice",
          "package": "libcspm",
          "partial": "TRSync Ext Choice",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Tokens.html#v:TRSyncExtChoice"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Tokens",
          "name": "TRSyncInterrupt",
          "package": "libcspm",
          "signature": "TRSyncInterrupt",
          "source": "src/CSPM-Parser-Tokens.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Tokens",
          "module": "CSPM.Parser.Tokens",
          "name": "TRSyncInterrupt",
          "package": "libcspm",
          "partial": "TRSync Interrupt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Tokens.html#v:TRSyncInterrupt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Tokens",
          "name": "TRefines",
          "package": "libcspm",
          "signature": "TRefines Model",
          "source": "src/CSPM-Parser-Tokens.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Tokens",
          "module": "CSPM.Parser.Tokens",
          "name": "TRefines",
          "package": "libcspm",
          "partial": "TRefines",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Tokens.html#v:TRefines"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Tokens",
          "name": "TScope",
          "package": "libcspm",
          "signature": "TScope",
          "source": "src/CSPM-Parser-Tokens.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Tokens",
          "module": "CSPM.Parser.Tokens",
          "name": "TScope",
          "package": "libcspm",
          "partial": "TScope",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Tokens.html#v:TScope"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Tokens",
          "name": "TSemiColon",
          "package": "libcspm",
          "signature": "TSemiColon",
          "source": "src/CSPM-Parser-Tokens.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Tokens",
          "module": "CSPM.Parser.Tokens",
          "name": "TSemiColon",
          "package": "libcspm",
          "partial": "TSemi Colon",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Tokens.html#v:TSemiColon"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Tokens",
          "name": "TSlidingChoice",
          "package": "libcspm",
          "signature": "TSlidingChoice",
          "source": "src/CSPM-Parser-Tokens.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Tokens",
          "module": "CSPM.Parser.Tokens",
          "name": "TSlidingChoice",
          "package": "libcspm",
          "partial": "TSliding Choice",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Tokens.html#v:TSlidingChoice"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Tokens",
          "name": "TString",
          "package": "libcspm",
          "signature": "TString String",
          "source": "src/CSPM-Parser-Tokens.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Tokens",
          "module": "CSPM.Parser.Tokens",
          "name": "TString",
          "package": "libcspm",
          "partial": "TString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Tokens.html#v:TString"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Tokens",
          "name": "TSubType",
          "package": "libcspm",
          "signature": "TSubType",
          "source": "src/CSPM-Parser-Tokens.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Tokens",
          "module": "CSPM.Parser.Tokens",
          "name": "TSubType",
          "package": "libcspm",
          "partial": "TSub Type",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Tokens.html#v:TSubType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Tokens",
          "name": "TTauPriority",
          "package": "libcspm",
          "signature": "TTauPriority",
          "source": "src/CSPM-Parser-Tokens.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Tokens",
          "module": "CSPM.Parser.Tokens",
          "name": "TTauPriority",
          "package": "libcspm",
          "partial": "TTau Priority",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Tokens.html#v:TTauPriority"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Tokens",
          "name": "TThen",
          "package": "libcspm",
          "signature": "TThen",
          "source": "src/CSPM-Parser-Tokens.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Tokens",
          "module": "CSPM.Parser.Tokens",
          "name": "TThen",
          "package": "libcspm",
          "partial": "TThen",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Tokens.html#v:TThen"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Tokens",
          "name": "TTie",
          "package": "libcspm",
          "signature": "TTie",
          "source": "src/CSPM-Parser-Tokens.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Tokens",
          "module": "CSPM.Parser.Tokens",
          "name": "TTie",
          "package": "libcspm",
          "partial": "TTie",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Tokens.html#v:TTie"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Tokens",
          "name": "TTimed",
          "package": "libcspm",
          "signature": "TTimed",
          "source": "src/CSPM-Parser-Tokens.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Tokens",
          "module": "CSPM.Parser.Tokens",
          "name": "TTimed",
          "package": "libcspm",
          "partial": "TTimed",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Tokens.html#v:TTimed"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Tokens",
          "name": "TTimes",
          "package": "libcspm",
          "signature": "TTimes",
          "source": "src/CSPM-Parser-Tokens.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Tokens",
          "module": "CSPM.Parser.Tokens",
          "name": "TTimes",
          "package": "libcspm",
          "partial": "TTimes",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Tokens.html#v:TTimes"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Tokens",
          "name": "TTransparent",
          "package": "libcspm",
          "signature": "TTransparent",
          "source": "src/CSPM-Parser-Tokens.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Tokens",
          "module": "CSPM.Parser.Tokens",
          "name": "TTransparent",
          "package": "libcspm",
          "partial": "TTransparent",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Tokens.html#v:TTransparent"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Tokens",
          "name": "TTrue",
          "package": "libcspm",
          "signature": "TTrue",
          "source": "src/CSPM-Parser-Tokens.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Tokens",
          "module": "CSPM.Parser.Tokens",
          "name": "TTrue",
          "package": "libcspm",
          "partial": "TTrue",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Tokens.html#v:TTrue"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Tokens",
          "name": "TWildCard",
          "package": "libcspm",
          "signature": "TWildCard",
          "source": "src/CSPM-Parser-Tokens.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Tokens",
          "module": "CSPM.Parser.Tokens",
          "name": "TWildCard",
          "package": "libcspm",
          "partial": "TWild Card",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Tokens.html#v:TWildCard"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Tokens",
          "name": "TWithin",
          "package": "libcspm",
          "signature": "TWithin",
          "source": "src/CSPM-Parser-Tokens.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Tokens",
          "module": "CSPM.Parser.Tokens",
          "name": "TWithin",
          "package": "libcspm",
          "partial": "TWithin",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Tokens.html#v:TWithin"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Tokens",
          "name": "TYield",
          "package": "libcspm",
          "signature": "TYield",
          "source": "src/CSPM-Parser-Tokens.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Tokens",
          "module": "CSPM.Parser.Tokens",
          "name": "TYield",
          "package": "libcspm",
          "partial": "TYield",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Tokens.html#v:TYield"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser.Tokens",
          "name": "TYieldStar",
          "package": "libcspm",
          "signature": "TYieldStar",
          "source": "src/CSPM-Parser-Tokens.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Parser Tokens",
          "module": "CSPM.Parser.Tokens",
          "name": "TYieldStar",
          "package": "libcspm",
          "partial": "TYield Star",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser-Tokens.html#v:TYieldStar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eA module that parses CSPM modules.\n\u003c/p\u003e\u003cp\u003eThe biggest problem with parsing CSPM is that \u003e means both greater than\n and end sequence. For example, consider \u003ccode\u003e\u003cx | x \u003e 2\u003c/code\u003e and \u003ccode\u003e\u003cx | x \u003e 2 \u003e\u003c/code\u003e.\n Both of these are syntactically valid, but the parser has no way of deducing\n whether or not the first \u003ccode\u003e\u003e\u003c/code\u003e it sees is an end sequence or a greater than.\n\u003c/p\u003e\u003cp\u003eClearly, without an arbitrary lookahead it is not possible, in general, to\n solve this. Hence, we go for the 'shortest sequence' approach, in which\n whenever a \u003ccode\u003e\u003e\u003c/code\u003e is seen whilst a list is currently open, we assume that it\n closes the list.\n\u003c/p\u003e\u003cp\u003eFDR has a slightly more sophisticated scheme, but this depends on the fact\n that Bison happens to generate a lazy lookahead in this case, whereas Happy\n is never lazy in its lookahead token. In particular, FDR has a sequence\n stack of integers. The top value means the number of open sequence brackets\n it has seen so far. It lexes \u003ccode\u003e\u003c\u003c/code\u003e as normal, but whenever it decides that a\n \u003ccode\u003e\u003c\u003c/code\u003e token is a open sequence token, adds one to the current top of the\n sequence stack. Then, whenever a \u003ccode\u003e\u003e\u003c/code\u003e token is discovered it checks to see \n if the top value is non-zero, and if so lexes endseq, otherwise lexes gt. \n It then decrements the value of the top of the sequence stack in the \n parser. It uses a stack to allow it to open new contexts within parenthesis.\n\u003c/p\u003e\u003cp\u003eLaziness is required when scanning something like \u003ccode\u003e\u003c1\u003e \u003e \u003c1\u003e\u003c/code\u003e as, if it is\n not lazy then the second \u003ccode\u003e\u003e\u003c/code\u003e will be lexed just before the first \u003ccode\u003e\u003e\u003c/code\u003e is dealt\n with.\n\u003c/p\u003e\u003cp\u003eInstead, we decrement the top of the sequence stack within the lexer instead.\n I don't think this will cause a change in behaviour, as if the lexer lexes\n a _endseq token then it will definitely decrement the counter later (and\n it has already checked to make sure it is non-zero). However, we do keep\n the decision about \u003ccode\u003eLT\u003c/code\u003e being \u003ccode\u003eopenseq\u003c/code\u003e or \u003ccode\u003e\u003c\u003c/code\u003e in the parser as this can \n decide when this is the case (e.g. \u003ccode\u003ex \u003c\u003c/code\u003e means it must be a \u003ccode\u003eLT\u003c/code\u003e). \n\u003c/p\u003e\u003cp\u003eThe above is a problem in conjunction with nested brackets. For example,\n consider \u003ccode\u003e\u003c(0,1) | x\u003e\u003c/code\u003e; when we parse this we would take the \u003ccode\u003e(\u003c/code\u003e into the \n lookahead before we actually parse \u003ccode\u003e\u003c\u003c/code\u003e, meaning that when we push the \u003ccode\u003e1\u003c/code\u003e\n onto the sequence stack it actually goes onto the new top entry that is \n popped off after \u003ccode\u003e)\u003c/code\u003e is processed. Therefore, the \u003ccode\u003e\u003e\u003c/code\u003e will be parsed as a \n \u003ccode\u003eGT\u003c/code\u003e. To solve this we make sure that whenever we pop off the sequence \n stack we add any remaining open sequences onto the new top element. Clearly \n this would be unsafe if we were relying on this for parsing, but as we are \n not this should be fine and should cause no further ambiguities.\n\u003c/p\u003e\u003cp\u003eIt should be noted the above is a big hacky workaround, but I see no \n alternative without resorting to an arbitrary lookahead parser (like parsec)\n and its obvious inefficiency.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "CSPM.Parser",
          "name": "Parser",
          "package": "libcspm",
          "source": "src/CSPM-Parser.html",
          "type": "module"
        },
        "index": {
          "description": "module that parses CSPM modules The biggest problem with parsing CSPM is that means both greater than and end sequence For example consider and Both of these are syntactically valid but the parser has no way of deducing whether or not the first it sees is an end sequence or greater than Clearly without an arbitrary lookahead it is not possible in general to solve this Hence we go for the shortest sequence approach in which whenever is seen whilst list is currently open we assume that it closes the list FDR has slightly more sophisticated scheme but this depends on the fact that Bison happens to generate lazy lookahead in this case whereas Happy is never lazy in its lookahead token In particular FDR has sequence stack of integers The top value means the number of open sequence brackets it has seen so far It lexes as normal but whenever it decides that token is open sequence token adds one to the current top of the sequence stack Then whenever token is discovered it checks to see if the top value is non-zero and if so lexes endseq otherwise lexes gt It then decrements the value of the top of the sequence stack in the parser It uses stack to allow it to open new contexts within parenthesis Laziness is required when scanning something like as if it is not lazy then the second will be lexed just before the first is dealt with Instead we decrement the top of the sequence stack within the lexer instead don think this will cause change in behaviour as if the lexer lexes endseq token then it will definitely decrement the counter later and it has already checked to make sure it is non-zero However we do keep the decision about LT being openseq or in the parser as this can decide when this is the case e.g means it must be LT The above is problem in conjunction with nested brackets For example consider when we parse this we would take the into the lookahead before we actually parse meaning that when we push the onto the sequence stack it actually goes onto the new top entry that is popped off after is processed Therefore the will be parsed as GT To solve this we make sure that whenever we pop off the sequence stack we add any remaining open sequences onto the new top element Clearly this would be unsafe if we were relying on this for parsing but as we are not this should be fine and should cause no further ambiguities It should be noted the above is big hacky workaround but see no alternative without resorting to an arbitrary lookahead parser like parsec and its obvious inefficiency",
          "hierarchy": "CSPM Parser",
          "module": "CSPM.Parser",
          "name": "Parser",
          "package": "libcspm",
          "partial": "Parser",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Parser",
          "name": "ParseMonad",
          "package": "libcspm",
          "source": "src/CSPM-Parser-Monad.html#ParseMonad",
          "type": "type"
        },
        "index": {
          "hierarchy": "CSPM Parser",
          "module": "CSPM.Parser",
          "name": "ParseMonad",
          "package": "libcspm",
          "partial": "Parse Monad",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser.html#t:ParseMonad"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eParses a string as an \u003ccode\u003e\u003ca\u003ePExp\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "CSPM.Parser",
          "name": "parseExpression",
          "package": "libcspm",
          "signature": "String -\u003e ParseMonad PExp",
          "source": "src/CSPM-Parser.html#parseExpression",
          "type": "function"
        },
        "index": {
          "description": "Parses string as an PExp",
          "hierarchy": "CSPM Parser",
          "module": "CSPM.Parser",
          "name": "parseExpression",
          "normalized": "String-\u003eParseMonad PExp",
          "package": "libcspm",
          "partial": "Expression",
          "signature": "String-\u003eParseMonad PExp",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser.html#v:parseExpression"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eParse the given file, returning the parsed \u003ccode\u003ePModule\u003c/code\u003es.\n\u003c/p\u003e",
          "module": "CSPM.Parser",
          "name": "parseFile",
          "package": "libcspm",
          "signature": "String -\u003e ParseMonad PCSPMFile",
          "source": "src/CSPM-Parser.html#parseFile",
          "type": "function"
        },
        "index": {
          "description": "Parse the given file returning the parsed PModule",
          "hierarchy": "CSPM Parser",
          "module": "CSPM.Parser",
          "name": "parseFile",
          "normalized": "String-\u003eParseMonad PCSPMFile",
          "package": "libcspm",
          "partial": "File",
          "signature": "String-\u003eParseMonad PCSPMFile",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser.html#v:parseFile"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eParse as string as an \u003ccode\u003e\u003ca\u003ePInteractiveStmt\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "CSPM.Parser",
          "name": "parseInteractiveStmt",
          "package": "libcspm",
          "signature": "String -\u003e ParseMonad PInteractiveStmt",
          "source": "src/CSPM-Parser.html#parseInteractiveStmt",
          "type": "function"
        },
        "index": {
          "description": "Parse as string as an PInteractiveStmt",
          "hierarchy": "CSPM Parser",
          "module": "CSPM.Parser",
          "name": "parseInteractiveStmt",
          "normalized": "String-\u003eParseMonad PInteractiveStmt",
          "package": "libcspm",
          "partial": "Interactive Stmt",
          "signature": "String-\u003eParseMonad PInteractiveStmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser.html#v:parseInteractiveStmt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eParse a string, as though it were an entire file, returning the parsed\n \u003ccode\u003ePModule\u003c/code\u003es.\n\u003c/p\u003e",
          "module": "CSPM.Parser",
          "name": "parseStringAsFile",
          "package": "libcspm",
          "signature": "String -\u003e ParseMonad PCSPMFile",
          "source": "src/CSPM-Parser.html#parseStringAsFile",
          "type": "function"
        },
        "index": {
          "description": "Parse string as though it were an entire file returning the parsed PModule",
          "hierarchy": "CSPM Parser",
          "module": "CSPM.Parser",
          "name": "parseStringAsFile",
          "normalized": "String-\u003eParseMonad PCSPMFile",
          "package": "libcspm",
          "partial": "String As File",
          "signature": "String-\u003eParseMonad PCSPMFile",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Parser.html#v:parseStringAsFile"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module contains all the builtin definitions for the input CSPM\n language.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "CSPM.Prelude",
          "name": "Prelude",
          "package": "libcspm",
          "source": "src/CSPM-Prelude.html",
          "type": "module"
        },
        "index": {
          "description": "This module contains all the builtin definitions for the input CSPM language",
          "hierarchy": "CSPM Prelude",
          "module": "CSPM.Prelude",
          "name": "Prelude",
          "package": "libcspm",
          "partial": "Prelude",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Prelude.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Prelude",
          "name": "BuiltIn",
          "package": "libcspm",
          "source": "src/CSPM-Prelude.html#BuiltIn",
          "type": "data"
        },
        "index": {
          "hierarchy": "CSPM Prelude",
          "module": "CSPM.Prelude",
          "name": "BuiltIn",
          "package": "libcspm",
          "partial": "Built In",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Prelude.html#t:BuiltIn"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Prelude",
          "name": "BuiltIn",
          "package": "libcspm",
          "signature": "BuiltIn",
          "source": "src/CSPM-Prelude.html#BuiltIn",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Prelude",
          "module": "CSPM.Prelude",
          "name": "BuiltIn",
          "package": "libcspm",
          "partial": "Built In",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Prelude.html#v:BuiltIn"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Prelude",
          "name": "builtins",
          "package": "libcspm",
          "signature": "Bool -\u003e [BuiltIn]",
          "source": "src/CSPM-Prelude.html#builtins",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Prelude",
          "module": "CSPM.Prelude",
          "name": "builtins",
          "normalized": "Bool-\u003e[BuiltIn]",
          "package": "libcspm",
          "signature": "Bool-\u003e[BuiltIn]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Prelude.html#v:builtins"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Prelude",
          "name": "deprecatedReplacement",
          "package": "libcspm",
          "signature": "Maybe Name",
          "source": "src/CSPM-Prelude.html#BuiltIn",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Prelude",
          "module": "CSPM.Prelude",
          "name": "deprecatedReplacement",
          "package": "libcspm",
          "partial": "Replacement",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Prelude.html#v:deprecatedReplacement"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Prelude",
          "name": "externalFunctionForOccName",
          "package": "libcspm",
          "signature": "OccName -\u003e Maybe BuiltIn",
          "source": "src/CSPM-Prelude.html#externalFunctionForOccName",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Prelude",
          "module": "CSPM.Prelude",
          "name": "externalFunctionForOccName",
          "normalized": "OccName-\u003eMaybe BuiltIn",
          "package": "libcspm",
          "partial": "Function For Occ Name",
          "signature": "OccName-\u003eMaybe BuiltIn",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Prelude.html#v:externalFunctionForOccName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Prelude",
          "name": "isDeprecated",
          "package": "libcspm",
          "signature": "Bool",
          "source": "src/CSPM-Prelude.html#BuiltIn",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Prelude",
          "module": "CSPM.Prelude",
          "name": "isDeprecated",
          "package": "libcspm",
          "partial": "Deprecated",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Prelude.html#v:isDeprecated"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Prelude",
          "name": "isExternal",
          "package": "libcspm",
          "signature": "Bool",
          "source": "src/CSPM-Prelude.html#BuiltIn",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Prelude",
          "module": "CSPM.Prelude",
          "name": "isExternal",
          "package": "libcspm",
          "partial": "External",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Prelude.html#v:isExternal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Prelude",
          "name": "isHidden",
          "package": "libcspm",
          "signature": "Bool",
          "source": "src/CSPM-Prelude.html#BuiltIn",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Prelude",
          "module": "CSPM.Prelude",
          "name": "isHidden",
          "package": "libcspm",
          "partial": "Hidden",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Prelude.html#v:isHidden"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Prelude",
          "name": "isTransparent",
          "package": "libcspm",
          "signature": "Bool",
          "source": "src/CSPM-Prelude.html#BuiltIn",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Prelude",
          "module": "CSPM.Prelude",
          "name": "isTransparent",
          "package": "libcspm",
          "partial": "Transparent",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Prelude.html#v:isTransparent"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Prelude",
          "name": "isTypeUnsafe",
          "package": "libcspm",
          "signature": "Bool",
          "source": "src/CSPM-Prelude.html#BuiltIn",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Prelude",
          "module": "CSPM.Prelude",
          "name": "isTypeUnsafe",
          "package": "libcspm",
          "partial": "Type Unsafe",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Prelude.html#v:isTypeUnsafe"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Prelude",
          "name": "name",
          "package": "libcspm",
          "signature": "Name",
          "source": "src/CSPM-Prelude.html#BuiltIn",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Prelude",
          "module": "CSPM.Prelude",
          "name": "name",
          "package": "libcspm",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Prelude.html#v:name"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Prelude",
          "name": "stringName",
          "package": "libcspm",
          "signature": "String",
          "source": "src/CSPM-Prelude.html#BuiltIn",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Prelude",
          "module": "CSPM.Prelude",
          "name": "stringName",
          "package": "libcspm",
          "partial": "Name",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Prelude.html#v:stringName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Prelude",
          "name": "transparentFunctionForOccName",
          "package": "libcspm",
          "signature": "OccName -\u003e Maybe BuiltIn",
          "source": "src/CSPM-Prelude.html#transparentFunctionForOccName",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Prelude",
          "module": "CSPM.Prelude",
          "name": "transparentFunctionForOccName",
          "normalized": "OccName-\u003eMaybe BuiltIn",
          "package": "libcspm",
          "partial": "Function For Occ Name",
          "signature": "OccName-\u003eMaybe BuiltIn",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Prelude.html#v:transparentFunctionForOccName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Prelude",
          "name": "typeScheme",
          "package": "libcspm",
          "signature": "TypeScheme",
          "source": "src/CSPM-Prelude.html#BuiltIn",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Prelude",
          "module": "CSPM.Prelude",
          "name": "typeScheme",
          "package": "libcspm",
          "partial": "Scheme",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Prelude.html#v:typeScheme"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.PrettyPrinter",
          "name": "PrettyPrinter",
          "package": "libcspm",
          "source": "src/CSPM-PrettyPrinter.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "CSPM PrettyPrinter",
          "module": "CSPM.PrettyPrinter",
          "name": "PrettyPrinter",
          "package": "libcspm",
          "partial": "Pretty Printer",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-PrettyPrinter.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.PrettyPrinter",
          "name": "prettyPrint",
          "package": "libcspm",
          "signature": "a -\u003e Doc",
          "source": "src/Util-PrettyPrint.html#prettyPrint",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM PrettyPrinter",
          "module": "CSPM.PrettyPrinter",
          "name": "prettyPrint",
          "normalized": "a-\u003eDoc",
          "package": "libcspm",
          "partial": "Print",
          "signature": "a-\u003eDoc",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-PrettyPrinter.html#v:prettyPrint"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.PrettyPrinter",
          "name": "prettyPrintMatch",
          "package": "libcspm",
          "signature": "id -\u003e AnMatch id -\u003e Doc",
          "source": "src/CSPM-PrettyPrinter.html#prettyPrintMatch",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM PrettyPrinter",
          "module": "CSPM.PrettyPrinter",
          "name": "prettyPrintMatch",
          "normalized": "a-\u003eAnMatch a-\u003eDoc",
          "package": "libcspm",
          "partial": "Print Match",
          "signature": "id-\u003eAnMatch id-\u003eDoc",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-PrettyPrinter.html#v:prettyPrintMatch"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eRenames all variables to unique Names, in the process converting all\n UnRenamedName into Name. This simplifies many subsequent phases as every\n name is guaranteed to be unique so flat maps may be used, rather than\n Hierarchical maps. Further, this also flags patterns that match channels\n and datatype clauses.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "CSPM.Renamer",
          "name": "Renamer",
          "package": "libcspm",
          "source": "src/CSPM-Renamer.html",
          "type": "module"
        },
        "index": {
          "description": "Renames all variables to unique Names in the process converting all UnRenamedName into Name This simplifies many subsequent phases as every name is guaranteed to be unique so flat maps may be used rather than Hierarchical maps Further this also flags patterns that match channels and datatype clauses",
          "hierarchy": "CSPM Renamer",
          "module": "CSPM.Renamer",
          "name": "Renamer",
          "package": "libcspm",
          "partial": "Renamer",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Renamer.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Renamer",
          "name": "RenamerMonad",
          "package": "libcspm",
          "source": "src/CSPM-Renamer.html#RenamerMonad",
          "type": "type"
        },
        "index": {
          "hierarchy": "CSPM Renamer",
          "module": "CSPM.Renamer",
          "name": "RenamerMonad",
          "package": "libcspm",
          "partial": "Renamer Monad",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Renamer.html#t:RenamerMonad"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Renamer",
          "name": "RenamerState",
          "package": "libcspm",
          "source": "src/CSPM-Renamer.html#RenamerState",
          "type": "data"
        },
        "index": {
          "hierarchy": "CSPM Renamer",
          "module": "CSPM.Renamer",
          "name": "RenamerState",
          "package": "libcspm",
          "partial": "Renamer State",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Renamer.html#t:RenamerState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Renamer",
          "name": "getBoundNames",
          "package": "libcspm",
          "signature": "RenamerMonad [Name]",
          "source": "src/CSPM-Renamer.html#getBoundNames",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Renamer",
          "module": "CSPM.Renamer",
          "name": "getBoundNames",
          "normalized": "RenamerMonad[Name]",
          "package": "libcspm",
          "partial": "Bound Names",
          "signature": "RenamerMonad[Name]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Renamer.html#v:getBoundNames"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInitialises the renamer.\n\u003c/p\u003e",
          "module": "CSPM.Renamer",
          "name": "initRenamer",
          "package": "libcspm",
          "signature": "IO RenamerState",
          "source": "src/CSPM-Renamer.html#initRenamer",
          "type": "function"
        },
        "index": {
          "description": "Initialises the renamer",
          "hierarchy": "CSPM Renamer",
          "module": "CSPM.Renamer",
          "name": "initRenamer",
          "package": "libcspm",
          "partial": "Renamer",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Renamer.html#v:initRenamer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Renamer",
          "name": "newScope",
          "package": "libcspm",
          "signature": "RenamerMonad ()",
          "source": "src/CSPM-Renamer.html#newScope",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Renamer",
          "module": "CSPM.Renamer",
          "name": "newScope",
          "normalized": "RenamerMonad()",
          "package": "libcspm",
          "partial": "Scope",
          "signature": "RenamerMonad()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Renamer.html#v:newScope"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.Renamer",
          "name": "rename",
          "package": "libcspm",
          "signature": "e1 -\u003e RenamerMonad e2",
          "source": "src/CSPM-Renamer.html#rename",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM Renamer",
          "module": "CSPM.Renamer",
          "name": "rename",
          "normalized": "a-\u003eRenamerMonad a",
          "package": "libcspm",
          "signature": "e-\u003eRenamerMonad e",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Renamer.html#v:rename"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRuns the renamer starting at the given state and returning the given state.\n\u003c/p\u003e",
          "module": "CSPM.Renamer",
          "name": "runFromStateToState",
          "package": "libcspm",
          "signature": "RenamerState -\u003e RenamerMonad a -\u003e IO (a, RenamerState)",
          "source": "src/CSPM-Renamer.html#runFromStateToState",
          "type": "function"
        },
        "index": {
          "description": "Runs the renamer starting at the given state and returning the given state",
          "hierarchy": "CSPM Renamer",
          "module": "CSPM.Renamer",
          "name": "runFromStateToState",
          "normalized": "RenamerState-\u003eRenamerMonad a-\u003eIO(a,RenamerState)",
          "package": "libcspm",
          "partial": "From State To State",
          "signature": "RenamerState-\u003eRenamerMonad a-\u003eIO(a,RenamerState)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-Renamer.html#v:runFromStateToState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.TypeChecker.BuiltInFunctions",
          "name": "BuiltInFunctions",
          "package": "libcspm",
          "source": "src/CSPM-TypeChecker-BuiltInFunctions.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "CSPM TypeChecker BuiltInFunctions",
          "module": "CSPM.TypeChecker.BuiltInFunctions",
          "name": "BuiltInFunctions",
          "package": "libcspm",
          "partial": "Built In Functions",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-TypeChecker-BuiltInFunctions.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.TypeChecker.BuiltInFunctions",
          "name": "injectBuiltInFunctions",
          "package": "libcspm",
          "signature": "TypeCheckMonad ()",
          "source": "src/CSPM-TypeChecker-BuiltInFunctions.html#injectBuiltInFunctions",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM TypeChecker BuiltInFunctions",
          "module": "CSPM.TypeChecker.BuiltInFunctions",
          "name": "injectBuiltInFunctions",
          "normalized": "TypeCheckMonad()",
          "package": "libcspm",
          "partial": "Built In Functions",
          "signature": "TypeCheckMonad()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-TypeChecker-BuiltInFunctions.html#v:injectBuiltInFunctions"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.TypeChecker.Common",
          "name": "Common",
          "package": "libcspm",
          "source": "src/CSPM-TypeChecker-Common.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "CSPM TypeChecker Common",
          "module": "CSPM.TypeChecker.Common",
          "name": "Common",
          "package": "libcspm",
          "partial": "Common",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-TypeChecker-Common.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.TypeChecker.Common",
          "name": "TypeCheckable",
          "package": "libcspm",
          "source": "src/CSPM-TypeChecker-Common.html#TypeCheckable",
          "type": "class"
        },
        "index": {
          "hierarchy": "CSPM TypeChecker Common",
          "module": "CSPM.TypeChecker.Common",
          "name": "TypeCheckable",
          "package": "libcspm",
          "partial": "Type Checkable",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-TypeChecker-Common.html#t:TypeCheckable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.TypeChecker.Common",
          "name": "ensureAreEqual",
          "package": "libcspm",
          "signature": "[a] -\u003e TypeCheckMonad Type",
          "source": "src/CSPM-TypeChecker-Common.html#ensureAreEqual",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM TypeChecker Common",
          "module": "CSPM.TypeChecker.Common",
          "name": "ensureAreEqual",
          "normalized": "[a]-\u003eTypeCheckMonad Type",
          "package": "libcspm",
          "partial": "Are Equal",
          "signature": "[a]-\u003eTypeCheckMonad Type",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-TypeChecker-Common.html#v:ensureAreEqual"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.TypeChecker.Common",
          "name": "ensureHasConstraint",
          "package": "libcspm",
          "signature": "Constraint -\u003e Type -\u003e TypeCheckMonad Type",
          "source": "src/CSPM-TypeChecker-Common.html#ensureHasConstraint",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM TypeChecker Common",
          "module": "CSPM.TypeChecker.Common",
          "name": "ensureHasConstraint",
          "normalized": "Constraint-\u003eType-\u003eTypeCheckMonad Type",
          "package": "libcspm",
          "partial": "Has Constraint",
          "signature": "Constraint-\u003eType-\u003eTypeCheckMonad Type",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-TypeChecker-Common.html#v:ensureHasConstraint"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.TypeChecker.Common",
          "name": "ensureIsBool",
          "package": "libcspm",
          "signature": "a -\u003e TypeCheckMonad b",
          "source": "src/CSPM-TypeChecker-Common.html#ensureIsBool",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM TypeChecker Common",
          "module": "CSPM.TypeChecker.Common",
          "name": "ensureIsBool",
          "normalized": "a-\u003eTypeCheckMonad b",
          "package": "libcspm",
          "partial": "Is Bool",
          "signature": "a-\u003eTypeCheckMonad b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-TypeChecker-Common.html#v:ensureIsBool"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.TypeChecker.Common",
          "name": "ensureIsChannel",
          "package": "libcspm",
          "signature": "a -\u003e TypeCheckMonad b",
          "source": "src/CSPM-TypeChecker-Common.html#ensureIsChannel",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM TypeChecker Common",
          "module": "CSPM.TypeChecker.Common",
          "name": "ensureIsChannel",
          "normalized": "a-\u003eTypeCheckMonad b",
          "package": "libcspm",
          "partial": "Is Channel",
          "signature": "a-\u003eTypeCheckMonad b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-TypeChecker-Common.html#v:ensureIsChannel"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.TypeChecker.Common",
          "name": "ensureIsEvent",
          "package": "libcspm",
          "signature": "a -\u003e TypeCheckMonad b",
          "source": "src/CSPM-TypeChecker-Common.html#ensureIsEvent",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM TypeChecker Common",
          "module": "CSPM.TypeChecker.Common",
          "name": "ensureIsEvent",
          "normalized": "a-\u003eTypeCheckMonad b",
          "package": "libcspm",
          "partial": "Is Event",
          "signature": "a-\u003eTypeCheckMonad b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-TypeChecker-Common.html#v:ensureIsEvent"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.TypeChecker.Common",
          "name": "ensureIsExtendable",
          "package": "libcspm",
          "signature": "a -\u003e Type -\u003e TypeCheckMonad b",
          "source": "src/CSPM-TypeChecker-Common.html#ensureIsExtendable",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM TypeChecker Common",
          "module": "CSPM.TypeChecker.Common",
          "name": "ensureIsExtendable",
          "normalized": "a-\u003eType-\u003eTypeCheckMonad b",
          "package": "libcspm",
          "partial": "Is Extendable",
          "signature": "a-\u003eType-\u003eTypeCheckMonad b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-TypeChecker-Common.html#v:ensureIsExtendable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.TypeChecker.Common",
          "name": "ensureIsInt",
          "package": "libcspm",
          "signature": "a -\u003e TypeCheckMonad b",
          "source": "src/CSPM-TypeChecker-Common.html#ensureIsInt",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM TypeChecker Common",
          "module": "CSPM.TypeChecker.Common",
          "name": "ensureIsInt",
          "normalized": "a-\u003eTypeCheckMonad b",
          "package": "libcspm",
          "partial": "Is Int",
          "signature": "a-\u003eTypeCheckMonad b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-TypeChecker-Common.html#v:ensureIsInt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.TypeChecker.Common",
          "name": "ensureIsList",
          "package": "libcspm",
          "signature": "a -\u003e TypeCheckMonad b",
          "source": "src/CSPM-TypeChecker-Common.html#ensureIsList",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM TypeChecker Common",
          "module": "CSPM.TypeChecker.Common",
          "name": "ensureIsList",
          "normalized": "a-\u003eTypeCheckMonad b",
          "package": "libcspm",
          "partial": "Is List",
          "signature": "a-\u003eTypeCheckMonad b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-TypeChecker-Common.html#v:ensureIsList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.TypeChecker.Common",
          "name": "ensureIsProc",
          "package": "libcspm",
          "signature": "a -\u003e TypeCheckMonad b",
          "source": "src/CSPM-TypeChecker-Common.html#ensureIsProc",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM TypeChecker Common",
          "module": "CSPM.TypeChecker.Common",
          "name": "ensureIsProc",
          "normalized": "a-\u003eTypeCheckMonad b",
          "package": "libcspm",
          "partial": "Is Proc",
          "signature": "a-\u003eTypeCheckMonad b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-TypeChecker-Common.html#v:ensureIsProc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.TypeChecker.Common",
          "name": "ensureIsSet",
          "package": "libcspm",
          "signature": "a -\u003e TypeCheckMonad b",
          "source": "src/CSPM-TypeChecker-Common.html#ensureIsSet",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM TypeChecker Common",
          "module": "CSPM.TypeChecker.Common",
          "name": "ensureIsSet",
          "normalized": "a-\u003eTypeCheckMonad b",
          "package": "libcspm",
          "partial": "Is Set",
          "signature": "a-\u003eTypeCheckMonad b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-TypeChecker-Common.html#v:ensureIsSet"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.TypeChecker.Common",
          "name": "errorContext",
          "package": "libcspm",
          "signature": "a -\u003e Maybe ErrorContext",
          "source": "src/CSPM-TypeChecker-Common.html#errorContext",
          "type": "method"
        },
        "index": {
          "hierarchy": "CSPM TypeChecker Common",
          "module": "CSPM.TypeChecker.Common",
          "name": "errorContext",
          "normalized": "a-\u003eMaybe ErrorContext",
          "package": "libcspm",
          "partial": "Context",
          "signature": "a-\u003eMaybe ErrorContext",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-TypeChecker-Common.html#v:errorContext"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.TypeChecker.Common",
          "name": "typeCheck",
          "package": "libcspm",
          "signature": "a -\u003e TypeCheckMonad b",
          "source": "src/CSPM-TypeChecker-Common.html#typeCheck",
          "type": "method"
        },
        "index": {
          "hierarchy": "CSPM TypeChecker Common",
          "module": "CSPM.TypeChecker.Common",
          "name": "typeCheck",
          "normalized": "a-\u003eTypeCheckMonad b",
          "package": "libcspm",
          "partial": "Check",
          "signature": "a-\u003eTypeCheckMonad b",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-TypeChecker-Common.html#v:typeCheck"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.TypeChecker.Common",
          "name": "typeCheck'",
          "package": "libcspm",
          "signature": "a -\u003e TypeCheckMonad b",
          "source": "src/CSPM-TypeChecker-Common.html#typeCheck%27",
          "type": "method"
        },
        "index": {
          "hierarchy": "CSPM TypeChecker Common",
          "module": "CSPM.TypeChecker.Common",
          "name": "typeCheck'",
          "normalized": "a-\u003eTypeCheckMonad b",
          "package": "libcspm",
          "partial": "Check'",
          "signature": "a-\u003eTypeCheckMonad b",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-TypeChecker-Common.html#v:typeCheck-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.TypeChecker.Common",
          "name": "typeCheckExpect",
          "package": "libcspm",
          "signature": "a -\u003e Type -\u003e TypeCheckMonad b",
          "source": "src/CSPM-TypeChecker-Common.html#typeCheckExpect",
          "type": "method"
        },
        "index": {
          "hierarchy": "CSPM TypeChecker Common",
          "module": "CSPM.TypeChecker.Common",
          "name": "typeCheckExpect",
          "normalized": "a-\u003eType-\u003eTypeCheckMonad b",
          "package": "libcspm",
          "partial": "Check Expect",
          "signature": "a-\u003eType-\u003eTypeCheckMonad b",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-TypeChecker-Common.html#v:typeCheckExpect"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eTraverses the AST filling in all the type information, ensuring that each\n type is fully compressed.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "CSPM.TypeChecker.Compressor",
          "name": "Compressor",
          "package": "libcspm",
          "source": "src/CSPM-TypeChecker-Compressor.html",
          "type": "module"
        },
        "index": {
          "description": "Traverses the AST filling in all the type information ensuring that each type is fully compressed",
          "hierarchy": "CSPM TypeChecker Compressor",
          "module": "CSPM.TypeChecker.Compressor",
          "name": "Compressor",
          "package": "libcspm",
          "partial": "Compressor",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-TypeChecker-Compressor.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.TypeChecker.Compressor",
          "name": "Compressable",
          "package": "libcspm",
          "source": "src/CSPM-TypeChecker-Compressor.html#Compressable",
          "type": "class"
        },
        "index": {
          "hierarchy": "CSPM TypeChecker Compressor",
          "module": "CSPM.TypeChecker.Compressor",
          "name": "Compressable",
          "package": "libcspm",
          "partial": "Compressable",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-TypeChecker-Compressor.html#t:Compressable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMap compress.\n\u003c/p\u003e",
          "module": "CSPM.TypeChecker.Compressor",
          "name": "mcompress",
          "package": "libcspm",
          "signature": "a -\u003e TypeCheckMonad a",
          "source": "src/CSPM-TypeChecker-Compressor.html#mcompress",
          "type": "method"
        },
        "index": {
          "description": "Map compress",
          "hierarchy": "CSPM TypeChecker Compressor",
          "module": "CSPM.TypeChecker.Compressor",
          "name": "mcompress",
          "normalized": "a-\u003eTypeCheckMonad a",
          "package": "libcspm",
          "signature": "a-\u003eTypeCheckMonad a",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-TypeChecker-Compressor.html#v:mcompress"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.TypeChecker.Decl",
          "name": "Decl",
          "package": "libcspm",
          "source": "src/CSPM-TypeChecker-Decl.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "CSPM TypeChecker Decl",
          "module": "CSPM.TypeChecker.Decl",
          "name": "Decl",
          "package": "libcspm",
          "partial": "Decl",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-TypeChecker-Decl.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eType check a list of possibly mutually recursive functions\n\u003c/p\u003e",
          "module": "CSPM.TypeChecker.Decl",
          "name": "typeCheckDecls",
          "package": "libcspm",
          "signature": "[TCDecl] -\u003e TypeCheckMonad ()",
          "source": "src/CSPM-TypeChecker-Decl.html#typeCheckDecls",
          "type": "function"
        },
        "index": {
          "description": "Type check list of possibly mutually recursive functions",
          "hierarchy": "CSPM TypeChecker Decl",
          "module": "CSPM.TypeChecker.Decl",
          "name": "typeCheckDecls",
          "normalized": "[TCDecl]-\u003eTypeCheckMonad()",
          "package": "libcspm",
          "partial": "Check Decls",
          "signature": "[TCDecl]-\u003eTypeCheckMonad()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-TypeChecker-Decl.html#v:typeCheckDecls"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.TypeChecker.Environment",
          "name": "Environment",
          "package": "libcspm",
          "source": "src/CSPM-TypeChecker-Environment.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "CSPM TypeChecker Environment",
          "module": "CSPM.TypeChecker.Environment",
          "name": "Environment",
          "package": "libcspm",
          "partial": "Environment",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-TypeChecker-Environment.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.TypeChecker.Environment",
          "name": "Environment",
          "package": "libcspm",
          "source": "src/CSPM-TypeChecker-Environment.html#Environment",
          "type": "type"
        },
        "index": {
          "hierarchy": "CSPM TypeChecker Environment",
          "module": "CSPM.TypeChecker.Environment",
          "name": "Environment",
          "package": "libcspm",
          "partial": "Environment",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-TypeChecker-Environment.html#t:Environment"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUsed to represent information about a symbol\n\u003c/p\u003e",
          "module": "CSPM.TypeChecker.Environment",
          "name": "SymbolInformation",
          "package": "libcspm",
          "source": "src/CSPM-TypeChecker-Environment.html#SymbolInformation",
          "type": "data"
        },
        "index": {
          "description": "Used to represent information about symbol",
          "hierarchy": "CSPM TypeChecker Environment",
          "module": "CSPM.TypeChecker.Environment",
          "name": "SymbolInformation",
          "package": "libcspm",
          "partial": "Symbol Information",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-TypeChecker-Environment.html#t:SymbolInformation"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.TypeChecker.Environment",
          "name": "SymbolInformation",
          "package": "libcspm",
          "signature": "SymbolInformation",
          "source": "src/CSPM-TypeChecker-Environment.html#SymbolInformation",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM TypeChecker Environment",
          "module": "CSPM.TypeChecker.Environment",
          "name": "SymbolInformation",
          "package": "libcspm",
          "partial": "Symbol Information",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-TypeChecker-Environment.html#v:SymbolInformation"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.TypeChecker.Environment",
          "name": "bind",
          "package": "libcspm",
          "signature": "Environment -\u003e [(Name, SymbolInformation)] -\u003e Environment",
          "source": "src/CSPM-TypeChecker-Environment.html#bind",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM TypeChecker Environment",
          "module": "CSPM.TypeChecker.Environment",
          "name": "bind",
          "normalized": "Environment-\u003e[(Name,SymbolInformation)]-\u003eEnvironment",
          "package": "libcspm",
          "signature": "Environment-\u003e[(Name,SymbolInformation)]-\u003eEnvironment",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-TypeChecker-Environment.html#v:bind"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.TypeChecker.Environment",
          "name": "delete",
          "package": "libcspm",
          "signature": "Environment -\u003e Name -\u003e Environment",
          "source": "src/CSPM-TypeChecker-Environment.html#delete",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM TypeChecker Environment",
          "module": "CSPM.TypeChecker.Environment",
          "name": "delete",
          "normalized": "Environment-\u003eName-\u003eEnvironment",
          "package": "libcspm",
          "signature": "Environment-\u003eName-\u003eEnvironment",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-TypeChecker-Environment.html#v:delete"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.TypeChecker.Environment",
          "name": "deprecationReplacement",
          "package": "libcspm",
          "signature": "Maybe Name",
          "source": "src/CSPM-TypeChecker-Environment.html#SymbolInformation",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM TypeChecker Environment",
          "module": "CSPM.TypeChecker.Environment",
          "name": "deprecationReplacement",
          "package": "libcspm",
          "partial": "Replacement",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-TypeChecker-Environment.html#v:deprecationReplacement"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIs this symbol deprecated\n\u003c/p\u003e",
          "module": "CSPM.TypeChecker.Environment",
          "name": "isDeprecated",
          "package": "libcspm",
          "signature": "Bool",
          "source": "src/CSPM-TypeChecker-Environment.html#SymbolInformation",
          "type": "function"
        },
        "index": {
          "description": "Is this symbol deprecated",
          "hierarchy": "CSPM TypeChecker Environment",
          "module": "CSPM.TypeChecker.Environment",
          "name": "isDeprecated",
          "package": "libcspm",
          "partial": "Deprecated",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-TypeChecker-Environment.html#v:isDeprecated"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIs this symbols' type too general (if so\n use of it will emit a soundness warning)\n\u003c/p\u003e",
          "module": "CSPM.TypeChecker.Environment",
          "name": "isTypeUnsafe",
          "package": "libcspm",
          "signature": "Bool",
          "source": "src/CSPM-TypeChecker-Environment.html#SymbolInformation",
          "type": "function"
        },
        "index": {
          "description": "Is this symbols type too general if so use of it will emit soundness warning",
          "hierarchy": "CSPM TypeChecker Environment",
          "module": "CSPM.TypeChecker.Environment",
          "name": "isTypeUnsafe",
          "package": "libcspm",
          "partial": "Type Unsafe",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-TypeChecker-Environment.html#v:isTypeUnsafe"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.TypeChecker.Environment",
          "name": "maybeLookup",
          "package": "libcspm",
          "signature": "Environment -\u003e Name -\u003e Maybe SymbolInformation",
          "source": "src/CSPM-TypeChecker-Environment.html#maybeLookup",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM TypeChecker Environment",
          "module": "CSPM.TypeChecker.Environment",
          "name": "maybeLookup",
          "normalized": "Environment-\u003eName-\u003eMaybe SymbolInformation",
          "package": "libcspm",
          "partial": "Lookup",
          "signature": "Environment-\u003eName-\u003eMaybe SymbolInformation",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-TypeChecker-Environment.html#v:maybeLookup"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMake symbol information for the type assuming that the symbol\n is not deprecated and its type is not unsafe.\n\u003c/p\u003e",
          "module": "CSPM.TypeChecker.Environment",
          "name": "mkSymbolInformation",
          "package": "libcspm",
          "signature": "TypeScheme -\u003e SymbolInformation",
          "source": "src/CSPM-TypeChecker-Environment.html#mkSymbolInformation",
          "type": "function"
        },
        "index": {
          "description": "Make symbol information for the type assuming that the symbol is not deprecated and its type is not unsafe",
          "hierarchy": "CSPM TypeChecker Environment",
          "module": "CSPM.TypeChecker.Environment",
          "name": "mkSymbolInformation",
          "normalized": "TypeScheme-\u003eSymbolInformation",
          "package": "libcspm",
          "partial": "Symbol Information",
          "signature": "TypeScheme-\u003eSymbolInformation",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-TypeChecker-Environment.html#v:mkSymbolInformation"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.TypeChecker.Environment",
          "name": "new",
          "package": "libcspm",
          "signature": "Environment",
          "source": "src/CSPM-TypeChecker-Environment.html#new",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM TypeChecker Environment",
          "module": "CSPM.TypeChecker.Environment",
          "name": "new",
          "package": "libcspm",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-TypeChecker-Environment.html#v:new"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.TypeChecker.Environment",
          "name": "toList",
          "package": "libcspm",
          "signature": "Environment -\u003e [(Name, SymbolInformation)]",
          "source": "src/CSPM-TypeChecker-Environment.html#toList",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM TypeChecker Environment",
          "module": "CSPM.TypeChecker.Environment",
          "name": "toList",
          "normalized": "Environment-\u003e[(Name,SymbolInformation)]",
          "package": "libcspm",
          "partial": "List",
          "signature": "Environment-\u003e[(Name,SymbolInformation)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-TypeChecker-Environment.html#v:toList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe type of the symbol\n\u003c/p\u003e",
          "module": "CSPM.TypeChecker.Environment",
          "name": "typeScheme",
          "package": "libcspm",
          "signature": "TypeScheme",
          "source": "src/CSPM-TypeChecker-Environment.html#SymbolInformation",
          "type": "function"
        },
        "index": {
          "description": "The type of the symbol",
          "hierarchy": "CSPM TypeChecker Environment",
          "module": "CSPM.TypeChecker.Environment",
          "name": "typeScheme",
          "package": "libcspm",
          "partial": "Scheme",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-TypeChecker-Environment.html#v:typeScheme"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.TypeChecker.Environment",
          "name": "update",
          "package": "libcspm",
          "signature": "Environment -\u003e Name -\u003e SymbolInformation -\u003e Environment",
          "source": "src/CSPM-TypeChecker-Environment.html#update",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM TypeChecker Environment",
          "module": "CSPM.TypeChecker.Environment",
          "name": "update",
          "normalized": "Environment-\u003eName-\u003eSymbolInformation-\u003eEnvironment",
          "package": "libcspm",
          "signature": "Environment-\u003eName-\u003eSymbolInformation-\u003eEnvironment",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-TypeChecker-Environment.html#v:update"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.TypeChecker.Exceptions",
          "name": "Exceptions",
          "package": "libcspm",
          "source": "src/CSPM-TypeChecker-Exceptions.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "CSPM TypeChecker Exceptions",
          "module": "CSPM.TypeChecker.Exceptions",
          "name": "Exceptions",
          "package": "libcspm",
          "partial": "Exceptions",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-TypeChecker-Exceptions.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.TypeChecker.Exceptions",
          "name": "Error",
          "package": "libcspm",
          "source": "src/CSPM-TypeChecker-Exceptions.html#Error",
          "type": "type"
        },
        "index": {
          "hierarchy": "CSPM TypeChecker Exceptions",
          "module": "CSPM.TypeChecker.Exceptions",
          "name": "Error",
          "package": "libcspm",
          "partial": "Error",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-TypeChecker-Exceptions.html#t:Error"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA datatype used to hold which errors and warnings to actually emit.\n\u003c/p\u003e",
          "module": "CSPM.TypeChecker.Exceptions",
          "name": "ErrorOptions",
          "package": "libcspm",
          "source": "src/CSPM-TypeChecker-Exceptions.html#ErrorOptions",
          "type": "data"
        },
        "index": {
          "description": "datatype used to hold which errors and warnings to actually emit",
          "hierarchy": "CSPM TypeChecker Exceptions",
          "module": "CSPM.TypeChecker.Exceptions",
          "name": "ErrorOptions",
          "package": "libcspm",
          "partial": "Error Options",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-TypeChecker-Exceptions.html#t:ErrorOptions"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.TypeChecker.Exceptions",
          "name": "Warning",
          "package": "libcspm",
          "source": "src/CSPM-TypeChecker-Exceptions.html#Warning",
          "type": "type"
        },
        "index": {
          "hierarchy": "CSPM TypeChecker Exceptions",
          "module": "CSPM.TypeChecker.Exceptions",
          "name": "Warning",
          "package": "libcspm",
          "partial": "Warning",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-TypeChecker-Exceptions.html#t:Warning"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.TypeChecker.Exceptions",
          "name": "ErrorOptions",
          "package": "libcspm",
          "signature": "ErrorOptions",
          "source": "src/CSPM-TypeChecker-Exceptions.html#ErrorOptions",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM TypeChecker Exceptions",
          "module": "CSPM.TypeChecker.Exceptions",
          "name": "ErrorOptions",
          "package": "libcspm",
          "partial": "Error Options",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-TypeChecker-Exceptions.html#v:ErrorOptions"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.TypeChecker.Exceptions",
          "name": "constraintUnificationErrorMessage",
          "package": "libcspm",
          "signature": "Constraint -\u003e Type -\u003e Error",
          "source": "src/CSPM-TypeChecker-Exceptions.html#constraintUnificationErrorMessage",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM TypeChecker Exceptions",
          "module": "CSPM.TypeChecker.Exceptions",
          "name": "constraintUnificationErrorMessage",
          "normalized": "Constraint-\u003eType-\u003eError",
          "package": "libcspm",
          "partial": "Unification Error Message",
          "signature": "Constraint-\u003eType-\u003eError",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-TypeChecker-Exceptions.html#v:constraintUnificationErrorMessage"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.TypeChecker.Exceptions",
          "name": "defaultErrorOptions",
          "package": "libcspm",
          "signature": "ErrorOptions",
          "source": "src/CSPM-TypeChecker-Exceptions.html#defaultErrorOptions",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM TypeChecker Exceptions",
          "module": "CSPM.TypeChecker.Exceptions",
          "name": "defaultErrorOptions",
          "package": "libcspm",
          "partial": "Error Options",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-TypeChecker-Exceptions.html#v:defaultErrorOptions"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.TypeChecker.Exceptions",
          "name": "deprecatedNameUsed",
          "package": "libcspm",
          "signature": "Name -\u003e Maybe Name -\u003e Error",
          "source": "src/CSPM-TypeChecker-Exceptions.html#deprecatedNameUsed",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM TypeChecker Exceptions",
          "module": "CSPM.TypeChecker.Exceptions",
          "name": "deprecatedNameUsed",
          "normalized": "Name-\u003eMaybe Name-\u003eError",
          "package": "libcspm",
          "partial": "Name Used",
          "signature": "Name-\u003eMaybe Name-\u003eError",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-TypeChecker-Exceptions.html#v:deprecatedNameUsed"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.TypeChecker.Exceptions",
          "name": "illegalModuleInstanceCycleErrorMessage",
          "package": "libcspm",
          "signature": "Name -\u003e Name -\u003e [Name] -\u003e Error",
          "source": "src/CSPM-TypeChecker-Exceptions.html#illegalModuleInstanceCycleErrorMessage",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM TypeChecker Exceptions",
          "module": "CSPM.TypeChecker.Exceptions",
          "name": "illegalModuleInstanceCycleErrorMessage",
          "normalized": "Name-\u003eName-\u003e[Name]-\u003eError",
          "package": "libcspm",
          "partial": "Module Instance Cycle Error Message",
          "signature": "Name-\u003eName-\u003e[Name]-\u003eError",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-TypeChecker-Exceptions.html#v:illegalModuleInstanceCycleErrorMessage"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.TypeChecker.Exceptions",
          "name": "incorrectArgumentCountMessage",
          "package": "libcspm",
          "signature": "Doc -\u003e Int -\u003e Int -\u003e Error",
          "source": "src/CSPM-TypeChecker-Exceptions.html#incorrectArgumentCountMessage",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM TypeChecker Exceptions",
          "module": "CSPM.TypeChecker.Exceptions",
          "name": "incorrectArgumentCountMessage",
          "normalized": "Doc-\u003eInt-\u003eInt-\u003eError",
          "package": "libcspm",
          "partial": "Argument Count Message",
          "signature": "Doc-\u003eInt-\u003eInt-\u003eError",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-TypeChecker-Exceptions.html#v:incorrectArgumentCountMessage"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.TypeChecker.Exceptions",
          "name": "infiniteUnificationMessage",
          "package": "libcspm",
          "signature": "Type -\u003e Type -\u003e Error",
          "source": "src/CSPM-TypeChecker-Exceptions.html#infiniteUnificationMessage",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM TypeChecker Exceptions",
          "module": "CSPM.TypeChecker.Exceptions",
          "name": "infiniteUnificationMessage",
          "normalized": "Type-\u003eType-\u003eError",
          "package": "libcspm",
          "partial": "Unification Message",
          "signature": "Type-\u003eType-\u003eError",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-TypeChecker-Exceptions.html#v:infiniteUnificationMessage"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.TypeChecker.Exceptions",
          "name": "unificationErrorMessage",
          "package": "libcspm",
          "signature": "[(Type, Type)] -\u003e Error",
          "source": "src/CSPM-TypeChecker-Exceptions.html#unificationErrorMessage",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM TypeChecker Exceptions",
          "module": "CSPM.TypeChecker.Exceptions",
          "name": "unificationErrorMessage",
          "normalized": "[(Type,Type)]-\u003eError",
          "package": "libcspm",
          "partial": "Error Message",
          "signature": "[(Type,Type)]-\u003eError",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-TypeChecker-Exceptions.html#v:unificationErrorMessage"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.TypeChecker.Exceptions",
          "name": "unsafeNameUsed",
          "package": "libcspm",
          "signature": "Name -\u003e Error",
          "source": "src/CSPM-TypeChecker-Exceptions.html#unsafeNameUsed",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM TypeChecker Exceptions",
          "module": "CSPM.TypeChecker.Exceptions",
          "name": "unsafeNameUsed",
          "normalized": "Name-\u003eError",
          "package": "libcspm",
          "partial": "Name Used",
          "signature": "Name-\u003eError",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-TypeChecker-Exceptions.html#v:unsafeNameUsed"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.TypeChecker.Exceptions",
          "name": "warnDeprecatedNamesUsed",
          "package": "libcspm",
          "signature": "Bool",
          "source": "src/CSPM-TypeChecker-Exceptions.html#ErrorOptions",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM TypeChecker Exceptions",
          "module": "CSPM.TypeChecker.Exceptions",
          "name": "warnDeprecatedNamesUsed",
          "package": "libcspm",
          "partial": "Deprecated Names Used",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-TypeChecker-Exceptions.html#v:warnDeprecatedNamesUsed"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.TypeChecker.Exceptions",
          "name": "warnUnsafeNamesUsed",
          "package": "libcspm",
          "signature": "Bool",
          "source": "src/CSPM-TypeChecker-Exceptions.html#ErrorOptions",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM TypeChecker Exceptions",
          "module": "CSPM.TypeChecker.Exceptions",
          "name": "warnUnsafeNamesUsed",
          "package": "libcspm",
          "partial": "Unsafe Names Used",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-TypeChecker-Exceptions.html#v:warnUnsafeNamesUsed"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.TypeChecker.Expr",
          "name": "Expr",
          "package": "libcspm",
          "source": "src/CSPM-TypeChecker-Expr.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "CSPM TypeChecker Expr",
          "module": "CSPM.TypeChecker.Expr",
          "name": "Expr",
          "package": "libcspm",
          "partial": "Expr",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-TypeChecker-Expr.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.TypeChecker.File",
          "name": "File",
          "package": "libcspm",
          "source": "src/CSPM-TypeChecker-File.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "CSPM TypeChecker File",
          "module": "CSPM.TypeChecker.File",
          "name": "File",
          "package": "libcspm",
          "partial": "File",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-TypeChecker-File.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.TypeChecker.InteractiveStmt",
          "name": "InteractiveStmt",
          "package": "libcspm",
          "source": "src/CSPM-TypeChecker-InteractiveStmt.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "CSPM TypeChecker InteractiveStmt",
          "module": "CSPM.TypeChecker.InteractiveStmt",
          "name": "InteractiveStmt",
          "package": "libcspm",
          "partial": "Interactive Stmt",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-TypeChecker-InteractiveStmt.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.TypeChecker.Monad",
          "name": "Monad",
          "package": "libcspm",
          "source": "src/CSPM-TypeChecker-Monad.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "CSPM TypeChecker Monad",
          "module": "CSPM.TypeChecker.Monad",
          "name": "Monad",
          "package": "libcspm",
          "partial": "Monad",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-TypeChecker-Monad.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.TypeChecker.Monad",
          "name": "ErrorContext",
          "package": "libcspm",
          "source": "src/CSPM-TypeChecker-Monad.html#ErrorContext",
          "type": "type"
        },
        "index": {
          "hierarchy": "CSPM TypeChecker Monad",
          "module": "CSPM.TypeChecker.Monad",
          "name": "ErrorContext",
          "package": "libcspm",
          "partial": "Error Context",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-TypeChecker-Monad.html#t:ErrorContext"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.TypeChecker.Monad",
          "name": "TypeCheckMonad",
          "package": "libcspm",
          "source": "src/CSPM-TypeChecker-Monad.html#TypeCheckMonad",
          "type": "type"
        },
        "index": {
          "hierarchy": "CSPM TypeChecker Monad",
          "module": "CSPM.TypeChecker.Monad",
          "name": "TypeCheckMonad",
          "package": "libcspm",
          "partial": "Type Check Monad",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-TypeChecker-Monad.html#t:TypeCheckMonad"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.TypeChecker.Monad",
          "name": "TypeInferenceState",
          "package": "libcspm",
          "source": "src/CSPM-TypeChecker-Monad.html#TypeInferenceState",
          "type": "data"
        },
        "index": {
          "hierarchy": "CSPM TypeChecker Monad",
          "module": "CSPM.TypeChecker.Monad",
          "name": "TypeInferenceState",
          "package": "libcspm",
          "partial": "Type Inference State",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-TypeChecker-Monad.html#t:TypeInferenceState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.TypeChecker.Monad",
          "name": "TypeInferenceState",
          "package": "libcspm",
          "signature": "TypeInferenceState",
          "source": "src/CSPM-TypeChecker-Monad.html#TypeInferenceState",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM TypeChecker Monad",
          "module": "CSPM.TypeChecker.Monad",
          "name": "TypeInferenceState",
          "package": "libcspm",
          "partial": "Type Inference State",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-TypeChecker-Monad.html#v:TypeInferenceState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.TypeChecker.Monad",
          "name": "addDefinitionName",
          "package": "libcspm",
          "signature": "Name -\u003e TypeCheckMonad a -\u003e TypeCheckMonad a",
          "source": "src/CSPM-TypeChecker-Monad.html#addDefinitionName",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM TypeChecker Monad",
          "module": "CSPM.TypeChecker.Monad",
          "name": "addDefinitionName",
          "normalized": "Name-\u003eTypeCheckMonad a-\u003eTypeCheckMonad a",
          "package": "libcspm",
          "partial": "Definition Name",
          "signature": "Name-\u003eTypeCheckMonad a-\u003eTypeCheckMonad a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-TypeChecker-Monad.html#v:addDefinitionName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.TypeChecker.Monad",
          "name": "addErrorContext",
          "package": "libcspm",
          "signature": "ErrorContext -\u003e TypeCheckMonad a -\u003e TypeCheckMonad a",
          "source": "src/CSPM-TypeChecker-Monad.html#addErrorContext",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM TypeChecker Monad",
          "module": "CSPM.TypeChecker.Monad",
          "name": "addErrorContext",
          "normalized": "ErrorContext-\u003eTypeCheckMonad a-\u003eTypeCheckMonad a",
          "package": "libcspm",
          "partial": "Error Context",
          "signature": "ErrorContext-\u003eTypeCheckMonad a-\u003eTypeCheckMonad a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-TypeChecker-Monad.html#v:addErrorContext"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.TypeChecker.Monad",
          "name": "addUnificationPair",
          "package": "libcspm",
          "signature": "(Type, Type) -\u003e TypeCheckMonad a -\u003e TypeCheckMonad a",
          "source": "src/CSPM-TypeChecker-Monad.html#addUnificationPair",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM TypeChecker Monad",
          "module": "CSPM.TypeChecker.Monad",
          "name": "addUnificationPair",
          "normalized": "(Type,Type)-\u003eTypeCheckMonad a-\u003eTypeCheckMonad a",
          "package": "libcspm",
          "partial": "Unification Pair",
          "signature": "(Type,Type)-\u003eTypeCheckMonad a-\u003eTypeCheckMonad a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-TypeChecker-Monad.html#v:addUnificationPair"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.TypeChecker.Monad",
          "name": "addWarning",
          "package": "libcspm",
          "signature": "(ErrorOptions -\u003e Bool) -\u003e Warning -\u003e TypeCheckMonad ()",
          "source": "src/CSPM-TypeChecker-Monad.html#addWarning",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM TypeChecker Monad",
          "module": "CSPM.TypeChecker.Monad",
          "name": "addWarning",
          "normalized": "(ErrorOptions-\u003eBool)-\u003eWarning-\u003eTypeCheckMonad()",
          "package": "libcspm",
          "partial": "Warning",
          "signature": "(ErrorOptions-\u003eBool)-\u003eWarning-\u003eTypeCheckMonad()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-TypeChecker-Monad.html#v:addWarning"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe set of datatypes that can be compared for equality.\n\u003c/p\u003e",
          "module": "CSPM.TypeChecker.Monad",
          "name": "comparableForEqualityDataTypes",
          "package": "libcspm",
          "signature": "[Name]",
          "source": "src/CSPM-TypeChecker-Monad.html#TypeInferenceState",
          "type": "function"
        },
        "index": {
          "description": "The set of datatypes that can be compared for equality",
          "hierarchy": "CSPM TypeChecker Monad",
          "module": "CSPM.TypeChecker.Monad",
          "name": "comparableForEqualityDataTypes",
          "normalized": "[Name]",
          "package": "libcspm",
          "partial": "For Equality Data Types",
          "signature": "[Name]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-TypeChecker-Monad.html#v:comparableForEqualityDataTypes"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTakes a type and compresses the type by reading all type variables and\n if they point to another type, it returns that type instead.\n\u003c/p\u003e",
          "module": "CSPM.TypeChecker.Monad",
          "name": "compress",
          "package": "libcspm",
          "signature": "Type -\u003e TypeCheckMonad Type",
          "source": "src/CSPM-TypeChecker-Monad.html#compress",
          "type": "function"
        },
        "index": {
          "description": "Takes type and compresses the type by reading all type variables and if they point to another type it returns that type instead",
          "hierarchy": "CSPM TypeChecker Monad",
          "module": "CSPM.TypeChecker.Monad",
          "name": "compress",
          "normalized": "Type-\u003eTypeCheckMonad Type",
          "package": "libcspm",
          "signature": "Type-\u003eTypeCheckMonad Type",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-TypeChecker-Monad.html#v:compress"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eApply compress to the type of a type scheme.\n\u003c/p\u003e",
          "module": "CSPM.TypeChecker.Monad",
          "name": "compressTypeScheme",
          "package": "libcspm",
          "signature": "TypeScheme -\u003e TypeCheckMonad TypeScheme",
          "source": "src/CSPM-TypeChecker-Monad.html#compressTypeScheme",
          "type": "function"
        },
        "index": {
          "description": "Apply compress to the type of type scheme",
          "hierarchy": "CSPM TypeChecker Monad",
          "module": "CSPM.TypeChecker.Monad",
          "name": "compressTypeScheme",
          "normalized": "TypeScheme-\u003eTypeCheckMonad TypeScheme",
          "package": "libcspm",
          "partial": "Type Scheme",
          "signature": "TypeScheme-\u003eTypeCheckMonad TypeScheme",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-TypeChecker-Monad.html#v:compressTypeScheme"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.TypeChecker.Monad",
          "name": "datatypeIsComparableForEquality",
          "package": "libcspm",
          "signature": "Name -\u003e TypeCheckMonad Bool",
          "source": "src/CSPM-TypeChecker-Monad.html#datatypeIsComparableForEquality",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM TypeChecker Monad",
          "module": "CSPM.TypeChecker.Monad",
          "name": "datatypeIsComparableForEquality",
          "normalized": "Name-\u003eTypeCheckMonad Bool",
          "package": "libcspm",
          "partial": "Is Comparable For Equality",
          "signature": "Name-\u003eTypeCheckMonad Bool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-TypeChecker-Monad.html#v:datatypeIsComparableForEquality"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe stack of names that we are currently type-checking.\n\u003c/p\u003e",
          "module": "CSPM.TypeChecker.Monad",
          "name": "definitionStack",
          "package": "libcspm",
          "signature": "[Name]",
          "source": "src/CSPM-TypeChecker-Monad.html#TypeInferenceState",
          "type": "function"
        },
        "index": {
          "description": "The stack of names that we are currently type-checking",
          "hierarchy": "CSPM TypeChecker Monad",
          "module": "CSPM.TypeChecker.Monad",
          "name": "definitionStack",
          "normalized": "[Name]",
          "package": "libcspm",
          "partial": "Stack",
          "signature": "[Name]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-TypeChecker-Monad.html#v:definitionStack"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.TypeChecker.Monad",
          "name": "disallowSymmetricUnification",
          "package": "libcspm",
          "signature": "TypeCheckMonad a -\u003e TypeCheckMonad a",
          "source": "src/CSPM-TypeChecker-Monad.html#disallowSymmetricUnification",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM TypeChecker Monad",
          "module": "CSPM.TypeChecker.Monad",
          "name": "disallowSymmetricUnification",
          "normalized": "TypeCheckMonad a-\u003eTypeCheckMonad a",
          "package": "libcspm",
          "partial": "Symmetric Unification",
          "signature": "TypeCheckMonad a-\u003eTypeCheckMonad a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-TypeChecker-Monad.html#v:disallowSymmetricUnification"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe type environment, which is a map from names to types.\n\u003c/p\u003e",
          "module": "CSPM.TypeChecker.Monad",
          "name": "environment",
          "package": "libcspm",
          "signature": "Environment",
          "source": "src/CSPM-TypeChecker-Monad.html#TypeInferenceState",
          "type": "function"
        },
        "index": {
          "description": "The type environment which is map from names to types",
          "hierarchy": "CSPM TypeChecker Monad",
          "module": "CSPM.TypeChecker.Monad",
          "name": "environment",
          "package": "libcspm",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-TypeChecker-Monad.html#v:environment"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eError stack - provides context information for any\n errors that might be raised\n\u003c/p\u003e",
          "module": "CSPM.TypeChecker.Monad",
          "name": "errorContexts",
          "package": "libcspm",
          "signature": "[ErrorContext]",
          "source": "src/CSPM-TypeChecker-Monad.html#TypeInferenceState",
          "type": "function"
        },
        "index": {
          "description": "Error stack provides context information for any errors that might be raised",
          "hierarchy": "CSPM TypeChecker Monad",
          "module": "CSPM.TypeChecker.Monad",
          "name": "errorContexts",
          "normalized": "[ErrorContext]",
          "package": "libcspm",
          "partial": "Contexts",
          "signature": "[ErrorContext]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-TypeChecker-Monad.html#v:errorContexts"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReport the error if first parameter is False.\n\u003c/p\u003e",
          "module": "CSPM.TypeChecker.Monad",
          "name": "errorIfFalse",
          "package": "libcspm",
          "signature": "Bool -\u003e Error -\u003e TypeCheckMonad ()",
          "source": "src/CSPM-TypeChecker-Monad.html#errorIfFalse",
          "type": "function"
        },
        "index": {
          "description": "Report the error if first parameter is False",
          "hierarchy": "CSPM TypeChecker Monad",
          "module": "CSPM.TypeChecker.Monad",
          "name": "errorIfFalse",
          "normalized": "Bool-\u003eError-\u003eTypeCheckMonad()",
          "package": "libcspm",
          "partial": "If False",
          "signature": "Bool-\u003eError-\u003eTypeCheckMonad()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-TypeChecker-Monad.html#v:errorIfFalse"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.TypeChecker.Monad",
          "name": "errorIfFalseM",
          "package": "libcspm",
          "signature": "TypeCheckMonad Bool -\u003e Error -\u003e TypeCheckMonad ()",
          "source": "src/CSPM-TypeChecker-Monad.html#errorIfFalseM",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM TypeChecker Monad",
          "module": "CSPM.TypeChecker.Monad",
          "name": "errorIfFalseM",
          "normalized": "TypeCheckMonad Bool-\u003eError-\u003eTypeCheckMonad()",
          "package": "libcspm",
          "partial": "If False",
          "signature": "TypeCheckMonad Bool-\u003eError-\u003eTypeCheckMonad()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-TypeChecker-Monad.html#v:errorIfFalseM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe error options to use\n\u003c/p\u003e",
          "module": "CSPM.TypeChecker.Monad",
          "name": "errorOptions",
          "package": "libcspm",
          "signature": "ErrorOptions",
          "source": "src/CSPM-TypeChecker-Monad.html#TypeInferenceState",
          "type": "function"
        },
        "index": {
          "description": "The error options to use",
          "hierarchy": "CSPM TypeChecker Monad",
          "module": "CSPM.TypeChecker.Monad",
          "name": "errorOptions",
          "package": "libcspm",
          "partial": "Options",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-TypeChecker-Monad.html#v:errorOptions"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eErrors that have occured\n\u003c/p\u003e",
          "module": "CSPM.TypeChecker.Monad",
          "name": "errors",
          "package": "libcspm",
          "signature": "[ErrorMessage]",
          "source": "src/CSPM-TypeChecker-Monad.html#TypeInferenceState",
          "type": "function"
        },
        "index": {
          "description": "Errors that have occured",
          "hierarchy": "CSPM TypeChecker Monad",
          "module": "CSPM.TypeChecker.Monad",
          "name": "errors",
          "normalized": "[ErrorMessage]",
          "package": "libcspm",
          "signature": "[ErrorMessage]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-TypeChecker-Monad.html#v:errors"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.TypeChecker.Monad",
          "name": "failM",
          "package": "libcspm",
          "signature": "TypeCheckMonad a",
          "source": "src/CSPM-TypeChecker-Monad.html#failM",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM TypeChecker Monad",
          "module": "CSPM.TypeChecker.Monad",
          "name": "failM",
          "package": "libcspm",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-TypeChecker-Monad.html#v:failM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.TypeChecker.Monad",
          "name": "getDefinitionStack",
          "package": "libcspm",
          "signature": "TypeCheckMonad [Name]",
          "source": "src/CSPM-TypeChecker-Monad.html#getDefinitionStack",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM TypeChecker Monad",
          "module": "CSPM.TypeChecker.Monad",
          "name": "getDefinitionStack",
          "normalized": "TypeCheckMonad[Name]",
          "package": "libcspm",
          "partial": "Definition Stack",
          "signature": "TypeCheckMonad[Name]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-TypeChecker-Monad.html#v:getDefinitionStack"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.TypeChecker.Monad",
          "name": "getEnvironment",
          "package": "libcspm",
          "signature": "TypeCheckMonad Environment",
          "source": "src/CSPM-TypeChecker-Monad.html#getEnvironment",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM TypeChecker Monad",
          "module": "CSPM.TypeChecker.Monad",
          "name": "getEnvironment",
          "package": "libcspm",
          "partial": "Environment",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-TypeChecker-Monad.html#v:getEnvironment"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.TypeChecker.Monad",
          "name": "getErrorContexts",
          "package": "libcspm",
          "signature": "TypeCheckMonad [ErrorContext]",
          "source": "src/CSPM-TypeChecker-Monad.html#getErrorContexts",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM TypeChecker Monad",
          "module": "CSPM.TypeChecker.Monad",
          "name": "getErrorContexts",
          "normalized": "TypeCheckMonad[ErrorContext]",
          "package": "libcspm",
          "partial": "Error Contexts",
          "signature": "TypeCheckMonad[ErrorContext]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-TypeChecker-Monad.html#v:getErrorContexts"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.TypeChecker.Monad",
          "name": "getInError",
          "package": "libcspm",
          "signature": "TypeCheckMonad Bool",
          "source": "src/CSPM-TypeChecker-Monad.html#getInError",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM TypeChecker Monad",
          "module": "CSPM.TypeChecker.Monad",
          "name": "getInError",
          "package": "libcspm",
          "partial": "In Error",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-TypeChecker-Monad.html#v:getInError"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.TypeChecker.Monad",
          "name": "getSrcSpan",
          "package": "libcspm",
          "signature": "TypeCheckMonad SrcSpan",
          "source": "src/CSPM-TypeChecker-Monad.html#getSrcSpan",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM TypeChecker Monad",
          "module": "CSPM.TypeChecker.Monad",
          "name": "getSrcSpan",
          "package": "libcspm",
          "partial": "Src Span",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-TypeChecker-Monad.html#v:getSrcSpan"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.TypeChecker.Monad",
          "name": "getState",
          "package": "libcspm",
          "signature": "TypeCheckMonad TypeInferenceState",
          "source": "src/CSPM-TypeChecker-Monad.html#getState",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM TypeChecker Monad",
          "module": "CSPM.TypeChecker.Monad",
          "name": "getState",
          "package": "libcspm",
          "partial": "State",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-TypeChecker-Monad.html#v:getState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGet the type of \u003ccode\u003en\u003c/code\u003e and throw an exception if it doesn't exist.\n\u003c/p\u003e",
          "module": "CSPM.TypeChecker.Monad",
          "name": "getType",
          "package": "libcspm",
          "signature": "Name -\u003e TypeCheckMonad TypeScheme",
          "source": "src/CSPM-TypeChecker-Monad.html#getType",
          "type": "function"
        },
        "index": {
          "description": "Get the type of and throw an exception if it doesn exist",
          "hierarchy": "CSPM TypeChecker Monad",
          "module": "CSPM.TypeChecker.Monad",
          "name": "getType",
          "normalized": "Name-\u003eTypeCheckMonad TypeScheme",
          "package": "libcspm",
          "partial": "Type",
          "signature": "Name-\u003eTypeCheckMonad TypeScheme",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-TypeChecker-Monad.html#v:getType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.TypeChecker.Monad",
          "name": "getUnificationStack",
          "package": "libcspm",
          "signature": "TypeCheckMonad [(Type, Type)]",
          "source": "src/CSPM-TypeChecker-Monad.html#getUnificationStack",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM TypeChecker Monad",
          "module": "CSPM.TypeChecker.Monad",
          "name": "getUnificationStack",
          "normalized": "TypeCheckMonad[(Type,Type)]",
          "package": "libcspm",
          "partial": "Unification Stack",
          "signature": "TypeCheckMonad[(Type,Type)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-TypeChecker-Monad.html#v:getUnificationStack"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.TypeChecker.Monad",
          "name": "getWarnings",
          "package": "libcspm",
          "signature": "TypeCheckMonad [ErrorMessage]",
          "source": "src/CSPM-TypeChecker-Monad.html#getWarnings",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM TypeChecker Monad",
          "module": "CSPM.TypeChecker.Monad",
          "name": "getWarnings",
          "normalized": "TypeCheckMonad[ErrorMessage]",
          "package": "libcspm",
          "partial": "Warnings",
          "signature": "TypeCheckMonad[ErrorMessage]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-TypeChecker-Monad.html#v:getWarnings"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAre we currently in an error state\n\u003c/p\u003e",
          "module": "CSPM.TypeChecker.Monad",
          "name": "inError",
          "package": "libcspm",
          "signature": "Bool",
          "source": "src/CSPM-TypeChecker-Monad.html#TypeInferenceState",
          "type": "function"
        },
        "index": {
          "description": "Are we currently in an error state",
          "hierarchy": "CSPM TypeChecker Monad",
          "module": "CSPM.TypeChecker.Monad",
          "name": "inError",
          "package": "libcspm",
          "partial": "Error",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-TypeChecker-Monad.html#v:inError"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.TypeChecker.Monad",
          "name": "isDeprecated",
          "package": "libcspm",
          "signature": "Name -\u003e TypeCheckMonad Bool",
          "source": "src/CSPM-TypeChecker-Monad.html#isDeprecated",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM TypeChecker Monad",
          "module": "CSPM.TypeChecker.Monad",
          "name": "isDeprecated",
          "normalized": "Name-\u003eTypeCheckMonad Bool",
          "package": "libcspm",
          "partial": "Deprecated",
          "signature": "Name-\u003eTypeCheckMonad Bool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-TypeChecker-Monad.html#v:isDeprecated"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.TypeChecker.Monad",
          "name": "isTypeUnsafe",
          "package": "libcspm",
          "signature": "Name -\u003e TypeCheckMonad Bool",
          "source": "src/CSPM-TypeChecker-Monad.html#isTypeUnsafe",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM TypeChecker Monad",
          "module": "CSPM.TypeChecker.Monad",
          "name": "isTypeUnsafe",
          "normalized": "Name-\u003eTypeCheckMonad Bool",
          "package": "libcspm",
          "partial": "Type Unsafe",
          "signature": "Name-\u003eTypeCheckMonad Bool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-TypeChecker-Monad.html#v:isTypeUnsafe"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.TypeChecker.Monad",
          "name": "local",
          "package": "libcspm",
          "signature": "[Name] -\u003e TypeCheckMonad a -\u003e TypeCheckMonad a",
          "source": "src/CSPM-TypeChecker-Monad.html#local",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM TypeChecker Monad",
          "module": "CSPM.TypeChecker.Monad",
          "name": "local",
          "normalized": "[Name]-\u003eTypeCheckMonad a-\u003eTypeCheckMonad a",
          "package": "libcspm",
          "signature": "[Name]-\u003eTypeCheckMonad a-\u003eTypeCheckMonad a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-TypeChecker-Monad.html#v:local"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.TypeChecker.Monad",
          "name": "manyErrorsIfFalse",
          "package": "libcspm",
          "signature": "Bool -\u003e [Error] -\u003e TypeCheckMonad ()",
          "source": "src/CSPM-TypeChecker-Monad.html#manyErrorsIfFalse",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM TypeChecker Monad",
          "module": "CSPM.TypeChecker.Monad",
          "name": "manyErrorsIfFalse",
          "normalized": "Bool-\u003e[Error]-\u003eTypeCheckMonad()",
          "package": "libcspm",
          "partial": "Errors If False",
          "signature": "Bool-\u003e[Error]-\u003eTypeCheckMonad()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-TypeChecker-Monad.html#v:manyErrorsIfFalse"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.TypeChecker.Monad",
          "name": "markAsDeprecated",
          "package": "libcspm",
          "signature": "Name -\u003e Maybe Name -\u003e TypeCheckMonad ()",
          "source": "src/CSPM-TypeChecker-Monad.html#markAsDeprecated",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM TypeChecker Monad",
          "module": "CSPM.TypeChecker.Monad",
          "name": "markAsDeprecated",
          "normalized": "Name-\u003eMaybe Name-\u003eTypeCheckMonad()",
          "package": "libcspm",
          "partial": "As Deprecated",
          "signature": "Name-\u003eMaybe Name-\u003eTypeCheckMonad()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-TypeChecker-Monad.html#v:markAsDeprecated"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.TypeChecker.Monad",
          "name": "markDatatypeAsComparableForEquality",
          "package": "libcspm",
          "signature": "Name -\u003e TypeCheckMonad ()",
          "source": "src/CSPM-TypeChecker-Monad.html#markDatatypeAsComparableForEquality",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM TypeChecker Monad",
          "module": "CSPM.TypeChecker.Monad",
          "name": "markDatatypeAsComparableForEquality",
          "normalized": "Name-\u003eTypeCheckMonad()",
          "package": "libcspm",
          "partial": "Datatype As Comparable For Equality",
          "signature": "Name-\u003eTypeCheckMonad()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-TypeChecker-Monad.html#v:markDatatypeAsComparableForEquality"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.TypeChecker.Monad",
          "name": "markTypeAsUnsafe",
          "package": "libcspm",
          "signature": "Name -\u003e TypeCheckMonad ()",
          "source": "src/CSPM-TypeChecker-Monad.html#markTypeAsUnsafe",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM TypeChecker Monad",
          "module": "CSPM.TypeChecker.Monad",
          "name": "markTypeAsUnsafe",
          "normalized": "Name-\u003eTypeCheckMonad()",
          "package": "libcspm",
          "partial": "Type As Unsafe",
          "signature": "Name-\u003eTypeCheckMonad()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-TypeChecker-Monad.html#v:markTypeAsUnsafe"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"CSPM.TypeChecker.Monad\",\"CSPM.TypeChecker\"]",
          "name": "modifyErrorOptions",
          "package": "libcspm",
          "signature": "(ErrorOptions -\u003e ErrorOptions) -\u003e TypeCheckMonad ()",
          "source": "src/CSPM-TypeChecker-Monad.html#modifyErrorOptions",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/libcspm/docs/CSPM-TypeChecker-Monad.html#v:modifyErrorOptions\",\"http://hackage.haskell.org/package/libcspm/docs/CSPM-TypeChecker.html#v:modifyErrorOptions\"]"
        },
        "index": {
          "hierarchy": "CSPM TypeChecker Monad",
          "module": "CSPM.TypeChecker.Monad",
          "name": "modifyErrorOptions",
          "normalized": "(ErrorOptions-\u003eErrorOptions)-\u003eTypeCheckMonad()",
          "package": "libcspm",
          "partial": "Error Options",
          "signature": "(ErrorOptions-\u003eErrorOptions)-\u003eTypeCheckMonad()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-TypeChecker-Monad.html#v:modifyErrorOptions"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.TypeChecker.Monad",
          "name": "newTypeInferenceState",
          "package": "libcspm",
          "signature": "TypeInferenceState",
          "source": "src/CSPM-TypeChecker-Monad.html#newTypeInferenceState",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM TypeChecker Monad",
          "module": "CSPM.TypeChecker.Monad",
          "name": "newTypeInferenceState",
          "package": "libcspm",
          "partial": "Type Inference State",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-TypeChecker-Monad.html#v:newTypeInferenceState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGiven a string causes a \u003ccode\u003e\u003ca\u003ePanic\u003c/a\u003e\u003c/code\u003e to be thrown.\n\u003c/p\u003e",
          "module": "[\"CSPM.TypeChecker.Monad\",\"Util.Exception\"]",
          "name": "panic",
          "package": "libcspm",
          "signature": "String -\u003e a",
          "source": "src/Util-Exception.html#panic",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/libcspm/docs/CSPM-TypeChecker-Monad.html#v:panic\",\"http://hackage.haskell.org/package/libcspm/docs/Util-Exception.html#v:panic\"]"
        },
        "index": {
          "description": "Given string causes Panic to be thrown",
          "hierarchy": "CSPM TypeChecker Monad",
          "module": "CSPM.TypeChecker.Monad",
          "name": "panic",
          "normalized": "String-\u003ea",
          "package": "libcspm",
          "signature": "String-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-TypeChecker-Monad.html#v:panic"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.TypeChecker.Monad",
          "name": "raiseMessageAsError",
          "package": "libcspm",
          "signature": "Error -\u003e TypeCheckMonad a",
          "source": "src/CSPM-TypeChecker-Monad.html#raiseMessageAsError",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM TypeChecker Monad",
          "module": "CSPM.TypeChecker.Monad",
          "name": "raiseMessageAsError",
          "normalized": "Error-\u003eTypeCheckMonad a",
          "package": "libcspm",
          "partial": "Message As Error",
          "signature": "Error-\u003eTypeCheckMonad a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-TypeChecker-Monad.html#v:raiseMessageAsError"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReport a message as an error\n\u003c/p\u003e",
          "module": "CSPM.TypeChecker.Monad",
          "name": "raiseMessagesAsError",
          "package": "libcspm",
          "signature": "[Error] -\u003e TypeCheckMonad a",
          "source": "src/CSPM-TypeChecker-Monad.html#raiseMessagesAsError",
          "type": "function"
        },
        "index": {
          "description": "Report message as an error",
          "hierarchy": "CSPM TypeChecker Monad",
          "module": "CSPM.TypeChecker.Monad",
          "name": "raiseMessagesAsError",
          "normalized": "[Error]-\u003eTypeCheckMonad a",
          "package": "libcspm",
          "partial": "Messages As Error",
          "signature": "[Error]-\u003eTypeCheckMonad a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-TypeChecker-Monad.html#v:raiseMessagesAsError"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.TypeChecker.Monad",
          "name": "readTypeRef",
          "package": "libcspm",
          "signature": "TypeVarRef -\u003e TypeCheckMonad (Either (TypeVar, [Constraint]) Type)",
          "source": "src/CSPM-TypeChecker-Monad.html#readTypeRef",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM TypeChecker Monad",
          "module": "CSPM.TypeChecker.Monad",
          "name": "readTypeRef",
          "normalized": "TypeVarRef-\u003eTypeCheckMonad(Either(TypeVar,[Constraint])Type)",
          "package": "libcspm",
          "partial": "Type Ref",
          "signature": "TypeVarRef-\u003eTypeCheckMonad(Either(TypeVar,[Constraint])Type)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-TypeChecker-Monad.html#v:readTypeRef"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.TypeChecker.Monad",
          "name": "replacementForDeprecatedName",
          "package": "libcspm",
          "signature": "Name -\u003e TypeCheckMonad (Maybe Name)",
          "source": "src/CSPM-TypeChecker-Monad.html#replacementForDeprecatedName",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM TypeChecker Monad",
          "module": "CSPM.TypeChecker.Monad",
          "name": "replacementForDeprecatedName",
          "normalized": "Name-\u003eTypeCheckMonad(Maybe Name)",
          "package": "libcspm",
          "partial": "For Deprecated Name",
          "signature": "Name-\u003eTypeCheckMonad(Maybe Name)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-TypeChecker-Monad.html#v:replacementForDeprecatedName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.TypeChecker.Monad",
          "name": "resetWarnings",
          "package": "libcspm",
          "signature": "TypeCheckMonad ()",
          "source": "src/CSPM-TypeChecker-Monad.html#resetWarnings",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM TypeChecker Monad",
          "module": "CSPM.TypeChecker.Monad",
          "name": "resetWarnings",
          "normalized": "TypeCheckMonad()",
          "package": "libcspm",
          "partial": "Warnings",
          "signature": "TypeCheckMonad()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-TypeChecker-Monad.html#v:resetWarnings"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRuns the typechecker, starting from state \u003ccode\u003est\u003c/code\u003e. If any errors are\n encountered then a \u003ccode\u003e\u003ca\u003eSourceError\u003c/a\u003e\u003c/code\u003e will be thrown with the relevent\n error messages.\n\u003c/p\u003e",
          "module": "[\"CSPM.TypeChecker.Monad\",\"CSPM.TypeChecker\"]",
          "name": "runTypeChecker",
          "package": "libcspm",
          "signature": "TypeInferenceState -\u003e TypeCheckMonad a -\u003e IO a",
          "source": "src/CSPM-TypeChecker-Monad.html#runTypeChecker",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/libcspm/docs/CSPM-TypeChecker-Monad.html#v:runTypeChecker\",\"http://hackage.haskell.org/package/libcspm/docs/CSPM-TypeChecker.html#v:runTypeChecker\"]"
        },
        "index": {
          "description": "Runs the typechecker starting from state st If any errors are encountered then SourceError will be thrown with the relevent error messages",
          "hierarchy": "CSPM TypeChecker Monad",
          "module": "CSPM.TypeChecker.Monad",
          "name": "runTypeChecker",
          "normalized": "TypeInferenceState-\u003eTypeCheckMonad a-\u003eIO a",
          "package": "libcspm",
          "partial": "Type Checker",
          "signature": "TypeInferenceState-\u003eTypeCheckMonad a-\u003eIO a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-TypeChecker-Monad.html#v:runTypeChecker"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.TypeChecker.Monad",
          "name": "setInError",
          "package": "libcspm",
          "signature": "Bool -\u003e TypeCheckMonad a -\u003e TypeCheckMonad a",
          "source": "src/CSPM-TypeChecker-Monad.html#setInError",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM TypeChecker Monad",
          "module": "CSPM.TypeChecker.Monad",
          "name": "setInError",
          "normalized": "Bool-\u003eTypeCheckMonad a-\u003eTypeCheckMonad a",
          "package": "libcspm",
          "partial": "In Error",
          "signature": "Bool-\u003eTypeCheckMonad a-\u003eTypeCheckMonad a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-TypeChecker-Monad.html#v:setInError"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSets the SrcSpan only within prog.\n\u003c/p\u003e",
          "module": "CSPM.TypeChecker.Monad",
          "name": "setSrcSpan",
          "package": "libcspm",
          "signature": "SrcSpan -\u003e TypeCheckMonad a -\u003e TypeCheckMonad a",
          "source": "src/CSPM-TypeChecker-Monad.html#setSrcSpan",
          "type": "function"
        },
        "index": {
          "description": "Sets the SrcSpan only within prog",
          "hierarchy": "CSPM TypeChecker Monad",
          "module": "CSPM.TypeChecker.Monad",
          "name": "setSrcSpan",
          "normalized": "SrcSpan-\u003eTypeCheckMonad a-\u003eTypeCheckMonad a",
          "package": "libcspm",
          "partial": "Src Span",
          "signature": "SrcSpan-\u003eTypeCheckMonad a-\u003eTypeCheckMonad a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-TypeChecker-Monad.html#v:setSrcSpan"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSets the type of n to be t in the current scope only. No unification is \n performed.\n\u003c/p\u003e",
          "module": "CSPM.TypeChecker.Monad",
          "name": "setType",
          "package": "libcspm",
          "signature": "Name -\u003e TypeScheme -\u003e TypeCheckMonad ()",
          "source": "src/CSPM-TypeChecker-Monad.html#setType",
          "type": "function"
        },
        "index": {
          "description": "Sets the type of to be in the current scope only No unification is performed",
          "hierarchy": "CSPM TypeChecker Monad",
          "module": "CSPM.TypeChecker.Monad",
          "name": "setType",
          "normalized": "Name-\u003eTypeScheme-\u003eTypeCheckMonad()",
          "package": "libcspm",
          "partial": "Type",
          "signature": "Name-\u003eTypeScheme-\u003eTypeCheckMonad()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-TypeChecker-Monad.html#v:setType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLocation of the current AST element - used for error\n pretty printing\n\u003c/p\u003e",
          "module": "CSPM.TypeChecker.Monad",
          "name": "srcSpan",
          "package": "libcspm",
          "signature": "SrcSpan",
          "source": "src/CSPM-TypeChecker-Monad.html#TypeInferenceState",
          "type": "function"
        },
        "index": {
          "description": "Location of the current AST element used for error pretty printing",
          "hierarchy": "CSPM TypeChecker Monad",
          "module": "CSPM.TypeChecker.Monad",
          "name": "srcSpan",
          "package": "libcspm",
          "partial": "Span",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-TypeChecker-Monad.html#v:srcSpan"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.TypeChecker.Monad",
          "name": "symUnificationAllowed",
          "package": "libcspm",
          "signature": "Bool",
          "source": "src/CSPM-TypeChecker-Monad.html#TypeInferenceState",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM TypeChecker Monad",
          "module": "CSPM.TypeChecker.Monad",
          "name": "symUnificationAllowed",
          "package": "libcspm",
          "partial": "Unification Allowed",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-TypeChecker-Monad.html#v:symUnificationAllowed"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.TypeChecker.Monad",
          "name": "symmetricUnificationAllowed",
          "package": "libcspm",
          "signature": "TypeCheckMonad Bool",
          "source": "src/CSPM-TypeChecker-Monad.html#symmetricUnificationAllowed",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM TypeChecker Monad",
          "module": "CSPM.TypeChecker.Monad",
          "name": "symmetricUnificationAllowed",
          "package": "libcspm",
          "partial": "Unification Allowed",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-TypeChecker-Monad.html#v:symmetricUnificationAllowed"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.TypeChecker.Monad",
          "name": "tryAndRecover",
          "package": "libcspm",
          "signature": "Bool -\u003e TypeCheckMonad a -\u003e TypeCheckMonad a -\u003e TypeCheckMonad a",
          "source": "src/CSPM-TypeChecker-Monad.html#tryAndRecover",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM TypeChecker Monad",
          "module": "CSPM.TypeChecker.Monad",
          "name": "tryAndRecover",
          "normalized": "Bool-\u003eTypeCheckMonad a-\u003eTypeCheckMonad a-\u003eTypeCheckMonad a",
          "package": "libcspm",
          "partial": "And Recover",
          "signature": "Bool-\u003eTypeCheckMonad a-\u003eTypeCheckMonad a-\u003eTypeCheckMonad a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-TypeChecker-Monad.html#v:tryAndRecover"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eStack of attempted unifications - the current one\n is at the front. In the form (expected, actual).\n\u003c/p\u003e",
          "module": "CSPM.TypeChecker.Monad",
          "name": "unificationStack",
          "package": "libcspm",
          "signature": "[(Type, Type)]",
          "source": "src/CSPM-TypeChecker-Monad.html#TypeInferenceState",
          "type": "function"
        },
        "index": {
          "description": "Stack of attempted unifications the current one is at the front In the form expected actual",
          "hierarchy": "CSPM TypeChecker Monad",
          "module": "CSPM.TypeChecker.Monad",
          "name": "unificationStack",
          "normalized": "[(Type,Type)]",
          "package": "libcspm",
          "partial": "Stack",
          "signature": "[(Type,Type)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-TypeChecker-Monad.html#v:unificationStack"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.TypeChecker.Monad",
          "name": "unmarkDatatypeAsComparableForEquality",
          "package": "libcspm",
          "signature": "Name -\u003e TypeCheckMonad ()",
          "source": "src/CSPM-TypeChecker-Monad.html#unmarkDatatypeAsComparableForEquality",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM TypeChecker Monad",
          "module": "CSPM.TypeChecker.Monad",
          "name": "unmarkDatatypeAsComparableForEquality",
          "normalized": "Name-\u003eTypeCheckMonad()",
          "package": "libcspm",
          "partial": "Datatype As Comparable For Equality",
          "signature": "Name-\u003eTypeCheckMonad()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-TypeChecker-Monad.html#v:unmarkDatatypeAsComparableForEquality"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eList of warnings that have occured\n\u003c/p\u003e",
          "module": "CSPM.TypeChecker.Monad",
          "name": "warnings",
          "package": "libcspm",
          "signature": "[ErrorMessage]",
          "source": "src/CSPM-TypeChecker-Monad.html#TypeInferenceState",
          "type": "function"
        },
        "index": {
          "description": "List of warnings that have occured",
          "hierarchy": "CSPM TypeChecker Monad",
          "module": "CSPM.TypeChecker.Monad",
          "name": "warnings",
          "normalized": "[ErrorMessage]",
          "package": "libcspm",
          "signature": "[ErrorMessage]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-TypeChecker-Monad.html#v:warnings"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.TypeChecker.Monad",
          "name": "writeTypeRef",
          "package": "libcspm",
          "signature": "TypeVarRef -\u003e Type -\u003e TypeCheckMonad ()",
          "source": "src/CSPM-TypeChecker-Monad.html#writeTypeRef",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM TypeChecker Monad",
          "module": "CSPM.TypeChecker.Monad",
          "name": "writeTypeRef",
          "normalized": "TypeVarRef-\u003eType-\u003eTypeCheckMonad()",
          "package": "libcspm",
          "partial": "Type Ref",
          "signature": "TypeVarRef-\u003eType-\u003eTypeCheckMonad()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-TypeChecker-Monad.html#v:writeTypeRef"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.TypeChecker.Pat",
          "name": "Pat",
          "package": "libcspm",
          "source": "src/CSPM-TypeChecker-Pat.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "CSPM TypeChecker Pat",
          "module": "CSPM.TypeChecker.Pat",
          "name": "Pat",
          "package": "libcspm",
          "partial": "Pat",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-TypeChecker-Pat.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.TypeChecker.Unification",
          "name": "Unification",
          "package": "libcspm",
          "source": "src/CSPM-TypeChecker-Unification.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "CSPM TypeChecker Unification",
          "module": "CSPM.TypeChecker.Unification",
          "name": "Unification",
          "package": "libcspm",
          "partial": "Unification",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-TypeChecker-Unification.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.TypeChecker.Unification",
          "name": "dotableToDotList",
          "package": "libcspm",
          "signature": "Type -\u003e TypeCheckMonad ([Type], Type)",
          "source": "src/CSPM-TypeChecker-Unification.html#dotableToDotList",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM TypeChecker Unification",
          "module": "CSPM.TypeChecker.Unification",
          "name": "dotableToDotList",
          "normalized": "Type-\u003eTypeCheckMonad([Type],Type)",
          "package": "libcspm",
          "partial": "To Dot List",
          "signature": "Type-\u003eTypeCheckMonad([Type],Type)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-TypeChecker-Unification.html#v:dotableToDotList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTakes a type and attempts to simplify all TDots inside\n by combining TDotable t1 t2 and arguments.\n\u003c/p\u003e",
          "module": "CSPM.TypeChecker.Unification",
          "name": "evaluateDots",
          "package": "libcspm",
          "signature": "Type -\u003e TypeCheckMonad Type",
          "source": "src/CSPM-TypeChecker-Unification.html#evaluateDots",
          "type": "function"
        },
        "index": {
          "description": "Takes type and attempts to simplify all TDots inside by combining TDotable t1 t2 and arguments",
          "hierarchy": "CSPM TypeChecker Unification",
          "module": "CSPM.TypeChecker.Unification",
          "name": "evaluateDots",
          "normalized": "Type-\u003eTypeCheckMonad Type",
          "package": "libcspm",
          "partial": "Dots",
          "signature": "Type-\u003eTypeCheckMonad Type",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-TypeChecker-Unification.html#v:evaluateDots"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGeneralise the types of the declarations. The parameter \u003ccode\u003enames\u003c/code\u003e gives the \n names that were bound by all the declarations that we are interested in. This\n is done because we convert a type T into forall vs T where \n      vs = fvts (T) - fvts(Env)\n where Env does not contain the function whose type we are generalizing\n (this is because when we type a declaration we are really typing a \n lambda function).\n\u003c/p\u003e",
          "module": "CSPM.TypeChecker.Unification",
          "name": "generaliseGroup",
          "package": "libcspm",
          "signature": "[Name] -\u003e [TypeCheckMonad [(Name, Type)]] -\u003e TypeCheckMonad [[(Name, TypeScheme)]]",
          "source": "src/CSPM-TypeChecker-Unification.html#generaliseGroup",
          "type": "function"
        },
        "index": {
          "description": "Generalise the types of the declarations The parameter names gives the names that were bound by all the declarations that we are interested in This is done because we convert type into forall vs where vs fvts fvts Env where Env does not contain the function whose type we are generalizing this is because when we type declaration we are really typing lambda function",
          "hierarchy": "CSPM TypeChecker Unification",
          "module": "CSPM.TypeChecker.Unification",
          "name": "generaliseGroup",
          "normalized": "[Name]-\u003e[TypeCheckMonad[(Name,Type)]]-\u003eTypeCheckMonad[[(Name,TypeScheme)]]",
          "package": "libcspm",
          "partial": "Group",
          "signature": "[Name]-\u003e[TypeCheckMonad[(Name,Type)]]-\u003eTypeCheckMonad[[(Name,TypeScheme)]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-TypeChecker-Unification.html#v:generaliseGroup"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInstantiates the typescheme with some fresh type variables.\n\u003c/p\u003e",
          "module": "CSPM.TypeChecker.Unification",
          "name": "instantiate",
          "package": "libcspm",
          "signature": "TypeScheme -\u003e TypeCheckMonad Type",
          "source": "src/CSPM-TypeChecker-Unification.html#instantiate",
          "type": "function"
        },
        "index": {
          "description": "Instantiates the typescheme with some fresh type variables",
          "hierarchy": "CSPM TypeChecker Unification",
          "module": "CSPM.TypeChecker.Unification",
          "name": "instantiate",
          "normalized": "TypeScheme-\u003eTypeCheckMonad Type",
          "package": "libcspm",
          "signature": "TypeScheme-\u003eTypeCheckMonad Type",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-TypeChecker-Unification.html#v:instantiate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.TypeChecker.Unification",
          "name": "instantiate'",
          "package": "libcspm",
          "signature": "TypeScheme -\u003e TypeCheckMonad (Type, [(TypeVar, Type)])",
          "source": "src/CSPM-TypeChecker-Unification.html#instantiate%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM TypeChecker Unification",
          "module": "CSPM.TypeChecker.Unification",
          "name": "instantiate'",
          "normalized": "TypeScheme-\u003eTypeCheckMonad(Type,[(TypeVar,Type)])",
          "package": "libcspm",
          "signature": "TypeScheme-\u003eTypeCheckMonad(Type,[(TypeVar,Type)])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-TypeChecker-Unification.html#v:instantiate-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.TypeChecker.Unification",
          "name": "substituteTypes",
          "package": "libcspm",
          "signature": "[(TypeVar, Type)] -\u003e Type -\u003e TypeCheckMonad Type",
          "source": "src/CSPM-TypeChecker-Unification.html#substituteTypes",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM TypeChecker Unification",
          "module": "CSPM.TypeChecker.Unification",
          "name": "substituteTypes",
          "normalized": "[(TypeVar,Type)]-\u003eType-\u003eTypeCheckMonad Type",
          "package": "libcspm",
          "partial": "Types",
          "signature": "[(TypeVar,Type)]-\u003eType-\u003eTypeCheckMonad Type",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-TypeChecker-Unification.html#v:substituteTypes"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTakes a type and converts TDot t1 t2 to [t1, t2].\n\u003c/p\u003e",
          "module": "CSPM.TypeChecker.Unification",
          "name": "typeToDotList",
          "package": "libcspm",
          "signature": "Type -\u003e TypeCheckMonad [Type]",
          "source": "src/CSPM-TypeChecker-Unification.html#typeToDotList",
          "type": "function"
        },
        "index": {
          "description": "Takes type and converts TDot t1 t2 to t1 t2",
          "hierarchy": "CSPM TypeChecker Unification",
          "module": "CSPM.TypeChecker.Unification",
          "name": "typeToDotList",
          "normalized": "Type-\u003eTypeCheckMonad[Type]",
          "package": "libcspm",
          "partial": "To Dot List",
          "signature": "Type-\u003eTypeCheckMonad[Type]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-TypeChecker-Unification.html#v:typeToDotList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe main type unification algorithm. This adds values to the unification \n stack in order to ensure error messages are helpful.\n\u003c/p\u003e",
          "module": "CSPM.TypeChecker.Unification",
          "name": "unify",
          "package": "libcspm",
          "signature": "Type -\u003e Type -\u003e TypeCheckMonad Type",
          "source": "src/CSPM-TypeChecker-Unification.html#unify",
          "type": "function"
        },
        "index": {
          "description": "The main type unification algorithm This adds values to the unification stack in order to ensure error messages are helpful",
          "hierarchy": "CSPM TypeChecker Unification",
          "module": "CSPM.TypeChecker.Unification",
          "name": "unify",
          "normalized": "Type-\u003eType-\u003eTypeCheckMonad Type",
          "package": "libcspm",
          "signature": "Type-\u003eType-\u003eTypeCheckMonad Type",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-TypeChecker-Unification.html#v:unify"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUnifys all types to a single type. The first type is  used as the \n expected Type in error messages.\n\u003c/p\u003e",
          "module": "CSPM.TypeChecker.Unification",
          "name": "unifyAll",
          "package": "libcspm",
          "signature": "[Type] -\u003e TypeCheckMonad Type",
          "source": "src/CSPM-TypeChecker-Unification.html#unifyAll",
          "type": "function"
        },
        "index": {
          "description": "Unifys all types to single type The first type is used as the expected Type in error messages",
          "hierarchy": "CSPM TypeChecker Unification",
          "module": "CSPM.TypeChecker.Unification",
          "name": "unifyAll",
          "normalized": "[Type]-\u003eTypeCheckMonad Type",
          "package": "libcspm",
          "partial": "All",
          "signature": "[Type]-\u003eTypeCheckMonad Type",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-TypeChecker-Unification.html#v:unifyAll"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.TypeChecker",
          "name": "TypeChecker",
          "package": "libcspm",
          "source": "src/CSPM-TypeChecker.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "CSPM TypeChecker",
          "module": "CSPM.TypeChecker",
          "name": "TypeChecker",
          "package": "libcspm",
          "partial": "Type Checker",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-TypeChecker.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA datatype used to hold which errors and warnings to actually emit.\n\u003c/p\u003e",
          "module": "CSPM.TypeChecker",
          "name": "ErrorOptions",
          "package": "libcspm",
          "source": "src/CSPM-TypeChecker-Exceptions.html#ErrorOptions",
          "type": "data"
        },
        "index": {
          "description": "datatype used to hold which errors and warnings to actually emit",
          "hierarchy": "CSPM TypeChecker",
          "module": "CSPM.TypeChecker",
          "name": "ErrorOptions",
          "package": "libcspm",
          "partial": "Error Options",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-TypeChecker.html#t:ErrorOptions"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.TypeChecker",
          "name": "TypeCheckMonad",
          "package": "libcspm",
          "source": "src/CSPM-TypeChecker-Monad.html#TypeCheckMonad",
          "type": "type"
        },
        "index": {
          "hierarchy": "CSPM TypeChecker",
          "module": "CSPM.TypeChecker",
          "name": "TypeCheckMonad",
          "package": "libcspm",
          "partial": "Type Check Monad",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-TypeChecker.html#t:TypeCheckMonad"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.TypeChecker",
          "name": "TypeInferenceState",
          "package": "libcspm",
          "source": "src/CSPM-TypeChecker-Monad.html#TypeInferenceState",
          "type": "data"
        },
        "index": {
          "hierarchy": "CSPM TypeChecker",
          "module": "CSPM.TypeChecker",
          "name": "TypeInferenceState",
          "package": "libcspm",
          "partial": "Type Inference State",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-TypeChecker.html#t:TypeInferenceState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.TypeChecker",
          "name": "initTypeChecker",
          "package": "libcspm",
          "signature": "IO TypeInferenceState",
          "source": "src/CSPM-TypeChecker.html#initTypeChecker",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM TypeChecker",
          "module": "CSPM.TypeChecker",
          "name": "initTypeChecker",
          "package": "libcspm",
          "partial": "Type Checker",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-TypeChecker.html#v:initTypeChecker"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.TypeChecker",
          "name": "runFromStateToState",
          "package": "libcspm",
          "signature": "TypeInferenceState -\u003e TypeCheckMonad a -\u003e IO (a, [ErrorMessage], TypeInferenceState)",
          "source": "src/CSPM-TypeChecker.html#runFromStateToState",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM TypeChecker",
          "module": "CSPM.TypeChecker",
          "name": "runFromStateToState",
          "normalized": "TypeInferenceState-\u003eTypeCheckMonad a-\u003eIO(a,[ErrorMessage],TypeInferenceState)",
          "package": "libcspm",
          "partial": "From State To State",
          "signature": "TypeInferenceState-\u003eTypeCheckMonad a-\u003eIO(a,[ErrorMessage],TypeInferenceState)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-TypeChecker.html#v:runFromStateToState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.TypeChecker",
          "name": "typeCheck",
          "package": "libcspm",
          "signature": "a -\u003e TypeCheckMonad a",
          "source": "src/CSPM-TypeChecker.html#typeCheck",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM TypeChecker",
          "module": "CSPM.TypeChecker",
          "name": "typeCheck",
          "normalized": "a-\u003eTypeCheckMonad a",
          "package": "libcspm",
          "partial": "Check",
          "signature": "a-\u003eTypeCheckMonad a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-TypeChecker.html#v:typeCheck"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.TypeChecker",
          "name": "typeCheckExpect",
          "package": "libcspm",
          "signature": "Type -\u003e a -\u003e TypeCheckMonad a",
          "source": "src/CSPM-TypeChecker.html#typeCheckExpect",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM TypeChecker",
          "module": "CSPM.TypeChecker",
          "name": "typeCheckExpect",
          "normalized": "Type-\u003ea-\u003eTypeCheckMonad a",
          "package": "libcspm",
          "partial": "Check Expect",
          "signature": "Type-\u003ea-\u003eTypeCheckMonad a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-TypeChecker.html#v:typeCheckExpect"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.TypeChecker",
          "name": "typeOfExp",
          "package": "libcspm",
          "signature": "TCExp -\u003e TypeCheckMonad Type",
          "source": "src/CSPM-TypeChecker.html#typeOfExp",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM TypeChecker",
          "module": "CSPM.TypeChecker",
          "name": "typeOfExp",
          "normalized": "TCExp-\u003eTypeCheckMonad Type",
          "package": "libcspm",
          "partial": "Of Exp",
          "signature": "TCExp-\u003eTypeCheckMonad Type",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-TypeChecker.html#v:typeOfExp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM.TypeChecker",
          "name": "typeOfName",
          "package": "libcspm",
          "signature": "Name -\u003e TypeCheckMonad TypeScheme",
          "source": "src/CSPM-TypeChecker.html#typeOfName",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM TypeChecker",
          "module": "CSPM.TypeChecker",
          "name": "typeOfName",
          "normalized": "Name-\u003eTypeCheckMonad TypeScheme",
          "package": "libcspm",
          "partial": "Of Name",
          "signature": "Name-\u003eTypeCheckMonad TypeScheme",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM-TypeChecker.html#v:typeOfName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module provides the main high-level interface to the library \n functionality. It does this through a monadic interface, mainly due to the\n fact that several of the components require the use of the IO monad. It is\n highly recommended that users of this library use a monad and then implement\n the \u003ccode\u003e\u003ca\u003eCSPMMonad\u003c/a\u003e\u003c/code\u003e class on their own custom monad. An example of this is shown\n by the basic implementation of the \u003ccode\u003e\u003ca\u003eCSPM\u003c/a\u003e\u003c/code\u003e monad.\n\u003c/p\u003e\u003cp\u003eThe main library datatype is exported by \u003ccode\u003e\u003ca\u003eSyntax\u003c/a\u003e\u003c/code\u003e, which\n provides an AST representation of machine CSP. Most of the pieces of syntax,\n like expressions (\u003ccode\u003e\u003ca\u003eExp\u003c/a\u003e\u003c/code\u003e), are parametrised by the type of the variables that\n it contains. For more information see the comment at the top of the above\n module.\n\u003c/p\u003e\u003cp\u003eThe library exports several APIs which, in likely order of usage, are:\n\u003c/p\u003e\u003cdl\u003e\u003cdt\u003e\u003ccode\u003eParser\u003c/code\u003e\u003c/dt\u003e\u003cdd\u003e Parses strings or files and produces an AST, parametrised\n        by \u003ccode\u003e\u003ca\u003eUnRenamedName\u003c/a\u003e\u003c/code\u003e, which are simply pieces of text.\n\u003c/dd\u003e\u003cdt\u003e\u003ccode\u003eRenamer\u003c/code\u003e\u003c/dt\u003e\u003cdd\u003e Renames the AST and produces an equivalent AST, but \n        parametrised by \u003ccode\u003e\u003ca\u003eName\u003c/a\u003e\u003c/code\u003e, which uniquely identify the binding instance\n        of each variable (see documentation of \u003ccode\u003e\u003ca\u003eName\u003c/a\u003e\u003c/code\u003e).\n\u003c/dd\u003e\u003cdt\u003e\u003ccode\u003eType Checker\u003c/code\u003e\u003c/dt\u003e\u003cdd\u003e Type checks an AST, in the process annotating it with\n        types.\n\u003c/dd\u003e\u003cdt\u003e\u003ccode\u003eDesugarer\u003c/code\u003e\u003c/dt\u003e\u003cdd\u003e Desugars an AST, remove syntactic sugar and prepares it for\n        evaluation. The AST produced by this phase should not be pretty \n        printed as it parenthesis have been removed, potentially making it not\n        equivalent.\n\u003c/dd\u003e\u003cdt\u003e\u003ccode\u003eEvaluator\u003c/code\u003e\u003c/dt\u003e\u003cdd\u003e Evaluates an AST, returning a \u003ccode\u003e\u003ca\u003eValue\u003c/a\u003e\u003c/code\u003e. Note that the \n        evaluator is lazy, meaning that the resulting Value will be generated\n        as it is consumed, making it suitable for streaming to subsequent\n        compilation phases.\n\u003c/dd\u003e\u003c/dl\u003e\u003cp\u003eFor example, suppose we wish to evaluate the expression \u003ccode\u003etest(1,2,3)\u003c/code\u003e within\n the context of the file \u003ccode\u003etest.csp\u003c/code\u003e we could use the following segment of\n code:\n\u003c/p\u003e\u003cpre\u003e    main :: IO ()\n    main = do\n        session \u003c- newCSPMSession False\n        (value, resultingSession) \u003c- unCSPM session $ do\n            -- Parse the file, returning something of type PCSPMFile.\n            parsedFile \u003c- parseFile \"test.csp\"\n            -- Rename the file, returning something of type TCCSPMFile.\n            renamedFile \u003c- renameFile parsedFile\n            -- Typecheck the file, annotating it with types.\n            typeCheckedFile \u003c- typeCheckFile renamedFile\n            -- Desugar the file, returning the version ready for evaluation.\n            desugaredFile \u003c- desugarFile typeCheckedFile\n            -- Bind the file, making all functions and patterns available.\n            bindFile desugaredFile\n            \n            -- The file is now ready for use, so now we build the expression\n            -- to be evaluated.\n            parsedExpression \u003c- parseExpression \"test(1,2,3)\"\n            renamedExpression \u003c- renameExpression parsedExpression\n            typeCheckedExpression \u003c- typeCheckExpression renamedExpression\n            desugaredExpression \u003c- desugarExpression typeCheckedExpression\n\n            -- Evaluate the expression in the current context.\n            value \u003c- evaluateExpression desugaredExpression\n            return value\n        putStrLn (show (prettyPrint value))\n        return ()\n\u003c/pre\u003e\u003cp\u003eThis would pretty print the value of the expression to stdout.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "CSPM",
          "name": "CSPM",
          "package": "libcspm",
          "source": "src/CSPM.html",
          "type": "module"
        },
        "index": {
          "description": "This module provides the main high-level interface to the library functionality It does this through monadic interface mainly due to the fact that several of the components require the use of the IO monad It is highly recommended that users of this library use monad and then implement the CSPMMonad class on their own custom monad An example of this is shown by the basic implementation of the CSPM monad The main library datatype is exported by Syntax which provides an AST representation of machine CSP Most of the pieces of syntax like expressions Exp are parametrised by the type of the variables that it contains For more information see the comment at the top of the above module The library exports several APIs which in likely order of usage are Parser Parses strings or files and produces an AST parametrised by UnRenamedName which are simply pieces of text Renamer Renames the AST and produces an equivalent AST but parametrised by Name which uniquely identify the binding instance of each variable see documentation of Name Type Checker Type checks an AST in the process annotating it with types Desugarer Desugars an AST remove syntactic sugar and prepares it for evaluation The AST produced by this phase should not be pretty printed as it parenthesis have been removed potentially making it not equivalent Evaluator Evaluates an AST returning Value Note that the evaluator is lazy meaning that the resulting Value will be generated as it is consumed making it suitable for streaming to subsequent compilation phases For example suppose we wish to evaluate the expression test within the context of the file test.csp we could use the following segment of code main IO main do session newCSPMSession False value resultingSession unCSPM session do Parse the file returning something of type PCSPMFile parsedFile parseFile test.csp Rename the file returning something of type TCCSPMFile renamedFile renameFile parsedFile Typecheck the file annotating it with types typeCheckedFile typeCheckFile renamedFile Desugar the file returning the version ready for evaluation desugaredFile desugarFile typeCheckedFile Bind the file making all functions and patterns available bindFile desugaredFile The file is now ready for use so now we build the expression to be evaluated parsedExpression parseExpression test renamedExpression renameExpression parsedExpression typeCheckedExpression typeCheckExpression renamedExpression desugaredExpression desugarExpression typeCheckedExpression Evaluate the expression in the current context value evaluateExpression desugaredExpression return value putStrLn show prettyPrint value return This would pretty print the value of the expression to stdout",
          "hierarchy": "CSPM",
          "module": "CSPM",
          "name": "CSPM",
          "package": "libcspm",
          "partial": "CSPM",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA basic implementation of \u003ccode\u003e\u003ca\u003eCSPMMonad\u003c/a\u003e\u003c/code\u003e, using the \u003ccode\u003eStateT\u003c/code\u003e monad. This\n prints out any warnings to stdout.\n\u003c/p\u003e",
          "module": "CSPM",
          "name": "CSPM",
          "package": "libcspm",
          "source": "src/CSPM.html#CSPM",
          "type": "type"
        },
        "index": {
          "description": "basic implementation of CSPMMonad using the StateT monad This prints out any warnings to stdout",
          "hierarchy": "CSPM",
          "module": "CSPM",
          "name": "CSPM",
          "package": "libcspm",
          "partial": "CSPM",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM.html#t:CSPM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe CSPMMonad is the main monad in which all functions must be called.\n Whilst there is a build in representation (see \u003ccode\u003e\u003ca\u003eCSPM\u003c/a\u003e\u003c/code\u003e) it is recommended\n that you define an instance of \u003ccode\u003e\u003ca\u003eCSPMMonad\u003c/a\u003e\u003c/code\u003e over whatever monad you use.\n\u003c/p\u003e",
          "module": "CSPM",
          "name": "CSPMMonad",
          "package": "libcspm",
          "source": "src/CSPM.html#CSPMMonad",
          "type": "class"
        },
        "index": {
          "description": "The CSPMMonad is the main monad in which all functions must be called Whilst there is build in representation see CSPM it is recommended that you define an instance of CSPMMonad over whatever monad you use",
          "hierarchy": "CSPM",
          "module": "CSPM",
          "name": "CSPMMonad",
          "package": "libcspm",
          "partial": "CSPMMonad",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM.html#t:CSPMMonad"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA \u003ccode\u003e\u003ca\u003eCSPMSession\u003c/a\u003e\u003c/code\u003e represents the internal states of all the various\n components.\n\u003c/p\u003e",
          "module": "CSPM",
          "name": "CSPMSession",
          "package": "libcspm",
          "source": "src/CSPM.html#CSPMSession",
          "type": "data"
        },
        "index": {
          "description": "CSPMSession represents the internal states of all the various components",
          "hierarchy": "CSPM",
          "module": "CSPM",
          "name": "CSPMSession",
          "package": "libcspm",
          "partial": "CSPMSession",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM.html#t:CSPMSession"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM",
          "name": "EvaluatorOptions",
          "package": "libcspm",
          "source": "src/CSPM-Evaluator.html#EvaluatorOptions",
          "type": "data"
        },
        "index": {
          "hierarchy": "CSPM",
          "module": "CSPM",
          "name": "EvaluatorOptions",
          "package": "libcspm",
          "partial": "Evaluator Options",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM.html#t:EvaluatorOptions"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM",
          "name": "ProfilerOptions",
          "package": "libcspm",
          "source": "src/CSPM-Evaluator-Profiler.html#ProfilerOptions",
          "type": "data"
        },
        "index": {
          "hierarchy": "CSPM",
          "module": "CSPM",
          "name": "ProfilerOptions",
          "package": "libcspm",
          "partial": "Profiler Options",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM.html#t:ProfilerOptions"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTakes a declaration and adds it to the current environment. Requires the\n declaration to be desugared.\n\u003c/p\u003e",
          "module": "CSPM",
          "name": "bindDeclaration",
          "package": "libcspm",
          "signature": "TCDecl -\u003e m ()",
          "source": "src/CSPM.html#bindDeclaration",
          "type": "function"
        },
        "index": {
          "description": "Takes declaration and adds it to the current environment Requires the declaration to be desugared",
          "hierarchy": "CSPM",
          "module": "CSPM",
          "name": "bindDeclaration",
          "normalized": "TCDecl-\u003ea()",
          "package": "libcspm",
          "partial": "Declaration",
          "signature": "TCDecl-\u003em()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM.html#v:bindDeclaration"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eBinds all the declarations that are in a particular file. Requires the\n file to be desugared.\n\u003c/p\u003e",
          "module": "CSPM",
          "name": "bindFile",
          "package": "libcspm",
          "signature": "TCCSPMFile -\u003e m ()",
          "source": "src/CSPM.html#bindFile",
          "type": "function"
        },
        "index": {
          "description": "Binds all the declarations that are in particular file Requires the file to be desugared",
          "hierarchy": "CSPM",
          "module": "CSPM",
          "name": "bindFile",
          "normalized": "TCCSPMFile-\u003ea()",
          "package": "libcspm",
          "partial": "File",
          "signature": "TCCSPMFile-\u003em()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM.html#v:bindFile"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturns all currently bound process names, optionally including functions\n that evaluate to processes\n\u003c/p\u003e",
          "module": "CSPM",
          "name": "boundProcessNames",
          "package": "libcspm",
          "signature": "Bool-\u003e m [Name]",
          "type": "function"
        },
        "index": {
          "description": "Returns all currently bound process names optionally including functions that evaluate to processes",
          "hierarchy": "CSPM",
          "module": "CSPM",
          "name": "boundProcessNames",
          "normalized": "Bool-\u003ea[Name]",
          "package": "libcspm",
          "partial": "Process Names",
          "signature": "Bool-\u003em[Name]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM.html#v:boundProcessNames"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDesugars an expression.\n\u003c/p\u003e",
          "module": "CSPM",
          "name": "desugarExpression",
          "package": "libcspm",
          "signature": "TCExp -\u003e m TCExp",
          "source": "src/CSPM.html#desugarExpression",
          "type": "function"
        },
        "index": {
          "description": "Desugars an expression",
          "hierarchy": "CSPM",
          "module": "CSPM",
          "name": "desugarExpression",
          "normalized": "TCExp-\u003ea TCExp",
          "package": "libcspm",
          "partial": "Expression",
          "signature": "TCExp-\u003em TCExp",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM.html#v:desugarExpression"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDesugar a file, preparing it for evaulation.\n\u003c/p\u003e",
          "module": "CSPM",
          "name": "desugarFile",
          "package": "libcspm",
          "signature": "TCCSPMFile -\u003e m TCCSPMFile",
          "source": "src/CSPM.html#desugarFile",
          "type": "function"
        },
        "index": {
          "description": "Desugar file preparing it for evaulation",
          "hierarchy": "CSPM",
          "module": "CSPM",
          "name": "desugarFile",
          "normalized": "TCCSPMFile-\u003ea TCCSPMFile",
          "package": "libcspm",
          "partial": "File",
          "signature": "TCCSPMFile-\u003em TCCSPMFile",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM.html#v:desugarFile"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDesugars an interactive statement.\n\u003c/p\u003e",
          "module": "CSPM",
          "name": "desugarInteractiveStmt",
          "package": "libcspm",
          "signature": "TCInteractiveStmt -\u003e m TCInteractiveStmt",
          "source": "src/CSPM.html#desugarInteractiveStmt",
          "type": "function"
        },
        "index": {
          "description": "Desugars an interactive statement",
          "hierarchy": "CSPM",
          "module": "CSPM",
          "name": "desugarInteractiveStmt",
          "normalized": "TCInteractiveStmt-\u003ea TCInteractiveStmt",
          "package": "libcspm",
          "partial": "Interactive Stmt",
          "signature": "TCInteractiveStmt-\u003em TCInteractiveStmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM.html#v:desugarInteractiveStmt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGiven a \u003ccode\u003e\u003ca\u003eType\u003c/a\u003e\u003c/code\u003e, ensures that the \u003ccode\u003e\u003ca\u003ePExp\u003c/a\u003e\u003c/code\u003e is of that type. It returns the\n annoated and desugared expression.\n\u003c/p\u003e",
          "module": "CSPM",
          "name": "ensureExpressionIsOfType",
          "package": "libcspm",
          "signature": "Type -\u003e TCExp -\u003e m TCExp",
          "source": "src/CSPM.html#ensureExpressionIsOfType",
          "type": "function"
        },
        "index": {
          "description": "Given Type ensures that the PExp is of that type It returns the annoated and desugared expression",
          "hierarchy": "CSPM",
          "module": "CSPM",
          "name": "ensureExpressionIsOfType",
          "normalized": "Type-\u003eTCExp-\u003ea TCExp",
          "package": "libcspm",
          "partial": "Expression Is Of Type",
          "signature": "Type-\u003eTCExp-\u003em TCExp",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM.html#v:ensureExpressionIsOfType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEvaluates the expression in the current context. Requires the expression\n to be desugared.\n\u003c/p\u003e",
          "module": "CSPM",
          "name": "evaluateExpression",
          "package": "libcspm",
          "signature": "TCExp -\u003e m Value",
          "source": "src/CSPM.html#evaluateExpression",
          "type": "function"
        },
        "index": {
          "description": "Evaluates the expression in the current context Requires the expression to be desugared",
          "hierarchy": "CSPM",
          "module": "CSPM",
          "name": "evaluateExpression",
          "normalized": "TCExp-\u003ea Value",
          "package": "libcspm",
          "partial": "Expression",
          "signature": "TCExp-\u003em Value",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM.html#v:evaluateExpression"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGet a list of currently bound names in the environment.\n\u003c/p\u003e",
          "module": "CSPM",
          "name": "getBoundNames",
          "package": "libcspm",
          "signature": "m [Name]",
          "source": "src/CSPM.html#getBoundNames",
          "type": "function"
        },
        "index": {
          "description": "Get list of currently bound names in the environment",
          "hierarchy": "CSPM",
          "module": "CSPM",
          "name": "getBoundNames",
          "normalized": "a[Name]",
          "package": "libcspm",
          "partial": "Bound Names",
          "signature": "m[Name]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM.html#v:getBoundNames"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn the version of libcspm that is being used.\n\u003c/p\u003e",
          "module": "CSPM",
          "name": "getLibCSPMVersion",
          "package": "libcspm",
          "signature": "Version",
          "source": "src/CSPM.html#getLibCSPMVersion",
          "type": "function"
        },
        "index": {
          "description": "Return the version of libcspm that is being used",
          "hierarchy": "CSPM",
          "module": "CSPM",
          "name": "getLibCSPMVersion",
          "package": "libcspm",
          "partial": "Lib CSPMVersion",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM.html#v:getLibCSPMVersion"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGet the current session.\n\u003c/p\u003e",
          "module": "CSPM",
          "name": "getSession",
          "package": "libcspm",
          "signature": "m CSPMSession",
          "source": "src/CSPM.html#getSession",
          "type": "method"
        },
        "index": {
          "description": "Get the current session",
          "hierarchy": "CSPM",
          "module": "CSPM",
          "name": "getSession",
          "package": "libcspm",
          "partial": "Session",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM.html#v:getSession"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis is called whenever warnings are emitted.\n\u003c/p\u003e",
          "module": "CSPM",
          "name": "handleWarnings",
          "package": "libcspm",
          "signature": "[ErrorMessage] -\u003e m ()",
          "source": "src/CSPM.html#handleWarnings",
          "type": "method"
        },
        "index": {
          "description": "This is called whenever warnings are emitted",
          "hierarchy": "CSPM",
          "module": "CSPM",
          "name": "handleWarnings",
          "normalized": "[ErrorMessage]-\u003ea()",
          "package": "libcspm",
          "partial": "Warnings",
          "signature": "[ErrorMessage]-\u003em()",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM.html#v:handleWarnings"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGiven a process name, attempts to convert the name into a process. This\n is only possible for top-level function applications.\n\u003c/p\u003e",
          "module": "CSPM",
          "name": "maybeProcessNameToProcess",
          "package": "libcspm",
          "signature": "ProcName -\u003e m (Maybe UProc)",
          "source": "src/CSPM.html#maybeProcessNameToProcess",
          "type": "function"
        },
        "index": {
          "description": "Given process name attempts to convert the name into process This is only possible for top-level function applications",
          "hierarchy": "CSPM",
          "module": "CSPM",
          "name": "maybeProcessNameToProcess",
          "normalized": "ProcName-\u003ea(Maybe UProc)",
          "package": "libcspm",
          "partial": "Process Name To Process",
          "signature": "ProcName-\u003em(Maybe UProc)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM.html#v:maybeProcessNameToProcess"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CSPM",
          "name": "modifyTypeCheckerErrorOptions",
          "package": "libcspm",
          "signature": "(ErrorOptions -\u003e ErrorOptions) -\u003e m ()",
          "source": "src/CSPM.html#modifyTypeCheckerErrorOptions",
          "type": "function"
        },
        "index": {
          "hierarchy": "CSPM",
          "module": "CSPM",
          "name": "modifyTypeCheckerErrorOptions",
          "normalized": "(ErrorOptions-\u003eErrorOptions)-\u003ea()",
          "package": "libcspm",
          "partial": "Type Checker Error Options",
          "signature": "(ErrorOptions-\u003eErrorOptions)-\u003em()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM.html#v:modifyTypeCheckerErrorOptions"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreate a new \u003ccode\u003e\u003ca\u003eCSPMSession\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "CSPM",
          "name": "newCSPMSession",
          "package": "libcspm",
          "signature": "EvaluatorOptions -\u003e m CSPMSession",
          "source": "src/CSPM.html#newCSPMSession",
          "type": "function"
        },
        "index": {
          "description": "Create new CSPMSession",
          "hierarchy": "CSPM",
          "module": "CSPM",
          "name": "newCSPMSession",
          "normalized": "EvaluatorOptions-\u003ea CSPMSession",
          "package": "libcspm",
          "partial": "CSPMSession",
          "signature": "EvaluatorOptions-\u003em CSPMSession",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM.html#v:newCSPMSession"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eParses an \u003ccode\u003e\u003ca\u003eExp\u003c/a\u003e\u003c/code\u003e. Throws a \u003ccode\u003e\u003ca\u003eSourceError\u003c/a\u003e\u003c/code\u003e on any parse error.\n\u003c/p\u003e",
          "module": "CSPM",
          "name": "parseExpression",
          "package": "libcspm",
          "signature": "String -\u003e m PExp",
          "source": "src/CSPM.html#parseExpression",
          "type": "function"
        },
        "index": {
          "description": "Parses an Exp Throws SourceError on any parse error",
          "hierarchy": "CSPM",
          "module": "CSPM",
          "name": "parseExpression",
          "normalized": "String-\u003ea PExp",
          "package": "libcspm",
          "partial": "Expression",
          "signature": "String-\u003em PExp",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM.html#v:parseExpression"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eParse a file \u003ccode\u003efp\u003c/code\u003e. Throws a \u003ccode\u003e\u003ca\u003eSourceError\u003c/a\u003e\u003c/code\u003e on any parse error.\n\u003c/p\u003e",
          "module": "CSPM",
          "name": "parseFile",
          "package": "libcspm",
          "signature": "FilePath -\u003e m PCSPMFile",
          "source": "src/CSPM.html#parseFile",
          "type": "function"
        },
        "index": {
          "description": "Parse file fp Throws SourceError on any parse error",
          "hierarchy": "CSPM",
          "module": "CSPM",
          "name": "parseFile",
          "normalized": "FilePath-\u003ea PCSPMFile",
          "package": "libcspm",
          "partial": "File",
          "signature": "FilePath-\u003em PCSPMFile",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM.html#v:parseFile"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eParses a \u003ccode\u003e\u003ca\u003ePInteractiveStmt\u003c/a\u003e\u003c/code\u003e. Throws a \u003ccode\u003e\u003ca\u003eSourceError\u003c/a\u003e\u003c/code\u003e on any parse error.\n\u003c/p\u003e",
          "module": "CSPM",
          "name": "parseInteractiveStmt",
          "package": "libcspm",
          "signature": "String -\u003e m PInteractiveStmt",
          "source": "src/CSPM.html#parseInteractiveStmt",
          "type": "function"
        },
        "index": {
          "description": "Parses PInteractiveStmt Throws SourceError on any parse error",
          "hierarchy": "CSPM",
          "module": "CSPM",
          "name": "parseInteractiveStmt",
          "normalized": "String-\u003ea PInteractiveStmt",
          "package": "libcspm",
          "partial": "Interactive Stmt",
          "signature": "String-\u003em PInteractiveStmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM.html#v:parseInteractiveStmt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eParses a string, treating it as though it were a file. Throws a \n \u003ccode\u003e\u003ca\u003eSourceError\u003c/a\u003e\u003c/code\u003e on any parse error.\n\u003c/p\u003e",
          "module": "CSPM",
          "name": "parseStringAsFile",
          "package": "libcspm",
          "signature": "String -\u003e m PCSPMFile",
          "source": "src/CSPM.html#parseStringAsFile",
          "type": "function"
        },
        "index": {
          "description": "Parses string treating it as though it were file Throws SourceError on any parse error",
          "hierarchy": "CSPM",
          "module": "CSPM",
          "name": "parseStringAsFile",
          "normalized": "String-\u003ea PCSPMFile",
          "package": "libcspm",
          "partial": "String As File",
          "signature": "String-\u003em PCSPMFile",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM.html#v:parseStringAsFile"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eObtains the profiling data that the evaluator has produced so far.\n\u003c/p\u003e",
          "module": "CSPM",
          "name": "profilingData",
          "package": "libcspm",
          "signature": "m ProfilingData",
          "source": "src/CSPM.html#profilingData",
          "type": "function"
        },
        "index": {
          "description": "Obtains the profiling data that the evaluator has produced so far",
          "hierarchy": "CSPM",
          "module": "CSPM",
          "name": "profilingData",
          "package": "libcspm",
          "partial": "Data",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM.html#v:profilingData"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRenames an expression.\n\u003c/p\u003e",
          "module": "CSPM",
          "name": "renameExpression",
          "package": "libcspm",
          "signature": "PExp -\u003e m TCExp",
          "source": "src/CSPM.html#renameExpression",
          "type": "function"
        },
        "index": {
          "description": "Renames an expression",
          "hierarchy": "CSPM",
          "module": "CSPM",
          "name": "renameExpression",
          "normalized": "PExp-\u003ea TCExp",
          "package": "libcspm",
          "partial": "Expression",
          "signature": "PExp-\u003em TCExp",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM.html#v:renameExpression"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRenames a file.\n\u003c/p\u003e",
          "module": "CSPM",
          "name": "renameFile",
          "package": "libcspm",
          "signature": "PCSPMFile -\u003e m TCCSPMFile",
          "source": "src/CSPM.html#renameFile",
          "type": "function"
        },
        "index": {
          "description": "Renames file",
          "hierarchy": "CSPM",
          "module": "CSPM",
          "name": "renameFile",
          "normalized": "PCSPMFile-\u003ea TCCSPMFile",
          "package": "libcspm",
          "partial": "File",
          "signature": "PCSPMFile-\u003em TCCSPMFile",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM.html#v:renameFile"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRename ian interactive statement.\n\u003c/p\u003e",
          "module": "CSPM",
          "name": "renameInteractiveStmt",
          "package": "libcspm",
          "signature": "PInteractiveStmt -\u003e m TCInteractiveStmt",
          "source": "src/CSPM.html#renameInteractiveStmt",
          "type": "function"
        },
        "index": {
          "description": "Rename ian interactive statement",
          "hierarchy": "CSPM",
          "module": "CSPM",
          "name": "renameInteractiveStmt",
          "normalized": "PInteractiveStmt-\u003ea TCInteractiveStmt",
          "package": "libcspm",
          "partial": "Interactive Stmt",
          "signature": "PInteractiveStmt-\u003em TCInteractiveStmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM.html#v:renameInteractiveStmt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGiven a program that can return warnings, runs the program and raises\n any warnings found using \u003ccode\u003e\u003ca\u003ehandleWarnings\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "CSPM",
          "name": "reportWarnings",
          "package": "libcspm",
          "signature": "m (a, [ErrorMessage]) -\u003e m a",
          "source": "src/CSPM.html#reportWarnings",
          "type": "function"
        },
        "index": {
          "description": "Given program that can return warnings runs the program and raises any warnings found using handleWarnings",
          "hierarchy": "CSPM",
          "module": "CSPM",
          "name": "reportWarnings",
          "normalized": "a(b,[ErrorMessage])-\u003ea b",
          "package": "libcspm",
          "partial": "Warnings",
          "signature": "m(a,[ErrorMessage])-\u003em a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM.html#v:reportWarnings"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRuns the evaluator in the current state, saving the resulting state.\n\u003c/p\u003e",
          "module": "CSPM",
          "name": "runEvaluatorInCurrentState",
          "package": "libcspm",
          "signature": "EvaluationMonad a -\u003e m a",
          "source": "src/CSPM.html#runEvaluatorInCurrentState",
          "type": "function"
        },
        "index": {
          "description": "Runs the evaluator in the current state saving the resulting state",
          "hierarchy": "CSPM",
          "module": "CSPM",
          "name": "runEvaluatorInCurrentState",
          "normalized": "EvaluationMonad a-\u003eb a",
          "package": "libcspm",
          "partial": "Evaluator In Current State",
          "signature": "EvaluationMonad a-\u003em a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM.html#v:runEvaluatorInCurrentState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRuns the parser.\n\u003c/p\u003e",
          "module": "CSPM",
          "name": "runParserInCurrentState",
          "package": "libcspm",
          "signature": "FilePath -\u003e ParseMonad a -\u003e m a",
          "source": "src/CSPM.html#runParserInCurrentState",
          "type": "function"
        },
        "index": {
          "description": "Runs the parser",
          "hierarchy": "CSPM",
          "module": "CSPM",
          "name": "runParserInCurrentState",
          "normalized": "FilePath-\u003eParseMonad a-\u003eb a",
          "package": "libcspm",
          "partial": "Parser In Current State",
          "signature": "FilePath-\u003eParseMonad a-\u003em a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM.html#v:runParserInCurrentState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRuns renamer in the current state.\n\u003c/p\u003e",
          "module": "CSPM",
          "name": "runRenamerInCurrentState",
          "package": "libcspm",
          "signature": "RenamerMonad a -\u003e m a",
          "source": "src/CSPM.html#runRenamerInCurrentState",
          "type": "function"
        },
        "index": {
          "description": "Runs renamer in the current state",
          "hierarchy": "CSPM",
          "module": "CSPM",
          "name": "runRenamerInCurrentState",
          "normalized": "RenamerMonad a-\u003eb a",
          "package": "libcspm",
          "partial": "Renamer In Current State",
          "signature": "RenamerMonad a-\u003em a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM.html#v:runRenamerInCurrentState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRuns the typechecker in the current state, saving the resulting state and\n returning any warnings encountered.\n\u003c/p\u003e",
          "module": "CSPM",
          "name": "runTypeCheckerInCurrentState",
          "package": "libcspm",
          "signature": "TypeCheckMonad a -\u003e m (a, [ErrorMessage])",
          "source": "src/CSPM.html#runTypeCheckerInCurrentState",
          "type": "function"
        },
        "index": {
          "description": "Runs the typechecker in the current state saving the resulting state and returning any warnings encountered",
          "hierarchy": "CSPM",
          "module": "CSPM",
          "name": "runTypeCheckerInCurrentState",
          "normalized": "TypeCheckMonad a-\u003eb(a,[ErrorMessage])",
          "package": "libcspm",
          "partial": "Type Checker In Current State",
          "signature": "TypeCheckMonad a-\u003em(a,[ErrorMessage])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM.html#v:runTypeCheckerInCurrentState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUpdate the current session.\n\u003c/p\u003e",
          "module": "CSPM",
          "name": "setSession",
          "package": "libcspm",
          "signature": "CSPMSession -\u003e m ()",
          "source": "src/CSPM.html#setSession",
          "type": "method"
        },
        "index": {
          "description": "Update the current session",
          "hierarchy": "CSPM",
          "module": "CSPM",
          "name": "setSession",
          "normalized": "CSPMSession-\u003ea()",
          "package": "libcspm",
          "partial": "Session",
          "signature": "CSPMSession-\u003em()",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM.html#v:setSession"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTakes an expression string and a type and evaluates the expression,\n providing the expression is of the correct type.\n\u003c/p\u003e",
          "module": "CSPM",
          "name": "stringToValue",
          "package": "libcspm",
          "signature": "Type -\u003e String -\u003e m Value",
          "source": "src/CSPM.html#stringToValue",
          "type": "function"
        },
        "index": {
          "description": "Takes an expression string and type and evaluates the expression providing the expression is of the correct type",
          "hierarchy": "CSPM",
          "module": "CSPM",
          "name": "stringToValue",
          "normalized": "Type-\u003eString-\u003ea Value",
          "package": "libcspm",
          "partial": "To Value",
          "signature": "Type-\u003eString-\u003em Value",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM.html#v:stringToValue"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eType checkes a \u003ccode\u003e\u003ca\u003ePExp\u003c/a\u003e\u003c/code\u003e, returning the desugared and annotated version.\n\u003c/p\u003e",
          "module": "CSPM",
          "name": "typeCheckExpression",
          "package": "libcspm",
          "signature": "TCExp -\u003e m TCExp",
          "source": "src/CSPM.html#typeCheckExpression",
          "type": "function"
        },
        "index": {
          "description": "Type checkes PExp returning the desugared and annotated version",
          "hierarchy": "CSPM",
          "module": "CSPM",
          "name": "typeCheckExpression",
          "normalized": "TCExp-\u003ea TCExp",
          "package": "libcspm",
          "partial": "Check Expression",
          "signature": "TCExp-\u003em TCExp",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM.html#v:typeCheckExpression"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eType checks a file, also desugaring and annotating it. Throws a \n \u003ccode\u003e\u003ca\u003eSourceError\u003c/a\u003e\u003c/code\u003e if an error is encountered and will call \u003ccode\u003e\u003ca\u003ehandleWarnings\u003c/a\u003e\u003c/code\u003e on \n any warnings. This also performs desugaraing.\n\u003c/p\u003e",
          "module": "CSPM",
          "name": "typeCheckFile",
          "package": "libcspm",
          "signature": "TCCSPMFile -\u003e m TCCSPMFile",
          "source": "src/CSPM.html#typeCheckFile",
          "type": "function"
        },
        "index": {
          "description": "Type checks file also desugaring and annotating it Throws SourceError if an error is encountered and will call handleWarnings on any warnings This also performs desugaraing",
          "hierarchy": "CSPM",
          "module": "CSPM",
          "name": "typeCheckFile",
          "normalized": "TCCSPMFile-\u003ea TCCSPMFile",
          "package": "libcspm",
          "partial": "Check File",
          "signature": "TCCSPMFile-\u003em TCCSPMFile",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM.html#v:typeCheckFile"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eType checks a \u003ccode\u003e\u003ca\u003ePInteractiveStmt\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "CSPM",
          "name": "typeCheckInteractiveStmt",
          "package": "libcspm",
          "signature": "TCInteractiveStmt -\u003e m TCInteractiveStmt",
          "source": "src/CSPM.html#typeCheckInteractiveStmt",
          "type": "function"
        },
        "index": {
          "description": "Type checks PInteractiveStmt",
          "hierarchy": "CSPM",
          "module": "CSPM",
          "name": "typeCheckInteractiveStmt",
          "normalized": "TCInteractiveStmt-\u003ea TCInteractiveStmt",
          "package": "libcspm",
          "partial": "Check Interactive Stmt",
          "signature": "TCInteractiveStmt-\u003em TCInteractiveStmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM.html#v:typeCheckInteractiveStmt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGets the type of the expression in the current context.\n\u003c/p\u003e",
          "module": "CSPM",
          "name": "typeOfExpression",
          "package": "libcspm",
          "signature": "TCExp -\u003e m Type",
          "source": "src/CSPM.html#typeOfExpression",
          "type": "function"
        },
        "index": {
          "description": "Gets the type of the expression in the current context",
          "hierarchy": "CSPM",
          "module": "CSPM",
          "name": "typeOfExpression",
          "normalized": "TCExp-\u003ea Type",
          "package": "libcspm",
          "partial": "Of Expression",
          "signature": "TCExp-\u003em Type",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM.html#v:typeOfExpression"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturns the type of the given name in the current context.\n\u003c/p\u003e\u003cp\u003eThe file in which this name has been bound must have been typechecked using\n typeCheckFile.\n\u003c/p\u003e",
          "module": "CSPM",
          "name": "typeOfName",
          "package": "libcspm",
          "signature": "Name -\u003e m TypeScheme",
          "source": "src/CSPM.html#typeOfName",
          "type": "function"
        },
        "index": {
          "description": "Returns the type of the given name in the current context The file in which this name has been bound must have been typechecked using typeCheckFile",
          "hierarchy": "CSPM",
          "module": "CSPM",
          "name": "typeOfName",
          "normalized": "Name-\u003ea TypeScheme",
          "package": "libcspm",
          "partial": "Of Name",
          "signature": "Name-\u003em TypeScheme",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM.html#v:typeOfName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRuns a \u003ccode\u003e\u003ca\u003eCSPM\u003c/a\u003e\u003c/code\u003e function, returning the result and the resulting session.\n\u003c/p\u003e",
          "module": "CSPM",
          "name": "unCSPM",
          "package": "libcspm",
          "signature": "CSPMSession -\u003e CSPM a -\u003e IO (a, CSPMSession)",
          "source": "src/CSPM.html#unCSPM",
          "type": "function"
        },
        "index": {
          "description": "Runs CSPM function returning the result and the resulting session",
          "hierarchy": "CSPM",
          "module": "CSPM",
          "name": "unCSPM",
          "normalized": "CSPMSession-\u003eCSPM a-\u003eIO(a,CSPMSession)",
          "package": "libcspm",
          "partial": "CSPM",
          "signature": "CSPMSession-\u003eCSPM a-\u003eIO(a,CSPMSession)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM.html#v:unCSPM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExecutes an operation giving it access to the current \u003ccode\u003e\u003ca\u003eCSPMSession\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "CSPM",
          "name": "withSession",
          "package": "libcspm",
          "signature": "(CSPMSession -\u003e m a) -\u003e m a",
          "source": "src/CSPM.html#withSession",
          "type": "function"
        },
        "index": {
          "description": "Executes an operation giving it access to the current CSPMSession",
          "hierarchy": "CSPM",
          "module": "CSPM",
          "name": "withSession",
          "normalized": "(CSPMSession-\u003ea b)-\u003ea b",
          "package": "libcspm",
          "partial": "Session",
          "signature": "(CSPMSession-\u003em a)-\u003em a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/CSPM.html#v:withSession"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eGraph algorithms in the ST monad.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.Graph.ST",
          "name": "ST",
          "package": "libcspm",
          "source": "src/Data-Graph-ST.html",
          "type": "module"
        },
        "index": {
          "description": "Graph algorithms in the ST monad",
          "hierarchy": "Data Graph ST",
          "module": "Data.Graph.ST",
          "name": "ST",
          "package": "libcspm",
          "partial": "ST",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Data-Graph-ST.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA graph of \u003ccode\u003ea\u003c/code\u003es in the state thread s.\n\u003c/p\u003e\u003cp\u003eWe store the successors in an unboxed array and store indexes into the\n array for the index at which at a node's successors start. This is very\n memory efficient and cache friendly.\n\u003c/p\u003e",
          "module": "Data.Graph.ST",
          "name": "Graph",
          "package": "libcspm",
          "source": "src/Data-Graph-ST.html#Graph",
          "type": "data"
        },
        "index": {
          "description": "graph of in the state thread We store the successors in an unboxed array and store indexes into the array for the index at which at node successors start This is very memory efficient and cache friendly",
          "hierarchy": "Data Graph ST",
          "module": "Data.Graph.ST",
          "name": "Graph",
          "package": "libcspm",
          "partial": "Graph",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Data-Graph-ST.html#t:Graph"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Graph.ST",
          "name": "SCC",
          "package": "libcspm",
          "source": "src/Data-Graph-ST.html#SCC",
          "type": "data"
        },
        "index": {
          "hierarchy": "Data Graph ST",
          "module": "Data.Graph.ST",
          "name": "SCC",
          "package": "libcspm",
          "partial": "SCC",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Data-Graph-ST.html#t:SCC"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Graph.ST",
          "name": "AcyclicSCC",
          "package": "libcspm",
          "signature": "AcyclicSCC a",
          "source": "src/Data-Graph-ST.html#SCC",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Graph ST",
          "module": "Data.Graph.ST",
          "name": "AcyclicSCC",
          "package": "libcspm",
          "partial": "Acyclic SCC",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Data-Graph-ST.html#v:AcyclicSCC"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Graph.ST",
          "name": "CyclicSCC",
          "package": "libcspm",
          "signature": "CyclicSCC [a]",
          "source": "src/Data-Graph-ST.html#SCC",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Graph ST",
          "module": "Data.Graph.ST",
          "name": "CyclicSCC",
          "normalized": "CyclicSCC[a]",
          "package": "libcspm",
          "partial": "Cyclic SCC",
          "signature": "CyclicSCC[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Data-Graph-ST.html#v:CyclicSCC"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Graph.ST",
          "name": "newGraph",
          "package": "libcspm",
          "signature": "[a] -\u003e [(a, a)] -\u003e ST s (Graph s a)",
          "source": "src/Data-Graph-ST.html#newGraph",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Graph ST",
          "module": "Data.Graph.ST",
          "name": "newGraph",
          "normalized": "[a]-\u003e[(a,a)]-\u003eST b(Graph b a)",
          "package": "libcspm",
          "partial": "Graph",
          "signature": "[a]-\u003e[(a,a)]-\u003eST s(Graph s a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Data-Graph-ST.html#v:newGraph"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Graph.ST",
          "name": "newGraphNoDupeNodes",
          "package": "libcspm",
          "signature": "[a] -\u003e [(a, a)] -\u003e ST s (Graph s a)",
          "source": "src/Data-Graph-ST.html#newGraphNoDupeNodes",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Graph ST",
          "module": "Data.Graph.ST",
          "name": "newGraphNoDupeNodes",
          "normalized": "[a]-\u003e[(a,a)]-\u003eST b(Graph b a)",
          "package": "libcspm",
          "partial": "Graph No Dupe Nodes",
          "signature": "[a]-\u003e[(a,a)]-\u003eST s(Graph s a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Data-Graph-ST.html#v:newGraphNoDupeNodes"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGiven a graph, computes the transitive (but not reflexive) closure of the\n graph and then returns the relation (a,b) such that b is the representative\n member for a. Note, no pairs of the form a == b are returned, even if there\n is an edge from a to b. This is to minimise the size of the transitive\n closure.\n\u003c/p\u003e",
          "module": "Data.Graph.ST",
          "name": "nonReflexiveRepresentativesForNodes",
          "package": "libcspm",
          "signature": "Graph s a -\u003e ST s [(a, a)]",
          "source": "src/Data-Graph-ST.html#nonReflexiveRepresentativesForNodes",
          "type": "function"
        },
        "index": {
          "description": "Given graph computes the transitive but not reflexive closure of the graph and then returns the relation such that is the representative member for Note no pairs of the form are returned even if there is an edge from to This is to minimise the size of the transitive closure",
          "hierarchy": "Data Graph ST",
          "module": "Data.Graph.ST",
          "name": "nonReflexiveRepresentativesForNodes",
          "normalized": "Graph a b-\u003eST a[(b,b)]",
          "package": "libcspm",
          "partial": "Reflexive Representatives For Nodes",
          "signature": "Graph s a-\u003eST s[(a,a)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Data-Graph-ST.html#v:nonReflexiveRepresentativesForNodes"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn optimised implementation of Tarjan's SCC algorithm.\n\u003c/p\u003e",
          "module": "Data.Graph.ST",
          "name": "sccs",
          "package": "libcspm",
          "signature": "Graph s a -\u003e ST s [SCC a]",
          "source": "src/Data-Graph-ST.html#sccs",
          "type": "function"
        },
        "index": {
          "description": "An optimised implementation of Tarjan SCC algorithm",
          "hierarchy": "Data Graph ST",
          "module": "Data.Graph.ST",
          "name": "sccs",
          "normalized": "Graph a b-\u003eST a[SCC b]",
          "package": "libcspm",
          "signature": "Graph s a-\u003eST s[SCC a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Data-Graph-ST.html#v:sccs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Graph.ST",
          "name": "successorNodes",
          "package": "libcspm",
          "signature": "Graph s a -\u003e a -\u003e ST s [a]",
          "source": "src/Data-Graph-ST.html#successorNodes",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Graph ST",
          "module": "Data.Graph.ST",
          "name": "successorNodes",
          "normalized": "Graph a b-\u003eb-\u003eST a[b]",
          "package": "libcspm",
          "partial": "Nodes",
          "signature": "Graph s a-\u003ea-\u003eST s[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Data-Graph-ST.html#v:successorNodes"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eBit sets represent sets of integers by setting bit i to 1 iff i is in the\n set. This means they can effeciently support many operations, like union\n (bitwise or), intersection (bitwise and) etc. However, they obviously\n can only represent sets of relatively small integers, as they require\n O(max(S)) bits.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.Set.MutableBit",
          "name": "MutableBit",
          "package": "libcspm",
          "source": "src/Data-Set-MutableBit.html",
          "type": "module"
        },
        "index": {
          "description": "Bit sets represent sets of integers by setting bit to iff is in the set This means they can effeciently support many operations like union bitwise or intersection bitwise and etc However they obviously can only represent sets of relatively small integers as they require max bits",
          "hierarchy": "Data Set MutableBit",
          "module": "Data.Set.MutableBit",
          "name": "MutableBit",
          "package": "libcspm",
          "partial": "Mutable Bit",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Data-Set-MutableBit.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Set.MutableBit",
          "name": "Set",
          "package": "libcspm",
          "source": "src/Data-Set-MutableBit.html#Set",
          "type": "type"
        },
        "index": {
          "hierarchy": "Data Set MutableBit",
          "module": "Data.Set.MutableBit",
          "name": "Set",
          "package": "libcspm",
          "partial": "Set",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Data-Set-MutableBit.html#t:Set"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Set.MutableBit",
          "name": "insert",
          "package": "libcspm",
          "signature": "Set s -\u003e Int -\u003e ST s ()",
          "source": "src/Data-Set-MutableBit.html#insert",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Set MutableBit",
          "module": "Data.Set.MutableBit",
          "name": "insert",
          "normalized": "Set a-\u003eInt-\u003eST a()",
          "package": "libcspm",
          "signature": "Set s-\u003eInt-\u003eST s()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Data-Set-MutableBit.html#v:insert"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Set.MutableBit",
          "name": "member",
          "package": "libcspm",
          "signature": "Set s -\u003e Int -\u003e ST s Bool",
          "source": "src/Data-Set-MutableBit.html#member",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Set MutableBit",
          "module": "Data.Set.MutableBit",
          "name": "member",
          "normalized": "Set a-\u003eInt-\u003eST a Bool",
          "package": "libcspm",
          "signature": "Set s-\u003eInt-\u003eST s Bool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Data-Set-MutableBit.html#v:member"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Set.MutableBit",
          "name": "newSized",
          "package": "libcspm",
          "signature": "Int -\u003e ST s (Set s)",
          "source": "src/Data-Set-MutableBit.html#newSized",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Set MutableBit",
          "module": "Data.Set.MutableBit",
          "name": "newSized",
          "normalized": "Int-\u003eST a(Set a)",
          "package": "libcspm",
          "partial": "Sized",
          "signature": "Int-\u003eST s(Set s)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Data-Set-MutableBit.html#v:newSized"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Set.MutableBit",
          "name": "remove",
          "package": "libcspm",
          "signature": "Set s -\u003e Int -\u003e ST s ()",
          "source": "src/Data-Set-MutableBit.html#remove",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Set MutableBit",
          "module": "Data.Set.MutableBit",
          "name": "remove",
          "normalized": "Set a-\u003eInt-\u003eST a()",
          "package": "libcspm",
          "signature": "Set s-\u003eInt-\u003eST s()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Data-Set-MutableBit.html#v:remove"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Annotated",
          "name": "Annotated",
          "package": "libcspm",
          "source": "src/Util-Annotated.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Util Annotated",
          "module": "Util.Annotated",
          "name": "Annotated",
          "package": "libcspm",
          "partial": "Annotated",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Util-Annotated.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Annotated",
          "name": "Annotated",
          "package": "libcspm",
          "source": "src/Util-Annotated.html#Annotated",
          "type": "data"
        },
        "index": {
          "hierarchy": "Util Annotated",
          "module": "Util.Annotated",
          "name": "Annotated",
          "package": "libcspm",
          "partial": "Annotated",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Util-Annotated.html#t:Annotated"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Annotated",
          "name": "Located",
          "package": "libcspm",
          "source": "src/Util-Annotated.html#Located",
          "type": "data"
        },
        "index": {
          "hierarchy": "Util Annotated",
          "module": "Util.Annotated",
          "name": "Located",
          "package": "libcspm",
          "partial": "Located",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Util-Annotated.html#t:Located"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Annotated",
          "name": "SrcLoc",
          "package": "libcspm",
          "source": "src/Util-Annotated.html#SrcLoc",
          "type": "data"
        },
        "index": {
          "hierarchy": "Util Annotated",
          "module": "Util.Annotated",
          "name": "SrcLoc",
          "package": "libcspm",
          "partial": "Src Loc",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Util-Annotated.html#t:SrcLoc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Annotated",
          "name": "SrcSpan",
          "package": "libcspm",
          "source": "src/Util-Annotated.html#SrcSpan",
          "type": "data"
        },
        "index": {
          "hierarchy": "Util Annotated",
          "module": "Util.Annotated",
          "name": "SrcSpan",
          "package": "libcspm",
          "partial": "Src Span",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Util-Annotated.html#t:SrcSpan"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Annotated",
          "name": "An",
          "package": "libcspm",
          "signature": "An",
          "source": "src/Util-Annotated.html#Annotated",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util Annotated",
          "module": "Util.Annotated",
          "name": "An",
          "package": "libcspm",
          "partial": "An",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Util-Annotated.html#v:An"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA builtin thing\n\u003c/p\u003e",
          "module": "Util.Annotated",
          "name": "BuiltIn",
          "package": "libcspm",
          "signature": "BuiltIn",
          "source": "src/Util-Annotated.html#SrcSpan",
          "type": "function"
        },
        "index": {
          "description": "builtin thing",
          "hierarchy": "Util Annotated",
          "module": "Util.Annotated",
          "name": "BuiltIn",
          "package": "libcspm",
          "partial": "Built In",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Util-Annotated.html#v:BuiltIn"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Annotated",
          "name": "L",
          "package": "libcspm",
          "signature": "L",
          "source": "src/Util-Annotated.html#Located",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util Annotated",
          "module": "Util.Annotated",
          "name": "L",
          "package": "libcspm",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Util-Annotated.html#v:L"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Annotated",
          "name": "NoLoc",
          "package": "libcspm",
          "signature": "NoLoc",
          "source": "src/Util-Annotated.html#SrcLoc",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util Annotated",
          "module": "Util.Annotated",
          "name": "NoLoc",
          "package": "libcspm",
          "partial": "No Loc",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Util-Annotated.html#v:NoLoc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Annotated",
          "name": "SrcLoc",
          "package": "libcspm",
          "signature": "SrcLoc",
          "source": "src/Util-Annotated.html#SrcLoc",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util Annotated",
          "module": "Util.Annotated",
          "name": "SrcLoc",
          "package": "libcspm",
          "partial": "Src Loc",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Util-Annotated.html#v:SrcLoc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Annotated",
          "name": "SrcSpanMultiLine",
          "package": "libcspm",
          "signature": "SrcSpanMultiLine",
          "source": "src/Util-Annotated.html#SrcSpan",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util Annotated",
          "module": "Util.Annotated",
          "name": "SrcSpanMultiLine",
          "package": "libcspm",
          "partial": "Src Span Multi Line",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Util-Annotated.html#v:SrcSpanMultiLine"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Annotated",
          "name": "SrcSpanOneLine",
          "package": "libcspm",
          "signature": "SrcSpanOneLine",
          "source": "src/Util-Annotated.html#SrcSpan",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util Annotated",
          "module": "Util.Annotated",
          "name": "SrcSpanOneLine",
          "package": "libcspm",
          "partial": "Src Span One Line",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Util-Annotated.html#v:SrcSpanOneLine"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Annotated",
          "name": "SrcSpanPoint",
          "package": "libcspm",
          "signature": "SrcSpanPoint",
          "source": "src/Util-Annotated.html#SrcSpan",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util Annotated",
          "module": "Util.Annotated",
          "name": "SrcSpanPoint",
          "package": "libcspm",
          "partial": "Src Span Point",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Util-Annotated.html#v:SrcSpanPoint"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Annotated",
          "name": "Unknown",
          "package": "libcspm",
          "signature": "Unknown",
          "source": "src/Util-Annotated.html#SrcSpan",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util Annotated",
          "module": "Util.Annotated",
          "name": "Unknown",
          "package": "libcspm",
          "partial": "Unknown",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Util-Annotated.html#v:Unknown"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Annotated",
          "name": "annotation",
          "package": "libcspm",
          "signature": "a",
          "source": "src/Util-Annotated.html#Annotated",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util Annotated",
          "module": "Util.Annotated",
          "name": "annotation",
          "package": "libcspm",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Util-Annotated.html#v:annotation"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Annotated",
          "name": "combineSpans",
          "package": "libcspm",
          "signature": "SrcSpan -\u003e SrcSpan -\u003e SrcSpan",
          "source": "src/Util-Annotated.html#combineSpans",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util Annotated",
          "module": "Util.Annotated",
          "name": "combineSpans",
          "normalized": "SrcSpan-\u003eSrcSpan-\u003eSrcSpan",
          "package": "libcspm",
          "partial": "Spans",
          "signature": "SrcSpan-\u003eSrcSpan-\u003eSrcSpan",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Util-Annotated.html#v:combineSpans"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Annotated",
          "name": "dummyAnnotation",
          "package": "libcspm",
          "signature": "a",
          "source": "src/Util-Annotated.html#dummyAnnotation",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util Annotated",
          "module": "Util.Annotated",
          "name": "dummyAnnotation",
          "package": "libcspm",
          "partial": "Annotation",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Util-Annotated.html#v:dummyAnnotation"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Annotated",
          "name": "inner",
          "package": "libcspm",
          "signature": "b",
          "source": "src/Util-Annotated.html#Annotated",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util Annotated",
          "module": "Util.Annotated",
          "name": "inner",
          "package": "libcspm",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Util-Annotated.html#v:inner"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Annotated",
          "name": "loc",
          "package": "libcspm",
          "signature": "SrcSpan",
          "source": "src/Util-Annotated.html#Annotated",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util Annotated",
          "module": "Util.Annotated",
          "name": "loc",
          "package": "libcspm",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Util-Annotated.html#v:loc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Annotated",
          "name": "locatedInner",
          "package": "libcspm",
          "signature": "a",
          "source": "src/Util-Annotated.html#Located",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util Annotated",
          "module": "Util.Annotated",
          "name": "locatedInner",
          "package": "libcspm",
          "partial": "Inner",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Util-Annotated.html#v:locatedInner"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Annotated",
          "name": "locatedLoc",
          "package": "libcspm",
          "signature": "SrcSpan",
          "source": "src/Util-Annotated.html#Located",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util Annotated",
          "module": "Util.Annotated",
          "name": "locatedLoc",
          "package": "libcspm",
          "partial": "Loc",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Util-Annotated.html#v:locatedLoc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Annotated",
          "name": "srcLocCol",
          "package": "libcspm",
          "signature": "Int",
          "source": "src/Util-Annotated.html#SrcLoc",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util Annotated",
          "module": "Util.Annotated",
          "name": "srcLocCol",
          "package": "libcspm",
          "partial": "Loc Col",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Util-Annotated.html#v:srcLocCol"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Annotated",
          "name": "srcLocFile",
          "package": "libcspm",
          "signature": "String",
          "source": "src/Util-Annotated.html#SrcLoc",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util Annotated",
          "module": "Util.Annotated",
          "name": "srcLocFile",
          "package": "libcspm",
          "partial": "Loc File",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Util-Annotated.html#v:srcLocFile"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Annotated",
          "name": "srcLocLine",
          "package": "libcspm",
          "signature": "Int",
          "source": "src/Util-Annotated.html#SrcLoc",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util Annotated",
          "module": "Util.Annotated",
          "name": "srcLocLine",
          "package": "libcspm",
          "partial": "Loc Line",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Util-Annotated.html#v:srcLocLine"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Annotated",
          "name": "srcSpanCol",
          "package": "libcspm",
          "signature": "Int",
          "source": "src/Util-Annotated.html#SrcSpan",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util Annotated",
          "module": "Util.Annotated",
          "name": "srcSpanCol",
          "package": "libcspm",
          "partial": "Span Col",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Util-Annotated.html#v:srcSpanCol"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Annotated",
          "name": "srcSpanECol",
          "package": "libcspm",
          "signature": "Int",
          "source": "src/Util-Annotated.html#SrcSpan",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util Annotated",
          "module": "Util.Annotated",
          "name": "srcSpanECol",
          "package": "libcspm",
          "partial": "Span ECol",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Util-Annotated.html#v:srcSpanECol"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Annotated",
          "name": "srcSpanELine",
          "package": "libcspm",
          "signature": "Int",
          "source": "src/Util-Annotated.html#SrcSpan",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util Annotated",
          "module": "Util.Annotated",
          "name": "srcSpanELine",
          "package": "libcspm",
          "partial": "Span ELine",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Util-Annotated.html#v:srcSpanELine"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Annotated",
          "name": "srcSpanEnd",
          "package": "libcspm",
          "signature": "SrcSpan -\u003e SrcLoc",
          "source": "src/Util-Annotated.html#srcSpanEnd",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util Annotated",
          "module": "Util.Annotated",
          "name": "srcSpanEnd",
          "normalized": "SrcSpan-\u003eSrcLoc",
          "package": "libcspm",
          "partial": "Span End",
          "signature": "SrcSpan-\u003eSrcLoc",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Util-Annotated.html#v:srcSpanEnd"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Annotated",
          "name": "srcSpanFile",
          "package": "libcspm",
          "signature": "String",
          "source": "src/Util-Annotated.html#SrcSpan",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util Annotated",
          "module": "Util.Annotated",
          "name": "srcSpanFile",
          "package": "libcspm",
          "partial": "Span File",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Util-Annotated.html#v:srcSpanFile"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Annotated",
          "name": "srcSpanLine",
          "package": "libcspm",
          "signature": "Int",
          "source": "src/Util-Annotated.html#SrcSpan",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util Annotated",
          "module": "Util.Annotated",
          "name": "srcSpanLine",
          "package": "libcspm",
          "partial": "Span Line",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Util-Annotated.html#v:srcSpanLine"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Annotated",
          "name": "srcSpanSCol",
          "package": "libcspm",
          "signature": "Int",
          "source": "src/Util-Annotated.html#SrcSpan",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util Annotated",
          "module": "Util.Annotated",
          "name": "srcSpanSCol",
          "package": "libcspm",
          "partial": "Span SCol",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Util-Annotated.html#v:srcSpanSCol"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Annotated",
          "name": "srcSpanSLine",
          "package": "libcspm",
          "signature": "Int",
          "source": "src/Util-Annotated.html#SrcSpan",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util Annotated",
          "module": "Util.Annotated",
          "name": "srcSpanSLine",
          "package": "libcspm",
          "partial": "Span SLine",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Util-Annotated.html#v:srcSpanSLine"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Annotated",
          "name": "srcSpanStart",
          "package": "libcspm",
          "signature": "SrcSpan -\u003e SrcLoc",
          "source": "src/Util-Annotated.html#srcSpanStart",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util Annotated",
          "module": "Util.Annotated",
          "name": "srcSpanStart",
          "normalized": "SrcSpan-\u003eSrcLoc",
          "package": "libcspm",
          "partial": "Span Start",
          "signature": "SrcSpan-\u003eSrcLoc",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Util-Annotated.html#v:srcSpanStart"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Annotated",
          "name": "unAnnotate",
          "package": "libcspm",
          "signature": "Annotated a b -\u003e b",
          "source": "src/Util-Annotated.html#unAnnotate",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util Annotated",
          "module": "Util.Annotated",
          "name": "unAnnotate",
          "normalized": "Annotated a b-\u003eb",
          "package": "libcspm",
          "partial": "Annotate",
          "signature": "Annotated a b-\u003eb",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Util-Annotated.html#v:unAnnotate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Exception",
          "name": "Exception",
          "package": "libcspm",
          "source": "src/Util-Exception.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Util Exception",
          "module": "Util.Exception",
          "name": "Exception",
          "package": "libcspm",
          "partial": "Exception",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Util-Exception.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn error message that resulted from something in the user's input.\n\u003c/p\u003e",
          "module": "Util.Exception",
          "name": "ErrorMessage",
          "package": "libcspm",
          "source": "src/Util-Exception.html#ErrorMessage",
          "type": "data"
        },
        "index": {
          "description": "An error message that resulted from something in the user input",
          "hierarchy": "Util Exception",
          "module": "Util.Exception",
          "name": "ErrorMessage",
          "package": "libcspm",
          "partial": "Error Message",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Util-Exception.html#t:ErrorMessage"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Exception",
          "name": "ErrorMessages",
          "package": "libcspm",
          "source": "src/Util-Exception.html#ErrorMessages",
          "type": "type"
        },
        "index": {
          "hierarchy": "Util Exception",
          "module": "Util.Exception",
          "name": "ErrorMessages",
          "package": "libcspm",
          "partial": "Error Messages",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Util-Exception.html#t:ErrorMessages"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAny type that you wish to throw or catch as an exception must be an\ninstance of the \u003ccode\u003eException\u003c/code\u003e class. The simplest case is a new exception\ntype directly below the root:\n\u003c/p\u003e\u003cpre\u003e data MyException = ThisException | ThatException\n     deriving (Show, Typeable)\n\n instance Exception MyException\n\u003c/pre\u003e\u003cp\u003eThe default method definitions in the \u003ccode\u003eException\u003c/code\u003e class do what we need\nin this case. You can now throw and catch \u003ccode\u003eThisException\u003c/code\u003e and\n\u003ccode\u003eThatException\u003c/code\u003e as exceptions:\n\u003c/p\u003e\u003cpre\u003e\n*Main\u003e throw ThisException `catch` \\e -\u003e putStrLn (\"Caught \" ++ show (e :: MyException))\nCaught ThisException\n\u003c/pre\u003e\u003cp\u003eIn more complicated examples, you may wish to define a whole hierarchy\nof exceptions:\n\u003c/p\u003e\u003cpre\u003e ---------------------------------------------------------------------\n -- Make the root exception type for all the exceptions in a compiler\n\n data SomeCompilerException = forall e . Exception e =\u003e SomeCompilerException e\n     deriving Typeable\n\n instance Show SomeCompilerException where\n     show (SomeCompilerException e) = show e\n\n instance Exception SomeCompilerException\n\n compilerExceptionToException :: Exception e =\u003e e -\u003e SomeException\n compilerExceptionToException = toException . SomeCompilerException\n\n compilerExceptionFromException :: Exception e =\u003e SomeException -\u003e Maybe e\n compilerExceptionFromException x = do\n     SomeCompilerException a \u003c- fromException x\n     cast a\n\n ---------------------------------------------------------------------\n -- Make a subhierarchy for exceptions in the frontend of the compiler\n\n data SomeFrontendException = forall e . Exception e =\u003e SomeFrontendException e\n     deriving Typeable\n\n instance Show SomeFrontendException where\n     show (SomeFrontendException e) = show e\n\n instance Exception SomeFrontendException where\n     toException = compilerExceptionToException\n     fromException = compilerExceptionFromException\n\n frontendExceptionToException :: Exception e =\u003e e -\u003e SomeException\n frontendExceptionToException = toException . SomeFrontendException\n\n frontendExceptionFromException :: Exception e =\u003e SomeException -\u003e Maybe e\n frontendExceptionFromException x = do\n     SomeFrontendException a \u003c- fromException x\n     cast a\n\n ---------------------------------------------------------------------\n -- Make an exception type for a particular frontend compiler exception\n\n data MismatchedParentheses = MismatchedParentheses\n     deriving (Typeable, Show)\n\n instance Exception MismatchedParentheses where\n     toException   = frontendExceptionToException\n     fromException = frontendExceptionFromException\n\u003c/pre\u003e\u003cp\u003eWe can now catch a \u003ccode\u003eMismatchedParentheses\u003c/code\u003e exception as\n\u003ccode\u003eMismatchedParentheses\u003c/code\u003e, \u003ccode\u003eSomeFrontendException\u003c/code\u003e or\n\u003ccode\u003eSomeCompilerException\u003c/code\u003e, but not other types, e.g. \u003ccode\u003eIOException\u003c/code\u003e:\n\u003c/p\u003e\u003cpre\u003e\n*Main\u003e throw MismatchedParentheses \u003ccode\u003ecatch\u003c/code\u003e e -\u003e putStrLn (\"Caught \" ++ show (e :: MismatchedParentheses))\nCaught MismatchedParentheses\n*Main\u003e throw MismatchedParentheses \u003ccode\u003ecatch\u003c/code\u003e e -\u003e putStrLn (\"Caught \" ++ show (e :: SomeFrontendException))\nCaught MismatchedParentheses\n*Main\u003e throw MismatchedParentheses \u003ccode\u003ecatch\u003c/code\u003e e -\u003e putStrLn (\"Caught \" ++ show (e :: SomeCompilerException))\nCaught MismatchedParentheses\n*Main\u003e throw MismatchedParentheses \u003ccode\u003ecatch\u003c/code\u003e e -\u003e putStrLn (\"Caught \" ++ show (e :: IOException))\n*** Exception: MismatchedParentheses\n\u003c/pre\u003e",
          "module": "Util.Exception",
          "name": "Exception",
          "package": "libcspm",
          "type": "class"
        },
        "index": {
          "description": "Any type that you wish to throw or catch as an exception must be an instance of the Exception class The simplest case is new exception type directly below the root data MyException ThisException ThatException deriving Show Typeable instance Exception MyException The default method definitions in the Exception class do what we need in this case You can now throw and catch ThisException and ThatException as exceptions Main throw ThisException catch putStrLn Caught show MyException Caught ThisException In more complicated examples you may wish to define whole hierarchy of exceptions Make the root exception type for all the exceptions in compiler data SomeCompilerException forall Exception SomeCompilerException deriving Typeable instance Show SomeCompilerException where show SomeCompilerException show instance Exception SomeCompilerException compilerExceptionToException Exception SomeException compilerExceptionToException toException SomeCompilerException compilerExceptionFromException Exception SomeException Maybe compilerExceptionFromException do SomeCompilerException fromException cast Make subhierarchy for exceptions in the frontend of the compiler data SomeFrontendException forall Exception SomeFrontendException deriving Typeable instance Show SomeFrontendException where show SomeFrontendException show instance Exception SomeFrontendException where toException compilerExceptionToException fromException compilerExceptionFromException frontendExceptionToException Exception SomeException frontendExceptionToException toException SomeFrontendException frontendExceptionFromException Exception SomeException Maybe frontendExceptionFromException do SomeFrontendException fromException cast Make an exception type for particular frontend compiler exception data MismatchedParentheses MismatchedParentheses deriving Typeable Show instance Exception MismatchedParentheses where toException frontendExceptionToException fromException frontendExceptionFromException We can now catch MismatchedParentheses exception as MismatchedParentheses SomeFrontendException or SomeCompilerException but not other types e.g IOException Main throw MismatchedParentheses catch putStrLn Caught show MismatchedParentheses Caught MismatchedParentheses Main throw MismatchedParentheses catch putStrLn Caught show SomeFrontendException Caught MismatchedParentheses Main throw MismatchedParentheses catch putStrLn Caught show SomeCompilerException Caught MismatchedParentheses Main throw MismatchedParentheses catch putStrLn Caught show IOException Exception MismatchedParentheses",
          "hierarchy": "Util Exception",
          "module": "Util.Exception",
          "name": "Exception",
          "package": "libcspm",
          "partial": "Exception",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Util-Exception.html#t:Exception"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExceptions that cause LibCSPM to abort whatever it is doing. \n\u003c/p\u003e",
          "module": "Util.Exception",
          "name": "LibCSPMException",
          "package": "libcspm",
          "source": "src/Util-Exception.html#LibCSPMException",
          "type": "data"
        },
        "index": {
          "description": "Exceptions that cause LibCSPM to abort whatever it is doing",
          "hierarchy": "Util Exception",
          "module": "Util.Exception",
          "name": "LibCSPMException",
          "package": "libcspm",
          "partial": "Lib CSPMException",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Util-Exception.html#t:LibCSPMException"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA class to allow catching of SourceErrors in arbitrary monads.\n\u003c/p\u003e",
          "module": "Util.Exception",
          "name": "MonadIOException",
          "package": "libcspm",
          "source": "src/Util-Exception.html#MonadIOException",
          "type": "class"
        },
        "index": {
          "description": "class to allow catching of SourceErrors in arbitrary monads",
          "hierarchy": "Util Exception",
          "module": "Util.Exception",
          "name": "MonadIOException",
          "package": "libcspm",
          "partial": "Monad IOException",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Util-Exception.html#t:MonadIOException"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Exception",
          "name": "ErrorMessage",
          "package": "libcspm",
          "signature": "ErrorMessage",
          "source": "src/Util-Exception.html#ErrorMessage",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util Exception",
          "module": "Util.Exception",
          "name": "ErrorMessage",
          "package": "libcspm",
          "partial": "Error Message",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Util-Exception.html#v:ErrorMessage"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn unexpected internal error\n\u003c/p\u003e",
          "module": "Util.Exception",
          "name": "Panic",
          "package": "libcspm",
          "signature": "Panic String",
          "source": "src/Util-Exception.html#LibCSPMException",
          "type": "function"
        },
        "index": {
          "description": "An unexpected internal error",
          "hierarchy": "Util Exception",
          "module": "Util.Exception",
          "name": "Panic",
          "package": "libcspm",
          "partial": "Panic",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Util-Exception.html#v:Panic"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn error in the user's input occured\n\u003c/p\u003e",
          "module": "Util.Exception",
          "name": "SourceError",
          "package": "libcspm",
          "signature": "SourceError ErrorMessages",
          "source": "src/Util-Exception.html#LibCSPMException",
          "type": "function"
        },
        "index": {
          "description": "An error in the user input occured",
          "hierarchy": "Util Exception",
          "module": "Util.Exception",
          "name": "SourceError",
          "package": "libcspm",
          "partial": "Source Error",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Util-Exception.html#v:SourceError"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn error occured. Normally this is caught by the application and \n then turned into a SourceError.\n\u003c/p\u003e",
          "module": "Util.Exception",
          "name": "UserError",
          "package": "libcspm",
          "signature": "UserError",
          "source": "src/Util-Exception.html#LibCSPMException",
          "type": "function"
        },
        "index": {
          "description": "An error occured Normally this is caught by the application and then turned into SourceError",
          "hierarchy": "Util Exception",
          "module": "Util.Exception",
          "name": "UserError",
          "package": "libcspm",
          "partial": "User Error",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Util-Exception.html#v:UserError"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Exception",
          "name": "WarningMessage",
          "package": "libcspm",
          "signature": "WarningMessage",
          "source": "src/Util-Exception.html#ErrorMessage",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util Exception",
          "module": "Util.Exception",
          "name": "WarningMessage",
          "package": "libcspm",
          "partial": "Warning Message",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Util-Exception.html#v:WarningMessage"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConverts arbitrary exceptions to panics, rethrowing them.\n\u003c/p\u003e",
          "module": "Util.Exception",
          "name": "convertExceptionsToPanics",
          "package": "libcspm",
          "signature": "m a -\u003e m a",
          "source": "src/Util-Exception.html#convertExceptionsToPanics",
          "type": "method"
        },
        "index": {
          "description": "Converts arbitrary exceptions to panics rethrowing them",
          "hierarchy": "Util Exception",
          "module": "Util.Exception",
          "name": "convertExceptionsToPanics",
          "normalized": "a b-\u003ea b",
          "package": "libcspm",
          "partial": "Exceptions To Panics",
          "signature": "m a-\u003em a",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Util-Exception.html#v:convertExceptionsToPanics"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRuns the action, running the finaliser if an exception is thrown. The\n exception is always rethrown.\n\u003c/p\u003e",
          "module": "Util.Exception",
          "name": "finally",
          "package": "libcspm",
          "signature": "m a -\u003e m () -\u003e m a",
          "source": "src/Util-Exception.html#finally",
          "type": "method"
        },
        "index": {
          "description": "Runs the action running the finaliser if an exception is thrown The exception is always rethrown",
          "hierarchy": "Util Exception",
          "module": "Util.Exception",
          "name": "finally",
          "normalized": "a b-\u003ea()-\u003ea b",
          "package": "libcspm",
          "signature": "m a-\u003em()-\u003em a",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Util-Exception.html#v:finally"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUsed for sorting into order.\n\u003c/p\u003e\u003cp\u003eUsed for sorting into order.\n\u003c/p\u003e",
          "module": "Util.Exception",
          "name": "location",
          "package": "libcspm",
          "signature": "SrcSpan",
          "source": "src/Util-Exception.html#ErrorMessage",
          "type": "function"
        },
        "index": {
          "description": "Used for sorting into order Used for sorting into order",
          "hierarchy": "Util Exception",
          "module": "Util.Exception",
          "name": "location",
          "package": "libcspm",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Util-Exception.html#v:location"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe message.\n\u003c/p\u003e\u003cp\u003eThe message.\n\u003c/p\u003e",
          "module": "Util.Exception",
          "name": "message",
          "package": "libcspm",
          "signature": "Doc",
          "source": "src/Util-Exception.html#ErrorMessage",
          "type": "function"
        },
        "index": {
          "description": "The message The message",
          "hierarchy": "Util Exception",
          "module": "Util.Exception",
          "name": "message",
          "package": "libcspm",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Util-Exception.html#v:message"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGiven a \u003ccode\u003e\u003ca\u003eSrcSpan\u003c/a\u003e\u003c/code\u003e and a pretty printed \u003ccode\u003e\u003ca\u003eDoc\u003c/a\u003e\u003c/code\u003e creates an \u003ccode\u003e\u003ca\u003eErrorMessage\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Util.Exception",
          "name": "mkErrorMessage",
          "package": "libcspm",
          "signature": "SrcSpan -\u003e Doc -\u003e ErrorMessage",
          "source": "src/Util-Exception.html#mkErrorMessage",
          "type": "function"
        },
        "index": {
          "description": "Given SrcSpan and pretty printed Doc creates an ErrorMessage",
          "hierarchy": "Util Exception",
          "module": "Util.Exception",
          "name": "mkErrorMessage",
          "normalized": "SrcSpan-\u003eDoc-\u003eErrorMessage",
          "package": "libcspm",
          "partial": "Error Message",
          "signature": "SrcSpan-\u003eDoc-\u003eErrorMessage",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Util-Exception.html#v:mkErrorMessage"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstructs a warning from a \u003ccode\u003e\u003ca\u003eSrcSpan\u003c/a\u003e\u003c/code\u003e and a pretty printed \u003ccode\u003e\u003ca\u003eDoc\u003c/a\u003e\u003c/code\u003e,\n prepending \u003ccode\u003eWarning: \u003c/code\u003e to the \u003ccode\u003e\u003ca\u003eDoc\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Util.Exception",
          "name": "mkWarningMessage",
          "package": "libcspm",
          "signature": "SrcSpan -\u003e Doc -\u003e ErrorMessage",
          "source": "src/Util-Exception.html#mkWarningMessage",
          "type": "function"
        },
        "index": {
          "description": "Constructs warning from SrcSpan and pretty printed Doc prepending Warning to the Doc",
          "hierarchy": "Util Exception",
          "module": "Util.Exception",
          "name": "mkWarningMessage",
          "normalized": "SrcSpan-\u003eDoc-\u003eErrorMessage",
          "package": "libcspm",
          "partial": "Warning Message",
          "signature": "SrcSpan-\u003eDoc-\u003eErrorMessage",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Util-Exception.html#v:mkWarningMessage"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThrows an arbitrary \u003ccode\u003e\u003ca\u003eException\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Util.Exception",
          "name": "throwException",
          "package": "libcspm",
          "signature": "e -\u003e a",
          "source": "src/Util-Exception.html#throwException",
          "type": "function"
        },
        "index": {
          "description": "Throws an arbitrary Exception",
          "hierarchy": "Util Exception",
          "module": "Util.Exception",
          "name": "throwException",
          "normalized": "a-\u003eb",
          "package": "libcspm",
          "partial": "Exception",
          "signature": "e-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Util-Exception.html#v:throwException"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRuns the action, catching any non-fatal LibCSPMExecptions (i.e. non-\n Panic).\n\u003c/p\u003e",
          "module": "Util.Exception",
          "name": "tryM",
          "package": "libcspm",
          "signature": "m a -\u003e m (Either LibCSPMException a)",
          "source": "src/Util-Exception.html#tryM",
          "type": "method"
        },
        "index": {
          "description": "Runs the action catching any non-fatal LibCSPMExecptions i.e non Panic",
          "hierarchy": "Util Exception",
          "module": "Util.Exception",
          "name": "tryM",
          "normalized": "a b-\u003ea(Either LibCSPMException b)",
          "package": "libcspm",
          "signature": "m a-\u003em(Either LibCSPMException a)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Util-Exception.html#v:tryM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRuns the action, catching all exceptions including panics.\n\u003c/p\u003e",
          "module": "Util.Exception",
          "name": "tryM'",
          "package": "libcspm",
          "signature": "m a -\u003e m (Either LibCSPMException a)",
          "source": "src/Util-Exception.html#tryM%27",
          "type": "method"
        },
        "index": {
          "description": "Runs the action catching all exceptions including panics",
          "hierarchy": "Util Exception",
          "module": "Util.Exception",
          "name": "tryM'",
          "normalized": "a b-\u003ea(Either LibCSPMException b)",
          "package": "libcspm",
          "partial": "M'",
          "signature": "m a-\u003em(Either LibCSPMException a)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Util-Exception.html#v:tryM-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eProvides fuzzy string matching.\n\u003c/p\u003e\u003cp\u003eTaken from GHC (which is BSD licensed and thus compatible). Copyright\n reproduced below:\n\u003c/p\u003e\u003cp\u003e(c) The University of Glasgow 2006\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Util.FuzzyLookup",
          "name": "FuzzyLookup",
          "package": "libcspm",
          "source": "src/Util-FuzzyLookup.html",
          "type": "module"
        },
        "index": {
          "description": "Provides fuzzy string matching Taken from GHC which is BSD licensed and thus compatible Copyright reproduced below The University of Glasgow",
          "hierarchy": "Util FuzzyLookup",
          "module": "Util.FuzzyLookup",
          "name": "FuzzyLookup",
          "package": "libcspm",
          "partial": "Fuzzy Lookup",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Util-FuzzyLookup.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSearch for possible matches to the users input in the given list,\n returning a small number of ranked results\n\u003c/p\u003e",
          "module": "Util.FuzzyLookup",
          "name": "fuzzyLookup",
          "package": "libcspm",
          "signature": "String -\u003e [(String, a)] -\u003e [a]",
          "source": "src/Util-FuzzyLookup.html#fuzzyLookup",
          "type": "function"
        },
        "index": {
          "description": "Search for possible matches to the users input in the given list returning small number of ranked results",
          "hierarchy": "Util FuzzyLookup",
          "module": "Util.FuzzyLookup",
          "name": "fuzzyLookup",
          "normalized": "String-\u003e[(String,a)]-\u003e[a]",
          "package": "libcspm",
          "partial": "Lookup",
          "signature": "String-\u003e[(String,a)]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Util-FuzzyLookup.html#v:fuzzyLookup"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.FuzzyLookup",
          "name": "fuzzyMatch",
          "package": "libcspm",
          "signature": "String -\u003e [String] -\u003e [String]",
          "source": "src/Util-FuzzyLookup.html#fuzzyMatch",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util FuzzyLookup",
          "module": "Util.FuzzyLookup",
          "name": "fuzzyMatch",
          "normalized": "String-\u003e[String]-\u003e[String]",
          "package": "libcspm",
          "partial": "Match",
          "signature": "String-\u003e[String]-\u003e[String]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Util-FuzzyLookup.html#v:fuzzyMatch"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.HierarchicalMap",
          "name": "HierarchicalMap",
          "package": "libcspm",
          "source": "src/Util-HierarchicalMap.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Util HierarchicalMap",
          "module": "Util.HierarchicalMap",
          "name": "HierarchicalMap",
          "package": "libcspm",
          "partial": "Hierarchical Map",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Util-HierarchicalMap.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.HierarchicalMap",
          "name": "HierarchicalMap",
          "package": "libcspm",
          "source": "src/Util-HierarchicalMap.html#HierarchicalMap",
          "type": "data"
        },
        "index": {
          "hierarchy": "Util HierarchicalMap",
          "module": "Util.HierarchicalMap",
          "name": "HierarchicalMap",
          "package": "libcspm",
          "partial": "Hierarchical Map",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Util-HierarchicalMap.html#t:HierarchicalMap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.HierarchicalMap",
          "name": "HierarchicalMapException",
          "package": "libcspm",
          "source": "src/Util-HierarchicalMap.html#HierarchicalMapException",
          "type": "data"
        },
        "index": {
          "hierarchy": "Util HierarchicalMap",
          "module": "Util.HierarchicalMap",
          "name": "HierarchicalMapException",
          "package": "libcspm",
          "partial": "Hierarchical Map Exception",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Util-HierarchicalMap.html#t:HierarchicalMapException"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.HierarchicalMap",
          "name": "HierarchicalMap",
          "package": "libcspm",
          "signature": "HierarchicalMap [Map a b]",
          "source": "src/Util-HierarchicalMap.html#HierarchicalMap",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util HierarchicalMap",
          "module": "Util.HierarchicalMap",
          "name": "HierarchicalMap",
          "normalized": "HierarchicalMap[Map a b]",
          "package": "libcspm",
          "partial": "Hierarchical Map",
          "signature": "HierarchicalMap[Map a b]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Util-HierarchicalMap.html#v:HierarchicalMap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.HierarchicalMap",
          "name": "ValueNotFoundException",
          "package": "libcspm",
          "signature": "ValueNotFoundException a",
          "source": "src/Util-HierarchicalMap.html#HierarchicalMapException",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util HierarchicalMap",
          "module": "Util.HierarchicalMap",
          "name": "ValueNotFoundException",
          "package": "libcspm",
          "partial": "Value Not Found Exception",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Util-HierarchicalMap.html#v:ValueNotFoundException"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.HierarchicalMap",
          "name": "flatten",
          "package": "libcspm",
          "signature": "HierarchicalMap a b -\u003e [(a, b)]",
          "source": "src/Util-HierarchicalMap.html#flatten",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util HierarchicalMap",
          "module": "Util.HierarchicalMap",
          "name": "flatten",
          "normalized": "HierarchicalMap a b-\u003e[(a,b)]",
          "package": "libcspm",
          "signature": "HierarchicalMap a b-\u003e[(a,b)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Util-HierarchicalMap.html#v:flatten"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLooks up a key in any map, starting from the top\n\u003c/p\u003e",
          "module": "Util.HierarchicalMap",
          "name": "lookup",
          "package": "libcspm",
          "signature": "HierarchicalMap k a -\u003e k -\u003e a",
          "source": "src/Util-HierarchicalMap.html#lookup",
          "type": "function"
        },
        "index": {
          "description": "Looks up key in any map starting from the top",
          "hierarchy": "Util HierarchicalMap",
          "module": "Util.HierarchicalMap",
          "name": "lookup",
          "normalized": "HierarchicalMap a b-\u003ea-\u003eb",
          "package": "libcspm",
          "signature": "HierarchicalMap k a-\u003ek-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Util-HierarchicalMap.html#v:lookup"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.HierarchicalMap",
          "name": "map",
          "package": "libcspm",
          "signature": "(k -\u003e a -\u003e b) -\u003e HierarchicalMap k a -\u003e HierarchicalMap k b",
          "source": "src/Util-HierarchicalMap.html#map",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util HierarchicalMap",
          "module": "Util.HierarchicalMap",
          "name": "map",
          "normalized": "(a-\u003eb-\u003ec)-\u003eHierarchicalMap a b-\u003eHierarchicalMap a c",
          "package": "libcspm",
          "signature": "(k-\u003ea-\u003eb)-\u003eHierarchicalMap k a-\u003eHierarchicalMap k b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Util-HierarchicalMap.html#v:map"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.HierarchicalMap",
          "name": "maybeLookup",
          "package": "libcspm",
          "signature": "HierarchicalMap k a -\u003e k -\u003e Maybe a",
          "source": "src/Util-HierarchicalMap.html#maybeLookup",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util HierarchicalMap",
          "module": "Util.HierarchicalMap",
          "name": "maybeLookup",
          "normalized": "HierarchicalMap a b-\u003ea-\u003eMaybe b",
          "package": "libcspm",
          "partial": "Lookup",
          "signature": "HierarchicalMap k a-\u003ek-\u003eMaybe a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Util-HierarchicalMap.html#v:maybeLookup"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.HierarchicalMap",
          "name": "maybeLookupInTopLayer",
          "package": "libcspm",
          "signature": "HierarchicalMap k a -\u003e k -\u003e Maybe a",
          "source": "src/Util-HierarchicalMap.html#maybeLookupInTopLayer",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util HierarchicalMap",
          "module": "Util.HierarchicalMap",
          "name": "maybeLookupInTopLayer",
          "normalized": "HierarchicalMap a b-\u003ea-\u003eMaybe b",
          "package": "libcspm",
          "partial": "Lookup In Top Layer",
          "signature": "HierarchicalMap k a-\u003ek-\u003eMaybe a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Util-HierarchicalMap.html#v:maybeLookupInTopLayer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreates a new map\n\u003c/p\u003e",
          "module": "Util.HierarchicalMap",
          "name": "new",
          "package": "libcspm",
          "signature": "HierarchicalMap a b",
          "source": "src/Util-HierarchicalMap.html#new",
          "type": "function"
        },
        "index": {
          "description": "Creates new map",
          "hierarchy": "Util HierarchicalMap",
          "module": "Util.HierarchicalMap",
          "name": "new",
          "package": "libcspm",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Util-HierarchicalMap.html#v:new"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.HierarchicalMap",
          "name": "newLayer",
          "package": "libcspm",
          "signature": "HierarchicalMap a b -\u003e HierarchicalMap a b",
          "source": "src/Util-HierarchicalMap.html#newLayer",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util HierarchicalMap",
          "module": "Util.HierarchicalMap",
          "name": "newLayer",
          "normalized": "HierarchicalMap a b-\u003eHierarchicalMap a b",
          "package": "libcspm",
          "partial": "Layer",
          "signature": "HierarchicalMap a b-\u003eHierarchicalMap a b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Util-HierarchicalMap.html#v:newLayer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.HierarchicalMap",
          "name": "newLayerAndBind",
          "package": "libcspm",
          "signature": "HierarchicalMap a b -\u003e [(a, b)] -\u003e HierarchicalMap a b",
          "source": "src/Util-HierarchicalMap.html#newLayerAndBind",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util HierarchicalMap",
          "module": "Util.HierarchicalMap",
          "name": "newLayerAndBind",
          "normalized": "HierarchicalMap a b-\u003e[(a,b)]-\u003eHierarchicalMap a b",
          "package": "libcspm",
          "partial": "Layer And Bind",
          "signature": "HierarchicalMap a b-\u003e[(a,b)]-\u003eHierarchicalMap a b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Util-HierarchicalMap.html#v:newLayerAndBind"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.HierarchicalMap",
          "name": "newRecursiveLayerAndBind",
          "package": "libcspm",
          "signature": "HierarchicalMap a b -\u003e [HierarchicalMap a b -\u003e (a, b)] -\u003e HierarchicalMap a b",
          "source": "src/Util-HierarchicalMap.html#newRecursiveLayerAndBind",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util HierarchicalMap",
          "module": "Util.HierarchicalMap",
          "name": "newRecursiveLayerAndBind",
          "normalized": "HierarchicalMap a b-\u003e[HierarchicalMap a b-\u003e(a,b)]-\u003eHierarchicalMap a b",
          "package": "libcspm",
          "partial": "Recursive Layer And Bind",
          "signature": "HierarchicalMap a b-\u003e[HierarchicalMap a b-\u003e(a,b)]-\u003eHierarchicalMap a b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Util-HierarchicalMap.html#v:newRecursiveLayerAndBind"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.HierarchicalMap",
          "name": "popLayer",
          "package": "libcspm",
          "signature": "HierarchicalMap a b -\u003e HierarchicalMap a b",
          "source": "src/Util-HierarchicalMap.html#popLayer",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util HierarchicalMap",
          "module": "Util.HierarchicalMap",
          "name": "popLayer",
          "normalized": "HierarchicalMap a b-\u003eHierarchicalMap a b",
          "package": "libcspm",
          "partial": "Layer",
          "signature": "HierarchicalMap a b-\u003eHierarchicalMap a b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Util-HierarchicalMap.html#v:popLayer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreates/updates a key in the top level map.\n\u003c/p\u003e",
          "module": "Util.HierarchicalMap",
          "name": "update",
          "package": "libcspm",
          "signature": "HierarchicalMap a b -\u003e a -\u003e b -\u003e HierarchicalMap a b",
          "source": "src/Util-HierarchicalMap.html#update",
          "type": "function"
        },
        "index": {
          "description": "Creates updates key in the top level map",
          "hierarchy": "Util HierarchicalMap",
          "module": "Util.HierarchicalMap",
          "name": "update",
          "normalized": "HierarchicalMap a b-\u003ea-\u003eb-\u003eHierarchicalMap a b",
          "package": "libcspm",
          "signature": "HierarchicalMap a b-\u003ea-\u003eb-\u003eHierarchicalMap a b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Util-HierarchicalMap.html#v:update"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.HierarchicalMap",
          "name": "updateMulti",
          "package": "libcspm",
          "signature": "HierarchicalMap a b -\u003e [(a, b)] -\u003e HierarchicalMap a b",
          "source": "src/Util-HierarchicalMap.html#updateMulti",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util HierarchicalMap",
          "module": "Util.HierarchicalMap",
          "name": "updateMulti",
          "normalized": "HierarchicalMap a b-\u003e[(a,b)]-\u003eHierarchicalMap a b",
          "package": "libcspm",
          "partial": "Multi",
          "signature": "HierarchicalMap a b-\u003e[(a,b)]-\u003eHierarchicalMap a b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Util-HierarchicalMap.html#v:updateMulti"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.List",
          "name": "List",
          "package": "libcspm",
          "source": "src/Util-List.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Util List",
          "module": "Util.List",
          "name": "List",
          "package": "libcspm",
          "partial": "List",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Util-List.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.List",
          "name": "cartesianProduct",
          "package": "libcspm",
          "signature": "[[a]] -\u003e [[a]]",
          "source": "src/Util-List.html#cartesianProduct",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util List",
          "module": "Util.List",
          "name": "cartesianProduct",
          "normalized": "[[a]]-\u003e[[a]]",
          "package": "libcspm",
          "partial": "Product",
          "signature": "[[a]]-\u003e[[a]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Util-List.html#v:cartesianProduct"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturns true iff the list has no duplicates.\n\u003c/p\u003e",
          "module": "Util.List",
          "name": "noDups",
          "package": "libcspm",
          "signature": "[a] -\u003e Bool",
          "source": "src/Util-List.html#noDups",
          "type": "function"
        },
        "index": {
          "description": "Returns true iff the list has no duplicates",
          "hierarchy": "Util List",
          "module": "Util.List",
          "name": "noDups",
          "normalized": "[a]-\u003eBool",
          "package": "libcspm",
          "partial": "Dups",
          "signature": "[a]-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Util-List.html#v:noDups"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReplaces the last item in a list. Assumes the list is non empty.\n\u003c/p\u003e",
          "module": "Util.List",
          "name": "replaceLast",
          "package": "libcspm",
          "signature": "[a] -\u003e a -\u003e [a]",
          "source": "src/Util-List.html#replaceLast",
          "type": "function"
        },
        "index": {
          "description": "Replaces the last item in list Assumes the list is non empty",
          "hierarchy": "Util List",
          "module": "Util.List",
          "name": "replaceLast",
          "normalized": "[a]-\u003ea-\u003e[a]",
          "package": "libcspm",
          "partial": "Last",
          "signature": "[a]-\u003ea-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Util-List.html#v:replaceLast"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eMisc utility functions that are defined on monads.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Util.Monad",
          "name": "Monad",
          "package": "libcspm",
          "source": "src/Util-Monad.html",
          "type": "module"
        },
        "index": {
          "description": "Misc utility functions that are defined on monads",
          "hierarchy": "Util Monad",
          "module": "Util.Monad",
          "name": "Monad",
          "package": "libcspm",
          "partial": "Monad",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Util-Monad.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Monad",
          "name": "($$)",
          "package": "libcspm",
          "signature": "m (a -\u003e b) -\u003e m a -\u003e m b",
          "source": "src/Util-Monad.html#%24%24",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util Monad",
          "module": "Util.Monad",
          "name": "($$) $$",
          "normalized": "a(b-\u003ec)-\u003ea b-\u003ea c",
          "package": "libcspm",
          "signature": "m(a-\u003eb)-\u003em a-\u003em b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Util-Monad.html#v:-36--36-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Monad",
          "name": "andM",
          "package": "libcspm",
          "signature": "[m Bool] -\u003e m Bool",
          "source": "src/Util-Monad.html#andM",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util Monad",
          "module": "Util.Monad",
          "name": "andM",
          "normalized": "[a Bool]-\u003ea Bool",
          "package": "libcspm",
          "signature": "[m Bool]-\u003em Bool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Util-Monad.html#v:andM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Monad",
          "name": "concatMapM",
          "package": "libcspm",
          "signature": "(a -\u003e m [b]) -\u003e [a] -\u003e m [b]",
          "source": "src/Util-Monad.html#concatMapM",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util Monad",
          "module": "Util.Monad",
          "name": "concatMapM",
          "normalized": "(a-\u003eb[c])-\u003e[a]-\u003eb[c]",
          "package": "libcspm",
          "partial": "Map",
          "signature": "(a-\u003em[b])-\u003e[a]-\u003em[b]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Util-Monad.html#v:concatMapM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Monad",
          "name": "orM",
          "package": "libcspm",
          "signature": "[m Bool] -\u003e m Bool",
          "source": "src/Util-Monad.html#orM",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util Monad",
          "module": "Util.Monad",
          "name": "orM",
          "normalized": "[a Bool]-\u003ea Bool",
          "package": "libcspm",
          "signature": "[m Bool]-\u003em Bool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Util-Monad.html#v:orM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Monad",
          "name": "whenM",
          "package": "libcspm",
          "signature": "m Bool -\u003e m () -\u003e m ()",
          "source": "src/Util-Monad.html#whenM",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util Monad",
          "module": "Util.Monad",
          "name": "whenM",
          "normalized": "a Bool-\u003ea()-\u003ea()",
          "package": "libcspm",
          "signature": "m Bool-\u003em()-\u003em()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Util-Monad.html#v:whenM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.MonadicPrettyPrint",
          "name": "MonadicPrettyPrint",
          "package": "libcspm",
          "source": "src/Util-MonadicPrettyPrint.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Util MonadicPrettyPrint",
          "module": "Util.MonadicPrettyPrint",
          "name": "MonadicPrettyPrint",
          "package": "libcspm",
          "partial": "Monadic Pretty Print",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Util-MonadicPrettyPrint.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.MonadicPrettyPrint",
          "name": "MonadicPrettyPrintable",
          "package": "libcspm",
          "source": "src/Util-MonadicPrettyPrint.html#MonadicPrettyPrintable",
          "type": "class"
        },
        "index": {
          "hierarchy": "Util MonadicPrettyPrint",
          "module": "Util.MonadicPrettyPrint",
          "name": "MonadicPrettyPrintable",
          "package": "libcspm",
          "partial": "Monadic Pretty Printable",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Util-MonadicPrettyPrint.html#t:MonadicPrettyPrintable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSurrounds a \u003ccode\u003e\u003ca\u003eDoc\u003c/a\u003e\u003c/code\u003e with \u003ccode\u003e\u003ca\u003e\u003c\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003e\u003e\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Util.MonadicPrettyPrint",
          "name": "angles",
          "package": "libcspm",
          "signature": "m Doc -\u003e m Doc",
          "source": "src/Util-MonadicPrettyPrint.html#angles",
          "type": "function"
        },
        "index": {
          "description": "Surrounds Doc with and",
          "hierarchy": "Util MonadicPrettyPrint",
          "module": "Util.MonadicPrettyPrint",
          "name": "angles",
          "normalized": "a Doc-\u003ea Doc",
          "package": "libcspm",
          "signature": "m Doc-\u003em Doc",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Util-MonadicPrettyPrint.html#v:angles"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSurrounds a \u003ccode\u003e\u003ca\u003eDoc\u003c/a\u003e\u003c/code\u003e with '|'.\n\u003c/p\u003e",
          "module": "Util.MonadicPrettyPrint",
          "name": "bars",
          "package": "libcspm",
          "signature": "m Doc -\u003e m Doc",
          "source": "src/Util-MonadicPrettyPrint.html#bars",
          "type": "function"
        },
        "index": {
          "description": "Surrounds Doc with",
          "hierarchy": "Util MonadicPrettyPrint",
          "module": "Util.MonadicPrettyPrint",
          "name": "bars",
          "normalized": "a Doc-\u003ea Doc",
          "package": "libcspm",
          "signature": "m Doc-\u003em Doc",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Util-MonadicPrettyPrint.html#v:bars"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePretty prints an integer and separates it into groups of 3, separated by\n commas.\n\u003c/p\u003e",
          "module": "Util.MonadicPrettyPrint",
          "name": "commaSeparatedInt",
          "package": "libcspm",
          "signature": "Int -\u003e m Doc",
          "source": "src/Util-MonadicPrettyPrint.html#commaSeparatedInt",
          "type": "function"
        },
        "index": {
          "description": "Pretty prints an integer and separates it into groups of separated by commas",
          "hierarchy": "Util MonadicPrettyPrint",
          "module": "Util.MonadicPrettyPrint",
          "name": "commaSeparatedInt",
          "normalized": "Int-\u003ea Doc",
          "package": "libcspm",
          "partial": "Separated Int",
          "signature": "Int-\u003em Doc",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Util-MonadicPrettyPrint.html#v:commaSeparatedInt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSeparates a list of \u003ccode\u003e\u003ca\u003eDoc\u003c/a\u003e\u003c/code\u003es by \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Util.MonadicPrettyPrint",
          "name": "dotSep",
          "package": "libcspm",
          "signature": "m [Doc] -\u003e m Doc",
          "source": "src/Util-MonadicPrettyPrint.html#dotSep",
          "type": "function"
        },
        "index": {
          "description": "Separates list of Doc by",
          "hierarchy": "Util MonadicPrettyPrint",
          "module": "Util.MonadicPrettyPrint",
          "name": "dotSep",
          "normalized": "a[Doc]-\u003ea Doc",
          "package": "libcspm",
          "partial": "Sep",
          "signature": "m[Doc]-\u003em Doc",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Util-MonadicPrettyPrint.html#v:dotSep"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.MonadicPrettyPrint",
          "name": "ellipsis",
          "package": "libcspm",
          "signature": "m Doc",
          "source": "src/Util-MonadicPrettyPrint.html#ellipsis",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util MonadicPrettyPrint",
          "module": "Util.MonadicPrettyPrint",
          "name": "ellipsis",
          "package": "libcspm",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Util-MonadicPrettyPrint.html#v:ellipsis"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSeparates a list of \u003ccode\u003e\u003ca\u003eDoc\u003c/a\u003e\u003c/code\u003es by ','.\n\u003c/p\u003e",
          "module": "Util.MonadicPrettyPrint",
          "name": "list",
          "package": "libcspm",
          "signature": "m [Doc] -\u003e m Doc",
          "source": "src/Util-MonadicPrettyPrint.html#list",
          "type": "function"
        },
        "index": {
          "description": "Separates list of Doc by",
          "hierarchy": "Util MonadicPrettyPrint",
          "module": "Util.MonadicPrettyPrint",
          "name": "list",
          "normalized": "a[Doc]-\u003ea Doc",
          "package": "libcspm",
          "signature": "m[Doc]-\u003em Doc",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Util-MonadicPrettyPrint.html#v:list"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.MonadicPrettyPrint",
          "name": "ppBinaryOp",
          "package": "libcspm",
          "signature": "a -\u003e m Doc -\u003e a -\u003e a -\u003e m Doc",
          "source": "src/Util-MonadicPrettyPrint.html#ppBinaryOp",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util MonadicPrettyPrint",
          "module": "Util.MonadicPrettyPrint",
          "name": "ppBinaryOp",
          "normalized": "a-\u003eb Doc-\u003ea-\u003ea-\u003eb Doc",
          "package": "libcspm",
          "partial": "Binary Op",
          "signature": "a-\u003em Doc-\u003ea-\u003ea-\u003em Doc",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Util-MonadicPrettyPrint.html#v:ppBinaryOp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.MonadicPrettyPrint",
          "name": "ppBinaryOp'",
          "package": "libcspm",
          "signature": "a -\u003e m Doc -\u003e a -\u003e a -\u003e m Doc",
          "source": "src/Util-MonadicPrettyPrint.html#ppBinaryOp%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util MonadicPrettyPrint",
          "module": "Util.MonadicPrettyPrint",
          "name": "ppBinaryOp'",
          "normalized": "a-\u003eb Doc-\u003ea-\u003ea-\u003eb Doc",
          "package": "libcspm",
          "partial": "Binary Op'",
          "signature": "a-\u003em Doc-\u003ea-\u003ea-\u003em Doc",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Util-MonadicPrettyPrint.html#v:ppBinaryOp-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.MonadicPrettyPrint",
          "name": "prettyPrint",
          "package": "libcspm",
          "signature": "a -\u003e m Doc",
          "source": "src/Util-MonadicPrettyPrint.html#prettyPrint",
          "type": "method"
        },
        "index": {
          "hierarchy": "Util MonadicPrettyPrint",
          "module": "Util.MonadicPrettyPrint",
          "name": "prettyPrint",
          "normalized": "a-\u003eb Doc",
          "package": "libcspm",
          "partial": "Print",
          "signature": "a-\u003em Doc",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Util-MonadicPrettyPrint.html#v:prettyPrint"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAs prettyPrint, but yields a briefer description.\n\u003c/p\u003e",
          "module": "Util.MonadicPrettyPrint",
          "name": "prettyPrintBrief",
          "package": "libcspm",
          "signature": "a -\u003e m Doc",
          "source": "src/Util-MonadicPrettyPrint.html#prettyPrintBrief",
          "type": "method"
        },
        "index": {
          "description": "As prettyPrint but yields briefer description",
          "hierarchy": "Util MonadicPrettyPrint",
          "module": "Util.MonadicPrettyPrint",
          "name": "prettyPrintBrief",
          "normalized": "a-\u003eb Doc",
          "package": "libcspm",
          "partial": "Print Brief",
          "signature": "a-\u003em Doc",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Util-MonadicPrettyPrint.html#v:prettyPrintBrief"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.MonadicPrettyPrint",
          "name": "prettyPrintBriefPrec",
          "package": "libcspm",
          "signature": "Int -\u003e a -\u003e m Doc",
          "source": "src/Util-MonadicPrettyPrint.html#prettyPrintBriefPrec",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util MonadicPrettyPrint",
          "module": "Util.MonadicPrettyPrint",
          "name": "prettyPrintBriefPrec",
          "normalized": "Int-\u003ea-\u003eb Doc",
          "package": "libcspm",
          "partial": "Print Brief Prec",
          "signature": "Int-\u003ea-\u003em Doc",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Util-MonadicPrettyPrint.html#v:prettyPrintBriefPrec"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.MonadicPrettyPrint",
          "name": "prettyPrintPrec",
          "package": "libcspm",
          "signature": "a -\u003e a -\u003e m Doc",
          "source": "src/Util-MonadicPrettyPrint.html#prettyPrintPrec",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util MonadicPrettyPrint",
          "module": "Util.MonadicPrettyPrint",
          "name": "prettyPrintPrec",
          "normalized": "a-\u003ea-\u003eb Doc",
          "package": "libcspm",
          "partial": "Print Prec",
          "signature": "a-\u003ea-\u003em Doc",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Util-MonadicPrettyPrint.html#v:prettyPrintPrec"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEquivalent to [d1, sep \u003ca/\u003e d2, sep \u003ca/\u003e d3, ...].\n\u003c/p\u003e",
          "module": "Util.MonadicPrettyPrint",
          "name": "punctuateFront",
          "package": "libcspm",
          "signature": "m Doc -\u003e m [Doc] -\u003e m [Doc]",
          "source": "src/Util-MonadicPrettyPrint.html#punctuateFront",
          "type": "function"
        },
        "index": {
          "description": "Equivalent to d1 sep d2 sep d3",
          "hierarchy": "Util MonadicPrettyPrint",
          "module": "Util.MonadicPrettyPrint",
          "name": "punctuateFront",
          "normalized": "a Doc-\u003ea[Doc]-\u003ea[Doc]",
          "package": "libcspm",
          "partial": "Front",
          "signature": "m Doc-\u003em[Doc]-\u003em[Doc]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Util-MonadicPrettyPrint.html#v:punctuateFront"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eShow a double \u003ccode\u003ed\u003c/code\u003e printing only \u003ccode\u003eplaces\u003c/code\u003e places after the decimal place.\n\u003c/p\u003e",
          "module": "Util.MonadicPrettyPrint",
          "name": "shortDouble",
          "package": "libcspm",
          "signature": "Int -\u003e Double -\u003e m Doc",
          "source": "src/Util-MonadicPrettyPrint.html#shortDouble",
          "type": "function"
        },
        "index": {
          "description": "Show double printing only places places after the decimal place",
          "hierarchy": "Util MonadicPrettyPrint",
          "module": "Util.MonadicPrettyPrint",
          "name": "shortDouble",
          "normalized": "Int-\u003eDouble-\u003ea Doc",
          "package": "libcspm",
          "partial": "Double",
          "signature": "Int-\u003eDouble-\u003em Doc",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Util-MonadicPrettyPrint.html#v:shortDouble"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConverts a number into \u003ccode\u003efirst\u003c/code\u003e, \u003ccode\u003esecond\u003c/code\u003e etc.\n\u003c/p\u003e",
          "module": "Util.MonadicPrettyPrint",
          "name": "speakNth",
          "package": "libcspm",
          "signature": "Int -\u003e m Doc",
          "source": "src/Util-MonadicPrettyPrint.html#speakNth",
          "type": "function"
        },
        "index": {
          "description": "Converts number into first second etc",
          "hierarchy": "Util MonadicPrettyPrint",
          "module": "Util.MonadicPrettyPrint",
          "name": "speakNth",
          "normalized": "Int-\u003ea Doc",
          "package": "libcspm",
          "partial": "Nth",
          "signature": "Int-\u003em Doc",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Util-MonadicPrettyPrint.html#v:speakNth"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIndent a document by \u003ccode\u003e\u003ca\u003etabWidth\u003c/a\u003e\u003c/code\u003e characters, on each line\n (uses \u003ccode\u003e\u003ca\u003enest\u003c/a\u003e\u003c/code\u003e).\n\u003c/p\u003e",
          "module": "Util.MonadicPrettyPrint",
          "name": "tabIndent",
          "package": "libcspm",
          "signature": "m Doc -\u003e m Doc",
          "source": "src/Util-MonadicPrettyPrint.html#tabIndent",
          "type": "function"
        },
        "index": {
          "description": "Indent document by tabWidth characters on each line uses nest",
          "hierarchy": "Util MonadicPrettyPrint",
          "module": "Util.MonadicPrettyPrint",
          "name": "tabIndent",
          "normalized": "a Doc-\u003ea Doc",
          "package": "libcspm",
          "partial": "Indent",
          "signature": "m Doc-\u003em Doc",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Util-MonadicPrettyPrint.html#v:tabIndent"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe width, in spaces, of a tab character.\n\u003c/p\u003e",
          "module": "Util.MonadicPrettyPrint",
          "name": "tabWidth",
          "package": "libcspm",
          "signature": "Int",
          "source": "src/Util-MonadicPrettyPrint.html#tabWidth",
          "type": "function"
        },
        "index": {
          "description": "The width in spaces of tab character",
          "hierarchy": "Util MonadicPrettyPrint",
          "module": "Util.MonadicPrettyPrint",
          "name": "tabWidth",
          "package": "libcspm",
          "partial": "Width",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Util-MonadicPrettyPrint.html#v:tabWidth"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eA wrapper around the John Hughes's and Simon Peyton Jones's Pretty\n Printer combinators based on the ReaderT monad transformer, allowing\n lookups to be performed during the pretty-printing process.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Util.MonadicPrettyPrintInternal",
          "name": "MonadicPrettyPrintInternal",
          "package": "libcspm",
          "source": "src/Util-MonadicPrettyPrintInternal.html",
          "type": "module"
        },
        "index": {
          "description": "wrapper around the John Hughes and Simon Peyton Jones Pretty Printer combinators based on the ReaderT monad transformer allowing lookups to be performed during the pretty-printing process",
          "hierarchy": "Util MonadicPrettyPrintInternal",
          "module": "Util.MonadicPrettyPrintInternal",
          "name": "MonadicPrettyPrintInternal",
          "package": "libcspm",
          "partial": "Monadic Pretty Print Internal",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Util-MonadicPrettyPrintInternal.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe abstract type of documents.\n A Doc represents a *set* of layouts. A Doc with\n no occurrences of Union or NoDoc represents just one layout.\n\u003c/p\u003e",
          "module": "Util.MonadicPrettyPrintInternal",
          "name": "Doc",
          "package": "libcspm",
          "type": "data"
        },
        "index": {
          "description": "The abstract type of documents Doc represents set of layouts Doc with no occurrences of Union or NoDoc represents just one layout",
          "hierarchy": "Util MonadicPrettyPrintInternal",
          "module": "Util.MonadicPrettyPrintInternal",
          "name": "Doc",
          "package": "libcspm",
          "partial": "Doc",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Util-MonadicPrettyPrintInternal.html#t:Doc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRendering mode.\n\u003c/p\u003e",
          "module": "Util.MonadicPrettyPrintInternal",
          "name": "Mode",
          "package": "libcspm",
          "type": "data"
        },
        "index": {
          "description": "Rendering mode",
          "hierarchy": "Util MonadicPrettyPrintInternal",
          "module": "Util.MonadicPrettyPrintInternal",
          "name": "Mode",
          "package": "libcspm",
          "partial": "Mode",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Util-MonadicPrettyPrintInternal.html#t:Mode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA rendering style.\n\u003c/p\u003e",
          "module": "Util.MonadicPrettyPrintInternal",
          "name": "Style",
          "package": "libcspm",
          "type": "data"
        },
        "index": {
          "description": "rendering style",
          "hierarchy": "Util MonadicPrettyPrintInternal",
          "module": "Util.MonadicPrettyPrintInternal",
          "name": "Style",
          "package": "libcspm",
          "partial": "Style",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Util-MonadicPrettyPrintInternal.html#t:Style"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe TextDetails data type\n\u003c/p\u003e\u003cp\u003eA TextDetails represents a fragment of text that will be\n output at some point.\n\u003c/p\u003e",
          "module": "Util.MonadicPrettyPrintInternal",
          "name": "TextDetails",
          "package": "libcspm",
          "type": "data"
        },
        "index": {
          "description": "The TextDetails data type TextDetails represents fragment of text that will be output at some point",
          "hierarchy": "Util MonadicPrettyPrintInternal",
          "module": "Util.MonadicPrettyPrintInternal",
          "name": "TextDetails",
          "package": "libcspm",
          "partial": "Text Details",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Util-MonadicPrettyPrintInternal.html#t:TextDetails"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAbove, except that if the last line of the first argument stops\n at least one position before the first line of the second begins,\n these two lines are overlapped.  For example:\n\u003c/p\u003e\u003cpre\u003e    text \"hi\" $$ nest 5 (text \"there\")\n\u003c/pre\u003e\u003cp\u003elays out as\n\u003c/p\u003e\u003cpre\u003e    hi   there\n\u003c/pre\u003e\u003cp\u003erather than\n\u003c/p\u003e\u003cpre\u003e    hi\n         there\n\u003c/pre\u003e\u003cp\u003e\u003ccode\u003e\u003ca\u003e$$\u003c/a\u003e\u003c/code\u003e is associative, with identity \u003ccode\u003e\u003ca\u003eempty\u003c/a\u003e\u003c/code\u003e, and also satisfies\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e \u003ccode\u003e(x \u003ccode\u003e\u003ca\u003e$$\u003c/a\u003e\u003c/code\u003e y) \u003ccode\u003e\u003ca\u003e\u003c\u003e\u003c/a\u003e\u003c/code\u003e z = x \u003ccode\u003e\u003ca\u003e$$\u003c/a\u003e\u003c/code\u003e (y \u003ccode\u003e\u003ca\u003e\u003c\u003e\u003c/a\u003e\u003c/code\u003e z)\u003c/code\u003e, if \u003ccode\u003ey\u003c/code\u003e non-empty.\n\u003c/li\u003e\u003c/ul\u003e",
          "module": "Util.MonadicPrettyPrintInternal",
          "name": "($$)",
          "package": "libcspm",
          "signature": "m Doc -\u003e m Doc -\u003e m Doc",
          "source": "src/Util-MonadicPrettyPrintInternal.html#%24%24",
          "type": "function"
        },
        "index": {
          "description": "Above except that if the last line of the first argument stops at least one position before the first line of the second begins these two lines are overlapped For example text hi nest text there lays out as hi there rather than hi there is associative with identity empty and also satisfies if non-empty",
          "hierarchy": "Util MonadicPrettyPrintInternal",
          "module": "Util.MonadicPrettyPrintInternal",
          "name": "($$) $$",
          "normalized": "a Doc-\u003ea Doc-\u003ea Doc",
          "package": "libcspm",
          "signature": "m Doc-\u003em Doc-\u003em Doc",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Util-MonadicPrettyPrintInternal.html#v:-36--36-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAbove, with no overlapping.\n \u003ccode\u003e\u003ca\u003e$+$\u003c/a\u003e\u003c/code\u003e is associative, with identity \u003ccode\u003e\u003ca\u003eempty\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Util.MonadicPrettyPrintInternal",
          "name": "($+$)",
          "package": "libcspm",
          "signature": "m Doc -\u003e m Doc -\u003e m Doc",
          "source": "src/Util-MonadicPrettyPrintInternal.html#%24%2B%24",
          "type": "function"
        },
        "index": {
          "description": "Above with no overlapping is associative with identity empty",
          "hierarchy": "Util MonadicPrettyPrintInternal",
          "module": "Util.MonadicPrettyPrintInternal",
          "name": "($+$) $+$",
          "normalized": "a Doc-\u003ea Doc-\u003ea Doc",
          "package": "libcspm",
          "signature": "m Doc-\u003em Doc-\u003em Doc",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Util-MonadicPrettyPrintInternal.html#v:-36--43--36-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eBeside, separated by space, unless one of the arguments is \u003ccode\u003e\u003ca\u003eempty\u003c/a\u003e\u003c/code\u003e.\n \u003ccode\u003e\u003ca\u003e\u003c+\u003e\u003c/a\u003e\u003c/code\u003e is associative, with identity \u003ccode\u003e\u003ca\u003eempty\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Util.MonadicPrettyPrintInternal",
          "name": "(\u003c+\u003e)",
          "package": "libcspm",
          "signature": "m Doc -\u003e m Doc -\u003e m Doc",
          "source": "src/Util-MonadicPrettyPrintInternal.html#%3C%2B%3E",
          "type": "function"
        },
        "index": {
          "description": "Beside separated by space unless one of the arguments is empty is associative with identity empty",
          "hierarchy": "Util MonadicPrettyPrintInternal",
          "module": "Util.MonadicPrettyPrintInternal",
          "name": "(\u003c+\u003e) \u003c+\u003e",
          "normalized": "a Doc-\u003ea Doc-\u003ea Doc",
          "package": "libcspm",
          "signature": "m Doc-\u003em Doc-\u003em Doc",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Util-MonadicPrettyPrintInternal.html#v:-60--43--62-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eBeside.\n \u003ccode\u003e\u003ca\u003e\u003c\u003e\u003c/a\u003e\u003c/code\u003e is associative, with identity \u003ccode\u003e\u003ca\u003eempty\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Util.MonadicPrettyPrintInternal",
          "name": "(\u003c\u003e)",
          "package": "libcspm",
          "signature": "m Doc -\u003e m Doc -\u003e m Doc",
          "source": "src/Util-MonadicPrettyPrintInternal.html#%3C%3E",
          "type": "function"
        },
        "index": {
          "description": "Beside is associative with identity empty",
          "hierarchy": "Util MonadicPrettyPrintInternal",
          "module": "Util.MonadicPrettyPrintInternal",
          "name": "(\u003c\u003e) \u003c\u003e",
          "normalized": "a Doc-\u003ea Doc-\u003ea Doc",
          "package": "libcspm",
          "signature": "m Doc-\u003em Doc-\u003em Doc",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Util-MonadicPrettyPrintInternal.html#v:-60--62-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA single Char fragment\n\u003c/p\u003e",
          "module": "Util.MonadicPrettyPrintInternal",
          "name": "Chr",
          "package": "libcspm",
          "signature": "Chr !Char",
          "type": "function"
        },
        "index": {
          "description": "single Char fragment",
          "hierarchy": "Util MonadicPrettyPrintInternal",
          "module": "Util.MonadicPrettyPrintInternal",
          "name": "Chr",
          "package": "libcspm",
          "partial": "Chr",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Util-MonadicPrettyPrintInternal.html#v:Chr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eNo indentation, infinitely long lines\n\u003c/p\u003e",
          "module": "Util.MonadicPrettyPrintInternal",
          "name": "LeftMode",
          "package": "libcspm",
          "signature": "LeftMode",
          "type": "function"
        },
        "index": {
          "description": "No indentation infinitely long lines",
          "hierarchy": "Util MonadicPrettyPrintInternal",
          "module": "Util.MonadicPrettyPrintInternal",
          "name": "LeftMode",
          "package": "libcspm",
          "partial": "Left Mode",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Util-MonadicPrettyPrintInternal.html#v:LeftMode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAll on one line\n\u003c/p\u003e",
          "module": "Util.MonadicPrettyPrintInternal",
          "name": "OneLineMode",
          "package": "libcspm",
          "signature": "OneLineMode",
          "type": "function"
        },
        "index": {
          "description": "All on one line",
          "hierarchy": "Util MonadicPrettyPrintInternal",
          "module": "Util.MonadicPrettyPrintInternal",
          "name": "OneLineMode",
          "package": "libcspm",
          "partial": "One Line Mode",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Util-MonadicPrettyPrintInternal.html#v:OneLineMode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUsed to represent a Fast String fragment\n   but now deprecated and identical to the\n   Str constructor.\n\u003c/p\u003e",
          "module": "Util.MonadicPrettyPrintInternal",
          "name": "PStr",
          "package": "libcspm",
          "signature": "PStr String",
          "type": "function"
        },
        "index": {
          "description": "Used to represent Fast String fragment but now deprecated and identical to the Str constructor",
          "hierarchy": "Util MonadicPrettyPrintInternal",
          "module": "Util.MonadicPrettyPrintInternal",
          "name": "PStr",
          "package": "libcspm",
          "partial": "PStr",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Util-MonadicPrettyPrintInternal.html#v:PStr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eNormal\n\u003c/p\u003e",
          "module": "Util.MonadicPrettyPrintInternal",
          "name": "PageMode",
          "package": "libcspm",
          "signature": "PageMode",
          "type": "function"
        },
        "index": {
          "description": "Normal",
          "hierarchy": "Util MonadicPrettyPrintInternal",
          "module": "Util.MonadicPrettyPrintInternal",
          "name": "PageMode",
          "package": "libcspm",
          "partial": "Page Mode",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Util-MonadicPrettyPrintInternal.html#v:PageMode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA whole String fragment\n\u003c/p\u003e",
          "module": "Util.MonadicPrettyPrintInternal",
          "name": "Str",
          "package": "libcspm",
          "signature": "Str String",
          "type": "function"
        },
        "index": {
          "description": "whole String fragment",
          "hierarchy": "Util MonadicPrettyPrintInternal",
          "module": "Util.MonadicPrettyPrintInternal",
          "name": "Str",
          "package": "libcspm",
          "partial": "Str",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Util-MonadicPrettyPrintInternal.html#v:Str"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.MonadicPrettyPrintInternal",
          "name": "Style",
          "package": "libcspm",
          "signature": "Style",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util MonadicPrettyPrintInternal",
          "module": "Util.MonadicPrettyPrintInternal",
          "name": "Style",
          "package": "libcspm",
          "partial": "Style",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Util-MonadicPrettyPrintInternal.html#v:Style"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWith zig-zag cuts\n\u003c/p\u003e",
          "module": "Util.MonadicPrettyPrintInternal",
          "name": "ZigZagMode",
          "package": "libcspm",
          "signature": "ZigZagMode",
          "type": "function"
        },
        "index": {
          "description": "With zig-zag cuts",
          "hierarchy": "Util MonadicPrettyPrintInternal",
          "module": "Util.MonadicPrettyPrintInternal",
          "name": "ZigZagMode",
          "package": "libcspm",
          "partial": "Zig Zag Mode",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Util-MonadicPrettyPrintInternal.html#v:ZigZagMode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWrap document in \u003ccode\u003e{...}\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Util.MonadicPrettyPrintInternal",
          "name": "braces",
          "package": "libcspm",
          "signature": "m Doc -\u003e m Doc",
          "source": "src/Util-MonadicPrettyPrintInternal.html#braces",
          "type": "function"
        },
        "index": {
          "description": "Wrap document in",
          "hierarchy": "Util MonadicPrettyPrintInternal",
          "module": "Util.MonadicPrettyPrintInternal",
          "name": "braces",
          "normalized": "a Doc-\u003ea Doc",
          "package": "libcspm",
          "signature": "m Doc-\u003em Doc",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Util-MonadicPrettyPrintInternal.html#v:braces"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWrap document in \u003ccode\u003e[...]\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Util.MonadicPrettyPrintInternal",
          "name": "brackets",
          "package": "libcspm",
          "signature": "m Doc -\u003e m Doc",
          "source": "src/Util-MonadicPrettyPrintInternal.html#brackets",
          "type": "function"
        },
        "index": {
          "description": "Wrap document in",
          "hierarchy": "Util MonadicPrettyPrintInternal",
          "module": "Util.MonadicPrettyPrintInternal",
          "name": "brackets",
          "normalized": "a Doc-\u003ea Doc",
          "package": "libcspm",
          "signature": "m Doc-\u003em Doc",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Util-MonadicPrettyPrintInternal.html#v:brackets"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEither \u003ccode\u003e\u003ca\u003ehcat\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003evcat\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Util.MonadicPrettyPrintInternal",
          "name": "cat",
          "package": "libcspm",
          "signature": "m [Doc] -\u003e m Doc",
          "source": "src/Util-MonadicPrettyPrintInternal.html#cat",
          "type": "function"
        },
        "index": {
          "description": "Either hcat or vcat",
          "hierarchy": "Util MonadicPrettyPrintInternal",
          "module": "Util.MonadicPrettyPrintInternal",
          "name": "cat",
          "normalized": "a[Doc]-\u003ea Doc",
          "package": "libcspm",
          "signature": "m[Doc]-\u003em Doc",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Util-MonadicPrettyPrintInternal.html#v:cat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA document of height and width 1, containing a literal character.\n\u003c/p\u003e",
          "module": "Util.MonadicPrettyPrintInternal",
          "name": "char",
          "package": "libcspm",
          "signature": "Char -\u003e m Doc",
          "source": "src/Util-MonadicPrettyPrintInternal.html#char",
          "type": "function"
        },
        "index": {
          "description": "document of height and width containing literal character",
          "hierarchy": "Util MonadicPrettyPrintInternal",
          "module": "Util.MonadicPrettyPrintInternal",
          "name": "char",
          "normalized": "Char-\u003ea Doc",
          "package": "libcspm",
          "signature": "Char-\u003em Doc",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Util-MonadicPrettyPrintInternal.html#v:char"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA \u003ccode\u003e:\u003c/code\u003e character\n\u003c/p\u003e",
          "module": "Util.MonadicPrettyPrintInternal",
          "name": "colon",
          "package": "libcspm",
          "signature": "m Doc",
          "source": "src/Util-MonadicPrettyPrintInternal.html#colon",
          "type": "function"
        },
        "index": {
          "description": "character",
          "hierarchy": "Util MonadicPrettyPrintInternal",
          "module": "Util.MonadicPrettyPrintInternal",
          "name": "colon",
          "package": "libcspm",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Util-MonadicPrettyPrintInternal.html#v:colon"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA ',' character\n\u003c/p\u003e",
          "module": "Util.MonadicPrettyPrintInternal",
          "name": "comma",
          "package": "libcspm",
          "signature": "m Doc",
          "source": "src/Util-MonadicPrettyPrintInternal.html#comma",
          "type": "function"
        },
        "index": {
          "description": "character",
          "hierarchy": "Util MonadicPrettyPrintInternal",
          "module": "Util.MonadicPrettyPrintInternal",
          "name": "comma",
          "package": "libcspm",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Util-MonadicPrettyPrintInternal.html#v:comma"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cpre\u003edouble n = text (show n)\u003c/pre\u003e",
          "module": "Util.MonadicPrettyPrintInternal",
          "name": "double",
          "package": "libcspm",
          "signature": "Double -\u003e m Doc",
          "source": "src/Util-MonadicPrettyPrintInternal.html#double",
          "type": "function"
        },
        "index": {
          "description": "double text show",
          "hierarchy": "Util MonadicPrettyPrintInternal",
          "module": "Util.MonadicPrettyPrintInternal",
          "name": "double",
          "normalized": "Double-\u003ea Doc",
          "package": "libcspm",
          "signature": "Double-\u003em Doc",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Util-MonadicPrettyPrintInternal.html#v:double"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWrap document in \u003ccode\u003e\"...\"\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Util.MonadicPrettyPrintInternal",
          "name": "doubleQuotes",
          "package": "libcspm",
          "signature": "m Doc -\u003e m Doc",
          "source": "src/Util-MonadicPrettyPrintInternal.html#doubleQuotes",
          "type": "function"
        },
        "index": {
          "description": "Wrap document in",
          "hierarchy": "Util MonadicPrettyPrintInternal",
          "module": "Util.MonadicPrettyPrintInternal",
          "name": "doubleQuotes",
          "normalized": "a Doc-\u003ea Doc",
          "package": "libcspm",
          "partial": "Quotes",
          "signature": "m Doc-\u003em Doc",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Util-MonadicPrettyPrintInternal.html#v:doubleQuotes"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe empty document, with no height and no width.\n \u003ccode\u003e\u003ca\u003eempty\u003c/a\u003e\u003c/code\u003e is the identity for \u003ccode\u003e\u003ca\u003e\u003c\u003e\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003e\u003c+\u003e\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003e$$\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003e$+$\u003c/a\u003e\u003c/code\u003e, and anywhere\n in the argument list for \u003ccode\u003e\u003ca\u003esep\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003ehcat\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003ehsep\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003evcat\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003efcat\u003c/a\u003e\u003c/code\u003e etc.\n\u003c/p\u003e",
          "module": "Util.MonadicPrettyPrintInternal",
          "name": "empty",
          "package": "libcspm",
          "signature": "m Doc",
          "source": "src/Util-MonadicPrettyPrintInternal.html#empty",
          "type": "function"
        },
        "index": {
          "description": "The empty document with no height and no width empty is the identity for and and anywhere in the argument list for sep hcat hsep vcat fcat etc",
          "hierarchy": "Util MonadicPrettyPrintInternal",
          "module": "Util.MonadicPrettyPrintInternal",
          "name": "empty",
          "package": "libcspm",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Util-MonadicPrettyPrintInternal.html#v:empty"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA '=' character\n\u003c/p\u003e",
          "module": "Util.MonadicPrettyPrintInternal",
          "name": "equals",
          "package": "libcspm",
          "signature": "m Doc",
          "source": "src/Util-MonadicPrettyPrintInternal.html#equals",
          "type": "function"
        },
        "index": {
          "description": "character",
          "hierarchy": "Util MonadicPrettyPrintInternal",
          "module": "Util.MonadicPrettyPrintInternal",
          "name": "equals",
          "package": "libcspm",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Util-MonadicPrettyPrintInternal.html#v:equals"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\"Paragraph fill\" version of \u003ccode\u003e\u003ca\u003ecat\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Util.MonadicPrettyPrintInternal",
          "name": "fcat",
          "package": "libcspm",
          "signature": "m [Doc] -\u003e m Doc",
          "source": "src/Util-MonadicPrettyPrintInternal.html#fcat",
          "type": "function"
        },
        "index": {
          "description": "Paragraph fill version of cat",
          "hierarchy": "Util MonadicPrettyPrintInternal",
          "module": "Util.MonadicPrettyPrintInternal",
          "name": "fcat",
          "normalized": "a[Doc]-\u003ea Doc",
          "package": "libcspm",
          "signature": "m[Doc]-\u003em Doc",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Util-MonadicPrettyPrintInternal.html#v:fcat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cpre\u003efloat n = text (show n)\u003c/pre\u003e",
          "module": "Util.MonadicPrettyPrintInternal",
          "name": "float",
          "package": "libcspm",
          "signature": "Float -\u003e m Doc",
          "source": "src/Util-MonadicPrettyPrintInternal.html#float",
          "type": "function"
        },
        "index": {
          "description": "float text show",
          "hierarchy": "Util MonadicPrettyPrintInternal",
          "module": "Util.MonadicPrettyPrintInternal",
          "name": "float",
          "normalized": "Float-\u003ea Doc",
          "package": "libcspm",
          "signature": "Float-\u003em Doc",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Util-MonadicPrettyPrintInternal.html#v:float"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\"Paragraph fill\" version of \u003ccode\u003e\u003ca\u003esep\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Util.MonadicPrettyPrintInternal",
          "name": "fsep",
          "package": "libcspm",
          "signature": "m [Doc] -\u003e m Doc",
          "source": "src/Util-MonadicPrettyPrintInternal.html#fsep",
          "type": "function"
        },
        "index": {
          "description": "Paragraph fill version of sep",
          "hierarchy": "Util MonadicPrettyPrintInternal",
          "module": "Util.MonadicPrettyPrintInternal",
          "name": "fsep",
          "normalized": "a[Doc]-\u003ea Doc",
          "package": "libcspm",
          "signature": "m[Doc]-\u003em Doc",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Util-MonadicPrettyPrintInternal.html#v:fsep"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe general rendering interface.\n\u003c/p\u003e",
          "module": "Util.MonadicPrettyPrintInternal",
          "name": "fullRender",
          "package": "libcspm",
          "signature": "Mode-\u003e Int-\u003e Float-\u003e (TextDetails -\u003e a -\u003e a)-\u003e a-\u003e m Doc-\u003e m a",
          "type": "function"
        },
        "index": {
          "description": "The general rendering interface",
          "hierarchy": "Util MonadicPrettyPrintInternal",
          "module": "Util.MonadicPrettyPrintInternal",
          "name": "fullRender",
          "normalized": "Mode-\u003eInt-\u003eFloat-\u003e(TextDetails-\u003ea-\u003ea)-\u003ea-\u003eb Doc-\u003eb a",
          "package": "libcspm",
          "partial": "Render",
          "signature": "Mode-\u003eInt-\u003eFloat-\u003e(TextDetails-\u003ea-\u003ea)-\u003ea-\u003em Doc-\u003em a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Util-MonadicPrettyPrintInternal.html#v:fullRender"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cpre\u003ehang d1 n d2 = sep [d1, nest n d2]\u003c/pre\u003e",
          "module": "Util.MonadicPrettyPrintInternal",
          "name": "hang",
          "package": "libcspm",
          "signature": "m Doc -\u003e Int -\u003e m Doc -\u003e m Doc",
          "source": "src/Util-MonadicPrettyPrintInternal.html#hang",
          "type": "function"
        },
        "index": {
          "description": "hang d1 d2 sep d1 nest d2",
          "hierarchy": "Util MonadicPrettyPrintInternal",
          "module": "Util.MonadicPrettyPrintInternal",
          "name": "hang",
          "normalized": "a Doc-\u003eInt-\u003ea Doc-\u003ea Doc",
          "package": "libcspm",
          "signature": "m Doc-\u003eInt-\u003em Doc-\u003em Doc",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Util-MonadicPrettyPrintInternal.html#v:hang"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eList version of \u003ccode\u003e\u003ca\u003e\u003c\u003e\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Util.MonadicPrettyPrintInternal",
          "name": "hcat",
          "package": "libcspm",
          "signature": "m [Doc] -\u003e m Doc",
          "source": "src/Util-MonadicPrettyPrintInternal.html#hcat",
          "type": "function"
        },
        "index": {
          "description": "List version of",
          "hierarchy": "Util MonadicPrettyPrintInternal",
          "module": "Util.MonadicPrettyPrintInternal",
          "name": "hcat",
          "normalized": "a[Doc]-\u003ea Doc",
          "package": "libcspm",
          "signature": "m[Doc]-\u003em Doc",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Util-MonadicPrettyPrintInternal.html#v:hcat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eList version of \u003ccode\u003e\u003ca\u003e\u003c+\u003e\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Util.MonadicPrettyPrintInternal",
          "name": "hsep",
          "package": "libcspm",
          "signature": "m [Doc] -\u003e m Doc",
          "source": "src/Util-MonadicPrettyPrintInternal.html#hsep",
          "type": "function"
        },
        "index": {
          "description": "List version of",
          "hierarchy": "Util MonadicPrettyPrintInternal",
          "module": "Util.MonadicPrettyPrintInternal",
          "name": "hsep",
          "normalized": "a[Doc]-\u003ea Doc",
          "package": "libcspm",
          "signature": "m[Doc]-\u003em Doc",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Util-MonadicPrettyPrintInternal.html#v:hsep"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cpre\u003eint n = text (show n)\u003c/pre\u003e",
          "module": "Util.MonadicPrettyPrintInternal",
          "name": "int",
          "package": "libcspm",
          "signature": "Int -\u003e m Doc",
          "source": "src/Util-MonadicPrettyPrintInternal.html#int",
          "type": "function"
        },
        "index": {
          "description": "int text show",
          "hierarchy": "Util MonadicPrettyPrintInternal",
          "module": "Util.MonadicPrettyPrintInternal",
          "name": "int",
          "normalized": "Int-\u003ea Doc",
          "package": "libcspm",
          "signature": "Int-\u003em Doc",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Util-MonadicPrettyPrintInternal.html#v:int"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cpre\u003einteger n = text (show n)\u003c/pre\u003e",
          "module": "Util.MonadicPrettyPrintInternal",
          "name": "integer",
          "package": "libcspm",
          "signature": "Integer -\u003e m Doc",
          "source": "src/Util-MonadicPrettyPrintInternal.html#integer",
          "type": "function"
        },
        "index": {
          "description": "integer text show",
          "hierarchy": "Util MonadicPrettyPrintInternal",
          "module": "Util.MonadicPrettyPrintInternal",
          "name": "integer",
          "normalized": "Integer-\u003ea Doc",
          "package": "libcspm",
          "signature": "Integer-\u003em Doc",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Util-MonadicPrettyPrintInternal.html#v:integer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturns \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e if the document is empty\n\u003c/p\u003e",
          "module": "Util.MonadicPrettyPrintInternal",
          "name": "isEmpty",
          "package": "libcspm",
          "signature": "m Doc -\u003e m Bool",
          "source": "src/Util-MonadicPrettyPrintInternal.html#isEmpty",
          "type": "function"
        },
        "index": {
          "description": "Returns True if the document is empty",
          "hierarchy": "Util MonadicPrettyPrintInternal",
          "module": "Util.MonadicPrettyPrintInternal",
          "name": "isEmpty",
          "normalized": "a Doc-\u003ea Bool",
          "package": "libcspm",
          "partial": "Empty",
          "signature": "m Doc-\u003em Bool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Util-MonadicPrettyPrintInternal.html#v:isEmpty"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA '{' character\n\u003c/p\u003e",
          "module": "Util.MonadicPrettyPrintInternal",
          "name": "lbrace",
          "package": "libcspm",
          "signature": "m Doc",
          "source": "src/Util-MonadicPrettyPrintInternal.html#lbrace",
          "type": "function"
        },
        "index": {
          "description": "character",
          "hierarchy": "Util MonadicPrettyPrintInternal",
          "module": "Util.MonadicPrettyPrintInternal",
          "name": "lbrace",
          "package": "libcspm",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Util-MonadicPrettyPrintInternal.html#v:lbrace"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA '[' character\n\u003c/p\u003e",
          "module": "Util.MonadicPrettyPrintInternal",
          "name": "lbrack",
          "package": "libcspm",
          "signature": "m Doc",
          "source": "src/Util-MonadicPrettyPrintInternal.html#lbrack",
          "type": "function"
        },
        "index": {
          "description": "character",
          "hierarchy": "Util MonadicPrettyPrintInternal",
          "module": "Util.MonadicPrettyPrintInternal",
          "name": "lbrack",
          "package": "libcspm",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Util-MonadicPrettyPrintInternal.html#v:lbrack"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLength of line, in chars\n\u003c/p\u003e",
          "module": "Util.MonadicPrettyPrintInternal",
          "name": "lineLength",
          "package": "libcspm",
          "signature": "Int",
          "type": "function"
        },
        "index": {
          "description": "Length of line in chars",
          "hierarchy": "Util MonadicPrettyPrintInternal",
          "module": "Util.MonadicPrettyPrintInternal",
          "name": "lineLength",
          "package": "libcspm",
          "partial": "Length",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Util-MonadicPrettyPrintInternal.html#v:lineLength"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA '(' character\n\u003c/p\u003e",
          "module": "Util.MonadicPrettyPrintInternal",
          "name": "lparen",
          "package": "libcspm",
          "signature": "m Doc",
          "source": "src/Util-MonadicPrettyPrintInternal.html#lparen",
          "type": "function"
        },
        "index": {
          "description": "character",
          "hierarchy": "Util MonadicPrettyPrintInternal",
          "module": "Util.MonadicPrettyPrintInternal",
          "name": "lparen",
          "package": "libcspm",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Util-MonadicPrettyPrintInternal.html#v:lparen"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe rendering mode\n\u003c/p\u003e",
          "module": "Util.MonadicPrettyPrintInternal",
          "name": "mode",
          "package": "libcspm",
          "signature": "Mode",
          "type": "function"
        },
        "index": {
          "description": "The rendering mode",
          "hierarchy": "Util MonadicPrettyPrintInternal",
          "module": "Util.MonadicPrettyPrintInternal",
          "name": "mode",
          "package": "libcspm",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Util-MonadicPrettyPrintInternal.html#v:mode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eNest (or indent) a document by a given number of positions\n (which may also be negative).  \u003ccode\u003e\u003ca\u003enest\u003c/a\u003e\u003c/code\u003e satisfies the laws:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e\u003cpre\u003e\u003ccode\u003e\u003ca\u003enest\u003c/a\u003e\u003c/code\u003e 0 x = x\u003c/pre\u003e\u003c/li\u003e\u003cli\u003e\u003cpre\u003e\u003ccode\u003e\u003ca\u003enest\u003c/a\u003e\u003c/code\u003e k (\u003ccode\u003e\u003ca\u003enest\u003c/a\u003e\u003c/code\u003e k' x) = \u003ccode\u003e\u003ca\u003enest\u003c/a\u003e\u003c/code\u003e (k+k') x\u003c/pre\u003e\u003c/li\u003e\u003cli\u003e\u003cpre\u003e\u003ccode\u003e\u003ca\u003enest\u003c/a\u003e\u003c/code\u003e k (x \u003ccode\u003e\u003ca\u003e\u003c\u003e\u003c/a\u003e\u003c/code\u003e y) = \u003ccode\u003e\u003ca\u003enest\u003c/a\u003e\u003c/code\u003e k z \u003ccode\u003e\u003ca\u003e\u003c\u003e\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003enest\u003c/a\u003e\u003c/code\u003e k y\u003c/pre\u003e\u003c/li\u003e\u003cli\u003e\u003cpre\u003e\u003ccode\u003e\u003ca\u003enest\u003c/a\u003e\u003c/code\u003e k (x \u003ccode\u003e\u003ca\u003e$$\u003c/a\u003e\u003c/code\u003e y) = \u003ccode\u003e\u003ca\u003enest\u003c/a\u003e\u003c/code\u003e k x \u003ccode\u003e\u003ca\u003e$$\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003enest\u003c/a\u003e\u003c/code\u003e k y\u003c/pre\u003e\u003c/li\u003e\u003cli\u003e\u003cpre\u003e\u003ccode\u003e\u003ca\u003enest\u003c/a\u003e\u003c/code\u003e k \u003ccode\u003e\u003ca\u003eempty\u003c/a\u003e\u003c/code\u003e = \u003ccode\u003e\u003ca\u003eempty\u003c/a\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/li\u003e\u003cli\u003e \u003ccode\u003ex \u003ccode\u003e\u003ca\u003e\u003c\u003e\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003enest\u003c/a\u003e\u003c/code\u003e k y = x \u003ccode\u003e\u003ca\u003e\u003c\u003e\u003c/a\u003e\u003c/code\u003e y\u003c/code\u003e, if \u003ccode\u003ex\u003c/code\u003e non-empty\n\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eThe side condition on the last law is needed because\n \u003ccode\u003e\u003ca\u003eempty\u003c/a\u003e\u003c/code\u003e is a left identity for \u003ccode\u003e\u003ca\u003e\u003c\u003e\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Util.MonadicPrettyPrintInternal",
          "name": "nest",
          "package": "libcspm",
          "signature": "Int -\u003e m Doc -\u003e m Doc",
          "source": "src/Util-MonadicPrettyPrintInternal.html#nest",
          "type": "function"
        },
        "index": {
          "description": "Nest or indent document by given number of positions which may also be negative nest satisfies the laws nest nest nest nest nest nest nest nest nest nest nest empty empty nest if non-empty The side condition on the last law is needed because empty is left identity for",
          "hierarchy": "Util MonadicPrettyPrintInternal",
          "module": "Util.MonadicPrettyPrintInternal",
          "name": "nest",
          "normalized": "Int-\u003ea Doc-\u003ea Doc",
          "package": "libcspm",
          "signature": "Int-\u003em Doc-\u003em Doc",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Util-MonadicPrettyPrintInternal.html#v:nest"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWrap document in \u003ccode\u003e(...)\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Util.MonadicPrettyPrintInternal",
          "name": "parens",
          "package": "libcspm",
          "signature": "m Doc -\u003e m Doc",
          "source": "src/Util-MonadicPrettyPrintInternal.html#parens",
          "type": "function"
        },
        "index": {
          "description": "Wrap document in",
          "hierarchy": "Util MonadicPrettyPrintInternal",
          "module": "Util.MonadicPrettyPrintInternal",
          "name": "parens",
          "normalized": "a Doc-\u003ea Doc",
          "package": "libcspm",
          "signature": "m Doc-\u003em Doc",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Util-MonadicPrettyPrintInternal.html#v:parens"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSame as \u003ccode\u003etext\u003c/code\u003e. Used to be used for Bytestrings.\n\u003c/p\u003e",
          "module": "Util.MonadicPrettyPrintInternal",
          "name": "ptext",
          "package": "libcspm",
          "signature": "String -\u003e m Doc",
          "source": "src/Util-MonadicPrettyPrintInternal.html#ptext",
          "type": "function"
        },
        "index": {
          "description": "Same as text Used to be used for Bytestrings",
          "hierarchy": "Util MonadicPrettyPrintInternal",
          "module": "Util.MonadicPrettyPrintInternal",
          "name": "ptext",
          "normalized": "String-\u003ea Doc",
          "package": "libcspm",
          "signature": "String-\u003em Doc",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Util-MonadicPrettyPrintInternal.html#v:ptext"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cpre\u003epunctuate p [d1, ... dn] = [d1 \u003c\u003e p, d2 \u003c\u003e p, ... dn-1 \u003c\u003e p, dn]\u003c/pre\u003e",
          "module": "Util.MonadicPrettyPrintInternal",
          "name": "punctuate",
          "package": "libcspm",
          "signature": "m Doc -\u003e m [Doc] -\u003e m [Doc]",
          "source": "src/Util-MonadicPrettyPrintInternal.html#punctuate",
          "type": "function"
        },
        "index": {
          "description": "punctuate d1 dn d1 d2 dn-1 dn",
          "hierarchy": "Util MonadicPrettyPrintInternal",
          "module": "Util.MonadicPrettyPrintInternal",
          "name": "punctuate",
          "normalized": "a Doc-\u003ea[Doc]-\u003ea[Doc]",
          "package": "libcspm",
          "signature": "m Doc-\u003em[Doc]-\u003em[Doc]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Util-MonadicPrettyPrintInternal.html#v:punctuate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWrap document in \u003ccode\u003e'...'\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Util.MonadicPrettyPrintInternal",
          "name": "quotes",
          "package": "libcspm",
          "signature": "m Doc -\u003e m Doc",
          "source": "src/Util-MonadicPrettyPrintInternal.html#quotes",
          "type": "function"
        },
        "index": {
          "description": "Wrap document in",
          "hierarchy": "Util MonadicPrettyPrintInternal",
          "module": "Util.MonadicPrettyPrintInternal",
          "name": "quotes",
          "normalized": "a Doc-\u003ea Doc",
          "package": "libcspm",
          "signature": "m Doc-\u003em Doc",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Util-MonadicPrettyPrintInternal.html#v:quotes"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cpre\u003erational n = text (show n)\u003c/pre\u003e",
          "module": "Util.MonadicPrettyPrintInternal",
          "name": "rational",
          "package": "libcspm",
          "signature": "Rational -\u003e m Doc",
          "source": "src/Util-MonadicPrettyPrintInternal.html#rational",
          "type": "function"
        },
        "index": {
          "description": "rational text show",
          "hierarchy": "Util MonadicPrettyPrintInternal",
          "module": "Util.MonadicPrettyPrintInternal",
          "name": "rational",
          "normalized": "Rational-\u003ea Doc",
          "package": "libcspm",
          "signature": "Rational-\u003em Doc",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Util-MonadicPrettyPrintInternal.html#v:rational"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA '}' character\n\u003c/p\u003e",
          "module": "Util.MonadicPrettyPrintInternal",
          "name": "rbrace",
          "package": "libcspm",
          "signature": "m Doc",
          "source": "src/Util-MonadicPrettyPrintInternal.html#rbrace",
          "type": "function"
        },
        "index": {
          "description": "character",
          "hierarchy": "Util MonadicPrettyPrintInternal",
          "module": "Util.MonadicPrettyPrintInternal",
          "name": "rbrace",
          "package": "libcspm",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Util-MonadicPrettyPrintInternal.html#v:rbrace"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA ']' character\n\u003c/p\u003e",
          "module": "Util.MonadicPrettyPrintInternal",
          "name": "rbrack",
          "package": "libcspm",
          "signature": "m Doc",
          "source": "src/Util-MonadicPrettyPrintInternal.html#rbrack",
          "type": "function"
        },
        "index": {
          "description": "character",
          "hierarchy": "Util MonadicPrettyPrintInternal",
          "module": "Util.MonadicPrettyPrintInternal",
          "name": "rbrack",
          "package": "libcspm",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Util-MonadicPrettyPrintInternal.html#v:rbrack"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRender the \u003ccode\u003eDoc\u003c/code\u003e to a String using the default \u003ccode\u003eStyle\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Util.MonadicPrettyPrintInternal",
          "name": "render",
          "package": "libcspm",
          "signature": "m Doc -\u003e m String",
          "source": "src/Util-MonadicPrettyPrintInternal.html#render",
          "type": "function"
        },
        "index": {
          "description": "Render the Doc to String using the default Style",
          "hierarchy": "Util MonadicPrettyPrintInternal",
          "module": "Util.MonadicPrettyPrintInternal",
          "name": "render",
          "normalized": "a Doc-\u003ea String",
          "package": "libcspm",
          "signature": "m Doc-\u003em String",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Util-MonadicPrettyPrintInternal.html#v:render"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRender the \u003ccode\u003eDoc\u003c/code\u003e to a String using the given \u003ccode\u003eStyle\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Util.MonadicPrettyPrintInternal",
          "name": "renderStyle",
          "package": "libcspm",
          "signature": "Style -\u003e m Doc -\u003e m String",
          "source": "src/Util-MonadicPrettyPrintInternal.html#renderStyle",
          "type": "function"
        },
        "index": {
          "description": "Render the Doc to String using the given Style",
          "hierarchy": "Util MonadicPrettyPrintInternal",
          "module": "Util.MonadicPrettyPrintInternal",
          "name": "renderStyle",
          "normalized": "Style-\u003ea Doc-\u003ea String",
          "package": "libcspm",
          "partial": "Style",
          "signature": "Style-\u003em Doc-\u003em String",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Util-MonadicPrettyPrintInternal.html#v:renderStyle"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRatio of ribbon length to line length\n\u003c/p\u003e",
          "module": "Util.MonadicPrettyPrintInternal",
          "name": "ribbonsPerLine",
          "package": "libcspm",
          "signature": "Float",
          "type": "function"
        },
        "index": {
          "description": "Ratio of ribbon length to line length",
          "hierarchy": "Util MonadicPrettyPrintInternal",
          "module": "Util.MonadicPrettyPrintInternal",
          "name": "ribbonsPerLine",
          "package": "libcspm",
          "partial": "Per Line",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Util-MonadicPrettyPrintInternal.html#v:ribbonsPerLine"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA ')' character\n\u003c/p\u003e",
          "module": "Util.MonadicPrettyPrintInternal",
          "name": "rparen",
          "package": "libcspm",
          "signature": "m Doc",
          "source": "src/Util-MonadicPrettyPrintInternal.html#rparen",
          "type": "function"
        },
        "index": {
          "description": "character",
          "hierarchy": "Util MonadicPrettyPrintInternal",
          "module": "Util.MonadicPrettyPrintInternal",
          "name": "rparen",
          "package": "libcspm",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Util-MonadicPrettyPrintInternal.html#v:rparen"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA ';' character\n\u003c/p\u003e",
          "module": "Util.MonadicPrettyPrintInternal",
          "name": "semi",
          "package": "libcspm",
          "signature": "m Doc",
          "source": "src/Util-MonadicPrettyPrintInternal.html#semi",
          "type": "function"
        },
        "index": {
          "description": "character",
          "hierarchy": "Util MonadicPrettyPrintInternal",
          "module": "Util.MonadicPrettyPrintInternal",
          "name": "semi",
          "package": "libcspm",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Util-MonadicPrettyPrintInternal.html#v:semi"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEither \u003ccode\u003e\u003ca\u003ehsep\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003evcat\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Util.MonadicPrettyPrintInternal",
          "name": "sep",
          "package": "libcspm",
          "signature": "m [Doc] -\u003e m Doc",
          "source": "src/Util-MonadicPrettyPrintInternal.html#sep",
          "type": "function"
        },
        "index": {
          "description": "Either hsep or vcat",
          "hierarchy": "Util MonadicPrettyPrintInternal",
          "module": "Util.MonadicPrettyPrintInternal",
          "name": "sep",
          "normalized": "a[Doc]-\u003ea Doc",
          "package": "libcspm",
          "signature": "m[Doc]-\u003em Doc",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Util-MonadicPrettyPrintInternal.html#v:sep"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSome text with any width. (\u003ccode\u003etext s = sizedText (length s) s\u003c/code\u003e)\n\u003c/p\u003e",
          "module": "Util.MonadicPrettyPrintInternal",
          "name": "sizedText",
          "package": "libcspm",
          "signature": "Int -\u003e String -\u003e m Doc",
          "source": "src/Util-MonadicPrettyPrintInternal.html#sizedText",
          "type": "function"
        },
        "index": {
          "description": "Some text with any width text sizedText length",
          "hierarchy": "Util MonadicPrettyPrintInternal",
          "module": "Util.MonadicPrettyPrintInternal",
          "name": "sizedText",
          "normalized": "Int-\u003eString-\u003ea Doc",
          "package": "libcspm",
          "partial": "Text",
          "signature": "Int-\u003eString-\u003em Doc",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Util-MonadicPrettyPrintInternal.html#v:sizedText"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA space character\n\u003c/p\u003e",
          "module": "Util.MonadicPrettyPrintInternal",
          "name": "space",
          "package": "libcspm",
          "signature": "m Doc",
          "source": "src/Util-MonadicPrettyPrintInternal.html#space",
          "type": "function"
        },
        "index": {
          "description": "space character",
          "hierarchy": "Util MonadicPrettyPrintInternal",
          "module": "Util.MonadicPrettyPrintInternal",
          "name": "space",
          "package": "libcspm",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Util-MonadicPrettyPrintInternal.html#v:space"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe default style (\u003ccode\u003emode=PageMode, lineLength=100, ribbonsPerLine=1.5\u003c/code\u003e).\n\u003c/p\u003e",
          "module": "Util.MonadicPrettyPrintInternal",
          "name": "style",
          "package": "libcspm",
          "signature": "Style",
          "type": "function"
        },
        "index": {
          "description": "The default style mode PageMode lineLength ribbonsPerLine",
          "hierarchy": "Util MonadicPrettyPrintInternal",
          "module": "Util.MonadicPrettyPrintInternal",
          "name": "style",
          "package": "libcspm",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Util-MonadicPrettyPrintInternal.html#v:style"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA document of height 1 containing a literal string.\n \u003ccode\u003e\u003ca\u003etext\u003c/a\u003e\u003c/code\u003e satisfies the following laws:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e\u003cpre\u003e\u003ccode\u003e\u003ca\u003etext\u003c/a\u003e\u003c/code\u003e s \u003ccode\u003e\u003ca\u003e\u003c\u003e\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003etext\u003c/a\u003e\u003c/code\u003e t = \u003ccode\u003e\u003ca\u003etext\u003c/a\u003e\u003c/code\u003e (s\u003ccode\u003e\u003ca\u003e++\u003c/a\u003e\u003c/code\u003et)\u003c/pre\u003e\u003c/li\u003e\u003cli\u003e \u003ccode\u003e\u003ccode\u003e\u003ca\u003etext\u003c/a\u003e\u003c/code\u003e \"\" \u003ccode\u003e\u003ca\u003e\u003c\u003e\u003c/a\u003e\u003c/code\u003e x = x\u003c/code\u003e, if \u003ccode\u003ex\u003c/code\u003e non-empty\n\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eThe side condition on the last law is necessary because \u003ccode\u003e\u003ccode\u003e\u003ca\u003etext\u003c/a\u003e\u003c/code\u003e \"\"\u003c/code\u003e\n has height 1, while \u003ccode\u003e\u003ca\u003eempty\u003c/a\u003e\u003c/code\u003e has no height.\n\u003c/p\u003e",
          "module": "Util.MonadicPrettyPrintInternal",
          "name": "text",
          "package": "libcspm",
          "signature": "String -\u003e m Doc",
          "source": "src/Util-MonadicPrettyPrintInternal.html#text",
          "type": "function"
        },
        "index": {
          "description": "document of height containing literal string text satisfies the following laws text text text text if non-empty The side condition on the last law is necessary because text has height while empty has no height",
          "hierarchy": "Util MonadicPrettyPrintInternal",
          "module": "Util.MonadicPrettyPrintInternal",
          "name": "text",
          "normalized": "String-\u003ea Doc",
          "package": "libcspm",
          "signature": "String-\u003em Doc",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Util-MonadicPrettyPrintInternal.html#v:text"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eList version of \u003ccode\u003e\u003ca\u003e$$\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Util.MonadicPrettyPrintInternal",
          "name": "vcat",
          "package": "libcspm",
          "signature": "m [Doc] -\u003e m Doc",
          "source": "src/Util-MonadicPrettyPrintInternal.html#vcat",
          "type": "function"
        },
        "index": {
          "description": "List version of",
          "hierarchy": "Util MonadicPrettyPrintInternal",
          "module": "Util.MonadicPrettyPrintInternal",
          "name": "vcat",
          "normalized": "a[Doc]-\u003ea Doc",
          "package": "libcspm",
          "signature": "m[Doc]-\u003em Doc",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Util-MonadicPrettyPrintInternal.html#v:vcat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSome text, but without any width. Use for non-printing text\n such as a HTML or Latex tags\n\u003c/p\u003e",
          "module": "Util.MonadicPrettyPrintInternal",
          "name": "zeroWidthText",
          "package": "libcspm",
          "signature": "String -\u003e m Doc",
          "source": "src/Util-MonadicPrettyPrintInternal.html#zeroWidthText",
          "type": "function"
        },
        "index": {
          "description": "Some text but without any width Use for non-printing text such as HTML or Latex tags",
          "hierarchy": "Util MonadicPrettyPrintInternal",
          "module": "Util.MonadicPrettyPrintInternal",
          "name": "zeroWidthText",
          "normalized": "String-\u003ea Doc",
          "package": "libcspm",
          "partial": "Width Text",
          "signature": "String-\u003em Doc",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Util-MonadicPrettyPrintInternal.html#v:zeroWidthText"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.PartialFunctions",
          "name": "PartialFunctions",
          "package": "libcspm",
          "source": "src/Util-PartialFunctions.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Util PartialFunctions",
          "module": "Util.PartialFunctions",
          "name": "PartialFunctions",
          "package": "libcspm",
          "partial": "Partial Functions",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Util-PartialFunctions.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.PartialFunctions",
          "name": "PartialFunction",
          "package": "libcspm",
          "source": "src/Util-PartialFunctions.html#PartialFunction",
          "type": "type"
        },
        "index": {
          "hierarchy": "Util PartialFunctions",
          "module": "Util.PartialFunctions",
          "name": "PartialFunction",
          "package": "libcspm",
          "partial": "Partial Function",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Util-PartialFunctions.html#t:PartialFunction"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.PartialFunctions",
          "name": "apply",
          "package": "libcspm",
          "signature": "PartialFunction a b -\u003e a -\u003e b",
          "source": "src/Util-PartialFunctions.html#apply",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util PartialFunctions",
          "module": "Util.PartialFunctions",
          "name": "apply",
          "normalized": "PartialFunction a b-\u003ea-\u003eb",
          "package": "libcspm",
          "signature": "PartialFunction a b-\u003ea-\u003eb",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Util-PartialFunctions.html#v:apply"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.PartialFunctions",
          "name": "applyRelation",
          "package": "libcspm",
          "signature": "PartialFunction a b -\u003e a -\u003e [b]",
          "source": "src/Util-PartialFunctions.html#applyRelation",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util PartialFunctions",
          "module": "Util.PartialFunctions",
          "name": "applyRelation",
          "normalized": "PartialFunction a b-\u003ea-\u003e[b]",
          "package": "libcspm",
          "partial": "Relation",
          "signature": "PartialFunction a b-\u003ea-\u003e[b]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Util-PartialFunctions.html#v:applyRelation"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.PartialFunctions",
          "name": "composeFunctions",
          "package": "libcspm",
          "signature": "PartialFunction b c -\u003e PartialFunction a b -\u003e PartialFunction a c",
          "source": "src/Util-PartialFunctions.html#composeFunctions",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util PartialFunctions",
          "module": "Util.PartialFunctions",
          "name": "composeFunctions",
          "normalized": "PartialFunction a b-\u003ePartialFunction c a-\u003ePartialFunction c b",
          "package": "libcspm",
          "partial": "Functions",
          "signature": "PartialFunction b c-\u003ePartialFunction a b-\u003ePartialFunction a c",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Util-PartialFunctions.html#v:composeFunctions"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.PartialFunctions",
          "name": "functionDomain",
          "package": "libcspm",
          "signature": "PartialFunction a b -\u003e [a]",
          "source": "src/Util-PartialFunctions.html#functionDomain",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util PartialFunctions",
          "module": "Util.PartialFunctions",
          "name": "functionDomain",
          "normalized": "PartialFunction a b-\u003e[a]",
          "package": "libcspm",
          "partial": "Domain",
          "signature": "PartialFunction a b-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Util-PartialFunctions.html#v:functionDomain"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.PartialFunctions",
          "name": "functionImage",
          "package": "libcspm",
          "signature": "PartialFunction a b -\u003e [b]",
          "source": "src/Util-PartialFunctions.html#functionImage",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util PartialFunctions",
          "module": "Util.PartialFunctions",
          "name": "functionImage",
          "normalized": "PartialFunction a b-\u003e[b]",
          "package": "libcspm",
          "partial": "Image",
          "signature": "PartialFunction a b-\u003e[b]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Util-PartialFunctions.html#v:functionImage"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.PartialFunctions",
          "name": "identityFunction",
          "package": "libcspm",
          "signature": "[a] -\u003e PartialFunction a a",
          "source": "src/Util-PartialFunctions.html#identityFunction",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util PartialFunctions",
          "module": "Util.PartialFunctions",
          "name": "identityFunction",
          "normalized": "[a]-\u003ePartialFunction a a",
          "package": "libcspm",
          "partial": "Function",
          "signature": "[a]-\u003ePartialFunction a a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Util-PartialFunctions.html#v:identityFunction"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.PartialFunctions",
          "name": "invert",
          "package": "libcspm",
          "signature": "PartialFunction a b -\u003e PartialFunction b a",
          "source": "src/Util-PartialFunctions.html#invert",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util PartialFunctions",
          "module": "Util.PartialFunctions",
          "name": "invert",
          "normalized": "PartialFunction a b-\u003ePartialFunction b a",
          "package": "libcspm",
          "signature": "PartialFunction a b-\u003ePartialFunction b a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Util-PartialFunctions.html#v:invert"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.PartialFunctions",
          "name": "mapPF",
          "package": "libcspm",
          "signature": "PartialFunction a b -\u003e [a] -\u003e [b]",
          "source": "src/Util-PartialFunctions.html#mapPF",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util PartialFunctions",
          "module": "Util.PartialFunctions",
          "name": "mapPF",
          "normalized": "PartialFunction a b-\u003e[a]-\u003e[b]",
          "package": "libcspm",
          "partial": "PF",
          "signature": "PartialFunction a b-\u003e[a]-\u003e[b]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Util-PartialFunctions.html#v:mapPF"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.PartialFunctions",
          "name": "removeEntry",
          "package": "libcspm",
          "signature": "PartialFunction a b -\u003e a -\u003e PartialFunction a b",
          "source": "src/Util-PartialFunctions.html#removeEntry",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util PartialFunctions",
          "module": "Util.PartialFunctions",
          "name": "removeEntry",
          "normalized": "PartialFunction a b-\u003ea-\u003ePartialFunction a b",
          "package": "libcspm",
          "partial": "Entry",
          "signature": "PartialFunction a b-\u003ea-\u003ePartialFunction a b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Util-PartialFunctions.html#v:removeEntry"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.PartialFunctions",
          "name": "safeApply",
          "package": "libcspm",
          "signature": "PartialFunction a b -\u003e a -\u003e Maybe b",
          "source": "src/Util-PartialFunctions.html#safeApply",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util PartialFunctions",
          "module": "Util.PartialFunctions",
          "name": "safeApply",
          "normalized": "PartialFunction a b-\u003ea-\u003eMaybe b",
          "package": "libcspm",
          "partial": "Apply",
          "signature": "PartialFunction a b-\u003ea-\u003eMaybe b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Util-PartialFunctions.html#v:safeApply"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.PartialFunctions",
          "name": "safeMapPF",
          "package": "libcspm",
          "signature": "PartialFunction a b -\u003e [a] -\u003e [b]",
          "source": "src/Util-PartialFunctions.html#safeMapPF",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util PartialFunctions",
          "module": "Util.PartialFunctions",
          "name": "safeMapPF",
          "normalized": "PartialFunction a b-\u003e[a]-\u003e[b]",
          "package": "libcspm",
          "partial": "Map PF",
          "signature": "PartialFunction a b-\u003e[a]-\u003e[b]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Util-PartialFunctions.html#v:safeMapPF"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.PartialFunctions",
          "name": "updatePF",
          "package": "libcspm",
          "signature": "PartialFunction a b -\u003e a -\u003e b -\u003e PartialFunction a b",
          "source": "src/Util-PartialFunctions.html#updatePF",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util PartialFunctions",
          "module": "Util.PartialFunctions",
          "name": "updatePF",
          "normalized": "PartialFunction a b-\u003ea-\u003eb-\u003ePartialFunction a b",
          "package": "libcspm",
          "partial": "PF",
          "signature": "PartialFunction a b-\u003ea-\u003eb-\u003ePartialFunction a b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Util-PartialFunctions.html#v:updatePF"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Precedence",
          "name": "Precedence",
          "package": "libcspm",
          "source": "src/Util-Precedence.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Util Precedence",
          "module": "Util.Precedence",
          "name": "Precedence",
          "package": "libcspm",
          "partial": "Precedence",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Util-Precedence.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe associativity of an operator\n\u003c/p\u003e",
          "module": "Util.Precedence",
          "name": "Associativity",
          "package": "libcspm",
          "source": "src/Util-Precedence.html#Associativity",
          "type": "data"
        },
        "index": {
          "description": "The associativity of an operator",
          "hierarchy": "Util Precedence",
          "module": "Util.Precedence",
          "name": "Associativity",
          "package": "libcspm",
          "partial": "Associativity",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Util-Precedence.html#t:Associativity"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Precedence",
          "name": "Precedence",
          "package": "libcspm",
          "source": "src/Util-Precedence.html#Precedence",
          "type": "class"
        },
        "index": {
          "hierarchy": "Util Precedence",
          "module": "Util.Precedence",
          "name": "Precedence",
          "package": "libcspm",
          "partial": "Precedence",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Util-Precedence.html#t:Precedence"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Precedence",
          "name": "AssocLeft",
          "package": "libcspm",
          "signature": "AssocLeft",
          "source": "src/Util-Precedence.html#Associativity",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util Precedence",
          "module": "Util.Precedence",
          "name": "AssocLeft",
          "package": "libcspm",
          "partial": "Assoc Left",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Util-Precedence.html#v:AssocLeft"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Precedence",
          "name": "AssocNone",
          "package": "libcspm",
          "signature": "AssocNone",
          "source": "src/Util-Precedence.html#Associativity",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util Precedence",
          "module": "Util.Precedence",
          "name": "AssocNone",
          "package": "libcspm",
          "partial": "Assoc None",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Util-Precedence.html#v:AssocNone"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Precedence",
          "name": "AssocRight",
          "package": "libcspm",
          "signature": "AssocRight",
          "source": "src/Util-Precedence.html#Associativity",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util Precedence",
          "module": "Util.Precedence",
          "name": "AssocRight",
          "package": "libcspm",
          "partial": "Assoc Right",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Util-Precedence.html#v:AssocRight"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturns the associativity of the operator.\n\u003c/p\u003e",
          "module": "Util.Precedence",
          "name": "associativity",
          "package": "libcspm",
          "signature": "a -\u003e Associativity",
          "source": "src/Util-Precedence.html#associativity",
          "type": "method"
        },
        "index": {
          "description": "Returns the associativity of the operator",
          "hierarchy": "Util Precedence",
          "module": "Util.Precedence",
          "name": "associativity",
          "normalized": "a-\u003eAssociativity",
          "package": "libcspm",
          "signature": "a-\u003eAssociativity",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Util-Precedence.html#v:associativity"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturns the binding strength of the operator. Higher numbers bind more\n loosely.\n\u003c/p\u003e",
          "module": "Util.Precedence",
          "name": "precedence",
          "package": "libcspm",
          "signature": "a -\u003e Int",
          "source": "src/Util-Precedence.html#precedence",
          "type": "method"
        },
        "index": {
          "description": "Returns the binding strength of the operator Higher numbers bind more loosely",
          "hierarchy": "Util Precedence",
          "module": "Util.Precedence",
          "name": "precedence",
          "normalized": "a-\u003eInt",
          "package": "libcspm",
          "signature": "a-\u003eInt",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Util-Precedence.html#v:precedence"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTrue if the two items are the same operator. This is used to decide\n when to paranthesise.\n\u003c/p\u003e",
          "module": "Util.Precedence",
          "name": "sameOperator",
          "package": "libcspm",
          "signature": "a -\u003e a -\u003e Bool",
          "source": "src/Util-Precedence.html#sameOperator",
          "type": "method"
        },
        "index": {
          "description": "True if the two items are the same operator This is used to decide when to paranthesise",
          "hierarchy": "Util Precedence",
          "module": "Util.Precedence",
          "name": "sameOperator",
          "normalized": "a-\u003ea-\u003eBool",
          "package": "libcspm",
          "partial": "Operator",
          "signature": "a-\u003ea-\u003eBool",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Util-Precedence.html#v:sameOperator"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eVarious miscellaneous functions utility functions.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Util.Prelude",
          "name": "Prelude",
          "package": "libcspm",
          "source": "src/Util-Prelude.html",
          "type": "module"
        },
        "index": {
          "description": "Various miscellaneous functions utility functions",
          "hierarchy": "Util Prelude",
          "module": "Util.Prelude",
          "name": "Prelude",
          "package": "libcspm",
          "partial": "Prelude",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Util-Prelude.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCompute the Cartesian product of a list of lists.\n\u003c/p\u003e",
          "module": "Util.Prelude",
          "name": "cartProduct",
          "package": "libcspm",
          "signature": "[[a]] -\u003e [[a]]",
          "source": "src/Util-Prelude.html#cartProduct",
          "type": "function"
        },
        "index": {
          "description": "Compute the Cartesian product of list of lists",
          "hierarchy": "Util Prelude",
          "module": "Util.Prelude",
          "name": "cartProduct",
          "normalized": "[[a]]-\u003e[[a]]",
          "package": "libcspm",
          "partial": "Product",
          "signature": "[[a]]-\u003e[[a]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Util-Prelude.html#v:cartProduct"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGiven a file path, if the first character is a ~ then\n expands the ~ to the users' home directory.\n\u003c/p\u003e",
          "module": "Util.Prelude",
          "name": "expandPathIO",
          "package": "libcspm",
          "signature": "String -\u003e IO String",
          "source": "src/Util-Prelude.html#expandPathIO",
          "type": "function"
        },
        "index": {
          "description": "Given file path if the first character is then expands the to the users home directory",
          "hierarchy": "Util Prelude",
          "module": "Util.Prelude",
          "name": "expandPathIO",
          "normalized": "String-\u003eIO String",
          "package": "libcspm",
          "partial": "Path IO",
          "signature": "String-\u003eIO String",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Util-Prelude.html#v:expandPathIO"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGiven two orderings, returns the second if the first is \n \u003ccode\u003e\u003ca\u003eEQ\u003c/a\u003e\u003c/code\u003e and returns the first otherwise.\n\u003c/p\u003e",
          "module": "Util.Prelude",
          "name": "thenCmp",
          "package": "libcspm",
          "signature": "Ordering -\u003e Ordering -\u003e Ordering",
          "source": "src/Util-Prelude.html#thenCmp",
          "type": "function"
        },
        "index": {
          "description": "Given two orderings returns the second if the first is EQ and returns the first otherwise",
          "hierarchy": "Util Prelude",
          "module": "Util.Prelude",
          "name": "thenCmp",
          "normalized": "Ordering-\u003eOrdering-\u003eOrdering",
          "package": "libcspm",
          "partial": "Cmp",
          "signature": "Ordering-\u003eOrdering-\u003eOrdering",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Util-Prelude.html#v:thenCmp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRemove whitespace from the beginning and end of a string.\n\u003c/p\u003e",
          "module": "Util.Prelude",
          "name": "trim",
          "package": "libcspm",
          "signature": "String -\u003e String",
          "source": "src/Util-Prelude.html#trim",
          "type": "function"
        },
        "index": {
          "description": "Remove whitespace from the beginning and end of string",
          "hierarchy": "Util Prelude",
          "module": "Util.Prelude",
          "name": "trim",
          "normalized": "String-\u003eString",
          "package": "libcspm",
          "signature": "String-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Util-Prelude.html#v:trim"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.PrettyPrint",
          "name": "PrettyPrint",
          "package": "libcspm",
          "source": "src/Util-PrettyPrint.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Util PrettyPrint",
          "module": "Util.PrettyPrint",
          "name": "PrettyPrint",
          "package": "libcspm",
          "partial": "Pretty Print",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Util-PrettyPrint.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.PrettyPrint",
          "name": "PrettyPrintable",
          "package": "libcspm",
          "source": "src/Util-PrettyPrint.html#PrettyPrintable",
          "type": "class"
        },
        "index": {
          "hierarchy": "Util PrettyPrint",
          "module": "Util.PrettyPrint",
          "name": "PrettyPrintable",
          "package": "libcspm",
          "partial": "Pretty Printable",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Util-PrettyPrint.html#t:PrettyPrintable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSurrounds a \u003ccode\u003e\u003ca\u003eDoc\u003c/a\u003e\u003c/code\u003e with \u003ccode\u003e\u003ca\u003e\u003c\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003e\u003e\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Util.PrettyPrint",
          "name": "angles",
          "package": "libcspm",
          "signature": "Doc -\u003e Doc",
          "source": "src/Util-PrettyPrint.html#angles",
          "type": "function"
        },
        "index": {
          "description": "Surrounds Doc with and",
          "hierarchy": "Util PrettyPrint",
          "module": "Util.PrettyPrint",
          "name": "angles",
          "normalized": "Doc-\u003eDoc",
          "package": "libcspm",
          "signature": "Doc-\u003eDoc",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Util-PrettyPrint.html#v:angles"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSurrounds a \u003ccode\u003e\u003ca\u003eDoc\u003c/a\u003e\u003c/code\u003e with '|'.\n\u003c/p\u003e",
          "module": "Util.PrettyPrint",
          "name": "bars",
          "package": "libcspm",
          "signature": "Doc -\u003e Doc",
          "source": "src/Util-PrettyPrint.html#bars",
          "type": "function"
        },
        "index": {
          "description": "Surrounds Doc with",
          "hierarchy": "Util PrettyPrint",
          "module": "Util.PrettyPrint",
          "name": "bars",
          "normalized": "Doc-\u003eDoc",
          "package": "libcspm",
          "signature": "Doc-\u003eDoc",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Util-PrettyPrint.html#v:bars"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePretty prints an integer and separates it into groups of 3, separated by\n commas.\n\u003c/p\u003e",
          "module": "Util.PrettyPrint",
          "name": "commaSeparatedInt",
          "package": "libcspm",
          "signature": "Int -\u003e Doc",
          "source": "src/Util-PrettyPrint.html#commaSeparatedInt",
          "type": "function"
        },
        "index": {
          "description": "Pretty prints an integer and separates it into groups of separated by commas",
          "hierarchy": "Util PrettyPrint",
          "module": "Util.PrettyPrint",
          "name": "commaSeparatedInt",
          "normalized": "Int-\u003eDoc",
          "package": "libcspm",
          "partial": "Separated Int",
          "signature": "Int-\u003eDoc",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Util-PrettyPrint.html#v:commaSeparatedInt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSeparates a list of \u003ccode\u003e\u003ca\u003eDoc\u003c/a\u003e\u003c/code\u003es by \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Util.PrettyPrint",
          "name": "dotSep",
          "package": "libcspm",
          "signature": "[Doc] -\u003e Doc",
          "source": "src/Util-PrettyPrint.html#dotSep",
          "type": "function"
        },
        "index": {
          "description": "Separates list of Doc by",
          "hierarchy": "Util PrettyPrint",
          "module": "Util.PrettyPrint",
          "name": "dotSep",
          "normalized": "[Doc]-\u003eDoc",
          "package": "libcspm",
          "partial": "Sep",
          "signature": "[Doc]-\u003eDoc",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Util-PrettyPrint.html#v:dotSep"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSeparates a list of \u003ccode\u003e\u003ca\u003eDoc\u003c/a\u003e\u003c/code\u003es by ','.\n\u003c/p\u003e",
          "module": "Util.PrettyPrint",
          "name": "list",
          "package": "libcspm",
          "signature": "[Doc] -\u003e Doc",
          "source": "src/Util-PrettyPrint.html#list",
          "type": "function"
        },
        "index": {
          "description": "Separates list of Doc by",
          "hierarchy": "Util PrettyPrint",
          "module": "Util.PrettyPrint",
          "name": "list",
          "normalized": "[Doc]-\u003eDoc",
          "package": "libcspm",
          "signature": "[Doc]-\u003eDoc",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Util-PrettyPrint.html#v:list"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.PrettyPrint",
          "name": "prettyPrint",
          "package": "libcspm",
          "signature": "a -\u003e Doc",
          "source": "src/Util-PrettyPrint.html#prettyPrint",
          "type": "method"
        },
        "index": {
          "hierarchy": "Util PrettyPrint",
          "module": "Util.PrettyPrint",
          "name": "prettyPrint",
          "normalized": "a-\u003eDoc",
          "package": "libcspm",
          "partial": "Print",
          "signature": "a-\u003eDoc",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Util-PrettyPrint.html#v:prettyPrint"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEquivalent to [d1, sep \u003ca/\u003e d2, sep \u003ca/\u003e d3, ...].\n\u003c/p\u003e",
          "module": "Util.PrettyPrint",
          "name": "punctuateFront",
          "package": "libcspm",
          "signature": "Doc -\u003e [Doc] -\u003e [Doc]",
          "source": "src/Util-PrettyPrint.html#punctuateFront",
          "type": "function"
        },
        "index": {
          "description": "Equivalent to d1 sep d2 sep d3",
          "hierarchy": "Util PrettyPrint",
          "module": "Util.PrettyPrint",
          "name": "punctuateFront",
          "normalized": "Doc-\u003e[Doc]-\u003e[Doc]",
          "package": "libcspm",
          "partial": "Front",
          "signature": "Doc-\u003e[Doc]-\u003e[Doc]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Util-PrettyPrint.html#v:punctuateFront"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eShow a double \u003ccode\u003ed\u003c/code\u003e printing only \u003ccode\u003eplaces\u003c/code\u003e places after the decimal place.\n\u003c/p\u003e",
          "module": "Util.PrettyPrint",
          "name": "shortDouble",
          "package": "libcspm",
          "signature": "Int -\u003e Double -\u003e Doc",
          "source": "src/Util-PrettyPrint.html#shortDouble",
          "type": "function"
        },
        "index": {
          "description": "Show double printing only places places after the decimal place",
          "hierarchy": "Util PrettyPrint",
          "module": "Util.PrettyPrint",
          "name": "shortDouble",
          "normalized": "Int-\u003eDouble-\u003eDoc",
          "package": "libcspm",
          "partial": "Double",
          "signature": "Int-\u003eDouble-\u003eDoc",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Util-PrettyPrint.html#v:shortDouble"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConverts a number into \u003ccode\u003e\u003ca\u003efirst\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003esecond\u003c/code\u003e etc.\n\u003c/p\u003e",
          "module": "Util.PrettyPrint",
          "name": "speakNth",
          "package": "libcspm",
          "signature": "Int -\u003e Doc",
          "source": "src/Util-PrettyPrint.html#speakNth",
          "type": "function"
        },
        "index": {
          "description": "Converts number into first second etc",
          "hierarchy": "Util PrettyPrint",
          "module": "Util.PrettyPrint",
          "name": "speakNth",
          "normalized": "Int-\u003eDoc",
          "package": "libcspm",
          "partial": "Nth",
          "signature": "Int-\u003eDoc",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Util-PrettyPrint.html#v:speakNth"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIndent a document by \u003ccode\u003e\u003ca\u003etabWidth\u003c/a\u003e\u003c/code\u003e characters, on each line\n (uses \u003ccode\u003e\u003ca\u003enest\u003c/a\u003e\u003c/code\u003e).\n\u003c/p\u003e",
          "module": "Util.PrettyPrint",
          "name": "tabIndent",
          "package": "libcspm",
          "signature": "Doc -\u003e Doc",
          "source": "src/Util-PrettyPrint.html#tabIndent",
          "type": "function"
        },
        "index": {
          "description": "Indent document by tabWidth characters on each line uses nest",
          "hierarchy": "Util PrettyPrint",
          "module": "Util.PrettyPrint",
          "name": "tabIndent",
          "normalized": "Doc-\u003eDoc",
          "package": "libcspm",
          "partial": "Indent",
          "signature": "Doc-\u003eDoc",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Util-PrettyPrint.html#v:tabIndent"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe width, in spaces, of a tab character.\n\u003c/p\u003e",
          "module": "Util.PrettyPrint",
          "name": "tabWidth",
          "package": "libcspm",
          "signature": "Int",
          "source": "src/Util-PrettyPrint.html#tabWidth",
          "type": "function"
        },
        "index": {
          "description": "The width in spaces of tab character",
          "hierarchy": "Util PrettyPrint",
          "module": "Util.PrettyPrint",
          "name": "tabWidth",
          "package": "libcspm",
          "partial": "Width",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/libcspm/docs/Util-PrettyPrint.html#v:tabWidth"
      }
    }
  ]
]