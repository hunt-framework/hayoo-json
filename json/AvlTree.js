[
  {
    "cmd": "delete-by-query",
    "query": {
      "contexts": [
        "package"
      ],
      "query": {
        "op": "case",
        "type": "word",
        "word": "AvlTree"
      },
      "type": "context"
    }
  },
  [
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module contains a large set of fairly comprehensive but extremely\n time consuming tests of AVL tree functions (not based on QuickCheck).\n\u003c/p\u003e\u003cp\u003eThey can all be run using \u003ccode\u003e\u003ca\u003eallTests\u003c/a\u003e\u003c/code\u003e, or they can be run individually.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.Tree.AVL.Test.AllTests",
          "name": "AllTests",
          "package": "AvlTree",
          "source": "src/Data-Tree-AVL-Test-AllTests.html",
          "type": "module"
        },
        "index": {
          "description": "This module contains large set of fairly comprehensive but extremely time consuming tests of AVL tree functions not based on QuickCheck They can all be run using allTests or they can be run individually",
          "hierarchy": "Data Tree AVL Test AllTests",
          "module": "Data.Tree.AVL.Test.AllTests",
          "name": "AllTests",
          "package": "AvlTree",
          "partial": "All Tests",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL-Test-AllTests.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRun every test in this module (takes a very long time).\n\u003c/p\u003e",
          "module": "Data.Tree.AVL.Test.AllTests",
          "name": "allTests",
          "package": "AvlTree",
          "signature": "IO ()",
          "source": "src/Data-Tree-AVL-Test-AllTests.html#allTests",
          "type": "function"
        },
        "index": {
          "description": "Run every test in this module takes very long time",
          "hierarchy": "Data Tree AVL Test AllTests",
          "module": "Data.Tree.AVL.Test.AllTests",
          "name": "allTests",
          "normalized": "IO()",
          "package": "AvlTree",
          "partial": "Tests",
          "signature": "IO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL-Test-AllTests.html#v:allTests"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTest assertDelL function\n Also exercises: asListL\n\u003c/p\u003e",
          "module": "Data.Tree.AVL.Test.AllTests",
          "name": "testAssertDelL",
          "package": "AvlTree",
          "signature": "IO ()",
          "source": "src/Data-Tree-AVL-Test-AllTests.html#testAssertDelL",
          "type": "function"
        },
        "index": {
          "description": "Test assertDelL function Also exercises asListL",
          "hierarchy": "Data Tree AVL Test AllTests",
          "module": "Data.Tree.AVL.Test.AllTests",
          "name": "testAssertDelL",
          "normalized": "IO()",
          "package": "AvlTree",
          "partial": "Assert Del",
          "signature": "IO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL-Test-AllTests.html#v:testAssertDelL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTest delR function\n Also exercises: asListR\n\u003c/p\u003e",
          "module": "Data.Tree.AVL.Test.AllTests",
          "name": "testAssertDelR",
          "package": "AvlTree",
          "signature": "IO ()",
          "source": "src/Data-Tree-AVL-Test-AllTests.html#testAssertDelR",
          "type": "function"
        },
        "index": {
          "description": "Test delR function Also exercises asListR",
          "hierarchy": "Data Tree AVL Test AllTests",
          "module": "Data.Tree.AVL.Test.AllTests",
          "name": "testAssertDelR",
          "normalized": "IO()",
          "package": "AvlTree",
          "partial": "Assert Del",
          "signature": "IO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL-Test-AllTests.html#v:testAssertDelR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTest assertPop function\n\u003c/p\u003e",
          "module": "Data.Tree.AVL.Test.AllTests",
          "name": "testAssertPop",
          "package": "AvlTree",
          "signature": "IO ()",
          "source": "src/Data-Tree-AVL-Test-AllTests.html#testAssertPop",
          "type": "function"
        },
        "index": {
          "description": "Test assertPop function",
          "hierarchy": "Data Tree AVL Test AllTests",
          "module": "Data.Tree.AVL.Test.AllTests",
          "name": "testAssertPop",
          "normalized": "IO()",
          "package": "AvlTree",
          "partial": "Assert Pop",
          "signature": "IO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL-Test-AllTests.html#v:testAssertPop"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTest assertPopL function\n Also exercises: asListL\n\u003c/p\u003e",
          "module": "Data.Tree.AVL.Test.AllTests",
          "name": "testAssertPopL",
          "package": "AvlTree",
          "signature": "IO ()",
          "source": "src/Data-Tree-AVL-Test-AllTests.html#testAssertPopL",
          "type": "function"
        },
        "index": {
          "description": "Test assertPopL function Also exercises asListL",
          "hierarchy": "Data Tree AVL Test AllTests",
          "module": "Data.Tree.AVL.Test.AllTests",
          "name": "testAssertPopL",
          "normalized": "IO()",
          "package": "AvlTree",
          "partial": "Assert Pop",
          "signature": "IO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL-Test-AllTests.html#v:testAssertPopL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTest assertPopR function\n Also exercises: asListR\n\u003c/p\u003e",
          "module": "Data.Tree.AVL.Test.AllTests",
          "name": "testAssertPopR",
          "package": "AvlTree",
          "signature": "IO ()",
          "source": "src/Data-Tree-AVL-Test-AllTests.html#testAssertPopR",
          "type": "function"
        },
        "index": {
          "description": "Test assertPopR function Also exercises asListR",
          "hierarchy": "Data Tree AVL Test AllTests",
          "module": "Data.Tree.AVL.Test.AllTests",
          "name": "testAssertPopR",
          "normalized": "IO()",
          "package": "AvlTree",
          "partial": "Assert Pop",
          "signature": "IO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL-Test-AllTests.html#v:testAssertPopR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTest anyBAVLtoEither\n\u003c/p\u003e",
          "module": "Data.Tree.AVL.Test.AllTests",
          "name": "testBAVLtoZipper",
          "package": "AvlTree",
          "signature": "IO ()",
          "source": "src/Data-Tree-AVL-Test-AllTests.html#testBAVLtoZipper",
          "type": "function"
        },
        "index": {
          "description": "Test anyBAVLtoEither",
          "hierarchy": "Data Tree AVL Test AllTests",
          "module": "Data.Tree.AVL.Test.AllTests",
          "name": "testBAVLtoZipper",
          "normalized": "IO()",
          "package": "AvlTree",
          "partial": "BAVLto Zipper",
          "signature": "IO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL-Test-AllTests.html#v:testBAVLtoZipper"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTest clipSize function\n\u003c/p\u003e",
          "module": "Data.Tree.AVL.Test.AllTests",
          "name": "testClipSize",
          "package": "AvlTree",
          "signature": "IO ()",
          "source": "src/Data-Tree-AVL-Test-AllTests.html#testClipSize",
          "type": "function"
        },
        "index": {
          "description": "Test clipSize function",
          "hierarchy": "Data Tree AVL Test AllTests",
          "module": "Data.Tree.AVL.Test.AllTests",
          "name": "testClipSize",
          "normalized": "IO()",
          "package": "AvlTree",
          "partial": "Clip Size",
          "signature": "IO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL-Test-AllTests.html#v:testClipSize"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTest compareHeight function\n\u003c/p\u003e",
          "module": "Data.Tree.AVL.Test.AllTests",
          "name": "testCompareHeight",
          "package": "AvlTree",
          "signature": "IO ()",
          "source": "src/Data-Tree-AVL-Test-AllTests.html#testCompareHeight",
          "type": "function"
        },
        "index": {
          "description": "Test compareHeight function",
          "hierarchy": "Data Tree AVL Test AllTests",
          "module": "Data.Tree.AVL.Test.AllTests",
          "name": "testCompareHeight",
          "normalized": "IO()",
          "package": "AvlTree",
          "partial": "Compare Height",
          "signature": "IO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL-Test-AllTests.html#v:testCompareHeight"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTest the concatAVL function.\n\u003c/p\u003e",
          "module": "Data.Tree.AVL.Test.AllTests",
          "name": "testConcatAVL",
          "package": "AvlTree",
          "signature": "IO ()",
          "source": "src/Data-Tree-AVL-Test-AllTests.html#testConcatAVL",
          "type": "function"
        },
        "index": {
          "description": "Test the concatAVL function",
          "hierarchy": "Data Tree AVL Test AllTests",
          "module": "Data.Tree.AVL.Test.AllTests",
          "name": "testConcatAVL",
          "normalized": "IO()",
          "package": "AvlTree",
          "partial": "Concat AVL",
          "signature": "IO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL-Test-AllTests.html#v:testConcatAVL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTest Zipper delAllCloseL\n\u003c/p\u003e",
          "module": "Data.Tree.AVL.Test.AllTests",
          "name": "testDelAllCloseL",
          "package": "AvlTree",
          "signature": "IO ()",
          "source": "src/Data-Tree-AVL-Test-AllTests.html#testDelAllCloseL",
          "type": "function"
        },
        "index": {
          "description": "Test Zipper delAllCloseL",
          "hierarchy": "Data Tree AVL Test AllTests",
          "module": "Data.Tree.AVL.Test.AllTests",
          "name": "testDelAllCloseL",
          "normalized": "IO()",
          "package": "AvlTree",
          "partial": "Del All Close",
          "signature": "IO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL-Test-AllTests.html#v:testDelAllCloseL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTest Zipper delAllCloseR\n\u003c/p\u003e",
          "module": "Data.Tree.AVL.Test.AllTests",
          "name": "testDelAllCloseR",
          "package": "AvlTree",
          "signature": "IO ()",
          "source": "src/Data-Tree-AVL-Test-AllTests.html#testDelAllCloseR",
          "type": "function"
        },
        "index": {
          "description": "Test Zipper delAllCloseR",
          "hierarchy": "Data Tree AVL Test AllTests",
          "module": "Data.Tree.AVL.Test.AllTests",
          "name": "testDelAllCloseR",
          "normalized": "IO()",
          "package": "AvlTree",
          "partial": "Del All Close",
          "signature": "IO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL-Test-AllTests.html#v:testDelAllCloseR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTest Zipper delAllIncCloseL\n\u003c/p\u003e",
          "module": "Data.Tree.AVL.Test.AllTests",
          "name": "testDelAllIncCloseL",
          "package": "AvlTree",
          "signature": "IO ()",
          "source": "src/Data-Tree-AVL-Test-AllTests.html#testDelAllIncCloseL",
          "type": "function"
        },
        "index": {
          "description": "Test Zipper delAllIncCloseL",
          "hierarchy": "Data Tree AVL Test AllTests",
          "module": "Data.Tree.AVL.Test.AllTests",
          "name": "testDelAllIncCloseL",
          "normalized": "IO()",
          "package": "AvlTree",
          "partial": "Del All Inc Close",
          "signature": "IO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL-Test-AllTests.html#v:testDelAllIncCloseL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTest Zipper delAllIncCloseR\n\u003c/p\u003e",
          "module": "Data.Tree.AVL.Test.AllTests",
          "name": "testDelAllIncCloseR",
          "package": "AvlTree",
          "signature": "IO ()",
          "source": "src/Data-Tree-AVL-Test-AllTests.html#testDelAllIncCloseR",
          "type": "function"
        },
        "index": {
          "description": "Test Zipper delAllIncCloseR",
          "hierarchy": "Data Tree AVL Test AllTests",
          "module": "Data.Tree.AVL.Test.AllTests",
          "name": "testDelAllIncCloseR",
          "normalized": "IO()",
          "package": "AvlTree",
          "partial": "Del All Inc Close",
          "signature": "IO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL-Test-AllTests.html#v:testDelAllIncCloseR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTest Zipper delAllL\n\u003c/p\u003e",
          "module": "Data.Tree.AVL.Test.AllTests",
          "name": "testDelAllL",
          "package": "AvlTree",
          "signature": "IO ()",
          "source": "src/Data-Tree-AVL-Test-AllTests.html#testDelAllL",
          "type": "function"
        },
        "index": {
          "description": "Test Zipper delAllL",
          "hierarchy": "Data Tree AVL Test AllTests",
          "module": "Data.Tree.AVL.Test.AllTests",
          "name": "testDelAllL",
          "normalized": "IO()",
          "package": "AvlTree",
          "partial": "Del All",
          "signature": "IO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL-Test-AllTests.html#v:testDelAllL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTest Zipper delAllR\n\u003c/p\u003e",
          "module": "Data.Tree.AVL.Test.AllTests",
          "name": "testDelAllR",
          "package": "AvlTree",
          "signature": "IO ()",
          "source": "src/Data-Tree-AVL-Test-AllTests.html#testDelAllR",
          "type": "function"
        },
        "index": {
          "description": "Test Zipper delAllR",
          "hierarchy": "Data Tree AVL Test AllTests",
          "module": "Data.Tree.AVL.Test.AllTests",
          "name": "testDelAllR",
          "normalized": "IO()",
          "package": "AvlTree",
          "partial": "Del All",
          "signature": "IO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL-Test-AllTests.html#v:testDelAllR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTest Zipper delClose\n\u003c/p\u003e",
          "module": "Data.Tree.AVL.Test.AllTests",
          "name": "testDelClose",
          "package": "AvlTree",
          "signature": "IO ()",
          "source": "src/Data-Tree-AVL-Test-AllTests.html#testDelClose",
          "type": "function"
        },
        "index": {
          "description": "Test Zipper delClose",
          "hierarchy": "Data Tree AVL Test AllTests",
          "module": "Data.Tree.AVL.Test.AllTests",
          "name": "testDelClose",
          "normalized": "IO()",
          "package": "AvlTree",
          "partial": "Del Close",
          "signature": "IO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL-Test-AllTests.html#v:testDelClose"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTest Zipper assertDelMoveL\n\u003c/p\u003e",
          "module": "Data.Tree.AVL.Test.AllTests",
          "name": "testDelMoveL",
          "package": "AvlTree",
          "signature": "IO ()",
          "source": "src/Data-Tree-AVL-Test-AllTests.html#testDelMoveL",
          "type": "function"
        },
        "index": {
          "description": "Test Zipper assertDelMoveL",
          "hierarchy": "Data Tree AVL Test AllTests",
          "module": "Data.Tree.AVL.Test.AllTests",
          "name": "testDelMoveL",
          "normalized": "IO()",
          "package": "AvlTree",
          "partial": "Del Move",
          "signature": "IO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL-Test-AllTests.html#v:testDelMoveL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTest Zipper assertDelMoveR\n\u003c/p\u003e",
          "module": "Data.Tree.AVL.Test.AllTests",
          "name": "testDelMoveR",
          "package": "AvlTree",
          "signature": "IO ()",
          "source": "src/Data-Tree-AVL-Test-AllTests.html#testDelMoveR",
          "type": "function"
        },
        "index": {
          "description": "Test Zipper assertDelMoveR",
          "hierarchy": "Data Tree AVL Test AllTests",
          "module": "Data.Tree.AVL.Test.AllTests",
          "name": "testDelMoveR",
          "normalized": "IO()",
          "package": "AvlTree",
          "partial": "Del Move",
          "signature": "IO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL-Test-AllTests.html#v:testDelMoveR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTest delete function\n\u003c/p\u003e",
          "module": "Data.Tree.AVL.Test.AllTests",
          "name": "testDelete",
          "package": "AvlTree",
          "signature": "IO ()",
          "source": "src/Data-Tree-AVL-Test-AllTests.html#testDelete",
          "type": "function"
        },
        "index": {
          "description": "Test delete function",
          "hierarchy": "Data Tree AVL Test AllTests",
          "module": "Data.Tree.AVL.Test.AllTests",
          "name": "testDelete",
          "normalized": "IO()",
          "package": "AvlTree",
          "partial": "Delete",
          "signature": "IO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL-Test-AllTests.html#v:testDelete"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTest the difference function\n\u003c/p\u003e",
          "module": "Data.Tree.AVL.Test.AllTests",
          "name": "testDifference",
          "package": "AvlTree",
          "signature": "IO ()",
          "source": "src/Data-Tree-AVL-Test-AllTests.html#testDifference",
          "type": "function"
        },
        "index": {
          "description": "Test the difference function",
          "hierarchy": "Data Tree AVL Test AllTests",
          "module": "Data.Tree.AVL.Test.AllTests",
          "name": "testDifference",
          "normalized": "IO()",
          "package": "AvlTree",
          "partial": "Difference",
          "signature": "IO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL-Test-AllTests.html#v:testDifference"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTest the differenceMaybe function\n\u003c/p\u003e",
          "module": "Data.Tree.AVL.Test.AllTests",
          "name": "testDifferenceMaybe",
          "package": "AvlTree",
          "signature": "IO ()",
          "source": "src/Data-Tree-AVL-Test-AllTests.html#testDifferenceMaybe",
          "type": "function"
        },
        "index": {
          "description": "Test the differenceMaybe function",
          "hierarchy": "Data Tree AVL Test AllTests",
          "module": "Data.Tree.AVL.Test.AllTests",
          "name": "testDifferenceMaybe",
          "normalized": "IO()",
          "package": "AvlTree",
          "partial": "Difference Maybe",
          "signature": "IO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL-Test-AllTests.html#v:testDifferenceMaybe"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTest the disjointUnion function\n\u003c/p\u003e",
          "module": "Data.Tree.AVL.Test.AllTests",
          "name": "testDisjointUnion",
          "package": "AvlTree",
          "signature": "IO ()",
          "source": "src/Data-Tree-AVL-Test-AllTests.html#testDisjointUnion",
          "type": "function"
        },
        "index": {
          "description": "Test the disjointUnion function",
          "hierarchy": "Data Tree AVL Test AllTests",
          "module": "Data.Tree.AVL.Test.AllTests",
          "name": "testDisjointUnion",
          "normalized": "IO()",
          "package": "AvlTree",
          "partial": "Disjoint Union",
          "signature": "IO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL-Test-AllTests.html#v:testDisjointUnion"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTest dropL function\n\u003c/p\u003e",
          "module": "Data.Tree.AVL.Test.AllTests",
          "name": "testDropL",
          "package": "AvlTree",
          "signature": "IO ()",
          "source": "src/Data-Tree-AVL-Test-AllTests.html#testDropL",
          "type": "function"
        },
        "index": {
          "description": "Test dropL function",
          "hierarchy": "Data Tree AVL Test AllTests",
          "module": "Data.Tree.AVL.Test.AllTests",
          "name": "testDropL",
          "normalized": "IO()",
          "package": "AvlTree",
          "partial": "Drop",
          "signature": "IO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL-Test-AllTests.html#v:testDropL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTest dropR function\n\u003c/p\u003e",
          "module": "Data.Tree.AVL.Test.AllTests",
          "name": "testDropR",
          "package": "AvlTree",
          "signature": "IO ()",
          "source": "src/Data-Tree-AVL-Test-AllTests.html#testDropR",
          "type": "function"
        },
        "index": {
          "description": "Test dropR function",
          "hierarchy": "Data Tree AVL Test AllTests",
          "module": "Data.Tree.AVL.Test.AllTests",
          "name": "testDropR",
          "normalized": "IO()",
          "package": "AvlTree",
          "partial": "Drop",
          "signature": "IO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL-Test-AllTests.html#v:testDropR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTest dropWhileL function\n\u003c/p\u003e",
          "module": "Data.Tree.AVL.Test.AllTests",
          "name": "testDropWhileL",
          "package": "AvlTree",
          "signature": "IO ()",
          "source": "src/Data-Tree-AVL-Test-AllTests.html#testDropWhileL",
          "type": "function"
        },
        "index": {
          "description": "Test dropWhileL function",
          "hierarchy": "Data Tree AVL Test AllTests",
          "module": "Data.Tree.AVL.Test.AllTests",
          "name": "testDropWhileL",
          "normalized": "IO()",
          "package": "AvlTree",
          "partial": "Drop While",
          "signature": "IO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL-Test-AllTests.html#v:testDropWhileL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTest dropWhileR function\n\u003c/p\u003e",
          "module": "Data.Tree.AVL.Test.AllTests",
          "name": "testDropWhileR",
          "package": "AvlTree",
          "signature": "IO ()",
          "source": "src/Data-Tree-AVL-Test-AllTests.html#testDropWhileR",
          "type": "function"
        },
        "index": {
          "description": "Test dropWhileR function",
          "hierarchy": "Data Tree AVL Test AllTests",
          "module": "Data.Tree.AVL.Test.AllTests",
          "name": "testDropWhileR",
          "normalized": "IO()",
          "package": "AvlTree",
          "partial": "Drop While",
          "signature": "IO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL-Test-AllTests.html#v:testDropWhileR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTest the filter function\n\u003c/p\u003e",
          "module": "Data.Tree.AVL.Test.AllTests",
          "name": "testFilter",
          "package": "AvlTree",
          "signature": "IO ()",
          "source": "src/Data-Tree-AVL-Test-AllTests.html#testFilter",
          "type": "function"
        },
        "index": {
          "description": "Test the filter function",
          "hierarchy": "Data Tree AVL Test AllTests",
          "module": "Data.Tree.AVL.Test.AllTests",
          "name": "testFilter",
          "normalized": "IO()",
          "package": "AvlTree",
          "partial": "Filter",
          "signature": "IO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL-Test-AllTests.html#v:testFilter"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTest the filterViaList function\n\u003c/p\u003e",
          "module": "Data.Tree.AVL.Test.AllTests",
          "name": "testFilterViaList",
          "package": "AvlTree",
          "signature": "IO ()",
          "source": "src/Data-Tree-AVL-Test-AllTests.html#testFilterViaList",
          "type": "function"
        },
        "index": {
          "description": "Test the filterViaList function",
          "hierarchy": "Data Tree AVL Test AllTests",
          "module": "Data.Tree.AVL.Test.AllTests",
          "name": "testFilterViaList",
          "normalized": "IO()",
          "package": "AvlTree",
          "partial": "Filter Via List",
          "signature": "IO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL-Test-AllTests.html#v:testFilterViaList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTest the flatConcat function.\n\u003c/p\u003e",
          "module": "Data.Tree.AVL.Test.AllTests",
          "name": "testFlatConcat",
          "package": "AvlTree",
          "signature": "IO ()",
          "source": "src/Data-Tree-AVL-Test-AllTests.html#testFlatConcat",
          "type": "function"
        },
        "index": {
          "description": "Test the flatConcat function",
          "hierarchy": "Data Tree AVL Test AllTests",
          "module": "Data.Tree.AVL.Test.AllTests",
          "name": "testFlatConcat",
          "normalized": "IO()",
          "package": "AvlTree",
          "partial": "Flat Concat",
          "signature": "IO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL-Test-AllTests.html#v:testFlatConcat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTest flatten function\n Also exercises: asListL,replicateAVL\n\u003c/p\u003e",
          "module": "Data.Tree.AVL.Test.AllTests",
          "name": "testFlatten",
          "package": "AvlTree",
          "signature": "IO ()",
          "source": "src/Data-Tree-AVL-Test-AllTests.html#testFlatten",
          "type": "function"
        },
        "index": {
          "description": "Test flatten function Also exercises asListL replicateAVL",
          "hierarchy": "Data Tree AVL Test AllTests",
          "module": "Data.Tree.AVL.Test.AllTests",
          "name": "testFlatten",
          "normalized": "IO()",
          "package": "AvlTree",
          "partial": "Flatten",
          "signature": "IO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL-Test-AllTests.html#v:testFlatten"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTest foldl\n\u003c/p\u003e",
          "module": "Data.Tree.AVL.Test.AllTests",
          "name": "testFoldl",
          "package": "AvlTree",
          "signature": "IO ()",
          "source": "src/Data-Tree-AVL-Test-AllTests.html#testFoldl",
          "type": "function"
        },
        "index": {
          "description": "Test foldl",
          "hierarchy": "Data Tree AVL Test AllTests",
          "module": "Data.Tree.AVL.Test.AllTests",
          "name": "testFoldl",
          "normalized": "IO()",
          "package": "AvlTree",
          "partial": "Foldl",
          "signature": "IO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL-Test-AllTests.html#v:testFoldl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTest foldl'\n\u003c/p\u003e",
          "module": "Data.Tree.AVL.Test.AllTests",
          "name": "testFoldl'",
          "package": "AvlTree",
          "signature": "IO ()",
          "source": "src/Data-Tree-AVL-Test-AllTests.html#testFoldl%27",
          "type": "function"
        },
        "index": {
          "description": "Test foldl",
          "hierarchy": "Data Tree AVL Test AllTests",
          "module": "Data.Tree.AVL.Test.AllTests",
          "name": "testFoldl'",
          "normalized": "IO()",
          "package": "AvlTree",
          "partial": "Foldl'",
          "signature": "IO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL-Test-AllTests.html#v:testFoldl-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTest foldl1\n\u003c/p\u003e",
          "module": "Data.Tree.AVL.Test.AllTests",
          "name": "testFoldl1",
          "package": "AvlTree",
          "signature": "IO ()",
          "source": "src/Data-Tree-AVL-Test-AllTests.html#testFoldl1",
          "type": "function"
        },
        "index": {
          "description": "Test foldl1",
          "hierarchy": "Data Tree AVL Test AllTests",
          "module": "Data.Tree.AVL.Test.AllTests",
          "name": "testFoldl1",
          "normalized": "IO()",
          "package": "AvlTree",
          "partial": "Foldl",
          "signature": "IO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL-Test-AllTests.html#v:testFoldl1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTest foldl1'\n\u003c/p\u003e",
          "module": "Data.Tree.AVL.Test.AllTests",
          "name": "testFoldl1'",
          "package": "AvlTree",
          "signature": "IO ()",
          "source": "src/Data-Tree-AVL-Test-AllTests.html#testFoldl1%27",
          "type": "function"
        },
        "index": {
          "description": "Test foldl1",
          "hierarchy": "Data Tree AVL Test AllTests",
          "module": "Data.Tree.AVL.Test.AllTests",
          "name": "testFoldl1'",
          "normalized": "IO()",
          "package": "AvlTree",
          "partial": "Foldl",
          "signature": "IO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL-Test-AllTests.html#v:testFoldl1-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTest foldr\n\u003c/p\u003e",
          "module": "Data.Tree.AVL.Test.AllTests",
          "name": "testFoldr",
          "package": "AvlTree",
          "signature": "IO ()",
          "source": "src/Data-Tree-AVL-Test-AllTests.html#testFoldr",
          "type": "function"
        },
        "index": {
          "description": "Test foldr",
          "hierarchy": "Data Tree AVL Test AllTests",
          "module": "Data.Tree.AVL.Test.AllTests",
          "name": "testFoldr",
          "normalized": "IO()",
          "package": "AvlTree",
          "partial": "Foldr",
          "signature": "IO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL-Test-AllTests.html#v:testFoldr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTest foldr'\n\u003c/p\u003e",
          "module": "Data.Tree.AVL.Test.AllTests",
          "name": "testFoldr'",
          "package": "AvlTree",
          "signature": "IO ()",
          "source": "src/Data-Tree-AVL-Test-AllTests.html#testFoldr%27",
          "type": "function"
        },
        "index": {
          "description": "Test foldr",
          "hierarchy": "Data Tree AVL Test AllTests",
          "module": "Data.Tree.AVL.Test.AllTests",
          "name": "testFoldr'",
          "normalized": "IO()",
          "package": "AvlTree",
          "partial": "Foldr'",
          "signature": "IO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL-Test-AllTests.html#v:testFoldr-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTest foldr1\n\u003c/p\u003e",
          "module": "Data.Tree.AVL.Test.AllTests",
          "name": "testFoldr1",
          "package": "AvlTree",
          "signature": "IO ()",
          "source": "src/Data-Tree-AVL-Test-AllTests.html#testFoldr1",
          "type": "function"
        },
        "index": {
          "description": "Test foldr1",
          "hierarchy": "Data Tree AVL Test AllTests",
          "module": "Data.Tree.AVL.Test.AllTests",
          "name": "testFoldr1",
          "normalized": "IO()",
          "package": "AvlTree",
          "partial": "Foldr",
          "signature": "IO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL-Test-AllTests.html#v:testFoldr1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTest foldr1'\n\u003c/p\u003e",
          "module": "Data.Tree.AVL.Test.AllTests",
          "name": "testFoldr1'",
          "package": "AvlTree",
          "signature": "IO ()",
          "source": "src/Data-Tree-AVL-Test-AllTests.html#testFoldr1%27",
          "type": "function"
        },
        "index": {
          "description": "Test foldr1",
          "hierarchy": "Data Tree AVL Test AllTests",
          "module": "Data.Tree.AVL.Test.AllTests",
          "name": "testFoldr1'",
          "normalized": "IO()",
          "package": "AvlTree",
          "partial": "Foldr",
          "signature": "IO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL-Test-AllTests.html#v:testFoldr1-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTest fork function\n\u003c/p\u003e",
          "module": "Data.Tree.AVL.Test.AllTests",
          "name": "testFork",
          "package": "AvlTree",
          "signature": "IO ()",
          "source": "src/Data-Tree-AVL-Test-AllTests.html#testFork",
          "type": "function"
        },
        "index": {
          "description": "Test fork function",
          "hierarchy": "Data Tree AVL Test AllTests",
          "module": "Data.Tree.AVL.Test.AllTests",
          "name": "testFork",
          "normalized": "IO()",
          "package": "AvlTree",
          "partial": "Fork",
          "signature": "IO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL-Test-AllTests.html#v:testFork"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTest forkL function\n\u003c/p\u003e",
          "module": "Data.Tree.AVL.Test.AllTests",
          "name": "testForkL",
          "package": "AvlTree",
          "signature": "IO ()",
          "source": "src/Data-Tree-AVL-Test-AllTests.html#testForkL",
          "type": "function"
        },
        "index": {
          "description": "Test forkL function",
          "hierarchy": "Data Tree AVL Test AllTests",
          "module": "Data.Tree.AVL.Test.AllTests",
          "name": "testForkL",
          "normalized": "IO()",
          "package": "AvlTree",
          "partial": "Fork",
          "signature": "IO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL-Test-AllTests.html#v:testForkL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTest forkR function\n\u003c/p\u003e",
          "module": "Data.Tree.AVL.Test.AllTests",
          "name": "testForkR",
          "package": "AvlTree",
          "signature": "IO ()",
          "source": "src/Data-Tree-AVL-Test-AllTests.html#testForkR",
          "type": "function"
        },
        "index": {
          "description": "Test forkR function",
          "hierarchy": "Data Tree AVL Test AllTests",
          "module": "Data.Tree.AVL.Test.AllTests",
          "name": "testForkR",
          "normalized": "IO()",
          "package": "AvlTree",
          "partial": "Fork",
          "signature": "IO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL-Test-AllTests.html#v:testForkR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTest Zipper insertL\n\u003c/p\u003e",
          "module": "Data.Tree.AVL.Test.AllTests",
          "name": "testInsertL",
          "package": "AvlTree",
          "signature": "IO ()",
          "source": "src/Data-Tree-AVL-Test-AllTests.html#testInsertL",
          "type": "function"
        },
        "index": {
          "description": "Test Zipper insertL",
          "hierarchy": "Data Tree AVL Test AllTests",
          "module": "Data.Tree.AVL.Test.AllTests",
          "name": "testInsertL",
          "normalized": "IO()",
          "package": "AvlTree",
          "partial": "Insert",
          "signature": "IO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL-Test-AllTests.html#v:testInsertL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTest Zipper insertMoveL\n\u003c/p\u003e",
          "module": "Data.Tree.AVL.Test.AllTests",
          "name": "testInsertMoveL",
          "package": "AvlTree",
          "signature": "IO ()",
          "source": "src/Data-Tree-AVL-Test-AllTests.html#testInsertMoveL",
          "type": "function"
        },
        "index": {
          "description": "Test Zipper insertMoveL",
          "hierarchy": "Data Tree AVL Test AllTests",
          "module": "Data.Tree.AVL.Test.AllTests",
          "name": "testInsertMoveL",
          "normalized": "IO()",
          "package": "AvlTree",
          "partial": "Insert Move",
          "signature": "IO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL-Test-AllTests.html#v:testInsertMoveL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTest Zipper insertMoveR\n\u003c/p\u003e",
          "module": "Data.Tree.AVL.Test.AllTests",
          "name": "testInsertMoveR",
          "package": "AvlTree",
          "signature": "IO ()",
          "source": "src/Data-Tree-AVL-Test-AllTests.html#testInsertMoveR",
          "type": "function"
        },
        "index": {
          "description": "Test Zipper insertMoveR",
          "hierarchy": "Data Tree AVL Test AllTests",
          "module": "Data.Tree.AVL.Test.AllTests",
          "name": "testInsertMoveR",
          "normalized": "IO()",
          "package": "AvlTree",
          "partial": "Insert Move",
          "signature": "IO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL-Test-AllTests.html#v:testInsertMoveR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTest Zipper insertR\n\u003c/p\u003e",
          "module": "Data.Tree.AVL.Test.AllTests",
          "name": "testInsertR",
          "package": "AvlTree",
          "signature": "IO ()",
          "source": "src/Data-Tree-AVL-Test-AllTests.html#testInsertR",
          "type": "function"
        },
        "index": {
          "description": "Test Zipper insertR",
          "hierarchy": "Data Tree AVL Test AllTests",
          "module": "Data.Tree.AVL.Test.AllTests",
          "name": "testInsertR",
          "normalized": "IO()",
          "package": "AvlTree",
          "partial": "Insert",
          "signature": "IO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL-Test-AllTests.html#v:testInsertR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTest Zipper insertTreeL\n\u003c/p\u003e",
          "module": "Data.Tree.AVL.Test.AllTests",
          "name": "testInsertTreeL",
          "package": "AvlTree",
          "signature": "IO ()",
          "source": "src/Data-Tree-AVL-Test-AllTests.html#testInsertTreeL",
          "type": "function"
        },
        "index": {
          "description": "Test Zipper insertTreeL",
          "hierarchy": "Data Tree AVL Test AllTests",
          "module": "Data.Tree.AVL.Test.AllTests",
          "name": "testInsertTreeL",
          "normalized": "IO()",
          "package": "AvlTree",
          "partial": "Insert Tree",
          "signature": "IO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL-Test-AllTests.html#v:testInsertTreeL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTest Zipper insertTreeR\n\u003c/p\u003e",
          "module": "Data.Tree.AVL.Test.AllTests",
          "name": "testInsertTreeR",
          "package": "AvlTree",
          "signature": "IO ()",
          "source": "src/Data-Tree-AVL-Test-AllTests.html#testInsertTreeR",
          "type": "function"
        },
        "index": {
          "description": "Test Zipper insertTreeR",
          "hierarchy": "Data Tree AVL Test AllTests",
          "module": "Data.Tree.AVL.Test.AllTests",
          "name": "testInsertTreeR",
          "normalized": "IO()",
          "package": "AvlTree",
          "partial": "Insert Tree",
          "signature": "IO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL-Test-AllTests.html#v:testInsertTreeR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTest the intersection function\n\u003c/p\u003e",
          "module": "Data.Tree.AVL.Test.AllTests",
          "name": "testIntersection",
          "package": "AvlTree",
          "signature": "IO ()",
          "source": "src/Data-Tree-AVL-Test-AllTests.html#testIntersection",
          "type": "function"
        },
        "index": {
          "description": "Test the intersection function",
          "hierarchy": "Data Tree AVL Test AllTests",
          "module": "Data.Tree.AVL.Test.AllTests",
          "name": "testIntersection",
          "normalized": "IO()",
          "package": "AvlTree",
          "partial": "Intersection",
          "signature": "IO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL-Test-AllTests.html#v:testIntersection"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTest the intersectionAsList function\n\u003c/p\u003e",
          "module": "Data.Tree.AVL.Test.AllTests",
          "name": "testIntersectionAsList",
          "package": "AvlTree",
          "signature": "IO ()",
          "source": "src/Data-Tree-AVL-Test-AllTests.html#testIntersectionAsList",
          "type": "function"
        },
        "index": {
          "description": "Test the intersectionAsList function",
          "hierarchy": "Data Tree AVL Test AllTests",
          "module": "Data.Tree.AVL.Test.AllTests",
          "name": "testIntersectionAsList",
          "normalized": "IO()",
          "package": "AvlTree",
          "partial": "Intersection As List",
          "signature": "IO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL-Test-AllTests.html#v:testIntersectionAsList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTest the intersectionMaybe function\n\u003c/p\u003e",
          "module": "Data.Tree.AVL.Test.AllTests",
          "name": "testIntersectionMaybe",
          "package": "AvlTree",
          "signature": "IO ()",
          "source": "src/Data-Tree-AVL-Test-AllTests.html#testIntersectionMaybe",
          "type": "function"
        },
        "index": {
          "description": "Test the intersectionMaybe function",
          "hierarchy": "Data Tree AVL Test AllTests",
          "module": "Data.Tree.AVL.Test.AllTests",
          "name": "testIntersectionMaybe",
          "normalized": "IO()",
          "package": "AvlTree",
          "partial": "Intersection Maybe",
          "signature": "IO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL-Test-AllTests.html#v:testIntersectionMaybe"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTest the intersectionMaybeAsList function\n\u003c/p\u003e",
          "module": "Data.Tree.AVL.Test.AllTests",
          "name": "testIntersectionMaybeAsList",
          "package": "AvlTree",
          "signature": "IO ()",
          "source": "src/Data-Tree-AVL-Test-AllTests.html#testIntersectionMaybeAsList",
          "type": "function"
        },
        "index": {
          "description": "Test the intersectionMaybeAsList function",
          "hierarchy": "Data Tree AVL Test AllTests",
          "module": "Data.Tree.AVL.Test.AllTests",
          "name": "testIntersectionMaybeAsList",
          "normalized": "IO()",
          "package": "AvlTree",
          "partial": "Intersection Maybe As List",
          "signature": "IO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL-Test-AllTests.html#v:testIntersectionMaybeAsList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTest isBalanced is capable of failing for a few non-AVL trees.\n\u003c/p\u003e",
          "module": "Data.Tree.AVL.Test.AllTests",
          "name": "testIsBalanced",
          "package": "AvlTree",
          "signature": "IO ()",
          "source": "src/Data-Tree-AVL-Test-AllTests.html#testIsBalanced",
          "type": "function"
        },
        "index": {
          "description": "Test isBalanced is capable of failing for few non-AVL trees",
          "hierarchy": "Data Tree AVL Test AllTests",
          "module": "Data.Tree.AVL.Test.AllTests",
          "name": "testIsBalanced",
          "normalized": "IO()",
          "package": "AvlTree",
          "partial": "Is Balanced",
          "signature": "IO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL-Test-AllTests.html#v:testIsBalanced"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTest isSorted is capable of failing for a few non-sorted trees.\n\u003c/p\u003e",
          "module": "Data.Tree.AVL.Test.AllTests",
          "name": "testIsSorted",
          "package": "AvlTree",
          "signature": "IO ()",
          "source": "src/Data-Tree-AVL-Test-AllTests.html#testIsSorted",
          "type": "function"
        },
        "index": {
          "description": "Test isSorted is capable of failing for few non-sorted trees",
          "hierarchy": "Data Tree AVL Test AllTests",
          "module": "Data.Tree.AVL.Test.AllTests",
          "name": "testIsSorted",
          "normalized": "IO()",
          "package": "AvlTree",
          "partial": "Is Sorted",
          "signature": "IO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL-Test-AllTests.html#v:testIsSorted"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTest the isSubsetOf function\n\u003c/p\u003e",
          "module": "Data.Tree.AVL.Test.AllTests",
          "name": "testIsSubsetOf",
          "package": "AvlTree",
          "signature": "IO ()",
          "source": "src/Data-Tree-AVL-Test-AllTests.html#testIsSubsetOf",
          "type": "function"
        },
        "index": {
          "description": "Test the isSubsetOf function",
          "hierarchy": "Data Tree AVL Test AllTests",
          "module": "Data.Tree.AVL.Test.AllTests",
          "name": "testIsSubsetOf",
          "normalized": "IO()",
          "package": "AvlTree",
          "partial": "Is Subset Of",
          "signature": "IO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL-Test-AllTests.html#v:testIsSubsetOf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTest the isSubsetOfBy function\n\u003c/p\u003e",
          "module": "Data.Tree.AVL.Test.AllTests",
          "name": "testIsSubsetOfBy",
          "package": "AvlTree",
          "signature": "IO ()",
          "source": "src/Data-Tree-AVL-Test-AllTests.html#testIsSubsetOfBy",
          "type": "function"
        },
        "index": {
          "description": "Test the isSubsetOfBy function",
          "hierarchy": "Data Tree AVL Test AllTests",
          "module": "Data.Tree.AVL.Test.AllTests",
          "name": "testIsSubsetOfBy",
          "normalized": "IO()",
          "package": "AvlTree",
          "partial": "Is Subset Of By",
          "signature": "IO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL-Test-AllTests.html#v:testIsSubsetOfBy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTest the join function\n\u003c/p\u003e",
          "module": "Data.Tree.AVL.Test.AllTests",
          "name": "testJoin",
          "package": "AvlTree",
          "signature": "IO ()",
          "source": "src/Data-Tree-AVL-Test-AllTests.html#testJoin",
          "type": "function"
        },
        "index": {
          "description": "Test the join function",
          "hierarchy": "Data Tree AVL Test AllTests",
          "module": "Data.Tree.AVL.Test.AllTests",
          "name": "testJoin",
          "normalized": "IO()",
          "package": "AvlTree",
          "partial": "Join",
          "signature": "IO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL-Test-AllTests.html#v:testJoin"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTest the joinHAVL function\n\u003c/p\u003e",
          "module": "Data.Tree.AVL.Test.AllTests",
          "name": "testJoinHAVL",
          "package": "AvlTree",
          "signature": "IO ()",
          "source": "src/Data-Tree-AVL-Test-AllTests.html#testJoinHAVL",
          "type": "function"
        },
        "index": {
          "description": "Test the joinHAVL function",
          "hierarchy": "Data Tree AVL Test AllTests",
          "module": "Data.Tree.AVL.Test.AllTests",
          "name": "testJoinHAVL",
          "normalized": "IO()",
          "package": "AvlTree",
          "partial": "Join HAVL",
          "signature": "IO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL-Test-AllTests.html#v:testJoinHAVL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTest mapAccumL\n\u003c/p\u003e",
          "module": "Data.Tree.AVL.Test.AllTests",
          "name": "testMapAccumL",
          "package": "AvlTree",
          "signature": "IO ()",
          "source": "src/Data-Tree-AVL-Test-AllTests.html#testMapAccumL",
          "type": "function"
        },
        "index": {
          "description": "Test mapAccumL",
          "hierarchy": "Data Tree AVL Test AllTests",
          "module": "Data.Tree.AVL.Test.AllTests",
          "name": "testMapAccumL",
          "normalized": "IO()",
          "package": "AvlTree",
          "partial": "Map Accum",
          "signature": "IO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL-Test-AllTests.html#v:testMapAccumL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTest mapAccumL'\n\u003c/p\u003e",
          "module": "Data.Tree.AVL.Test.AllTests",
          "name": "testMapAccumL'",
          "package": "AvlTree",
          "signature": "IO ()",
          "source": "src/Data-Tree-AVL-Test-AllTests.html#testMapAccumL%27",
          "type": "function"
        },
        "index": {
          "description": "Test mapAccumL",
          "hierarchy": "Data Tree AVL Test AllTests",
          "module": "Data.Tree.AVL.Test.AllTests",
          "name": "testMapAccumL'",
          "normalized": "IO()",
          "package": "AvlTree",
          "partial": "Map Accum L'",
          "signature": "IO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL-Test-AllTests.html#v:testMapAccumL-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTest mapAccumL''\n\u003c/p\u003e",
          "module": "Data.Tree.AVL.Test.AllTests",
          "name": "testMapAccumL''",
          "package": "AvlTree",
          "signature": "IO ()",
          "source": "src/Data-Tree-AVL-Test-AllTests.html#testMapAccumL%27%27",
          "type": "function"
        },
        "index": {
          "description": "Test mapAccumL",
          "hierarchy": "Data Tree AVL Test AllTests",
          "module": "Data.Tree.AVL.Test.AllTests",
          "name": "testMapAccumL''",
          "normalized": "IO()",
          "package": "AvlTree",
          "partial": "Map Accum L''",
          "signature": "IO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL-Test-AllTests.html#v:testMapAccumL-39--39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTest mapAccumR\n\u003c/p\u003e",
          "module": "Data.Tree.AVL.Test.AllTests",
          "name": "testMapAccumR",
          "package": "AvlTree",
          "signature": "IO ()",
          "source": "src/Data-Tree-AVL-Test-AllTests.html#testMapAccumR",
          "type": "function"
        },
        "index": {
          "description": "Test mapAccumR",
          "hierarchy": "Data Tree AVL Test AllTests",
          "module": "Data.Tree.AVL.Test.AllTests",
          "name": "testMapAccumR",
          "normalized": "IO()",
          "package": "AvlTree",
          "partial": "Map Accum",
          "signature": "IO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL-Test-AllTests.html#v:testMapAccumR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTest mapAccumR'\n\u003c/p\u003e",
          "module": "Data.Tree.AVL.Test.AllTests",
          "name": "testMapAccumR'",
          "package": "AvlTree",
          "signature": "IO ()",
          "source": "src/Data-Tree-AVL-Test-AllTests.html#testMapAccumR%27",
          "type": "function"
        },
        "index": {
          "description": "Test mapAccumR",
          "hierarchy": "Data Tree AVL Test AllTests",
          "module": "Data.Tree.AVL.Test.AllTests",
          "name": "testMapAccumR'",
          "normalized": "IO()",
          "package": "AvlTree",
          "partial": "Map Accum R'",
          "signature": "IO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL-Test-AllTests.html#v:testMapAccumR-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTest mapAccumR''\n\u003c/p\u003e",
          "module": "Data.Tree.AVL.Test.AllTests",
          "name": "testMapAccumR''",
          "package": "AvlTree",
          "signature": "IO ()",
          "source": "src/Data-Tree-AVL-Test-AllTests.html#testMapAccumR%27%27",
          "type": "function"
        },
        "index": {
          "description": "Test mapAccumR",
          "hierarchy": "Data Tree AVL Test AllTests",
          "module": "Data.Tree.AVL.Test.AllTests",
          "name": "testMapAccumR''",
          "normalized": "IO()",
          "package": "AvlTree",
          "partial": "Map Accum R''",
          "signature": "IO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL-Test-AllTests.html#v:testMapAccumR-39--39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTest the mapMaybe function\n\u003c/p\u003e",
          "module": "Data.Tree.AVL.Test.AllTests",
          "name": "testMapMaybe",
          "package": "AvlTree",
          "signature": "IO ()",
          "source": "src/Data-Tree-AVL-Test-AllTests.html#testMapMaybe",
          "type": "function"
        },
        "index": {
          "description": "Test the mapMaybe function",
          "hierarchy": "Data Tree AVL Test AllTests",
          "module": "Data.Tree.AVL.Test.AllTests",
          "name": "testMapMaybe",
          "normalized": "IO()",
          "package": "AvlTree",
          "partial": "Map Maybe",
          "signature": "IO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL-Test-AllTests.html#v:testMapMaybe"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTest the mapMaybeViaList function\n\u003c/p\u003e",
          "module": "Data.Tree.AVL.Test.AllTests",
          "name": "testMapMaybeViaList",
          "package": "AvlTree",
          "signature": "IO ()",
          "source": "src/Data-Tree-AVL-Test-AllTests.html#testMapMaybeViaList",
          "type": "function"
        },
        "index": {
          "description": "Test the mapMaybeViaList function",
          "hierarchy": "Data Tree AVL Test AllTests",
          "module": "Data.Tree.AVL.Test.AllTests",
          "name": "testMapMaybeViaList",
          "normalized": "IO()",
          "package": "AvlTree",
          "partial": "Map Maybe Via List",
          "signature": "IO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL-Test-AllTests.html#v:testMapMaybeViaList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTest Zipper assertMoveL/isRightmost\n\u003c/p\u003e",
          "module": "Data.Tree.AVL.Test.AllTests",
          "name": "testMoveL",
          "package": "AvlTree",
          "signature": "IO ()",
          "source": "src/Data-Tree-AVL-Test-AllTests.html#testMoveL",
          "type": "function"
        },
        "index": {
          "description": "Test Zipper assertMoveL isRightmost",
          "hierarchy": "Data Tree AVL Test AllTests",
          "module": "Data.Tree.AVL.Test.AllTests",
          "name": "testMoveL",
          "normalized": "IO()",
          "package": "AvlTree",
          "partial": "Move",
          "signature": "IO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL-Test-AllTests.html#v:testMoveL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTest Zipper assertMoveR/isLeftmost\n\u003c/p\u003e",
          "module": "Data.Tree.AVL.Test.AllTests",
          "name": "testMoveR",
          "package": "AvlTree",
          "signature": "IO ()",
          "source": "src/Data-Tree-AVL-Test-AllTests.html#testMoveR",
          "type": "function"
        },
        "index": {
          "description": "Test Zipper assertMoveR isLeftmost",
          "hierarchy": "Data Tree AVL Test AllTests",
          "module": "Data.Tree.AVL.Test.AllTests",
          "name": "testMoveR",
          "normalized": "IO()",
          "package": "AvlTree",
          "partial": "Move",
          "signature": "IO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL-Test-AllTests.html#v:testMoveR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTest Zipper open/close\n\u003c/p\u003e",
          "module": "Data.Tree.AVL.Test.AllTests",
          "name": "testOpenClose",
          "package": "AvlTree",
          "signature": "IO ()",
          "source": "src/Data-Tree-AVL-Test-AllTests.html#testOpenClose",
          "type": "function"
        },
        "index": {
          "description": "Test Zipper open close",
          "hierarchy": "Data Tree AVL Test AllTests",
          "module": "Data.Tree.AVL.Test.AllTests",
          "name": "testOpenClose",
          "normalized": "IO()",
          "package": "AvlTree",
          "partial": "Open Close",
          "signature": "IO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL-Test-AllTests.html#v:testOpenClose"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTest Zipper openEither (also tests fill and fillClose)\n\u003c/p\u003e",
          "module": "Data.Tree.AVL.Test.AllTests",
          "name": "testOpenEither",
          "package": "AvlTree",
          "signature": "IO ()",
          "source": "src/Data-Tree-AVL-Test-AllTests.html#testOpenEither",
          "type": "function"
        },
        "index": {
          "description": "Test Zipper openEither also tests fill and fillClose",
          "hierarchy": "Data Tree AVL Test AllTests",
          "module": "Data.Tree.AVL.Test.AllTests",
          "name": "testOpenEither",
          "normalized": "IO()",
          "package": "AvlTree",
          "partial": "Open Either",
          "signature": "IO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL-Test-AllTests.html#v:testOpenEither"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTest Zipper assertOpenL/close\n\u003c/p\u003e",
          "module": "Data.Tree.AVL.Test.AllTests",
          "name": "testOpenLClose",
          "package": "AvlTree",
          "signature": "IO ()",
          "source": "src/Data-Tree-AVL-Test-AllTests.html#testOpenLClose",
          "type": "function"
        },
        "index": {
          "description": "Test Zipper assertOpenL close",
          "hierarchy": "Data Tree AVL Test AllTests",
          "module": "Data.Tree.AVL.Test.AllTests",
          "name": "testOpenLClose",
          "normalized": "IO()",
          "package": "AvlTree",
          "partial": "Open LClose",
          "signature": "IO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL-Test-AllTests.html#v:testOpenLClose"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTest Zipper assertOpenR/close\n\u003c/p\u003e",
          "module": "Data.Tree.AVL.Test.AllTests",
          "name": "testOpenRClose",
          "package": "AvlTree",
          "signature": "IO ()",
          "source": "src/Data-Tree-AVL-Test-AllTests.html#testOpenRClose",
          "type": "function"
        },
        "index": {
          "description": "Test Zipper assertOpenR close",
          "hierarchy": "Data Tree AVL Test AllTests",
          "module": "Data.Tree.AVL.Test.AllTests",
          "name": "testOpenRClose",
          "normalized": "IO()",
          "package": "AvlTree",
          "partial": "Open RClose",
          "signature": "IO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL-Test-AllTests.html#v:testOpenRClose"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTest popHL function\n This test can only be run if popHL and HAVL are not hidden.\n However, popHL is exercised by indirectly by testConcatAVL anyway\n\u003c/p\u003e",
          "module": "Data.Tree.AVL.Test.AllTests",
          "name": "testPopHL",
          "package": "AvlTree",
          "signature": "IO ()",
          "source": "src/Data-Tree-AVL-Test-AllTests.html#testPopHL",
          "type": "function"
        },
        "index": {
          "description": "Test popHL function This test can only be run if popHL and HAVL are not hidden However popHL is exercised by indirectly by testConcatAVL anyway",
          "hierarchy": "Data Tree AVL Test AllTests",
          "module": "Data.Tree.AVL.Test.AllTests",
          "name": "testPopHL",
          "normalized": "IO()",
          "package": "AvlTree",
          "partial": "Pop HL",
          "signature": "IO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL-Test-AllTests.html#v:testPopHL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTest push function\n\u003c/p\u003e",
          "module": "Data.Tree.AVL.Test.AllTests",
          "name": "testPush",
          "package": "AvlTree",
          "signature": "IO ()",
          "source": "src/Data-Tree-AVL-Test-AllTests.html#testPush",
          "type": "function"
        },
        "index": {
          "description": "Test push function",
          "hierarchy": "Data Tree AVL Test AllTests",
          "module": "Data.Tree.AVL.Test.AllTests",
          "name": "testPush",
          "normalized": "IO()",
          "package": "AvlTree",
          "partial": "Push",
          "signature": "IO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL-Test-AllTests.html#v:testPush"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTest pushL function\n Also exercises: asListL\n\u003c/p\u003e",
          "module": "Data.Tree.AVL.Test.AllTests",
          "name": "testPushL",
          "package": "AvlTree",
          "signature": "IO ()",
          "source": "src/Data-Tree-AVL-Test-AllTests.html#testPushL",
          "type": "function"
        },
        "index": {
          "description": "Test pushL function Also exercises asListL",
          "hierarchy": "Data Tree AVL Test AllTests",
          "module": "Data.Tree.AVL.Test.AllTests",
          "name": "testPushL",
          "normalized": "IO()",
          "package": "AvlTree",
          "partial": "Push",
          "signature": "IO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL-Test-AllTests.html#v:testPushL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTest pushR function\n Also exercises: asListR\n\u003c/p\u003e",
          "module": "Data.Tree.AVL.Test.AllTests",
          "name": "testPushR",
          "package": "AvlTree",
          "signature": "IO ()",
          "source": "src/Data-Tree-AVL-Test-AllTests.html#testPushR",
          "type": "function"
        },
        "index": {
          "description": "Test pushR function Also exercises asListR",
          "hierarchy": "Data Tree AVL Test AllTests",
          "module": "Data.Tree.AVL.Test.AllTests",
          "name": "testPushR",
          "normalized": "IO()",
          "package": "AvlTree",
          "partial": "Push",
          "signature": "IO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL-Test-AllTests.html#v:testPushR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTest readPath\n\u003c/p\u003e",
          "module": "Data.Tree.AVL.Test.AllTests",
          "name": "testReadPath",
          "package": "AvlTree",
          "signature": "IO ()",
          "source": "src/Data-Tree-AVL-Test-AllTests.html#testReadPath",
          "type": "function"
        },
        "index": {
          "description": "Test readPath",
          "hierarchy": "Data Tree AVL Test AllTests",
          "module": "Data.Tree.AVL.Test.AllTests",
          "name": "testReadPath",
          "normalized": "IO()",
          "package": "AvlTree",
          "partial": "Read Path",
          "signature": "IO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL-Test-AllTests.html#v:testReadPath"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTest rotateByL function\n\u003c/p\u003e",
          "module": "Data.Tree.AVL.Test.AllTests",
          "name": "testRotateByL",
          "package": "AvlTree",
          "signature": "IO ()",
          "source": "src/Data-Tree-AVL-Test-AllTests.html#testRotateByL",
          "type": "function"
        },
        "index": {
          "description": "Test rotateByL function",
          "hierarchy": "Data Tree AVL Test AllTests",
          "module": "Data.Tree.AVL.Test.AllTests",
          "name": "testRotateByL",
          "normalized": "IO()",
          "package": "AvlTree",
          "partial": "Rotate By",
          "signature": "IO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL-Test-AllTests.html#v:testRotateByL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTest rotateByR function\n\u003c/p\u003e",
          "module": "Data.Tree.AVL.Test.AllTests",
          "name": "testRotateByR",
          "package": "AvlTree",
          "signature": "IO ()",
          "source": "src/Data-Tree-AVL-Test-AllTests.html#testRotateByR",
          "type": "function"
        },
        "index": {
          "description": "Test rotateByR function",
          "hierarchy": "Data Tree AVL Test AllTests",
          "module": "Data.Tree.AVL.Test.AllTests",
          "name": "testRotateByR",
          "normalized": "IO()",
          "package": "AvlTree",
          "partial": "Rotate By",
          "signature": "IO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL-Test-AllTests.html#v:testRotateByR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTest rotateL function\n\u003c/p\u003e",
          "module": "Data.Tree.AVL.Test.AllTests",
          "name": "testRotateL",
          "package": "AvlTree",
          "signature": "IO ()",
          "source": "src/Data-Tree-AVL-Test-AllTests.html#testRotateL",
          "type": "function"
        },
        "index": {
          "description": "Test rotateL function",
          "hierarchy": "Data Tree AVL Test AllTests",
          "module": "Data.Tree.AVL.Test.AllTests",
          "name": "testRotateL",
          "normalized": "IO()",
          "package": "AvlTree",
          "partial": "Rotate",
          "signature": "IO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL-Test-AllTests.html#v:testRotateL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTest rotateR function\n\u003c/p\u003e",
          "module": "Data.Tree.AVL.Test.AllTests",
          "name": "testRotateR",
          "package": "AvlTree",
          "signature": "IO ()",
          "source": "src/Data-Tree-AVL-Test-AllTests.html#testRotateR",
          "type": "function"
        },
        "index": {
          "description": "Test rotateR function",
          "hierarchy": "Data Tree AVL Test AllTests",
          "module": "Data.Tree.AVL.Test.AllTests",
          "name": "testRotateR",
          "normalized": "IO()",
          "package": "AvlTree",
          "partial": "Rotate",
          "signature": "IO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL-Test-AllTests.html#v:testRotateR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTest Show,Read,Eq instances\n\u003c/p\u003e",
          "module": "Data.Tree.AVL.Test.AllTests",
          "name": "testShowReadEq",
          "package": "AvlTree",
          "signature": "IO ()",
          "source": "src/Data-Tree-AVL-Test-AllTests.html#testShowReadEq",
          "type": "function"
        },
        "index": {
          "description": "Test Show Read Eq instances",
          "hierarchy": "Data Tree AVL Test AllTests",
          "module": "Data.Tree.AVL.Test.AllTests",
          "name": "testShowReadEq",
          "normalized": "IO()",
          "package": "AvlTree",
          "partial": "Show Read Eq",
          "signature": "IO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL-Test-AllTests.html#v:testShowReadEq"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTest size function\n\u003c/p\u003e",
          "module": "Data.Tree.AVL.Test.AllTests",
          "name": "testSize",
          "package": "AvlTree",
          "signature": "IO ()",
          "source": "src/Data-Tree-AVL-Test-AllTests.html#testSize",
          "type": "function"
        },
        "index": {
          "description": "Test size function",
          "hierarchy": "Data Tree AVL Test AllTests",
          "module": "Data.Tree.AVL.Test.AllTests",
          "name": "testSize",
          "normalized": "IO()",
          "package": "AvlTree",
          "partial": "Size",
          "signature": "IO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL-Test-AllTests.html#v:testSize"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTest spanL function\n\u003c/p\u003e",
          "module": "Data.Tree.AVL.Test.AllTests",
          "name": "testSpanL",
          "package": "AvlTree",
          "signature": "IO ()",
          "source": "src/Data-Tree-AVL-Test-AllTests.html#testSpanL",
          "type": "function"
        },
        "index": {
          "description": "Test spanL function",
          "hierarchy": "Data Tree AVL Test AllTests",
          "module": "Data.Tree.AVL.Test.AllTests",
          "name": "testSpanL",
          "normalized": "IO()",
          "package": "AvlTree",
          "partial": "Span",
          "signature": "IO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL-Test-AllTests.html#v:testSpanL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTest spanR function\n\u003c/p\u003e",
          "module": "Data.Tree.AVL.Test.AllTests",
          "name": "testSpanR",
          "package": "AvlTree",
          "signature": "IO ()",
          "source": "src/Data-Tree-AVL-Test-AllTests.html#testSpanR",
          "type": "function"
        },
        "index": {
          "description": "Test spanR function",
          "hierarchy": "Data Tree AVL Test AllTests",
          "module": "Data.Tree.AVL.Test.AllTests",
          "name": "testSpanR",
          "normalized": "IO()",
          "package": "AvlTree",
          "partial": "Span",
          "signature": "IO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL-Test-AllTests.html#v:testSpanR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTest splitAtL function\n\u003c/p\u003e",
          "module": "Data.Tree.AVL.Test.AllTests",
          "name": "testSplitAtL",
          "package": "AvlTree",
          "signature": "IO ()",
          "source": "src/Data-Tree-AVL-Test-AllTests.html#testSplitAtL",
          "type": "function"
        },
        "index": {
          "description": "Test splitAtL function",
          "hierarchy": "Data Tree AVL Test AllTests",
          "module": "Data.Tree.AVL.Test.AllTests",
          "name": "testSplitAtL",
          "normalized": "IO()",
          "package": "AvlTree",
          "partial": "Split At",
          "signature": "IO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL-Test-AllTests.html#v:testSplitAtL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTest splitAtR function\n\u003c/p\u003e",
          "module": "Data.Tree.AVL.Test.AllTests",
          "name": "testSplitAtR",
          "package": "AvlTree",
          "signature": "IO ()",
          "source": "src/Data-Tree-AVL-Test-AllTests.html#testSplitAtR",
          "type": "function"
        },
        "index": {
          "description": "Test splitAtR function",
          "hierarchy": "Data Tree AVL Test AllTests",
          "module": "Data.Tree.AVL.Test.AllTests",
          "name": "testSplitAtR",
          "normalized": "IO()",
          "package": "AvlTree",
          "partial": "Split At",
          "signature": "IO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL-Test-AllTests.html#v:testSplitAtR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTest the symDifference function\n\u003c/p\u003e",
          "module": "Data.Tree.AVL.Test.AllTests",
          "name": "testSymDifference",
          "package": "AvlTree",
          "signature": "IO ()",
          "source": "src/Data-Tree-AVL-Test-AllTests.html#testSymDifference",
          "type": "function"
        },
        "index": {
          "description": "Test the symDifference function",
          "hierarchy": "Data Tree AVL Test AllTests",
          "module": "Data.Tree.AVL.Test.AllTests",
          "name": "testSymDifference",
          "normalized": "IO()",
          "package": "AvlTree",
          "partial": "Sym Difference",
          "signature": "IO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL-Test-AllTests.html#v:testSymDifference"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTest takeGE function\n\u003c/p\u003e",
          "module": "Data.Tree.AVL.Test.AllTests",
          "name": "testTakeGE",
          "package": "AvlTree",
          "signature": "IO ()",
          "source": "src/Data-Tree-AVL-Test-AllTests.html#testTakeGE",
          "type": "function"
        },
        "index": {
          "description": "Test takeGE function",
          "hierarchy": "Data Tree AVL Test AllTests",
          "module": "Data.Tree.AVL.Test.AllTests",
          "name": "testTakeGE",
          "normalized": "IO()",
          "package": "AvlTree",
          "partial": "Take GE",
          "signature": "IO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL-Test-AllTests.html#v:testTakeGE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTest takeGT function\n\u003c/p\u003e",
          "module": "Data.Tree.AVL.Test.AllTests",
          "name": "testTakeGT",
          "package": "AvlTree",
          "signature": "IO ()",
          "source": "src/Data-Tree-AVL-Test-AllTests.html#testTakeGT",
          "type": "function"
        },
        "index": {
          "description": "Test takeGT function",
          "hierarchy": "Data Tree AVL Test AllTests",
          "module": "Data.Tree.AVL.Test.AllTests",
          "name": "testTakeGT",
          "normalized": "IO()",
          "package": "AvlTree",
          "partial": "Take GT",
          "signature": "IO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL-Test-AllTests.html#v:testTakeGT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTest takeL function\n\u003c/p\u003e",
          "module": "Data.Tree.AVL.Test.AllTests",
          "name": "testTakeL",
          "package": "AvlTree",
          "signature": "IO ()",
          "source": "src/Data-Tree-AVL-Test-AllTests.html#testTakeL",
          "type": "function"
        },
        "index": {
          "description": "Test takeL function",
          "hierarchy": "Data Tree AVL Test AllTests",
          "module": "Data.Tree.AVL.Test.AllTests",
          "name": "testTakeL",
          "normalized": "IO()",
          "package": "AvlTree",
          "partial": "Take",
          "signature": "IO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL-Test-AllTests.html#v:testTakeL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTest takeLE function\n\u003c/p\u003e",
          "module": "Data.Tree.AVL.Test.AllTests",
          "name": "testTakeLE",
          "package": "AvlTree",
          "signature": "IO ()",
          "source": "src/Data-Tree-AVL-Test-AllTests.html#testTakeLE",
          "type": "function"
        },
        "index": {
          "description": "Test takeLE function",
          "hierarchy": "Data Tree AVL Test AllTests",
          "module": "Data.Tree.AVL.Test.AllTests",
          "name": "testTakeLE",
          "normalized": "IO()",
          "package": "AvlTree",
          "partial": "Take LE",
          "signature": "IO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL-Test-AllTests.html#v:testTakeLE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTest takeLT function\n\u003c/p\u003e",
          "module": "Data.Tree.AVL.Test.AllTests",
          "name": "testTakeLT",
          "package": "AvlTree",
          "signature": "IO ()",
          "source": "src/Data-Tree-AVL-Test-AllTests.html#testTakeLT",
          "type": "function"
        },
        "index": {
          "description": "Test takeLT function",
          "hierarchy": "Data Tree AVL Test AllTests",
          "module": "Data.Tree.AVL.Test.AllTests",
          "name": "testTakeLT",
          "normalized": "IO()",
          "package": "AvlTree",
          "partial": "Take LT",
          "signature": "IO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL-Test-AllTests.html#v:testTakeLT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTest takeR function\n\u003c/p\u003e",
          "module": "Data.Tree.AVL.Test.AllTests",
          "name": "testTakeR",
          "package": "AvlTree",
          "signature": "IO ()",
          "source": "src/Data-Tree-AVL-Test-AllTests.html#testTakeR",
          "type": "function"
        },
        "index": {
          "description": "Test takeR function",
          "hierarchy": "Data Tree AVL Test AllTests",
          "module": "Data.Tree.AVL.Test.AllTests",
          "name": "testTakeR",
          "normalized": "IO()",
          "package": "AvlTree",
          "partial": "Take",
          "signature": "IO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL-Test-AllTests.html#v:testTakeR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTest takeWhileL function\n\u003c/p\u003e",
          "module": "Data.Tree.AVL.Test.AllTests",
          "name": "testTakeWhileL",
          "package": "AvlTree",
          "signature": "IO ()",
          "source": "src/Data-Tree-AVL-Test-AllTests.html#testTakeWhileL",
          "type": "function"
        },
        "index": {
          "description": "Test takeWhileL function",
          "hierarchy": "Data Tree AVL Test AllTests",
          "module": "Data.Tree.AVL.Test.AllTests",
          "name": "testTakeWhileL",
          "normalized": "IO()",
          "package": "AvlTree",
          "partial": "Take While",
          "signature": "IO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL-Test-AllTests.html#v:testTakeWhileL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTest takeWhileR function\n\u003c/p\u003e",
          "module": "Data.Tree.AVL.Test.AllTests",
          "name": "testTakeWhileR",
          "package": "AvlTree",
          "signature": "IO ()",
          "source": "src/Data-Tree-AVL-Test-AllTests.html#testTakeWhileR",
          "type": "function"
        },
        "index": {
          "description": "Test takeWhileR function",
          "hierarchy": "Data Tree AVL Test AllTests",
          "module": "Data.Tree.AVL.Test.AllTests",
          "name": "testTakeWhileR",
          "normalized": "IO()",
          "package": "AvlTree",
          "partial": "Take While",
          "signature": "IO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL-Test-AllTests.html#v:testTakeWhileR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTest Zipper tryOpenGE\n\u003c/p\u003e",
          "module": "Data.Tree.AVL.Test.AllTests",
          "name": "testTryOpenGE",
          "package": "AvlTree",
          "signature": "IO ()",
          "source": "src/Data-Tree-AVL-Test-AllTests.html#testTryOpenGE",
          "type": "function"
        },
        "index": {
          "description": "Test Zipper tryOpenGE",
          "hierarchy": "Data Tree AVL Test AllTests",
          "module": "Data.Tree.AVL.Test.AllTests",
          "name": "testTryOpenGE",
          "normalized": "IO()",
          "package": "AvlTree",
          "partial": "Try Open GE",
          "signature": "IO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL-Test-AllTests.html#v:testTryOpenGE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTest Zipper tryOpenLE\n\u003c/p\u003e",
          "module": "Data.Tree.AVL.Test.AllTests",
          "name": "testTryOpenLE",
          "package": "AvlTree",
          "signature": "IO ()",
          "source": "src/Data-Tree-AVL-Test-AllTests.html#testTryOpenLE",
          "type": "function"
        },
        "index": {
          "description": "Test Zipper tryOpenLE",
          "hierarchy": "Data Tree AVL Test AllTests",
          "module": "Data.Tree.AVL.Test.AllTests",
          "name": "testTryOpenLE",
          "normalized": "IO()",
          "package": "AvlTree",
          "partial": "Try Open LE",
          "signature": "IO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL-Test-AllTests.html#v:testTryOpenLE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTest the union function\n\u003c/p\u003e",
          "module": "Data.Tree.AVL.Test.AllTests",
          "name": "testUnion",
          "package": "AvlTree",
          "signature": "IO ()",
          "source": "src/Data-Tree-AVL-Test-AllTests.html#testUnion",
          "type": "function"
        },
        "index": {
          "description": "Test the union function",
          "hierarchy": "Data Tree AVL Test AllTests",
          "module": "Data.Tree.AVL.Test.AllTests",
          "name": "testUnion",
          "normalized": "IO()",
          "package": "AvlTree",
          "partial": "Union",
          "signature": "IO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL-Test-AllTests.html#v:testUnion"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTest the unionMaybe function\n\u003c/p\u003e",
          "module": "Data.Tree.AVL.Test.AllTests",
          "name": "testUnionMaybe",
          "package": "AvlTree",
          "signature": "IO ()",
          "source": "src/Data-Tree-AVL-Test-AllTests.html#testUnionMaybe",
          "type": "function"
        },
        "index": {
          "description": "Test the unionMaybe function",
          "hierarchy": "Data Tree AVL Test AllTests",
          "module": "Data.Tree.AVL.Test.AllTests",
          "name": "testUnionMaybe",
          "normalized": "IO()",
          "package": "AvlTree",
          "partial": "Union Maybe",
          "signature": "IO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL-Test-AllTests.html#v:testUnionMaybe"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTest the venn function. Also exercises disjointUnion\n\u003c/p\u003e",
          "module": "Data.Tree.AVL.Test.AllTests",
          "name": "testVenn",
          "package": "AvlTree",
          "signature": "IO ()",
          "source": "src/Data-Tree-AVL-Test-AllTests.html#testVenn",
          "type": "function"
        },
        "index": {
          "description": "Test the venn function Also exercises disjointUnion",
          "hierarchy": "Data Tree AVL Test AllTests",
          "module": "Data.Tree.AVL.Test.AllTests",
          "name": "testVenn",
          "normalized": "IO()",
          "package": "AvlTree",
          "partial": "Venn",
          "signature": "IO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL-Test-AllTests.html#v:testVenn"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTest the vennMaybe function.\n\u003c/p\u003e",
          "module": "Data.Tree.AVL.Test.AllTests",
          "name": "testVennMaybe",
          "package": "AvlTree",
          "signature": "IO ()",
          "source": "src/Data-Tree-AVL-Test-AllTests.html#testVennMaybe",
          "type": "function"
        },
        "index": {
          "description": "Test the vennMaybe function",
          "hierarchy": "Data Tree AVL Test AllTests",
          "module": "Data.Tree.AVL.Test.AllTests",
          "name": "testVennMaybe",
          "normalized": "IO()",
          "package": "AvlTree",
          "partial": "Venn Maybe",
          "signature": "IO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL-Test-AllTests.html#v:testVennMaybe"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTest write function\n\u003c/p\u003e",
          "module": "Data.Tree.AVL.Test.AllTests",
          "name": "testWrite",
          "package": "AvlTree",
          "signature": "IO ()",
          "source": "src/Data-Tree-AVL-Test-AllTests.html#testWrite",
          "type": "function"
        },
        "index": {
          "description": "Test write function",
          "hierarchy": "Data Tree AVL Test AllTests",
          "module": "Data.Tree.AVL.Test.AllTests",
          "name": "testWrite",
          "normalized": "IO()",
          "package": "AvlTree",
          "partial": "Write",
          "signature": "IO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL-Test-AllTests.html#v:testWrite"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTest Zipper sizeL/sizeR/sizeZAVL\n\u003c/p\u003e",
          "module": "Data.Tree.AVL.Test.AllTests",
          "name": "testZipSize",
          "package": "AvlTree",
          "signature": "IO ()",
          "source": "src/Data-Tree-AVL-Test-AllTests.html#testZipSize",
          "type": "function"
        },
        "index": {
          "description": "Test Zipper sizeL sizeR sizeZAVL",
          "hierarchy": "Data Tree AVL Test AllTests",
          "module": "Data.Tree.AVL.Test.AllTests",
          "name": "testZipSize",
          "normalized": "IO()",
          "package": "AvlTree",
          "partial": "Zip Size",
          "signature": "IO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL-Test-AllTests.html#v:testZipSize"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module defines the \u003ccode\u003e\u003ca\u003eXInt\u003c/a\u003e\u003c/code\u003e type which is a specialised instance of \u003ccode\u003e\u003ca\u003eOrd\u003c/a\u003e\u003c/code\u003e which allows\n the number of comparisons performed to be counted. This may be used evaluate various\n algorithms. The functions defined here are not exported by the main \u003ca\u003eData.Tree.AVL\u003c/a\u003e\n module. You need to import this module explicitly if you want to use any of them.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.Tree.AVL.Test.Counter",
          "name": "Counter",
          "package": "AvlTree",
          "source": "src/Data-Tree-AVL-Test-Counter.html",
          "type": "module"
        },
        "index": {
          "description": "This module defines the XInt type which is specialised instance of Ord which allows the number of comparisons performed to be counted This may be used evaluate various algorithms The functions defined here are not exported by the main Data.Tree.AVL module You need to import this module explicitly if you want to use any of them",
          "hierarchy": "Data Tree AVL Test Counter",
          "module": "Data.Tree.AVL.Test.Counter",
          "name": "Counter",
          "package": "AvlTree",
          "partial": "Counter",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL-Test-Counter.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eBasic data type.\n\u003c/p\u003e",
          "module": "Data.Tree.AVL.Test.Counter",
          "name": "XInt",
          "package": "AvlTree",
          "source": "src/Data-Tree-AVL-Test-Counter.html#XInt",
          "type": "newtype"
        },
        "index": {
          "description": "Basic data type",
          "hierarchy": "Data Tree AVL Test Counter",
          "module": "Data.Tree.AVL.Test.Counter",
          "name": "XInt",
          "package": "AvlTree",
          "partial": "XInt",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL-Test-Counter.html#t:XInt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Tree.AVL.Test.Counter",
          "name": "XInt",
          "package": "AvlTree",
          "signature": "XInt Int",
          "source": "src/Data-Tree-AVL-Test-Counter.html#XInt",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Tree AVL Test Counter",
          "module": "Data.Tree.AVL.Test.Counter",
          "name": "XInt",
          "package": "AvlTree",
          "partial": "XInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL-Test-Counter.html#v:XInt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRead the current comparison counter.\n\u003c/p\u003e",
          "module": "Data.Tree.AVL.Test.Counter",
          "name": "getCount",
          "package": "AvlTree",
          "signature": "IO Int",
          "source": "src/Data-Tree-AVL-Test-Counter.html#getCount",
          "type": "function"
        },
        "index": {
          "description": "Read the current comparison counter",
          "hierarchy": "Data Tree AVL Test Counter",
          "module": "Data.Tree.AVL.Test.Counter",
          "name": "getCount",
          "package": "AvlTree",
          "partial": "Count",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL-Test-Counter.html#v:getCount"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReset the comparison counter to zero.\n\u003c/p\u003e",
          "module": "Data.Tree.AVL.Test.Counter",
          "name": "resetCount",
          "package": "AvlTree",
          "signature": "IO ()",
          "source": "src/Data-Tree-AVL-Test-Counter.html#resetCount",
          "type": "function"
        },
        "index": {
          "description": "Reset the comparison counter to zero",
          "hierarchy": "Data Tree AVL Test Counter",
          "module": "Data.Tree.AVL.Test.Counter",
          "name": "resetCount",
          "normalized": "IO()",
          "package": "AvlTree",
          "partial": "Count",
          "signature": "IO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL-Test-Counter.html#v:resetCount"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eMany of the functions defined by this package make use of generalised comparison functions\n which return a variant of the Prelude \u003ccode\u003e\u003ca\u003eOrdering\u003c/a\u003e\u003c/code\u003e data type: \u003ccode\u003eData.COrdering.COrdering\u003c/code\u003e. These\n are refered to as \"combining comparisons\". (This is because they combine \"equal\"\n values in some manner defined by the user.)\n\u003c/p\u003e\u003cp\u003eThe idea is that using this simple mechanism you can define many practical and\n useful variations of tree (or general set) operations from a few generic primitives,\n something that would not be so easy using plain \u003ccode\u003e\u003ca\u003eOrdering\u003c/a\u003e\u003c/code\u003e comparisons\n (overloaded or otherwise).\n\u003c/p\u003e\u003cp\u003eFunctions which involve searching a tree really only require a single argument\n function which takes the current tree element value as argument and returns\n an \u003ccode\u003e\u003ca\u003eOrdering\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003eData.COrdering.COrdering\u003c/code\u003e to direct the next stage of the search down\n the left or right sub-trees (or stop at the current element). For documentation\n purposes, these functions are called \"selectors\" throughout this library.\n Typically a selector will be obtained by partially applying the appropriate\n combining comparison with the value or key being searched for. For example..\n\u003c/p\u003e\u003cpre\u003e\n mySelector :: Int -\u003e Ordering               Tree elements are Ints\n or..\n mySelector :: (key,val) -\u003e COrdering val    Tree elements are (key,val) pairs\n\u003c/pre\u003e\u003c/div\u003e",
          "module": "Data.Tree.AVL",
          "name": "AVL",
          "package": "AvlTree",
          "source": "src/Data-Tree-AVL.html",
          "type": "module"
        },
        "index": {
          "description": "Many of the functions defined by this package make use of generalised comparison functions which return variant of the Prelude Ordering data type Data.COrdering.COrdering These are refered to as combining comparisons This is because they combine equal values in some manner defined by the user The idea is that using this simple mechanism you can define many practical and useful variations of tree or general set operations from few generic primitives something that would not be so easy using plain Ordering comparisons overloaded or otherwise Functions which involve searching tree really only require single argument function which takes the current tree element value as argument and returns an Ordering or Data.COrdering.COrdering to direct the next stage of the search down the left or right sub-trees or stop at the current element For documentation purposes these functions are called selectors throughout this library Typically selector will be obtained by partially applying the appropriate combining comparison with the value or key being searched for For example mySelector Int Ordering Tree elements are Ints or mySelector key val COrdering val Tree elements are key val pairs",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "AVL",
          "package": "AvlTree",
          "partial": "AVL",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAVL tree data type.\n\u003c/p\u003e\u003cp\u003eThe balance factor (BF) of an \u003ccode\u003e\u003ca\u003eAVL\u003c/a\u003e\u003c/code\u003e tree node is defined as the difference between the height of\n the left and right sub-trees. An \u003ccode\u003e\u003ca\u003eAVL\u003c/a\u003e\u003c/code\u003e tree is ALWAYS height balanced, such that |BF| \u003c= 1.\n The functions in this library (\u003ca\u003eData.Tree.AVL\u003c/a\u003e) are designed so that they never construct\n an unbalanced tree (well that's assuming they're not broken). The \u003ccode\u003e\u003ca\u003eAVL\u003c/a\u003e\u003c/code\u003e tree type defined here\n has the BF encoded the constructors.\n\u003c/p\u003e\u003cp\u003eSome functions in this library return \u003ccode\u003e\u003ca\u003eAVL\u003c/a\u003e\u003c/code\u003e trees that are also \"flat\", which (in the context\n of this library) means that the sizes of left and right sub-trees differ by at most one and\n are also flat. Flat sorted trees should give slightly shorter searches than sorted trees which\n are merely height balanced. Whether or not flattening is worth the effort depends on the number\n of times the tree will be searched and the cost of element comparison.\n\u003c/p\u003e\u003cp\u003eIn cases where the tree elements are sorted, all the relevant \u003ccode\u003e\u003ca\u003eAVL\u003c/a\u003e\u003c/code\u003e functions follow the\n convention that the leftmost tree element is least and the rightmost tree element is\n the greatest. Bear this in mind when defining general comparison functions. It should\n also be noted that all functions in this library for sorted trees require that the tree\n does not contain multiple elements which are \"equal\" (according to whatever criterion\n has been used to sort the elements).\n\u003c/p\u003e\u003cp\u003eIt is important to be consistent about argument ordering when defining general purpose\n comparison functions (or selectors) for searching a sorted tree, such as ..\n\u003c/p\u003e\u003cpre\u003e\n myComp  :: (k -\u003e e -\u003e Ordering)\n -- or..\n myCComp :: (k -\u003e e -\u003e COrdering a)\n\u003c/pre\u003e\u003cp\u003eIn these cases the first argument is the search key and the second argument is an element of\n the \u003ccode\u003e\u003ca\u003eAVL\u003c/a\u003e\u003c/code\u003e tree. For example..\n\u003c/p\u003e\u003cpre\u003e\n key `myCComp` element -\u003e Lt  implies key \u003c element, proceed down the left sub-tree\n key `myCComp` element -\u003e Gt  implies key \u003e element, proceed down the right sub-tree\n\u003c/pre\u003e\u003cp\u003eThis convention is same as that used by the overloaded \u003ccode\u003e\u003ca\u003ecompare\u003c/a\u003e\u003c/code\u003e method from \u003ccode\u003e\u003ca\u003eOrd\u003c/a\u003e\u003c/code\u003e class.\n\u003c/p\u003e\u003cp\u003eControlling Strictness.\n\u003c/p\u003e\u003cp\u003eThe \u003ccode\u003e\u003ca\u003eAVL\u003c/a\u003e\u003c/code\u003e tree data type is declared as non-strict in all it's fields,\n but all the functions in this library behave as though it is strict in its\n recursive fields (left and right sub-trees). Strictness in the element field is\n controlled either by using the strict variants of functions (defined in this library\n where appropriate), or using strict variants of the combinators defined in \u003ca\u003eData.COrdering\u003c/a\u003e,\n or using \u003ccode\u003e\u003ca\u003eseq\u003c/a\u003e\u003c/code\u003e etc. in your own code (in any combining comparisons you define, for example).\n\u003c/p\u003e\u003cp\u003eThe \u003ccode\u003e\u003ca\u003eEq\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003eOrd\u003c/a\u003e\u003c/code\u003e instances.\n\u003c/p\u003e\u003cp\u003eBegining with version 3.0 these are now derived, and hence are defined in terms of\n strict structural equality, rather than observational equivalence. The reason for\n this change is that the observational equivalence abstraction was technically breakable\n with the exposed API. But since this change, some functions which were previously\n considered unsafe have become safe to expose (those that measure tree height, for example).\n\u003c/p\u003e\u003cp\u003eThe \u003ccode\u003e\u003ca\u003eRead\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003eShow\u003c/a\u003e\u003c/code\u003e instances.\n\u003c/p\u003e\u003cp\u003eBegining with version 4.0 these are now derived to ensure consistency with \u003ccode\u003e\u003ca\u003eEq\u003c/a\u003e\u003c/code\u003e instance.\n (Show now reveals the exact tree structure).\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "AVL",
          "package": "AvlTree",
          "source": "src/Data-Tree-AVL-Types.html#AVL",
          "type": "data"
        },
        "index": {
          "description": "AVL tree data type The balance factor BF of an AVL tree node is defined as the difference between the height of the left and right sub-trees An AVL tree is ALWAYS height balanced such that BF The functions in this library Data.Tree.AVL are designed so that they never construct an unbalanced tree well that assuming they re not broken The AVL tree type defined here has the BF encoded the constructors Some functions in this library return AVL trees that are also flat which in the context of this library means that the sizes of left and right sub-trees differ by at most one and are also flat Flat sorted trees should give slightly shorter searches than sorted trees which are merely height balanced Whether or not flattening is worth the effort depends on the number of times the tree will be searched and the cost of element comparison In cases where the tree elements are sorted all the relevant AVL functions follow the convention that the leftmost tree element is least and the rightmost tree element is the greatest Bear this in mind when defining general comparison functions It should also be noted that all functions in this library for sorted trees require that the tree does not contain multiple elements which are equal according to whatever criterion has been used to sort the elements It is important to be consistent about argument ordering when defining general purpose comparison functions or selectors for searching sorted tree such as myComp Ordering or myCComp COrdering In these cases the first argument is the search key and the second argument is an element of the AVL tree For example key myCComp element Lt implies key element proceed down the left sub-tree key myCComp element Gt implies key element proceed down the right sub-tree This convention is same as that used by the overloaded compare method from Ord class Controlling Strictness The AVL tree data type is declared as non-strict in all it fields but all the functions in this library behave as though it is strict in its recursive fields left and right sub-trees Strictness in the element field is controlled either by using the strict variants of functions defined in this library where appropriate or using strict variants of the combinators defined in Data.COrdering or using seq etc in your own code in any combining comparisons you define for example The Eq and Ord instances Begining with version these are now derived and hence are defined in terms of strict structural equality rather than observational equivalence The reason for this change is that the observational equivalence abstraction was technically breakable with the exposed API But since this change some functions which were previously considered unsafe have become safe to expose those that measure tree height for example The Read and Show instances Begining with version these are now derived to ensure consistency with Eq instance Show now reveals the exact tree structure",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "AVL",
          "package": "AvlTree",
          "partial": "AVL",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#t:AVL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA \u003ccode\u003e\u003ca\u003eBAVL\u003c/a\u003e\u003c/code\u003e is like a pointer reference to somewhere inside an \u003ccode\u003e\u003ca\u003eAVL\u003c/a\u003e\u003c/code\u003e tree. It may be either \"full\"\n (meaning it points to an actual tree node containing an element), or \"empty\" (meaning it\n points to the position in a tree where an element was expected but wasn't found).\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "BAVL",
          "package": "AvlTree",
          "source": "src/Data-Tree-AVL-Zipper.html#BAVL",
          "type": "data"
        },
        "index": {
          "description": "BAVL is like pointer reference to somewhere inside an AVL tree It may be either full meaning it points to an actual tree node containing an element or empty meaning it points to the position in tree where an element was expected but wasn found",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "BAVL",
          "package": "AvlTree",
          "partial": "BAVL",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#t:BAVL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA BinPath is full if the search succeeded, empty otherwise.\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "BinPath",
          "package": "AvlTree",
          "source": "src/Data-Tree-AVL-BinPath.html#BinPath",
          "type": "data"
        },
        "index": {
          "description": "BinPath is full if the search succeeded empty otherwise",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "BinPath",
          "package": "AvlTree",
          "partial": "Bin Path",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#t:BinPath"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAbstract data type for an unsuccessfully opened AVL tree.\n A PAVL can be thought of as a functional pointer to the gap\n where the expected element should be (but isn't). You can fill this gap using\n the \u003ccode\u003e\u003ca\u003efill\u003c/a\u003e\u003c/code\u003e function, or fill and close at the same time using the \u003ccode\u003e\u003ca\u003efillClose\u003c/a\u003e\u003c/code\u003e function.\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "PAVL",
          "package": "AvlTree",
          "source": "src/Data-Tree-AVL-Zipper.html#PAVL",
          "type": "data"
        },
        "index": {
          "description": "Abstract data type for an unsuccessfully opened AVL tree PAVL can be thought of as functional pointer to the gap where the expected element should be but isn You can fill this gap using the fill function or fill and close at the same time using the fillClose function",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "PAVL",
          "package": "AvlTree",
          "partial": "PAVL",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#t:PAVL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAbstract data type for a successfully opened AVL tree. All ZAVL's are non-empty!\n A ZAVL can be tought of as a functional pointer to an AVL tree element.\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "ZAVL",
          "package": "AvlTree",
          "source": "src/Data-Tree-AVL-Zipper.html#ZAVL",
          "type": "data"
        },
        "index": {
          "description": "Abstract data type for successfully opened AVL tree All ZAVL are non-empty ZAVL can be tought of as functional pointer to an AVL tree element",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "ZAVL",
          "package": "AvlTree",
          "partial": "ZAVL",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#t:ZAVL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEmpty Tree\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "E",
          "package": "AvlTree",
          "signature": "E",
          "source": "src/Data-Tree-AVL-Types.html#AVL",
          "type": "function"
        },
        "index": {
          "description": "Empty Tree",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "E",
          "package": "AvlTree",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:E"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Tree.AVL",
          "name": "EmptyBP",
          "package": "AvlTree",
          "signature": "EmptyBP !Int#",
          "source": "src/Data-Tree-AVL-BinPath.html#BinPath",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "EmptyBP",
          "package": "AvlTree",
          "partial": "Empty BP",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:EmptyBP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Tree.AVL",
          "name": "FullBP",
          "package": "AvlTree",
          "signature": "FullBP !Int# a",
          "source": "src/Data-Tree-AVL-BinPath.html#BinPath",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "FullBP",
          "package": "AvlTree",
          "partial": "Full BP",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:FullBP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eBF=-1 (right height \u003e left height)\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "N",
          "package": "AvlTree",
          "signature": "N (AVL e) e (AVL e)",
          "source": "src/Data-Tree-AVL-Types.html#AVL",
          "type": "function"
        },
        "index": {
          "description": "BF right height left height",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "N",
          "package": "AvlTree",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:N"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eBF=+1 (left height \u003e right height)\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "P",
          "package": "AvlTree",
          "signature": "P (AVL e) e (AVL e)",
          "source": "src/Data-Tree-AVL-Types.html#AVL",
          "type": "function"
        },
        "index": {
          "description": "BF left height right height",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "P",
          "package": "AvlTree",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:P"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eBF= 0\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "Z",
          "package": "AvlTree",
          "signature": "Z (AVL e) e (AVL e)",
          "source": "src/Data-Tree-AVL-Types.html#AVL",
          "type": "function"
        },
        "index": {
          "description": "BF",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "Z",
          "package": "AvlTree",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:Z"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAdds the height of a tree to the first argument.\n\u003c/p\u003e\u003cp\u003eComplexity: O(log n)\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "addHeight",
          "package": "AvlTree",
          "signature": "Int# -\u003e AVL e -\u003e Int#",
          "source": "src/Data-Tree-AVL-Height.html#addHeight",
          "type": "function"
        },
        "index": {
          "description": "Adds the height of tree to the first argument Complexity log",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "addHeight",
          "normalized": "Int #-\u003eAVL a-\u003eInt #",
          "package": "AvlTree",
          "partial": "Height",
          "signature": "Int #-\u003eAVL e-\u003eInt #",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:addHeight"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSee \u003ccode\u003e\u003ca\u003eaddSize#\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "addSize",
          "package": "AvlTree",
          "signature": "Int -\u003e AVL e -\u003e Int",
          "source": "src/Data-Tree-AVL-Size.html#addSize",
          "type": "function"
        },
        "index": {
          "description": "See addSize",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "addSize",
          "normalized": "Int-\u003eAVL a-\u003eInt",
          "package": "AvlTree",
          "partial": "Size",
          "signature": "Int-\u003eAVL e-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:addSize"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFast algorithm to add the size of a tree to the first argument. This avoids visiting about 50% of tree nodes\n by using fact that trees with small heights can only have particular shapes.\n So it's still O(n), but with substantial saving in constant factors.\n\u003c/p\u003e\u003cp\u003eComplexity: O(n)\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "addSize#",
          "package": "AvlTree",
          "signature": "Int# -\u003e AVL e -\u003e Int#",
          "source": "src/Data-Tree-AVL-Size.html#addSize%23",
          "type": "function"
        },
        "index": {
          "description": "Fast algorithm to add the size of tree to the first argument This avoids visiting about of tree nodes by using fact that trees with small heights can only have particular shapes So it still but with substantial saving in constant factors Complexity",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "addSize#",
          "normalized": "Int #-\u003eAVL a-\u003eInt #",
          "package": "AvlTree",
          "partial": "Size",
          "signature": "Int #-\u003eAVL e-\u003eInt #",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:addSize-35-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConverts a \u003ccode\u003e\u003ca\u003eBAVL\u003c/a\u003e\u003c/code\u003e to either a \u003ccode\u003e\u003ca\u003ePAVL\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eZAVL\u003c/a\u003e\u003c/code\u003e (depending on whether it is \"empty\" or \"full\").\n\u003c/p\u003e\u003cp\u003eComplexity: O(log n)\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "anyBAVLtoEither",
          "package": "AvlTree",
          "signature": "BAVL e -\u003e Either (PAVL e) (ZAVL e)",
          "source": "src/Data-Tree-AVL-Zipper.html#anyBAVLtoEither",
          "type": "function"
        },
        "index": {
          "description": "Converts BAVL to either PAVL or ZAVL depending on whether it is empty or full Complexity log",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "anyBAVLtoEither",
          "normalized": "BAVL a-\u003eEither(PAVL a)(ZAVL a)",
          "package": "AvlTree",
          "partial": "BAVLto Either",
          "signature": "BAVL e-\u003eEither(PAVL e)(ZAVL e)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:anyBAVLtoEither"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eApplies a function to the current element of a Zipper (lazily).\n See also \u003ccode\u003e\u003ca\u003eapplyCurrent'\u003c/a\u003e\u003c/code\u003e for a strict version of this function.\n\u003c/p\u003e\u003cp\u003eComplexity: O(1)\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "applyCurrent",
          "package": "AvlTree",
          "signature": "(e -\u003e e) -\u003e ZAVL e -\u003e ZAVL e",
          "source": "src/Data-Tree-AVL-Zipper.html#applyCurrent",
          "type": "function"
        },
        "index": {
          "description": "Applies function to the current element of Zipper lazily See also applyCurrent for strict version of this function Complexity",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "applyCurrent",
          "normalized": "(a-\u003ea)-\u003eZAVL a-\u003eZAVL a",
          "package": "AvlTree",
          "partial": "Current",
          "signature": "(e-\u003ee)-\u003eZAVL e-\u003eZAVL e",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:applyCurrent"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eApplies a function to the current element of a Zipper strictly.\n See also \u003ccode\u003e\u003ca\u003eapplyCurrent\u003c/a\u003e\u003c/code\u003e for a non-strict version of this function.\n\u003c/p\u003e\u003cp\u003eComplexity: O(1)\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "applyCurrent'",
          "package": "AvlTree",
          "signature": "(e -\u003e e) -\u003e ZAVL e -\u003e ZAVL e",
          "source": "src/Data-Tree-AVL-Zipper.html#applyCurrent%27",
          "type": "function"
        },
        "index": {
          "description": "Applies function to the current element of Zipper strictly See also applyCurrent for non-strict version of this function Complexity",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "applyCurrent'",
          "normalized": "(a-\u003ea)-\u003eZAVL a-\u003eZAVL a",
          "package": "AvlTree",
          "partial": "Current'",
          "signature": "(e-\u003ee)-\u003eZAVL e-\u003eZAVL e",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:applyCurrent-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eList AVL tree contents in left to right order.\n The resulting list in ascending order if the tree is sorted.\n\u003c/p\u003e\u003cp\u003eComplexity: O(n)\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "asListL",
          "package": "AvlTree",
          "signature": "AVL e -\u003e [e]",
          "source": "src/Data-Tree-AVL-List.html#asListL",
          "type": "function"
        },
        "index": {
          "description": "List AVL tree contents in left to right order The resulting list in ascending order if the tree is sorted Complexity",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "asListL",
          "normalized": "AVL a-\u003e[a]",
          "package": "AvlTree",
          "partial": "List",
          "signature": "AVL e-\u003e[e]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:asListL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eList AVL tree contents in right to left order.\n The resulting list in descending order if the tree is sorted.\n\u003c/p\u003e\u003cp\u003eComplexity: O(n)\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "asListR",
          "package": "AvlTree",
          "signature": "AVL e -\u003e [e]",
          "source": "src/Data-Tree-AVL-List.html#asListR",
          "type": "function"
        },
        "index": {
          "description": "List AVL tree contents in right to left order The resulting list in descending order if the tree is sorted Complexity",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "asListR",
          "normalized": "AVL a-\u003e[a]",
          "package": "AvlTree",
          "partial": "List",
          "signature": "AVL e-\u003e[e]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:asListR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInvokes \u003ccode\u003e\u003ca\u003epushList\u003c/a\u003e\u003c/code\u003e on the empty AVL tree.\n\u003c/p\u003e\u003cp\u003eComplexity: O(n.(log n))\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "asTree",
          "package": "AvlTree",
          "signature": "(e -\u003e e -\u003e COrdering e) -\u003e [e] -\u003e AVL e",
          "source": "src/Data-Tree-AVL-List.html#asTree",
          "type": "function"
        },
        "index": {
          "description": "Invokes pushList on the empty AVL tree Complexity log",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "asTree",
          "normalized": "(a-\u003ea-\u003eCOrdering a)-\u003e[a]-\u003eAVL a",
          "package": "AvlTree",
          "partial": "Tree",
          "signature": "(e-\u003ee-\u003eCOrdering e)-\u003e[e]-\u003eAVL e",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:asTree"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAs \u003ccode\u003e\u003ca\u003easTreeLenL\u003c/a\u003e\u003c/code\u003e, except the length of the list is calculated internally, not supplied\n as an argument.\n\u003c/p\u003e\u003cp\u003eComplexity: O(n)\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "asTreeL",
          "package": "AvlTree",
          "signature": "[e] -\u003e AVL e",
          "source": "src/Data-Tree-AVL-List.html#asTreeL",
          "type": "function"
        },
        "index": {
          "description": "As asTreeLenL except the length of the list is calculated internally not supplied as an argument Complexity",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "asTreeL",
          "normalized": "[a]-\u003eAVL a",
          "package": "AvlTree",
          "partial": "Tree",
          "signature": "[e]-\u003eAVL e",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:asTreeL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert a list of known length into an AVL tree, such that the head of the list becomes\n the leftmost tree element. The resulting tree is flat (and also sorted if the supplied list\n is sorted in ascending order).\n\u003c/p\u003e\u003cp\u003eIf the actual length of the list is not the same as the supplied length then\n an error will be raised.\n\u003c/p\u003e\u003cp\u003eComplexity: O(n)\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "asTreeLenL",
          "package": "AvlTree",
          "signature": "Int -\u003e [e] -\u003e AVL e",
          "source": "src/Data-Tree-AVL-List.html#asTreeLenL",
          "type": "function"
        },
        "index": {
          "description": "Convert list of known length into an AVL tree such that the head of the list becomes the leftmost tree element The resulting tree is flat and also sorted if the supplied list is sorted in ascending order If the actual length of the list is not the same as the supplied length then an error will be raised Complexity",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "asTreeLenL",
          "normalized": "Int-\u003e[a]-\u003eAVL a",
          "package": "AvlTree",
          "partial": "Tree Len",
          "signature": "Int-\u003e[e]-\u003eAVL e",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:asTreeLenL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert a list of known length into an AVL tree, such that the head of the list becomes\n the rightmost tree element. The resulting tree is flat (and also sorted if the supplied list\n is sorted in descending order).\n\u003c/p\u003e\u003cp\u003eIf the actual length of the list is not the same as the supplied length then\n an error will be raised.\n\u003c/p\u003e\u003cp\u003eComplexity: O(n)\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "asTreeLenR",
          "package": "AvlTree",
          "signature": "Int -\u003e [e] -\u003e AVL e",
          "source": "src/Data-Tree-AVL-List.html#asTreeLenR",
          "type": "function"
        },
        "index": {
          "description": "Convert list of known length into an AVL tree such that the head of the list becomes the rightmost tree element The resulting tree is flat and also sorted if the supplied list is sorted in descending order If the actual length of the list is not the same as the supplied length then an error will be raised Complexity",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "asTreeLenR",
          "normalized": "Int-\u003e[a]-\u003eAVL a",
          "package": "AvlTree",
          "partial": "Tree Len",
          "signature": "Int-\u003e[e]-\u003eAVL e",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:asTreeLenR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAs \u003ccode\u003e\u003ca\u003easTreeLenR\u003c/a\u003e\u003c/code\u003e, except the length of the list is calculated internally, not supplied\n as an argument.\n\u003c/p\u003e\u003cp\u003eComplexity: O(n)\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "asTreeR",
          "package": "AvlTree",
          "signature": "[e] -\u003e AVL e",
          "source": "src/Data-Tree-AVL-List.html#asTreeR",
          "type": "function"
        },
        "index": {
          "description": "As asTreeLenR except the length of the list is calculated internally not supplied as an argument Complexity",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "asTreeR",
          "normalized": "[a]-\u003eAVL a",
          "package": "AvlTree",
          "partial": "Tree",
          "signature": "[e]-\u003eAVL e",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:asTreeR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDelete the left-most element of a \u003cem\u003enon-empty\u003c/em\u003e AVL tree. If the tree is sorted this will be the\n least element. This function raises an error if it's argument is an empty tree.\n\u003c/p\u003e\u003cp\u003eComplexity: O(log n)\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "assertDelL",
          "package": "AvlTree",
          "signature": "AVL e -\u003e AVL e",
          "source": "src/Data-Tree-AVL-Delete.html#assertDelL",
          "type": "function"
        },
        "index": {
          "description": "Delete the left-most element of non-empty AVL tree If the tree is sorted this will be the least element This function raises an error if it argument is an empty tree Complexity log",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "assertDelL",
          "normalized": "AVL a-\u003eAVL a",
          "package": "AvlTree",
          "partial": "Del",
          "signature": "AVL e-\u003eAVL e",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:assertDelL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDeletes the current element and moves one step left.\n This function raises an error if the current element is already the leftmost element.\n\u003c/p\u003e\u003cp\u003eComplexity: O(1) average, O(log n) worst case.\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "assertDelMoveL",
          "package": "AvlTree",
          "signature": "ZAVL e -\u003e ZAVL e",
          "source": "src/Data-Tree-AVL-Zipper.html#assertDelMoveL",
          "type": "function"
        },
        "index": {
          "description": "Deletes the current element and moves one step left This function raises an error if the current element is already the leftmost element Complexity average log worst case",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "assertDelMoveL",
          "normalized": "ZAVL a-\u003eZAVL a",
          "package": "AvlTree",
          "partial": "Del Move",
          "signature": "ZAVL e-\u003eZAVL e",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:assertDelMoveL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDeletes the current element and moves one step right.\n This function raises an error if the current element is already the rightmost element.\n\u003c/p\u003e\u003cp\u003eComplexity: O(1) average, O(log n) worst case.\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "assertDelMoveR",
          "package": "AvlTree",
          "signature": "ZAVL e -\u003e ZAVL e",
          "source": "src/Data-Tree-AVL-Zipper.html#assertDelMoveR",
          "type": "function"
        },
        "index": {
          "description": "Deletes the current element and moves one step right This function raises an error if the current element is already the rightmost element Complexity average log worst case",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "assertDelMoveR",
          "normalized": "ZAVL a-\u003eZAVL a",
          "package": "AvlTree",
          "partial": "Del Move",
          "signature": "ZAVL e-\u003eZAVL e",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:assertDelMoveR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDelete the right-most element of a \u003cem\u003enon-empty\u003c/em\u003e AVL tree. If the tree is sorted this will be the\n greatest element. This function raises an error if it's argument is an empty tree.\n\u003c/p\u003e\u003cp\u003eComplexity: O(log n)\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "assertDelR",
          "package": "AvlTree",
          "signature": "AVL e -\u003e AVL e",
          "source": "src/Data-Tree-AVL-Delete.html#assertDelR",
          "type": "function"
        },
        "index": {
          "description": "Delete the right-most element of non-empty AVL tree If the tree is sorted this will be the greatest element This function raises an error if it argument is an empty tree Complexity log",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "assertDelR",
          "normalized": "AVL a-\u003eAVL a",
          "package": "AvlTree",
          "partial": "Del",
          "signature": "AVL e-\u003eAVL e",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:assertDelR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMoves one step left.\n This function raises an error if the current element is already the leftmost element.\n\u003c/p\u003e\u003cp\u003eComplexity: O(1) average, O(log n) worst case.\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "assertMoveL",
          "package": "AvlTree",
          "signature": "ZAVL e -\u003e ZAVL e",
          "source": "src/Data-Tree-AVL-Zipper.html#assertMoveL",
          "type": "function"
        },
        "index": {
          "description": "Moves one step left This function raises an error if the current element is already the leftmost element Complexity average log worst case",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "assertMoveL",
          "normalized": "ZAVL a-\u003eZAVL a",
          "package": "AvlTree",
          "partial": "Move",
          "signature": "ZAVL e-\u003eZAVL e",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:assertMoveL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMoves one step right.\n This function raises an error if the current element is already the rightmost element.\n\u003c/p\u003e\u003cp\u003eComplexity: O(1) average, O(log n) worst case.\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "assertMoveR",
          "package": "AvlTree",
          "signature": "ZAVL e -\u003e ZAVL e",
          "source": "src/Data-Tree-AVL-Zipper.html#assertMoveR",
          "type": "function"
        },
        "index": {
          "description": "Moves one step right This function raises an error if the current element is already the rightmost element Complexity average log worst case",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "assertMoveR",
          "normalized": "ZAVL a-\u003eZAVL a",
          "package": "AvlTree",
          "partial": "Move",
          "signature": "ZAVL e-\u003eZAVL e",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:assertMoveR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eOpens a sorted AVL tree at the element given by the supplied selector. This function\n raises an error if the tree does not contain such an element.\n\u003c/p\u003e\u003cp\u003eComplexity: O(log n)\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "assertOpen",
          "package": "AvlTree",
          "signature": "(e -\u003e Ordering) -\u003e AVL e -\u003e ZAVL e",
          "source": "src/Data-Tree-AVL-Zipper.html#assertOpen",
          "type": "function"
        },
        "index": {
          "description": "Opens sorted AVL tree at the element given by the supplied selector This function raises an error if the tree does not contain such an element Complexity log",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "assertOpen",
          "normalized": "(a-\u003eOrdering)-\u003eAVL a-\u003eZAVL a",
          "package": "AvlTree",
          "partial": "Open",
          "signature": "(e-\u003eOrdering)-\u003eAVL e-\u003eZAVL e",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:assertOpen"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eOpens a non-empty AVL tree at the leftmost element.\n This function raises an error if the tree is empty.\n\u003c/p\u003e\u003cp\u003eComplexity: O(log n)\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "assertOpenL",
          "package": "AvlTree",
          "signature": "AVL e -\u003e ZAVL e",
          "source": "src/Data-Tree-AVL-Zipper.html#assertOpenL",
          "type": "function"
        },
        "index": {
          "description": "Opens non-empty AVL tree at the leftmost element This function raises an error if the tree is empty Complexity log",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "assertOpenL",
          "normalized": "AVL a-\u003eZAVL a",
          "package": "AvlTree",
          "partial": "Open",
          "signature": "AVL e-\u003eZAVL e",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:assertOpenL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eOpens a non-empty AVL tree at the rightmost element.\n This function raises an error if the tree is empty.\n\u003c/p\u003e\u003cp\u003eComplexity: O(log n)\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "assertOpenR",
          "package": "AvlTree",
          "signature": "AVL e -\u003e ZAVL e",
          "source": "src/Data-Tree-AVL-Zipper.html#assertOpenR",
          "type": "function"
        },
        "index": {
          "description": "Opens non-empty AVL tree at the rightmost element This function raises an error if the tree is empty Complexity log",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "assertOpenR",
          "normalized": "AVL a-\u003eZAVL a",
          "package": "AvlTree",
          "partial": "Open",
          "signature": "AVL e-\u003eZAVL e",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:assertOpenR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGeneral purpose function for popping elements from a sorted AVL tree.\n An error is raised if a matching element is not found. The pair returned\n by this function consists of the popped value and the modified tree.\n\u003c/p\u003e\u003cp\u003eComplexity: O(log n)\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "assertPop",
          "package": "AvlTree",
          "signature": "(e -\u003e COrdering a) -\u003e AVL e -\u003e (a, AVL e)",
          "source": "src/Data-Tree-AVL-Delete.html#assertPop",
          "type": "function"
        },
        "index": {
          "description": "General purpose function for popping elements from sorted AVL tree An error is raised if matching element is not found The pair returned by this function consists of the popped value and the modified tree Complexity log",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "assertPop",
          "normalized": "(a-\u003eCOrdering b)-\u003eAVL a-\u003e(b,AVL a)",
          "package": "AvlTree",
          "partial": "Pop",
          "signature": "(e-\u003eCOrdering a)-\u003eAVL e-\u003e(a,AVL e)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:assertPop"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA simpler version of \u003ccode\u003e\u003ca\u003eassertPopMaybe\u003c/a\u003e\u003c/code\u003e. The corresponding element is deleted if the second value\n returned by the selector is \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e. If it's \u003ccode\u003e\u003ca\u003eFalse\u003c/a\u003e\u003c/code\u003e, the original tree is returned.\n This function raises an error if the search fails.\n\u003c/p\u003e\u003cp\u003eComplexity: O(log n)\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "assertPopIf",
          "package": "AvlTree",
          "signature": "(e -\u003e COrdering (a, Bool)) -\u003e AVL e -\u003e (a, AVL e)",
          "source": "src/Data-Tree-AVL-Delete.html#assertPopIf",
          "type": "function"
        },
        "index": {
          "description": "simpler version of assertPopMaybe The corresponding element is deleted if the second value returned by the selector is True If it False the original tree is returned This function raises an error if the search fails Complexity log",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "assertPopIf",
          "normalized": "(a-\u003eCOrdering(b,Bool))-\u003eAVL a-\u003e(b,AVL a)",
          "package": "AvlTree",
          "partial": "Pop If",
          "signature": "(e-\u003eCOrdering(a,Bool))-\u003eAVL e-\u003e(a,AVL e)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:assertPopIf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePop the left-most element from a non-empty AVL tree, returning the popped element and the\n modified AVL tree. If the tree is sorted this will be the least element.\n This function raises an error if it's argument is an empty tree.\n\u003c/p\u003e\u003cp\u003eComplexity: O(log n)\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "assertPopL",
          "package": "AvlTree",
          "signature": "AVL e -\u003e (e, AVL e)",
          "source": "src/Data-Tree-AVL-Delete.html#assertPopL",
          "type": "function"
        },
        "index": {
          "description": "Pop the left-most element from non-empty AVL tree returning the popped element and the modified AVL tree If the tree is sorted this will be the least element This function raises an error if it argument is an empty tree Complexity log",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "assertPopL",
          "normalized": "AVL a-\u003e(a,AVL a)",
          "package": "AvlTree",
          "partial": "Pop",
          "signature": "AVL e-\u003e(e,AVL e)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:assertPopL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIn this case the selector returns two values if a search succeeds.\n If the second is \u003ccode\u003e(\u003ccode\u003e\u003ca\u003eJust\u003c/a\u003e\u003c/code\u003e e)\u003c/code\u003e then the new value (\u003ccode\u003ee\u003c/code\u003e) is substituted in the same place in the tree.\n If the second is \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e then the corresponding tree element is deleted.\n This function raises an error if the search fails.\n\u003c/p\u003e\u003cp\u003eComplexity: O(log n)\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "assertPopMaybe",
          "package": "AvlTree",
          "signature": "(e -\u003e COrdering (a, Maybe e)) -\u003e AVL e -\u003e (a, AVL e)",
          "source": "src/Data-Tree-AVL-Delete.html#assertPopMaybe",
          "type": "function"
        },
        "index": {
          "description": "In this case the selector returns two values if search succeeds If the second is Just then the new value is substituted in the same place in the tree If the second is Nothing then the corresponding tree element is deleted This function raises an error if the search fails Complexity log",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "assertPopMaybe",
          "normalized": "(a-\u003eCOrdering(b,Maybe a))-\u003eAVL a-\u003e(b,AVL a)",
          "package": "AvlTree",
          "partial": "Pop Maybe",
          "signature": "(e-\u003eCOrdering(a,Maybe e))-\u003eAVL e-\u003e(a,AVL e)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:assertPopMaybe"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePop the right-most element from a non-empty AVL tree, returning the popped element and the\n modified AVL tree. If the tree is sorted this will be the greatest element.\n This function raises an error if it's argument is an empty tree.\n\u003c/p\u003e\u003cp\u003eComplexity: O(log n)\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "assertPopR",
          "package": "AvlTree",
          "signature": "AVL e -\u003e (AVL e, e)",
          "source": "src/Data-Tree-AVL-Delete.html#assertPopR",
          "type": "function"
        },
        "index": {
          "description": "Pop the right-most element from non-empty AVL tree returning the popped element and the modified AVL tree If the tree is sorted this will be the greatest element This function raises an error if it argument is an empty tree Complexity log",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "assertPopR",
          "normalized": "AVL a-\u003e(AVL a,a)",
          "package": "AvlTree",
          "partial": "Pop",
          "signature": "AVL e-\u003e(AVL e,e)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:assertPopR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGeneral purpose function to perform a search of a sorted tree, using the supplied selector.\n This function raises a error if the search fails.\n\u003c/p\u003e\u003cp\u003eComplexity: O(log n)\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "assertRead",
          "package": "AvlTree",
          "signature": "AVL e -\u003e (e -\u003e COrdering a) -\u003e a",
          "source": "src/Data-Tree-AVL-Read.html#assertRead",
          "type": "function"
        },
        "index": {
          "description": "General purpose function to perform search of sorted tree using the supplied selector This function raises error if the search fails Complexity log",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "assertRead",
          "normalized": "AVL a-\u003e(a-\u003eCOrdering b)-\u003eb",
          "package": "AvlTree",
          "partial": "Read",
          "signature": "AVL e-\u003e(e-\u003eCOrdering a)-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:assertRead"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRead the leftmost element from a \u003cem\u003enon-empty\u003c/em\u003e tree. Raises an error if the tree is empty.\n If the tree is sorted this will return the least element.\n\u003c/p\u003e\u003cp\u003eComplexity: O(log n)\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "assertReadL",
          "package": "AvlTree",
          "signature": "AVL e -\u003e e",
          "source": "src/Data-Tree-AVL-Read.html#assertReadL",
          "type": "function"
        },
        "index": {
          "description": "Read the leftmost element from non-empty tree Raises an error if the tree is empty If the tree is sorted this will return the least element Complexity log",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "assertReadL",
          "normalized": "AVL a-\u003ea",
          "package": "AvlTree",
          "partial": "Read",
          "signature": "AVL e-\u003ee",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:assertReadL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRead the rightmost element from a \u003cem\u003enon-empty\u003c/em\u003e tree. Raises an error if the tree is empty.\n If the tree is sorted this will return the greatest element.\n\u003c/p\u003e\u003cp\u003eComplexity: O(log n)\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "assertReadR",
          "package": "AvlTree",
          "signature": "AVL e -\u003e e",
          "source": "src/Data-Tree-AVL-Read.html#assertReadR",
          "type": "function"
        },
        "index": {
          "description": "Read the rightmost element from non-empty tree Raises an error if the tree is empty If the tree is sorted this will return the greatest element Complexity log",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "assertReadR",
          "normalized": "AVL a-\u003ea",
          "package": "AvlTree",
          "partial": "Read",
          "signature": "AVL e-\u003ee",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:assertReadR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturns the exact tree size in the form \u003ccode\u003e(\u003ccode\u003e\u003ca\u003eJust\u003c/a\u003e\u003c/code\u003e n)\u003c/code\u003e if this is less than or\n equal to the input clip value. Returns \u003ccode\u003e\u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e of the size is greater than\n the clip value. This function exploits the same optimisation as \u003ccode\u003e\u003ca\u003eaddSize\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eComplexity: O(min n c) where n is tree size and c is clip value.\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "clipSize",
          "package": "AvlTree",
          "signature": "Int -\u003e AVL e -\u003e Maybe Int",
          "source": "src/Data-Tree-AVL-Size.html#clipSize",
          "type": "function"
        },
        "index": {
          "description": "Returns the exact tree size in the form Just if this is less than or equal to the input clip value Returns Nothing of the size is greater than the clip value This function exploits the same optimisation as addSize Complexity min where is tree size and is clip value",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "clipSize",
          "normalized": "Int-\u003eAVL a-\u003eMaybe Int",
          "package": "AvlTree",
          "partial": "Size",
          "signature": "Int-\u003eAVL e-\u003eMaybe Int",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:clipSize"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCloses a Zipper.\n\u003c/p\u003e\u003cp\u003eComplexity: O(log n)\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "close",
          "package": "AvlTree",
          "signature": "ZAVL e -\u003e AVL e",
          "source": "src/Data-Tree-AVL-Zipper.html#close",
          "type": "function"
        },
        "index": {
          "description": "Closes Zipper Complexity log",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "close",
          "normalized": "ZAVL a-\u003eAVL a",
          "package": "AvlTree",
          "signature": "ZAVL e-\u003eAVL e",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:close"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturns the original tree, extracted from the \u003ccode\u003e\u003ca\u003eBAVL\u003c/a\u003e\u003c/code\u003e. Typically you will not need this, as\n the original tree will still be in scope in most cases.\n\u003c/p\u003e\u003cp\u003eComplexity: O(1)\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "closeBAVL",
          "package": "AvlTree",
          "signature": "BAVL e -\u003e AVL e",
          "source": "src/Data-Tree-AVL-Zipper.html#closeBAVL",
          "type": "function"
        },
        "index": {
          "description": "Returns the original tree extracted from the BAVL Typically you will not need this as the original tree will still be in scope in most cases Complexity",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "closeBAVL",
          "normalized": "BAVL a-\u003eAVL a",
          "package": "AvlTree",
          "partial": "BAVL",
          "signature": "BAVL e-\u003eAVL e",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:closeBAVL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA fast algorithm for comparing the heights of two trees. This algorithm avoids the need\n to compute the heights of both trees and should offer better performance if the trees differ\n significantly in height. But if you need the heights anyway it will be quicker to just evaluate\n them both and compare the results.\n\u003c/p\u003e\u003cp\u003eComplexity: O(log n), where n is the size of the smaller of the two trees.\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "compareHeight",
          "package": "AvlTree",
          "signature": "AVL a -\u003e AVL b -\u003e Ordering",
          "source": "src/Data-Tree-AVL-Height.html#compareHeight",
          "type": "function"
        },
        "index": {
          "description": "fast algorithm for comparing the heights of two trees This algorithm avoids the need to compute the heights of both trees and should offer better performance if the trees differ significantly in height But if you need the heights anyway it will be quicker to just evaluate them both and compare the results Complexity log where is the size of the smaller of the two trees",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "compareHeight",
          "normalized": "AVL a-\u003eAVL b-\u003eOrdering",
          "package": "AvlTree",
          "partial": "Height",
          "signature": "AVL a-\u003eAVL b-\u003eOrdering",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:compareHeight"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConcatenate a \u003cem\u003efinite\u003c/em\u003e list of AVL trees. During construction of the resulting tree the\n input list is consumed lazily, but it will be consumed entirely before the result is returned.\n\u003c/p\u003e\u003cpre\u003e asListL (concatAVL avls) = concatMap asListL avls\n\u003c/pre\u003e\u003cp\u003eComplexity: Umm..Dunno. Uses a divide and conquer approach to splice adjacent pairs of\n trees in the list recursively, until only one tree remains. The complexity of each splice\n is proportional to the difference in tree heights.\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "concatAVL",
          "package": "AvlTree",
          "signature": "[AVL e] -\u003e AVL e",
          "source": "src/Data-Tree-AVL-Join.html#concatAVL",
          "type": "function"
        },
        "index": {
          "description": "Concatenate finite list of AVL trees During construction of the resulting tree the input list is consumed lazily but it will be consumed entirely before the result is returned asListL concatAVL avls concatMap asListL avls Complexity Umm..Dunno Uses divide and conquer approach to splice adjacent pairs of trees in the list recursively until only one tree remains The complexity of each splice is proportional to the difference in tree heights",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "concatAVL",
          "normalized": "[AVL a]-\u003eAVL a",
          "package": "AvlTree",
          "partial": "AVL",
          "signature": "[AVL e]-\u003eAVL e",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:concatAVL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGeneral purpose function to perform a search of a sorted tree, using the supplied selector.\n Returns True if matching element is found.\n\u003c/p\u003e\u003cp\u003eComplexity: O(log n)\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "contains",
          "package": "AvlTree",
          "signature": "AVL e -\u003e (e -\u003e Ordering) -\u003e Bool",
          "source": "src/Data-Tree-AVL-Read.html#contains",
          "type": "function"
        },
        "index": {
          "description": "General purpose function to perform search of sorted tree using the supplied selector Returns True if matching element is found Complexity log",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "contains",
          "normalized": "AVL a-\u003e(a-\u003eOrdering)-\u003eBool",
          "package": "AvlTree",
          "signature": "AVL e-\u003e(e-\u003eOrdering)-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:contains"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGeneral purpose function to perform a search of a sorted tree, using the supplied selector.\n This function is similar to \u003ccode\u003e\u003ca\u003eassertRead\u003c/a\u003e\u003c/code\u003e, but returns a the default value (first argument) if\n the search fails.\n\u003c/p\u003e\u003cp\u003eComplexity: O(log n)\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "defaultRead",
          "package": "AvlTree",
          "signature": "a -\u003e AVL e -\u003e (e -\u003e COrdering a) -\u003e a",
          "source": "src/Data-Tree-AVL-Read.html#defaultRead",
          "type": "function"
        },
        "index": {
          "description": "General purpose function to perform search of sorted tree using the supplied selector This function is similar to assertRead but returns the default value first argument if the search fails Complexity log",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "defaultRead",
          "normalized": "a-\u003eAVL b-\u003e(b-\u003eCOrdering a)-\u003ea",
          "package": "AvlTree",
          "partial": "Read",
          "signature": "a-\u003eAVL e-\u003e(e-\u003eCOrdering a)-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:defaultRead"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSimilar to \u003ccode\u003e\u003ca\u003edelAllL\u003c/a\u003e\u003c/code\u003e, in that all elements to the left of the current element are deleted,\n but this function also closes the tree in the process.\n\u003c/p\u003e\u003cp\u003eComplexity: O(log n)\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "delAllCloseL",
          "package": "AvlTree",
          "signature": "ZAVL e -\u003e AVL e",
          "source": "src/Data-Tree-AVL-Zipper.html#delAllCloseL",
          "type": "function"
        },
        "index": {
          "description": "Similar to delAllL in that all elements to the left of the current element are deleted but this function also closes the tree in the process Complexity log",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "delAllCloseL",
          "normalized": "ZAVL a-\u003eAVL a",
          "package": "AvlTree",
          "partial": "All Close",
          "signature": "ZAVL e-\u003eAVL e",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:delAllCloseL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSimilar to \u003ccode\u003e\u003ca\u003edelAllR\u003c/a\u003e\u003c/code\u003e, in that all elements to the right of the current element are deleted,\n but this function also closes the tree in the process.\n\u003c/p\u003e\u003cp\u003eComplexity: O(log n)\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "delAllCloseR",
          "package": "AvlTree",
          "signature": "ZAVL e -\u003e AVL e",
          "source": "src/Data-Tree-AVL-Zipper.html#delAllCloseR",
          "type": "function"
        },
        "index": {
          "description": "Similar to delAllR in that all elements to the right of the current element are deleted but this function also closes the tree in the process Complexity log",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "delAllCloseR",
          "normalized": "ZAVL a-\u003eAVL a",
          "package": "AvlTree",
          "partial": "All Close",
          "signature": "ZAVL e-\u003eAVL e",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:delAllCloseR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSimilar to \u003ccode\u003e\u003ca\u003edelAllCloseL\u003c/a\u003e\u003c/code\u003e, but in this case the current element and all\n those to the left of the current element are deleted.\n\u003c/p\u003e\u003cp\u003eComplexity: O(log n)\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "delAllIncCloseL",
          "package": "AvlTree",
          "signature": "ZAVL e -\u003e AVL e",
          "source": "src/Data-Tree-AVL-Zipper.html#delAllIncCloseL",
          "type": "function"
        },
        "index": {
          "description": "Similar to delAllCloseL but in this case the current element and all those to the left of the current element are deleted Complexity log",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "delAllIncCloseL",
          "normalized": "ZAVL a-\u003eAVL a",
          "package": "AvlTree",
          "partial": "All Inc Close",
          "signature": "ZAVL e-\u003eAVL e",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:delAllIncCloseL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSimilar to \u003ccode\u003e\u003ca\u003edelAllCloseR\u003c/a\u003e\u003c/code\u003e, but in this case the current element and all\n those to the right of the current element are deleted.\n\u003c/p\u003e\u003cp\u003eComplexity: O(log n)\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "delAllIncCloseR",
          "package": "AvlTree",
          "signature": "ZAVL e -\u003e AVL e",
          "source": "src/Data-Tree-AVL-Zipper.html#delAllIncCloseR",
          "type": "function"
        },
        "index": {
          "description": "Similar to delAllCloseR but in this case the current element and all those to the right of the current element are deleted Complexity log",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "delAllIncCloseR",
          "normalized": "ZAVL a-\u003eAVL a",
          "package": "AvlTree",
          "partial": "All Inc Close",
          "signature": "ZAVL e-\u003eAVL e",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:delAllIncCloseR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDelete all elements to the left of the current element.\n\u003c/p\u003e\u003cp\u003eComplexity: O(log n)\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "delAllL",
          "package": "AvlTree",
          "signature": "ZAVL e -\u003e ZAVL e",
          "source": "src/Data-Tree-AVL-Zipper.html#delAllL",
          "type": "function"
        },
        "index": {
          "description": "Delete all elements to the left of the current element Complexity log",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "delAllL",
          "normalized": "ZAVL a-\u003eZAVL a",
          "package": "AvlTree",
          "partial": "All",
          "signature": "ZAVL e-\u003eZAVL e",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:delAllL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDelete all elements to the right of the current element.\n\u003c/p\u003e\u003cp\u003eComplexity: O(log n)\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "delAllR",
          "package": "AvlTree",
          "signature": "ZAVL e -\u003e ZAVL e",
          "source": "src/Data-Tree-AVL-Zipper.html#delAllR",
          "type": "function"
        },
        "index": {
          "description": "Delete all elements to the right of the current element Complexity log",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "delAllR",
          "normalized": "ZAVL a-\u003eZAVL a",
          "package": "AvlTree",
          "partial": "All",
          "signature": "ZAVL e-\u003eZAVL e",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:delAllR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDeletes the current element and then closes the Zipper.\n\u003c/p\u003e\u003cp\u003eComplexity: O(log n)\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "delClose",
          "package": "AvlTree",
          "signature": "ZAVL e -\u003e AVL e",
          "source": "src/Data-Tree-AVL-Zipper.html#delClose",
          "type": "function"
        },
        "index": {
          "description": "Deletes the current element and then closes the Zipper Complexity log",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "delClose",
          "normalized": "ZAVL a-\u003eAVL a",
          "package": "AvlTree",
          "partial": "Close",
          "signature": "ZAVL e-\u003eAVL e",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:delClose"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDelete the left-most element of an AVL tree. If the tree is sorted this will be the\n least element. This function returns an empty tree if it's argument is an empty tree.\n\u003c/p\u003e\u003cp\u003eComplexity: O(log n)\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "delL",
          "package": "AvlTree",
          "signature": "AVL e -\u003e AVL e",
          "source": "src/Data-Tree-AVL-Delete.html#delL",
          "type": "function"
        },
        "index": {
          "description": "Delete the left-most element of an AVL tree If the tree is sorted this will be the least element This function returns an empty tree if it argument is an empty tree Complexity log",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "delL",
          "normalized": "AVL a-\u003eAVL a",
          "package": "AvlTree",
          "signature": "AVL e-\u003eAVL e",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:delL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDelete the right-most element of an AVL tree. If the tree is sorted this will be the\n greatest element. This function returns an empty tree if it's argument is an empty tree.\n\u003c/p\u003e\u003cp\u003eComplexity: O(log n)\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "delR",
          "package": "AvlTree",
          "signature": "AVL e -\u003e AVL e",
          "source": "src/Data-Tree-AVL-Delete.html#delR",
          "type": "function"
        },
        "index": {
          "description": "Delete the right-most element of an AVL tree If the tree is sorted this will be the greatest element This function returns an empty tree if it argument is an empty tree Complexity log",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "delR",
          "normalized": "AVL a-\u003eAVL a",
          "package": "AvlTree",
          "signature": "AVL e-\u003eAVL e",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:delR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGeneral purpose function for deletion of elements from a sorted AVL tree.\n If a matching element is not found then this function returns the original tree.\n\u003c/p\u003e\u003cp\u003eComplexity: O(log n)\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "delete",
          "package": "AvlTree",
          "signature": "(e -\u003e Ordering) -\u003e AVL e -\u003e AVL e",
          "source": "src/Data-Tree-AVL-Delete.html#delete",
          "type": "function"
        },
        "index": {
          "description": "General purpose function for deletion of elements from sorted AVL tree If matching element is not found then this function returns the original tree Complexity log",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "delete",
          "normalized": "(a-\u003eOrdering)-\u003eAVL a-\u003eAVL a",
          "package": "AvlTree",
          "signature": "(e-\u003eOrdering)-\u003eAVL e-\u003eAVL e",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:delete"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIf the \u003ccode\u003e\u003ca\u003eBAVL\u003c/a\u003e\u003c/code\u003e is \"full\", this function returns the original tree with the corresponding\n element deleted. If it's \"empty\" the original tree is returned unmodified.\n\u003c/p\u003e\u003cp\u003eComplexity: O(log n) (or O(1) for an empty \u003ccode\u003e\u003ca\u003eBAVL\u003c/a\u003e\u003c/code\u003e)\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "deleteBAVL",
          "package": "AvlTree",
          "signature": "BAVL e -\u003e AVL e",
          "source": "src/Data-Tree-AVL-Zipper.html#deleteBAVL",
          "type": "function"
        },
        "index": {
          "description": "If the BAVL is full this function returns the original tree with the corresponding element deleted If it empty the original tree is returned unmodified Complexity log or for an empty BAVL",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "deleteBAVL",
          "normalized": "BAVL a-\u003eAVL a",
          "package": "AvlTree",
          "partial": "BAVL",
          "signature": "BAVL e-\u003eAVL e",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:deleteBAVL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFunctionally identical to \u003ccode\u003e\u003ca\u003edelete\u003c/a\u003e\u003c/code\u003e, but returns an identical tree (one with all the nodes on\n the path duplicated) if the search fails. This should probably only be used if you know the\n search will succeed.\n\u003c/p\u003e\u003cp\u003eComplexity: O(log n)\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "deleteFast",
          "package": "AvlTree",
          "signature": "(e -\u003e Ordering) -\u003e AVL e -\u003e AVL e",
          "source": "src/Data-Tree-AVL-Delete.html#deleteFast",
          "type": "function"
        },
        "index": {
          "description": "Functionally identical to delete but returns an identical tree one with all the nodes on the path duplicated if the search fails This should probably only be used if you know the search will succeed Complexity log",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "deleteFast",
          "normalized": "(a-\u003eOrdering)-\u003eAVL a-\u003eAVL a",
          "package": "AvlTree",
          "partial": "Fast",
          "signature": "(e-\u003eOrdering)-\u003eAVL e-\u003eAVL e",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:deleteFast"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis version only deletes the element if the supplied selector returns \u003ccode\u003e(\u003ccode\u003e\u003ca\u003eEq\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e)\u003c/code\u003e.\n If it returns \u003ccode\u003e(\u003ccode\u003e\u003ca\u003eEq\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eFalse\u003c/a\u003e\u003c/code\u003e)\u003c/code\u003e or if no matching element is found then this function returns\n the original tree.\n\u003c/p\u003e\u003cp\u003eComplexity: O(log n)\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "deleteIf",
          "package": "AvlTree",
          "signature": "(e -\u003e COrdering Bool) -\u003e AVL e -\u003e AVL e",
          "source": "src/Data-Tree-AVL-Delete.html#deleteIf",
          "type": "function"
        },
        "index": {
          "description": "This version only deletes the element if the supplied selector returns Eq True If it returns Eq False or if no matching element is found then this function returns the original tree Complexity log",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "deleteIf",
          "normalized": "(a-\u003eCOrdering Bool)-\u003eAVL a-\u003eAVL a",
          "package": "AvlTree",
          "partial": "If",
          "signature": "(e-\u003eCOrdering Bool)-\u003eAVL e-\u003eAVL e",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:deleteIf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis version only deletes the element if the supplied selector returns \u003ccode\u003e(\u003ccode\u003e\u003ca\u003eEq\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e)\u003c/code\u003e.\n If it returns \u003ccode\u003e(\u003ccode\u003e\u003ca\u003eEq\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003eJust\u003c/a\u003e\u003c/code\u003e e))\u003c/code\u003e  then the matching element is replaced by e.\n If no matching element is found then this function returns the original tree.\n\u003c/p\u003e\u003cp\u003eComplexity: O(log n)\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "deleteMaybe",
          "package": "AvlTree",
          "signature": "(e -\u003e COrdering (Maybe e)) -\u003e AVL e -\u003e AVL e",
          "source": "src/Data-Tree-AVL-Delete.html#deleteMaybe",
          "type": "function"
        },
        "index": {
          "description": "This version only deletes the element if the supplied selector returns Eq Nothing If it returns Eq Just then the matching element is replaced by If no matching element is found then this function returns the original tree Complexity log",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "deleteMaybe",
          "normalized": "(a-\u003eCOrdering(Maybe a))-\u003eAVL a-\u003eAVL a",
          "package": "AvlTree",
          "partial": "Maybe",
          "signature": "(e-\u003eCOrdering(Maybe e))-\u003eAVL e-\u003eAVL e",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:deleteMaybe"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDeletes a tree element. Assumes the path bits were extracted from a \u003ccode\u003eFullBP\u003c/code\u003e constructor.\n\u003c/p\u003e\u003cp\u003eComplexity: O(log n)\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "deletePath",
          "package": "AvlTree",
          "signature": "Int# -\u003e AVL e -\u003e AVL e",
          "source": "src/Data-Tree-AVL-Internals-DelUtils.html#deletePath",
          "type": "function"
        },
        "index": {
          "description": "Deletes tree element Assumes the path bits were extracted from FullBP constructor Complexity log",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "deletePath",
          "normalized": "Int #-\u003eAVL a-\u003eAVL a",
          "package": "AvlTree",
          "partial": "Path",
          "signature": "Int #-\u003eAVL e-\u003eAVL e",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:deletePath"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUses the supplied comparison to evaluate the difference between two sets represented as\n sorted AVL trees. The expression..\n\u003c/p\u003e\u003cpre\u003e difference cmp setA setB\n\u003c/pre\u003e\u003cp\u003e.. is a set containing all those elements of \u003ccode\u003esetA\u003c/code\u003e which do not appear in \u003ccode\u003esetB\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eComplexity: Not sure, but I'd appreciate it if someone could figure it out.\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "difference",
          "package": "AvlTree",
          "signature": "(a -\u003e b -\u003e Ordering) -\u003e AVL a -\u003e AVL b -\u003e AVL a",
          "source": "src/Data-Tree-AVL-Set.html#difference",
          "type": "function"
        },
        "index": {
          "description": "Uses the supplied comparison to evaluate the difference between two sets represented as sorted AVL trees The expression difference cmp setA setB is set containing all those elements of setA which do not appear in setB Complexity Not sure but appreciate it if someone could figure it out",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "difference",
          "normalized": "(a-\u003eb-\u003eOrdering)-\u003eAVL a-\u003eAVL b-\u003eAVL a",
          "package": "AvlTree",
          "signature": "(a-\u003eb-\u003eOrdering)-\u003eAVL a-\u003eAVL b-\u003eAVL a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:difference"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSimilar to \u003ccode\u003e\u003ca\u003edifference\u003c/a\u003e\u003c/code\u003e, but the resulting tree also includes those elements a' for which the\n combining comparison returns \u003ccode\u003e(Eq (Just a'))\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eComplexity: Not sure, but I'd appreciate it if someone could figure it out.\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "differenceMaybe",
          "package": "AvlTree",
          "signature": "(a -\u003e b -\u003e COrdering (Maybe a)) -\u003e AVL a -\u003e AVL b -\u003e AVL a",
          "source": "src/Data-Tree-AVL-Set.html#differenceMaybe",
          "type": "function"
        },
        "index": {
          "description": "Similar to difference but the resulting tree also includes those elements for which the combining comparison returns Eq Just Complexity Not sure but appreciate it if someone could figure it out",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "differenceMaybe",
          "normalized": "(a-\u003eb-\u003eCOrdering(Maybe a))-\u003eAVL a-\u003eAVL b-\u003eAVL a",
          "package": "AvlTree",
          "partial": "Maybe",
          "signature": "(a-\u003eb-\u003eCOrdering(Maybe a))-\u003eAVL a-\u003eAVL b-\u003eAVL a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:differenceMaybe"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUses the supplied comparison to evaluate the union of two \u003cem\u003edisjoint\u003c/em\u003e sets represented as\n sorted AVL trees. It will be slightly faster than \u003ccode\u003e\u003ca\u003eunion\u003c/a\u003e\u003c/code\u003e but will raise an error if the\n two sets intersect. Typically this would be used to re-combine the \"post-munge\" results\n from one of the \"venn\" operations.\n\u003c/p\u003e\u003cp\u003eComplexity: Not sure, but I'd appreciate it if someone could figure it out.\n (Faster than Hedge union from Data.Set at any rate).\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "disjointUnion",
          "package": "AvlTree",
          "signature": "(e -\u003e e -\u003e Ordering) -\u003e AVL e -\u003e AVL e -\u003e AVL e",
          "source": "src/Data-Tree-AVL-Set.html#disjointUnion",
          "type": "function"
        },
        "index": {
          "description": "Uses the supplied comparison to evaluate the union of two disjoint sets represented as sorted AVL trees It will be slightly faster than union but will raise an error if the two sets intersect Typically this would be used to re-combine the post-munge results from one of the venn operations Complexity Not sure but appreciate it if someone could figure it out Faster than Hedge union from Data.Set at any rate",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "disjointUnion",
          "normalized": "(a-\u003ea-\u003eOrdering)-\u003eAVL a-\u003eAVL a-\u003eAVL a",
          "package": "AvlTree",
          "partial": "Union",
          "signature": "(e-\u003ee-\u003eOrdering)-\u003eAVL e-\u003eAVL e-\u003eAVL e",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:disjointUnion"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA synonym for \u003ccode\u003e\u003ca\u003etakeLT\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eComplexity: O(log n)\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "dropGE",
          "package": "AvlTree",
          "signature": "(e -\u003e Ordering) -\u003e AVL e -\u003e AVL e",
          "source": "src/Data-Tree-AVL-Split.html#dropGE",
          "type": "function"
        },
        "index": {
          "description": "synonym for takeLT Complexity log",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "dropGE",
          "normalized": "(a-\u003eOrdering)-\u003eAVL a-\u003eAVL a",
          "package": "AvlTree",
          "partial": "GE",
          "signature": "(e-\u003eOrdering)-\u003eAVL e-\u003eAVL e",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:dropGE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA synonym for \u003ccode\u003e\u003ca\u003etakeLE\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eComplexity: O(log n)\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "dropGT",
          "package": "AvlTree",
          "signature": "(e -\u003e Ordering) -\u003e AVL e -\u003e AVL e",
          "source": "src/Data-Tree-AVL-Split.html#dropGT",
          "type": "function"
        },
        "index": {
          "description": "synonym for takeLE Complexity log",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "dropGT",
          "normalized": "(a-\u003eOrdering)-\u003eAVL a-\u003eAVL a",
          "package": "AvlTree",
          "partial": "GT",
          "signature": "(e-\u003eOrdering)-\u003eAVL e-\u003eAVL e",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:dropGT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis is a simplified version of \u003ccode\u003e\u003ca\u003esplitAtL\u003c/a\u003e\u003c/code\u003e which returns the remaining tree only (rightmost elements).\n This function raises an error if n is negative.\n\u003c/p\u003e\u003cp\u003eIf the tree size is greater than n the result is (Right r) where r contains\n the remaining elements (r will be non-empty).\n\u003c/p\u003e\u003cp\u003eIf the tree size is less than or equal to n then the result is (Left s), where s is tree size.\n\u003c/p\u003e\u003cp\u003eAn empty tree will always yield a result of (Left 0).\n\u003c/p\u003e\u003cp\u003eComplexity: O(n)\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "dropL",
          "package": "AvlTree",
          "signature": "Int -\u003e AVL e -\u003e Either Int (AVL e)",
          "source": "src/Data-Tree-AVL-Split.html#dropL",
          "type": "function"
        },
        "index": {
          "description": "This is simplified version of splitAtL which returns the remaining tree only rightmost elements This function raises an error if is negative If the tree size is greater than the result is Right where contains the remaining elements will be non-empty If the tree size is less than or equal to then the result is Left where is tree size An empty tree will always yield result of Left Complexity",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "dropL",
          "normalized": "Int-\u003eAVL a-\u003eEither Int(AVL a)",
          "package": "AvlTree",
          "signature": "Int-\u003eAVL e-\u003eEither Int(AVL e)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:dropL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA synonym for \u003ccode\u003e\u003ca\u003etakeGT\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eComplexity: O(log n)\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "dropLE",
          "package": "AvlTree",
          "signature": "(e -\u003e Ordering) -\u003e AVL e -\u003e AVL e",
          "source": "src/Data-Tree-AVL-Split.html#dropLE",
          "type": "function"
        },
        "index": {
          "description": "synonym for takeGT Complexity log",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "dropLE",
          "normalized": "(a-\u003eOrdering)-\u003eAVL a-\u003eAVL a",
          "package": "AvlTree",
          "partial": "LE",
          "signature": "(e-\u003eOrdering)-\u003eAVL e-\u003eAVL e",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:dropLE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA synonym for \u003ccode\u003e\u003ca\u003etakeGE\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eComplexity: O(log n)\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "dropLT",
          "package": "AvlTree",
          "signature": "(e -\u003e Ordering) -\u003e AVL e -\u003e AVL e",
          "source": "src/Data-Tree-AVL-Split.html#dropLT",
          "type": "function"
        },
        "index": {
          "description": "synonym for takeGE Complexity log",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "dropLT",
          "normalized": "(a-\u003eOrdering)-\u003eAVL a-\u003eAVL a",
          "package": "AvlTree",
          "partial": "LT",
          "signature": "(e-\u003eOrdering)-\u003eAVL e-\u003eAVL e",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:dropLT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis is a simplified version of \u003ccode\u003e\u003ca\u003esplitAtR\u003c/a\u003e\u003c/code\u003e which returns the remaining tree only (leftmost elements).\n This function raises an error if n is negative.\n\u003c/p\u003e\u003cp\u003eIf the tree size is greater than n the result is (Right l) where l contains\n the remaining elements (l will be non-empty).\n\u003c/p\u003e\u003cp\u003eIf the tree size is less than or equal to n then the result is (Left s), where s is tree size.\n\u003c/p\u003e\u003cp\u003eAn empty tree will always yield a result of (Left 0).\n\u003c/p\u003e\u003cp\u003eComplexity: O(n)\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "dropR",
          "package": "AvlTree",
          "signature": "Int -\u003e AVL e -\u003e Either Int (AVL e)",
          "source": "src/Data-Tree-AVL-Split.html#dropR",
          "type": "function"
        },
        "index": {
          "description": "This is simplified version of splitAtR which returns the remaining tree only leftmost elements This function raises an error if is negative If the tree size is greater than the result is Right where contains the remaining elements will be non-empty If the tree size is less than or equal to then the result is Left where is tree size An empty tree will always yield result of Left Complexity",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "dropR",
          "normalized": "Int-\u003eAVL a-\u003eEither Int(AVL a)",
          "package": "AvlTree",
          "signature": "Int-\u003eAVL e-\u003eEither Int(AVL e)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:dropR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis is a simplified version of \u003ccode\u003e\u003ca\u003espanL\u003c/a\u003e\u003c/code\u003e which does not return the tree containing\n the elements which satisfy the supplied predicate.\n The result is a tree whose leftmost element is the first to fail the predicate, starting from\n the left (which may be empty).\n\u003c/p\u003e\u003cp\u003eComplexity: O(n), where n is the number of elements dropped.\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "dropWhileL",
          "package": "AvlTree",
          "signature": "(e -\u003e Bool) -\u003e AVL e -\u003e AVL e",
          "source": "src/Data-Tree-AVL-Split.html#dropWhileL",
          "type": "function"
        },
        "index": {
          "description": "This is simplified version of spanL which does not return the tree containing the elements which satisfy the supplied predicate The result is tree whose leftmost element is the first to fail the predicate starting from the left which may be empty Complexity where is the number of elements dropped",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "dropWhileL",
          "normalized": "(a-\u003eBool)-\u003eAVL a-\u003eAVL a",
          "package": "AvlTree",
          "partial": "While",
          "signature": "(e-\u003eBool)-\u003eAVL e-\u003eAVL e",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:dropWhileL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis is a simplified version of \u003ccode\u003e\u003ca\u003espanR\u003c/a\u003e\u003c/code\u003e which does not return the tree containing\n the elements which satisfy the supplied predicate.\n The result is a tree whose rightmost element is the first to fail the predicate, starting from\n the right (which may be empty).\n\u003c/p\u003e\u003cp\u003eComplexity: O(n), where n is the number of elements dropped.\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "dropWhileR",
          "package": "AvlTree",
          "signature": "(e -\u003e Bool) -\u003e AVL e -\u003e AVL e",
          "source": "src/Data-Tree-AVL-Split.html#dropWhileR",
          "type": "function"
        },
        "index": {
          "description": "This is simplified version of spanR which does not return the tree containing the elements which satisfy the supplied predicate The result is tree whose rightmost element is the first to fail the predicate starting from the right which may be empty Complexity where is the number of elements dropped",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "dropWhileR",
          "normalized": "(a-\u003eBool)-\u003eAVL a-\u003eAVL a",
          "package": "AvlTree",
          "partial": "While",
          "signature": "(e-\u003eBool)-\u003eAVL e-\u003eAVL e",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:dropWhileR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe empty AVL tree.\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "empty",
          "package": "AvlTree",
          "signature": "AVL e",
          "source": "src/Data-Tree-AVL-Types.html#empty",
          "type": "function"
        },
        "index": {
          "description": "The empty AVL tree",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "empty",
          "package": "AvlTree",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:empty"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturns \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e if the \u003ccode\u003e\u003ca\u003eBAVL\u003c/a\u003e\u003c/code\u003e is \"empty\" (no corresponding element was found).\n\u003c/p\u003e\u003cp\u003eComplexity: O(1)\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "emptyBAVL",
          "package": "AvlTree",
          "signature": "BAVL e -\u003e Bool",
          "source": "src/Data-Tree-AVL-Zipper.html#emptyBAVL",
          "type": "function"
        },
        "index": {
          "description": "Returns True if the BAVL is empty no corresponding element was found Complexity",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "emptyBAVL",
          "normalized": "BAVL a-\u003eBool",
          "package": "AvlTree",
          "partial": "BAVL",
          "signature": "BAVL e-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:emptyBAVL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConverts an \"empty\" \u003ccode\u003e\u003ca\u003eBAVL\u003c/a\u003e\u003c/code\u003e as a \u003ccode\u003e\u003ca\u003ePAVL\u003c/a\u003e\u003c/code\u003e. Raises an error if applied to a \"full\" \u003ccode\u003e\u003ca\u003eBAVL\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eComplexity: O(log n)\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "emptyBAVLtoPAVL",
          "package": "AvlTree",
          "signature": "BAVL e -\u003e PAVL e",
          "source": "src/Data-Tree-AVL-Zipper.html#emptyBAVLtoPAVL",
          "type": "function"
        },
        "index": {
          "description": "Converts an empty BAVL as PAVL Raises an error if applied to full BAVL Complexity log",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "emptyBAVLtoPAVL",
          "normalized": "BAVL a-\u003ePAVL a",
          "package": "AvlTree",
          "partial": "BAVLto PAVL",
          "signature": "BAVL e-\u003ePAVL e",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:emptyBAVLtoPAVL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis name is \u003cem\u003edeprecated\u003c/em\u003e. Instead use \u003ccode\u003e\u003ca\u003eaddSize\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eaddSize#\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "fastAddSize",
          "package": "AvlTree",
          "signature": "Int# -\u003e AVL e -\u003e Int#",
          "source": "src/Data-Tree-AVL-Deprecated.html#fastAddSize",
          "type": "function"
        },
        "index": {
          "description": "This name is deprecated Instead use addSize or addSize",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "fastAddSize",
          "normalized": "Int #-\u003eAVL a-\u003eInt #",
          "package": "AvlTree",
          "partial": "Add Size",
          "signature": "Int #-\u003eAVL e-\u003eInt #",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:fastAddSize"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFill the gap pointed to by a \u003ccode\u003e\u003ca\u003ePAVL\u003c/a\u003e\u003c/code\u003e with the supplied element, which becomes\n the current element of the resulting \u003ccode\u003e\u003ca\u003eZAVL\u003c/a\u003e\u003c/code\u003e. The supplied filling element should\n be \"equal\" to the value used in the search which created the \u003ccode\u003e\u003ca\u003ePAVL\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eComplexity: O(1)\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "fill",
          "package": "AvlTree",
          "signature": "e -\u003e PAVL e -\u003e ZAVL e",
          "source": "src/Data-Tree-AVL-Zipper.html#fill",
          "type": "function"
        },
        "index": {
          "description": "Fill the gap pointed to by PAVL with the supplied element which becomes the current element of the resulting ZAVL The supplied filling element should be equal to the value used in the search which created the PAVL Complexity",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "fill",
          "normalized": "a-\u003ePAVL a-\u003eZAVL a",
          "package": "AvlTree",
          "signature": "e-\u003ePAVL e-\u003eZAVL e",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:fill"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEssentially the same operation as \u003ccode\u003e\u003ca\u003efill\u003c/a\u003e\u003c/code\u003e, but the resulting \u003ccode\u003e\u003ca\u003eZAVL\u003c/a\u003e\u003c/code\u003e is closed\n immediately.\n\u003c/p\u003e\u003cp\u003eComplexity: O(log n)\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "fillClose",
          "package": "AvlTree",
          "signature": "e -\u003e PAVL e -\u003e AVL e",
          "source": "src/Data-Tree-AVL-Zipper.html#fillClose",
          "type": "function"
        },
        "index": {
          "description": "Essentially the same operation as fill but the resulting ZAVL is closed immediately Complexity log",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "fillClose",
          "normalized": "a-\u003ePAVL a-\u003eAVL a",
          "package": "AvlTree",
          "partial": "Close",
          "signature": "e-\u003ePAVL e-\u003eAVL e",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:fillClose"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRemove all AVL tree elements which do not satisfy the supplied predicate.\n Element ordering is preserved.\n\u003c/p\u003e\u003cp\u003eComplexity: O(n)\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "filter",
          "package": "AvlTree",
          "signature": "(e -\u003e Bool) -\u003e AVL e -\u003e AVL e",
          "source": "src/Data-Tree-AVL-List.html#filter",
          "type": "function"
        },
        "index": {
          "description": "Remove all AVL tree elements which do not satisfy the supplied predicate Element ordering is preserved Complexity",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "filter",
          "normalized": "(a-\u003eBool)-\u003eAVL a-\u003eAVL a",
          "package": "AvlTree",
          "signature": "(e-\u003eBool)-\u003eAVL e-\u003eAVL e",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:filter"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis name is \u003cem\u003edeprecated\u003c/em\u003e. Instead use \u003ccode\u003e\u003ca\u003efilter\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "filterAVL",
          "package": "AvlTree",
          "signature": "(e -\u003e Bool) -\u003e AVL e -\u003e AVL e",
          "source": "src/Data-Tree-AVL-Deprecated.html#filterAVL",
          "type": "function"
        },
        "index": {
          "description": "This name is deprecated Instead use filter",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "filterAVL",
          "normalized": "(a-\u003eBool)-\u003eAVL a-\u003eAVL a",
          "package": "AvlTree",
          "partial": "AVL",
          "signature": "(e-\u003eBool)-\u003eAVL e-\u003eAVL e",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:filterAVL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRemove all AVL tree elements which do not satisfy the supplied predicate.\n Element ordering is preserved. The resulting tree is flat.\n See \u003ccode\u003e\u003ca\u003efilter\u003c/a\u003e\u003c/code\u003e for an alternative implementation which is probably more efficient.\n\u003c/p\u003e\u003cp\u003eComplexity: O(n)\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "filterViaList",
          "package": "AvlTree",
          "signature": "(e -\u003e Bool) -\u003e AVL e -\u003e AVL e",
          "source": "src/Data-Tree-AVL-List.html#filterViaList",
          "type": "function"
        },
        "index": {
          "description": "Remove all AVL tree elements which do not satisfy the supplied predicate Element ordering is preserved The resulting tree is flat See filter for an alternative implementation which is probably more efficient Complexity",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "filterViaList",
          "normalized": "(a-\u003eBool)-\u003eAVL a-\u003eAVL a",
          "package": "AvlTree",
          "partial": "Via List",
          "signature": "(e-\u003eBool)-\u003eAVL e-\u003eAVL e",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:filterViaList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFind the path to a non-existant AVL tree element, returns -1 (invalid path) if element is found\n\u003c/p\u003e\u003cp\u003eComplexity: O(log n)\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "findEmptyPath",
          "package": "AvlTree",
          "signature": "(e -\u003e Ordering) -\u003e AVL e -\u003e Int#",
          "source": "src/Data-Tree-AVL-BinPath.html#findEmptyPath",
          "type": "function"
        },
        "index": {
          "description": "Find the path to non-existant AVL tree element returns invalid path if element is found Complexity log",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "findEmptyPath",
          "normalized": "(a-\u003eOrdering)-\u003eAVL a-\u003eInt #",
          "package": "AvlTree",
          "partial": "Empty Path",
          "signature": "(e-\u003eOrdering)-\u003eAVL e-\u003eInt #",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:findEmptyPath"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFind the path to a AVL tree element, returns -1 (invalid path) if element not found\n\u003c/p\u003e\u003cp\u003eComplexity: O(log n)\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "findFullPath",
          "package": "AvlTree",
          "signature": "(e -\u003e Ordering) -\u003e AVL e -\u003e Int#",
          "source": "src/Data-Tree-AVL-BinPath.html#findFullPath",
          "type": "function"
        },
        "index": {
          "description": "Find the path to AVL tree element returns invalid path if element not found Complexity log",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "findFullPath",
          "normalized": "(a-\u003eOrdering)-\u003eAVL a-\u003eInt #",
          "package": "AvlTree",
          "partial": "Full Path",
          "signature": "(e-\u003eOrdering)-\u003eAVL e-\u003eInt #",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:findFullPath"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis name is \u003cem\u003edeprecated\u003c/em\u003e. Instead use \u003ccode\u003e\u003ca\u003efindFullPath\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "findPath",
          "package": "AvlTree",
          "signature": "(e -\u003e Ordering) -\u003e AVL e -\u003e Int#",
          "source": "src/Data-Tree-AVL-Deprecated.html#findPath",
          "type": "function"
        },
        "index": {
          "description": "This name is deprecated Instead use findFullPath",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "findPath",
          "normalized": "(a-\u003eOrdering)-\u003eAVL a-\u003eInt #",
          "package": "AvlTree",
          "partial": "Path",
          "signature": "(e-\u003eOrdering)-\u003eAVL e-\u003eInt #",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:findPath"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSimilar to \u003ccode\u003e\u003ca\u003econcatAVL\u003c/a\u003e\u003c/code\u003e, except the resulting tree is flat.\n This function evaluates the entire list of trees before constructing the result.\n\u003c/p\u003e\u003cp\u003eComplexity: O(n), where n is the total number of elements in the resulting tree.\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "flatConcat",
          "package": "AvlTree",
          "signature": "[AVL e] -\u003e AVL e",
          "source": "src/Data-Tree-AVL-Join.html#flatConcat",
          "type": "function"
        },
        "index": {
          "description": "Similar to concatAVL except the resulting tree is flat This function evaluates the entire list of trees before constructing the result Complexity where is the total number of elements in the resulting tree",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "flatConcat",
          "normalized": "[AVL a]-\u003eAVL a",
          "package": "AvlTree",
          "partial": "Concat",
          "signature": "[AVL e]-\u003eAVL e",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:flatConcat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSimilar to \u003ccode\u003e\u003ca\u003emap\u003c/a\u003e\u003c/code\u003e, but the resulting tree is flat.\n This function has higher constant factor overhead than \u003ccode\u003e\u003ca\u003emap\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eComplexity: O(n)\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "flatMap",
          "package": "AvlTree",
          "signature": "(a -\u003e b) -\u003e AVL a -\u003e AVL b",
          "source": "src/Data-Tree-AVL-List.html#flatMap",
          "type": "function"
        },
        "index": {
          "description": "Similar to map but the resulting tree is flat This function has higher constant factor overhead than map Complexity",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "flatMap",
          "normalized": "(a-\u003eb)-\u003eAVL a-\u003eAVL b",
          "package": "AvlTree",
          "partial": "Map",
          "signature": "(a-\u003eb)-\u003eAVL a-\u003eAVL b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:flatMap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSame as \u003ccode\u003e\u003ca\u003eflatMap\u003c/a\u003e\u003c/code\u003e, but the supplied function is applied strictly.\n\u003c/p\u003e\u003cp\u003eComplexity: O(n)\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "flatMap'",
          "package": "AvlTree",
          "signature": "(a -\u003e b) -\u003e AVL a -\u003e AVL b",
          "source": "src/Data-Tree-AVL-List.html#flatMap%27",
          "type": "function"
        },
        "index": {
          "description": "Same as flatMap but the supplied function is applied strictly Complexity",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "flatMap'",
          "normalized": "(a-\u003eb)-\u003eAVL a-\u003eAVL b",
          "package": "AvlTree",
          "partial": "Map'",
          "signature": "(a-\u003eb)-\u003eAVL a-\u003eAVL b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:flatMap-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSimilar to \u003ccode\u003e\u003ca\u003eflatten\u003c/a\u003e\u003c/code\u003e, but the tree elements are reversed. This function has higher constant\n factor overhead than \u003ccode\u003e\u003ca\u003ereverse\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eComplexity: O(n)\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "flatReverse",
          "package": "AvlTree",
          "signature": "AVL e -\u003e AVL e",
          "source": "src/Data-Tree-AVL-List.html#flatReverse",
          "type": "function"
        },
        "index": {
          "description": "Similar to flatten but the tree elements are reversed This function has higher constant factor overhead than reverse Complexity",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "flatReverse",
          "normalized": "AVL a-\u003eAVL a",
          "package": "AvlTree",
          "partial": "Reverse",
          "signature": "AVL e-\u003eAVL e",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:flatReverse"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFlatten an AVL tree, preserving the ordering of the tree elements.\n\u003c/p\u003e\u003cp\u003eComplexity: O(n)\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "flatten",
          "package": "AvlTree",
          "signature": "AVL e -\u003e AVL e",
          "source": "src/Data-Tree-AVL-List.html#flatten",
          "type": "function"
        },
        "index": {
          "description": "Flatten an AVL tree preserving the ordering of the tree elements Complexity",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "flatten",
          "normalized": "AVL a-\u003eAVL a",
          "package": "AvlTree",
          "signature": "AVL e-\u003eAVL e",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:flatten"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe AVL equivalent of \u003ccode\u003e\u003ca\u003efoldl\u003c/a\u003e\u003c/code\u003e on lists. This is a the lazy version (as lazy as the folding function\n anyway). Using this version with a function that is strict in it's first argument will result in O(n)\n stack use. See \u003ccode\u003e\u003ca\u003efoldl'\u003c/a\u003e\u003c/code\u003e for a strict version.\n\u003c/p\u003e\u003cpre\u003e foldl f a avl = foldl f a (asListL avl)\n\u003c/pre\u003e\u003cp\u003eFor example, the \u003ccode\u003e\u003ca\u003easListR\u003c/a\u003e\u003c/code\u003e function could be defined..\n\u003c/p\u003e\u003cpre\u003e asListR = foldl (flip (:)) []\n\u003c/pre\u003e\u003cp\u003eComplexity: O(n)\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "foldl",
          "package": "AvlTree",
          "signature": "(a -\u003e e -\u003e a) -\u003e a -\u003e AVL e -\u003e a",
          "source": "src/Data-Tree-AVL-List.html#foldl",
          "type": "function"
        },
        "index": {
          "description": "The AVL equivalent of foldl on lists This is the lazy version as lazy as the folding function anyway Using this version with function that is strict in it first argument will result in stack use See foldl for strict version foldl avl foldl asListL avl For example the asListR function could be defined asListR foldl flip Complexity",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "foldl",
          "normalized": "(a-\u003eb-\u003ea)-\u003ea-\u003eAVL b-\u003ea",
          "package": "AvlTree",
          "signature": "(a-\u003ee-\u003ea)-\u003ea-\u003eAVL e-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:foldl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe strict version of \u003ccode\u003e\u003ca\u003efoldl\u003c/a\u003e\u003c/code\u003e, which is useful for functions which are strict in their first\n argument. The advantage of this version is that it reduces the stack use from the O(n) that the lazy\n version gives (when used with strict functions) to O(log n).\n\u003c/p\u003e\u003cp\u003eComplexity: O(n)\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "foldl'",
          "package": "AvlTree",
          "signature": "(a -\u003e e -\u003e a) -\u003e a -\u003e AVL e -\u003e a",
          "source": "src/Data-Tree-AVL-List.html#foldl%27",
          "type": "function"
        },
        "index": {
          "description": "The strict version of foldl which is useful for functions which are strict in their first argument The advantage of this version is that it reduces the stack use from the that the lazy version gives when used with strict functions to log Complexity",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "foldl'",
          "normalized": "(a-\u003eb-\u003ea)-\u003ea-\u003eAVL b-\u003ea",
          "package": "AvlTree",
          "signature": "(a-\u003ee-\u003ea)-\u003ea-\u003eAVL e-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:foldl-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe AVL equivalent of \u003ccode\u003e\u003ca\u003efoldl1\u003c/a\u003e\u003c/code\u003e on lists. This is a the lazy version (as lazy as the folding function\n anyway). Using this version with a function that is strict in it's first argument will result in O(n)\n stack use. See \u003ccode\u003e\u003ca\u003efoldl1'\u003c/a\u003e\u003c/code\u003e for a strict version.\n\u003c/p\u003e\u003cpre\u003e foldl1 f avl = foldl1 f (asListL avl)\n\u003c/pre\u003e\u003cp\u003eThis function raises an error if the tree is empty.\n\u003c/p\u003e\u003cp\u003eComplexity: O(n)\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "foldl1",
          "package": "AvlTree",
          "signature": "(e -\u003e e -\u003e e) -\u003e AVL e -\u003e e",
          "source": "src/Data-Tree-AVL-List.html#foldl1",
          "type": "function"
        },
        "index": {
          "description": "The AVL equivalent of foldl1 on lists This is the lazy version as lazy as the folding function anyway Using this version with function that is strict in it first argument will result in stack use See foldl1 for strict version foldl1 avl foldl1 asListL avl This function raises an error if the tree is empty Complexity",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "foldl1",
          "normalized": "(a-\u003ea-\u003ea)-\u003eAVL a-\u003ea",
          "package": "AvlTree",
          "signature": "(e-\u003ee-\u003ee)-\u003eAVL e-\u003ee",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:foldl1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe strict version of \u003ccode\u003e\u003ca\u003efoldl1\u003c/a\u003e\u003c/code\u003e, which is useful for functions which are strict in their first\n argument. The advantage of this version is that it reduces the stack use from the O(n) that the lazy\n version gives (when used with strict functions) to O(log n).\n\u003c/p\u003e\u003cp\u003eComplexity: O(n)\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "foldl1'",
          "package": "AvlTree",
          "signature": "(e -\u003e e -\u003e e) -\u003e AVL e -\u003e e",
          "source": "src/Data-Tree-AVL-List.html#foldl1%27",
          "type": "function"
        },
        "index": {
          "description": "The strict version of foldl1 which is useful for functions which are strict in their first argument The advantage of this version is that it reduces the stack use from the that the lazy version gives when used with strict functions to log Complexity",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "foldl1'",
          "normalized": "(a-\u003ea-\u003ea)-\u003eAVL a-\u003ea",
          "package": "AvlTree",
          "signature": "(e-\u003ee-\u003ee)-\u003eAVL e-\u003ee",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:foldl1-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis name is \u003cem\u003edeprecated\u003c/em\u003e. Instead use \u003ccode\u003e\u003ca\u003efoldl1\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "foldl1AVL",
          "package": "AvlTree",
          "signature": "(e -\u003e e -\u003e e) -\u003e AVL e -\u003e e",
          "source": "src/Data-Tree-AVL-Deprecated.html#foldl1AVL",
          "type": "function"
        },
        "index": {
          "description": "This name is deprecated Instead use foldl1",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "foldl1AVL",
          "normalized": "(a-\u003ea-\u003ea)-\u003eAVL a-\u003ea",
          "package": "AvlTree",
          "partial": "AVL",
          "signature": "(e-\u003ee-\u003ee)-\u003eAVL e-\u003ee",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:foldl1AVL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis name is \u003cem\u003edeprecated\u003c/em\u003e. Instead use \u003ccode\u003e\u003ca\u003efoldl1'\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "foldl1AVL'",
          "package": "AvlTree",
          "signature": "(e -\u003e e -\u003e e) -\u003e AVL e -\u003e e",
          "source": "src/Data-Tree-AVL-Deprecated.html#foldl1AVL%27",
          "type": "function"
        },
        "index": {
          "description": "This name is deprecated Instead use foldl1",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "foldl1AVL'",
          "normalized": "(a-\u003ea-\u003ea)-\u003eAVL a-\u003ea",
          "package": "AvlTree",
          "partial": "AVL'",
          "signature": "(e-\u003ee-\u003ee)-\u003eAVL e-\u003ee",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:foldl1AVL-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis fold is a hybrid between \u003ccode\u003e\u003ca\u003efoldl\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003efoldl1\u003c/a\u003e\u003c/code\u003e. As with \u003ccode\u003e\u003ca\u003efoldl1\u003c/a\u003e\u003c/code\u003e, it requires\n a non-empty tree, but instead of treating the leftmost element as an initial value, it applies\n a function to it (second function argument) and uses the result instead. This allows\n a more flexible type for the main folding function (same type as that used by \u003ccode\u003e\u003ca\u003efoldl\u003c/a\u003e\u003c/code\u003e).\n As with \u003ccode\u003e\u003ca\u003efoldl\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003efoldl1\u003c/a\u003e\u003c/code\u003e, this function is lazy, so it's best not to use it with functions\n that are strict in their first argument. See \u003ccode\u003e\u003ca\u003efoldl2'\u003c/a\u003e\u003c/code\u003e for a strict version.\n\u003c/p\u003e\u003cp\u003eComplexity: O(n)\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "foldl2",
          "package": "AvlTree",
          "signature": "(a -\u003e e -\u003e a) -\u003e (e -\u003e a) -\u003e AVL e -\u003e a",
          "source": "src/Data-Tree-AVL-List.html#foldl2",
          "type": "function"
        },
        "index": {
          "description": "This fold is hybrid between foldl and foldl1 As with foldl1 it requires non-empty tree but instead of treating the leftmost element as an initial value it applies function to it second function argument and uses the result instead This allows more flexible type for the main folding function same type as that used by foldl As with foldl and foldl1 this function is lazy so it best not to use it with functions that are strict in their first argument See foldl2 for strict version Complexity",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "foldl2",
          "normalized": "(a-\u003eb-\u003ea)-\u003e(b-\u003ea)-\u003eAVL b-\u003ea",
          "package": "AvlTree",
          "signature": "(a-\u003ee-\u003ea)-\u003e(e-\u003ea)-\u003eAVL e-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:foldl2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe strict version of \u003ccode\u003e\u003ca\u003efoldl2\u003c/a\u003e\u003c/code\u003e, which is useful for functions which are strict in their first\n argument. The advantage of this version is that it reduces the stack use from the O(n) that the lazy\n version gives (when used with strict functions) to O(log n).\n\u003c/p\u003e\u003cp\u003eComplexity: O(n)\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "foldl2'",
          "package": "AvlTree",
          "signature": "(a -\u003e e -\u003e a) -\u003e (e -\u003e a) -\u003e AVL e -\u003e a",
          "source": "src/Data-Tree-AVL-List.html#foldl2%27",
          "type": "function"
        },
        "index": {
          "description": "The strict version of foldl2 which is useful for functions which are strict in their first argument The advantage of this version is that it reduces the stack use from the that the lazy version gives when used with strict functions to log Complexity",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "foldl2'",
          "normalized": "(a-\u003eb-\u003ea)-\u003e(b-\u003ea)-\u003eAVL b-\u003ea",
          "package": "AvlTree",
          "signature": "(a-\u003ee-\u003ea)-\u003e(e-\u003ea)-\u003eAVL e-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:foldl2-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis name is \u003cem\u003edeprecated\u003c/em\u003e. Instead use \u003ccode\u003e\u003ca\u003efoldl2\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "foldl2AVL",
          "package": "AvlTree",
          "signature": "(a -\u003e e -\u003e a) -\u003e (e -\u003e a) -\u003e AVL e -\u003e a",
          "source": "src/Data-Tree-AVL-Deprecated.html#foldl2AVL",
          "type": "function"
        },
        "index": {
          "description": "This name is deprecated Instead use foldl2",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "foldl2AVL",
          "normalized": "(a-\u003eb-\u003ea)-\u003e(b-\u003ea)-\u003eAVL b-\u003ea",
          "package": "AvlTree",
          "partial": "AVL",
          "signature": "(a-\u003ee-\u003ea)-\u003e(e-\u003ea)-\u003eAVL e-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:foldl2AVL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis name is \u003cem\u003edeprecated\u003c/em\u003e. Instead use \u003ccode\u003e\u003ca\u003efoldl2'\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "foldl2AVL'",
          "package": "AvlTree",
          "signature": "(a -\u003e e -\u003e a) -\u003e (e -\u003e a) -\u003e AVL e -\u003e a",
          "source": "src/Data-Tree-AVL-Deprecated.html#foldl2AVL%27",
          "type": "function"
        },
        "index": {
          "description": "This name is deprecated Instead use foldl2",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "foldl2AVL'",
          "normalized": "(a-\u003eb-\u003ea)-\u003e(b-\u003ea)-\u003eAVL b-\u003ea",
          "package": "AvlTree",
          "partial": "AVL'",
          "signature": "(a-\u003ee-\u003ea)-\u003e(e-\u003ea)-\u003eAVL e-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:foldl2AVL-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis name is \u003cem\u003edeprecated\u003c/em\u003e. Instead use \u003ccode\u003e\u003ca\u003efoldl\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "foldlAVL",
          "package": "AvlTree",
          "signature": "(a -\u003e e -\u003e a) -\u003e a -\u003e AVL e -\u003e a",
          "source": "src/Data-Tree-AVL-Deprecated.html#foldlAVL",
          "type": "function"
        },
        "index": {
          "description": "This name is deprecated Instead use foldl",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "foldlAVL",
          "normalized": "(a-\u003eb-\u003ea)-\u003ea-\u003eAVL b-\u003ea",
          "package": "AvlTree",
          "partial": "AVL",
          "signature": "(a-\u003ee-\u003ea)-\u003ea-\u003eAVL e-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:foldlAVL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis name is \u003cem\u003edeprecated\u003c/em\u003e. Instead use \u003ccode\u003e\u003ca\u003efoldl'\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "foldlAVL'",
          "package": "AvlTree",
          "signature": "(a -\u003e e -\u003e a) -\u003e a -\u003e AVL e -\u003e a",
          "source": "src/Data-Tree-AVL-Deprecated.html#foldlAVL%27",
          "type": "function"
        },
        "index": {
          "description": "This name is deprecated Instead use foldl",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "foldlAVL'",
          "normalized": "(a-\u003eb-\u003ea)-\u003ea-\u003eAVL b-\u003ea",
          "package": "AvlTree",
          "partial": "AVL'",
          "signature": "(a-\u003ee-\u003ea)-\u003ea-\u003eAVL e-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:foldlAVL-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe AVL equivalent of \u003ccode\u003e\u003ca\u003efoldr\u003c/a\u003e\u003c/code\u003e on lists. This is a the lazy version (as lazy as the folding function\n anyway). Using this version with a function that is strict in it's second argument will result in O(n)\n stack use. See \u003ccode\u003e\u003ca\u003efoldr'\u003c/a\u003e\u003c/code\u003e for a strict version.\n\u003c/p\u003e\u003cp\u003eIt behaves as if defined..\n\u003c/p\u003e\u003cpre\u003e foldr f a avl = foldr f a (asListL avl)\n\u003c/pre\u003e\u003cp\u003eFor example, the \u003ccode\u003e\u003ca\u003easListL\u003c/a\u003e\u003c/code\u003e function could be defined..\n\u003c/p\u003e\u003cpre\u003e asListL = foldr (:) []\n\u003c/pre\u003e\u003cp\u003eComplexity: O(n)\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "foldr",
          "package": "AvlTree",
          "signature": "(e -\u003e a -\u003e a) -\u003e a -\u003e AVL e -\u003e a",
          "source": "src/Data-Tree-AVL-List.html#foldr",
          "type": "function"
        },
        "index": {
          "description": "The AVL equivalent of foldr on lists This is the lazy version as lazy as the folding function anyway Using this version with function that is strict in it second argument will result in stack use See foldr for strict version It behaves as if defined foldr avl foldr asListL avl For example the asListL function could be defined asListL foldr Complexity",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "foldr",
          "normalized": "(a-\u003eb-\u003eb)-\u003eb-\u003eAVL a-\u003eb",
          "package": "AvlTree",
          "signature": "(e-\u003ea-\u003ea)-\u003ea-\u003eAVL e-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:foldr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe strict version of \u003ccode\u003e\u003ca\u003efoldr\u003c/a\u003e\u003c/code\u003e, which is useful for functions which are strict in their second\n argument. The advantage of this version is that it reduces the stack use from the O(n) that the lazy\n version gives (when used with strict functions) to O(log n).\n\u003c/p\u003e\u003cp\u003eComplexity: O(n)\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "foldr'",
          "package": "AvlTree",
          "signature": "(e -\u003e a -\u003e a) -\u003e a -\u003e AVL e -\u003e a",
          "source": "src/Data-Tree-AVL-List.html#foldr%27",
          "type": "function"
        },
        "index": {
          "description": "The strict version of foldr which is useful for functions which are strict in their second argument The advantage of this version is that it reduces the stack use from the that the lazy version gives when used with strict functions to log Complexity",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "foldr'",
          "normalized": "(a-\u003eb-\u003eb)-\u003eb-\u003eAVL a-\u003eb",
          "package": "AvlTree",
          "signature": "(e-\u003ea-\u003ea)-\u003ea-\u003eAVL e-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:foldr-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe AVL equivalent of \u003ccode\u003e\u003ca\u003efoldr1\u003c/a\u003e\u003c/code\u003e on lists. This is a the lazy version (as lazy as the folding function\n anyway). Using this version with a function that is strict in it's second argument will result in O(n)\n stack use. See \u003ccode\u003e\u003ca\u003efoldr1'\u003c/a\u003e\u003c/code\u003e for a strict version.\n\u003c/p\u003e\u003cpre\u003e foldr1 f avl = foldr1 f (asListL avl)\n\u003c/pre\u003e\u003cp\u003eThis function raises an error if the tree is empty.\n\u003c/p\u003e\u003cp\u003eComplexity: O(n)\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "foldr1",
          "package": "AvlTree",
          "signature": "(e -\u003e e -\u003e e) -\u003e AVL e -\u003e e",
          "source": "src/Data-Tree-AVL-List.html#foldr1",
          "type": "function"
        },
        "index": {
          "description": "The AVL equivalent of foldr1 on lists This is the lazy version as lazy as the folding function anyway Using this version with function that is strict in it second argument will result in stack use See foldr1 for strict version foldr1 avl foldr1 asListL avl This function raises an error if the tree is empty Complexity",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "foldr1",
          "normalized": "(a-\u003ea-\u003ea)-\u003eAVL a-\u003ea",
          "package": "AvlTree",
          "signature": "(e-\u003ee-\u003ee)-\u003eAVL e-\u003ee",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:foldr1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe strict version of \u003ccode\u003e\u003ca\u003efoldr1\u003c/a\u003e\u003c/code\u003e, which is useful for functions which are strict in their second\n argument. The advantage of this version is that it reduces the stack use from the O(n) that the lazy\n version gives (when used with strict functions) to O(log n).\n\u003c/p\u003e\u003cp\u003eComplexity: O(n)\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "foldr1'",
          "package": "AvlTree",
          "signature": "(e -\u003e e -\u003e e) -\u003e AVL e -\u003e e",
          "source": "src/Data-Tree-AVL-List.html#foldr1%27",
          "type": "function"
        },
        "index": {
          "description": "The strict version of foldr1 which is useful for functions which are strict in their second argument The advantage of this version is that it reduces the stack use from the that the lazy version gives when used with strict functions to log Complexity",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "foldr1'",
          "normalized": "(a-\u003ea-\u003ea)-\u003eAVL a-\u003ea",
          "package": "AvlTree",
          "signature": "(e-\u003ee-\u003ee)-\u003eAVL e-\u003ee",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:foldr1-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis name is \u003cem\u003edeprecated\u003c/em\u003e. Instead use \u003ccode\u003e\u003ca\u003efoldr1\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "foldr1AVL",
          "package": "AvlTree",
          "signature": "(e -\u003e e -\u003e e) -\u003e AVL e -\u003e e",
          "source": "src/Data-Tree-AVL-Deprecated.html#foldr1AVL",
          "type": "function"
        },
        "index": {
          "description": "This name is deprecated Instead use foldr1",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "foldr1AVL",
          "normalized": "(a-\u003ea-\u003ea)-\u003eAVL a-\u003ea",
          "package": "AvlTree",
          "partial": "AVL",
          "signature": "(e-\u003ee-\u003ee)-\u003eAVL e-\u003ee",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:foldr1AVL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis name is \u003cem\u003edeprecated\u003c/em\u003e. Instead use \u003ccode\u003e\u003ca\u003efoldr1'\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "foldr1AVL'",
          "package": "AvlTree",
          "signature": "(e -\u003e e -\u003e e) -\u003e AVL e -\u003e e",
          "source": "src/Data-Tree-AVL-Deprecated.html#foldr1AVL%27",
          "type": "function"
        },
        "index": {
          "description": "This name is deprecated Instead use foldr1",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "foldr1AVL'",
          "normalized": "(a-\u003ea-\u003ea)-\u003eAVL a-\u003ea",
          "package": "AvlTree",
          "partial": "AVL'",
          "signature": "(e-\u003ee-\u003ee)-\u003eAVL e-\u003ee",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:foldr1AVL-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis fold is a hybrid between \u003ccode\u003e\u003ca\u003efoldr\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003efoldr1\u003c/a\u003e\u003c/code\u003e. As with \u003ccode\u003e\u003ca\u003efoldr1\u003c/a\u003e\u003c/code\u003e, it requires\n a non-empty tree, but instead of treating the rightmost element as an initial value, it applies\n a function to it (second function argument) and uses the result instead. This allows\n a more flexible type for the main folding function (same type as that used by \u003ccode\u003e\u003ca\u003efoldr\u003c/a\u003e\u003c/code\u003e).\n As with \u003ccode\u003e\u003ca\u003efoldr\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003efoldr1\u003c/a\u003e\u003c/code\u003e, this function is lazy, so it's best not to use it with functions\n that are strict in their second argument. See \u003ccode\u003e\u003ca\u003efoldr2'\u003c/a\u003e\u003c/code\u003e for a strict version.\n\u003c/p\u003e\u003cp\u003eComplexity: O(n)\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "foldr2",
          "package": "AvlTree",
          "signature": "(e -\u003e a -\u003e a) -\u003e (e -\u003e a) -\u003e AVL e -\u003e a",
          "source": "src/Data-Tree-AVL-List.html#foldr2",
          "type": "function"
        },
        "index": {
          "description": "This fold is hybrid between foldr and foldr1 As with foldr1 it requires non-empty tree but instead of treating the rightmost element as an initial value it applies function to it second function argument and uses the result instead This allows more flexible type for the main folding function same type as that used by foldr As with foldr and foldr1 this function is lazy so it best not to use it with functions that are strict in their second argument See foldr2 for strict version Complexity",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "foldr2",
          "normalized": "(a-\u003eb-\u003eb)-\u003e(a-\u003eb)-\u003eAVL a-\u003eb",
          "package": "AvlTree",
          "signature": "(e-\u003ea-\u003ea)-\u003e(e-\u003ea)-\u003eAVL e-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:foldr2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe strict version of \u003ccode\u003e\u003ca\u003efoldr2\u003c/a\u003e\u003c/code\u003e, which is useful for functions which are strict in their second\n argument. The advantage of this version is that it reduces the stack use from the O(n) that the lazy\n version gives (when used with strict functions) to O(log n).\n\u003c/p\u003e\u003cp\u003eComplexity: O(n)\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "foldr2'",
          "package": "AvlTree",
          "signature": "(e -\u003e a -\u003e a) -\u003e (e -\u003e a) -\u003e AVL e -\u003e a",
          "source": "src/Data-Tree-AVL-List.html#foldr2%27",
          "type": "function"
        },
        "index": {
          "description": "The strict version of foldr2 which is useful for functions which are strict in their second argument The advantage of this version is that it reduces the stack use from the that the lazy version gives when used with strict functions to log Complexity",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "foldr2'",
          "normalized": "(a-\u003eb-\u003eb)-\u003e(a-\u003eb)-\u003eAVL a-\u003eb",
          "package": "AvlTree",
          "signature": "(e-\u003ea-\u003ea)-\u003e(e-\u003ea)-\u003eAVL e-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:foldr2-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis name is \u003cem\u003edeprecated\u003c/em\u003e. Instead use \u003ccode\u003e\u003ca\u003efoldr2\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "foldr2AVL",
          "package": "AvlTree",
          "signature": "(e -\u003e a -\u003e a) -\u003e (e -\u003e a) -\u003e AVL e -\u003e a",
          "source": "src/Data-Tree-AVL-Deprecated.html#foldr2AVL",
          "type": "function"
        },
        "index": {
          "description": "This name is deprecated Instead use foldr2",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "foldr2AVL",
          "normalized": "(a-\u003eb-\u003eb)-\u003e(a-\u003eb)-\u003eAVL a-\u003eb",
          "package": "AvlTree",
          "partial": "AVL",
          "signature": "(e-\u003ea-\u003ea)-\u003e(e-\u003ea)-\u003eAVL e-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:foldr2AVL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis name is \u003cem\u003edeprecated\u003c/em\u003e. Instead use \u003ccode\u003e\u003ca\u003efoldr2'\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "foldr2AVL'",
          "package": "AvlTree",
          "signature": "(e -\u003e a -\u003e a) -\u003e (e -\u003e a) -\u003e AVL e -\u003e a",
          "source": "src/Data-Tree-AVL-Deprecated.html#foldr2AVL%27",
          "type": "function"
        },
        "index": {
          "description": "This name is deprecated Instead use foldr2",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "foldr2AVL'",
          "normalized": "(a-\u003eb-\u003eb)-\u003e(a-\u003eb)-\u003eAVL a-\u003eb",
          "package": "AvlTree",
          "partial": "AVL'",
          "signature": "(e-\u003ea-\u003ea)-\u003e(e-\u003ea)-\u003eAVL e-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:foldr2AVL-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis name is \u003cem\u003edeprecated\u003c/em\u003e. Instead use \u003ccode\u003e\u003ca\u003efoldr\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "foldrAVL",
          "package": "AvlTree",
          "signature": "(e -\u003e a -\u003e a) -\u003e a -\u003e AVL e -\u003e a",
          "source": "src/Data-Tree-AVL-Deprecated.html#foldrAVL",
          "type": "function"
        },
        "index": {
          "description": "This name is deprecated Instead use foldr",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "foldrAVL",
          "normalized": "(a-\u003eb-\u003eb)-\u003eb-\u003eAVL a-\u003eb",
          "package": "AvlTree",
          "partial": "AVL",
          "signature": "(e-\u003ea-\u003ea)-\u003ea-\u003eAVL e-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:foldrAVL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis name is \u003cem\u003edeprecated\u003c/em\u003e. Instead use \u003ccode\u003e\u003ca\u003efoldr'\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "foldrAVL'",
          "package": "AvlTree",
          "signature": "(e -\u003e a -\u003e a) -\u003e a -\u003e AVL e -\u003e a",
          "source": "src/Data-Tree-AVL-Deprecated.html#foldrAVL%27",
          "type": "function"
        },
        "index": {
          "description": "This name is deprecated Instead use foldr",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "foldrAVL'",
          "normalized": "(a-\u003eb-\u003eb)-\u003eb-\u003eAVL a-\u003eb",
          "package": "AvlTree",
          "partial": "AVL'",
          "signature": "(e-\u003ea-\u003ea)-\u003ea-\u003eAVL e-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:foldrAVL-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis name is \u003cem\u003edeprecated\u003c/em\u003e. Instead use \u003ccode\u003e\u003ca\u003efoldrInt#\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "foldrAVL_UINT",
          "package": "AvlTree",
          "signature": "(e -\u003e Int# -\u003e Int#) -\u003e Int# -\u003e AVL e -\u003e Int#",
          "source": "src/Data-Tree-AVL-Deprecated.html#foldrAVL_UINT",
          "type": "function"
        },
        "index": {
          "description": "This name is deprecated Instead use foldrInt",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "foldrAVL_UINT",
          "normalized": "(a-\u003eInt #-\u003eInt #)-\u003eInt #-\u003eAVL a-\u003eInt #",
          "package": "AvlTree",
          "partial": "AVL UINT",
          "signature": "(e-\u003eInt #-\u003eInt #)-\u003eInt #-\u003eAVL e-\u003eInt #",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:foldrAVL_UINT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis is a specialised version of \u003ccode\u003e\u003ca\u003efoldr'\u003c/a\u003e\u003c/code\u003e for use with an\n \u003cem\u003eunboxed\u003c/em\u003e Int accumulator.\n\u003c/p\u003e\u003cp\u003eComplexity: O(n)\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "foldrInt#",
          "package": "AvlTree",
          "signature": "(e -\u003e Int# -\u003e Int#) -\u003e Int# -\u003e AVL e -\u003e Int#",
          "source": "src/Data-Tree-AVL-List.html#foldrInt%23",
          "type": "function"
        },
        "index": {
          "description": "This is specialised version of foldr for use with an unboxed Int accumulator Complexity",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "foldrInt#",
          "normalized": "(a-\u003eInt #-\u003eInt #)-\u003eInt #-\u003eAVL a-\u003eInt #",
          "package": "AvlTree",
          "partial": "Int",
          "signature": "(e-\u003eInt #-\u003eInt #)-\u003eInt #-\u003eAVL e-\u003eInt #",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:foldrInt-35-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSimilar to \u003ccode\u003e\u003ca\u003eforkL\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003eforkR\u003c/a\u003e\u003c/code\u003e, but returns any equal element found (instead of\n incorporating it into the left or right tree results respectively).\n\u003c/p\u003e\u003cp\u003eComplexity: O(log n)\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "fork",
          "package": "AvlTree",
          "signature": "(e -\u003e COrdering a) -\u003e AVL e -\u003e (AVL e, Maybe a, AVL e)",
          "source": "src/Data-Tree-AVL-Split.html#fork",
          "type": "function"
        },
        "index": {
          "description": "Similar to forkL and forkR but returns any equal element found instead of incorporating it into the left or right tree results respectively Complexity log",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "fork",
          "normalized": "(a-\u003eCOrdering b)-\u003eAVL a-\u003e(AVL a,Maybe b,AVL a)",
          "package": "AvlTree",
          "signature": "(e-\u003eCOrdering a)-\u003eAVL e-\u003e(AVL e,Maybe a,AVL e)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:fork"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDivide a sorted AVL tree into left and right sorted trees (l,r), such that l contains all the\n elements less than or equal to according to the supplied selector and r contains all the elements greater than\n according to the supplied selector.\n\u003c/p\u003e\u003cp\u003eComplexity: O(log n)\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "forkL",
          "package": "AvlTree",
          "signature": "(e -\u003e Ordering) -\u003e AVL e -\u003e (AVL e, AVL e)",
          "source": "src/Data-Tree-AVL-Split.html#forkL",
          "type": "function"
        },
        "index": {
          "description": "Divide sorted AVL tree into left and right sorted trees such that contains all the elements less than or equal to according to the supplied selector and contains all the elements greater than according to the supplied selector Complexity log",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "forkL",
          "normalized": "(a-\u003eOrdering)-\u003eAVL a-\u003e(AVL a,AVL a)",
          "package": "AvlTree",
          "signature": "(e-\u003eOrdering)-\u003eAVL e-\u003e(AVL e,AVL e)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:forkL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDivide a sorted AVL tree into left and right sorted trees (l,r), such that l contains all the\n elements less than supplied selector and r contains all the elements greater than or equal to the\n supplied selector.\n\u003c/p\u003e\u003cp\u003eComplexity: O(log n)\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "forkR",
          "package": "AvlTree",
          "signature": "(e -\u003e Ordering) -\u003e AVL e -\u003e (AVL e, AVL e)",
          "source": "src/Data-Tree-AVL-Split.html#forkR",
          "type": "function"
        },
        "index": {
          "description": "Divide sorted AVL tree into left and right sorted trees such that contains all the elements less than supplied selector and contains all the elements greater than or equal to the supplied selector Complexity log",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "forkR",
          "normalized": "(a-\u003eOrdering)-\u003eAVL a-\u003e(AVL a,AVL a)",
          "package": "AvlTree",
          "signature": "(e-\u003eOrdering)-\u003eAVL e-\u003e(AVL e,AVL e)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:forkR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturns \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e if the \u003ccode\u003e\u003ca\u003eBAVL\u003c/a\u003e\u003c/code\u003e is \"full\" (a corresponding element was found).\n\u003c/p\u003e\u003cp\u003eComplexity: O(1)\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "fullBAVL",
          "package": "AvlTree",
          "signature": "BAVL e -\u003e Bool",
          "source": "src/Data-Tree-AVL-Zipper.html#fullBAVL",
          "type": "function"
        },
        "index": {
          "description": "Returns True if the BAVL is full corresponding element was found Complexity",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "fullBAVL",
          "normalized": "BAVL a-\u003eBool",
          "package": "AvlTree",
          "partial": "BAVL",
          "signature": "BAVL e-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:fullBAVL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConverts a \"full\" \u003ccode\u003e\u003ca\u003eBAVL\u003c/a\u003e\u003c/code\u003e as a \u003ccode\u003e\u003ca\u003eZAVL\u003c/a\u003e\u003c/code\u003e. Raises an error if applied to an \"empty\" \u003ccode\u003e\u003ca\u003eBAVL\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eComplexity: O(log n)\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "fullBAVLtoZAVL",
          "package": "AvlTree",
          "signature": "BAVL e -\u003e ZAVL e",
          "source": "src/Data-Tree-AVL-Zipper.html#fullBAVLtoZAVL",
          "type": "function"
        },
        "index": {
          "description": "Converts full BAVL as ZAVL Raises an error if applied to an empty BAVL Complexity log",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "fullBAVLtoZAVL",
          "normalized": "BAVL a-\u003eZAVL a",
          "package": "AvlTree",
          "partial": "BAVLto ZAVL",
          "signature": "BAVL e-\u003eZAVL e",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:fullBAVLtoZAVL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis name is \u003cem\u003edeprecated\u003c/em\u003e. Instead use \u003ccode\u003e\u003ca\u003easTree\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "genAsTree",
          "package": "AvlTree",
          "signature": "(e -\u003e e -\u003e COrdering e) -\u003e [e] -\u003e AVL e",
          "source": "src/Data-Tree-AVL-Deprecated.html#genAsTree",
          "type": "function"
        },
        "index": {
          "description": "This name is deprecated Instead use asTree",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "genAsTree",
          "normalized": "(a-\u003ea-\u003eCOrdering a)-\u003e[a]-\u003eAVL a",
          "package": "AvlTree",
          "partial": "As Tree",
          "signature": "(e-\u003ee-\u003eCOrdering e)-\u003e[e]-\u003eAVL e",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:genAsTree"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis name is \u003cem\u003edeprecated\u003c/em\u003e. Instead use \u003ccode\u003e\u003ca\u003eassertOpen\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "genAssertOpen",
          "package": "AvlTree",
          "signature": "(e -\u003e Ordering) -\u003e AVL e -\u003e ZAVL e",
          "source": "src/Data-Tree-AVL-Deprecated.html#genAssertOpen",
          "type": "function"
        },
        "index": {
          "description": "This name is deprecated Instead use assertOpen",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "genAssertOpen",
          "normalized": "(a-\u003eOrdering)-\u003eAVL a-\u003eZAVL a",
          "package": "AvlTree",
          "partial": "Assert Open",
          "signature": "(e-\u003eOrdering)-\u003eAVL e-\u003eZAVL e",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:genAssertOpen"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis name is \u003cem\u003edeprecated\u003c/em\u003e. Instead use \u003ccode\u003e\u003ca\u003eassertPop\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "genAssertPop",
          "package": "AvlTree",
          "signature": "(e -\u003e COrdering a) -\u003e AVL e -\u003e (a, AVL e)",
          "source": "src/Data-Tree-AVL-Deprecated.html#genAssertPop",
          "type": "function"
        },
        "index": {
          "description": "This name is deprecated Instead use assertPop",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "genAssertPop",
          "normalized": "(a-\u003eCOrdering b)-\u003eAVL a-\u003e(b,AVL a)",
          "package": "AvlTree",
          "partial": "Assert Pop",
          "signature": "(e-\u003eCOrdering a)-\u003eAVL e-\u003e(a,AVL e)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:genAssertPop"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis name is \u003cem\u003edeprecated\u003c/em\u003e. Instead use \u003ccode\u003e\u003ca\u003eassertPopIf\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "genAssertPopIf",
          "package": "AvlTree",
          "signature": "(e -\u003e COrdering (a, Bool)) -\u003e AVL e -\u003e (a, AVL e)",
          "source": "src/Data-Tree-AVL-Deprecated.html#genAssertPopIf",
          "type": "function"
        },
        "index": {
          "description": "This name is deprecated Instead use assertPopIf",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "genAssertPopIf",
          "normalized": "(a-\u003eCOrdering(b,Bool))-\u003eAVL a-\u003e(b,AVL a)",
          "package": "AvlTree",
          "partial": "Assert Pop If",
          "signature": "(e-\u003eCOrdering(a,Bool))-\u003eAVL e-\u003e(a,AVL e)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:genAssertPopIf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis name is \u003cem\u003edeprecated\u003c/em\u003e. Instead use \u003ccode\u003e\u003ca\u003eassertPopMaybe\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "genAssertPopMaybe",
          "package": "AvlTree",
          "signature": "(e -\u003e COrdering (a, Maybe e)) -\u003e AVL e -\u003e (a, AVL e)",
          "source": "src/Data-Tree-AVL-Deprecated.html#genAssertPopMaybe",
          "type": "function"
        },
        "index": {
          "description": "This name is deprecated Instead use assertPopMaybe",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "genAssertPopMaybe",
          "normalized": "(a-\u003eCOrdering(b,Maybe a))-\u003eAVL a-\u003e(b,AVL a)",
          "package": "AvlTree",
          "partial": "Assert Pop Maybe",
          "signature": "(e-\u003eCOrdering(a,Maybe e))-\u003eAVL e-\u003e(a,AVL e)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:genAssertPopMaybe"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis name is \u003cem\u003edeprecated\u003c/em\u003e. Instead use \u003ccode\u003e\u003ca\u003eassertRead\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "genAssertRead",
          "package": "AvlTree",
          "signature": "AVL e -\u003e (e -\u003e COrdering a) -\u003e a",
          "source": "src/Data-Tree-AVL-Deprecated.html#genAssertRead",
          "type": "function"
        },
        "index": {
          "description": "This name is deprecated Instead use assertRead",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "genAssertRead",
          "normalized": "AVL a-\u003e(a-\u003eCOrdering b)-\u003eb",
          "package": "AvlTree",
          "partial": "Assert Read",
          "signature": "AVL e-\u003e(e-\u003eCOrdering a)-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:genAssertRead"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis name is \u003cem\u003edeprecated\u003c/em\u003e. Instead use \u003ccode\u003e\u003ca\u003econtains\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "genContains",
          "package": "AvlTree",
          "signature": "AVL e -\u003e (e -\u003e Ordering) -\u003e Bool",
          "source": "src/Data-Tree-AVL-Deprecated.html#genContains",
          "type": "function"
        },
        "index": {
          "description": "This name is deprecated Instead use contains",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "genContains",
          "normalized": "AVL a-\u003e(a-\u003eOrdering)-\u003eBool",
          "package": "AvlTree",
          "partial": "Contains",
          "signature": "AVL e-\u003e(e-\u003eOrdering)-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:genContains"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis name is \u003cem\u003edeprecated\u003c/em\u003e. Instead use \u003ccode\u003e\u003ca\u003edefaultRead\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "genDefaultRead",
          "package": "AvlTree",
          "signature": "a -\u003e AVL e -\u003e (e -\u003e COrdering a) -\u003e a",
          "source": "src/Data-Tree-AVL-Deprecated.html#genDefaultRead",
          "type": "function"
        },
        "index": {
          "description": "This name is deprecated Instead use defaultRead",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "genDefaultRead",
          "normalized": "a-\u003eAVL b-\u003e(b-\u003eCOrdering a)-\u003ea",
          "package": "AvlTree",
          "partial": "Default Read",
          "signature": "a-\u003eAVL e-\u003e(e-\u003eCOrdering a)-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:genDefaultRead"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis name is \u003cem\u003edeprecated\u003c/em\u003e. Instead use \u003ccode\u003e\u003ca\u003edelete\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "genDel",
          "package": "AvlTree",
          "signature": "(e -\u003e Ordering) -\u003e AVL e -\u003e AVL e",
          "source": "src/Data-Tree-AVL-Deprecated.html#genDel",
          "type": "function"
        },
        "index": {
          "description": "This name is deprecated Instead use delete",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "genDel",
          "normalized": "(a-\u003eOrdering)-\u003eAVL a-\u003eAVL a",
          "package": "AvlTree",
          "partial": "Del",
          "signature": "(e-\u003eOrdering)-\u003eAVL e-\u003eAVL e",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:genDel"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis name is \u003cem\u003edeprecated\u003c/em\u003e. Instead use \u003ccode\u003e\u003ca\u003edeleteFast\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "genDelFast",
          "package": "AvlTree",
          "signature": "(e -\u003e Ordering) -\u003e AVL e -\u003e AVL e",
          "source": "src/Data-Tree-AVL-Deprecated.html#genDelFast",
          "type": "function"
        },
        "index": {
          "description": "This name is deprecated Instead use deleteFast",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "genDelFast",
          "normalized": "(a-\u003eOrdering)-\u003eAVL a-\u003eAVL a",
          "package": "AvlTree",
          "partial": "Del Fast",
          "signature": "(e-\u003eOrdering)-\u003eAVL e-\u003eAVL e",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:genDelFast"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis name is \u003cem\u003edeprecated\u003c/em\u003e. Instead use \u003ccode\u003e\u003ca\u003edeleteIf\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "genDelIf",
          "package": "AvlTree",
          "signature": "(e -\u003e COrdering Bool) -\u003e AVL e -\u003e AVL e",
          "source": "src/Data-Tree-AVL-Deprecated.html#genDelIf",
          "type": "function"
        },
        "index": {
          "description": "This name is deprecated Instead use deleteIf",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "genDelIf",
          "normalized": "(a-\u003eCOrdering Bool)-\u003eAVL a-\u003eAVL a",
          "package": "AvlTree",
          "partial": "Del If",
          "signature": "(e-\u003eCOrdering Bool)-\u003eAVL e-\u003eAVL e",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:genDelIf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis name is \u003cem\u003edeprecated\u003c/em\u003e. Instead use \u003ccode\u003e\u003ca\u003edeleteMaybe\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "genDelMaybe",
          "package": "AvlTree",
          "signature": "(e -\u003e COrdering (Maybe e)) -\u003e AVL e -\u003e AVL e",
          "source": "src/Data-Tree-AVL-Deprecated.html#genDelMaybe",
          "type": "function"
        },
        "index": {
          "description": "This name is deprecated Instead use deleteMaybe",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "genDelMaybe",
          "normalized": "(a-\u003eCOrdering(Maybe a))-\u003eAVL a-\u003eAVL a",
          "package": "AvlTree",
          "partial": "Del Maybe",
          "signature": "(e-\u003eCOrdering(Maybe e))-\u003eAVL e-\u003eAVL e",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:genDelMaybe"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis name is \u003cem\u003edeprecated\u003c/em\u003e. Instead use \u003ccode\u003e\u003ca\u003edifference\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "genDifference",
          "package": "AvlTree",
          "signature": "(a -\u003e b -\u003e Ordering) -\u003e AVL a -\u003e AVL b -\u003e AVL a",
          "source": "src/Data-Tree-AVL-Deprecated.html#genDifference",
          "type": "function"
        },
        "index": {
          "description": "This name is deprecated Instead use difference",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "genDifference",
          "normalized": "(a-\u003eb-\u003eOrdering)-\u003eAVL a-\u003eAVL b-\u003eAVL a",
          "package": "AvlTree",
          "partial": "Difference",
          "signature": "(a-\u003eb-\u003eOrdering)-\u003eAVL a-\u003eAVL b-\u003eAVL a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:genDifference"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis name is \u003cem\u003edeprecated\u003c/em\u003e. Instead use \u003ccode\u003e\u003ca\u003edifferenceMaybe\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "genDifferenceMaybe",
          "package": "AvlTree",
          "signature": "(a -\u003e b -\u003e COrdering (Maybe a)) -\u003e AVL a -\u003e AVL b -\u003e AVL a",
          "source": "src/Data-Tree-AVL-Deprecated.html#genDifferenceMaybe",
          "type": "function"
        },
        "index": {
          "description": "This name is deprecated Instead use differenceMaybe",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "genDifferenceMaybe",
          "normalized": "(a-\u003eb-\u003eCOrdering(Maybe a))-\u003eAVL a-\u003eAVL b-\u003eAVL a",
          "package": "AvlTree",
          "partial": "Difference Maybe",
          "signature": "(a-\u003eb-\u003eCOrdering(Maybe a))-\u003eAVL a-\u003eAVL b-\u003eAVL a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:genDifferenceMaybe"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis name is \u003cem\u003edeprecated\u003c/em\u003e. Instead use \u003ccode\u003e\u003ca\u003edisjointUnion\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "genDisjointUnion",
          "package": "AvlTree",
          "signature": "(e -\u003e e -\u003e Ordering) -\u003e AVL e -\u003e AVL e -\u003e AVL e",
          "source": "src/Data-Tree-AVL-Deprecated.html#genDisjointUnion",
          "type": "function"
        },
        "index": {
          "description": "This name is deprecated Instead use disjointUnion",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "genDisjointUnion",
          "normalized": "(a-\u003ea-\u003eOrdering)-\u003eAVL a-\u003eAVL a-\u003eAVL a",
          "package": "AvlTree",
          "partial": "Disjoint Union",
          "signature": "(e-\u003ee-\u003eOrdering)-\u003eAVL e-\u003eAVL e-\u003eAVL e",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:genDisjointUnion"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis name is \u003cem\u003edeprecated\u003c/em\u003e. Instead use \u003ccode\u003e\u003ca\u003edropGE\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "genDropGE",
          "package": "AvlTree",
          "signature": "(e -\u003e Ordering) -\u003e AVL e -\u003e AVL e",
          "source": "src/Data-Tree-AVL-Deprecated.html#genDropGE",
          "type": "function"
        },
        "index": {
          "description": "This name is deprecated Instead use dropGE",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "genDropGE",
          "normalized": "(a-\u003eOrdering)-\u003eAVL a-\u003eAVL a",
          "package": "AvlTree",
          "partial": "Drop GE",
          "signature": "(e-\u003eOrdering)-\u003eAVL e-\u003eAVL e",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:genDropGE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis name is \u003cem\u003edeprecated\u003c/em\u003e. Instead use \u003ccode\u003e\u003ca\u003edropGT\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "genDropGT",
          "package": "AvlTree",
          "signature": "(e -\u003e Ordering) -\u003e AVL e -\u003e AVL e",
          "source": "src/Data-Tree-AVL-Deprecated.html#genDropGT",
          "type": "function"
        },
        "index": {
          "description": "This name is deprecated Instead use dropGT",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "genDropGT",
          "normalized": "(a-\u003eOrdering)-\u003eAVL a-\u003eAVL a",
          "package": "AvlTree",
          "partial": "Drop GT",
          "signature": "(e-\u003eOrdering)-\u003eAVL e-\u003eAVL e",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:genDropGT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis name is \u003cem\u003edeprecated\u003c/em\u003e. Instead use \u003ccode\u003e\u003ca\u003edropLE\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "genDropLE",
          "package": "AvlTree",
          "signature": "(e -\u003e Ordering) -\u003e AVL e -\u003e AVL e",
          "source": "src/Data-Tree-AVL-Deprecated.html#genDropLE",
          "type": "function"
        },
        "index": {
          "description": "This name is deprecated Instead use dropLE",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "genDropLE",
          "normalized": "(a-\u003eOrdering)-\u003eAVL a-\u003eAVL a",
          "package": "AvlTree",
          "partial": "Drop LE",
          "signature": "(e-\u003eOrdering)-\u003eAVL e-\u003eAVL e",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:genDropLE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis name is \u003cem\u003edeprecated\u003c/em\u003e. Instead use \u003ccode\u003e\u003ca\u003edropLT\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "genDropLT",
          "package": "AvlTree",
          "signature": "(e -\u003e Ordering) -\u003e AVL e -\u003e AVL e",
          "source": "src/Data-Tree-AVL-Deprecated.html#genDropLT",
          "type": "function"
        },
        "index": {
          "description": "This name is deprecated Instead use dropLT",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "genDropLT",
          "normalized": "(a-\u003eOrdering)-\u003eAVL a-\u003eAVL a",
          "package": "AvlTree",
          "partial": "Drop LT",
          "signature": "(e-\u003eOrdering)-\u003eAVL e-\u003eAVL e",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:genDropLT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis name is \u003cem\u003edeprecated\u003c/em\u003e. Instead use \u003ccode\u003e\u003ca\u003efindPath\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "genFindPath",
          "package": "AvlTree",
          "signature": "(e -\u003e Ordering) -\u003e AVL e -\u003e Int#",
          "source": "src/Data-Tree-AVL-Deprecated.html#genFindPath",
          "type": "function"
        },
        "index": {
          "description": "This name is deprecated Instead use findPath",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "genFindPath",
          "normalized": "(a-\u003eOrdering)-\u003eAVL a-\u003eInt #",
          "package": "AvlTree",
          "partial": "Find Path",
          "signature": "(e-\u003eOrdering)-\u003eAVL e-\u003eInt #",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:genFindPath"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis name is \u003cem\u003edeprecated\u003c/em\u003e. Instead use \u003ccode\u003e\u003ca\u003efork\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "genFork",
          "package": "AvlTree",
          "signature": "(e -\u003e COrdering a) -\u003e AVL e -\u003e (AVL e, Maybe a, AVL e)",
          "source": "src/Data-Tree-AVL-Deprecated.html#genFork",
          "type": "function"
        },
        "index": {
          "description": "This name is deprecated Instead use fork",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "genFork",
          "normalized": "(a-\u003eCOrdering b)-\u003eAVL a-\u003e(AVL a,Maybe b,AVL a)",
          "package": "AvlTree",
          "partial": "Fork",
          "signature": "(e-\u003eCOrdering a)-\u003eAVL e-\u003e(AVL e,Maybe a,AVL e)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:genFork"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis name is \u003cem\u003edeprecated\u003c/em\u003e. Instead use \u003ccode\u003e\u003ca\u003eforkL\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "genForkL",
          "package": "AvlTree",
          "signature": "(e -\u003e Ordering) -\u003e AVL e -\u003e (AVL e, AVL e)",
          "source": "src/Data-Tree-AVL-Deprecated.html#genForkL",
          "type": "function"
        },
        "index": {
          "description": "This name is deprecated Instead use forkL",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "genForkL",
          "normalized": "(a-\u003eOrdering)-\u003eAVL a-\u003e(AVL a,AVL a)",
          "package": "AvlTree",
          "partial": "Fork",
          "signature": "(e-\u003eOrdering)-\u003eAVL e-\u003e(AVL e,AVL e)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:genForkL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis name is \u003cem\u003edeprecated\u003c/em\u003e. Instead use \u003ccode\u003e\u003ca\u003eforkR\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "genForkR",
          "package": "AvlTree",
          "signature": "(e -\u003e Ordering) -\u003e AVL e -\u003e (AVL e, AVL e)",
          "source": "src/Data-Tree-AVL-Deprecated.html#genForkR",
          "type": "function"
        },
        "index": {
          "description": "This name is deprecated Instead use forkR",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "genForkR",
          "normalized": "(a-\u003eOrdering)-\u003eAVL a-\u003e(AVL a,AVL a)",
          "package": "AvlTree",
          "partial": "Fork",
          "signature": "(e-\u003eOrdering)-\u003eAVL e-\u003e(AVL e,AVL e)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:genForkR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis name is \u003cem\u003edeprecated\u003c/em\u003e. Instead use \u003ccode\u003e\u003ca\u003eintersection\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "genIntersection",
          "package": "AvlTree",
          "signature": "(a -\u003e b -\u003e COrdering c) -\u003e AVL a -\u003e AVL b -\u003e AVL c",
          "source": "src/Data-Tree-AVL-Deprecated.html#genIntersection",
          "type": "function"
        },
        "index": {
          "description": "This name is deprecated Instead use intersection",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "genIntersection",
          "normalized": "(a-\u003eb-\u003eCOrdering c)-\u003eAVL a-\u003eAVL b-\u003eAVL c",
          "package": "AvlTree",
          "partial": "Intersection",
          "signature": "(a-\u003eb-\u003eCOrdering c)-\u003eAVL a-\u003eAVL b-\u003eAVL c",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:genIntersection"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis name is \u003cem\u003edeprecated\u003c/em\u003e. Instead use \u003ccode\u003e\u003ca\u003eintersectionAsList\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "genIntersectionAsListL",
          "package": "AvlTree",
          "signature": "(a -\u003e b -\u003e COrdering c) -\u003e AVL a -\u003e AVL b -\u003e [c]",
          "source": "src/Data-Tree-AVL-Deprecated.html#genIntersectionAsListL",
          "type": "function"
        },
        "index": {
          "description": "This name is deprecated Instead use intersectionAsList",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "genIntersectionAsListL",
          "normalized": "(a-\u003eb-\u003eCOrdering c)-\u003eAVL a-\u003eAVL b-\u003e[c]",
          "package": "AvlTree",
          "partial": "Intersection As List",
          "signature": "(a-\u003eb-\u003eCOrdering c)-\u003eAVL a-\u003eAVL b-\u003e[c]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:genIntersectionAsListL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis name is \u003cem\u003edeprecated\u003c/em\u003e. Instead use \u003ccode\u003e\u003ca\u003eintersectionMaybe\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "genIntersectionMaybe",
          "package": "AvlTree",
          "signature": "(a -\u003e b -\u003e COrdering (Maybe c)) -\u003e AVL a -\u003e AVL b -\u003e AVL c",
          "source": "src/Data-Tree-AVL-Deprecated.html#genIntersectionMaybe",
          "type": "function"
        },
        "index": {
          "description": "This name is deprecated Instead use intersectionMaybe",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "genIntersectionMaybe",
          "normalized": "(a-\u003eb-\u003eCOrdering(Maybe c))-\u003eAVL a-\u003eAVL b-\u003eAVL c",
          "package": "AvlTree",
          "partial": "Intersection Maybe",
          "signature": "(a-\u003eb-\u003eCOrdering(Maybe c))-\u003eAVL a-\u003eAVL b-\u003eAVL c",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:genIntersectionMaybe"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis name is \u003cem\u003edeprecated\u003c/em\u003e. Instead use \u003ccode\u003e\u003ca\u003eintersectionMaybeAsList\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "genIntersectionMaybeAsListL",
          "package": "AvlTree",
          "signature": "(a -\u003e b -\u003e COrdering (Maybe c)) -\u003e AVL a -\u003e AVL b -\u003e [c]",
          "source": "src/Data-Tree-AVL-Deprecated.html#genIntersectionMaybeAsListL",
          "type": "function"
        },
        "index": {
          "description": "This name is deprecated Instead use intersectionMaybeAsList",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "genIntersectionMaybeAsListL",
          "normalized": "(a-\u003eb-\u003eCOrdering(Maybe c))-\u003eAVL a-\u003eAVL b-\u003e[c]",
          "package": "AvlTree",
          "partial": "Intersection Maybe As List",
          "signature": "(a-\u003eb-\u003eCOrdering(Maybe c))-\u003eAVL a-\u003eAVL b-\u003e[c]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:genIntersectionMaybeAsListL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis name is \u003cem\u003edeprecated\u003c/em\u003e. Instead use \u003ccode\u003e\u003ca\u003eintersectionMaybeToList\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "genIntersectionMaybeToListL",
          "package": "AvlTree",
          "signature": "(a -\u003e b -\u003e COrdering (Maybe c)) -\u003e AVL a -\u003e AVL b -\u003e [c] -\u003e [c]",
          "source": "src/Data-Tree-AVL-Deprecated.html#genIntersectionMaybeToListL",
          "type": "function"
        },
        "index": {
          "description": "This name is deprecated Instead use intersectionMaybeToList",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "genIntersectionMaybeToListL",
          "normalized": "(a-\u003eb-\u003eCOrdering(Maybe c))-\u003eAVL a-\u003eAVL b-\u003e[c]-\u003e[c]",
          "package": "AvlTree",
          "partial": "Intersection Maybe To List",
          "signature": "(a-\u003eb-\u003eCOrdering(Maybe c))-\u003eAVL a-\u003eAVL b-\u003e[c]-\u003e[c]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:genIntersectionMaybeToListL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis name is \u003cem\u003edeprecated\u003c/em\u003e. Instead use \u003ccode\u003e\u003ca\u003eintersectionToList\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "genIntersectionToListL",
          "package": "AvlTree",
          "signature": "(a -\u003e b -\u003e COrdering c) -\u003e AVL a -\u003e AVL b -\u003e [c] -\u003e [c]",
          "source": "src/Data-Tree-AVL-Deprecated.html#genIntersectionToListL",
          "type": "function"
        },
        "index": {
          "description": "This name is deprecated Instead use intersectionToList",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "genIntersectionToListL",
          "normalized": "(a-\u003eb-\u003eCOrdering c)-\u003eAVL a-\u003eAVL b-\u003e[c]-\u003e[c]",
          "package": "AvlTree",
          "partial": "Intersection To List",
          "signature": "(a-\u003eb-\u003eCOrdering c)-\u003eAVL a-\u003eAVL b-\u003e[c]-\u003e[c]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:genIntersectionToListL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis name is \u003cem\u003edeprecated\u003c/em\u003e. Instead use \u003ccode\u003e\u003ca\u003eisSubsetOf\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "genIsSubsetOf",
          "package": "AvlTree",
          "signature": "(a -\u003e b -\u003e Ordering) -\u003e AVL a -\u003e AVL b -\u003e Bool",
          "source": "src/Data-Tree-AVL-Deprecated.html#genIsSubsetOf",
          "type": "function"
        },
        "index": {
          "description": "This name is deprecated Instead use isSubsetOf",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "genIsSubsetOf",
          "normalized": "(a-\u003eb-\u003eOrdering)-\u003eAVL a-\u003eAVL b-\u003eBool",
          "package": "AvlTree",
          "partial": "Is Subset Of",
          "signature": "(a-\u003eb-\u003eOrdering)-\u003eAVL a-\u003eAVL b-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:genIsSubsetOf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis name is \u003cem\u003edeprecated\u003c/em\u003e. Instead use \u003ccode\u003e\u003ca\u003eisSubsetOfBy\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "genIsSubsetOfBy",
          "package": "AvlTree",
          "signature": "(a -\u003e b -\u003e COrdering Bool) -\u003e AVL a -\u003e AVL b -\u003e Bool",
          "source": "src/Data-Tree-AVL-Deprecated.html#genIsSubsetOfBy",
          "type": "function"
        },
        "index": {
          "description": "This name is deprecated Instead use isSubsetOfBy",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "genIsSubsetOfBy",
          "normalized": "(a-\u003eb-\u003eCOrdering Bool)-\u003eAVL a-\u003eAVL b-\u003eBool",
          "package": "AvlTree",
          "partial": "Is Subset Of By",
          "signature": "(a-\u003eb-\u003eCOrdering Bool)-\u003eAVL a-\u003eAVL b-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:genIsSubsetOfBy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis name is \u003cem\u003edeprecated\u003c/em\u003e. Instead use \u003ccode\u003e\u003ca\u003eopenBAVL\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "genOpenBAVL",
          "package": "AvlTree",
          "signature": "(e -\u003e Ordering) -\u003e AVL e -\u003e BAVL e",
          "source": "src/Data-Tree-AVL-Deprecated.html#genOpenBAVL",
          "type": "function"
        },
        "index": {
          "description": "This name is deprecated Instead use openBAVL",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "genOpenBAVL",
          "normalized": "(a-\u003eOrdering)-\u003eAVL a-\u003eBAVL a",
          "package": "AvlTree",
          "partial": "Open BAVL",
          "signature": "(e-\u003eOrdering)-\u003eAVL e-\u003eBAVL e",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:genOpenBAVL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis name is \u003cem\u003edeprecated\u003c/em\u003e. Instead use \u003ccode\u003e\u003ca\u003eopenEither\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "genOpenEither",
          "package": "AvlTree",
          "signature": "(e -\u003e Ordering) -\u003e AVL e -\u003e Either (PAVL e) (ZAVL e)",
          "source": "src/Data-Tree-AVL-Deprecated.html#genOpenEither",
          "type": "function"
        },
        "index": {
          "description": "This name is deprecated Instead use openEither",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "genOpenEither",
          "normalized": "(a-\u003eOrdering)-\u003eAVL a-\u003eEither(PAVL a)(ZAVL a)",
          "package": "AvlTree",
          "partial": "Open Either",
          "signature": "(e-\u003eOrdering)-\u003eAVL e-\u003eEither(PAVL e)(ZAVL e)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:genOpenEither"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis name is \u003cem\u003edeprecated\u003c/em\u003e. Instead use \u003ccode\u003e\u003ca\u003eopenPath\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "genOpenPath",
          "package": "AvlTree",
          "signature": "(e -\u003e Ordering) -\u003e AVL e -\u003e BinPath e",
          "source": "src/Data-Tree-AVL-Deprecated.html#genOpenPath",
          "type": "function"
        },
        "index": {
          "description": "This name is deprecated Instead use openPath",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "genOpenPath",
          "normalized": "(a-\u003eOrdering)-\u003eAVL a-\u003eBinPath a",
          "package": "AvlTree",
          "partial": "Open Path",
          "signature": "(e-\u003eOrdering)-\u003eAVL e-\u003eBinPath e",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:genOpenPath"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis name is \u003cem\u003edeprecated\u003c/em\u003e. Instead use \u003ccode\u003e\u003ca\u003eopenPathWith\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "genOpenPathWith",
          "package": "AvlTree",
          "signature": "(e -\u003e COrdering a) -\u003e AVL e -\u003e BinPath a",
          "source": "src/Data-Tree-AVL-Deprecated.html#genOpenPathWith",
          "type": "function"
        },
        "index": {
          "description": "This name is deprecated Instead use openPathWith",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "genOpenPathWith",
          "normalized": "(a-\u003eCOrdering b)-\u003eAVL a-\u003eBinPath b",
          "package": "AvlTree",
          "partial": "Open Path With",
          "signature": "(e-\u003eCOrdering a)-\u003eAVL e-\u003eBinPath a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:genOpenPathWith"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis name is \u003cem\u003edeprecated\u003c/em\u003e. Instead use \u003ccode\u003e\u003ca\u003epush\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "genPush",
          "package": "AvlTree",
          "signature": "(e -\u003e COrdering e) -\u003e e -\u003e AVL e -\u003e AVL e",
          "source": "src/Data-Tree-AVL-Deprecated.html#genPush",
          "type": "function"
        },
        "index": {
          "description": "This name is deprecated Instead use push",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "genPush",
          "normalized": "(a-\u003eCOrdering a)-\u003ea-\u003eAVL a-\u003eAVL a",
          "package": "AvlTree",
          "partial": "Push",
          "signature": "(e-\u003eCOrdering e)-\u003ee-\u003eAVL e-\u003eAVL e",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:genPush"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis name is \u003cem\u003edeprecated\u003c/em\u003e. Instead use ' push''.\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "genPush'",
          "package": "AvlTree",
          "signature": "(e -\u003e COrdering e) -\u003e e -\u003e AVL e -\u003e AVL e",
          "source": "src/Data-Tree-AVL-Deprecated.html#genPush%27",
          "type": "function"
        },
        "index": {
          "description": "This name is deprecated Instead use push",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "genPush'",
          "normalized": "(a-\u003eCOrdering a)-\u003ea-\u003eAVL a-\u003eAVL a",
          "package": "AvlTree",
          "partial": "Push'",
          "signature": "(e-\u003eCOrdering e)-\u003ee-\u003eAVL e-\u003eAVL e",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:genPush-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis name is \u003cem\u003edeprecated\u003c/em\u003e. Instead use \u003ccode\u003e\u003ca\u003epushMaybe\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "genPushMaybe",
          "package": "AvlTree",
          "signature": "(e -\u003e COrdering (Maybe e)) -\u003e e -\u003e AVL e -\u003e AVL e",
          "source": "src/Data-Tree-AVL-Deprecated.html#genPushMaybe",
          "type": "function"
        },
        "index": {
          "description": "This name is deprecated Instead use pushMaybe",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "genPushMaybe",
          "normalized": "(a-\u003eCOrdering(Maybe a))-\u003ea-\u003eAVL a-\u003eAVL a",
          "package": "AvlTree",
          "partial": "Push Maybe",
          "signature": "(e-\u003eCOrdering(Maybe e))-\u003ee-\u003eAVL e-\u003eAVL e",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:genPushMaybe"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis name is \u003cem\u003edeprecated\u003c/em\u003e. Instead use \u003ccode\u003e\u003ca\u003epushMaybe'\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "genPushMaybe'",
          "package": "AvlTree",
          "signature": "(e -\u003e COrdering (Maybe e)) -\u003e e -\u003e AVL e -\u003e AVL e",
          "source": "src/Data-Tree-AVL-Deprecated.html#genPushMaybe%27",
          "type": "function"
        },
        "index": {
          "description": "This name is deprecated Instead use pushMaybe",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "genPushMaybe'",
          "normalized": "(a-\u003eCOrdering(Maybe a))-\u003ea-\u003eAVL a-\u003eAVL a",
          "package": "AvlTree",
          "partial": "Push Maybe'",
          "signature": "(e-\u003eCOrdering(Maybe e))-\u003ee-\u003eAVL e-\u003eAVL e",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:genPushMaybe-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis name is \u003cem\u003edeprecated\u003c/em\u003e. Instead use \u003ccode\u003e\u003ca\u003esymDifference\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "genSymDifference",
          "package": "AvlTree",
          "signature": "(e -\u003e e -\u003e Ordering) -\u003e AVL e -\u003e AVL e -\u003e AVL e",
          "source": "src/Data-Tree-AVL-Deprecated.html#genSymDifference",
          "type": "function"
        },
        "index": {
          "description": "This name is deprecated Instead use symDifference",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "genSymDifference",
          "normalized": "(a-\u003ea-\u003eOrdering)-\u003eAVL a-\u003eAVL a-\u003eAVL a",
          "package": "AvlTree",
          "partial": "Sym Difference",
          "signature": "(e-\u003ee-\u003eOrdering)-\u003eAVL e-\u003eAVL e-\u003eAVL e",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:genSymDifference"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis name is \u003cem\u003edeprecated\u003c/em\u003e. Instead use \u003ccode\u003e\u003ca\u003etakeGE\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "genTakeGE",
          "package": "AvlTree",
          "signature": "(e -\u003e Ordering) -\u003e AVL e -\u003e AVL e",
          "source": "src/Data-Tree-AVL-Deprecated.html#genTakeGE",
          "type": "function"
        },
        "index": {
          "description": "This name is deprecated Instead use takeGE",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "genTakeGE",
          "normalized": "(a-\u003eOrdering)-\u003eAVL a-\u003eAVL a",
          "package": "AvlTree",
          "partial": "Take GE",
          "signature": "(e-\u003eOrdering)-\u003eAVL e-\u003eAVL e",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:genTakeGE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis name is \u003cem\u003edeprecated\u003c/em\u003e. Instead use \u003ccode\u003e\u003ca\u003etakeGT\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "genTakeGT",
          "package": "AvlTree",
          "signature": "(e -\u003e Ordering) -\u003e AVL e -\u003e AVL e",
          "source": "src/Data-Tree-AVL-Deprecated.html#genTakeGT",
          "type": "function"
        },
        "index": {
          "description": "This name is deprecated Instead use takeGT",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "genTakeGT",
          "normalized": "(a-\u003eOrdering)-\u003eAVL a-\u003eAVL a",
          "package": "AvlTree",
          "partial": "Take GT",
          "signature": "(e-\u003eOrdering)-\u003eAVL e-\u003eAVL e",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:genTakeGT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis name is \u003cem\u003edeprecated\u003c/em\u003e. Instead use \u003ccode\u003e\u003ca\u003etakeLE\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "genTakeLE",
          "package": "AvlTree",
          "signature": "(e -\u003e Ordering) -\u003e AVL e -\u003e AVL e",
          "source": "src/Data-Tree-AVL-Deprecated.html#genTakeLE",
          "type": "function"
        },
        "index": {
          "description": "This name is deprecated Instead use takeLE",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "genTakeLE",
          "normalized": "(a-\u003eOrdering)-\u003eAVL a-\u003eAVL a",
          "package": "AvlTree",
          "partial": "Take LE",
          "signature": "(e-\u003eOrdering)-\u003eAVL e-\u003eAVL e",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:genTakeLE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis name is \u003cem\u003edeprecated\u003c/em\u003e. Instead use \u003ccode\u003e\u003ca\u003etakeLT\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "genTakeLT",
          "package": "AvlTree",
          "signature": "(e -\u003e Ordering) -\u003e AVL e -\u003e AVL e",
          "source": "src/Data-Tree-AVL-Deprecated.html#genTakeLT",
          "type": "function"
        },
        "index": {
          "description": "This name is deprecated Instead use takeLT",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "genTakeLT",
          "normalized": "(a-\u003eOrdering)-\u003eAVL a-\u003eAVL a",
          "package": "AvlTree",
          "partial": "Take LT",
          "signature": "(e-\u003eOrdering)-\u003eAVL e-\u003eAVL e",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:genTakeLT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis name is \u003cem\u003edeprecated\u003c/em\u003e. Instead use \u003ccode\u003e\u003ca\u003etryOpen\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "genTryOpen",
          "package": "AvlTree",
          "signature": "(e -\u003e Ordering) -\u003e AVL e -\u003e Maybe (ZAVL e)",
          "source": "src/Data-Tree-AVL-Deprecated.html#genTryOpen",
          "type": "function"
        },
        "index": {
          "description": "This name is deprecated Instead use tryOpen",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "genTryOpen",
          "normalized": "(a-\u003eOrdering)-\u003eAVL a-\u003eMaybe(ZAVL a)",
          "package": "AvlTree",
          "partial": "Try Open",
          "signature": "(e-\u003eOrdering)-\u003eAVL e-\u003eMaybe(ZAVL e)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:genTryOpen"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis name is \u003cem\u003edeprecated\u003c/em\u003e. Instead use \u003ccode\u003e\u003ca\u003etryOpenGE\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "genTryOpenGE",
          "package": "AvlTree",
          "signature": "(e -\u003e Ordering) -\u003e AVL e -\u003e Maybe (ZAVL e)",
          "source": "src/Data-Tree-AVL-Deprecated.html#genTryOpenGE",
          "type": "function"
        },
        "index": {
          "description": "This name is deprecated Instead use tryOpenGE",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "genTryOpenGE",
          "normalized": "(a-\u003eOrdering)-\u003eAVL a-\u003eMaybe(ZAVL a)",
          "package": "AvlTree",
          "partial": "Try Open GE",
          "signature": "(e-\u003eOrdering)-\u003eAVL e-\u003eMaybe(ZAVL e)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:genTryOpenGE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis name is \u003cem\u003edeprecated\u003c/em\u003e. Instead use \u003ccode\u003e\u003ca\u003etryOpenLE\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "genTryOpenLE",
          "package": "AvlTree",
          "signature": "(e -\u003e Ordering) -\u003e AVL e -\u003e Maybe (ZAVL e)",
          "source": "src/Data-Tree-AVL-Deprecated.html#genTryOpenLE",
          "type": "function"
        },
        "index": {
          "description": "This name is deprecated Instead use tryOpenLE",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "genTryOpenLE",
          "normalized": "(a-\u003eOrdering)-\u003eAVL a-\u003eMaybe(ZAVL a)",
          "package": "AvlTree",
          "partial": "Try Open LE",
          "signature": "(e-\u003eOrdering)-\u003eAVL e-\u003eMaybe(ZAVL e)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:genTryOpenLE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis name is \u003cem\u003edeprecated\u003c/em\u003e. Instead use \u003ccode\u003e\u003ca\u003etryPop\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "genTryPop",
          "package": "AvlTree",
          "signature": "(e -\u003e COrdering a) -\u003e AVL e -\u003e Maybe (a, AVL e)",
          "source": "src/Data-Tree-AVL-Deprecated.html#genTryPop",
          "type": "function"
        },
        "index": {
          "description": "This name is deprecated Instead use tryPop",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "genTryPop",
          "normalized": "(a-\u003eCOrdering b)-\u003eAVL a-\u003eMaybe(b,AVL a)",
          "package": "AvlTree",
          "partial": "Try Pop",
          "signature": "(e-\u003eCOrdering a)-\u003eAVL e-\u003eMaybe(a,AVL e)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:genTryPop"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis name is \u003cem\u003edeprecated\u003c/em\u003e. Instead use \u003ccode\u003e\u003ca\u003etryPopIf\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "genTryPopIf",
          "package": "AvlTree",
          "signature": "(e -\u003e COrdering (a, Bool)) -\u003e AVL e -\u003e Maybe (a, AVL e)",
          "source": "src/Data-Tree-AVL-Deprecated.html#genTryPopIf",
          "type": "function"
        },
        "index": {
          "description": "This name is deprecated Instead use tryPopIf",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "genTryPopIf",
          "normalized": "(a-\u003eCOrdering(b,Bool))-\u003eAVL a-\u003eMaybe(b,AVL a)",
          "package": "AvlTree",
          "partial": "Try Pop If",
          "signature": "(e-\u003eCOrdering(a,Bool))-\u003eAVL e-\u003eMaybe(a,AVL e)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:genTryPopIf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis name is \u003cem\u003edeprecated\u003c/em\u003e. Instead use \u003ccode\u003e\u003ca\u003etryPopMaybe\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "genTryPopMaybe",
          "package": "AvlTree",
          "signature": "(e -\u003e COrdering (a, Maybe e)) -\u003e AVL e -\u003e Maybe (a, AVL e)",
          "source": "src/Data-Tree-AVL-Deprecated.html#genTryPopMaybe",
          "type": "function"
        },
        "index": {
          "description": "This name is deprecated Instead use tryPopMaybe",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "genTryPopMaybe",
          "normalized": "(a-\u003eCOrdering(b,Maybe a))-\u003eAVL a-\u003eMaybe(b,AVL a)",
          "package": "AvlTree",
          "partial": "Try Pop Maybe",
          "signature": "(e-\u003eCOrdering(a,Maybe e))-\u003eAVL e-\u003eMaybe(a,AVL e)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:genTryPopMaybe"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis name is \u003cem\u003edeprecated\u003c/em\u003e. Instead use \u003ccode\u003e\u003ca\u003etryRead\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "genTryRead",
          "package": "AvlTree",
          "signature": "AVL e -\u003e (e -\u003e COrdering a) -\u003e Maybe a",
          "source": "src/Data-Tree-AVL-Deprecated.html#genTryRead",
          "type": "function"
        },
        "index": {
          "description": "This name is deprecated Instead use tryRead",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "genTryRead",
          "normalized": "AVL a-\u003e(a-\u003eCOrdering b)-\u003eMaybe b",
          "package": "AvlTree",
          "partial": "Try Read",
          "signature": "AVL e-\u003e(e-\u003eCOrdering a)-\u003eMaybe a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:genTryRead"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis name is \u003cem\u003edeprecated\u003c/em\u003e. Instead use \u003ccode\u003e\u003ca\u003etryReadMaybe\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "genTryReadMaybe",
          "package": "AvlTree",
          "signature": "AVL e -\u003e (e -\u003e COrdering (Maybe a)) -\u003e Maybe a",
          "source": "src/Data-Tree-AVL-Deprecated.html#genTryReadMaybe",
          "type": "function"
        },
        "index": {
          "description": "This name is deprecated Instead use tryReadMaybe",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "genTryReadMaybe",
          "normalized": "AVL a-\u003e(a-\u003eCOrdering(Maybe b))-\u003eMaybe b",
          "package": "AvlTree",
          "partial": "Try Read Maybe",
          "signature": "AVL e-\u003e(e-\u003eCOrdering(Maybe a))-\u003eMaybe a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:genTryReadMaybe"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis name is \u003cem\u003edeprecated\u003c/em\u003e. Instead use \u003ccode\u003e\u003ca\u003etryWrite\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "genTryWrite",
          "package": "AvlTree",
          "signature": "(e -\u003e COrdering e) -\u003e AVL e -\u003e Maybe (AVL e)",
          "source": "src/Data-Tree-AVL-Deprecated.html#genTryWrite",
          "type": "function"
        },
        "index": {
          "description": "This name is deprecated Instead use tryWrite",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "genTryWrite",
          "normalized": "(a-\u003eCOrdering a)-\u003eAVL a-\u003eMaybe(AVL a)",
          "package": "AvlTree",
          "partial": "Try Write",
          "signature": "(e-\u003eCOrdering e)-\u003eAVL e-\u003eMaybe(AVL e)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:genTryWrite"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis name is \u003cem\u003edeprecated\u003c/em\u003e. Instead use \u003ccode\u003e\u003ca\u003etryWriteMaybe\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "genTryWriteMaybe",
          "package": "AvlTree",
          "signature": "(e -\u003e COrdering (Maybe e)) -\u003e AVL e -\u003e Maybe (AVL e)",
          "source": "src/Data-Tree-AVL-Deprecated.html#genTryWriteMaybe",
          "type": "function"
        },
        "index": {
          "description": "This name is deprecated Instead use tryWriteMaybe",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "genTryWriteMaybe",
          "normalized": "(a-\u003eCOrdering(Maybe a))-\u003eAVL a-\u003eMaybe(AVL a)",
          "package": "AvlTree",
          "partial": "Try Write Maybe",
          "signature": "(e-\u003eCOrdering(Maybe e))-\u003eAVL e-\u003eMaybe(AVL e)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:genTryWriteMaybe"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis name is \u003cem\u003edeprecated\u003c/em\u003e. Instead use \u003ccode\u003e\u003ca\u003eunion\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "genUnion",
          "package": "AvlTree",
          "signature": "(e -\u003e e -\u003e COrdering e) -\u003e AVL e -\u003e AVL e -\u003e AVL e",
          "source": "src/Data-Tree-AVL-Deprecated.html#genUnion",
          "type": "function"
        },
        "index": {
          "description": "This name is deprecated Instead use union",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "genUnion",
          "normalized": "(a-\u003ea-\u003eCOrdering a)-\u003eAVL a-\u003eAVL a-\u003eAVL a",
          "package": "AvlTree",
          "partial": "Union",
          "signature": "(e-\u003ee-\u003eCOrdering e)-\u003eAVL e-\u003eAVL e-\u003eAVL e",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:genUnion"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis name is \u003cem\u003edeprecated\u003c/em\u003e. Instead use \u003ccode\u003e\u003ca\u003eunionMaybe\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "genUnionMaybe",
          "package": "AvlTree",
          "signature": "(e -\u003e e -\u003e COrdering (Maybe e)) -\u003e AVL e -\u003e AVL e -\u003e AVL e",
          "source": "src/Data-Tree-AVL-Deprecated.html#genUnionMaybe",
          "type": "function"
        },
        "index": {
          "description": "This name is deprecated Instead use unionMaybe",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "genUnionMaybe",
          "normalized": "(a-\u003ea-\u003eCOrdering(Maybe a))-\u003eAVL a-\u003eAVL a-\u003eAVL a",
          "package": "AvlTree",
          "partial": "Union Maybe",
          "signature": "(e-\u003ee-\u003eCOrdering(Maybe e))-\u003eAVL e-\u003eAVL e-\u003eAVL e",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:genUnionMaybe"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis name is \u003cem\u003edeprecated\u003c/em\u003e. Instead use \u003ccode\u003e\u003ca\u003eunions\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "genUnions",
          "package": "AvlTree",
          "signature": "(e -\u003e e -\u003e COrdering e) -\u003e [AVL e] -\u003e AVL e",
          "source": "src/Data-Tree-AVL-Deprecated.html#genUnions",
          "type": "function"
        },
        "index": {
          "description": "This name is deprecated Instead use unions",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "genUnions",
          "normalized": "(a-\u003ea-\u003eCOrdering a)-\u003e[AVL a]-\u003eAVL a",
          "package": "AvlTree",
          "partial": "Unions",
          "signature": "(e-\u003ee-\u003eCOrdering e)-\u003e[AVL e]-\u003eAVL e",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:genUnions"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis name is \u003cem\u003edeprecated\u003c/em\u003e. Instead use \u003ccode\u003e\u003ca\u003evenn\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "genVenn",
          "package": "AvlTree",
          "signature": "(a -\u003e b -\u003e COrdering c) -\u003e AVL a -\u003e AVL b -\u003e (AVL a, AVL c, AVL b)",
          "source": "src/Data-Tree-AVL-Deprecated.html#genVenn",
          "type": "function"
        },
        "index": {
          "description": "This name is deprecated Instead use venn",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "genVenn",
          "normalized": "(a-\u003eb-\u003eCOrdering c)-\u003eAVL a-\u003eAVL b-\u003e(AVL a,AVL c,AVL b)",
          "package": "AvlTree",
          "partial": "Venn",
          "signature": "(a-\u003eb-\u003eCOrdering c)-\u003eAVL a-\u003eAVL b-\u003e(AVL a,AVL c,AVL b)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:genVenn"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis name is \u003cem\u003edeprecated\u003c/em\u003e. Instead use \u003ccode\u003e\u003ca\u003evennAsList\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "genVennAsList",
          "package": "AvlTree",
          "signature": "(a -\u003e b -\u003e COrdering c) -\u003e AVL a -\u003e AVL b -\u003e (AVL a, [c], AVL b)",
          "source": "src/Data-Tree-AVL-Deprecated.html#genVennAsList",
          "type": "function"
        },
        "index": {
          "description": "This name is deprecated Instead use vennAsList",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "genVennAsList",
          "normalized": "(a-\u003eb-\u003eCOrdering c)-\u003eAVL a-\u003eAVL b-\u003e(AVL a,[c],AVL b)",
          "package": "AvlTree",
          "partial": "Venn As List",
          "signature": "(a-\u003eb-\u003eCOrdering c)-\u003eAVL a-\u003eAVL b-\u003e(AVL a,[c],AVL b)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:genVennAsList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis name is \u003cem\u003edeprecated\u003c/em\u003e. Instead use \u003ccode\u003e\u003ca\u003evennMaybe\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "genVennMaybe",
          "package": "AvlTree",
          "signature": "(a -\u003e b -\u003e COrdering (Maybe c)) -\u003e AVL a -\u003e AVL b -\u003e (AVL a, AVL c, AVL b)",
          "source": "src/Data-Tree-AVL-Deprecated.html#genVennMaybe",
          "type": "function"
        },
        "index": {
          "description": "This name is deprecated Instead use vennMaybe",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "genVennMaybe",
          "normalized": "(a-\u003eb-\u003eCOrdering(Maybe c))-\u003eAVL a-\u003eAVL b-\u003e(AVL a,AVL c,AVL b)",
          "package": "AvlTree",
          "partial": "Venn Maybe",
          "signature": "(a-\u003eb-\u003eCOrdering(Maybe c))-\u003eAVL a-\u003eAVL b-\u003e(AVL a,AVL c,AVL b)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:genVennMaybe"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis name is \u003cem\u003edeprecated\u003c/em\u003e. Instead use \u003ccode\u003e\u003ca\u003evennMaybeAsList\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "genVennMaybeAsList",
          "package": "AvlTree",
          "signature": "(a -\u003e b -\u003e COrdering (Maybe c)) -\u003e AVL a -\u003e AVL b -\u003e (AVL a, [c], AVL b)",
          "source": "src/Data-Tree-AVL-Deprecated.html#genVennMaybeAsList",
          "type": "function"
        },
        "index": {
          "description": "This name is deprecated Instead use vennMaybeAsList",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "genVennMaybeAsList",
          "normalized": "(a-\u003eb-\u003eCOrdering(Maybe c))-\u003eAVL a-\u003eAVL b-\u003e(AVL a,[c],AVL b)",
          "package": "AvlTree",
          "partial": "Venn Maybe As List",
          "signature": "(a-\u003eb-\u003eCOrdering(Maybe c))-\u003eAVL a-\u003eAVL b-\u003e(AVL a,[c],AVL b)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:genVennMaybeAsList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis name is \u003cem\u003edeprecated\u003c/em\u003e. Instead use \u003ccode\u003e\u003ca\u003evennMaybeToList\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "genVennMaybeToList",
          "package": "AvlTree",
          "signature": "(a -\u003e b -\u003e COrdering (Maybe c)) -\u003e [c] -\u003e AVL a -\u003e AVL b -\u003e (AVL a, [c], AVL b)",
          "source": "src/Data-Tree-AVL-Deprecated.html#genVennMaybeToList",
          "type": "function"
        },
        "index": {
          "description": "This name is deprecated Instead use vennMaybeToList",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "genVennMaybeToList",
          "normalized": "(a-\u003eb-\u003eCOrdering(Maybe c))-\u003e[c]-\u003eAVL a-\u003eAVL b-\u003e(AVL a,[c],AVL b)",
          "package": "AvlTree",
          "partial": "Venn Maybe To List",
          "signature": "(a-\u003eb-\u003eCOrdering(Maybe c))-\u003e[c]-\u003eAVL a-\u003eAVL b-\u003e(AVL a,[c],AVL b)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:genVennMaybeToList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis name is \u003cem\u003edeprecated\u003c/em\u003e. Instead use \u003ccode\u003e\u003ca\u003evennToList\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "genVennToList",
          "package": "AvlTree",
          "signature": "(a -\u003e b -\u003e COrdering c) -\u003e [c] -\u003e AVL a -\u003e AVL b -\u003e (AVL a, [c], AVL b)",
          "source": "src/Data-Tree-AVL-Deprecated.html#genVennToList",
          "type": "function"
        },
        "index": {
          "description": "This name is deprecated Instead use vennToList",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "genVennToList",
          "normalized": "(a-\u003eb-\u003eCOrdering c)-\u003e[c]-\u003eAVL a-\u003eAVL b-\u003e(AVL a,[c],AVL b)",
          "package": "AvlTree",
          "partial": "Venn To List",
          "signature": "(a-\u003eb-\u003eCOrdering c)-\u003e[c]-\u003eAVL a-\u003eAVL b-\u003e(AVL a,[c],AVL b)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:genVennToList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis name is \u003cem\u003edeprecated\u003c/em\u003e. Instead use \u003ccode\u003e\u003ca\u003ewrite\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "genWrite",
          "package": "AvlTree",
          "signature": "(e -\u003e COrdering e) -\u003e AVL e -\u003e AVL e",
          "source": "src/Data-Tree-AVL-Deprecated.html#genWrite",
          "type": "function"
        },
        "index": {
          "description": "This name is deprecated Instead use write",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "genWrite",
          "normalized": "(a-\u003eCOrdering a)-\u003eAVL a-\u003eAVL a",
          "package": "AvlTree",
          "partial": "Write",
          "signature": "(e-\u003eCOrdering e)-\u003eAVL e-\u003eAVL e",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:genWrite"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis name is \u003cem\u003edeprecated\u003c/em\u003e. Instead use \u003ccode\u003e\u003ca\u003ewriteFast\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "genWriteFast",
          "package": "AvlTree",
          "signature": "(e -\u003e COrdering e) -\u003e AVL e -\u003e AVL e",
          "source": "src/Data-Tree-AVL-Deprecated.html#genWriteFast",
          "type": "function"
        },
        "index": {
          "description": "This name is deprecated Instead use writeFast",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "genWriteFast",
          "normalized": "(a-\u003eCOrdering a)-\u003eAVL a-\u003eAVL a",
          "package": "AvlTree",
          "partial": "Write Fast",
          "signature": "(e-\u003eCOrdering e)-\u003eAVL e-\u003eAVL e",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:genWriteFast"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis name is \u003cem\u003edeprecated\u003c/em\u003e. Instead use \u003ccode\u003e\u003ca\u003ewriteMaybe\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "genWriteMaybe",
          "package": "AvlTree",
          "signature": "(e -\u003e COrdering (Maybe e)) -\u003e AVL e -\u003e AVL e",
          "source": "src/Data-Tree-AVL-Deprecated.html#genWriteMaybe",
          "type": "function"
        },
        "index": {
          "description": "This name is deprecated Instead use writeMaybe",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "genWriteMaybe",
          "normalized": "(a-\u003eCOrdering(Maybe a))-\u003eAVL a-\u003eAVL a",
          "package": "AvlTree",
          "partial": "Write Maybe",
          "signature": "(e-\u003eCOrdering(Maybe e))-\u003eAVL e-\u003eAVL e",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:genWriteMaybe"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGets the current element of a Zipper.\n\u003c/p\u003e\u003cp\u003eComplexity: O(1)\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "getCurrent",
          "package": "AvlTree",
          "signature": "ZAVL e -\u003e e",
          "source": "src/Data-Tree-AVL-Zipper.html#getCurrent",
          "type": "function"
        },
        "index": {
          "description": "Gets the current element of Zipper Complexity",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "getCurrent",
          "normalized": "ZAVL a-\u003ea",
          "package": "AvlTree",
          "partial": "Current",
          "signature": "ZAVL e-\u003ee",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:getCurrent"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDetermine the height of an AVL tree.\n\u003c/p\u003e\u003cp\u003eComplexity: O(log n)\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "height",
          "package": "AvlTree",
          "signature": "AVL e -\u003e Int#",
          "source": "src/Data-Tree-AVL-Height.html#height",
          "type": "function"
        },
        "index": {
          "description": "Determine the height of an AVL tree Complexity log",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "height",
          "normalized": "AVL a-\u003eInt #",
          "package": "AvlTree",
          "signature": "AVL e-\u003eInt #",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:height"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInserts a new element to the immediate left of the current element.\n\u003c/p\u003e\u003cp\u003eComplexity: O(1) average, O(log n) worst case.\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "insertL",
          "package": "AvlTree",
          "signature": "e -\u003e ZAVL e -\u003e ZAVL e",
          "source": "src/Data-Tree-AVL-Zipper.html#insertL",
          "type": "function"
        },
        "index": {
          "description": "Inserts new element to the immediate left of the current element Complexity average log worst case",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "insertL",
          "normalized": "a-\u003eZAVL a-\u003eZAVL a",
          "package": "AvlTree",
          "signature": "e-\u003eZAVL e-\u003eZAVL e",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:insertL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInserts a new element to the immediate left of the current element and then\n moves one step left (so the newly inserted element becomes the current element).\n\u003c/p\u003e\u003cp\u003eComplexity: O(1) average, O(log n) worst case.\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "insertMoveL",
          "package": "AvlTree",
          "signature": "e -\u003e ZAVL e -\u003e ZAVL e",
          "source": "src/Data-Tree-AVL-Zipper.html#insertMoveL",
          "type": "function"
        },
        "index": {
          "description": "Inserts new element to the immediate left of the current element and then moves one step left so the newly inserted element becomes the current element Complexity average log worst case",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "insertMoveL",
          "normalized": "a-\u003eZAVL a-\u003eZAVL a",
          "package": "AvlTree",
          "partial": "Move",
          "signature": "e-\u003eZAVL e-\u003eZAVL e",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:insertMoveL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInserts a new element to the immediate right of the current element and then\n moves one step right (so the newly inserted element becomes the current element).\n\u003c/p\u003e\u003cp\u003eComplexity: O(1) average, O(log n) worst case.\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "insertMoveR",
          "package": "AvlTree",
          "signature": "ZAVL e -\u003e e -\u003e ZAVL e",
          "source": "src/Data-Tree-AVL-Zipper.html#insertMoveR",
          "type": "function"
        },
        "index": {
          "description": "Inserts new element to the immediate right of the current element and then moves one step right so the newly inserted element becomes the current element Complexity average log worst case",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "insertMoveR",
          "normalized": "ZAVL a-\u003ea-\u003eZAVL a",
          "package": "AvlTree",
          "partial": "Move",
          "signature": "ZAVL e-\u003ee-\u003eZAVL e",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:insertMoveR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInserts a new tree element. Assumes the path bits were extracted from a \u003ccode\u003e\u003ca\u003eEmptyBP\u003c/a\u003e\u003c/code\u003e constructor.\n This function replaces the first Empty node it encounters with the supplied value, regardless\n of the current path bits (which are not checked). DO NOT USE THIS FOR REPLACING ELEMENTS ALREADY\n PRESENT IN THE TREE (use \u003ccode\u003e\u003ca\u003ewritePath\u003c/a\u003e\u003c/code\u003e for this).\n\u003c/p\u003e\u003cp\u003eComplexity: O(log n)\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "insertPath",
          "package": "AvlTree",
          "signature": "Int# -\u003e e -\u003e AVL e -\u003e AVL e",
          "source": "src/Data-Tree-AVL-BinPath.html#insertPath",
          "type": "function"
        },
        "index": {
          "description": "Inserts new tree element Assumes the path bits were extracted from EmptyBP constructor This function replaces the first Empty node it encounters with the supplied value regardless of the current path bits which are not checked DO NOT USE THIS FOR REPLACING ELEMENTS ALREADY PRESENT IN THE TREE use writePath for this Complexity log",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "insertPath",
          "normalized": "Int #-\u003ea-\u003eAVL a-\u003eAVL a",
          "package": "AvlTree",
          "partial": "Path",
          "signature": "Int #-\u003ee-\u003eAVL e-\u003eAVL e",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:insertPath"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInserts a new element to the immediate right of the current element.\n\u003c/p\u003e\u003cp\u003eComplexity: O(1) average, O(log n) worst case.\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "insertR",
          "package": "AvlTree",
          "signature": "ZAVL e -\u003e e -\u003e ZAVL e",
          "source": "src/Data-Tree-AVL-Zipper.html#insertR",
          "type": "function"
        },
        "index": {
          "description": "Inserts new element to the immediate right of the current element Complexity average log worst case",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "insertR",
          "normalized": "ZAVL a-\u003ea-\u003eZAVL a",
          "package": "AvlTree",
          "signature": "ZAVL e-\u003ee-\u003eZAVL e",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:insertR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInserts a new AVL tree to the immediate left of the current element.\n\u003c/p\u003e\u003cp\u003eComplexity: O(log n), where n is the size of the inserted tree.\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "insertTreeL",
          "package": "AvlTree",
          "signature": "AVL e -\u003e ZAVL e -\u003e ZAVL e",
          "source": "src/Data-Tree-AVL-Zipper.html#insertTreeL",
          "type": "function"
        },
        "index": {
          "description": "Inserts new AVL tree to the immediate left of the current element Complexity log where is the size of the inserted tree",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "insertTreeL",
          "normalized": "AVL a-\u003eZAVL a-\u003eZAVL a",
          "package": "AvlTree",
          "partial": "Tree",
          "signature": "AVL e-\u003eZAVL e-\u003eZAVL e",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:insertTreeL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInserts a new AVL tree to the immediate right of the current element.\n\u003c/p\u003e\u003cp\u003eComplexity: O(log n), where n is the size of the inserted tree.\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "insertTreeR",
          "package": "AvlTree",
          "signature": "ZAVL e -\u003e AVL e -\u003e ZAVL e",
          "source": "src/Data-Tree-AVL-Zipper.html#insertTreeR",
          "type": "function"
        },
        "index": {
          "description": "Inserts new AVL tree to the immediate right of the current element Complexity log where is the size of the inserted tree",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "insertTreeR",
          "normalized": "ZAVL a-\u003eAVL a-\u003eZAVL a",
          "package": "AvlTree",
          "partial": "Tree",
          "signature": "ZAVL e-\u003eAVL e-\u003eZAVL e",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:insertTreeR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUses the supplied combining comparison to evaluate the intersection of two sets represented as\n sorted AVL trees.\n\u003c/p\u003e\u003cp\u003eComplexity: Not sure, but I'd appreciate it if someone could figure it out.\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "intersection",
          "package": "AvlTree",
          "signature": "(a -\u003e b -\u003e COrdering c) -\u003e AVL a -\u003e AVL b -\u003e AVL c",
          "source": "src/Data-Tree-AVL-Set.html#intersection",
          "type": "function"
        },
        "index": {
          "description": "Uses the supplied combining comparison to evaluate the intersection of two sets represented as sorted AVL trees Complexity Not sure but appreciate it if someone could figure it out",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "intersection",
          "normalized": "(a-\u003eb-\u003eCOrdering c)-\u003eAVL a-\u003eAVL b-\u003eAVL c",
          "package": "AvlTree",
          "signature": "(a-\u003eb-\u003eCOrdering c)-\u003eAVL a-\u003eAVL b-\u003eAVL c",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:intersection"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eApplies \u003ccode\u003e\u003ca\u003eintersectionToList\u003c/a\u003e\u003c/code\u003e to the empty list.\n\u003c/p\u003e\u003cp\u003eComplexity: Not sure, but I'd appreciate it if someone could figure it out.\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "intersectionAsList",
          "package": "AvlTree",
          "signature": "(a -\u003e b -\u003e COrdering c) -\u003e AVL a -\u003e AVL b -\u003e [c]",
          "source": "src/Data-Tree-AVL-Set.html#intersectionAsList",
          "type": "function"
        },
        "index": {
          "description": "Applies intersectionToList to the empty list Complexity Not sure but appreciate it if someone could figure it out",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "intersectionAsList",
          "normalized": "(a-\u003eb-\u003eCOrdering c)-\u003eAVL a-\u003eAVL b-\u003e[c]",
          "package": "AvlTree",
          "partial": "As List",
          "signature": "(a-\u003eb-\u003eCOrdering c)-\u003eAVL a-\u003eAVL b-\u003e[c]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:intersectionAsList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSimilar to \u003ccode\u003e\u003ca\u003eintersection\u003c/a\u003e\u003c/code\u003e, but the resulting tree does not include elements in cases where\n the supplied combining comparison returns \u003ccode\u003e(Eq Nothing)\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eComplexity: Not sure, but I'd appreciate it if someone could figure it out.\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "intersectionMaybe",
          "package": "AvlTree",
          "signature": "(a -\u003e b -\u003e COrdering (Maybe c)) -\u003e AVL a -\u003e AVL b -\u003e AVL c",
          "source": "src/Data-Tree-AVL-Set.html#intersectionMaybe",
          "type": "function"
        },
        "index": {
          "description": "Similar to intersection but the resulting tree does not include elements in cases where the supplied combining comparison returns Eq Nothing Complexity Not sure but appreciate it if someone could figure it out",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "intersectionMaybe",
          "normalized": "(a-\u003eb-\u003eCOrdering(Maybe c))-\u003eAVL a-\u003eAVL b-\u003eAVL c",
          "package": "AvlTree",
          "partial": "Maybe",
          "signature": "(a-\u003eb-\u003eCOrdering(Maybe c))-\u003eAVL a-\u003eAVL b-\u003eAVL c",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:intersectionMaybe"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eApplies \u003ccode\u003e\u003ca\u003eintersectionMaybeToList\u003c/a\u003e\u003c/code\u003e to the empty list.\n\u003c/p\u003e\u003cp\u003eComplexity: Not sure, but I'd appreciate it if someone could figure it out.\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "intersectionMaybeAsList",
          "package": "AvlTree",
          "signature": "(a -\u003e b -\u003e COrdering (Maybe c)) -\u003e AVL a -\u003e AVL b -\u003e [c]",
          "source": "src/Data-Tree-AVL-Set.html#intersectionMaybeAsList",
          "type": "function"
        },
        "index": {
          "description": "Applies intersectionMaybeToList to the empty list Complexity Not sure but appreciate it if someone could figure it out",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "intersectionMaybeAsList",
          "normalized": "(a-\u003eb-\u003eCOrdering(Maybe c))-\u003eAVL a-\u003eAVL b-\u003e[c]",
          "package": "AvlTree",
          "partial": "Maybe As List",
          "signature": "(a-\u003eb-\u003eCOrdering(Maybe c))-\u003eAVL a-\u003eAVL b-\u003e[c]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:intersectionMaybeAsList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSimilar to \u003ccode\u003e\u003ca\u003eintersectionToList\u003c/a\u003e\u003c/code\u003e, but the result does not include elements in cases where\n the supplied combining comparison returns \u003ccode\u003e(Eq Nothing)\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eComplexity: Not sure, but I'd appreciate it if someone could figure it out.\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "intersectionMaybeToList",
          "package": "AvlTree",
          "signature": "(a -\u003e b -\u003e COrdering (Maybe c)) -\u003e AVL a -\u003e AVL b -\u003e [c] -\u003e [c]",
          "source": "src/Data-Tree-AVL-Set.html#intersectionMaybeToList",
          "type": "function"
        },
        "index": {
          "description": "Similar to intersectionToList but the result does not include elements in cases where the supplied combining comparison returns Eq Nothing Complexity Not sure but appreciate it if someone could figure it out",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "intersectionMaybeToList",
          "normalized": "(a-\u003eb-\u003eCOrdering(Maybe c))-\u003eAVL a-\u003eAVL b-\u003e[c]-\u003e[c]",
          "package": "AvlTree",
          "partial": "Maybe To List",
          "signature": "(a-\u003eb-\u003eCOrdering(Maybe c))-\u003eAVL a-\u003eAVL b-\u003e[c]-\u003e[c]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:intersectionMaybeToList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSimilar to \u003ccode\u003e\u003ca\u003eintersection\u003c/a\u003e\u003c/code\u003e, but prepends the result to the supplied list in\n ascending order. This is a (++) free function which behaves as if defined:\n\u003c/p\u003e\u003cpre\u003eintersectionToList c setA setB cs = asListL (intersection c setA setB) ++ cs\u003c/pre\u003e\u003cp\u003eComplexity: Not sure, but I'd appreciate it if someone could figure it out.\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "intersectionToList",
          "package": "AvlTree",
          "signature": "(a -\u003e b -\u003e COrdering c) -\u003e AVL a -\u003e AVL b -\u003e [c] -\u003e [c]",
          "source": "src/Data-Tree-AVL-Set.html#intersectionToList",
          "type": "function"
        },
        "index": {
          "description": "Similar to intersection but prepends the result to the supplied list in ascending order This is free function which behaves as if defined intersectionToList setA setB cs asListL intersection setA setB cs Complexity Not sure but appreciate it if someone could figure it out",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "intersectionToList",
          "normalized": "(a-\u003eb-\u003eCOrdering c)-\u003eAVL a-\u003eAVL b-\u003e[c]-\u003e[c]",
          "package": "AvlTree",
          "partial": "To List",
          "signature": "(a-\u003eb-\u003eCOrdering c)-\u003eAVL a-\u003eAVL b-\u003e[c]-\u003e[c]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:intersectionToList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eVerify that a tree is height balanced and that the BF of each node is correct.\n\u003c/p\u003e\u003cp\u003eComplexity: O(n)\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "isBalanced",
          "package": "AvlTree",
          "signature": "AVL e -\u003e Bool",
          "source": "src/Data-Tree-AVL-Test-Utils.html#isBalanced",
          "type": "function"
        },
        "index": {
          "description": "Verify that tree is height balanced and that the BF of each node is correct Complexity",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "isBalanced",
          "normalized": "AVL a-\u003eBool",
          "package": "AvlTree",
          "partial": "Balanced",
          "signature": "AVL e-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:isBalanced"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturns \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e if an AVL tree is empty.\n\u003c/p\u003e\u003cp\u003eComplexity: O(1)\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "isEmpty",
          "package": "AvlTree",
          "signature": "AVL e -\u003e Bool",
          "source": "src/Data-Tree-AVL-Types.html#isEmpty",
          "type": "function"
        },
        "index": {
          "description": "Returns True if an AVL tree is empty Complexity",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "isEmpty",
          "normalized": "AVL a-\u003eBool",
          "package": "AvlTree",
          "partial": "Empty",
          "signature": "AVL e-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:isEmpty"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturns \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e if the current element is the leftmost element.\n\u003c/p\u003e\u003cp\u003eComplexity: O(1) average, O(log n) worst case.\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "isLeftmost",
          "package": "AvlTree",
          "signature": "ZAVL e -\u003e Bool",
          "source": "src/Data-Tree-AVL-Zipper.html#isLeftmost",
          "type": "function"
        },
        "index": {
          "description": "Returns True if the current element is the leftmost element Complexity average log worst case",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "isLeftmost",
          "normalized": "ZAVL a-\u003eBool",
          "package": "AvlTree",
          "partial": "Leftmost",
          "signature": "ZAVL e-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:isLeftmost"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturns \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e if an AVL tree is non-empty.\n\u003c/p\u003e\u003cp\u003eComplexity: O(1)\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "isNonEmpty",
          "package": "AvlTree",
          "signature": "AVL e -\u003e Bool",
          "source": "src/Data-Tree-AVL-Types.html#isNonEmpty",
          "type": "function"
        },
        "index": {
          "description": "Returns True if an AVL tree is non-empty Complexity",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "isNonEmpty",
          "normalized": "AVL a-\u003eBool",
          "package": "AvlTree",
          "partial": "Non Empty",
          "signature": "AVL e-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:isNonEmpty"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturns \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e if the current element is the rightmost element.\n\u003c/p\u003e\u003cp\u003eComplexity: O(1) average, O(log n) worst case.\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "isRightmost",
          "package": "AvlTree",
          "signature": "ZAVL e -\u003e Bool",
          "source": "src/Data-Tree-AVL-Zipper.html#isRightmost",
          "type": "function"
        },
        "index": {
          "description": "Returns True if the current element is the rightmost element Complexity average log worst case",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "isRightmost",
          "normalized": "ZAVL a-\u003eBool",
          "package": "AvlTree",
          "partial": "Rightmost",
          "signature": "ZAVL e-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:isRightmost"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eVerify that a tree is sorted.\n\u003c/p\u003e\u003cp\u003eComplexity: O(n)\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "isSorted",
          "package": "AvlTree",
          "signature": "(e -\u003e e -\u003e Ordering) -\u003e AVL e -\u003e Bool",
          "source": "src/Data-Tree-AVL-Test-Utils.html#isSorted",
          "type": "function"
        },
        "index": {
          "description": "Verify that tree is sorted Complexity",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "isSorted",
          "normalized": "(a-\u003ea-\u003eOrdering)-\u003eAVL a-\u003eBool",
          "package": "AvlTree",
          "partial": "Sorted",
          "signature": "(e-\u003ee-\u003eOrdering)-\u003eAVL e-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:isSorted"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eVerify that a tree is sorted, height balanced and the BF of each node is correct.\n\u003c/p\u003e\u003cp\u003eComplexity: O(n)\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "isSortedOK",
          "package": "AvlTree",
          "signature": "(e -\u003e e -\u003e Ordering) -\u003e AVL e -\u003e Bool",
          "source": "src/Data-Tree-AVL-Test-Utils.html#isSortedOK",
          "type": "function"
        },
        "index": {
          "description": "Verify that tree is sorted height balanced and the BF of each node is correct Complexity",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "isSortedOK",
          "normalized": "(a-\u003ea-\u003eOrdering)-\u003eAVL a-\u003eBool",
          "package": "AvlTree",
          "partial": "Sorted OK",
          "signature": "(e-\u003ee-\u003eOrdering)-\u003eAVL e-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:isSortedOK"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUses the supplied comparison to test whether the first set is a subset of the second,\n both sets being represented as sorted AVL trees.  This function returns True if any of\n the following conditions hold..\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e The first set is empty (the empty set is a subset of any set).\n\u003c/li\u003e\u003cli\u003e The two sets are equal.\n\u003c/li\u003e\u003cli\u003e The first set is a proper subset of the second set.\n\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eComplexity: Not sure, but I'd appreciate it if someone could figure it out.\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "isSubsetOf",
          "package": "AvlTree",
          "signature": "(a -\u003e b -\u003e Ordering) -\u003e AVL a -\u003e AVL b -\u003e Bool",
          "source": "src/Data-Tree-AVL-Set.html#isSubsetOf",
          "type": "function"
        },
        "index": {
          "description": "Uses the supplied comparison to test whether the first set is subset of the second both sets being represented as sorted AVL trees This function returns True if any of the following conditions hold The first set is empty the empty set is subset of any set The two sets are equal The first set is proper subset of the second set Complexity Not sure but appreciate it if someone could figure it out",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "isSubsetOf",
          "normalized": "(a-\u003eb-\u003eOrdering)-\u003eAVL a-\u003eAVL b-\u003eBool",
          "package": "AvlTree",
          "partial": "Subset Of",
          "signature": "(a-\u003eb-\u003eOrdering)-\u003eAVL a-\u003eAVL b-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:isSubsetOf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSimilar to \u003ccode\u003e\u003ca\u003eisSubsetOf\u003c/a\u003e\u003c/code\u003e, but also requires that the supplied combining\n comparison returns \u003ccode\u003e(\u003ccode\u003e\u003ca\u003eEq\u003c/a\u003e\u003c/code\u003e True)\u003c/code\u003e for matching elements.\n\u003c/p\u003e\u003cp\u003eComplexity: Not sure, but I'd appreciate it if someone could figure it out.\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "isSubsetOfBy",
          "package": "AvlTree",
          "signature": "(a -\u003e b -\u003e COrdering Bool) -\u003e AVL a -\u003e AVL b -\u003e Bool",
          "source": "src/Data-Tree-AVL-Set.html#isSubsetOfBy",
          "type": "function"
        },
        "index": {
          "description": "Similar to isSubsetOf but also requires that the supplied combining comparison returns Eq True for matching elements Complexity Not sure but appreciate it if someone could figure it out",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "isSubsetOfBy",
          "normalized": "(a-\u003eb-\u003eCOrdering Bool)-\u003eAVL a-\u003eAVL b-\u003eBool",
          "package": "AvlTree",
          "partial": "Subset Of By",
          "signature": "(a-\u003eb-\u003eCOrdering Bool)-\u003eAVL a-\u003eAVL b-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:isSubsetOfBy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eJoin two AVL trees. This is the AVL equivalent of (++).\n\u003c/p\u003e\u003cpre\u003e asListL (l `join` r) = asListL l ++ asListL r\n\u003c/pre\u003e\u003cp\u003eComplexity: O(log n), where n is the size of the larger of the two trees.\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "join",
          "package": "AvlTree",
          "signature": "AVL e -\u003e AVL e -\u003e AVL e",
          "source": "src/Data-Tree-AVL-Join.html#join",
          "type": "function"
        },
        "index": {
          "description": "Join two AVL trees This is the AVL equivalent of asListL join asListL asListL Complexity log where is the size of the larger of the two trees",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "join",
          "normalized": "AVL a-\u003eAVL a-\u003eAVL a",
          "package": "AvlTree",
          "signature": "AVL e-\u003eAVL e-\u003eAVL e",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:join"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eApply a function to every element in an AVL tree. This function preserves the tree shape.\n There is also a strict version of this function (\u003ccode\u003e\u003ca\u003emap'\u003c/a\u003e\u003c/code\u003e).\n\u003c/p\u003e\u003cp\u003eN.B. If the tree is sorted the result of this operation will only be sorted if\n the applied function preserves ordering (for some suitable ordering definition).\n\u003c/p\u003e\u003cp\u003eComplexity: O(n)\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "map",
          "package": "AvlTree",
          "signature": "(a -\u003e b) -\u003e AVL a -\u003e AVL b",
          "source": "src/Data-Tree-AVL-List.html#map",
          "type": "function"
        },
        "index": {
          "description": "Apply function to every element in an AVL tree This function preserves the tree shape There is also strict version of this function map N.B If the tree is sorted the result of this operation will only be sorted if the applied function preserves ordering for some suitable ordering definition Complexity",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "map",
          "normalized": "(a-\u003eb)-\u003eAVL a-\u003eAVL b",
          "package": "AvlTree",
          "signature": "(a-\u003eb)-\u003eAVL a-\u003eAVL b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:map"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSimilar to \u003ccode\u003e\u003ca\u003emap\u003c/a\u003e\u003c/code\u003e, but the supplied function is applied strictly.\n\u003c/p\u003e\u003cp\u003eComplexity: O(n)\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "map'",
          "package": "AvlTree",
          "signature": "(a -\u003e b) -\u003e AVL a -\u003e AVL b",
          "source": "src/Data-Tree-AVL-List.html#map%27",
          "type": "function"
        },
        "index": {
          "description": "Similar to map but the supplied function is applied strictly Complexity",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "map'",
          "normalized": "(a-\u003eb)-\u003eAVL a-\u003eAVL b",
          "package": "AvlTree",
          "signature": "(a-\u003eb)-\u003eAVL a-\u003eAVL b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:map-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis name is \u003cem\u003edeprecated\u003c/em\u003e. Instead use \u003ccode\u003e\u003ca\u003emap\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "mapAVL",
          "package": "AvlTree",
          "signature": "(a -\u003e b) -\u003e AVL a -\u003e AVL b",
          "source": "src/Data-Tree-AVL-Deprecated.html#mapAVL",
          "type": "function"
        },
        "index": {
          "description": "This name is deprecated Instead use map",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "mapAVL",
          "normalized": "(a-\u003eb)-\u003eAVL a-\u003eAVL b",
          "package": "AvlTree",
          "partial": "AVL",
          "signature": "(a-\u003eb)-\u003eAVL a-\u003eAVL b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:mapAVL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis name is \u003cem\u003edeprecated\u003c/em\u003e. Instead use \u003ccode\u003e\u003ca\u003emap'\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "mapAVL'",
          "package": "AvlTree",
          "signature": "(a -\u003e b) -\u003e AVL a -\u003e AVL b",
          "source": "src/Data-Tree-AVL-Deprecated.html#mapAVL%27",
          "type": "function"
        },
        "index": {
          "description": "This name is deprecated Instead use map",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "mapAVL'",
          "normalized": "(a-\u003eb)-\u003eAVL a-\u003eAVL b",
          "package": "AvlTree",
          "partial": "AVL'",
          "signature": "(a-\u003eb)-\u003eAVL a-\u003eAVL b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:mapAVL-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe AVL equivalent of \u003ccode\u003eData.List.mapAccumL\u003c/code\u003e on lists.\n It behaves like a combination of \u003ccode\u003e\u003ca\u003emap\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003efoldl\u003c/a\u003e\u003c/code\u003e.\n It applies a function to each element of a tree, passing an accumulating parameter from\n left to right, and returning a final value of this accumulator together with the new tree.\n\u003c/p\u003e\u003cp\u003eUsing this version with a function that is strict in it's first argument will result in\n O(n) stack use. See \u003ccode\u003e\u003ca\u003emapAccumL'\u003c/a\u003e\u003c/code\u003e for a strict version.\n\u003c/p\u003e\u003cp\u003eComplexity: O(n)\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "mapAccumL",
          "package": "AvlTree",
          "signature": "(z -\u003e a -\u003e (z, b)) -\u003e z -\u003e AVL a -\u003e (z, AVL b)",
          "source": "src/Data-Tree-AVL-List.html#mapAccumL",
          "type": "function"
        },
        "index": {
          "description": "The AVL equivalent of Data.List.mapAccumL on lists It behaves like combination of map and foldl It applies function to each element of tree passing an accumulating parameter from left to right and returning final value of this accumulator together with the new tree Using this version with function that is strict in it first argument will result in stack use See mapAccumL for strict version Complexity",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "mapAccumL",
          "normalized": "(a-\u003eb-\u003e(a,c))-\u003ea-\u003eAVL b-\u003e(a,AVL c)",
          "package": "AvlTree",
          "partial": "Accum",
          "signature": "(z-\u003ea-\u003e(z,b))-\u003ez-\u003eAVL a-\u003e(z,AVL b)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:mapAccumL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis is a strict version of \u003ccode\u003e\u003ca\u003emapAccumL\u003c/a\u003e\u003c/code\u003e, which is useful for functions which\n are strict in their first argument. The advantage of this version is that it reduces\n the stack use from the O(n) that the lazy version gives (when used with strict functions)\n to O(log n).\n\u003c/p\u003e\u003cp\u003eComplexity: O(n)\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "mapAccumL'",
          "package": "AvlTree",
          "signature": "(z -\u003e a -\u003e (z, b)) -\u003e z -\u003e AVL a -\u003e (z, AVL b)",
          "source": "src/Data-Tree-AVL-List.html#mapAccumL%27",
          "type": "function"
        },
        "index": {
          "description": "This is strict version of mapAccumL which is useful for functions which are strict in their first argument The advantage of this version is that it reduces the stack use from the that the lazy version gives when used with strict functions to log Complexity",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "mapAccumL'",
          "normalized": "(a-\u003eb-\u003e(a,c))-\u003ea-\u003eAVL b-\u003e(a,AVL c)",
          "package": "AvlTree",
          "partial": "Accum L'",
          "signature": "(z-\u003ea-\u003e(z,b))-\u003ez-\u003eAVL a-\u003e(z,AVL b)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:mapAccumL-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGlasgow Haskell only. Similar to \u003ccode\u003e\u003ca\u003emapAccumL'\u003c/a\u003e\u003c/code\u003e but uses an unboxed pair in the\n accumulating function.\n\u003c/p\u003e\u003cp\u003eComplexity: O(n)\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "mapAccumL''",
          "package": "AvlTree",
          "signature": "(z -\u003e a -\u003e (#z, b#)) -\u003e z -\u003e AVL a -\u003e (z, AVL b)",
          "source": "src/Data-Tree-AVL-List.html#mapAccumL%27%27",
          "type": "function"
        },
        "index": {
          "description": "Glasgow Haskell only Similar to mapAccumL but uses an unboxed pair in the accumulating function Complexity",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "mapAccumL''",
          "normalized": "(a-\u003eb-\u003e(#z,c #))-\u003ea-\u003eAVL b-\u003e(a,AVL c)",
          "package": "AvlTree",
          "partial": "Accum L''",
          "signature": "(z-\u003ea-\u003e(#z,b #))-\u003ez-\u003eAVL a-\u003e(z,AVL b)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:mapAccumL-39--39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis name is \u003cem\u003edeprecated\u003c/em\u003e. Instead use \u003ccode\u003e\u003ca\u003emapAccumL\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "mapAccumLAVL",
          "package": "AvlTree",
          "signature": "(z -\u003e a -\u003e (z, b)) -\u003e z -\u003e AVL a -\u003e (z, AVL b)",
          "source": "src/Data-Tree-AVL-Deprecated.html#mapAccumLAVL",
          "type": "function"
        },
        "index": {
          "description": "This name is deprecated Instead use mapAccumL",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "mapAccumLAVL",
          "normalized": "(a-\u003eb-\u003e(a,c))-\u003ea-\u003eAVL b-\u003e(a,AVL c)",
          "package": "AvlTree",
          "partial": "Accum LAVL",
          "signature": "(z-\u003ea-\u003e(z,b))-\u003ez-\u003eAVL a-\u003e(z,AVL b)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:mapAccumLAVL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis name is \u003cem\u003edeprecated\u003c/em\u003e. Instead use \u003ccode\u003e\u003ca\u003emapAccumL'\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "mapAccumLAVL'",
          "package": "AvlTree",
          "signature": "(z -\u003e a -\u003e (z, b)) -\u003e z -\u003e AVL a -\u003e (z, AVL b)",
          "source": "src/Data-Tree-AVL-Deprecated.html#mapAccumLAVL%27",
          "type": "function"
        },
        "index": {
          "description": "This name is deprecated Instead use mapAccumL",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "mapAccumLAVL'",
          "normalized": "(a-\u003eb-\u003e(a,c))-\u003ea-\u003eAVL b-\u003e(a,AVL c)",
          "package": "AvlTree",
          "partial": "Accum LAVL'",
          "signature": "(z-\u003ea-\u003e(z,b))-\u003ez-\u003eAVL a-\u003e(z,AVL b)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:mapAccumLAVL-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis name is \u003cem\u003edeprecated\u003c/em\u003e. Instead use \u003ccode\u003e\u003ca\u003emapAccumL''\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "mapAccumLAVL''",
          "package": "AvlTree",
          "signature": "(z -\u003e a -\u003e (#z, b#)) -\u003e z -\u003e AVL a -\u003e (z, AVL b)",
          "source": "src/Data-Tree-AVL-Deprecated.html#mapAccumLAVL%27%27",
          "type": "function"
        },
        "index": {
          "description": "This name is deprecated Instead use mapAccumL",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "mapAccumLAVL''",
          "normalized": "(a-\u003eb-\u003e(#z,c #))-\u003ea-\u003eAVL b-\u003e(a,AVL c)",
          "package": "AvlTree",
          "partial": "Accum LAVL''",
          "signature": "(z-\u003ea-\u003e(#z,b #))-\u003ez-\u003eAVL a-\u003e(z,AVL b)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:mapAccumLAVL-39--39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe AVL equivalent of \u003ccode\u003eData.List.mapAccumR\u003c/code\u003e on lists.\n It behaves like a combination of \u003ccode\u003e\u003ca\u003emap\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003efoldr\u003c/a\u003e\u003c/code\u003e.\n It applies a function to each element of a tree, passing an accumulating parameter from\n right to left, and returning a final value of this accumulator together with the new tree.\n\u003c/p\u003e\u003cp\u003eUsing this version with a function that is strict in it's first argument will result in\n O(n) stack use. See \u003ccode\u003e\u003ca\u003emapAccumR'\u003c/a\u003e\u003c/code\u003e for a strict version.\n\u003c/p\u003e\u003cp\u003eComplexity: O(n)\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "mapAccumR",
          "package": "AvlTree",
          "signature": "(z -\u003e a -\u003e (z, b)) -\u003e z -\u003e AVL a -\u003e (z, AVL b)",
          "source": "src/Data-Tree-AVL-List.html#mapAccumR",
          "type": "function"
        },
        "index": {
          "description": "The AVL equivalent of Data.List.mapAccumR on lists It behaves like combination of map and foldr It applies function to each element of tree passing an accumulating parameter from right to left and returning final value of this accumulator together with the new tree Using this version with function that is strict in it first argument will result in stack use See mapAccumR for strict version Complexity",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "mapAccumR",
          "normalized": "(a-\u003eb-\u003e(a,c))-\u003ea-\u003eAVL b-\u003e(a,AVL c)",
          "package": "AvlTree",
          "partial": "Accum",
          "signature": "(z-\u003ea-\u003e(z,b))-\u003ez-\u003eAVL a-\u003e(z,AVL b)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:mapAccumR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis is a strict version of \u003ccode\u003e\u003ca\u003emapAccumR\u003c/a\u003e\u003c/code\u003e, which is useful for functions which\n are strict in their first argument. The advantage of this version is that it reduces\n the stack use from the O(n) that the lazy version gives (when used with strict functions)\n to O(log n).\n\u003c/p\u003e\u003cp\u003eComplexity: O(n)\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "mapAccumR'",
          "package": "AvlTree",
          "signature": "(z -\u003e a -\u003e (z, b)) -\u003e z -\u003e AVL a -\u003e (z, AVL b)",
          "source": "src/Data-Tree-AVL-List.html#mapAccumR%27",
          "type": "function"
        },
        "index": {
          "description": "This is strict version of mapAccumR which is useful for functions which are strict in their first argument The advantage of this version is that it reduces the stack use from the that the lazy version gives when used with strict functions to log Complexity",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "mapAccumR'",
          "normalized": "(a-\u003eb-\u003e(a,c))-\u003ea-\u003eAVL b-\u003e(a,AVL c)",
          "package": "AvlTree",
          "partial": "Accum R'",
          "signature": "(z-\u003ea-\u003e(z,b))-\u003ez-\u003eAVL a-\u003e(z,AVL b)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:mapAccumR-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGlasgow Haskell only. Similar to \u003ccode\u003e\u003ca\u003emapAccumR'\u003c/a\u003e\u003c/code\u003e but uses an unboxed pair in the\n accumulating function.\n\u003c/p\u003e\u003cp\u003eComplexity: O(n)\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "mapAccumR''",
          "package": "AvlTree",
          "signature": "(z -\u003e a -\u003e (#z, b#)) -\u003e z -\u003e AVL a -\u003e (z, AVL b)",
          "source": "src/Data-Tree-AVL-List.html#mapAccumR%27%27",
          "type": "function"
        },
        "index": {
          "description": "Glasgow Haskell only Similar to mapAccumR but uses an unboxed pair in the accumulating function Complexity",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "mapAccumR''",
          "normalized": "(a-\u003eb-\u003e(#z,c #))-\u003ea-\u003eAVL b-\u003e(a,AVL c)",
          "package": "AvlTree",
          "partial": "Accum R''",
          "signature": "(z-\u003ea-\u003e(#z,b #))-\u003ez-\u003eAVL a-\u003e(z,AVL b)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:mapAccumR-39--39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis name is \u003cem\u003edeprecated\u003c/em\u003e. Instead use \u003ccode\u003e\u003ca\u003emapAccumR\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "mapAccumRAVL",
          "package": "AvlTree",
          "signature": "(z -\u003e a -\u003e (z, b)) -\u003e z -\u003e AVL a -\u003e (z, AVL b)",
          "source": "src/Data-Tree-AVL-Deprecated.html#mapAccumRAVL",
          "type": "function"
        },
        "index": {
          "description": "This name is deprecated Instead use mapAccumR",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "mapAccumRAVL",
          "normalized": "(a-\u003eb-\u003e(a,c))-\u003ea-\u003eAVL b-\u003e(a,AVL c)",
          "package": "AvlTree",
          "partial": "Accum RAVL",
          "signature": "(z-\u003ea-\u003e(z,b))-\u003ez-\u003eAVL a-\u003e(z,AVL b)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:mapAccumRAVL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis name is \u003cem\u003edeprecated\u003c/em\u003e. Instead use \u003ccode\u003e\u003ca\u003emapAccumR'\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "mapAccumRAVL'",
          "package": "AvlTree",
          "signature": "(z -\u003e a -\u003e (z, b)) -\u003e z -\u003e AVL a -\u003e (z, AVL b)",
          "source": "src/Data-Tree-AVL-Deprecated.html#mapAccumRAVL%27",
          "type": "function"
        },
        "index": {
          "description": "This name is deprecated Instead use mapAccumR",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "mapAccumRAVL'",
          "normalized": "(a-\u003eb-\u003e(a,c))-\u003ea-\u003eAVL b-\u003e(a,AVL c)",
          "package": "AvlTree",
          "partial": "Accum RAVL'",
          "signature": "(z-\u003ea-\u003e(z,b))-\u003ez-\u003eAVL a-\u003e(z,AVL b)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:mapAccumRAVL-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis name is \u003cem\u003edeprecated\u003c/em\u003e. Instead use \u003ccode\u003e\u003ca\u003emapAccumR''\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "mapAccumRAVL''",
          "package": "AvlTree",
          "signature": "(z -\u003e a -\u003e (#z, b#)) -\u003e z -\u003e AVL a -\u003e (z, AVL b)",
          "source": "src/Data-Tree-AVL-Deprecated.html#mapAccumRAVL%27%27",
          "type": "function"
        },
        "index": {
          "description": "This name is deprecated Instead use mapAccumR",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "mapAccumRAVL''",
          "normalized": "(a-\u003eb-\u003e(#z,c #))-\u003ea-\u003eAVL b-\u003e(a,AVL c)",
          "package": "AvlTree",
          "partial": "Accum RAVL''",
          "signature": "(z-\u003ea-\u003e(#z,b #))-\u003ez-\u003eAVL a-\u003e(z,AVL b)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:mapAccumRAVL-39--39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRemove all AVL tree elements for which the supplied function returns \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e.\n Element ordering is preserved.\n\u003c/p\u003e\u003cp\u003eComplexity: O(n)\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "mapMaybe",
          "package": "AvlTree",
          "signature": "(a -\u003e Maybe b) -\u003e AVL a -\u003e AVL b",
          "source": "src/Data-Tree-AVL-List.html#mapMaybe",
          "type": "function"
        },
        "index": {
          "description": "Remove all AVL tree elements for which the supplied function returns Nothing Element ordering is preserved Complexity",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "mapMaybe",
          "normalized": "(a-\u003eMaybe b)-\u003eAVL a-\u003eAVL b",
          "package": "AvlTree",
          "partial": "Maybe",
          "signature": "(a-\u003eMaybe b)-\u003eAVL a-\u003eAVL b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:mapMaybe"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis name is \u003cem\u003edeprecated\u003c/em\u003e. Instead use \u003ccode\u003e\u003ca\u003emapMaybe\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "mapMaybeAVL",
          "package": "AvlTree",
          "signature": "(a -\u003e Maybe b) -\u003e AVL a -\u003e AVL b",
          "source": "src/Data-Tree-AVL-Deprecated.html#mapMaybeAVL",
          "type": "function"
        },
        "index": {
          "description": "This name is deprecated Instead use mapMaybe",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "mapMaybeAVL",
          "normalized": "(a-\u003eMaybe b)-\u003eAVL a-\u003eAVL b",
          "package": "AvlTree",
          "partial": "Maybe AVL",
          "signature": "(a-\u003eMaybe b)-\u003eAVL a-\u003eAVL b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:mapMaybeAVL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRemove all AVL tree elements for which the supplied function returns \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e.\n Element ordering is preserved. The resulting tree is flat.\n See \u003ccode\u003e\u003ca\u003emapMaybe\u003c/a\u003e\u003c/code\u003e for an alternative implementation which is probably more efficient.\n\u003c/p\u003e\u003cp\u003eComplexity: O(n)\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "mapMaybeViaList",
          "package": "AvlTree",
          "signature": "(a -\u003e Maybe b) -\u003e AVL a -\u003e AVL b",
          "source": "src/Data-Tree-AVL-List.html#mapMaybeViaList",
          "type": "function"
        },
        "index": {
          "description": "Remove all AVL tree elements for which the supplied function returns Nothing Element ordering is preserved The resulting tree is flat See mapMaybe for an alternative implementation which is probably more efficient Complexity",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "mapMaybeViaList",
          "normalized": "(a-\u003eMaybe b)-\u003eAVL a-\u003eAVL b",
          "package": "AvlTree",
          "partial": "Maybe Via List",
          "signature": "(a-\u003eMaybe b)-\u003eAVL a-\u003eAVL b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:mapMaybeViaList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDetetermine the maximum number of elements in an AVL tree of given height.\n This function satisfies this recurrence relation..\n\u003c/p\u003e\u003cpre\u003e\n maxElements 0 = 0\n maxElements h = 1 + 2 * maxElements (h-1) -- = 2^h-1\n\u003c/pre\u003e",
          "module": "Data.Tree.AVL",
          "name": "maxElements",
          "package": "AvlTree",
          "signature": "Int -\u003e Integer",
          "source": "src/Data-Tree-AVL-Test-Utils.html#maxElements",
          "type": "function"
        },
        "index": {
          "description": "Detetermine the maximum number of elements in an AVL tree of given height This function satisfies this recurrence relation maxElements maxElements maxElements h-1 h-1",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "maxElements",
          "normalized": "Int-\u003eInteger",
          "package": "AvlTree",
          "partial": "Elements",
          "signature": "Int-\u003eInteger",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:maxElements"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDetetermine the minimum number of elements in an AVL tree of given height.\n This function satisfies this recurrence relation..\n\u003c/p\u003e\u003cpre\u003e\n minElements 0 = 0\n minElements 1 = 1\n minElements h = 1 + minElements (h-1) + minElements (h-2)\n            -- = Some weird expression involving the golden ratio\n\u003c/pre\u003e",
          "module": "Data.Tree.AVL",
          "name": "minElements",
          "package": "AvlTree",
          "signature": "Int -\u003e Integer",
          "source": "src/Data-Tree-AVL-Test-Utils.html#minElements",
          "type": "function"
        },
        "index": {
          "description": "Detetermine the minimum number of elements in an AVL tree of given height This function satisfies this recurrence relation minElements minElements minElements minElements h-1 minElements h-2 Some weird expression involving the golden ratio",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "minElements",
          "normalized": "Int-\u003eInteger",
          "package": "AvlTree",
          "partial": "Elements",
          "signature": "Int-\u003eInteger",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:minElements"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA fast alternative implementation for \u003ccode\u003eData.List.nub\u003c/code\u003e.\n Deletes all but the first occurrence of an element from the input list.\n\u003c/p\u003e\u003cp\u003eComplexity: O(n.(log n))\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "nub",
          "package": "AvlTree",
          "signature": "[a] -\u003e [a]",
          "source": "src/Data-Tree-AVL-List.html#nub",
          "type": "function"
        },
        "index": {
          "description": "fast alternative implementation for Data.List.nub Deletes all but the first occurrence of an element from the input list Complexity log",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "nub",
          "normalized": "[a]-\u003e[a]",
          "package": "AvlTree",
          "signature": "[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:nub"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA fast alternative implementation for \u003ccode\u003eData.List.nubBy\u003c/code\u003e.\n Deletes all but the first occurrence of an element from the input list.\n\u003c/p\u003e\u003cp\u003eComplexity: O(n.(log n))\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "nubBy",
          "package": "AvlTree",
          "signature": "(a -\u003e a -\u003e Ordering) -\u003e [a] -\u003e [a]",
          "source": "src/Data-Tree-AVL-List.html#nubBy",
          "type": "function"
        },
        "index": {
          "description": "fast alternative implementation for Data.List.nubBy Deletes all but the first occurrence of an element from the input list Complexity log",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "nubBy",
          "normalized": "(a-\u003ea-\u003eOrdering)-\u003e[a]-\u003e[a]",
          "package": "AvlTree",
          "partial": "By",
          "signature": "(a-\u003ea-\u003eOrdering)-\u003e[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:nubBy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSearch for an element in a \u003cem\u003esorted\u003c/em\u003e \u003ccode\u003e\u003ca\u003eAVL\u003c/a\u003e\u003c/code\u003e tree using the supplied selector.\n Returns a \"full\" \u003ccode\u003e\u003ca\u003eBAVL\u003c/a\u003e\u003c/code\u003e if a matching element was found, otherwise returns an \"empty\" \u003ccode\u003e\u003ca\u003eBAVL\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eComplexity: O(log n)\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "openBAVL",
          "package": "AvlTree",
          "signature": "(e -\u003e Ordering) -\u003e AVL e -\u003e BAVL e",
          "source": "src/Data-Tree-AVL-Zipper.html#openBAVL",
          "type": "function"
        },
        "index": {
          "description": "Search for an element in sorted AVL tree using the supplied selector Returns full BAVL if matching element was found otherwise returns an empty BAVL Complexity log",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "openBAVL",
          "normalized": "(a-\u003eOrdering)-\u003eAVL a-\u003eBAVL a",
          "package": "AvlTree",
          "partial": "BAVL",
          "signature": "(e-\u003eOrdering)-\u003eAVL e-\u003eBAVL e",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:openBAVL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturns \u003ccode\u003e(\u003ccode\u003e\u003ca\u003eRight\u003c/a\u003e\u003c/code\u003e zavl)\u003c/code\u003e if the expected element was found, \u003ccode\u003e(\u003ccode\u003e\u003ca\u003eLeft\u003c/a\u003e\u003c/code\u003e pavl)\u003c/code\u003e if the\n expected element was not found. It's OK to use this function on empty trees.\n\u003c/p\u003e\u003cp\u003eComplexity: O(log n)\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "openEither",
          "package": "AvlTree",
          "signature": "(e -\u003e Ordering) -\u003e AVL e -\u003e Either (PAVL e) (ZAVL e)",
          "source": "src/Data-Tree-AVL-Zipper.html#openEither",
          "type": "function"
        },
        "index": {
          "description": "Returns Right zavl if the expected element was found Left pavl if the expected element was not found It OK to use this function on empty trees Complexity log",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "openEither",
          "normalized": "(a-\u003eOrdering)-\u003eAVL a-\u003eEither(PAVL a)(ZAVL a)",
          "package": "AvlTree",
          "partial": "Either",
          "signature": "(e-\u003eOrdering)-\u003eAVL e-\u003eEither(PAVL e)(ZAVL e)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:openEither"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGet the BinPath of an element using the supplied selector.\n\u003c/p\u003e\u003cp\u003eComplexity: O(log n)\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "openPath",
          "package": "AvlTree",
          "signature": "(e -\u003e Ordering) -\u003e AVL e -\u003e BinPath e",
          "source": "src/Data-Tree-AVL-BinPath.html#openPath",
          "type": "function"
        },
        "index": {
          "description": "Get the BinPath of an element using the supplied selector Complexity log",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "openPath",
          "normalized": "(a-\u003eOrdering)-\u003eAVL a-\u003eBinPath a",
          "package": "AvlTree",
          "partial": "Path",
          "signature": "(e-\u003eOrdering)-\u003eAVL e-\u003eBinPath e",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:openPath"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGet the BinPath of an element using the supplied (combining) selector.\n\u003c/p\u003e\u003cp\u003eComplexity: O(log n)\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "openPathWith",
          "package": "AvlTree",
          "signature": "(e -\u003e COrdering a) -\u003e AVL e -\u003e BinPath a",
          "source": "src/Data-Tree-AVL-BinPath.html#openPathWith",
          "type": "function"
        },
        "index": {
          "description": "Get the BinPath of an element using the supplied combining selector Complexity log",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "openPathWith",
          "normalized": "(a-\u003eCOrdering b)-\u003eAVL a-\u003eBinPath b",
          "package": "AvlTree",
          "partial": "Path With",
          "signature": "(e-\u003eCOrdering a)-\u003eAVL e-\u003eBinPath a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:openPathWith"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreate an AVL tree of two elements, occuring in same order as the arguments.\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "pair",
          "package": "AvlTree",
          "signature": "e -\u003e e -\u003e AVL e",
          "source": "src/Data-Tree-AVL-Types.html#pair",
          "type": "function"
        },
        "index": {
          "description": "Create an AVL tree of two elements occuring in same order as the arguments",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "pair",
          "normalized": "a-\u003ea-\u003eAVL a",
          "package": "AvlTree",
          "signature": "e-\u003ee-\u003eAVL e",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:pair"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePartition an AVL tree using the supplied predicate. The first AVL tree in the\n resulting pair contains all elements for which the predicate is True, the second\n contains all those for which the predicate is False. Element ordering is preserved.\n Both of the resulting trees are flat.\n\u003c/p\u003e\u003cp\u003eComplexity: O(n)\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "partition",
          "package": "AvlTree",
          "signature": "(e -\u003e Bool) -\u003e AVL e -\u003e (AVL e, AVL e)",
          "source": "src/Data-Tree-AVL-List.html#partition",
          "type": "function"
        },
        "index": {
          "description": "Partition an AVL tree using the supplied predicate The first AVL tree in the resulting pair contains all elements for which the predicate is True the second contains all those for which the predicate is False Element ordering is preserved Both of the resulting trees are flat Complexity",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "partition",
          "normalized": "(a-\u003eBool)-\u003eAVL a-\u003e(AVL a,AVL a)",
          "package": "AvlTree",
          "signature": "(e-\u003eBool)-\u003eAVL e-\u003e(AVL e,AVL e)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:partition"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis name is \u003cem\u003edeprecated\u003c/em\u003e. Instead use \u003ccode\u003e\u003ca\u003epartition\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "partitionAVL",
          "package": "AvlTree",
          "signature": "(e -\u003e Bool) -\u003e AVL e -\u003e (AVL e, AVL e)",
          "source": "src/Data-Tree-AVL-Deprecated.html#partitionAVL",
          "type": "function"
        },
        "index": {
          "description": "This name is deprecated Instead use partition",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "partitionAVL",
          "normalized": "(a-\u003eBool)-\u003eAVL a-\u003e(AVL a,AVL a)",
          "package": "AvlTree",
          "partial": "AVL",
          "signature": "(e-\u003eBool)-\u003eAVL e-\u003e(AVL e,AVL e)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:partitionAVL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSimilar to \u003ccode\u003e\u003ca\u003erotateL\u003c/a\u003e\u003c/code\u003e, but returns the rotated element. This function raises an error if\n applied to an empty tree.\n\u003c/p\u003e\u003cp\u003eComplexity: O(log n)\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "popRotateL",
          "package": "AvlTree",
          "signature": "AVL e -\u003e (e, AVL e)",
          "source": "src/Data-Tree-AVL-Split.html#popRotateL",
          "type": "function"
        },
        "index": {
          "description": "Similar to rotateL but returns the rotated element This function raises an error if applied to an empty tree Complexity log",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "popRotateL",
          "normalized": "AVL a-\u003e(a,AVL a)",
          "package": "AvlTree",
          "partial": "Rotate",
          "signature": "AVL e-\u003e(e,AVL e)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:popRotateL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSimilar to \u003ccode\u003e\u003ca\u003erotateR\u003c/a\u003e\u003c/code\u003e, but returns the rotated element. This function raises an error if\n applied to an empty tree.\n\u003c/p\u003e\u003cp\u003eComplexity: O(log n)\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "popRotateR",
          "package": "AvlTree",
          "signature": "AVL e -\u003e (AVL e, e)",
          "source": "src/Data-Tree-AVL-Split.html#popRotateR",
          "type": "function"
        },
        "index": {
          "description": "Similar to rotateR but returns the rotated element This function raises an error if applied to an empty tree Complexity log",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "popRotateR",
          "normalized": "AVL a-\u003e(AVL a,a)",
          "package": "AvlTree",
          "partial": "Rotate",
          "signature": "AVL e-\u003e(AVL e,e)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:popRotateR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGeneral push. This function searches the AVL tree using the supplied selector. If a matching element\n is found it's replaced by the value (\u003ccode\u003ee\u003c/code\u003e) returned in the \u003ccode\u003e(\u003ccode\u003e\u003ca\u003eEq\u003c/a\u003e\u003c/code\u003e e)\u003c/code\u003e constructor returned by the selector.\n If no match is found then the default element value is added at in the appropriate position in the tree.\n\u003c/p\u003e\u003cp\u003eNote that for this to work properly requires that the selector behave as if it were comparing the\n (potentially) new default element with existing tree elements, even if it isn't.\n\u003c/p\u003e\u003cp\u003eNote also that this function is \u003cem\u003enon-strict\u003c/em\u003e in it's second argument (the default value which\n is inserted if the search fails or is discarded if the search succeeds). If you want\n to force evaluation, but only if it's actually incorprated in the tree, then use \u003ccode\u003e\u003ca\u003epush'\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e\u003cp\u003eComplexity: O(log n)\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "push",
          "package": "AvlTree",
          "signature": "(e -\u003e COrdering e) -\u003e e -\u003e AVL e -\u003e AVL e",
          "source": "src/Data-Tree-AVL-Push.html#push",
          "type": "function"
        },
        "index": {
          "description": "General push This function searches the AVL tree using the supplied selector If matching element is found it replaced by the value returned in the Eq constructor returned by the selector If no match is found then the default element value is added at in the appropriate position in the tree Note that for this to work properly requires that the selector behave as if it were comparing the potentially new default element with existing tree elements even if it isn Note also that this function is non-strict in it second argument the default value which is inserted if the search fails or is discarded if the search succeeds If you want to force evaluation but only if it actually incorprated in the tree then use push Complexity log",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "push",
          "normalized": "(a-\u003eCOrdering a)-\u003ea-\u003eAVL a-\u003eAVL a",
          "package": "AvlTree",
          "signature": "(e-\u003eCOrdering e)-\u003ee-\u003eAVL e-\u003eAVL e",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:push"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAlmost identical to \u003ccode\u003e\u003ca\u003epush\u003c/a\u003e\u003c/code\u003e, but this version forces evaluation of the default new element\n (second argument) if no matching element is found. Note that it does \u003cem\u003enot\u003c/em\u003e do this if\n a matching element is found, because in this case the default new element is discarded\n anyway. Note also that it does not force evaluation of any replacement value provided by the\n selector (if it returns Eq). (You have to do that yourself if that's what you want.)\n\u003c/p\u003e\u003cp\u003eComplexity: O(log n)\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "push'",
          "package": "AvlTree",
          "signature": "(e -\u003e COrdering e) -\u003e e -\u003e AVL e -\u003e AVL e",
          "source": "src/Data-Tree-AVL-Push.html#push%27",
          "type": "function"
        },
        "index": {
          "description": "Almost identical to push but this version forces evaluation of the default new element second argument if no matching element is found Note that it does not do this if matching element is found because in this case the default new element is discarded anyway Note also that it does not force evaluation of any replacement value provided by the selector if it returns Eq You have to do that yourself if that what you want Complexity log",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "push'",
          "normalized": "(a-\u003eCOrdering a)-\u003ea-\u003eAVL a-\u003eAVL a",
          "package": "AvlTree",
          "signature": "(e-\u003eCOrdering e)-\u003ee-\u003eAVL e-\u003eAVL e",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:push-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIf the \u003ccode\u003e\u003ca\u003eBAVL\u003c/a\u003e\u003c/code\u003e is \"full\", this function returns the original tree with the corresponding\n element replaced by the new element (first argument). If it's \"empty\" the original tree is returned\n with the new element inserted.\n\u003c/p\u003e\u003cp\u003eComplexity: O(log n)\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "pushBAVL",
          "package": "AvlTree",
          "signature": "e -\u003e BAVL e -\u003e AVL e",
          "source": "src/Data-Tree-AVL-Zipper.html#pushBAVL",
          "type": "function"
        },
        "index": {
          "description": "If the BAVL is full this function returns the original tree with the corresponding element replaced by the new element first argument If it empty the original tree is returned with the new element inserted Complexity log",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "pushBAVL",
          "normalized": "a-\u003eBAVL a-\u003eAVL a",
          "package": "AvlTree",
          "partial": "BAVL",
          "signature": "e-\u003eBAVL e-\u003eAVL e",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:pushBAVL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePush a new element in the leftmost position of an AVL tree. No comparison or searching is involved.\n\u003c/p\u003e\u003cp\u003eComplexity: O(log n)\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "pushL",
          "package": "AvlTree",
          "signature": "e -\u003e AVL e -\u003e AVL e",
          "source": "src/Data-Tree-AVL-Push.html#pushL",
          "type": "function"
        },
        "index": {
          "description": "Push new element in the leftmost position of an AVL tree No comparison or searching is involved Complexity log",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "pushL",
          "normalized": "a-\u003eAVL a-\u003eAVL a",
          "package": "AvlTree",
          "signature": "e-\u003eAVL e-\u003eAVL e",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:pushL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePush the elements of an unsorted List in a sorted AVL tree using the supplied combining comparison.\n\u003c/p\u003e\u003cp\u003eComplexity: O(n.(log (m+n))) where n is the list length, m is the tree size.\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "pushList",
          "package": "AvlTree",
          "signature": "(e -\u003e e -\u003e COrdering e) -\u003e AVL e -\u003e [e] -\u003e AVL e",
          "source": "src/Data-Tree-AVL-List.html#pushList",
          "type": "function"
        },
        "index": {
          "description": "Push the elements of an unsorted List in sorted AVL tree using the supplied combining comparison Complexity log where is the list length is the tree size",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "pushList",
          "normalized": "(a-\u003ea-\u003eCOrdering a)-\u003eAVL a-\u003e[a]-\u003eAVL a",
          "package": "AvlTree",
          "partial": "List",
          "signature": "(e-\u003ee-\u003eCOrdering e)-\u003eAVL e-\u003e[e]-\u003eAVL e",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:pushList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSimilar to \u003ccode\u003e\u003ca\u003epush\u003c/a\u003e\u003c/code\u003e, but returns the original tree if the combining comparison returns\n \u003ccode\u003e(\u003ccode\u003e\u003ca\u003eEq\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e)\u003c/code\u003e. So this function can be used reduce heap burn rate by avoiding duplication\n of nodes on the insertion path. But it may also be marginally slower otherwise.\n\u003c/p\u003e\u003cp\u003eNote that this function is \u003cem\u003enon-strict\u003c/em\u003e in it's second argument (the default value which\n is inserted in the search fails or is discarded if the search succeeds). If you want\n to force evaluation, but only if it's actually incorprated in the tree, then use \u003ccode\u003e\u003ca\u003epushMaybe'\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e\u003cp\u003eComplexity: O(log n)\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "pushMaybe",
          "package": "AvlTree",
          "signature": "(e -\u003e COrdering (Maybe e)) -\u003e e -\u003e AVL e -\u003e AVL e",
          "source": "src/Data-Tree-AVL-Push.html#pushMaybe",
          "type": "function"
        },
        "index": {
          "description": "Similar to push but returns the original tree if the combining comparison returns Eq Nothing So this function can be used reduce heap burn rate by avoiding duplication of nodes on the insertion path But it may also be marginally slower otherwise Note that this function is non-strict in it second argument the default value which is inserted in the search fails or is discarded if the search succeeds If you want to force evaluation but only if it actually incorprated in the tree then use pushMaybe Complexity log",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "pushMaybe",
          "normalized": "(a-\u003eCOrdering(Maybe a))-\u003ea-\u003eAVL a-\u003eAVL a",
          "package": "AvlTree",
          "partial": "Maybe",
          "signature": "(e-\u003eCOrdering(Maybe e))-\u003ee-\u003eAVL e-\u003eAVL e",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:pushMaybe"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAlmost identical to \u003ccode\u003e\u003ca\u003epushMaybe\u003c/a\u003e\u003c/code\u003e, but this version forces evaluation of the default new element\n (second argument) if no matching element is found. Note that it does \u003cem\u003enot\u003c/em\u003e do this if\n a matching element is found, because in this case the default new element is discarded\n anyway.\n\u003c/p\u003e\u003cp\u003eComplexity: O(log n)\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "pushMaybe'",
          "package": "AvlTree",
          "signature": "(e -\u003e COrdering (Maybe e)) -\u003e e -\u003e AVL e -\u003e AVL e",
          "source": "src/Data-Tree-AVL-Push.html#pushMaybe%27",
          "type": "function"
        },
        "index": {
          "description": "Almost identical to pushMaybe but this version forces evaluation of the default new element second argument if no matching element is found Note that it does not do this if matching element is found because in this case the default new element is discarded anyway Complexity log",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "pushMaybe'",
          "normalized": "(a-\u003eCOrdering(Maybe a))-\u003ea-\u003eAVL a-\u003eAVL a",
          "package": "AvlTree",
          "partial": "Maybe'",
          "signature": "(e-\u003eCOrdering(Maybe e))-\u003ee-\u003eAVL e-\u003eAVL e",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:pushMaybe-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePush a new element in the rightmost position of an AVL tree. No comparison or searching is involved.\n\u003c/p\u003e\u003cp\u003eComplexity: O(log n)\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "pushR",
          "package": "AvlTree",
          "signature": "AVL e -\u003e e -\u003e AVL e",
          "source": "src/Data-Tree-AVL-Push.html#pushR",
          "type": "function"
        },
        "index": {
          "description": "Push new element in the rightmost position of an AVL tree No comparison or searching is involved Complexity log",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "pushR",
          "normalized": "AVL a-\u003ea-\u003eAVL a",
          "package": "AvlTree",
          "signature": "AVL e-\u003ee-\u003eAVL e",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:pushR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eOverwrites the current element of a Zipper.\n\u003c/p\u003e\u003cp\u003eComplexity: O(1)\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "putCurrent",
          "package": "AvlTree",
          "signature": "e -\u003e ZAVL e -\u003e ZAVL e",
          "source": "src/Data-Tree-AVL-Zipper.html#putCurrent",
          "type": "function"
        },
        "index": {
          "description": "Overwrites the current element of Zipper Complexity",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "putCurrent",
          "normalized": "a-\u003eZAVL a-\u003eZAVL a",
          "package": "AvlTree",
          "partial": "Current",
          "signature": "e-\u003eZAVL e-\u003eZAVL e",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:putCurrent"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRead the element value from a \"full\" \u003ccode\u003e\u003ca\u003eBAVL\u003c/a\u003e\u003c/code\u003e.\n This function raises an error if applied to an \"empty\" \u003ccode\u003e\u003ca\u003eBAVL\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eComplexity: O(1)\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "readFullBAVL",
          "package": "AvlTree",
          "signature": "BAVL e -\u003e e",
          "source": "src/Data-Tree-AVL-Zipper.html#readFullBAVL",
          "type": "function"
        },
        "index": {
          "description": "Read the element value from full BAVL This function raises an error if applied to an empty BAVL Complexity",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "readFullBAVL",
          "normalized": "BAVL a-\u003ea",
          "package": "AvlTree",
          "partial": "Full BAVL",
          "signature": "BAVL e-\u003ee",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:readFullBAVL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRead a tree element. Assumes the path bits were extracted from \u003ccode\u003e\u003ca\u003eFullBP\u003c/a\u003e\u003c/code\u003e constructor.\n Raises an error if the path leads to an empty tree.\n\u003c/p\u003e\u003cp\u003eComplexity: O(log n)\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "readPath",
          "package": "AvlTree",
          "signature": "Int# -\u003e AVL e -\u003e e",
          "source": "src/Data-Tree-AVL-BinPath.html#readPath",
          "type": "function"
        },
        "index": {
          "description": "Read tree element Assumes the path bits were extracted from FullBP constructor Raises an error if the path leads to an empty tree Complexity log",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "readPath",
          "normalized": "Int #-\u003eAVL a-\u003ea",
          "package": "AvlTree",
          "partial": "Path",
          "signature": "Int #-\u003eAVL e-\u003ee",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:readPath"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstruct a flat AVL tree of size n (n\u003e=0), where all elements are identical.\n\u003c/p\u003e\u003cp\u003eComplexity: O(log n)\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "replicate",
          "package": "AvlTree",
          "signature": "Int -\u003e e -\u003e AVL e",
          "source": "src/Data-Tree-AVL-List.html#replicate",
          "type": "function"
        },
        "index": {
          "description": "Construct flat AVL tree of size where all elements are identical Complexity log",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "replicate",
          "normalized": "Int-\u003ea-\u003eAVL a",
          "package": "AvlTree",
          "signature": "Int-\u003ee-\u003eAVL e",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:replicate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis name is \u003cem\u003edeprecated\u003c/em\u003e. Instead use \u003ccode\u003e\u003ca\u003ereplicate\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "replicateAVL",
          "package": "AvlTree",
          "signature": "Int -\u003e e -\u003e AVL e",
          "source": "src/Data-Tree-AVL-Deprecated.html#replicateAVL",
          "type": "function"
        },
        "index": {
          "description": "This name is deprecated Instead use replicate",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "replicateAVL",
          "normalized": "Int-\u003ea-\u003eAVL a",
          "package": "AvlTree",
          "partial": "AVL",
          "signature": "Int-\u003ee-\u003eAVL e",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:replicateAVL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReverse an AVL tree (swaps and reverses left and right sub-trees).\n The resulting tree is the mirror image of the original.\n\u003c/p\u003e\u003cp\u003eComplexity: O(n)\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "reverse",
          "package": "AvlTree",
          "signature": "AVL e -\u003e AVL e",
          "source": "src/Data-Tree-AVL-List.html#reverse",
          "type": "function"
        },
        "index": {
          "description": "Reverse an AVL tree swaps and reverses left and right sub-trees The resulting tree is the mirror image of the original Complexity",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "reverse",
          "normalized": "AVL a-\u003eAVL a",
          "package": "AvlTree",
          "signature": "AVL e-\u003eAVL e",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:reverse"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis name is \u003cem\u003edeprecated\u003c/em\u003e. Instead use \u003ccode\u003e\u003ca\u003ereverse\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "reverseAVL",
          "package": "AvlTree",
          "signature": "AVL e -\u003e AVL e",
          "source": "src/Data-Tree-AVL-Deprecated.html#reverseAVL",
          "type": "function"
        },
        "index": {
          "description": "This name is deprecated Instead use reverse",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "reverseAVL",
          "normalized": "AVL a-\u003eAVL a",
          "package": "AvlTree",
          "partial": "AVL",
          "signature": "AVL e-\u003eAVL e",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:reverseAVL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRotate an AVL tree left by n places. If s is the size of the tree then ordinarily n\n should be in the range [0..s-1]. However, this function will deliver a correct result\n for any n (n\u003c0 or n\u003e=s), the actual rotation being given by (n `mod` s) in such cases.\n The result of rotating an empty tree is an empty tree.\n\u003c/p\u003e\u003cp\u003eComplexity: O(n)\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "rotateByL",
          "package": "AvlTree",
          "signature": "AVL e -\u003e Int -\u003e AVL e",
          "source": "src/Data-Tree-AVL-Split.html#rotateByL",
          "type": "function"
        },
        "index": {
          "description": "Rotate an AVL tree left by places If is the size of the tree then ordinarily should be in the range s-1 However this function will deliver correct result for any or the actual rotation being given by mod in such cases The result of rotating an empty tree is an empty tree Complexity",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "rotateByL",
          "normalized": "AVL a-\u003eInt-\u003eAVL a",
          "package": "AvlTree",
          "partial": "By",
          "signature": "AVL e-\u003eInt-\u003eAVL e",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:rotateByL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRotate an AVL tree right by n places. If s is the size of the tree then ordinarily n\n should be in the range [0..s-1]. However, this function will deliver a correct result\n for any n (n\u003c0 or n\u003e=s), the actual rotation being given by (n `mod` s) in such cases.\n The result of rotating an empty tree is an empty tree.\n\u003c/p\u003e\u003cp\u003eComplexity: O(n)\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "rotateByR",
          "package": "AvlTree",
          "signature": "AVL e -\u003e Int -\u003e AVL e",
          "source": "src/Data-Tree-AVL-Split.html#rotateByR",
          "type": "function"
        },
        "index": {
          "description": "Rotate an AVL tree right by places If is the size of the tree then ordinarily should be in the range s-1 However this function will deliver correct result for any or the actual rotation being given by mod in such cases The result of rotating an empty tree is an empty tree Complexity",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "rotateByR",
          "normalized": "AVL a-\u003eInt-\u003eAVL a",
          "package": "AvlTree",
          "partial": "By",
          "signature": "AVL e-\u003eInt-\u003eAVL e",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:rotateByR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRotate an AVL tree one place left. This function pops the leftmost element and pushes into\n the rightmost position. An empty tree yields an empty tree.\n\u003c/p\u003e\u003cp\u003eComplexity: O(log n)\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "rotateL",
          "package": "AvlTree",
          "signature": "AVL e -\u003e AVL e",
          "source": "src/Data-Tree-AVL-Split.html#rotateL",
          "type": "function"
        },
        "index": {
          "description": "Rotate an AVL tree one place left This function pops the leftmost element and pushes into the rightmost position An empty tree yields an empty tree Complexity log",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "rotateL",
          "normalized": "AVL a-\u003eAVL a",
          "package": "AvlTree",
          "signature": "AVL e-\u003eAVL e",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:rotateL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRotate an AVL tree one place right. This function pops the rightmost element and pushes into\n the leftmost position. An empty tree yields an empty tree.\n\u003c/p\u003e\u003cp\u003eComplexity: O(log n)\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "rotateR",
          "package": "AvlTree",
          "signature": "AVL e -\u003e AVL e",
          "source": "src/Data-Tree-AVL-Split.html#rotateR",
          "type": "function"
        },
        "index": {
          "description": "Rotate an AVL tree one place right This function pops the rightmost element and pushes into the leftmost position An empty tree yields an empty tree Complexity log",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "rotateR",
          "normalized": "AVL a-\u003eAVL a",
          "package": "AvlTree",
          "signature": "AVL e-\u003eAVL e",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:rotateR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreates an AVL tree with just one element.\n\u003c/p\u003e\u003cp\u003eComplexity: O(1)\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "singleton",
          "package": "AvlTree",
          "signature": "e -\u003e AVL e",
          "source": "src/Data-Tree-AVL-Types.html#singleton",
          "type": "function"
        },
        "index": {
          "description": "Creates an AVL tree with just one element Complexity",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "singleton",
          "normalized": "a-\u003eAVL a",
          "package": "AvlTree",
          "signature": "e-\u003eAVL e",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:singleton"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA convenience wrapper for \u003ccode\u003e\u003ca\u003eaddSize#\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "size",
          "package": "AvlTree",
          "signature": "AVL e -\u003e Int",
          "source": "src/Data-Tree-AVL-Size.html#size",
          "type": "function"
        },
        "index": {
          "description": "convenience wrapper for addSize",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "size",
          "normalized": "AVL a-\u003eInt",
          "package": "AvlTree",
          "signature": "AVL e-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:size"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA convenience wrapper for \u003ccode\u003e\u003ca\u003eaddSize#\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "size#",
          "package": "AvlTree",
          "signature": "AVL e -\u003e Int#",
          "source": "src/Data-Tree-AVL-Size.html#size%23",
          "type": "function"
        },
        "index": {
          "description": "convenience wrapper for addSize",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "size#",
          "normalized": "AVL a-\u003eInt #",
          "package": "AvlTree",
          "signature": "AVL e-\u003eInt #",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:size-35-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCounts the number of elements to the left of the current element\n (this does not include the current element).\n\u003c/p\u003e\u003cp\u003eComplexity: O(n), where n is the count result.\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "sizeL",
          "package": "AvlTree",
          "signature": "ZAVL e -\u003e Int",
          "source": "src/Data-Tree-AVL-Zipper.html#sizeL",
          "type": "function"
        },
        "index": {
          "description": "Counts the number of elements to the left of the current element this does not include the current element Complexity where is the count result",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "sizeL",
          "normalized": "ZAVL a-\u003eInt",
          "package": "AvlTree",
          "signature": "ZAVL e-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:sizeL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCounts the number of elements to the right of the current element\n (this does not include the current element).\n\u003c/p\u003e\u003cp\u003eComplexity: O(n), where n is the count result.\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "sizeR",
          "package": "AvlTree",
          "signature": "ZAVL e -\u003e Int",
          "source": "src/Data-Tree-AVL-Zipper.html#sizeR",
          "type": "function"
        },
        "index": {
          "description": "Counts the number of elements to the right of the current element this does not include the current element Complexity where is the count result",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "sizeR",
          "normalized": "ZAVL a-\u003eInt",
          "package": "AvlTree",
          "signature": "ZAVL e-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:sizeR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCounts the total number of elements in a ZAVL.\n\u003c/p\u003e\u003cp\u003eComplexity: O(n)\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "sizeZAVL",
          "package": "AvlTree",
          "signature": "ZAVL e -\u003e Int",
          "source": "src/Data-Tree-AVL-Zipper.html#sizeZAVL",
          "type": "function"
        },
        "index": {
          "description": "Counts the total number of elements in ZAVL Complexity",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "sizeZAVL",
          "normalized": "ZAVL a-\u003eInt",
          "package": "AvlTree",
          "partial": "ZAVL",
          "signature": "ZAVL e-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:sizeZAVL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSpan an AVL tree from the left, using the supplied predicate. This function returns\n a pair of trees (l,r), where l contains the leftmost consecutive elements which\n satisfy the predicate. The leftmost element of r (if any) is the first to fail\n the predicate. Either of the resulting trees may be empty. Element ordering is preserved.\n\u003c/p\u003e\u003cp\u003eComplexity: O(n), where n is the size of l.\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "spanL",
          "package": "AvlTree",
          "signature": "(e -\u003e Bool) -\u003e AVL e -\u003e (AVL e, AVL e)",
          "source": "src/Data-Tree-AVL-Split.html#spanL",
          "type": "function"
        },
        "index": {
          "description": "Span an AVL tree from the left using the supplied predicate This function returns pair of trees where contains the leftmost consecutive elements which satisfy the predicate The leftmost element of if any is the first to fail the predicate Either of the resulting trees may be empty Element ordering is preserved Complexity where is the size of",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "spanL",
          "normalized": "(a-\u003eBool)-\u003eAVL a-\u003e(AVL a,AVL a)",
          "package": "AvlTree",
          "signature": "(e-\u003eBool)-\u003eAVL e-\u003e(AVL e,AVL e)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:spanL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSpan an AVL tree from the right, using the supplied predicate. This function returns\n a pair of trees (l,r), where r contains the rightmost consecutive elements which\n satisfy the predicate. The rightmost element of l (if any) is the first to fail\n the predicate. Either of the resulting trees may be empty. Element ordering is preserved.\n\u003c/p\u003e\u003cp\u003eComplexity: O(n), where n is the size of r.\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "spanR",
          "package": "AvlTree",
          "signature": "(e -\u003e Bool) -\u003e AVL e -\u003e (AVL e, AVL e)",
          "source": "src/Data-Tree-AVL-Split.html#spanR",
          "type": "function"
        },
        "index": {
          "description": "Span an AVL tree from the right using the supplied predicate This function returns pair of trees where contains the rightmost consecutive elements which satisfy the predicate The rightmost element of if any is the first to fail the predicate Either of the resulting trees may be empty Element ordering is preserved Complexity where is the size of",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "spanR",
          "normalized": "(a-\u003eBool)-\u003eAVL a-\u003e(AVL a,AVL a)",
          "package": "AvlTree",
          "signature": "(e-\u003eBool)-\u003eAVL e-\u003e(AVL e,AVL e)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:spanR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSplit an AVL tree from the Left. The \u003ccode\u003e\u003ca\u003eInt\u003c/a\u003e\u003c/code\u003e argument n (n \u003e= 0) specifies the split point.\n This function raises an error if n is negative.\n\u003c/p\u003e\u003cp\u003eIf the tree size is greater than n the result is (Right (l,r)) where l contains\n the leftmost n elements and r contains the remaining rightmost elements (r will be non-empty).\n\u003c/p\u003e\u003cp\u003eIf the tree size is less than or equal to n then the result is (Left s), where s is tree size.\n\u003c/p\u003e\u003cp\u003eAn empty tree will always yield a result of (Left 0).\n\u003c/p\u003e\u003cp\u003eComplexity: O(n)\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "splitAtL",
          "package": "AvlTree",
          "signature": "Int -\u003e AVL e -\u003e Either Int (AVL e, AVL e)",
          "source": "src/Data-Tree-AVL-Split.html#splitAtL",
          "type": "function"
        },
        "index": {
          "description": "Split an AVL tree from the Left The Int argument specifies the split point This function raises an error if is negative If the tree size is greater than the result is Right where contains the leftmost elements and contains the remaining rightmost elements will be non-empty If the tree size is less than or equal to then the result is Left where is tree size An empty tree will always yield result of Left Complexity",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "splitAtL",
          "normalized": "Int-\u003eAVL a-\u003eEither Int(AVL a,AVL a)",
          "package": "AvlTree",
          "partial": "At",
          "signature": "Int-\u003eAVL e-\u003eEither Int(AVL e,AVL e)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:splitAtL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSplit an AVL tree from the Right. The \u003ccode\u003e\u003ca\u003eInt\u003c/a\u003e\u003c/code\u003e argument n (n \u003e= 0) specifies the split point.\n This function raises an error if n is negative.\n\u003c/p\u003e\u003cp\u003eIf the tree size is greater than n the result is (Right (l,r)) where r contains\n the rightmost n elements and l contains the remaining leftmost elements (l will be non-empty).\n\u003c/p\u003e\u003cp\u003eIf the tree size is less than or equal to n then the result is (Left s), where s is tree size.\n\u003c/p\u003e\u003cp\u003eAn empty tree will always yield a result of (Left 0).\n\u003c/p\u003e\u003cp\u003eComplexity: O(n)\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "splitAtR",
          "package": "AvlTree",
          "signature": "Int -\u003e AVL e -\u003e Either Int (AVL e, AVL e)",
          "source": "src/Data-Tree-AVL-Split.html#splitAtR",
          "type": "function"
        },
        "index": {
          "description": "Split an AVL tree from the Right The Int argument specifies the split point This function raises an error if is negative If the tree size is greater than the result is Right where contains the rightmost elements and contains the remaining leftmost elements will be non-empty If the tree size is less than or equal to then the result is Left where is tree size An empty tree will always yield result of Left Complexity",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "splitAtR",
          "normalized": "Int-\u003eAVL a-\u003eEither Int(AVL a,AVL a)",
          "package": "AvlTree",
          "partial": "At",
          "signature": "Int-\u003eAVL e-\u003eEither Int(AVL e,AVL e)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:splitAtR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe symmetric difference is the set of elements which occur in one set or the other but \u003cem\u003enot both\u003c/em\u003e.\n\u003c/p\u003e\u003cp\u003eComplexity: Not sure, but I'd appreciate it if someone could figure it out.\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "symDifference",
          "package": "AvlTree",
          "signature": "(e -\u003e e -\u003e Ordering) -\u003e AVL e -\u003e AVL e -\u003e AVL e",
          "source": "src/Data-Tree-AVL-Set.html#symDifference",
          "type": "function"
        },
        "index": {
          "description": "The symmetric difference is the set of elements which occur in one set or the other but not both Complexity Not sure but appreciate it if someone could figure it out",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "symDifference",
          "normalized": "(a-\u003ea-\u003eOrdering)-\u003eAVL a-\u003eAVL a-\u003eAVL a",
          "package": "AvlTree",
          "partial": "Difference",
          "signature": "(e-\u003ee-\u003eOrdering)-\u003eAVL e-\u003eAVL e-\u003eAVL e",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:symDifference"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis is a simplified version of \u003ccode\u003e\u003ca\u003eforkR\u003c/a\u003e\u003c/code\u003e which returns a sorted tree containing\n only those elements which are greater or equal to according to the supplied selector.\n This function also has the synonym \u003ccode\u003e\u003ca\u003edropLT\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eComplexity: O(log n)\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "takeGE",
          "package": "AvlTree",
          "signature": "(e -\u003e Ordering) -\u003e AVL e -\u003e AVL e",
          "source": "src/Data-Tree-AVL-Split.html#takeGE",
          "type": "function"
        },
        "index": {
          "description": "This is simplified version of forkR which returns sorted tree containing only those elements which are greater or equal to according to the supplied selector This function also has the synonym dropLT Complexity log",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "takeGE",
          "normalized": "(a-\u003eOrdering)-\u003eAVL a-\u003eAVL a",
          "package": "AvlTree",
          "partial": "GE",
          "signature": "(e-\u003eOrdering)-\u003eAVL e-\u003eAVL e",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:takeGE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis is a simplified version of \u003ccode\u003e\u003ca\u003eforkL\u003c/a\u003e\u003c/code\u003e which returns a sorted tree containing\n only those elements which are greater according to the supplied selector.\n This function also has the synonym \u003ccode\u003e\u003ca\u003edropLE\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eComplexity: O(log n)\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "takeGT",
          "package": "AvlTree",
          "signature": "(e -\u003e Ordering) -\u003e AVL e -\u003e AVL e",
          "source": "src/Data-Tree-AVL-Split.html#takeGT",
          "type": "function"
        },
        "index": {
          "description": "This is simplified version of forkL which returns sorted tree containing only those elements which are greater according to the supplied selector This function also has the synonym dropLE Complexity log",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "takeGT",
          "normalized": "(a-\u003eOrdering)-\u003eAVL a-\u003eAVL a",
          "package": "AvlTree",
          "partial": "GT",
          "signature": "(e-\u003eOrdering)-\u003eAVL e-\u003eAVL e",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:takeGT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis is a simplified version of \u003ccode\u003e\u003ca\u003esplitAtL\u003c/a\u003e\u003c/code\u003e which does not return the remaining tree.\n The \u003ccode\u003e\u003ca\u003eInt\u003c/a\u003e\u003c/code\u003e argument n (n \u003e= 0) specifies the number of elements to take (from the left).\n This function raises an error if n is negative.\n\u003c/p\u003e\u003cp\u003eIf the tree size is greater than n the result is (Right l) where l contains\n the leftmost n elements.\n\u003c/p\u003e\u003cp\u003eIf the tree size is less than or equal to n then the result is (Left s), where s is tree size.\n\u003c/p\u003e\u003cp\u003eAn empty tree will always yield a result of (Left 0).\n\u003c/p\u003e\u003cp\u003eComplexity: O(n)\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "takeL",
          "package": "AvlTree",
          "signature": "Int -\u003e AVL e -\u003e Either Int (AVL e)",
          "source": "src/Data-Tree-AVL-Split.html#takeL",
          "type": "function"
        },
        "index": {
          "description": "This is simplified version of splitAtL which does not return the remaining tree The Int argument specifies the number of elements to take from the left This function raises an error if is negative If the tree size is greater than the result is Right where contains the leftmost elements If the tree size is less than or equal to then the result is Left where is tree size An empty tree will always yield result of Left Complexity",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "takeL",
          "normalized": "Int-\u003eAVL a-\u003eEither Int(AVL a)",
          "package": "AvlTree",
          "signature": "Int-\u003eAVL e-\u003eEither Int(AVL e)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:takeL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis is a simplified version of \u003ccode\u003e\u003ca\u003eforkL\u003c/a\u003e\u003c/code\u003e which returns a sorted tree containing\n only those elements which are less than or equal to according to the supplied selector.\n This function also has the synonym \u003ccode\u003e\u003ca\u003edropGT\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eComplexity: O(log n)\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "takeLE",
          "package": "AvlTree",
          "signature": "(e -\u003e Ordering) -\u003e AVL e -\u003e AVL e",
          "source": "src/Data-Tree-AVL-Split.html#takeLE",
          "type": "function"
        },
        "index": {
          "description": "This is simplified version of forkL which returns sorted tree containing only those elements which are less than or equal to according to the supplied selector This function also has the synonym dropGT Complexity log",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "takeLE",
          "normalized": "(a-\u003eOrdering)-\u003eAVL a-\u003eAVL a",
          "package": "AvlTree",
          "partial": "LE",
          "signature": "(e-\u003eOrdering)-\u003eAVL e-\u003eAVL e",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:takeLE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis is a simplified version of \u003ccode\u003e\u003ca\u003eforkR\u003c/a\u003e\u003c/code\u003e which returns a sorted tree containing\n only those elements which are less than according to the supplied selector.\n This function also has the synonym \u003ccode\u003e\u003ca\u003edropGE\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eComplexity: O(log n)\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "takeLT",
          "package": "AvlTree",
          "signature": "(e -\u003e Ordering) -\u003e AVL e -\u003e AVL e",
          "source": "src/Data-Tree-AVL-Split.html#takeLT",
          "type": "function"
        },
        "index": {
          "description": "This is simplified version of forkR which returns sorted tree containing only those elements which are less than according to the supplied selector This function also has the synonym dropGE Complexity log",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "takeLT",
          "normalized": "(a-\u003eOrdering)-\u003eAVL a-\u003eAVL a",
          "package": "AvlTree",
          "partial": "LT",
          "signature": "(e-\u003eOrdering)-\u003eAVL e-\u003eAVL e",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:takeLT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis is a simplified version of \u003ccode\u003e\u003ca\u003esplitAtR\u003c/a\u003e\u003c/code\u003e which does not return the remaining tree.\n The \u003ccode\u003e\u003ca\u003eInt\u003c/a\u003e\u003c/code\u003e argument n (n \u003e= 0) specifies the number of elements to take (from the right).\n This function raises an error if n is negative.\n\u003c/p\u003e\u003cp\u003eIf the tree size is greater than n the result is (Right r) where r contains\n the rightmost n elements.\n\u003c/p\u003e\u003cp\u003eIf the tree size is less than or equal to n then the result is (Left s), where s is tree size.\n\u003c/p\u003e\u003cp\u003eAn empty tree will always yield a result of (Left 0).\n\u003c/p\u003e\u003cp\u003eComplexity: O(n)\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "takeR",
          "package": "AvlTree",
          "signature": "Int -\u003e AVL e -\u003e Either Int (AVL e)",
          "source": "src/Data-Tree-AVL-Split.html#takeR",
          "type": "function"
        },
        "index": {
          "description": "This is simplified version of splitAtR which does not return the remaining tree The Int argument specifies the number of elements to take from the right This function raises an error if is negative If the tree size is greater than the result is Right where contains the rightmost elements If the tree size is less than or equal to then the result is Left where is tree size An empty tree will always yield result of Left Complexity",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "takeR",
          "normalized": "Int-\u003eAVL a-\u003eEither Int(AVL a)",
          "package": "AvlTree",
          "signature": "Int-\u003eAVL e-\u003eEither Int(AVL e)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:takeR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis is a simplified version of \u003ccode\u003e\u003ca\u003espanL\u003c/a\u003e\u003c/code\u003e which does not return the remaining tree\n The result is the leftmost consecutive sequence of elements which satisfy the\n supplied predicate (which may be empty).\n\u003c/p\u003e\u003cp\u003eComplexity: O(n), where n is the size of the result.\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "takeWhileL",
          "package": "AvlTree",
          "signature": "(e -\u003e Bool) -\u003e AVL e -\u003e AVL e",
          "source": "src/Data-Tree-AVL-Split.html#takeWhileL",
          "type": "function"
        },
        "index": {
          "description": "This is simplified version of spanL which does not return the remaining tree The result is the leftmost consecutive sequence of elements which satisfy the supplied predicate which may be empty Complexity where is the size of the result",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "takeWhileL",
          "normalized": "(a-\u003eBool)-\u003eAVL a-\u003eAVL a",
          "package": "AvlTree",
          "partial": "While",
          "signature": "(e-\u003eBool)-\u003eAVL e-\u003eAVL e",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:takeWhileL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis is a simplified version of \u003ccode\u003e\u003ca\u003espanR\u003c/a\u003e\u003c/code\u003e which does not return the remaining tree\n The result is the rightmost consecutive sequence of elements which satisfy the\n supplied predicate (which may be empty).\n\u003c/p\u003e\u003cp\u003eComplexity: O(n), where n is the size of the result.\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "takeWhileR",
          "package": "AvlTree",
          "signature": "(e -\u003e Bool) -\u003e AVL e -\u003e AVL e",
          "source": "src/Data-Tree-AVL-Split.html#takeWhileR",
          "type": "function"
        },
        "index": {
          "description": "This is simplified version of spanR which does not return the remaining tree The result is the rightmost consecutive sequence of elements which satisfy the supplied predicate which may be empty Complexity where is the size of the result",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "takeWhileR",
          "normalized": "(a-\u003eBool)-\u003eAVL a-\u003eAVL a",
          "package": "AvlTree",
          "partial": "While",
          "signature": "(e-\u003eBool)-\u003eAVL e-\u003eAVL e",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:takeWhileR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eJoin the AVL tree contents to an existing list in left to right order.\n This is a ++ free function which behaves as if defined thusly..\n\u003c/p\u003e\u003cpre\u003e avl `toListL` as = (asListL avl) ++ as\n\u003c/pre\u003e\u003cp\u003eComplexity: O(n)\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "toListL",
          "package": "AvlTree",
          "signature": "AVL e -\u003e [e] -\u003e [e]",
          "source": "src/Data-Tree-AVL-List.html#toListL",
          "type": "function"
        },
        "index": {
          "description": "Join the AVL tree contents to an existing list in left to right order This is free function which behaves as if defined thusly avl toListL as asListL avl as Complexity",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "toListL",
          "normalized": "AVL a-\u003e[a]-\u003e[a]",
          "package": "AvlTree",
          "partial": "List",
          "signature": "AVL e-\u003e[e]-\u003e[e]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:toListL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eJoin the AVL tree contents to an existing list in right to left order.\n This is a ++ free function which behaves as if defined thusly..\n\u003c/p\u003e\u003cpre\u003e avl `toListR` as = (asListR avl) ++ as\n\u003c/pre\u003e\u003cp\u003eComplexity: O(n)\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "toListR",
          "package": "AvlTree",
          "signature": "AVL e -\u003e [e] -\u003e [e]",
          "source": "src/Data-Tree-AVL-List.html#toListR",
          "type": "function"
        },
        "index": {
          "description": "Join the AVL tree contents to an existing list in right to left order This is free function which behaves as if defined thusly avl toListR as asListR avl as Complexity",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "toListR",
          "normalized": "AVL a-\u003e[a]-\u003e[a]",
          "package": "AvlTree",
          "partial": "List",
          "signature": "AVL e-\u003e[e]-\u003e[e]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:toListR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis is the non-overloaded version of the \u003ccode\u003eData.Traversable.traverse\u003c/code\u003e method for AVL trees.\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "traverseAVL",
          "package": "AvlTree",
          "signature": "(a -\u003e f b) -\u003e AVL a -\u003e f (AVL b)",
          "source": "src/Data-Tree-AVL-List.html#traverseAVL",
          "type": "function"
        },
        "index": {
          "description": "This is the non-overloaded version of the Data.Traversable.traverse method for AVL trees",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "traverseAVL",
          "normalized": "(a-\u003eb c)-\u003eAVL a-\u003eb(AVL c)",
          "package": "AvlTree",
          "partial": "AVL",
          "signature": "(a-\u003ef b)-\u003eAVL a-\u003ef(AVL b)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:traverseAVL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTry to delete the left-most element of a \u003cem\u003enon-empty\u003c/em\u003e AVL tree. If the tree is sorted this will be the\n least element. This function returns \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e if it's argument is an empty tree.\n\u003c/p\u003e\u003cp\u003eComplexity: O(log n)\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "tryDelL",
          "package": "AvlTree",
          "signature": "AVL e -\u003e Maybe (AVL e)",
          "source": "src/Data-Tree-AVL-Delete.html#tryDelL",
          "type": "function"
        },
        "index": {
          "description": "Try to delete the left-most element of non-empty AVL tree If the tree is sorted this will be the least element This function returns Nothing if it argument is an empty tree Complexity log",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "tryDelL",
          "normalized": "AVL a-\u003eMaybe(AVL a)",
          "package": "AvlTree",
          "partial": "Del",
          "signature": "AVL e-\u003eMaybe(AVL e)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:tryDelL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAttempts to delete the current element and move one step left.\n This function returns \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e if the current element is already the leftmost element.\n\u003c/p\u003e\u003cp\u003eComplexity: O(1) average, O(log n) worst case.\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "tryDelMoveL",
          "package": "AvlTree",
          "signature": "ZAVL e -\u003e Maybe (ZAVL e)",
          "source": "src/Data-Tree-AVL-Zipper.html#tryDelMoveL",
          "type": "function"
        },
        "index": {
          "description": "Attempts to delete the current element and move one step left This function returns Nothing if the current element is already the leftmost element Complexity average log worst case",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "tryDelMoveL",
          "normalized": "ZAVL a-\u003eMaybe(ZAVL a)",
          "package": "AvlTree",
          "partial": "Del Move",
          "signature": "ZAVL e-\u003eMaybe(ZAVL e)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:tryDelMoveL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAttempts to delete the current element and move one step right.\n This function returns \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e if the current element is already the rightmost element.\n\u003c/p\u003e\u003cp\u003eComplexity: O(1) average, O(log n) worst case.\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "tryDelMoveR",
          "package": "AvlTree",
          "signature": "ZAVL e -\u003e Maybe (ZAVL e)",
          "source": "src/Data-Tree-AVL-Zipper.html#tryDelMoveR",
          "type": "function"
        },
        "index": {
          "description": "Attempts to delete the current element and move one step right This function returns Nothing if the current element is already the rightmost element Complexity average log worst case",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "tryDelMoveR",
          "normalized": "ZAVL a-\u003eMaybe(ZAVL a)",
          "package": "AvlTree",
          "partial": "Del Move",
          "signature": "ZAVL e-\u003eMaybe(ZAVL e)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:tryDelMoveR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTry to delete the right-most element of a \u003cem\u003enon-empty\u003c/em\u003e AVL tree. If the tree is sorted this will be the\n greatest element. This function returns \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e if it's argument is an empty tree.\n\u003c/p\u003e\u003cp\u003eComplexity: O(log n)\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "tryDelR",
          "package": "AvlTree",
          "signature": "AVL e -\u003e Maybe (AVL e)",
          "source": "src/Data-Tree-AVL-Delete.html#tryDelR",
          "type": "function"
        },
        "index": {
          "description": "Try to delete the right-most element of non-empty AVL tree If the tree is sorted this will be the greatest element This function returns Nothing if it argument is an empty tree Complexity log",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "tryDelR",
          "normalized": "AVL a-\u003eMaybe(AVL a)",
          "package": "AvlTree",
          "partial": "Del",
          "signature": "AVL e-\u003eMaybe(AVL e)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:tryDelR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIf the AVL tree is a singleton (has only one element \u003ccode\u003ee\u003c/code\u003e) then this function returns \u003ccode\u003e(\u003ccode\u003e\u003ca\u003eJust\u003c/a\u003e\u003c/code\u003e e)\u003c/code\u003e.\n Otherwise it returns Nothing.\n\u003c/p\u003e\u003cp\u003eComplexity: O(1)\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "tryGetSingleton",
          "package": "AvlTree",
          "signature": "AVL e -\u003e Maybe e",
          "source": "src/Data-Tree-AVL-Types.html#tryGetSingleton",
          "type": "function"
        },
        "index": {
          "description": "If the AVL tree is singleton has only one element then this function returns Just Otherwise it returns Nothing Complexity",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "tryGetSingleton",
          "normalized": "AVL a-\u003eMaybe a",
          "package": "AvlTree",
          "partial": "Get Singleton",
          "signature": "AVL e-\u003eMaybe e",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:tryGetSingleton"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAttempts to move one step left.\n This function returns \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e if the current element is already the leftmost element.\n\u003c/p\u003e\u003cp\u003eComplexity: O(1) average, O(log n) worst case.\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "tryMoveL",
          "package": "AvlTree",
          "signature": "ZAVL e -\u003e Maybe (ZAVL e)",
          "source": "src/Data-Tree-AVL-Zipper.html#tryMoveL",
          "type": "function"
        },
        "index": {
          "description": "Attempts to move one step left This function returns Nothing if the current element is already the leftmost element Complexity average log worst case",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "tryMoveL",
          "normalized": "ZAVL a-\u003eMaybe(ZAVL a)",
          "package": "AvlTree",
          "partial": "Move",
          "signature": "ZAVL e-\u003eMaybe(ZAVL e)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:tryMoveL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAttempts to move one step right.\n This function returns \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e if the current element is already the rightmost element.\n\u003c/p\u003e\u003cp\u003eComplexity: O(1) average, O(log n) worst case.\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "tryMoveR",
          "package": "AvlTree",
          "signature": "ZAVL e -\u003e Maybe (ZAVL e)",
          "source": "src/Data-Tree-AVL-Zipper.html#tryMoveR",
          "type": "function"
        },
        "index": {
          "description": "Attempts to move one step right This function returns Nothing if the current element is already the rightmost element Complexity average log worst case",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "tryMoveR",
          "normalized": "ZAVL a-\u003eMaybe(ZAVL a)",
          "package": "AvlTree",
          "partial": "Move",
          "signature": "ZAVL e-\u003eMaybe(ZAVL e)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:tryMoveR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAttempts to open a sorted AVL tree at the element given by the supplied selector.\n This function returns \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e if there is no such element.\n\u003c/p\u003e\u003cp\u003eNote that this operation will still create a zipper path structure on the heap (which\n is promptly discarded) if the search fails, and so is potentially inefficient if failure\n is likely. In cases like this it may be better to use \u003ccode\u003e\u003ca\u003eopenBAVL\u003c/a\u003e\u003c/code\u003e, test for \"fullness\"\n using \u003ccode\u003e\u003ca\u003efullBAVL\u003c/a\u003e\u003c/code\u003e and then convert to a \u003ccode\u003e\u003ca\u003eZAVL\u003c/a\u003e\u003c/code\u003e using \u003ccode\u003e\u003ca\u003efullBAVLtoZAVL\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eComplexity: O(log n)\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "tryOpen",
          "package": "AvlTree",
          "signature": "(e -\u003e Ordering) -\u003e AVL e -\u003e Maybe (ZAVL e)",
          "source": "src/Data-Tree-AVL-Zipper.html#tryOpen",
          "type": "function"
        },
        "index": {
          "description": "Attempts to open sorted AVL tree at the element given by the supplied selector This function returns Nothing if there is no such element Note that this operation will still create zipper path structure on the heap which is promptly discarded if the search fails and so is potentially inefficient if failure is likely In cases like this it may be better to use openBAVL test for fullness using fullBAVL and then convert to ZAVL using fullBAVLtoZAVL Complexity log",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "tryOpen",
          "normalized": "(a-\u003eOrdering)-\u003eAVL a-\u003eMaybe(ZAVL a)",
          "package": "AvlTree",
          "partial": "Open",
          "signature": "(e-\u003eOrdering)-\u003eAVL e-\u003eMaybe(ZAVL e)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:tryOpen"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAttempts to open a sorted AVL tree at the least element which is greater than or equal, according to\n the supplied selector. This function returns \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e if the tree does not contain such an element.\n\u003c/p\u003e\u003cp\u003eComplexity: O(log n)\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "tryOpenGE",
          "package": "AvlTree",
          "signature": "(e -\u003e Ordering) -\u003e AVL e -\u003e Maybe (ZAVL e)",
          "source": "src/Data-Tree-AVL-Zipper.html#tryOpenGE",
          "type": "function"
        },
        "index": {
          "description": "Attempts to open sorted AVL tree at the least element which is greater than or equal according to the supplied selector This function returns Nothing if the tree does not contain such an element Complexity log",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "tryOpenGE",
          "normalized": "(a-\u003eOrdering)-\u003eAVL a-\u003eMaybe(ZAVL a)",
          "package": "AvlTree",
          "partial": "Open GE",
          "signature": "(e-\u003eOrdering)-\u003eAVL e-\u003eMaybe(ZAVL e)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:tryOpenGE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAttempts to open a non-empty AVL tree at the leftmost element.\n This function returns \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e if the tree is empty.\n\u003c/p\u003e\u003cp\u003eComplexity: O(log n)\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "tryOpenL",
          "package": "AvlTree",
          "signature": "AVL e -\u003e Maybe (ZAVL e)",
          "source": "src/Data-Tree-AVL-Zipper.html#tryOpenL",
          "type": "function"
        },
        "index": {
          "description": "Attempts to open non-empty AVL tree at the leftmost element This function returns Nothing if the tree is empty Complexity log",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "tryOpenL",
          "normalized": "AVL a-\u003eMaybe(ZAVL a)",
          "package": "AvlTree",
          "partial": "Open",
          "signature": "AVL e-\u003eMaybe(ZAVL e)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:tryOpenL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAttempts to open a sorted AVL tree at the greatest element which is less than or equal, according to\n the supplied selector. This function returns _Nothing_ if the tree does not contain such an element.\n\u003c/p\u003e\u003cp\u003eComplexity: O(log n)\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "tryOpenLE",
          "package": "AvlTree",
          "signature": "(e -\u003e Ordering) -\u003e AVL e -\u003e Maybe (ZAVL e)",
          "source": "src/Data-Tree-AVL-Zipper.html#tryOpenLE",
          "type": "function"
        },
        "index": {
          "description": "Attempts to open sorted AVL tree at the greatest element which is less than or equal according to the supplied selector This function returns Nothing if the tree does not contain such an element Complexity log",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "tryOpenLE",
          "normalized": "(a-\u003eOrdering)-\u003eAVL a-\u003eMaybe(ZAVL a)",
          "package": "AvlTree",
          "partial": "Open LE",
          "signature": "(e-\u003eOrdering)-\u003eAVL e-\u003eMaybe(ZAVL e)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:tryOpenLE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAttempts to open a non-empty AVL tree at the rightmost element.\n This function returns \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e if the tree is empty.\n\u003c/p\u003e\u003cp\u003eComplexity: O(log n)\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "tryOpenR",
          "package": "AvlTree",
          "signature": "AVL e -\u003e Maybe (ZAVL e)",
          "source": "src/Data-Tree-AVL-Zipper.html#tryOpenR",
          "type": "function"
        },
        "index": {
          "description": "Attempts to open non-empty AVL tree at the rightmost element This function returns Nothing if the tree is empty Complexity log",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "tryOpenR",
          "normalized": "AVL a-\u003eMaybe(ZAVL a)",
          "package": "AvlTree",
          "partial": "Open",
          "signature": "AVL e-\u003eMaybe(ZAVL e)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:tryOpenR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSimilar to \u003ccode\u003egenPop\u003c/code\u003e, but this function returns \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e if the search fails.\n\u003c/p\u003e\u003cp\u003eComplexity: O(log n)\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "tryPop",
          "package": "AvlTree",
          "signature": "(e -\u003e COrdering a) -\u003e AVL e -\u003e Maybe (a, AVL e)",
          "source": "src/Data-Tree-AVL-Delete.html#tryPop",
          "type": "function"
        },
        "index": {
          "description": "Similar to genPop but this function returns Nothing if the search fails Complexity log",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "tryPop",
          "normalized": "(a-\u003eCOrdering b)-\u003eAVL a-\u003eMaybe(b,AVL a)",
          "package": "AvlTree",
          "partial": "Pop",
          "signature": "(e-\u003eCOrdering a)-\u003eAVL e-\u003eMaybe(a,AVL e)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:tryPop"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSimilar to \u003ccode\u003egenPopIf\u003c/code\u003e, but returns \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e if the search fails.\n\u003c/p\u003e\u003cp\u003eComplexity: O(log n)\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "tryPopIf",
          "package": "AvlTree",
          "signature": "(e -\u003e COrdering (a, Bool)) -\u003e AVL e -\u003e Maybe (a, AVL e)",
          "source": "src/Data-Tree-AVL-Delete.html#tryPopIf",
          "type": "function"
        },
        "index": {
          "description": "Similar to genPopIf but returns Nothing if the search fails Complexity log",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "tryPopIf",
          "normalized": "(a-\u003eCOrdering(b,Bool))-\u003eAVL a-\u003eMaybe(b,AVL a)",
          "package": "AvlTree",
          "partial": "Pop If",
          "signature": "(e-\u003eCOrdering(a,Bool))-\u003eAVL e-\u003eMaybe(a,AVL e)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:tryPopIf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSame as \u003ccode\u003e\u003ca\u003eassertPopL\u003c/a\u003e\u003c/code\u003e, except this version returns \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e if it's argument is an empty tree.\n\u003c/p\u003e\u003cp\u003eComplexity: O(log n)\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "tryPopL",
          "package": "AvlTree",
          "signature": "AVL e -\u003e Maybe (e, AVL e)",
          "source": "src/Data-Tree-AVL-Delete.html#tryPopL",
          "type": "function"
        },
        "index": {
          "description": "Same as assertPopL except this version returns Nothing if it argument is an empty tree Complexity log",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "tryPopL",
          "normalized": "AVL a-\u003eMaybe(a,AVL a)",
          "package": "AvlTree",
          "partial": "Pop",
          "signature": "AVL e-\u003eMaybe(e,AVL e)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:tryPopL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSimilar to \u003ccode\u003e\u003ca\u003eassertPopMaybe\u003c/a\u003e\u003c/code\u003e, but returns \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e if the search fails.\n\u003c/p\u003e\u003cp\u003eComplexity: O(log n)\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "tryPopMaybe",
          "package": "AvlTree",
          "signature": "(e -\u003e COrdering (a, Maybe e)) -\u003e AVL e -\u003e Maybe (a, AVL e)",
          "source": "src/Data-Tree-AVL-Delete.html#tryPopMaybe",
          "type": "function"
        },
        "index": {
          "description": "Similar to assertPopMaybe but returns Nothing if the search fails Complexity log",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "tryPopMaybe",
          "normalized": "(a-\u003eCOrdering(b,Maybe a))-\u003eAVL a-\u003eMaybe(b,AVL a)",
          "package": "AvlTree",
          "partial": "Pop Maybe",
          "signature": "(e-\u003eCOrdering(a,Maybe e))-\u003eAVL e-\u003eMaybe(a,AVL e)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:tryPopMaybe"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSame as \u003ccode\u003e\u003ca\u003eassertPopR\u003c/a\u003e\u003c/code\u003e, except this version returns \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e if it's argument is an empty tree.\n\u003c/p\u003e\u003cp\u003eComplexity: O(log n)\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "tryPopR",
          "package": "AvlTree",
          "signature": "AVL e -\u003e Maybe (AVL e, e)",
          "source": "src/Data-Tree-AVL-Delete.html#tryPopR",
          "type": "function"
        },
        "index": {
          "description": "Same as assertPopR except this version returns Nothing if it argument is an empty tree Complexity log",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "tryPopR",
          "normalized": "AVL a-\u003eMaybe(AVL a,a)",
          "package": "AvlTree",
          "partial": "Pop",
          "signature": "AVL e-\u003eMaybe(AVL e,e)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:tryPopR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGeneral purpose function to perform a search of a sorted tree, using the supplied selector.\n This function is similar to \u003ccode\u003e\u003ca\u003eassertRead\u003c/a\u003e\u003c/code\u003e, but returns \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e if the search failed.\n\u003c/p\u003e\u003cp\u003eComplexity: O(log n)\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "tryRead",
          "package": "AvlTree",
          "signature": "AVL e -\u003e (e -\u003e COrdering a) -\u003e Maybe a",
          "source": "src/Data-Tree-AVL-Read.html#tryRead",
          "type": "function"
        },
        "index": {
          "description": "General purpose function to perform search of sorted tree using the supplied selector This function is similar to assertRead but returns Nothing if the search failed Complexity log",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "tryRead",
          "normalized": "AVL a-\u003e(a-\u003eCOrdering b)-\u003eMaybe b",
          "package": "AvlTree",
          "partial": "Read",
          "signature": "AVL e-\u003e(e-\u003eCOrdering a)-\u003eMaybe a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:tryRead"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRead the element value from a \"full\" \u003ccode\u003e\u003ca\u003eBAVL\u003c/a\u003e\u003c/code\u003e.\n This function returns \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e if applied to an \"empty\" \u003ccode\u003e\u003ca\u003eBAVL\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eComplexity: O(1)\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "tryReadBAVL",
          "package": "AvlTree",
          "signature": "BAVL e -\u003e Maybe e",
          "source": "src/Data-Tree-AVL-Zipper.html#tryReadBAVL",
          "type": "function"
        },
        "index": {
          "description": "Read the element value from full BAVL This function returns Nothing if applied to an empty BAVL Complexity",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "tryReadBAVL",
          "normalized": "BAVL a-\u003eMaybe a",
          "package": "AvlTree",
          "partial": "Read BAVL",
          "signature": "BAVL e-\u003eMaybe e",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:tryReadBAVL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSimilar to \u003ccode\u003e\u003ca\u003eassertReadL\u003c/a\u003e\u003c/code\u003e but returns \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e if the tree is empty.\n\u003c/p\u003e\u003cp\u003eComplexity: O(log n)\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "tryReadL",
          "package": "AvlTree",
          "signature": "AVL e -\u003e Maybe e",
          "source": "src/Data-Tree-AVL-Read.html#tryReadL",
          "type": "function"
        },
        "index": {
          "description": "Similar to assertReadL but returns Nothing if the tree is empty Complexity log",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "tryReadL",
          "normalized": "AVL a-\u003eMaybe a",
          "package": "AvlTree",
          "partial": "Read",
          "signature": "AVL e-\u003eMaybe e",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:tryReadL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis version returns the result of the selector (without adding a \u003ccode\u003e\u003ca\u003eJust\u003c/a\u003e\u003c/code\u003e wrapper) if the search\n succeeds, or \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e if it fails.\n\u003c/p\u003e\u003cp\u003eComplexity: O(log n)\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "tryReadMaybe",
          "package": "AvlTree",
          "signature": "AVL e -\u003e (e -\u003e COrdering (Maybe a)) -\u003e Maybe a",
          "source": "src/Data-Tree-AVL-Read.html#tryReadMaybe",
          "type": "function"
        },
        "index": {
          "description": "This version returns the result of the selector without adding Just wrapper if the search succeeds or Nothing if it fails Complexity log",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "tryReadMaybe",
          "normalized": "AVL a-\u003e(a-\u003eCOrdering(Maybe b))-\u003eMaybe b",
          "package": "AvlTree",
          "partial": "Read Maybe",
          "signature": "AVL e-\u003e(e-\u003eCOrdering(Maybe a))-\u003eMaybe a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:tryReadMaybe"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSimilar to \u003ccode\u003e\u003ca\u003eassertReadR\u003c/a\u003e\u003c/code\u003e but returns \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e if the tree is empty.\n\u003c/p\u003e\u003cp\u003eComplexity: O(log n)\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "tryReadR",
          "package": "AvlTree",
          "signature": "AVL e -\u003e Maybe e",
          "source": "src/Data-Tree-AVL-Read.html#tryReadR",
          "type": "function"
        },
        "index": {
          "description": "Similar to assertReadR but returns Nothing if the tree is empty Complexity log",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "tryReadR",
          "normalized": "AVL a-\u003eMaybe a",
          "package": "AvlTree",
          "partial": "Read",
          "signature": "AVL e-\u003eMaybe e",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:tryReadR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA general purpose function to perform a search of a tree, using the supplied selector.\n The found element is replaced by the value (\u003ccode\u003ee\u003c/code\u003e) of the \u003ccode\u003e(\u003ccode\u003e\u003ca\u003eEq\u003c/a\u003e\u003c/code\u003e e)\u003c/code\u003e constructor returned by\n the selector. This function returns \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e if the search failed.\n\u003c/p\u003e\u003cp\u003eComplexity: O(log n)\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "tryWrite",
          "package": "AvlTree",
          "signature": "(e -\u003e COrdering e) -\u003e AVL e -\u003e Maybe (AVL e)",
          "source": "src/Data-Tree-AVL-Write.html#tryWrite",
          "type": "function"
        },
        "index": {
          "description": "general purpose function to perform search of tree using the supplied selector The found element is replaced by the value of the Eq constructor returned by the selector This function returns Nothing if the search failed Complexity log",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "tryWrite",
          "normalized": "(a-\u003eCOrdering a)-\u003eAVL a-\u003eMaybe(AVL a)",
          "package": "AvlTree",
          "partial": "Write",
          "signature": "(e-\u003eCOrdering e)-\u003eAVL e-\u003eMaybe(AVL e)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:tryWrite"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSimilar to \u003ccode\u003e\u003ca\u003ewriteL\u003c/a\u003e\u003c/code\u003e, but returns \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e if applied to an empty tree.\n\u003c/p\u003e\u003cp\u003eComplexity: O(log n)\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "tryWriteL",
          "package": "AvlTree",
          "signature": "e -\u003e AVL e -\u003e Maybe (AVL e)",
          "source": "src/Data-Tree-AVL-Write.html#tryWriteL",
          "type": "function"
        },
        "index": {
          "description": "Similar to writeL but returns Nothing if applied to an empty tree Complexity log",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "tryWriteL",
          "normalized": "a-\u003eAVL a-\u003eMaybe(AVL a)",
          "package": "AvlTree",
          "partial": "Write",
          "signature": "e-\u003eAVL e-\u003eMaybe(AVL e)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:tryWriteL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSimilar to \u003ccode\u003e\u003ca\u003etryWrite\u003c/a\u003e\u003c/code\u003e, but also returns the original tree if the search succeeds but\n the selector returns \u003ccode\u003e(\u003ccode\u003e\u003ca\u003eEq\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e)\u003c/code\u003e. (This version is intended to help reduce heap burn\n rate if it's likely that no modification of the value is needed.)\n\u003c/p\u003e\u003cp\u003eComplexity: O(log n)\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "tryWriteMaybe",
          "package": "AvlTree",
          "signature": "(e -\u003e COrdering (Maybe e)) -\u003e AVL e -\u003e Maybe (AVL e)",
          "source": "src/Data-Tree-AVL-Write.html#tryWriteMaybe",
          "type": "function"
        },
        "index": {
          "description": "Similar to tryWrite but also returns the original tree if the search succeeds but the selector returns Eq Nothing This version is intended to help reduce heap burn rate if it likely that no modification of the value is needed Complexity log",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "tryWriteMaybe",
          "normalized": "(a-\u003eCOrdering(Maybe a))-\u003eAVL a-\u003eMaybe(AVL a)",
          "package": "AvlTree",
          "partial": "Write Maybe",
          "signature": "(e-\u003eCOrdering(Maybe e))-\u003eAVL e-\u003eMaybe(AVL e)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:tryWriteMaybe"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSimilar to \u003ccode\u003e\u003ca\u003ewriteR\u003c/a\u003e\u003c/code\u003e, but returns \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e if applied to an empty tree.\n\u003c/p\u003e\u003cp\u003eComplexity: O(log n)\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "tryWriteR",
          "package": "AvlTree",
          "signature": "AVL e -\u003e e -\u003e Maybe (AVL e)",
          "source": "src/Data-Tree-AVL-Write.html#tryWriteR",
          "type": "function"
        },
        "index": {
          "description": "Similar to writeR but returns Nothing if applied to an empty tree Complexity log",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "tryWriteR",
          "normalized": "AVL a-\u003ea-\u003eMaybe(AVL a)",
          "package": "AvlTree",
          "partial": "Write",
          "signature": "AVL e-\u003ee-\u003eMaybe(AVL e)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:tryWriteR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUses the supplied combining comparison to evaluate the union of two sets represented as\n sorted AVL trees. Whenever the combining comparison is applied, the first comparison argument is\n an element of the first tree and the second comparison argument is an element of the second tree.\n\u003c/p\u003e\u003cp\u003eComplexity: Not sure, but I'd appreciate it if someone could figure it out.\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "union",
          "package": "AvlTree",
          "signature": "(e -\u003e e -\u003e COrdering e) -\u003e AVL e -\u003e AVL e -\u003e AVL e",
          "source": "src/Data-Tree-AVL-Set.html#union",
          "type": "function"
        },
        "index": {
          "description": "Uses the supplied combining comparison to evaluate the union of two sets represented as sorted AVL trees Whenever the combining comparison is applied the first comparison argument is an element of the first tree and the second comparison argument is an element of the second tree Complexity Not sure but appreciate it if someone could figure it out",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "union",
          "normalized": "(a-\u003ea-\u003eCOrdering a)-\u003eAVL a-\u003eAVL a-\u003eAVL a",
          "package": "AvlTree",
          "signature": "(e-\u003ee-\u003eCOrdering e)-\u003eAVL e-\u003eAVL e-\u003eAVL e",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:union"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSimilar to \u003ccode\u003e\u003ca\u003eunion\u003c/a\u003e\u003c/code\u003e, but the resulting tree does not include elements in cases where\n the supplied combining comparison returns \u003ccode\u003e(Eq Nothing)\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eComplexity: Not sure, but I'd appreciate it if someone could figure it out.\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "unionMaybe",
          "package": "AvlTree",
          "signature": "(e -\u003e e -\u003e COrdering (Maybe e)) -\u003e AVL e -\u003e AVL e -\u003e AVL e",
          "source": "src/Data-Tree-AVL-Set.html#unionMaybe",
          "type": "function"
        },
        "index": {
          "description": "Similar to union but the resulting tree does not include elements in cases where the supplied combining comparison returns Eq Nothing Complexity Not sure but appreciate it if someone could figure it out",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "unionMaybe",
          "normalized": "(a-\u003ea-\u003eCOrdering(Maybe a))-\u003eAVL a-\u003eAVL a-\u003eAVL a",
          "package": "AvlTree",
          "partial": "Maybe",
          "signature": "(e-\u003ee-\u003eCOrdering(Maybe e))-\u003eAVL e-\u003eAVL e-\u003eAVL e",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:unionMaybe"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUses the supplied combining comparison to evaluate the union of all sets in a list\n of sets represented as sorted AVL trees. Behaves as if defined..\n\u003c/p\u003e\u003cpre\u003eunions ccmp avls = foldl' (\u003ccode\u003e\u003ca\u003eunion\u003c/a\u003e\u003c/code\u003e ccmp) empty avls\u003c/pre\u003e",
          "module": "Data.Tree.AVL",
          "name": "unions",
          "package": "AvlTree",
          "signature": "(e -\u003e e -\u003e COrdering e) -\u003e [AVL e] -\u003e AVL e",
          "source": "src/Data-Tree-AVL-Set.html#unions",
          "type": "function"
        },
        "index": {
          "description": "Uses the supplied combining comparison to evaluate the union of all sets in list of sets represented as sorted AVL trees Behaves as if defined unions ccmp avls foldl union ccmp empty avls",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "unions",
          "normalized": "(a-\u003ea-\u003eCOrdering a)-\u003e[AVL a]-\u003eAVL a",
          "package": "AvlTree",
          "signature": "(e-\u003ee-\u003eCOrdering e)-\u003e[AVL e]-\u003eAVL e",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:unions"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGiven two Sets \u003ccode\u003eA\u003c/code\u003e and \u003ccode\u003eB\u003c/code\u003e represented as sorted AVL trees, this function\n extracts the 'Venn diagram' components \u003ccode\u003eA-B\u003c/code\u003e, \u003ccode\u003eA.B\u003c/code\u003e and \u003ccode\u003eB-A\u003c/code\u003e.\n See also \u003ccode\u003e\u003ca\u003evennMaybe\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eComplexity: Not sure, but I'd appreciate it if someone could figure it out.\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "venn",
          "package": "AvlTree",
          "signature": "(a -\u003e b -\u003e COrdering c) -\u003e AVL a -\u003e AVL b -\u003e (AVL a, AVL c, AVL b)",
          "source": "src/Data-Tree-AVL-Set.html#venn",
          "type": "function"
        },
        "index": {
          "description": "Given two Sets and represented as sorted AVL trees this function extracts the Venn diagram components A-B A.B and B-A See also vennMaybe Complexity Not sure but appreciate it if someone could figure it out",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "venn",
          "normalized": "(a-\u003eb-\u003eCOrdering c)-\u003eAVL a-\u003eAVL b-\u003e(AVL a,AVL c,AVL b)",
          "package": "AvlTree",
          "signature": "(a-\u003eb-\u003eCOrdering c)-\u003eAVL a-\u003eAVL b-\u003e(AVL a,AVL c,AVL b)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:venn"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSame as \u003ccode\u003e\u003ca\u003evenn\u003c/a\u003e\u003c/code\u003e, but returns the intersection component as a list in ascending order.\n This is just \u003ccode\u003e\u003ca\u003evennToList\u003c/a\u003e\u003c/code\u003e applied to an empty initial intersection list.\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "vennAsList",
          "package": "AvlTree",
          "signature": "(a -\u003e b -\u003e COrdering c) -\u003e AVL a -\u003e AVL b -\u003e (AVL a, [c], AVL b)",
          "source": "src/Data-Tree-AVL-Set.html#vennAsList",
          "type": "function"
        },
        "index": {
          "description": "Same as venn but returns the intersection component as list in ascending order This is just vennToList applied to an empty initial intersection list",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "vennAsList",
          "normalized": "(a-\u003eb-\u003eCOrdering c)-\u003eAVL a-\u003eAVL b-\u003e(AVL a,[c],AVL b)",
          "package": "AvlTree",
          "partial": "As List",
          "signature": "(a-\u003eb-\u003eCOrdering c)-\u003eAVL a-\u003eAVL b-\u003e(AVL a,[c],AVL b)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:vennAsList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSimilar to \u003ccode\u003e\u003ca\u003evenn\u003c/a\u003e\u003c/code\u003e, but intersection elements for which the combining comparison\n returns \u003ccode\u003e(\u003ccode\u003e\u003ca\u003eEq\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e)\u003c/code\u003e are deleted from the intersection result.\n\u003c/p\u003e\u003cp\u003eComplexity: Not sure, but I'd appreciate it if someone could figure it out.\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "vennMaybe",
          "package": "AvlTree",
          "signature": "(a -\u003e b -\u003e COrdering (Maybe c)) -\u003e AVL a -\u003e AVL b -\u003e (AVL a, AVL c, AVL b)",
          "source": "src/Data-Tree-AVL-Set.html#vennMaybe",
          "type": "function"
        },
        "index": {
          "description": "Similar to venn but intersection elements for which the combining comparison returns Eq Nothing are deleted from the intersection result Complexity Not sure but appreciate it if someone could figure it out",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "vennMaybe",
          "normalized": "(a-\u003eb-\u003eCOrdering(Maybe c))-\u003eAVL a-\u003eAVL b-\u003e(AVL a,AVL c,AVL b)",
          "package": "AvlTree",
          "partial": "Maybe",
          "signature": "(a-\u003eb-\u003eCOrdering(Maybe c))-\u003eAVL a-\u003eAVL b-\u003e(AVL a,AVL c,AVL b)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:vennMaybe"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSame as \u003ccode\u003e\u003ca\u003evennMaybe\u003c/a\u003e\u003c/code\u003e, but returns the intersection component as a list in ascending order.\n This is just \u003ccode\u003e\u003ca\u003evennMaybeToList\u003c/a\u003e\u003c/code\u003e applied to an empty initial intersection list.\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "vennMaybeAsList",
          "package": "AvlTree",
          "signature": "(a -\u003e b -\u003e COrdering (Maybe c)) -\u003e AVL a -\u003e AVL b -\u003e (AVL a, [c], AVL b)",
          "source": "src/Data-Tree-AVL-Set.html#vennMaybeAsList",
          "type": "function"
        },
        "index": {
          "description": "Same as vennMaybe but returns the intersection component as list in ascending order This is just vennMaybeToList applied to an empty initial intersection list",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "vennMaybeAsList",
          "normalized": "(a-\u003eb-\u003eCOrdering(Maybe c))-\u003eAVL a-\u003eAVL b-\u003e(AVL a,[c],AVL b)",
          "package": "AvlTree",
          "partial": "Maybe As List",
          "signature": "(a-\u003eb-\u003eCOrdering(Maybe c))-\u003eAVL a-\u003eAVL b-\u003e(AVL a,[c],AVL b)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:vennMaybeAsList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSame as \u003ccode\u003e\u003ca\u003evennMaybe\u003c/a\u003e\u003c/code\u003e, but prepends the intersection component to the supplied list\n in ascending order.\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "vennMaybeToList",
          "package": "AvlTree",
          "signature": "(a -\u003e b -\u003e COrdering (Maybe c)) -\u003e [c] -\u003e AVL a -\u003e AVL b -\u003e (AVL a, [c], AVL b)",
          "source": "src/Data-Tree-AVL-Set.html#vennMaybeToList",
          "type": "function"
        },
        "index": {
          "description": "Same as vennMaybe but prepends the intersection component to the supplied list in ascending order",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "vennMaybeToList",
          "normalized": "(a-\u003eb-\u003eCOrdering(Maybe c))-\u003e[c]-\u003eAVL a-\u003eAVL b-\u003e(AVL a,[c],AVL b)",
          "package": "AvlTree",
          "partial": "Maybe To List",
          "signature": "(a-\u003eb-\u003eCOrdering(Maybe c))-\u003e[c]-\u003eAVL a-\u003eAVL b-\u003e(AVL a,[c],AVL b)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:vennMaybeToList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSame as \u003ccode\u003e\u003ca\u003evenn\u003c/a\u003e\u003c/code\u003e, but prepends the intersection component to the supplied list\n in ascending order.\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "vennToList",
          "package": "AvlTree",
          "signature": "(a -\u003e b -\u003e COrdering c) -\u003e [c] -\u003e AVL a -\u003e AVL b -\u003e (AVL a, [c], AVL b)",
          "source": "src/Data-Tree-AVL-Set.html#vennToList",
          "type": "function"
        },
        "index": {
          "description": "Same as venn but prepends the intersection component to the supplied list in ascending order",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "vennToList",
          "normalized": "(a-\u003eb-\u003eCOrdering c)-\u003e[c]-\u003eAVL a-\u003eAVL b-\u003e(AVL a,[c],AVL b)",
          "package": "AvlTree",
          "partial": "To List",
          "signature": "(a-\u003eb-\u003eCOrdering c)-\u003e[c]-\u003eAVL a-\u003eAVL b-\u003e(AVL a,[c],AVL b)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:vennToList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA general purpose function to perform a search of a tree, using the supplied selector.\n If the search succeeds the found element is replaced by the value (\u003ccode\u003ee\u003c/code\u003e) of the \u003ccode\u003e(\u003ccode\u003e\u003ca\u003eEq\u003c/a\u003e\u003c/code\u003e e)\u003c/code\u003e\n constructor returned by the selector. If the search fails this function returns the original tree.\n\u003c/p\u003e\u003cp\u003eComplexity: O(log n)\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "write",
          "package": "AvlTree",
          "signature": "(e -\u003e COrdering e) -\u003e AVL e -\u003e AVL e",
          "source": "src/Data-Tree-AVL-Write.html#write",
          "type": "function"
        },
        "index": {
          "description": "general purpose function to perform search of tree using the supplied selector If the search succeeds the found element is replaced by the value of the Eq constructor returned by the selector If the search fails this function returns the original tree Complexity log",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "write",
          "normalized": "(a-\u003eCOrdering a)-\u003eAVL a-\u003eAVL a",
          "package": "AvlTree",
          "signature": "(e-\u003eCOrdering e)-\u003eAVL e-\u003eAVL e",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:write"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFunctionally identical to \u003ccode\u003e\u003ca\u003ewrite\u003c/a\u003e\u003c/code\u003e, but returns an identical tree (one with all the nodes on\n the path duplicated) if the search fails. This should probably only be used if you know the\n search will succeed and will return an element which is different from that already present.\n\u003c/p\u003e\u003cp\u003eComplexity: O(log n)\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "writeFast",
          "package": "AvlTree",
          "signature": "(e -\u003e COrdering e) -\u003e AVL e -\u003e AVL e",
          "source": "src/Data-Tree-AVL-Write.html#writeFast",
          "type": "function"
        },
        "index": {
          "description": "Functionally identical to write but returns an identical tree one with all the nodes on the path duplicated if the search fails This should probably only be used if you know the search will succeed and will return an element which is different from that already present Complexity log",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "writeFast",
          "normalized": "(a-\u003eCOrdering a)-\u003eAVL a-\u003eAVL a",
          "package": "AvlTree",
          "partial": "Fast",
          "signature": "(e-\u003eCOrdering e)-\u003eAVL e-\u003eAVL e",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:writeFast"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReplace the left most element of a tree with the supplied new element.\n This function raises an error if applied to an empty tree.\n\u003c/p\u003e\u003cp\u003eComplexity: O(log n)\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "writeL",
          "package": "AvlTree",
          "signature": "e -\u003e AVL e -\u003e AVL e",
          "source": "src/Data-Tree-AVL-Write.html#writeL",
          "type": "function"
        },
        "index": {
          "description": "Replace the left most element of tree with the supplied new element This function raises an error if applied to an empty tree Complexity log",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "writeL",
          "normalized": "a-\u003eAVL a-\u003eAVL a",
          "package": "AvlTree",
          "signature": "e-\u003eAVL e-\u003eAVL e",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:writeL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSimilar to \u003ccode\u003e\u003ca\u003ewrite\u003c/a\u003e\u003c/code\u003e, but also returns the original tree if the search succeeds but\n the selector returns \u003ccode\u003e(\u003ccode\u003e\u003ca\u003eEq\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e)\u003c/code\u003e. (This version is intended to help reduce heap burn\n rate if it's likely that no modification of the value is needed.)\n\u003c/p\u003e\u003cp\u003eComplexity: O(log n)\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "writeMaybe",
          "package": "AvlTree",
          "signature": "(e -\u003e COrdering (Maybe e)) -\u003e AVL e -\u003e AVL e",
          "source": "src/Data-Tree-AVL-Write.html#writeMaybe",
          "type": "function"
        },
        "index": {
          "description": "Similar to write but also returns the original tree if the search succeeds but the selector returns Eq Nothing This version is intended to help reduce heap burn rate if it likely that no modification of the value is needed Complexity log",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "writeMaybe",
          "normalized": "(a-\u003eCOrdering(Maybe a))-\u003eAVL a-\u003eAVL a",
          "package": "AvlTree",
          "partial": "Maybe",
          "signature": "(e-\u003eCOrdering(Maybe e))-\u003eAVL e-\u003eAVL e",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:writeMaybe"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eOverwrite a tree element. Assumes the path bits were extracted from \u003ccode\u003e\u003ca\u003eFullBP\u003c/a\u003e\u003c/code\u003e constructor.\n Raises an error if the path leads to an empty tree.\n\u003c/p\u003e\u003cp\u003eN.B This operation does not change tree shape (no insertion occurs).\n\u003c/p\u003e\u003cp\u003eComplexity: O(log n)\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "writePath",
          "package": "AvlTree",
          "signature": "Int# -\u003e e -\u003e AVL e -\u003e AVL e",
          "source": "src/Data-Tree-AVL-BinPath.html#writePath",
          "type": "function"
        },
        "index": {
          "description": "Overwrite tree element Assumes the path bits were extracted from FullBP constructor Raises an error if the path leads to an empty tree N.B This operation does not change tree shape no insertion occurs Complexity log",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "writePath",
          "normalized": "Int #-\u003ea-\u003eAVL a-\u003eAVL a",
          "package": "AvlTree",
          "partial": "Path",
          "signature": "Int #-\u003ee-\u003eAVL e-\u003eAVL e",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:writePath"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReplace the right most element of a tree with the supplied new element.\n This function raises an error if applied to an empty tree.\n\u003c/p\u003e\u003cp\u003eComplexity: O(log n)\n\u003c/p\u003e",
          "module": "Data.Tree.AVL",
          "name": "writeR",
          "package": "AvlTree",
          "signature": "AVL e -\u003e e -\u003e AVL e",
          "source": "src/Data-Tree-AVL-Write.html#writeR",
          "type": "function"
        },
        "index": {
          "description": "Replace the right most element of tree with the supplied new element This function raises an error if applied to an empty tree Complexity log",
          "hierarchy": "Data Tree AVL",
          "module": "Data.Tree.AVL",
          "name": "writeR",
          "normalized": "AVL a-\u003ea-\u003eAVL a",
          "package": "AvlTree",
          "signature": "AVL e-\u003ee-\u003eAVL e",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/AvlTree/docs/Data-Tree-AVL.html#v:writeR"
      }
    }
  ]
]