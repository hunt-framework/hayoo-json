[
  {
    "cmd": "delete-by-query",
    "query": {
      "contexts": [
        "package"
      ],
      "query": {
        "op": "case",
        "type": "word",
        "word": "monad-lrs"
      },
      "type": "context"
    }
  },
  [
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eA monad to calculate linear recursive sequence efficiently. Matrix\n multiplication and fast exponentiation algorithm are used to speed\n up calculating the number with particular index in the sequence. This\n library also provides a monadic DSL to describe the sequence.\n\u003c/p\u003e\u003cp\u003eAs an example, here is the fibonacci sequence\n\u003c/p\u003e\u003cpre\u003efib = do\n    [f0, f1] \u003c- newVariables [1, 1]\n    f0 \u003c:- f0 \u003c+\u003e f1\n    return f1\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003emap (runLinearRecursive fib) [0..10]\n\u003c/code\u003e\u003c/strong\u003e[1,1,2,3,5,8,13,21,34,55,89]\n\u003c/pre\u003e\u003c/div\u003e",
          "module": "Math.LinearRecursive.Monad",
          "name": "Monad",
          "package": "monad-lrs",
          "source": "src/Math-LinearRecursive-Monad.html",
          "type": "module"
        },
        "index": {
          "description": "monad to calculate linear recursive sequence efficiently Matrix multiplication and fast exponentiation algorithm are used to speed up calculating the number with particular index in the sequence This library also provides monadic DSL to describe the sequence As an example here is the fibonacci sequence fib do f0 f1 newVariables f0 f0 f1 return f1 map runLinearRecursive fib",
          "hierarchy": "Math LinearRecursive Monad",
          "module": "Math.LinearRecursive.Monad",
          "name": "Monad",
          "package": "monad-lrs",
          "partial": "Monad",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/monad-lrs/docs/Math-LinearRecursive-Monad.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA vector represents linear combination of several variables.\n\u003c/p\u003e",
          "module": "Math.LinearRecursive.Monad",
          "name": "LinearCombination",
          "package": "monad-lrs",
          "source": "src/Math-LinearRecursive-Monad.html#LinearCombination",
          "type": "type"
        },
        "index": {
          "description": "vector represents linear combination of several variables",
          "hierarchy": "Math LinearRecursive Monad",
          "module": "Math.LinearRecursive.Monad",
          "name": "LinearCombination",
          "package": "monad-lrs",
          "partial": "Linear Combination",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/monad-lrs/docs/Math-LinearRecursive-Monad.html#t:LinearCombination"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe monad to specify the calculation of next number of a linear recursive sequence.\n\u003c/p\u003e\u003cp\u003eAll linear recursive sequences can be generated by iteration, the next number can\n be represented by linear combination of some previous numbers. This can be regarded\n as linear transformation between states, and it's actually multiply a transform matrix.\n\u003c/p\u003e\u003cp\u003eIn order to formalize and simply this procedure, this monad use mutable-like variables to \n denote the states, and mutable-like assignment to denote the transform matrix.\n\u003c/p\u003e\u003cp\u003eTo evaluate this sequence, the monad will be simulated step by step, after each step, all\n variable will be updated. Besides, if the monad returns a \u003ccode\u003e\u003ca\u003eLinearCombination\u003c/a\u003e\u003c/code\u003e, a number\n will be generated each step. (well, actual calculation uses fast exponentiation algorithm \n to speed up this calculation)\n\u003c/p\u003e",
          "module": "Math.LinearRecursive.Monad",
          "name": "LinearRecursive",
          "package": "monad-lrs",
          "source": "src/Math-LinearRecursive-Monad.html#LinearRecursive",
          "type": "data"
        },
        "index": {
          "description": "The monad to specify the calculation of next number of linear recursive sequence All linear recursive sequences can be generated by iteration the next number can be represented by linear combination of some previous numbers This can be regarded as linear transformation between states and it actually multiply transform matrix In order to formalize and simply this procedure this monad use mutable-like variables to denote the states and mutable-like assignment to denote the transform matrix To evaluate this sequence the monad will be simulated step by step after each step all variable will be updated Besides if the monad returns LinearCombination number will be generated each step well actual calculation uses fast exponentiation algorithm to speed up this calculation",
          "hierarchy": "Math LinearRecursive Monad",
          "module": "Math.LinearRecursive.Monad",
          "name": "LinearRecursive",
          "package": "monad-lrs",
          "partial": "Linear Recursive",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/monad-lrs/docs/Math-LinearRecursive-Monad.html#t:LinearRecursive"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.LinearRecursive.Monad",
          "name": "Polynomial",
          "package": "monad-lrs",
          "source": "src/Math-LinearRecursive-Internal-Polynomial.html#Polynomial",
          "type": "data"
        },
        "index": {
          "hierarchy": "Math LinearRecursive Monad",
          "module": "Math.LinearRecursive.Monad",
          "name": "Polynomial",
          "package": "monad-lrs",
          "partial": "Polynomial",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/monad-lrs/docs/Math-LinearRecursive-Monad.html#t:Polynomial"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn unit vector represents dependence on a particular variable.\n\u003c/p\u003e",
          "module": "Math.LinearRecursive.Monad",
          "name": "Variable",
          "package": "monad-lrs",
          "source": "src/Math-LinearRecursive-Monad.html#Variable",
          "type": "type"
        },
        "index": {
          "description": "An unit vector represents dependence on particular variable",
          "hierarchy": "Math LinearRecursive Monad",
          "module": "Math.LinearRecursive.Monad",
          "name": "Variable",
          "package": "monad-lrs",
          "partial": "Variable",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/monad-lrs/docs/Math-LinearRecursive-Monad.html#t:Variable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003erepresents vector type class, there are two instances:\n\u003c/p\u003e\u003cdl\u003e\u003cdt\u003e\u003ccode\u003eVector\u003c/code\u003e\u003c/dt\u003e\u003cdd\u003e General purpose vector.\n\u003c/dd\u003e\u003cdt\u003e\u003ccode\u003eVector1\u003c/code\u003e\u003c/dt\u003e\u003cdd\u003e Unit vector in vector space.\n\u003c/dd\u003e\u003c/dl\u003e",
          "module": "Math.LinearRecursive.Monad",
          "name": "VectorLike",
          "package": "monad-lrs",
          "source": "src/Math-LinearRecursive-Internal-Vector.html#VectorLike",
          "type": "class"
        },
        "index": {
          "description": "represents vector type class there are two instances Vector General purpose vector Vector1 Unit vector in vector space",
          "hierarchy": "Math LinearRecursive Monad",
          "module": "Math.LinearRecursive.Monad",
          "name": "VectorLike",
          "package": "monad-lrs",
          "partial": "Vector Like",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/monad-lrs/docs/Math-LinearRecursive-Monad.html#t:VectorLike"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRight-side scalar multiplication, \u003ccode\u003ea *\u003e s\u003c/code\u003e is \u003ccode\u003ea\u003c/code\u003e scaled by \u003ccode\u003es\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Math.LinearRecursive.Monad",
          "name": "(*\u003e)",
          "package": "monad-lrs",
          "signature": "v a -\u003e a -\u003e Vector a",
          "source": "src/Math-LinearRecursive-Internal-Vector.html#%2A%3E",
          "type": "function"
        },
        "index": {
          "description": "Right-side scalar multiplication is scaled by",
          "hierarchy": "Math LinearRecursive Monad",
          "module": "Math.LinearRecursive.Monad",
          "name": "(*\u003e) *\u003e",
          "normalized": "a b-\u003eb-\u003eVector b",
          "package": "monad-lrs",
          "signature": "v a-\u003ea-\u003eVector a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/monad-lrs/docs/Math-LinearRecursive-Monad.html#v:-42--62-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLeft-side scalar multiplication, \u003ccode\u003es \u003c* a\u003c/code\u003e is \u003ccode\u003ea\u003c/code\u003e scaled by \u003ccode\u003es\u003c/code\u003e.\n For example, \u003ccode\u003e1 \u003c* a\u003c/code\u003e equals to \u003ccode\u003ea\u003c/code\u003e, \u003ccode\u003e2 \u003c* a\u003c/code\u003e equals to \u003ccode\u003ea+a\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Math.LinearRecursive.Monad",
          "name": "(\u003c*)",
          "package": "monad-lrs",
          "signature": "a -\u003e v a -\u003e Vector a",
          "source": "src/Math-LinearRecursive-Internal-Vector.html#%3C%2A",
          "type": "function"
        },
        "index": {
          "description": "Left-side scalar multiplication is scaled by For example equals to equals to",
          "hierarchy": "Math LinearRecursive Monad",
          "module": "Math.LinearRecursive.Monad",
          "name": "(\u003c*) \u003c*",
          "normalized": "a-\u003eb a-\u003eVector a",
          "package": "monad-lrs",
          "signature": "a-\u003ev a-\u003eVector a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/monad-lrs/docs/Math-LinearRecursive-Monad.html#v:-60--42-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eVariable accumulated assignment. \u003ccode\u003ev \u003c+- a\u003c/code\u003e replace variable \u003ccode\u003ev\u003c/code\u003e with \u003ccode\u003ev \u003c+\u003e a\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eBe aware that \u003ccode\u003ev\u003c/code\u003e will be zero before any assignment.\n\u003c/p\u003e",
          "module": "Math.LinearRecursive.Monad",
          "name": "(\u003c+-)",
          "package": "monad-lrs",
          "signature": "Variable a -\u003e v a -\u003e LinearRecursive a ()",
          "source": "src/Math-LinearRecursive-Monad.html#%3C%2B-",
          "type": "function"
        },
        "index": {
          "description": "Variable accumulated assignment replace variable with Be aware that will be zero before any assignment",
          "hierarchy": "Math LinearRecursive Monad",
          "module": "Math.LinearRecursive.Monad",
          "name": "(\u003c+-) \u003c+-",
          "normalized": "Variable a-\u003eb a-\u003eLinearRecursive a()",
          "package": "monad-lrs",
          "signature": "Variable a-\u003ev a-\u003eLinearRecursive a()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/monad-lrs/docs/Math-LinearRecursive-Monad.html#v:-60--43--45-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eVector addition, \u003ccode\u003ea \u003c+\u003e b\u003c/code\u003e represents sum of \u003ccode\u003ea\u003c/code\u003e and \u003ccode\u003eb\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Math.LinearRecursive.Monad",
          "name": "(\u003c+\u003e)",
          "package": "monad-lrs",
          "signature": "v1 a -\u003e v2 a -\u003e Vector a",
          "source": "src/Math-LinearRecursive-Internal-Vector.html#%3C%2B%3E",
          "type": "function"
        },
        "index": {
          "description": "Vector addition represents sum of and",
          "hierarchy": "Math LinearRecursive Monad",
          "module": "Math.LinearRecursive.Monad",
          "name": "(\u003c+\u003e) \u003c+\u003e",
          "normalized": "a b-\u003ea b-\u003eVector b",
          "package": "monad-lrs",
          "signature": "v a-\u003ev a-\u003eVector a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/monad-lrs/docs/Math-LinearRecursive-Monad.html#v:-60--43--62-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eVector subtraction, \u003ccode\u003ea \u003c-\u003e b\u003c/code\u003e represents difference of \u003ccode\u003ea\u003c/code\u003e and \u003ccode\u003eb\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Math.LinearRecursive.Monad",
          "name": "(\u003c-\u003e)",
          "package": "monad-lrs",
          "signature": "v1 a -\u003e v2 a -\u003e Vector a",
          "source": "src/Math-LinearRecursive-Internal-Vector.html#%3C-%3E",
          "type": "function"
        },
        "index": {
          "description": "Vector subtraction represents difference of and",
          "hierarchy": "Math LinearRecursive Monad",
          "module": "Math.LinearRecursive.Monad",
          "name": "(\u003c-\u003e) \u003c-\u003e",
          "normalized": "a b-\u003ea b-\u003eVector b",
          "package": "monad-lrs",
          "signature": "v a-\u003ev a-\u003eVector a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/monad-lrs/docs/Math-LinearRecursive-Monad.html#v:-60--45--62-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eVariable assignment. \u003ccode\u003ev \u003c:- a\u003c/code\u003e replace variable \u003ccode\u003ev\u003c/code\u003e with \u003ccode\u003ea\u003c/code\u003e after this step. \n If there are multiple assignments to one variable, only the last one counts.\n\u003c/p\u003e",
          "module": "Math.LinearRecursive.Monad",
          "name": "(\u003c:-)",
          "package": "monad-lrs",
          "signature": "Variable a -\u003e v a -\u003e LinearRecursive a ()",
          "source": "src/Math-LinearRecursive-Monad.html#%3C%3A-",
          "type": "function"
        },
        "index": {
          "description": "Variable assignment replace variable with after this step If there are multiple assignments to one variable only the last one counts",
          "hierarchy": "Math LinearRecursive Monad",
          "module": "Math.LinearRecursive.Monad",
          "name": "(\u003c:-) \u003c:-",
          "normalized": "Variable a-\u003eb a-\u003eLinearRecursive a()",
          "package": "monad-lrs",
          "signature": "Variable a-\u003ev a-\u003eLinearRecursive a()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/monad-lrs/docs/Math-LinearRecursive-Monad.html#v:-60-:-45-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ereturn a constent number. Use one extra variable.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003emap (runLinearRecursive (getConstant 3)) [0..10]\n\u003c/code\u003e\u003c/strong\u003e[3,3,3,3,3,3,3,3,3,3,3]\n\u003c/pre\u003e",
          "module": "Math.LinearRecursive.Monad",
          "name": "getConstant",
          "package": "monad-lrs",
          "signature": "a -\u003e LinearRecursive a (LinearCombination a)",
          "source": "src/Math-LinearRecursive-Monad.html#getConstant",
          "type": "function"
        },
        "index": {
          "description": "return constent number Use one extra variable map runLinearRecursive getConstant",
          "hierarchy": "Math LinearRecursive Monad",
          "module": "Math.LinearRecursive.Monad",
          "name": "getConstant",
          "normalized": "a-\u003eLinearRecursive a(LinearCombination a)",
          "package": "monad-lrs",
          "partial": "Constant",
          "signature": "a-\u003eLinearRecursive a(LinearCombination a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/monad-lrs/docs/Math-LinearRecursive-Monad.html#v:getConstant"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ereturn sum of a linear combination in steps before current one. Use one extra variable.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003emap (runLinearRecursive (getConstant 3 \u003e\u003e= getPartialSum)) [0..10]\n\u003c/code\u003e\u003c/strong\u003e[0,3,6,9,12,15,18,21,24,27,30]\n\u003c/pre\u003e",
          "module": "Math.LinearRecursive.Monad",
          "name": "getPartialSum",
          "package": "monad-lrs",
          "signature": "LinearCombination a -\u003e LinearRecursive a (LinearCombination a)",
          "source": "src/Math-LinearRecursive-Monad.html#getPartialSum",
          "type": "function"
        },
        "index": {
          "description": "return sum of linear combination in steps before current one Use one extra variable map runLinearRecursive getConstant getPartialSum",
          "hierarchy": "Math LinearRecursive Monad",
          "module": "Math.LinearRecursive.Monad",
          "name": "getPartialSum",
          "normalized": "LinearCombination a-\u003eLinearRecursive a(LinearCombination a)",
          "package": "monad-lrs",
          "partial": "Partial Sum",
          "signature": "LinearCombination a-\u003eLinearRecursive a(LinearCombination a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/monad-lrs/docs/Math-LinearRecursive-Monad.html#v:getPartialSum"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.LinearRecursive.Monad",
          "name": "getPartialSumWith",
          "package": "monad-lrs",
          "signature": "Polynomial a -\u003e v a -\u003e LinearRecursive a (LinearCombination a)",
          "source": "src/Math-LinearRecursive-Monad.html#getPartialSumWith",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math LinearRecursive Monad",
          "module": "Math.LinearRecursive.Monad",
          "name": "getPartialSumWith",
          "normalized": "Polynomial a-\u003eb a-\u003eLinearRecursive a(LinearCombination a)",
          "package": "monad-lrs",
          "partial": "Partial Sum With",
          "signature": "Polynomial a-\u003ev a-\u003eLinearRecursive a(LinearCombination a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/monad-lrs/docs/Math-LinearRecursive-Monad.html#v:getPartialSumWith"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003egetPolynomial poly\u003c/code\u003e evaluate polynomial \u003ccode\u003epoly\u003c/code\u003e with variable \u003ccode\u003ex\u003c/code\u003e replaced by current step number. \n Use \u003ccode\u003en\u003c/code\u003e extra variables, where \u003ccode\u003en\u003c/code\u003e is the degree of \u003ccode\u003epoly\u003c/code\u003e\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003emap (runLinearRecursive (getPolynomial ((x+1)^2))) [0..10]\n\u003c/code\u003e\u003c/strong\u003e[1,4,9,16,25,36,49,64,81,100,121]\n\u003c/pre\u003e",
          "module": "Math.LinearRecursive.Monad",
          "name": "getPolynomial",
          "package": "monad-lrs",
          "signature": "Polynomial a -\u003e LinearRecursive a (LinearCombination a)",
          "source": "src/Math-LinearRecursive-Monad.html#getPolynomial",
          "type": "function"
        },
        "index": {
          "description": "getPolynomial poly evaluate polynomial poly with variable replaced by current step number Use extra variables where is the degree of poly map runLinearRecursive getPolynomial",
          "hierarchy": "Math LinearRecursive Monad",
          "module": "Math.LinearRecursive.Monad",
          "name": "getPolynomial",
          "normalized": "Polynomial a-\u003eLinearRecursive a(LinearCombination a)",
          "package": "monad-lrs",
          "partial": "Polynomial",
          "signature": "Polynomial a-\u003eLinearRecursive a(LinearCombination a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/monad-lrs/docs/Math-LinearRecursive-Monad.html#v:getPolynomial"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003egetPowerOf a\u003c/code\u003e return power of \u003ccode\u003ea\u003c/code\u003e with order equal to current step number. \n Use one extra variable.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003emap (runLinearRecursive (getPowerOf 3)) [0..10]\n\u003c/code\u003e\u003c/strong\u003e[1,3,9,27,81,243,729,2187,6561,19683,59049]\n\u003c/pre\u003e",
          "module": "Math.LinearRecursive.Monad",
          "name": "getPowerOf",
          "package": "monad-lrs",
          "signature": "a -\u003e LinearRecursive a (LinearCombination a)",
          "source": "src/Math-LinearRecursive-Monad.html#getPowerOf",
          "type": "function"
        },
        "index": {
          "description": "getPowerOf return power of with order equal to current step number Use one extra variable map runLinearRecursive getPowerOf",
          "hierarchy": "Math LinearRecursive Monad",
          "module": "Math.LinearRecursive.Monad",
          "name": "getPowerOf",
          "normalized": "a-\u003eLinearRecursive a(LinearCombination a)",
          "package": "monad-lrs",
          "partial": "Power Of",
          "signature": "a-\u003eLinearRecursive a(LinearCombination a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/monad-lrs/docs/Math-LinearRecursive-Monad.html#v:getPowerOf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ereturn the current step number. Use two extra variables.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003emap (runLinearRecursive getStep) [0..10]\n\u003c/code\u003e\u003c/strong\u003e[0,1,2,3,4,5,6,7,8,9,10]\n\u003c/pre\u003e",
          "module": "Math.LinearRecursive.Monad",
          "name": "getStep",
          "package": "monad-lrs",
          "signature": "LinearRecursive a (LinearCombination a)",
          "source": "src/Math-LinearRecursive-Monad.html#getStep",
          "type": "function"
        },
        "index": {
          "description": "return the current step number Use two extra variables map runLinearRecursive getStep",
          "hierarchy": "Math LinearRecursive Monad",
          "module": "Math.LinearRecursive.Monad",
          "name": "getStep",
          "package": "monad-lrs",
          "partial": "Step",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/monad-lrs/docs/Math-LinearRecursive-Monad.html#v:getStep"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDeclare a new variable, with its initial value (the value before step 0).\n\u003c/p\u003e\u003cpre\u003etest = do\n    v \u003c- newVariable 1\n    v \u003c:- v \u003c+\u003e v\n    return v\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003emap (runLinearRecursive test) [0..10]\n\u003c/code\u003e\u003c/strong\u003e[1,2,4,8,16,32,64,128,256,512,1024]\n\u003c/pre\u003e",
          "module": "Math.LinearRecursive.Monad",
          "name": "newVariable",
          "package": "monad-lrs",
          "signature": "a -\u003e LinearRecursive a (Variable a)",
          "source": "src/Math-LinearRecursive-Monad.html#newVariable",
          "type": "function"
        },
        "index": {
          "description": "Declare new variable with its initial value the value before step test do newVariable return map runLinearRecursive test",
          "hierarchy": "Math LinearRecursive Monad",
          "module": "Math.LinearRecursive.Monad",
          "name": "newVariable",
          "normalized": "a-\u003eLinearRecursive a(Variable a)",
          "package": "monad-lrs",
          "partial": "Variable",
          "signature": "a-\u003eLinearRecursive a(Variable a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/monad-lrs/docs/Math-LinearRecursive-Monad.html#v:newVariable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDeclare a new sequence, with their initial value.\n\u003c/p\u003e\u003cp\u003eAfter each step, each variable except the first one will be assigned with\n the value of its predecessor variable before this turn. \n\u003c/p\u003e\u003cp\u003eIt's not encouraged to assign any value to the variables other \n than the first one.\n\u003c/p\u003e\u003cpre\u003etest = do\n     [v1, v2, v3] \u003c- newVariables [1,2,3]\n     v1 \u003c:- v3\n     return v3\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003emap (runLinearRecursive test) [0..10]\n\u003c/code\u003e\u003c/strong\u003e[3,2,1,3,2,1,3,2,1,3,2]\n\u003c/pre\u003e",
          "module": "Math.LinearRecursive.Monad",
          "name": "newVariables",
          "package": "monad-lrs",
          "signature": "[a] -\u003e LinearRecursive a [Variable a]",
          "source": "src/Math-LinearRecursive-Monad.html#newVariables",
          "type": "function"
        },
        "index": {
          "description": "Declare new sequence with their initial value After each step each variable except the first one will be assigned with the value of its predecessor variable before this turn It not encouraged to assign any value to the variables other than the first one test do v1 v2 v3 newVariables v1 v3 return v3 map runLinearRecursive test",
          "hierarchy": "Math LinearRecursive Monad",
          "module": "Math.LinearRecursive.Monad",
          "name": "newVariables",
          "normalized": "[a]-\u003eLinearRecursive a[Variable a]",
          "package": "monad-lrs",
          "partial": "Variables",
          "signature": "[a]-\u003eLinearRecursive a[Variable a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/monad-lrs/docs/Math-LinearRecursive-Monad.html#v:newVariables"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(v^3 * log n)\u003c/em\u003e, where \u003cem\u003ev\u003c/em\u003e is the number of variables, and \u003cem\u003en\u003c/em\u003e is steps to simulate.\n\u003c/p\u003e\u003cp\u003e\u003ccode\u003erunLinearRecursive m n\u003c/code\u003e simulate the monad by \u003ccode\u003en\u003c/code\u003e steps, and return the actual value denoted\n by returned \u003ccode\u003e\u003ca\u003eLinearCombination\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003en must be non-negative.\n\u003c/p\u003e",
          "module": "Math.LinearRecursive.Monad",
          "name": "runLinearRecursive",
          "package": "monad-lrs",
          "signature": "LinearRecursive a (v a) -\u003e b -\u003e a",
          "source": "src/Math-LinearRecursive-Monad.html#runLinearRecursive",
          "type": "function"
        },
        "index": {
          "description": "log where is the number of variables and is steps to simulate runLinearRecursive simulate the monad by steps and return the actual value denoted by returned LinearCombination must be non-negative",
          "hierarchy": "Math LinearRecursive Monad",
          "module": "Math.LinearRecursive.Monad",
          "name": "runLinearRecursive",
          "normalized": "LinearRecursive a(b a)-\u003ec-\u003ea",
          "package": "monad-lrs",
          "partial": "Linear Recursive",
          "signature": "LinearRecursive a(v a)-\u003eb-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/monad-lrs/docs/Math-LinearRecursive-Monad.html#v:runLinearRecursive"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(v^2 * n)\u003c/em\u003e. similar to \u003ccode\u003erunLinearRecursive\u003c/code\u003e, but return an infinite list instead of a particular index.\n\u003c/p\u003e",
          "module": "Math.LinearRecursive.Monad",
          "name": "simulateLinearRecursive",
          "package": "monad-lrs",
          "signature": "LinearRecursive a (v a) -\u003e [a]",
          "source": "src/Math-LinearRecursive-Monad.html#simulateLinearRecursive",
          "type": "function"
        },
        "index": {
          "description": "similar to runLinearRecursive but return an infinite list instead of particular index",
          "hierarchy": "Math LinearRecursive Monad",
          "module": "Math.LinearRecursive.Monad",
          "name": "simulateLinearRecursive",
          "normalized": "LinearRecursive a(b a)-\u003e[a]",
          "package": "monad-lrs",
          "partial": "Linear Recursive",
          "signature": "LinearRecursive a(v a)-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/monad-lrs/docs/Math-LinearRecursive-Monad.html#v:simulateLinearRecursive"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.LinearRecursive.Monad",
          "name": "toVector",
          "package": "monad-lrs",
          "signature": "v a -\u003e Vector a",
          "source": "src/Math-LinearRecursive-Internal-Vector.html#toVector",
          "type": "method"
        },
        "index": {
          "hierarchy": "Math LinearRecursive Monad",
          "module": "Math.LinearRecursive.Monad",
          "name": "toVector",
          "normalized": "a b-\u003eVector b",
          "package": "monad-lrs",
          "partial": "Vector",
          "signature": "v a-\u003eVector a",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/monad-lrs/docs/Math-LinearRecursive-Monad.html#v:toVector"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.LinearRecursive.Monad",
          "name": "x",
          "package": "monad-lrs",
          "signature": "Polynomial a",
          "source": "src/Math-LinearRecursive-Internal-Polynomial.html#x",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math LinearRecursive Monad",
          "module": "Math.LinearRecursive.Monad",
          "name": "x",
          "package": "monad-lrs",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/monad-lrs/docs/Math-LinearRecursive-Monad.html#v:x"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe zero vector.\n\u003c/p\u003e",
          "module": "Math.LinearRecursive.Monad",
          "name": "zeroVector",
          "package": "monad-lrs",
          "signature": "Vector a",
          "source": "src/Math-LinearRecursive-Internal-Vector.html#zeroVector",
          "type": "function"
        },
        "index": {
          "description": "The zero vector",
          "hierarchy": "Math LinearRecursive Monad",
          "module": "Math.LinearRecursive.Monad",
          "name": "zeroVector",
          "package": "monad-lrs",
          "partial": "Vector",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/monad-lrs/docs/Math-LinearRecursive-Monad.html#v:zeroVector"
      }
    }
  ]
]